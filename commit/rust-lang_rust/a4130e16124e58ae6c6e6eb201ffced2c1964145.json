{"sha": "a4130e16124e58ae6c6e6eb201ffced2c1964145", "node_id": "C_kwDOAAsO6NoAKGE0MTMwZTE2MTI0ZTU4YWU2YzZlNmViMjAxZmZjZWQyYzE5NjQxNDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T18:09:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T18:09:26Z"}, "message": "Auto merge of #8355 - Jarcho:explicit_auto_deref_2, r=flip1995\n\nAdd lint `explicit_auto_deref` take 2\n\nfixes: #234\nfixes: #8367\nfixes: #8380\n\nStill things to do:\n\n* ~~This currently only lints `&*<expr>` when it doesn't trigger `needless_borrow`.~~\n* ~~This requires a borrow after a deref to trigger. So `*<expr>` changing `&&T` to `&T` won't be caught.~~\n* The `deref` and `deref_mut` trait methods aren't linted.\n* Neither ~~field accesses~~, nor method receivers are linted.\n* ~~This probably shouldn't lint reborrowing.~~\n* Full slicing to deref should probably be handled here as well. e.g. `&vec[..]` when just `&vec` would do\n\nchangelog: new lint `explicit_auto_deref`", "tree": {"sha": "5c05b6ac518cc058976e2120af332453606dfdc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c05b6ac518cc058976e2120af332453606dfdc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4130e16124e58ae6c6e6eb201ffced2c1964145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4130e16124e58ae6c6e6eb201ffced2c1964145", "html_url": "https://github.com/rust-lang/rust/commit/a4130e16124e58ae6c6e6eb201ffced2c1964145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4130e16124e58ae6c6e6eb201ffced2c1964145/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23c6765276c968bf0fe4ee01f619f357b78390ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/23c6765276c968bf0fe4ee01f619f357b78390ca", "html_url": "https://github.com/rust-lang/rust/commit/23c6765276c968bf0fe4ee01f619f357b78390ca"}, {"sha": "5e2a2d3ac993cc6b89e561e69b4571d95d0f7627", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2a2d3ac993cc6b89e561e69b4571d95d0f7627", "html_url": "https://github.com/rust-lang/rust/commit/5e2a2d3ac993cc6b89e561e69b4571d95d0f7627"}], "stats": {"total": 1833, "additions": 1560, "deletions": 273}, "files": [{"sha": "9bc93c1cb42c91ad045e77c9a5c88f83abdf095b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -3400,6 +3400,7 @@ Released 2018-09-13\n [`expect_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_fun_call\n [`expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_used\n [`expl_impl_clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#expl_impl_clone_on_copy\n+[`explicit_auto_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_auto_deref\n [`explicit_counter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_counter_loop\n [`explicit_deref_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_deref_methods\n [`explicit_into_iter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_into_iter_loop"}, {"sha": "2e0659f42d7b6b85ea248f4e45a91513c70ed2ca", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -413,7 +413,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n                 .find(\"declare_lint_pass!\")\n                 .unwrap_or_else(|| panic!(\"failed to find `impl_lint_pass`\"))\n         });\n-        let mut impl_lint_pass_end = (&content[impl_lint_pass_start..])\n+        let mut impl_lint_pass_end = content[impl_lint_pass_start..]\n             .find(']')\n             .expect(\"failed to find `impl_lint_pass` terminator\");\n "}, {"sha": "59dcc1ebf191f9a926ea8844f89fb8498300ae0b", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 547, "deletions": 150, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,20 +1,24 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n+use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n+use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node,\n-    Pat, PatKind, UnOp,\n+    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, GenericArg, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    TraitItemKind, TyKind, UnOp,\n };\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -104,10 +108,34 @@ declare_clippy_lint! {\n     \"`ref` binding to a reference\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for dereferencing expressions which would be covered by auto-deref.\n+    ///\n+    /// ### Why is this bad?\n+    /// This unnecessarily complicates the code.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &*x;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &x;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub EXPLICIT_AUTO_DEREF,\n+    complexity,\n+    \"dereferencing when the compiler would automatically dereference\"\n+}\n+\n impl_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS,\n     NEEDLESS_BORROW,\n     REF_BINDING_TO_REFERENCE,\n+    EXPLICIT_AUTO_DEREF,\n ]);\n \n #[derive(Default)]\n@@ -136,6 +164,12 @@ struct StateData {\n     /// Span of the top level expression\n     span: Span,\n     hir_id: HirId,\n+    position: Position,\n+}\n+\n+struct DerefedBorrow {\n+    count: usize,\n+    msg: &'static str,\n }\n \n enum State {\n@@ -147,11 +181,19 @@ enum State {\n         /// The required mutability\n         target_mut: Mutability,\n     },\n-    DerefedBorrow {\n-        count: usize,\n-        required_precedence: i8,\n-        msg: &'static str,\n+    DerefedBorrow(DerefedBorrow),\n+    ExplicitDeref {\n+        // Span and id of the top-level deref expression if the parent expression is a borrow.\n+        deref_span_id: Option<(Span, HirId)>,\n+    },\n+    ExplicitDerefField {\n+        name: Symbol,\n     },\n+    Reborrow {\n+        deref_span: Span,\n+        deref_hir_id: HirId,\n+    },\n+    Borrow,\n }\n \n // A reference operation considered by this lint pass\n@@ -207,13 +249,28 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n \n         match (self.state.take(), kind) {\n             (None, kind) => {\n-                let parent = get_parent_node(cx.tcx, expr.hir_id);\n                 let expr_ty = typeck.expr_ty(expr);\n+                let (position, adjustments) = walk_parents(cx, expr);\n \n                 match kind {\n+                    RefOp::Deref => {\n+                        if let Position::FieldAccess(name) = position\n+                            && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n+                        {\n+                            self.state = Some((\n+                                State::ExplicitDerefField { name },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        } else if position.is_deref_stable() {\n+                            self.state = Some((\n+                                State::ExplicitDeref { deref_span_id: None },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        }\n+                    }\n                     RefOp::Method(target_mut)\n                         if !is_lint_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n-                            && is_linted_explicit_deref_position(parent, expr.hir_id, expr.span) =>\n+                            && position.lint_explicit_deref() =>\n                     {\n                         self.state = Some((\n                             State::DerefMethod {\n@@ -228,12 +285,13 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             StateData {\n                                 span: expr.span,\n                                 hir_id: expr.hir_id,\n+                                position\n                             },\n                         ));\n                     },\n                     RefOp::AddrOf => {\n                         // Find the number of times the borrow is auto-derefed.\n-                        let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n+                        let mut iter = adjustments.iter();\n                         let mut deref_count = 0usize;\n                         let next_adjust = loop {\n                             match iter.next() {\n@@ -274,40 +332,43 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n \n-                        let (required_refs, required_precedence, msg) = if is_auto_borrow_position(parent, expr.hir_id)\n-                        {\n-                            (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n-                            if matches!(mutability, AutoBorrowMutability::Mut { .. })\n-                                && !is_auto_reborrow_position(parent)\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, 0, deref_msg)\n+                                (3, deref_msg)\n                             } else {\n-                                (2, 0, deref_msg)\n+                                (2, deref_msg)\n                             }\n                         } else {\n-                            (2, 0, deref_msg)\n+                            (2, deref_msg)\n                         };\n \n                         if deref_count >= required_refs {\n                             self.state = Some((\n-                                State::DerefedBorrow {\n+                                State::DerefedBorrow(DerefedBorrow {\n                                     // One of the required refs is for the current borrow expression, the remaining ones\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n-                                    required_precedence,\n                                     msg,\n-                                },\n+                                }),\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        } else if position.is_deref_stable() {\n+                            self.state = Some((\n+                                State::Borrow,\n                                 StateData {\n                                     span: expr.span,\n                                     hir_id: expr.hir_id,\n+                                    position\n                                 },\n                             ));\n                         }\n                     },\n-                    _ => (),\n+                    RefOp::Method(..) => (),\n                 }\n             },\n             (\n@@ -334,26 +395,90 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) if state.count != 0 => {\n+                self.state = Some((\n+                    State::DerefedBorrow(DerefedBorrow {\n+                        count: state.count - 1,\n+                        ..state\n+                    }),\n+                    data,\n+                ));\n+            },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n+                let position = data.position;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if position.is_deref_stable() {\n+                    self.state = Some((\n+                        State::Borrow,\n+                        StateData {\n+                            span: expr.span,\n+                            hir_id: expr.hir_id,\n+                            position,\n+                        },\n+                    ));\n+                }\n+            },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n+                let position = data.position;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if let Position::FieldAccess(name) = position\n+                    && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n+                {\n+                    self.state = Some((\n+                        State::ExplicitDerefField { name },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                    ));\n+                } else if position.is_deref_stable() {\n+                    self.state = Some((\n+                        State::ExplicitDeref { deref_span_id: None },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                    ));\n+                }\n+            },\n+\n+            (Some((State::Borrow, data)), RefOp::Deref) => {\n+                if typeck.expr_ty(sub_expr).is_ref() {\n+                    self.state = Some((\n+                        State::Reborrow {\n+                            deref_span: expr.span,\n+                            deref_hir_id: expr.hir_id,\n+                        },\n+                        data,\n+                    ));\n+                } else {\n+                    self.state = Some((\n+                        State::ExplicitDeref {\n+                            deref_span_id: Some((expr.span, expr.hir_id)),\n+                        },\n+                        data,\n+                    ));\n+                }\n+            },\n             (\n                 Some((\n-                    State::DerefedBorrow {\n-                        count,\n-                        required_precedence,\n-                        msg,\n+                    State::Reborrow {\n+                        deref_span,\n+                        deref_hir_id,\n                     },\n                     data,\n                 )),\n-                RefOp::AddrOf,\n-            ) if count != 0 => {\n+                RefOp::Deref,\n+            ) => {\n                 self.state = Some((\n-                    State::DerefedBorrow {\n-                        count: count - 1,\n-                        required_precedence,\n-                        msg,\n+                    State::ExplicitDeref {\n+                        deref_span_id: Some((deref_span, deref_hir_id)),\n                     },\n                     data,\n                 ));\n             },\n+            (state @ Some((State::ExplicitDeref { .. }, _)), RefOp::Deref) => {\n+                self.state = state;\n+            },\n+            (Some((State::ExplicitDerefField { name }, data)), RefOp::Deref)\n+                if !ty_contains_field(typeck.expr_ty(sub_expr), name) =>\n+            {\n+                self.state = Some((State::ExplicitDerefField { name }, data));\n+            },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n@@ -473,131 +598,362 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Checks whether the parent node is a suitable context for switching from a deref method to the\n-// deref operator.\n-fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId, child_span: Span) -> bool {\n-    let parent = match parent {\n-        Some(Node::Expr(e)) if e.span.ctxt() == child_span.ctxt() => e,\n-        _ => return true,\n-    };\n-    match parent.kind {\n-        // Leave deref calls in the middle of a method chain.\n-        // e.g. x.deref().foo()\n-        ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n-\n-        // Leave deref calls resulting in a called function\n-        // e.g. (x.deref())()\n-        ExprKind::Call(func_expr, _) if func_expr.hir_id == child_id => false,\n-\n-        // Makes an ugly suggestion\n-        // e.g. *x.deref() => *&*x\n-        ExprKind::Unary(UnOp::Deref, _)\n-        // Postfix expressions would require parens\n-        | ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n-        | ExprKind::Field(..)\n-        | ExprKind::Index(..)\n-        | ExprKind::Err => false,\n-\n-        ExprKind::Box(..)\n-        | ExprKind::ConstBlock(..)\n-        | ExprKind::Array(_)\n-        | ExprKind::Call(..)\n-        | ExprKind::MethodCall(..)\n-        | ExprKind::Tup(..)\n-        | ExprKind::Binary(..)\n-        | ExprKind::Unary(..)\n-        | ExprKind::Lit(..)\n-        | ExprKind::Cast(..)\n-        | ExprKind::Type(..)\n-        | ExprKind::DropTemps(..)\n-        | ExprKind::If(..)\n-        | ExprKind::Loop(..)\n-        | ExprKind::Match(..)\n-        | ExprKind::Let(..)\n-        | ExprKind::Closure{..}\n-        | ExprKind::Block(..)\n-        | ExprKind::Assign(..)\n-        | ExprKind::AssignOp(..)\n-        | ExprKind::Path(..)\n-        | ExprKind::AddrOf(..)\n-        | ExprKind::Break(..)\n-        | ExprKind::Continue(..)\n-        | ExprKind::Ret(..)\n-        | ExprKind::InlineAsm(..)\n-        | ExprKind::Struct(..)\n-        | ExprKind::Repeat(..)\n-        | ExprKind::Yield(..) => true,\n-    }\n+/// The position of an expression relative to it's parent.\n+#[derive(Clone, Copy)]\n+enum Position {\n+    MethodReceiver,\n+    /// The method is defined on a reference type. e.g. `impl Foo for &T`\n+    MethodReceiverRefImpl,\n+    Callee,\n+    FieldAccess(Symbol),\n+    Postfix,\n+    Deref,\n+    /// Any other location which will trigger auto-deref to a specific time.\n+    DerefStable(i8),\n+    /// Any other location which will trigger auto-reborrowing.\n+    ReborrowStable(i8),\n+    Other(i8),\n }\n+impl Position {\n+    fn is_deref_stable(self) -> bool {\n+        matches!(self, Self::DerefStable(_))\n+    }\n \n-/// Checks if the given expression is in a position which can be auto-reborrowed.\n-/// Note: This is only correct assuming auto-deref is already occurring.\n-fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n-    match parent {\n-        Some(Node::Expr(parent)) => matches!(parent.kind, ExprKind::MethodCall(..) | ExprKind::Call(..)),\n-        Some(Node::Local(_)) => true,\n-        _ => false,\n+    fn is_reborrow_stable(self) -> bool {\n+        matches!(self, Self::DerefStable(_) | Self::ReborrowStable(_))\n     }\n-}\n \n-/// Checks if the given expression is a position which can auto-borrow.\n-fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n-    if let Some(Node::Expr(parent)) = parent {\n-        match parent.kind {\n-            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n-            ExprKind::Field(..) => true,\n-            ExprKind::Call(f, _) => f.hir_id == child_id,\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    fn can_auto_borrow(self) -> bool {\n+        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n-}\n \n-/// Adjustments are sometimes made in the parent block rather than the expression itself.\n-fn find_adjustments<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    typeck: &'tcx TypeckResults<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n-) -> &'tcx [Adjustment<'tcx>] {\n-    let map = tcx.hir();\n-    let mut iter = map.parent_iter(expr.hir_id);\n-    let mut prev = expr;\n+    fn lint_explicit_deref(self) -> bool {\n+        matches!(self, Self::Other(_) | Self::DerefStable(_) | Self::ReborrowStable(_))\n+    }\n \n-    loop {\n-        match typeck.expr_adjustments(prev) {\n-            [] => (),\n-            a => break a,\n-        };\n+    fn precedence(self) -> i8 {\n+        match self {\n+            Self::MethodReceiver\n+            | Self::MethodReceiverRefImpl\n+            | Self::Callee\n+            | Self::FieldAccess(_)\n+            | Self::Postfix => PREC_POSTFIX,\n+            Self::Deref => PREC_PREFIX,\n+            Self::DerefStable(p) | Self::ReborrowStable(p) | Self::Other(p) => p,\n+        }\n+    }\n+}\n \n-        match iter.next().map(|(_, x)| x) {\n-            Some(Node::Block(_)) => {\n-                if let Some((_, Node::Expr(e))) = iter.next() {\n-                    prev = e;\n+/// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n+/// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n+/// locations as those follow different rules.\n+#[allow(clippy::too_many_lines)]\n+fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n+    let mut adjustments = [].as_slice();\n+    let mut precedence = 0i8;\n+    let ctxt = e.span.ctxt();\n+    let position = walk_to_expr_usage(cx, e, &mut |parent, child_id| {\n+        // LocalTableInContext returns the wrong lifetime, so go use `expr_adjustments` instead.\n+        if adjustments.is_empty() && let Node::Expr(e) = cx.tcx.hir().get(child_id) {\n+            adjustments = cx.typeck_results().expr_adjustments(e);\n+        }\n+        match parent {\n+            Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n+                Some(binding_ty_auto_deref_stability(ty, precedence))\n+            },\n+            Node::Item(&Item {\n+                kind: ItemKind::Static(..) | ItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            }) if span.ctxt() == ctxt => {\n+                let ty = cx.tcx.type_of(def_id);\n+                Some(if ty.is_ref() {\n+                    Position::DerefStable(precedence)\n                 } else {\n-                    // This shouldn't happen. Blocks are always contained in an expression.\n-                    break &[];\n-                }\n+                    Position::Other(precedence)\n+                })\n             },\n-            Some(Node::Expr(&Expr {\n-                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+\n+            Node::Item(&Item {\n+                kind: ItemKind::Fn(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(..),\n+                def_id,\n+                span,\n                 ..\n-            })) => {\n-                if let Some(Node::Expr(e)) = map.find(id) {\n-                    prev = e;\n-                    iter = map.parent_iter(id);\n+            }) if span.ctxt() == ctxt => {\n+                let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n+                Some(if !output.is_ref() {\n+                    Position::Other(precedence)\n+                } else if output.has_placeholders() || output.has_opaque_types() {\n+                    Position::ReborrowStable(precedence)\n+                } else {\n+                    Position::DerefStable(precedence)\n+                })\n+            },\n+\n+            Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n+                ExprKind::Ret(_) => {\n+                    let output = cx\n+                        .tcx\n+                        .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n+                        .skip_binder()\n+                        .output();\n+                    Some(if !output.is_ref() {\n+                        Position::Other(precedence)\n+                    } else if output.has_placeholders() || output.has_opaque_types() {\n+                        Position::ReborrowStable(precedence)\n+                    } else {\n+                        Position::DerefStable(precedence)\n+                    })\n+                },\n+                ExprKind::Call(func, _) if func.hir_id == child_id => (child_id == e.hir_id).then(|| Position::Callee),\n+                ExprKind::Call(func, args) => args\n+                    .iter()\n+                    .position(|arg| arg.hir_id == child_id)\n+                    .zip(expr_sig(cx, func))\n+                    .and_then(|(i, sig)| sig.input_with_hir(i))\n+                    .map(|(hir_ty, ty)| match hir_ty {\n+                        // Type inference for closures can depend on how they're called. Only go by the explicit\n+                        // types here.\n+                        Some(ty) => binding_ty_auto_deref_stability(ty, precedence),\n+                        None => param_auto_deref_stability(ty.skip_binder(), precedence),\n+                    }),\n+                ExprKind::MethodCall(_, args, _) => {\n+                    let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n+                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n+                        if i == 0 {\n+                            // Check for calls to trait methods where the trait is implemented on a reference.\n+                            // Two cases need to be handled:\n+                            // * `self` methods on `&T` will never have auto-borrow\n+                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                            //   priority.\n+                            if e.hir_id != child_id {\n+                                Position::ReborrowStable(precedence)\n+                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                                && let subs = cx.typeck_results().node_substs_opt(child_id).unwrap_or_else(\n+                                    || cx.tcx.mk_substs([].iter())\n+                                ) && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                    // Trait methods taking `&self`\n+                                    sub_ty\n+                                } else {\n+                                    // Trait methods taking `self`\n+                                    arg_ty\n+                                } && impl_ty.is_ref()\n+                                && cx.tcx.infer_ctxt().enter(|infcx|\n+                                    infcx\n+                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                        .must_apply_modulo_regions()\n+                                )\n+                            {\n+                                Position::MethodReceiverRefImpl\n+                            } else {\n+                                Position::MethodReceiver\n+                            }\n+                        } else {\n+                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i], precedence)\n+                        }\n+                    })\n+                },\n+                ExprKind::Struct(path, fields, _) => {\n+                    let variant = variant_of_res(cx, cx.qpath_res(path, parent.hir_id));\n+                    fields\n+                        .iter()\n+                        .find(|f| f.expr.hir_id == child_id)\n+                        .zip(variant)\n+                        .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n+                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did), precedence))\n+                },\n+                ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n+                ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n+                ExprKind::Match(child, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+                | ExprKind::Index(child, _)\n+                    if child.hir_id == e.hir_id =>\n+                {\n+                    Some(Position::Postfix)\n+                },\n+                _ if child_id == e.hir_id => {\n+                    precedence = parent.precedence().order();\n+                    None\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    })\n+    .unwrap_or(Position::Other(precedence));\n+    (position, adjustments)\n+}\n+\n+// Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n+//\n+// e.g.\n+// let x = Box::new(Box::new(0u32));\n+// let y1: &Box<_> = x.deref();\n+// let y2: &Box<_> = &x;\n+//\n+// Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n+// switching to auto-dereferencing.\n+fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position {\n+    let TyKind::Rptr(_, ty) = &ty.kind else {\n+        return Position::Other(precedence);\n+    };\n+    let mut ty = ty;\n+\n+    loop {\n+        break match ty.ty.kind {\n+            TyKind::Rptr(_, ref ref_ty) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            TyKind::Path(\n+                QPath::TypeRelative(_, path)\n+                | QPath::Resolved(\n+                    _,\n+                    Path {\n+                        segments: [.., path], ..\n+                    },\n+                ),\n+            ) => {\n+                if let Some(args) = path.args\n+                    && args.args.iter().any(|arg| match arg {\n+                        GenericArg::Infer(_) => true,\n+                        GenericArg::Type(ty) => ty_contains_infer(ty),\n+                        _ => false,\n+                    })\n+                {\n+                    Position::ReborrowStable(precedence)\n                 } else {\n-                    // This shouldn't happen. The destination should exist.\n-                    break &[];\n+                    Position::DerefStable(precedence)\n                 }\n             },\n-            _ => break &[],\n+            TyKind::Slice(_)\n+            | TyKind::Array(..)\n+            | TyKind::BareFn(_)\n+            | TyKind::Never\n+            | TyKind::Tup(_)\n+            | TyKind::Ptr(_)\n+            | TyKind::TraitObject(..)\n+            | TyKind::Path(_) => Position::DerefStable(precedence),\n+            TyKind::OpaqueDef(..)\n+            | TyKind::Infer\n+            | TyKind::Typeof(..)\n+            | TyKind::Err => Position::ReborrowStable(precedence),\n+        };\n+    }\n+}\n+\n+// Checks whether a type is inferred at some point.\n+// e.g. `_`, `Box<_>`, `[_]`\n+fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n+    struct V(bool);\n+    impl Visitor<'_> for V {\n+        fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+            if self.0\n+                || matches!(\n+                    ty.kind,\n+                    TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err\n+                )\n+            {\n+                self.0 = true;\n+            } else {\n+                walk_ty(self, ty);\n+            }\n         }\n+\n+        fn visit_generic_arg(&mut self, arg: &GenericArg<'_>) {\n+            if self.0 || matches!(arg, GenericArg::Infer(_)) {\n+                self.0 = true;\n+            } else if let GenericArg::Type(ty) = arg {\n+                self.visit_ty(ty);\n+            }\n+        }\n+    }\n+    let mut v = V(false);\n+    v.visit_ty(ty);\n+    v.0\n+}\n+\n+// Checks whether a type is stable when switching to auto dereferencing,\n+fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n+    let ty::Ref(_, mut ty, _) = *ty.kind() else {\n+        return Position::Other(precedence);\n+    };\n+\n+    loop {\n+        break match *ty.kind() {\n+            ty::Ref(_, ref_ty, _) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            ty::Infer(_)\n+            | ty::Error(_)\n+            | ty::Param(_)\n+            | ty::Bound(..)\n+            | ty::Opaque(..)\n+            | ty::Placeholder(_)\n+            | ty::Dynamic(..) => Position::ReborrowStable(precedence),\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => {\n+                Position::ReborrowStable(precedence)\n+            },\n+            ty::Adt(..)\n+            | ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Projection(_) => Position::DerefStable(precedence),\n+        };\n+    }\n+}\n+\n+fn ty_contains_field(ty: Ty<'_>, name: Symbol) -> bool {\n+    if let ty::Adt(adt, _) = *ty.kind() {\n+        adt.is_struct() && adt.all_fields().any(|f| f.name == name)\n+    } else {\n+        false\n     }\n }\n \n-#[expect(clippy::needless_pass_by_value)]\n-fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: StateData) {\n+#[expect(clippy::needless_pass_by_value, clippy::too_many_lines)]\n+fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n     match state {\n         State::DerefMethod {\n             ty_changed_count,\n@@ -647,22 +1003,63 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: S\n                 app,\n             );\n         },\n-        State::DerefedBorrow {\n-            required_precedence,\n-            msg,\n-            ..\n-        } => {\n+        State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n-            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, msg, |diag| {\n-                let sugg = if required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n+                let sugg = if !snip_is_macro\n+                    && expr.precedence().order() < data.position.precedence()\n+                    && !has_enclosing_paren(&snip)\n+                {\n                     format!(\"({})\", snip)\n                 } else {\n                     snip.into()\n                 };\n                 diag.span_suggestion(data.span, \"change this to\", sugg, app);\n             });\n         },\n+        State::ExplicitDeref { deref_span_id } => {\n+            let (span, hir_id, precedence) = if let Some((span, hir_id)) = deref_span_id\n+                && !cx.typeck_results().expr_ty(expr).is_ref()\n+            {\n+                (span, hir_id, PREC_PREFIX)\n+            } else {\n+                (data.span, data.hir_id, data.position.precedence())\n+            };\n+            span_lint_hir_and_then(\n+                cx,\n+                EXPLICIT_AUTO_DEREF,\n+                hir_id,\n+                span,\n+                \"deref which would be done by auto-deref\",\n+                |diag| {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app);\n+                    let sugg =\n+                        if !snip_is_macro && expr.precedence().order() < precedence && !has_enclosing_paren(&snip) {\n+                            format!(\"({})\", snip)\n+                        } else {\n+                            snip.into()\n+                        };\n+                    diag.span_suggestion(span, \"try this\", sugg, app);\n+                },\n+            );\n+        },\n+        State::ExplicitDerefField { .. } => {\n+            span_lint_hir_and_then(\n+                cx,\n+                EXPLICIT_AUTO_DEREF,\n+                data.hir_id,\n+                data.span,\n+                \"deref which would be done by auto-deref\",\n+                |diag| {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n+                    diag.span_suggestion(data.span, \"try this\", snip.into_owned(), app);\n+                },\n+            );\n+        },\n+        State::Borrow | State::Reborrow { .. } => (),\n     }\n }\n "}, {"sha": "563ad891603a7b74882191c203f72da3fedf2c34", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -39,6 +39,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),"}, {"sha": "3784d3c68dceef2046f01b4f2a0393004867e35a", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -9,6 +9,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(explicit_write::EXPLICIT_WRITE),"}, {"sha": "d3c75f8b519107654df8d992bb677017deb594a1", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -104,6 +104,7 @@ store.register_lints(&[\n     default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n     default_union_representation::DEFAULT_UNION_REPRESENTATION,\n+    dereference::EXPLICIT_AUTO_DEREF,\n     dereference::EXPLICIT_DEREF_METHODS,\n     dereference::NEEDLESS_BORROW,\n     dereference::REF_BINDING_TO_REFERENCE,"}, {"sha": "15513de7d860d90dda22a8b7acaf4fcd5c8ec0be", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -285,7 +285,7 @@ impl<'a> NormalizedPat<'a> {\n                 // TODO: Handle negative integers. They're currently treated as a wild match.\n                 ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n-                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),"}, {"sha": "5ae4a65acaf33f9bb2dc94423b02579aa12ee39e", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         cx,\n                         (ex, expr),\n                         (bind_names, matched_vars),\n-                        &*snippet_body,\n+                        &snippet_body,\n                         &mut applicability,\n                         Some(span),\n                     );\n@@ -88,7 +88,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         cx,\n                         (ex, expr),\n                         (bind_names, matched_vars),\n-                        &*snippet_body,\n+                        &snippet_body,\n                         &mut applicability,\n                         None,\n                     );"}, {"sha": "fa3b8d1fceaaccb582e4c560ab4788d9828a26bc", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -118,7 +118,7 @@ fn lint(cx: &LateContext<'_>, case_method: &CaseMethod, bad_case_span: Span, bad\n         MATCH_STR_CASE_MISMATCH,\n         bad_case_span,\n         \"this `match` arm has a differing case than its expression\",\n-        &*format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n+        &format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n         format!(\"\\\"{}\\\"\", suggestion),\n         Applicability::MachineApplicable,\n     );"}, {"sha": "65cecd333f1ce6c090e8082ea46de21a2d2c6988", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -362,9 +362,9 @@ fn find_good_method_for_match<'a>(\n         .qpath_res(path_right, arms[1].pat.hir_id)\n         .opt_def_id()?;\n     let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        (&arms[0].body.kind, &arms[1].body.kind)\n     } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        (&arms[1].body.kind, &arms[0].body.kind)\n     } else {\n         return None;\n     };"}, {"sha": "b96af06b8d7c69a63c5c177970b322f6f98d01fa", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         // add the pattern after the expression because the bindings aren't available\n         // yet in the init\n         // expression\n-        SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n+        SimilarNamesNameVisitor(self).visit_pat(&local.pat);\n     }\n     fn visit_block(&mut self, blk: &'tcx Block) {\n         self.single_char_names.push(vec![]);"}, {"sha": "5678b8f6ca68ee96cdb802bc329bff1297364bda", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -574,14 +574,13 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                 Some((Node::Expr(e), child_id)) => match e.kind {\n                     ExprKind::Call(f, expr_args) => {\n                         let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n-                        if expr_sig(self.cx, f)\n-                            .map(|sig| sig.input(i).skip_binder().peel_refs())\n-                            .map_or(true, |ty| match *ty.kind() {\n+                        if expr_sig(self.cx, f).and_then(|sig| sig.input(i)).map_or(true, |ty| {\n+                            match *ty.skip_binder().peel_refs().kind() {\n                                 ty::Param(_) => true,\n                                 ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n-                            })\n-                        {\n+                            }\n+                        }) {\n                             // Passed to a function taking the non-dereferenced type.\n                             set_skip_flag();\n                         }"}, {"sha": "f8801f769e83d6cc2dddd94abac1f4bbc2f10da8", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -87,7 +87,7 @@ impl RedundantStaticLifetimes {\n                         _ => {},\n                     }\n                 }\n-                self.visit_type(&*borrow_type.ty, cx, reason);\n+                self.visit_type(&borrow_type.ty, cx, reason);\n             },\n             _ => {},\n         }"}, {"sha": "a2772edf73836bcd8439381cda6bac25167ad83c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -2058,6 +2058,21 @@ pub fn peel_hir_expr_refs<'a>(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_hir_ty_refs<'a>(mut ty: &'a hir::Ty<'a>) -> (&'a hir::Ty<'a>, usize) {\n+    let mut count = 0;\n+    loop {\n+        match &ty.kind {\n+            TyKind::Rptr(_, ref_ty) => {\n+                ty = ref_ty.ty;\n+                count += 1;\n+            },\n+            _ => break (ty, count),\n+        }\n+    }\n+}\n+\n /// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n /// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n@@ -2110,7 +2125,7 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n                 }\n             }\n             names.sort_unstable();\n-            f(&*entry.insert(names))\n+            f(entry.insert(names))\n         },\n     }\n }\n@@ -2168,6 +2183,50 @@ pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n             && item.ident.name.as_str().split('_').any(|a| a == \"test\" || a == \"tests\")\n }\n \n+/// Walks the HIR tree from the given expression, up to the node where the value produced by the\n+/// expression is consumed. Calls the function for every node encountered this way until it returns\n+/// `Some`.\n+///\n+/// This allows walking through `if`, `match`, `break`, block expressions to find where the value\n+/// produced by the expression is consumed.\n+pub fn walk_to_expr_usage<'tcx, T>(\n+    cx: &LateContext<'tcx>,\n+    e: &Expr<'tcx>,\n+    mut f: impl FnMut(Node<'tcx>, HirId) -> Option<T>,\n+) -> Option<T> {\n+    let map = cx.tcx.hir();\n+    let mut iter = map.parent_iter(e.hir_id);\n+    let mut child_id = e.hir_id;\n+\n+    while let Some((parent_id, parent)) = iter.next() {\n+        if let Some(x) = f(parent, child_id) {\n+            return Some(x);\n+        }\n+        let parent = match parent {\n+            Node::Expr(e) => e,\n+            Node::Block(Block { expr: Some(body), .. }) | Node::Arm(Arm { body, .. }) if body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            Node::Arm(a) if a.body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            _ => return None,\n+        };\n+        match parent.kind {\n+            ExprKind::If(child, ..) | ExprKind::Match(child, ..) if child.hir_id != child_id => child_id = parent_id,\n+            ExprKind::Break(Destination { target_id: Ok(id), .. }, _) => {\n+                child_id = id;\n+                iter = map.parent_iter(id);\n+            },\n+            ExprKind::Block(..) => child_id = parent_id,\n+            _ => return None,\n+        }\n+    }\n+    None\n+}\n+\n macro_rules! op_utils {\n     ($($name:ident $assign:ident)*) => {\n         /// Binary operation traits like `LangItem::Add`"}, {"sha": "6ca36eed4e654b7c8144a1ce618ad45b43f19944", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 166, "deletions": 72, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -6,16 +6,16 @@ use core::ops::ControlFlow;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, LangItem, TyKind, Unsafety};\n+use rustc_hir::{Expr, FnDecl, LangItem, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, Region, RegionKind, Ty,\n-    TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -502,24 +502,54 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n #[derive(Clone, Copy)]\n pub enum ExprFnSig<'tcx> {\n     Sig(Binder<'tcx, FnSig<'tcx>>),\n-    Closure(Binder<'tcx, FnSig<'tcx>>),\n+    Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n     Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n }\n impl<'tcx> ExprFnSig<'tcx> {\n-    /// Gets the argument type at the given offset.\n-    pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n+    /// Gets the argument type at the given offset. This will return `None` when the index is out of\n+    /// bounds only for variadic functions, otherwise this will panic.\n+    pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) => sig.input(i),\n-            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n-            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_fields()[i]),\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose()\n+                } else {\n+                    Some(sig.input(i))\n+                }\n+            },\n+            Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n+            Self::Trait(inputs, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n+        }\n+    }\n+\n+    /// Gets the argument type at the given offset. For closures this will also get the type as\n+    /// written. This will return `None` when the index is out of bounds only for variadic\n+    /// functions, otherwise this will panic.\n+    pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n+        match self {\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs()\n+                        .map_bound(|inputs| inputs.get(i).copied())\n+                        .transpose()\n+                        .map(|arg| (None, arg))\n+                } else {\n+                    Some((None, sig.input(i)))\n+                }\n+            },\n+            Self::Closure(decl, sig) => Some((\n+                decl.and_then(|decl| decl.inputs.get(i)),\n+                sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n+            )),\n+            Self::Trait(inputs, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n         }\n     }\n \n     /// Gets the result type, if one could be found. Note that the result type of a trait may not be\n     /// specified.\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) | Self::Closure(sig) => Some(sig.output()),\n+            Self::Sig(sig) | Self::Closure(_, sig) => Some(sig.output()),\n             Self::Trait(_, output) => output,\n         }\n     }\n@@ -530,74 +560,123 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n     if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n     } else {\n-        let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n-        match *ty.kind() {\n-            ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n-            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n-            ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n-            ty::Dynamic(bounds, _) => {\n-                let lang_items = cx.tcx.lang_items();\n-                match bounds.principal() {\n-                    Some(bound)\n-                        if Some(bound.def_id()) == lang_items.fn_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_once_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n-                    {\n-                        let output = bounds\n-                            .projection_bounds()\n-                            .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n-                            .map(|p| p.map_bound(|p| p.term.ty().expect(\"return type was a const\")));\n-                        Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n-                    },\n-                    _ => None,\n+        ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n+    }\n+}\n+\n+fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    match *ty.kind() {\n+        ty::Closure(id, subs) => {\n+            let decl = id\n+                .as_local()\n+                .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n+            Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n+        },\n+        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n+        ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+        ty::Dynamic(bounds, _) => {\n+            let lang_items = cx.tcx.lang_items();\n+            match bounds.principal() {\n+                Some(bound)\n+                    if Some(bound.def_id()) == lang_items.fn_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_once_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n+                {\n+                    let output = bounds\n+                        .projection_bounds()\n+                        .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                        .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n+                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                },\n+                _ => None,\n+            }\n+        },\n+        ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n+            Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty)),\n+        },\n+        ty::Param(_) => sig_from_bounds(cx, ty),\n+        _ => None,\n+    }\n+}\n+\n+fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n+\n+    for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+        match pred.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id()))\n+                    && p.self_ty() == ty =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                inputs = Some(pred.kind().rebind(p.trait_ref.substs.type_at(1)));\n             },\n-            ty::Param(_) | ty::Projection(..) => {\n-                let mut inputs = None;\n-                let mut output = None;\n-                let lang_items = cx.tcx.lang_items();\n-\n-                for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n-                    let mut is_input = false;\n-                    if let Some(ty) = pred\n-                        .kind()\n-                        .map_bound(|pred| match pred {\n-                            PredicateKind::Trait(p)\n-                                if (lang_items.fn_trait() == Some(p.def_id())\n-                                    || lang_items.fn_mut_trait() == Some(p.def_id())\n-                                    || lang_items.fn_once_trait() == Some(p.def_id()))\n-                                    && p.self_ty() == ty =>\n-                            {\n-                                is_input = true;\n-                                Some(p.trait_ref.substs.type_at(1))\n-                            },\n-                            PredicateKind::Projection(p)\n-                                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n-                                    && p.projection_ty.self_ty() == ty =>\n-                            {\n-                                is_input = false;\n-                                p.term.ty()\n-                            },\n-                            _ => None,\n-                        })\n-                        .transpose()\n-                    {\n-                        if is_input && inputs.is_none() {\n-                            inputs = Some(ty);\n-                        } else if !is_input && output.is_none() {\n-                            output = Some(ty);\n-                        } else {\n-                            // Multiple different fn trait impls. Is this even allowed?\n-                            return None;\n-                        }\n-                    }\n+            PredicateKind::Projection(p)\n+                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                    && p.projection_ty.self_ty() == ty =>\n+            {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                output = Some(pred.kind().rebind(p.term.ty().unwrap()));\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+}\n \n-                inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n+\n+    for pred in cx\n+        .tcx\n+        .bound_explicit_item_bounds(ty.item_def_id)\n+        .transpose_iter()\n+        .map(|x| x.map_bound(|(p, _)| p))\n+    {\n+        match pred.0.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id())) =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                inputs = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n             },\n-            _ => None,\n+            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                output = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n+            },\n+            _ => (),\n         }\n     }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n }\n \n #[derive(Clone, Copy)]\n@@ -695,3 +774,18 @@ pub fn for_each_top_level_late_bound_region<B>(\n     }\n     ty.visit_with(&mut V { index: 0, f })\n }\n+\n+/// Gets the struct or enum variant from the given `Res`\n+pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n+    match res {\n+        Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n+        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n+        Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n+            let var_id = cx.tcx.parent(id);\n+            Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n+        },\n+        Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n+        _ => None,\n+    }\n+}"}, {"sha": "d4ff1b1566dc613bd50d9c46e1f3c5ccdb4d5b64", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::needless_return,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments,\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_string(_: &String) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+extern \"C\" {\n+    fn var(_: u32, ...);\n+}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&x);\n+        f2(&x);\n+        f3(&x);\n+        f4.callable_str()(&x);\n+        f5(&x);\n+        f6(&x);\n+        f7.callable_str()(&x);\n+        f8.callable_t()(&x);\n+        f9(&x);\n+        f10(&x);\n+        f11.callable_t()(&x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(s);\n+            let _ = Self::S2 { s: s };\n+        }\n+    }\n+    let _ = E1::S1(&s);\n+    let _ = E1::S2 { s: &s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    let ref_s = &s;\n+    let _: &String = &*ref_s; // Don't lint reborrow.\n+    f_string(&*ref_s); // Don't lint reborrow.\n+\n+    struct S5 {\n+        foo: u32,\n+    }\n+    let b = Box::new(Box::new(S5 { foo: 5 }));\n+    let _ = b.foo;\n+    let _ = b.foo;\n+    let _ = b.foo;\n+\n+    struct S6 {\n+        foo: S5,\n+    }\n+    impl core::ops::Deref for S6 {\n+        type Target = S5;\n+        fn deref(&self) -> &Self::Target {\n+            &self.foo\n+        }\n+    }\n+    let s6 = S6 { foo: S5 { foo: 5 } };\n+    let _ = (*s6).foo; // Don't lint. `S6` also has a field named `foo`\n+\n+    let ref_str = &\"foo\";\n+    let _ = f_str(ref_str);\n+    let ref_ref_str = &ref_str;\n+    let _ = f_str(ref_ref_str);\n+\n+    fn _f5(x: &u32) -> u32 {\n+        if true {\n+            *x\n+        } else {\n+            return *x;\n+        }\n+    }\n+\n+    f_str(&&ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&ref_str); // `needless_borrow` will suggest removing only one reference\n+\n+    let x = &&40;\n+    unsafe {\n+        var(0, &**x);\n+    }\n+}"}, {"sha": "99294a7947bf16e8d24939434a085e1384fccbf6", "filename": "tests/ui/explicit_auto_deref.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::needless_return,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments,\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_string(_: &String) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+extern \"C\" {\n+    fn var(_: u32, ...);\n+}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &*s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&*s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&*s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &**b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&*s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        &**x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { &**x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        &**{ x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        &***x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&*x);\n+        f2(&*x);\n+        f3(&*x);\n+        f4.callable_str()(&*x);\n+        f5(&*x);\n+        f6(&*x);\n+        f7.callable_str()(&*x);\n+        f8.callable_t()(&*x);\n+        f9(&*x);\n+        f10(&*x);\n+        f11.callable_t()(&*x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&*s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &*s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(&**s);\n+            let _ = Self::S2 { s: &**s };\n+        }\n+    }\n+    let _ = E1::S1(&*s);\n+    let _ = E1::S2 { s: &*s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    let ref_s = &s;\n+    let _: &String = &*ref_s; // Don't lint reborrow.\n+    f_string(&*ref_s); // Don't lint reborrow.\n+\n+    struct S5 {\n+        foo: u32,\n+    }\n+    let b = Box::new(Box::new(S5 { foo: 5 }));\n+    let _ = b.foo;\n+    let _ = (*b).foo;\n+    let _ = (**b).foo;\n+\n+    struct S6 {\n+        foo: S5,\n+    }\n+    impl core::ops::Deref for S6 {\n+        type Target = S5;\n+        fn deref(&self) -> &Self::Target {\n+            &self.foo\n+        }\n+    }\n+    let s6 = S6 { foo: S5 { foo: 5 } };\n+    let _ = (*s6).foo; // Don't lint. `S6` also has a field named `foo`\n+\n+    let ref_str = &\"foo\";\n+    let _ = f_str(*ref_str);\n+    let ref_ref_str = &ref_str;\n+    let _ = f_str(**ref_ref_str);\n+\n+    fn _f5(x: &u32) -> u32 {\n+        if true {\n+            *x\n+        } else {\n+            return *x;\n+        }\n+    }\n+\n+    f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n+\n+    let x = &&40;\n+    unsafe {\n+        var(0, &**x);\n+    }\n+}"}, {"sha": "55f956e37aed77fb51d97e222658614a9e2ccff6", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -0,0 +1,196 @@\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:69:20\n+   |\n+LL |     let _: &str = &*s;\n+   |                    ^^ help: try this: `s`\n+   |\n+   = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:73:12\n+   |\n+LL |     f_str(&*s);\n+   |            ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:77:14\n+   |\n+LL |     f_str_t(&*s, &*s); // Don't lint second param.\n+   |              ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:80:25\n+   |\n+LL |     let _: &Box<i32> = &**b;\n+   |                         ^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:86:8\n+   |\n+LL |     c(&*s);\n+   |        ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:92:9\n+   |\n+LL |         &**x\n+   |         ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:96:11\n+   |\n+LL |         { &**x }\n+   |           ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:100:9\n+   |\n+LL |         &**{ x }\n+   |         ^^^^^^^^ help: try this: `{ x }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:104:9\n+   |\n+LL |         &***x\n+   |         ^^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:121:13\n+   |\n+LL |         f1(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:122:13\n+   |\n+LL |         f2(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:123:13\n+   |\n+LL |         f3(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:124:28\n+   |\n+LL |         f4.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:125:13\n+   |\n+LL |         f5(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:126:13\n+   |\n+LL |         f6(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:127:28\n+   |\n+LL |         f7.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:128:26\n+   |\n+LL |         f8.callable_t()(&*x);\n+   |                          ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:129:13\n+   |\n+LL |         f9(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:130:14\n+   |\n+LL |         f10(&*x);\n+   |              ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:131:27\n+   |\n+LL |         f11.callable_t()(&*x);\n+   |                           ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:135:17\n+   |\n+LL |     let _ = S1(&*s);\n+   |                 ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:140:22\n+   |\n+LL |     let _ = S2 { s: &*s };\n+   |                      ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:156:30\n+   |\n+LL |             let _ = Self::S1(&**s);\n+   |                              ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:157:35\n+   |\n+LL |             let _ = Self::S2 { s: &**s };\n+   |                                   ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:160:21\n+   |\n+LL |     let _ = E1::S1(&*s);\n+   |                     ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:161:26\n+   |\n+LL |     let _ = E1::S2 { s: &*s };\n+   |                          ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:179:13\n+   |\n+LL |     let _ = (*b).foo;\n+   |             ^^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:180:13\n+   |\n+LL |     let _ = (**b).foo;\n+   |             ^^^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:195:19\n+   |\n+LL |     let _ = f_str(*ref_str);\n+   |                   ^^^^^^^^ help: try this: `ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:197:19\n+   |\n+LL |     let _ = f_str(**ref_ref_str);\n+   |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:207:13\n+   |\n+LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+   |             ^^^^^^^^ help: try this: `ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:208:12\n+   |\n+LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n+   |            ^^^^^^^^^^ help: try this: `ref_str`\n+\n+error: aborting due to 32 previous errors\n+"}, {"sha": "523cae183ee6ec27fac2400d22d128202b4b1b9d", "filename": "tests/ui/explicit_deref_methods.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "0bbc1ae57cdf6dfc23eea738be3423db677a5dda", "filename": "tests/ui/explicit_deref_methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "4b10ed1377b0dc46f6eaf955bb23cb423542b2ab", "filename": "tests/ui/explicit_deref_methods.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fexplicit_deref_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.stderr?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,73 +1,73 @@\n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:35:19\n+  --> $DIR/explicit_deref_methods.rs:36:19\n    |\n LL |     let b: &str = a.deref();\n    |                   ^^^^^^^^^ help: try this: `&*a`\n    |\n    = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n \n error: explicit `deref_mut` method call\n-  --> $DIR/explicit_deref_methods.rs:37:23\n+  --> $DIR/explicit_deref_methods.rs:38:23\n    |\n LL |     let b: &mut str = a.deref_mut();\n    |                       ^^^^^^^^^^^^^ help: try this: `&mut **a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:39\n+  --> $DIR/explicit_deref_methods.rs:41:39\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                       ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:50\n+  --> $DIR/explicit_deref_methods.rs:41:50\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                                  ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:42:20\n+  --> $DIR/explicit_deref_methods.rs:43:20\n    |\n LL |     println!(\"{}\", a.deref());\n    |                    ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:45:11\n+  --> $DIR/explicit_deref_methods.rs:46:11\n    |\n LL |     match a.deref() {\n    |           ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:49:28\n+  --> $DIR/explicit_deref_methods.rs:50:28\n    |\n LL |     let b: String = concat(a.deref());\n    |                            ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:51:13\n+  --> $DIR/explicit_deref_methods.rs:52:13\n    |\n LL |     let b = just_return(a).deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:53:28\n+  --> $DIR/explicit_deref_methods.rs:54:28\n    |\n LL |     let b: String = concat(just_return(a).deref());\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:55:19\n+  --> $DIR/explicit_deref_methods.rs:56:19\n    |\n LL |     let b: &str = a.deref().deref();\n    |                   ^^^^^^^^^^^^^^^^^ help: try this: `&**a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:58:13\n+  --> $DIR/explicit_deref_methods.rs:59:13\n    |\n LL |     let b = opt_a.unwrap().deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:84:31\n+  --> $DIR/explicit_deref_methods.rs:85:31\n    |\n LL |     let b: &str = expr_deref!(a.deref());\n    |                               ^^^^^^^^^ help: try this: `&*a`"}, {"sha": "cb005122436019f2a2be9ac1c8fb219d8257e534", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();\n@@ -74,6 +85,36 @@ fn main() {\n     let _ = x.0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "d636a40100378c0f5bebc5cbb3f85b9f902ab365", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();\n@@ -74,6 +85,36 @@ fn main() {\n     let _ = (&x).0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (&*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "8a2e2b9895908f1ac5fb1d2d2737b5a5a230e5a7", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -84,17 +84,41 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:67:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:73:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:74:13\n+  --> $DIR/needless_borrow.rs:85:13\n    |\n LL |     let _ = (&x).0;\n    |             ^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:76:22\n+  --> $DIR/needless_borrow.rs:87:22\n    |\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n-error: aborting due to 16 previous errors\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:97:5\n+   |\n+LL |     (&&()).foo();\n+   |     ^^^^^^ help: change this to: `(&())`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:106:5\n+   |\n+LL |     (&&5).foo();\n+   |     ^^^^^ help: change this to: `(&5)`\n+\n+error: aborting due to 20 previous errors\n "}, {"sha": "222e8e617995d7943e4d0d6cd1e7ea7da452364e", "filename": "tests/ui/needless_borrow_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fneedless_borrow_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow_pat.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,7 +1,7 @@\n // FIXME: run-rustfix waiting on multi-span suggestions\n \n #![warn(clippy::needless_borrow)]\n-#![allow(clippy::needless_borrowed_reference)]\n+#![allow(clippy::needless_borrowed_reference, clippy::explicit_auto_deref)]\n \n fn f1(_: &str) {}\n macro_rules! m1 {"}, {"sha": "c8d0e56b197f4e939022ac07eddbdb8018176d84", "filename": "tests/ui/ref_binding_to_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fref_binding_to_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fref_binding_to_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_binding_to_reference.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(lint_reasons)]\n #![warn(clippy::ref_binding_to_reference)]\n-#![allow(clippy::needless_borrowed_reference)]\n+#![allow(clippy::needless_borrowed_reference, clippy::explicit_auto_deref)]\n \n fn f1(_: &str) {}\n macro_rules! m2 {"}, {"sha": "5190c5304c75d127f0c03deff0c424e049fb580d", "filename": "tests/ui/search_is_some_fixable_none.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "310d87333a93c4270f8becf2466705c70208a6bf", "filename": "tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "5a2aee465d1bdee6d95cd79f1763aef9b73e4300", "filename": "tests/ui/search_is_some_fixable_some.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "0e98ae18a217cb840dad5c974c1b221488c64b14", "filename": "tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "90cb8945e77ff1a1d86f79d87b3cf9159302b3c9", "filename": "tests/ui/useless_asref.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.fixed?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "cb9f8ae5909a551856a33fe57e94f6c77eab6306", "filename": "tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.rs?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "b21c67bb3645f0bee32311879842ecd86ebaf87c", "filename": "tests/ui/useless_asref.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4130e16124e58ae6c6e6eb201ffced2c1964145/tests%2Fui%2Fuseless_asref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.stderr?ref=a4130e16124e58ae6c6e6eb201ffced2c1964145", "patch": "@@ -1,5 +1,5 @@\n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:43:18\n+  --> $DIR/useless_asref.rs:44:18\n    |\n LL |         foo_rstr(rstr.as_ref());\n    |                  ^^^^^^^^^^^^^ help: try this: `rstr`\n@@ -11,61 +11,61 @@ LL | #![deny(clippy::useless_asref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:45:20\n+  --> $DIR/useless_asref.rs:46:20\n    |\n LL |         foo_rslice(rslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^ help: try this: `rslice`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:49:21\n+  --> $DIR/useless_asref.rs:50:21\n    |\n LL |         foo_mrslice(mrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:51:20\n+  --> $DIR/useless_asref.rs:52:20\n    |\n LL |         foo_rslice(mrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:58:20\n+  --> $DIR/useless_asref.rs:59:20\n    |\n LL |         foo_rslice(rrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^ help: try this: `rrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:60:18\n+  --> $DIR/useless_asref.rs:61:18\n    |\n LL |         foo_rstr(rrrrrstr.as_ref());\n    |                  ^^^^^^^^^^^^^^^^^ help: try this: `rrrrrstr`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:65:21\n+  --> $DIR/useless_asref.rs:66:21\n    |\n LL |         foo_mrslice(mrrrrrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:67:20\n+  --> $DIR/useless_asref.rs:68:20\n    |\n LL |         foo_rslice(mrrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:71:16\n+  --> $DIR/useless_asref.rs:72:16\n    |\n LL |     foo_rrrrmr((&&&&MoreRef).as_ref());\n    |                ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(&&&&MoreRef)`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:121:13\n+  --> $DIR/useless_asref.rs:122:13\n    |\n LL |     foo_mrt(mrt.as_mut());\n    |             ^^^^^^^^^^^^ help: try this: `mrt`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:123:12\n+  --> $DIR/useless_asref.rs:124:12\n    |\n LL |     foo_rt(mrt.as_ref());\n    |            ^^^^^^^^^^^^ help: try this: `mrt`"}]}