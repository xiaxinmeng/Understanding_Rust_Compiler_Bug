{"sha": "d2c6bef493a86d83e8df726a8210e09187384cd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYzZiZWY0OTNhODZkODNlOGRmNzI2YTgyMTBlMDkxODczODRjZDk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-22T19:39:57Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T14:45:29Z"}, "message": "typeck: Remove the redundant \"unifier\" from check_expr_with_unifier.", "tree": {"sha": "9aa0cfe435c717c56e5dcfb877c4a2bd696b625a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aa0cfe435c717c56e5dcfb877c4a2bd696b625a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2c6bef493a86d83e8df726a8210e09187384cd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2c6bef493a86d83e8df726a8210e09187384cd9", "html_url": "https://github.com/rust-lang/rust/commit/d2c6bef493a86d83e8df726a8210e09187384cd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2c6bef493a86d83e8df726a8210e09187384cd9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad91f19957b62bb19fce7d400cf2c94e33da153d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad91f19957b62bb19fce7d400cf2c94e33da153d", "html_url": "https://github.com/rust-lang/rust/commit/ad91f19957b62bb19fce7d400cf2c94e33da153d"}], "stats": {"total": 73, "additions": 25, "deletions": 48}, "files": [{"sha": "0f16b18461847d4c2e1a5e18e240f8e7fdb12256", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 48, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d2c6bef493a86d83e8df726a8210e09187384cd9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2c6bef493a86d83e8df726a8210e09187384cd9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d2c6bef493a86d83e8df726a8210e09187384cd9", "patch": "@@ -2491,20 +2491,17 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     Expectation::rvalue_hint(fcx.tcx(), ty)\n                 });\n \n-                check_expr_with_unifier(fcx,\n-                                        &arg,\n-                                        expected.unwrap_or(ExpectHasType(formal_ty)),\n-                                        NoPreference, || {\n-                    // 2. Coerce to the most detailed type that could be coerced\n-                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                    //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                    let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n-                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n-\n-                    // 3. Relate the expected type and the formal one,\n-                    //    if the expected type was used for the coercion.\n-                    coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n-                });\n+                check_expr_with_expectation(fcx, &arg,\n+                    expected.unwrap_or(ExpectHasType(formal_ty)));\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n+                demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n             }\n \n             if let Some(&arg_ty) = fcx.inh.tables.borrow().node_types.get(&arg.id) {\n@@ -2626,57 +2623,42 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_expr_eq_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 expr: &'tcx hir::Expr,\n                                 expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::eqtype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::eqtype(fcx, expr.span, expected, fcx.expr_ty(expr));\n }\n \n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n }\n \n fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           expr: &'tcx hir::Expr,\n                                           expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || demand::coerce(fcx, expr.span, expected, expr));\n+    check_expr_with_hint(fcx, expr, expected);\n+    demand::coerce(fcx, expr.span, expected, expr);\n }\n \n fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &'tcx hir::Expr,\n                                   expected: Ty<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, ExpectHasType(expected), NoPreference,\n-        || ())\n+    check_expr_with_expectation(fcx, expr, ExpectHasType(expected))\n }\n \n fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          expr: &'tcx hir::Expr,\n                                          expected: Expectation<'tcx>) {\n-    check_expr_with_unifier(\n-        fcx, expr, expected, NoPreference,\n-        || ())\n-}\n-\n-fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                         expr: &'tcx hir::Expr,\n-                                                         expected: Expectation<'tcx>,\n-                                                         lvalue_pref: LvaluePreference)\n-{\n-    check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n+    check_expr_with_expectation_and_lvalue_pref(fcx, expr, expected, NoPreference)\n }\n \n fn check_expr<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr)  {\n-    check_expr_with_unifier(fcx, expr, NoExpectation, NoPreference, || ())\n+    check_expr_with_expectation(fcx, expr, NoExpectation)\n }\n \n fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr,\n                                         lvalue_pref: LvaluePreference)  {\n-    check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n+    check_expr_with_expectation_and_lvalue_pref(fcx, expr, NoExpectation, lvalue_pref)\n }\n \n // determine the `self` type, using fresh variables for all variables\n@@ -2778,13 +2760,10 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `TyError`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        expr: &'tcx hir::Expr,\n-                                        expected: Expectation<'tcx>,\n-                                        lvalue_pref: LvaluePreference,\n-                                        unifier: F) where\n-    F: FnOnce(),\n-{\n+fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                         expr: &'tcx hir::Expr,\n+                                                         expected: Expectation<'tcx>,\n+                                                         lvalue_pref: LvaluePreference) {\n     debug!(\">> typechecking: expr={:?} expected={:?}\",\n            expr, expected);\n \n@@ -3662,8 +3641,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"... {:?}, expected is {:?}\",\n            fcx.expr_ty(expr),\n            expected);\n-\n-    unifier();\n }\n \n pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,"}]}