{"sha": "ade6d2cf6b1b42b3974ab4085918a06e55947865", "node_id": "C_kwDOAAsO6NoAKGFkZTZkMmNmNmIxYjQyYjM5NzRhYjQwODU5MThhMDZlNTU5NDc4NjU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-07T12:36:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-07T12:36:52Z"}, "message": "Rollup merge of #98901 - davidtwco:split-dwarf-incr-workproduct, r=michaelwoerister\n\nincr: cache dwarf objects in work products\n\nCache DWARF objects alongside object files in work products when those exist so that DWARF object files are available for thorin in packed mode in incremental scenarios.\n\nr? `@michaelwoerister`", "tree": {"sha": "4e5d75c98f5c346f2eeddae14b7327f19ba221ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e5d75c98f5c346f2eeddae14b7327f19ba221ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ade6d2cf6b1b42b3974ab4085918a06e55947865", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixtNkCRBK7hj4Ov3rIwAAtWwIACPXZa+VaVEnzt+EMwjpJhJ4\n3OfaOLdTxPmaYE8d/ycuohC+Q/hk1vTBFCh98e43FMuNhk9gE1Cu+upj1GwK6Ttk\npfL0V6BqeV7ee1EuJIjWdpOIBhZB1PR1x5Udw9LMe3omazXvMmBK1KPI5YLf/uHm\nW1id5NS8YsIvnEtCRZb++zU0S1OZXksPJ3Lj39h3LjFP8zp+uOmi00VAbwbnLiYJ\nqgKL3C1mfSaiFFC88m7oow3D98Peu3DzfsNmSTT9lonzSyFJsox7kcDa2in8kTne\nQ4E79pr7s8NMp1i+nC6hWwv5hVOmQ7Yzk8xH9EEuahf9+nGV+uWCco9/nphxlDw=\n=RyDx\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e5d75c98f5c346f2eeddae14b7327f19ba221ff\nparent 776bb6447455d7292f6898aa4b9484140e0d3115\nparent e1065239fe768dbad7ecbe37be39cb3204476a87\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657197412 +0530\ncommitter GitHub <noreply@github.com> 1657197412 +0530\n\nRollup merge of #98901 - davidtwco:split-dwarf-incr-workproduct, r=michaelwoerister\n\nincr: cache dwarf objects in work products\n\nCache DWARF objects alongside object files in work products when those exist so that DWARF object files are available for thorin in packed mode in incremental scenarios.\n\nr? `@michaelwoerister`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ade6d2cf6b1b42b3974ab4085918a06e55947865", "html_url": "https://github.com/rust-lang/rust/commit/ade6d2cf6b1b42b3974ab4085918a06e55947865", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ade6d2cf6b1b42b3974ab4085918a06e55947865/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "776bb6447455d7292f6898aa4b9484140e0d3115", "url": "https://api.github.com/repos/rust-lang/rust/commits/776bb6447455d7292f6898aa4b9484140e0d3115", "html_url": "https://github.com/rust-lang/rust/commit/776bb6447455d7292f6898aa4b9484140e0d3115"}, {"sha": "e1065239fe768dbad7ecbe37be39cb3204476a87", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1065239fe768dbad7ecbe37be39cb3204476a87", "html_url": "https://github.com/rust-lang/rust/commit/e1065239fe768dbad7ecbe37be39cb3204476a87"}], "stats": {"total": 227, "additions": 147, "deletions": 80}, "files": [{"sha": "50d8fc30d7d7cabe13275e9a3c099834abb37c69", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -66,7 +66,11 @@ fn emit_module(\n     let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(tcx.sess, &name, &tmp_file)\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+            tcx.sess,\n+            &name,\n+            &[(\"o\", &tmp_file)],\n+        )\n     };\n \n     ModuleCodegenResult(\n@@ -82,7 +86,10 @@ fn reuse_workproduct_for_cgu(\n ) -> CompiledModule {\n     let work_product = cgu.previous_work_product(tcx);\n     let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &work_product.saved_file);\n+    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+        &tcx.sess,\n+        &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n+    );\n     if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n         tcx.sess.err(&format!(\n             \"unable to copy {} to {}: {}\","}, {"sha": "960e98243ac727b8c8d8904d4271812fb9f8fe0b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -151,11 +151,23 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             return;\n         }\n \n-        let remove_temps_from_module = |module: &CompiledModule| {\n-            if let Some(ref obj) = module.object {\n-                ensure_removed(sess.diagnostic(), obj);\n-            }\n-        };\n+        let maybe_remove_temps_from_module =\n+            |preserve_objects: bool, preserve_dwarf_objects: bool, module: &CompiledModule| {\n+                if !preserve_objects {\n+                    if let Some(ref obj) = module.object {\n+                        ensure_removed(sess.diagnostic(), obj);\n+                    }\n+                }\n+\n+                if !preserve_dwarf_objects {\n+                    if let Some(ref dwo_obj) = module.dwarf_object {\n+                        ensure_removed(sess.diagnostic(), dwo_obj);\n+                    }\n+                }\n+            };\n+\n+        let remove_temps_from_module =\n+            |module: &CompiledModule| maybe_remove_temps_from_module(false, false, module);\n \n         // Otherwise, always remove the metadata and allocator module temporaries.\n         if let Some(ref metadata_module) = codegen_results.metadata_module {\n@@ -177,15 +189,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         debug!(?preserve_objects, ?preserve_dwarf_objects);\n \n         for module in &codegen_results.modules {\n-            if !preserve_objects {\n-                remove_temps_from_module(module);\n-            }\n-\n-            if !preserve_dwarf_objects {\n-                if let Some(ref obj) = module.dwarf_object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-            }\n+            maybe_remove_temps_from_module(preserve_objects, preserve_dwarf_objects, module);\n         }\n     });\n \n@@ -649,6 +653,7 @@ fn link_dwarf_object<'a>(\n             sess.struct_err(\"linking dwarf objects with thorin failed\")\n                 .note(&format!(\"{:?}\", e))\n                 .emit();\n+            sess.abort_if_errors();\n         }\n     }\n }"}, {"sha": "f4a5cac872e0516c2d5b7e483bd6ad3f9840fbaf", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -494,12 +494,18 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        if let Some(path) = &module.object {\n-            if let Some((id, product)) =\n-                copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, path)\n-            {\n-                work_products.insert(id, product);\n-            }\n+        let mut files = Vec::new();\n+        if let Some(object_file_path) = &module.object {\n+            files.push((\"o\", object_file_path.as_path()));\n+        }\n+        if let Some(dwarf_object_file_path) = &module.dwarf_object {\n+            files.push((\"dwo\", dwarf_object_file_path.as_path()));\n+        }\n+\n+        if let Some((id, product)) =\n+            copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, files.as_slice())\n+        {\n+            work_products.insert(id, product);\n         }\n     }\n \n@@ -856,29 +862,50 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     assert!(module_config.emit_obj != EmitObj::None);\n \n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n-    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n-    let source_file = in_incr_comp_dir(&incr_comp_session_dir, &module.source.saved_file);\n-    debug!(\n-        \"copying pre-existing module `{}` from {:?} to {}\",\n-        module.name,\n-        source_file,\n-        obj_out.display()\n+\n+    let load_from_incr_comp_dir = |output_path: PathBuf, saved_path: &str| {\n+        let source_file = in_incr_comp_dir(&incr_comp_session_dir, saved_path);\n+        debug!(\n+            \"copying pre-existing module `{}` from {:?} to {}\",\n+            module.name,\n+            source_file,\n+            output_path.display()\n+        );\n+        match link_or_copy(&source_file, &output_path) {\n+            Ok(_) => Some(output_path),\n+            Err(err) => {\n+                let diag_handler = cgcx.create_diag_handler();\n+                diag_handler.err(&format!(\n+                    \"unable to copy {} to {}: {}\",\n+                    source_file.display(),\n+                    output_path.display(),\n+                    err\n+                ));\n+                None\n+            }\n+        }\n+    };\n+\n+    let object = load_from_incr_comp_dir(\n+        cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name)),\n+        &module.source.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = link_or_copy(&source_file, &obj_out) {\n-        let diag_handler = cgcx.create_diag_handler();\n-        diag_handler.err(&format!(\n-            \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n-            err\n-        ));\n-    }\n+    let dwarf_object =\n+        module.source.saved_files.get(\"dwo\").as_ref().and_then(|saved_dwarf_object_file| {\n+            let dwarf_obj_out = cgcx\n+                .output_filenames\n+                .split_dwarf_path(cgcx.split_debuginfo, cgcx.split_dwarf_kind, Some(&module.name))\n+                .expect(\n+                    \"saved dwarf object in work product but `split_dwarf_path` returned `None`\",\n+                );\n+            load_from_incr_comp_dir(dwarf_obj_out, &saved_dwarf_object_file)\n+        });\n \n     WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n+        object,\n+        dwarf_object,\n         bytecode: None,\n     })\n }"}, {"sha": "f59d8d596b98ec1f9bcf8d50a36d0967465d7ce7", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -161,19 +161,13 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n                 Decodable::decode(&mut work_product_decoder);\n \n             for swp in work_products {\n-                let mut all_files_exist = true;\n-                let path = in_incr_comp_dir_sess(sess, &swp.work_product.saved_file);\n-                if !path.exists() {\n-                    all_files_exist = false;\n-\n-                    if sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\n-                            \"incremental: could not find file for work \\\n-                                    product: {}\",\n-                            path.display()\n-                        );\n+                let all_files_exist = swp.work_product.saved_files.iter().all(|(_, path)| {\n+                    let exists = in_incr_comp_dir_sess(sess, path).exists();\n+                    if !exists && sess.opts.debugging_opts.incremental_info {\n+                        eprintln!(\"incremental: could not find file for work product: {path}\",);\n                     }\n-                }\n+                    exists\n+                });\n \n                 if all_files_exist {\n                     debug!(\"reconcile_work_products: all files for {:?} exist\", swp);"}, {"sha": "4059b7cfc8eb9eb3d2ca072b795fffe2e619996a", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -108,16 +108,17 @@ pub fn save_work_product_index(\n     for (id, wp) in previous_work_products.iter() {\n         if !new_work_products.contains_key(id) {\n             work_product::delete_workproduct_files(sess, wp);\n-            debug_assert!(!in_incr_comp_dir_sess(sess, &wp.saved_file).exists());\n+            debug_assert!(\n+                !wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+            );\n         }\n     }\n \n     // Check that we did not delete one of the current work-products:\n     debug_assert!({\n-        new_work_products\n-            .iter()\n-            .map(|(_, wp)| in_incr_comp_dir_sess(sess, &wp.saved_file))\n-            .all(|path| path.exists())\n+        new_work_products.iter().all(|(_, wp)| {\n+            wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+        })\n     });\n }\n "}, {"sha": "1b184eca964c34fa5247205613f3aadd9ea94f36", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -3,6 +3,7 @@\n //! [work products]: WorkProduct\n \n use crate::persist::fs::*;\n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_fs_util::link_or_copy;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_session::Session;\n@@ -13,38 +14,41 @@ use std::path::Path;\n pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n     sess: &Session,\n     cgu_name: &str,\n-    path: &Path,\n+    files: &[(&'static str, &Path)],\n ) -> Option<(WorkProductId, WorkProduct)> {\n-    debug!(\"copy_cgu_workproduct_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, path);\n+    debug!(?cgu_name, ?files);\n     sess.opts.incremental.as_ref()?;\n \n-    let file_name = format!(\"{}.o\", cgu_name);\n-    let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n-    let saved_file = match link_or_copy(path, &path_in_incr_dir) {\n-        Ok(_) => file_name,\n-        Err(err) => {\n-            sess.warn(&format!(\n-                \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                path.display(),\n-                path_in_incr_dir.display(),\n-                err\n-            ));\n-            return None;\n+    let mut saved_files = FxHashMap::default();\n+    for (ext, path) in files {\n+        let file_name = format!(\"{cgu_name}.{ext}\");\n+        let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n+        match link_or_copy(path, &path_in_incr_dir) {\n+            Ok(_) => {\n+                let _ = saved_files.insert(ext.to_string(), file_name);\n+            }\n+            Err(err) => {\n+                sess.warn(&format!(\n+                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n+                    path.display(),\n+                    path_in_incr_dir.display(),\n+                    err\n+                ));\n+            }\n         }\n-    };\n-\n-    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_file };\n+    }\n \n+    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_files };\n+    debug!(?work_product);\n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n     Some((work_product_id, work_product))\n }\n \n /// Removes files for a given work product.\n pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n-    let path = in_incr_comp_dir_sess(sess, &work_product.saved_file);\n-    match std_fs::remove_file(&path) {\n-        Ok(()) => {}\n-        Err(err) => {\n+    for (_, path) in &work_product.saved_files {\n+        let path = in_incr_comp_dir_sess(sess, path);\n+        if let Err(err) = std_fs::remove_file(&path) {\n             sess.warn(&format!(\n                 \"file-system error deleting outdated file `{}`: {}\",\n                 path.display(),"}, {"sha": "3291717c550df27d2a5a7b3f3ba51b61c1d0f2f2", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -886,8 +886,12 @@ impl<K: DepKind> DepGraph<K> {\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved file associated with this CGU.\n-    pub saved_file: String,\n+    /// Saved files associated with this CGU. In each key/value pair, the value is the path to the\n+    /// saved file and the key is some identifier for the type of file being saved.\n+    ///\n+    /// By convention, file extensions are currently used as identifiers, i.e. the key \"o\" maps to\n+    /// the object file's path, and \"dwo\" to the dwarf object file's path.\n+    pub saved_files: FxHashMap<String, String>,\n }\n \n // Index type for `DepNodeData`'s edges."}, {"sha": "25c802d5a1d2e35471c6f143c7a263f724c4c33c", "filename": "src/test/incremental/split_debuginfo_cached.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ade6d2cf6b1b42b3974ab4085918a06e55947865/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade6d2cf6b1b42b3974ab4085918a06e55947865/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs?ref=ade6d2cf6b1b42b3974ab4085918a06e55947865", "patch": "@@ -0,0 +1,25 @@\n+// Check that compiling with packed Split DWARF twice succeeds. This should confirm that DWARF\n+// objects are cached as work products and available to the incremental compilation for `thorin` to\n+// pack into a DWARF package.\n+\n+// ignore-tidy-linelength\n+// only-x86_64-unknown-linux-gnu\n+// revisions:rpass1 rpass2\n+\n+// [rpass1]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+// [rpass2]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+\n+#![feature(rustc_attrs)]\n+// For `rpass2`, nothing has changed so everything should re-used.\n+#![rustc_partition_reused(module = \"split_debuginfo_cached\", cfg = \"rpass2\")]\n+#![rustc_partition_reused(module = \"split_debuginfo_cached-another_module\", cfg = \"rpass2\")]\n+\n+mod another_module {\n+    pub fn foo() -> &'static str {\n+        \"hello world\"\n+    }\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", another_module::foo());\n+}"}]}