{"sha": "9a32772f924b12af2cd40fe24cf59548cd81d3e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMzI3NzJmOTI0YjEyYWYyY2Q0MGZlMjRjZjU5NTQ4Y2Q4MWQzZTY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-21T11:23:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-21T11:23:37Z"}, "message": "Merge pull request #156 from oli-obk/master\n\nUse rustc generated shims instead of interpreter hacks", "tree": {"sha": "50f6596ebebad17d10dc580a0e68b734bad095d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50f6596ebebad17d10dc580a0e68b734bad095d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a32772f924b12af2cd40fe24cf59548cd81d3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a32772f924b12af2cd40fe24cf59548cd81d3e6", "html_url": "https://github.com/rust-lang/rust/commit/9a32772f924b12af2cd40fe24cf59548cd81d3e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a32772f924b12af2cd40fe24cf59548cd81d3e6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba0a7e8fc3fee508b2252c6adc59635a4767701", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba0a7e8fc3fee508b2252c6adc59635a4767701", "html_url": "https://github.com/rust-lang/rust/commit/cba0a7e8fc3fee508b2252c6adc59635a4767701"}, {"sha": "b9bd747b6c8f10b4430b96fba16c0359e7c1b271", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9bd747b6c8f10b4430b96fba16c0359e7c1b271", "html_url": "https://github.com/rust-lang/rust/commit/b9bd747b6c8f10b4430b96fba16c0359e7c1b271"}], "stats": {"total": 2103, "additions": 989, "deletions": 1114}, "files": [{"sha": "e6450622b2e88b61c30d8851373295292dd81d48", "filename": ".travis.yml", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -2,18 +2,16 @@ language: rust\n rust:\n - nightly\n before_script:\n-- |\n-  pip install 'travis-cargo<0.2' --user &&\n-  export PATH=$HOME/.local/bin:$PATH\n-- sh ~/rust-installer/rustup.sh --add-target=i686-unknown-linux-gnu --prefix=/home/travis/rust -y --disable-sudo\n-- sh ~/rust-installer/rustup.sh --add-target=i686-pc-windows-gnu --prefix=/home/travis/rust -y --disable-sudo\n-- sh ~/rust-installer/rustup.sh --add-target=i686-pc-windows-msvc --prefix=/home/travis/rust -y --disable-sudo\n+- export PATH=$HOME/.local/bin:$PATH\n+- rustup target add i686-unknown-linux-gnu\n+- rustup target add i686-pc-windows-gnu\n+- rustup target add i686-pc-windows-msvc\n script:\n - |\n   export RUST_SYSROOT=$HOME/rust &&\n-  travis-cargo build &&\n-  travis-cargo test &&\n-  travis-cargo install &&\n+  cargo build &&\n+  cargo test &&\n+  cargo install &&\n   cd cargo-miri-test &&\n   cargo miri &&\n   cargo miri test &&"}, {"sha": "7263e2beeebd6c1612cae9e37b82bab573e6b8db", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -21,7 +21,7 @@ dependencies = [\n [[package]]\n name = \"byteorder\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/quininer/byteorder.git?branch=i128#ef51df297aa833d0b6639aae328a95597fc07d75\"\n+source = \"git+https://github.com/quininer/byteorder.git?branch=i128#9bab6d7783f81da50feb234a120c918d9eabba6e\"\n \n [[package]]\n name = \"cargo_metadata\""}, {"sha": "fd692ef8b64a5ac3b70b18f7102ffaef26cf7567", "filename": "src/error.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::{Pointer, Function};\n+use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -52,9 +52,6 @@ pub enum EvalError<'tcx> {\n     DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n     Unreachable,\n-    ExpectedConcreteFunction(Function<'tcx>),\n-    ExpectedDropGlue(Function<'tcx>),\n-    ManuallyCalledDropGlue,\n     Panic,\n }\n \n@@ -128,12 +125,6 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n             EvalError::Unreachable =>\n                 \"entered unreachable code\",\n-            EvalError::ExpectedConcreteFunction(_) =>\n-                \"tried to use glue function as function\",\n-            EvalError::ExpectedDropGlue(_) =>\n-                \"tried to use non-drop-glue function as drop glue\",\n-            EvalError::ManuallyCalledDropGlue =>\n-                \"tried to manually invoke drop glue\",\n             EvalError::Panic =>\n                 \"the evaluated program panicked\",\n         }"}, {"sha": "3ddecc43373d70fdba45005d045967a0b73278fb", "filename": "src/eval_context.rs", "status": "modified", "additions": 561, "deletions": 72, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -5,13 +5,18 @@ use std::fmt::Write;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::ConstVal;\n+use rustc_const_math::{ConstInt, ConstUsize};\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n+use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n+use syntax::ast;\n+use syntax::abi::Abi;\n+use syntax::symbol::Symbol;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n@@ -41,6 +46,9 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: u64,\n+\n+    /// Drop glue for arrays and slices\n+    pub(crate) seq_drop_glue: MirRef<'tcx>,\n }\n \n /// A stack frame.\n@@ -52,11 +60,8 @@ pub struct Frame<'tcx> {\n     /// The MIR for the function called on this frame.\n     pub mir: MirRef<'tcx>,\n \n-    /// The def_id of the current function.\n-    pub def_id: DefId,\n-\n-    /// type substitutions for the current function invocation.\n-    pub substs: &'tcx Substs<'tcx>,\n+    /// The def_id and substs of the current function\n+    pub instance: ty::Instance<'tcx>,\n \n     /// The span of the call site.\n     pub span: codemap::Span,\n@@ -78,12 +83,6 @@ pub struct Frame<'tcx> {\n     /// Before being initialized, all locals are `Value::ByVal(PrimVal::Undef)`.\n     pub locals: Vec<Value>,\n \n-    /// Temporary allocations introduced to save stackframes\n-    /// This is pure interpreter magic and has nothing to do with how rustc does it\n-    /// An example is calling an FnMut closure that has been converted to a FnOnce closure\n-    /// The value's destructor will be called and the memory freed when the stackframe finishes\n-    pub interpreter_temporaries: Vec<(Pointer, Ty<'tcx>)>,\n-\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -130,13 +129,189 @@ impl Default for ResourceLimits {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+        let source_info = mir::SourceInfo {\n+            span: DUMMY_SP,\n+            scope: mir::ARGUMENT_VISIBILITY_SCOPE\n+        };\n+        // i = 0; len = Len(*a0); goto head;\n+        let start_block = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(2)),\n+                        mir::Rvalue::Use(mir::Operand::Constant(mir::Constant {\n+                            span: DUMMY_SP,\n+                            ty: tcx.types.usize,\n+                            literal: mir::Literal::Value {\n+                                value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(0, tcx.sess.target.uint_type).unwrap())),\n+                            },\n+                        }))\n+                    )\n+                },\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(3)),\n+                        mir::Rvalue::Len(mir::Lvalue::Projection(Box::new(mir::LvalueProjection {\n+                            base: mir::Lvalue::Local(mir::Local::new(1)),\n+                            elem: mir::ProjectionElem::Deref,\n+                        }))),\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n+            }),\n+            is_cleanup: false\n+        };\n+        // head: done = i == len; switch done { 1 => ret, 0 => loop }\n+        let head = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(4)),\n+                        mir::Rvalue::BinaryOp(\n+                            mir::BinOp::Eq,\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(3))),\n+                        )\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::SwitchInt {\n+                    targets: vec![\n+                        mir::BasicBlock::new(2),\n+                        mir::BasicBlock::new(4),\n+                    ],\n+                    discr: mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(4))),\n+                    switch_ty: tcx.types.bool,\n+                    values: vec![ConstInt::U8(0)].into(),\n+                },\n+            }),\n+            is_cleanup: false\n+        };\n+        // loop: drop (*a0)[i]; goto inc;\n+        let loop_ = mir::BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Drop {\n+                    target: mir::BasicBlock::new(3),\n+                    unwind: None,\n+                    location: mir::Lvalue::Projection(Box::new(\n+                        mir::LvalueProjection {\n+                            base: mir::Lvalue::Projection(Box::new(\n+                                mir::LvalueProjection {\n+                                    base: mir::Lvalue::Local(mir::Local::new(1)),\n+                                    elem: mir::ProjectionElem::Deref,\n+                                }\n+                            )),\n+                            elem: mir::ProjectionElem::Index(mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2)))),\n+                        }\n+                    )),\n+                },\n+            }),\n+            is_cleanup: false\n+        };\n+        // inc: i++; goto head;\n+        let inc = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(2)),\n+                        mir::Rvalue::BinaryOp(\n+                            mir::BinOp::Add,\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n+                            mir::Operand::Constant(mir::Constant {\n+                                span: DUMMY_SP,\n+                                ty: tcx.types.usize,\n+                                literal: mir::Literal::Value {\n+                                    value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(1, tcx.sess.target.uint_type).unwrap())),\n+                                },\n+                            }),\n+                        )\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n+            }),\n+            is_cleanup: false\n+        };\n+        // ret: return;\n+        let ret = mir::BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Return,\n+            }),\n+            is_cleanup: false\n+        };\n+        let locals = vec![\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.mk_nil(),\n+                name: None,\n+                source_info,\n+                is_user_variable: false,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.mk_mut_ptr(tcx.mk_slice(tcx.mk_param(0, Symbol::intern(\"T\")))),\n+                name: None,\n+                source_info,\n+                is_user_variable: false,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.usize,\n+                name: None,\n+                source_info,\n+                is_user_variable: false,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.usize,\n+                name: None,\n+                source_info,\n+                is_user_variable: false,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.bool,\n+                name: None,\n+                source_info,\n+                is_user_variable: false,\n+            },\n+        ];\n+        let seq_drop_glue = mir::Mir::new(\n+            vec![start_block, head, loop_, inc, ret].into_iter().collect(),\n+            Vec::new().into_iter().collect(), // vis scopes\n+            Vec::new().into_iter().collect(), // promoted\n+            tcx.mk_nil(), // return type\n+            locals.into_iter().collect(),\n+            1, // arg_count\n+            Vec::new(), // upvars\n+            DUMMY_SP,\n+        );\n+        let seq_drop_glue = tcx.alloc_mir(seq_drop_glue);\n+        // Perma-borrow MIR from shims to prevent mutation.\n+        ::std::mem::forget(seq_drop_glue.borrow());\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n+            seq_drop_glue: seq_drop_glue.borrow(),\n         }\n     }\n \n@@ -172,7 +347,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n-    pub(super) fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n+    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::ConstFloat;\n \n@@ -194,7 +369,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Struct(_)    => unimplemented!(),\n             Tuple(_)     => unimplemented!(),\n-            Function(_, _)  => unimplemented!(),\n+            // function items are zero sized and thus have no readable value\n+            Function(..)  => PrimVal::Undef,\n             Array(_)     => unimplemented!(),\n             Repeat(_, _) => unimplemented!(),\n         };\n@@ -208,12 +384,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    pub fn load_mir(&self, def_id: DefId) -> EvalResult<'tcx, MirRef<'tcx>> {\n-        trace!(\"load mir {:?}\", def_id);\n-        if def_id.is_local() || self.tcx.sess.cstore.is_item_mir_available(def_id) {\n-            Ok(self.tcx.item_mir(def_id))\n-        } else {\n-            Err(EvalError::NoMirFor(self.tcx.item_path_str(def_id)))\n+    pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, MirRef<'tcx>> {\n+        trace!(\"load mir {:?}\", instance);\n+        match instance {\n+            ty::InstanceDef::Item(def_id) => self.tcx.maybe_item_mir(def_id).ok_or_else(|| EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n+            _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }\n \n@@ -272,13 +447,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn push_stack_frame(\n         &mut self,\n-        def_id: DefId,\n+        instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n         mir: MirRef<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n-        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n@@ -293,10 +466,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return_to_block,\n             return_lvalue,\n             locals,\n-            interpreter_temporaries: temporaries,\n             span,\n-            def_id,\n-            substs,\n+            instance,\n             stmt: 0,\n         });\n \n@@ -352,13 +523,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n         }\n-        // drop and deallocate all temporary allocations\n-        for (ptr, ty) in frame.interpreter_temporaries {\n-            trace!(\"dropping temporary allocation\");\n-            let mut drops = Vec::new();\n-            self.drop(Lvalue::from_ptr(ptr), ty, &mut drops)?;\n-            self.eval_drop_impls(drops, frame.span)?;\n-        }\n+\n         Ok(())\n     }\n \n@@ -665,8 +830,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, sig) => {\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, sig);\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            let instance = resolve(self.tcx, def_id, substs);\n+                            let fn_ptr = self.memory.create_fn_alloc(instance);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -682,8 +848,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     ClosureFnPointer => match self.operand_ty(operand).sty {\n                         ty::TyClosure(def_id, substs) => {\n-                            let fn_ty = self.tcx.closure_type(def_id);\n-                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(def_id, substs, fn_ty);\n+                            let instance = resolve_closure(self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                            let fn_ptr = self.memory.create_fn_alloc(instance);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -835,26 +1001,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n \n-            Constant(mir::Constant { ref literal, ty, .. }) => {\n+            Constant(mir::Constant { ref literal, .. }) => {\n                 use rustc::mir::Literal;\n                 let value = match *literal {\n                     Literal::Value { ref value } => self.const_to_value(value)?,\n \n                     Literal::Item { def_id, substs } => {\n-                        if let ty::TyFnDef(..) = ty.sty {\n-                            // function items are zero sized\n-                            Value::ByRef(self.memory.allocate(0, 0)?)\n-                        } else {\n-                            let (def_id, substs) = self.resolve_associated_const(def_id, substs);\n-                            let cid = GlobalId { def_id, substs, promoted: None };\n-                            self.globals.get(&cid).expect(\"static/const not cached\").value\n-                        }\n+                        let instance = self.resolve_associated_const(def_id, substs);\n+                        let cid = GlobalId { instance, promoted: None };\n+                        self.globals.get(&cid).expect(\"static/const not cached\").value\n                     }\n \n                     Literal::Promoted { index } => {\n                         let cid = GlobalId {\n-                            def_id: self.frame().def_id,\n-                            substs: self.substs(),\n+                            instance: self.frame().instance,\n                             promoted: Some(index),\n                         };\n                         self.globals.get(&cid).expect(\"promoted not cached\").value\n@@ -891,8 +1051,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack[frame].substs);\n-                        let substs = self.stack[frame].substs;\n+                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n+                        let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].locals[local.index() - 1] = Value::ByRef(ptr);\n                         self.write_value_to_ptr(val, ptr, ty)?;\n@@ -911,7 +1071,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match global_val.value {\n                     Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n                     _ => {\n-                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n+                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n                         // see comment on `initialized` field\n@@ -1289,7 +1449,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn substs(&self) -> &'tcx Substs<'tcx> {\n-        self.frame().substs\n+        self.frame().instance.substs\n     }\n \n     fn unsize_into_ptr(\n@@ -1320,7 +1480,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (_, &ty::TyDynamic(ref data, _)) => {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                let vtable = self.get_vtable(trait_ref)?;\n+                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.read_ptr(&self.memory)?;\n                 let ptr = PrimVal::Ptr(ptr);\n                 let extra = PrimVal::Ptr(vtable);\n@@ -1519,7 +1679,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     limits: ResourceLimits,\n ) {\n     let mut ecx = EvalContext::new(tcx, limits);\n-    let mir = ecx.load_mir(def_id).expect(\"main function's MIR not found\");\n+    let instance = ty::Instance::mono(tcx, def_id);\n+    let mir = ecx.load_mir(instance.def).expect(\"main function's MIR not found\");\n \n     if !mir.return_ty.is_nil() || mir.arg_count != 0 {\n         let msg = \"miri does not support main functions without `fn()` type signatures\";\n@@ -1528,13 +1689,11 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     }\n \n     ecx.push_stack_frame(\n-        def_id,\n+        instance,\n         DUMMY_SP,\n         mir,\n-        tcx.intern_substs(&[]),\n         Lvalue::from_ptr(Pointer::zst_ptr()),\n         StackPopCleanup::None,\n-        Vec::new(),\n     ).expect(\"could not allocate first stack frame\");\n \n     loop {\n@@ -1564,23 +1723,12 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n         block.terminator().source_info.span\n     };\n     let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n-        if tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n+    for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n+        if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n             err.span_note(span, \"inside call to closure\");\n             continue;\n         }\n-        // FIXME(solson): Find a way to do this without this Display impl hack.\n-        use rustc::util::ppaux;\n-        use std::fmt;\n-        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n-        impl<'tcx> ::std::panic::UnwindSafe for Instance<'tcx> {}\n-        impl<'tcx> ::std::panic::RefUnwindSafe for Instance<'tcx> {}\n-        impl<'tcx> fmt::Display for Instance<'tcx> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                ppaux::parameterized(f, self.1, self.0, &[])\n-            }\n-        }\n-        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+        err.span_note(span, &format!(\"inside call to {}\", instance));\n     }\n     err.emit();\n }\n@@ -1657,3 +1805,344 @@ impl<'b, 'tcx: 'b> IntoValTyPair<'tcx> for &'b mir::Operand<'tcx> {\n         Ok((value, value_ty))\n     }\n }\n+\n+\n+/// FIXME: expose trans::monomorphize::resolve_closure\n+pub fn resolve_closure<'a, 'tcx> (\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    requested_kind: ty::ClosureKind,\n+) -> ty::Instance<'tcx> {\n+    let actual_kind = tcx.closure_kind(def_id);\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n+        _ => ty::Instance::new(def_id, substs.substs)\n+    }\n+}\n+\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    closure_did: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+) -> ty::Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+           closure_did,\n+           substs);\n+    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n+\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n+\n+    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+        Kind::from(self_ty),\n+        Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    ty::Instance { def, substs }\n+}\n+\n+fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+                              -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+           Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            Ok(true)\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+/// The point where linking happens. Resolve a (def_id, substs)\n+/// pair to an instance.\n+pub fn resolve<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>\n+) -> ty::Instance<'tcx> {\n+    debug!(\"resolve(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n+        debug!(\" => associated item, attempting to find impl\");\n+        let item = tcx.associated_item(def_id);\n+        resolve_associated_item(tcx, &item, trait_def_id, substs)\n+    } else {\n+        let item_type = def_ty(tcx, def_id, substs);\n+        let def = match item_type.sty {\n+            ty::TyFnDef(_, _, f) if\n+                f.abi() == Abi::RustIntrinsic ||\n+                f.abi() == Abi::PlatformIntrinsic =>\n+            {\n+                debug!(\" => intrinsic\");\n+                ty::InstanceDef::Intrinsic(def_id)\n+            }\n+            _ => {\n+                if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+                    let ty = substs.type_at(0);\n+                    if needs_drop_glue(tcx, ty) {\n+                        debug!(\" => nontrivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                    } else {\n+                        debug!(\" => trivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, None)\n+                    }\n+                } else {\n+                    debug!(\" => free item\");\n+                    ty::InstanceDef::Item(def_id)\n+                }\n+            }\n+        };\n+        ty::Instance { def, substs }\n+    };\n+    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n+           def_id, substs, result);\n+    result\n+}\n+\n+pub fn needs_drop_glue<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) -> bool {\n+    assert!(t.is_normalized_for_trans());\n+\n+    let t = tcx.erase_regions(&t);\n+\n+    // FIXME (#22815): note that type_needs_drop conservatively\n+    // approximates in some cases and may say a type expression\n+    // requires drop glue when it actually does not.\n+    //\n+    // (In this case it is not clear whether any harm is done, i.e.\n+    // erroneously returning `true` in some cases where we could have\n+    // returned `false` does not appear unsound. The impact on\n+    // code quality is unknown at this time.)\n+\n+    let env = tcx.empty_parameter_environment();\n+    if !tcx.type_needs_drop_given_env(t, &env) {\n+        return false;\n+    }\n+    match t.sty {\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            let typ = t.boxed_ty();\n+            if !tcx.type_needs_drop_given_env(typ, &env) && type_is_sized(tcx, typ) {\n+                tcx.infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n+                    let layout = t.layout(&infcx).unwrap();\n+                    if layout.size(&tcx.data_layout).bytes() == 0 {\n+                        // `Box<ZeroSizeType>` does not allocate.\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                })\n+            } else {\n+                true\n+            }\n+        }\n+        _ => true\n+    }\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+) -> ty::Instance<'tcx> {\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+                                    rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(tcx, DUMMY_SP, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        ::rustc::traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = ::rustc::traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            ty::Instance::new(def_id, substs)\n+        }\n+        ::rustc::traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n+                            trait_closure_kind)\n+        }\n+        ::rustc::traits::VtableFnPointer(ref data) => {\n+            ty::Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n+            }\n+        }\n+        ::rustc::traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            ty::Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n+            }\n+        }\n+        _ => {\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n+        }\n+    }\n+}\n+\n+pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        def_id: DefId,\n+                        substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx>\n+{\n+    let ty = tcx.item_type(def_id);\n+    apply_param_substs(tcx, substs, &ty)\n+}\n+\n+/// Monomorphizes a type from the AST by first applying the in-scope\n+/// substitutions and then normalizing any associated types.\n+pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n+    where T: ::rustc::infer::TransNormalize<'tcx>\n+{\n+    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+    let substituted = value.subst(tcx, param_substs);\n+    let substituted = tcx.erase_regions(&substituted);\n+    AssociatedTypeNormalizer{ tcx }.fold(&substituted)\n+}\n+\n+\n+struct AssociatedTypeNormalizer<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> AssociatedTypeNormalizer<'a, 'tcx> {\n+    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ::rustc::ty::fold::TypeFolder<'tcx, 'tcx> for AssociatedTypeNormalizer<'a, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.tcx.normalize_associated_type(&ty)\n+        }\n+    }\n+}\n+\n+fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    // generics are weird, don't run this function on a generic\n+    assert!(!ty.needs_subst());\n+    ty.is_sized(tcx, &tcx.empty_parameter_environment(), DUMMY_SP)\n+}\n+\n+/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n+/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n+/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n+fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                span: Span,\n+                                trait_ref: ty::PolyTraitRef<'tcx>)\n+                                -> traits::Vtable<'tcx, ()>\n+{\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n+\n+    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+            trait_ref, trait_ref.def_id());\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        let obligation_cause = traits::ObligationCause::misc(span,\n+                                                            ast::DUMMY_NODE_ID);\n+        let obligation = traits::Obligation::new(obligation_cause,\n+                                                    trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                        trait_ref);\n+                tcx.sess.span_fatal(span,\n+                    \"reached the recursion limit during monomorphization \\\n+                        (selection ambiguity)\");\n+            }\n+            Err(e) => {\n+                span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                            e, trait_ref)\n+            }\n+        };\n+\n+        debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+        debug!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        vtable\n+    })\n+}\n+\n+pub fn resolve_drop_in_place<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+) -> ty::Instance<'tcx>\n+{\n+    let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n+    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    resolve(tcx, def_id, substs)\n+}"}, {"sha": "45d9501458d7bc476d419768589c663f509197f6", "filename": "src/lvalue.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -1,11 +1,9 @@\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use error::EvalResult;\n+use error::{EvalError, EvalResult};\n use eval_context::{EvalContext};\n use memory::Pointer;\n use value::{PrimVal, Value};\n@@ -42,15 +40,9 @@ pub enum LvalueExtra {\n /// Uniquely identifies a specific constant or static.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n pub struct GlobalId<'tcx> {\n-    /// For a constant or static, the `DefId` of the item itself.\n-    /// For a promoted global, the `DefId` of the function they belong to.\n-    pub(super) def_id: DefId,\n-\n-    /// For statics and constants this is `Substs::empty()`, so only promoteds and associated\n-    /// constants actually have something useful here. We could special case statics and constants,\n-    /// but that would only require more branching when working with constants, and not bring any\n-    /// real benefits.\n-    pub(super) substs: &'tcx Substs<'tcx>,\n+    /// For a constant or static, the `Instance` of the item itself.\n+    /// For a promoted global, the `Instance` of the function they belong to.\n+    pub(super) instance: ty::Instance<'tcx>,\n \n     /// The index for promoted globals within their function's `Mir`.\n     pub(super) promoted: Option<mir::Promoted>,\n@@ -116,18 +108,24 @@ impl<'tcx> Global<'tcx> {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+        let ty = self.lvalue_ty(lvalue);\n         let lvalue = self.eval_lvalue(lvalue)?;\n-        Ok(self.read_lvalue(lvalue))\n-    }\n \n-    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> Value {\n+        if ty.is_never() {\n+            return Err(EvalError::Unreachable);\n+        }\n+\n         match lvalue {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Value::ByRef(ptr)\n+                Ok(Value::ByRef(ptr))\n+            }\n+            Lvalue::Local { frame, local, field } => {\n+                Ok(self.stack[frame].get_local(local, field.map(|(i, _)| i)))\n+            }\n+            Lvalue::Global(cid) => {\n+                Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n             }\n-            Lvalue::Local { frame, local, field } => self.stack[frame].get_local(local, field.map(|(i, _)| i)),\n-            Lvalue::Global(cid) => self.globals.get(&cid).expect(\"global not cached\").value,\n         }\n     }\n \n@@ -138,8 +136,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n \n             Static(ref static_) => {\n-                let substs = self.tcx.intern_substs(&[]);\n-                Lvalue::Global(GlobalId { def_id: static_.def_id, substs, promoted: None })\n+                let instance = ty::Instance::mono(self.tcx, static_.def_id);\n+                Lvalue::Global(GlobalId { instance, promoted: None })\n             }\n \n             Projection(ref proj) => return self.eval_lvalue_projection(proj),\n@@ -208,6 +206,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 (Size::from_bytes(field * elem_size), false)\n             }\n \n+            FatPointer { .. } => {\n+                let bytes = field_index as u64 * self.memory.pointer_size();\n+                let offset = Size::from_bytes(bytes);\n+                (offset, false)\n+            }\n+\n             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n         };\n "}, {"sha": "3d46d710d3dd7501fd7ed5d910affc36045f0de0", "filename": "src/memory.rs", "status": "modified", "additions": 10, "deletions": 115, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -2,9 +2,7 @@ use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque, BTreeSet};\n use std::{fmt, iter, ptr, mem, io};\n \n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, PolyFnSig, ClosureSubsts};\n-use rustc::ty::subst::Substs;\n+use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n use error::{EvalError, EvalResult};\n@@ -102,44 +100,6 @@ impl Pointer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n-/// Identifies a specific monomorphized function\n-pub struct FunctionDefinition<'tcx> {\n-    pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub sig: PolyFnSig<'tcx>,\n-}\n-\n-/// Either a concrete function, or a glue function\n-#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n-pub enum Function<'tcx> {\n-    /// A function or method created by compiling code\n-    Concrete(FunctionDefinition<'tcx>),\n-    /// Glue required to call a regular function through a Fn(Mut|Once) trait object\n-    FnDefAsTraitObject(FunctionDefinition<'tcx>),\n-    /// A drop glue function only needs to know the real type, and then miri can extract\n-    /// that type from a vtable's drop pointer.\n-    /// Instead of storing some drop function, we act as if there are no trait objects, by\n-    /// mapping trait objects to their real types before acting on them.\n-    DropGlue(ty::Ty<'tcx>),\n-    /// Glue required to treat the ptr part of a fat pointer\n-    /// as a function pointer\n-    FnPtrAsTraitObject(PolyFnSig<'tcx>),\n-    /// Glue for Closures\n-    Closure(FunctionDefinition<'tcx>),\n-    /// Glue for noncapturing closures casted to function pointers\n-    NonCaptureClosureAsFnPtr(FunctionDefinition<'tcx>),\n-}\n-\n-impl<'tcx> Function<'tcx> {\n-    pub fn expect_drop_glue_real_ty(self) -> EvalResult<'tcx, ty::Ty<'tcx>> {\n-        match self {\n-            Function::DropGlue(real_ty) => Ok(real_ty),\n-            other => Err(EvalError::ExpectedDropGlue(other)),\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -165,10 +125,10 @@ pub struct Memory<'a, 'tcx> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, Function<'tcx>>,\n+    functions: HashMap<AllocId, ty::Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n-    function_alloc_cache: HashMap<Function<'tcx>, AllocId>,\n+    function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n \n     /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n@@ -214,55 +174,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::Closure(FunctionDefinition {\n-            def_id,\n-            substs: substs.substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_ptr_from_noncapture_closure(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::NonCaptureClosureAsFnPtr(FunctionDefinition {\n-            def_id,\n-            substs: substs.substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_as_trait_glue(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n-            def_id,\n-            substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_ptr_as_trait_glue(&mut self, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnPtrAsTraitObject(sig))\n-    }\n-\n-    pub fn create_drop_glue(&mut self, ty: ty::Ty<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::DropGlue(ty))\n-    }\n-\n-    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::Concrete(FunctionDefinition {\n-            def_id,\n-            substs,\n-            sig,\n-        }))\n-    }\n-\n-    fn create_fn_alloc(&mut self, def: Function<'tcx>) -> Pointer {\n-        if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n+    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> Pointer {\n+        if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return Pointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, def);\n-        self.function_alloc_cache.insert(def, id);\n+        self.functions.insert(id, instance);\n+        self.function_alloc_cache.insert(instance, id);\n         Pointer::new(id, 0)\n     }\n \n@@ -469,7 +389,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, Function<'tcx>> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n             Some(&fndef) => Ok(fndef),\n@@ -501,28 +421,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n             let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n                 (Some(a), None) => a,\n-                (None, Some(&Function::Concrete(fn_def))) => {\n-                    trace!(\"{} {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::DropGlue(real_ty))) => {\n-                    trace!(\"{} drop glue for {}\", msg, real_ty);\n-                    continue;\n-                },\n-                (None, Some(&Function::FnDefAsTraitObject(fn_def))) => {\n-                    trace!(\"{} fn as Fn glue for {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::FnPtrAsTraitObject(fn_def))) => {\n-                    trace!(\"{} fn ptr as Fn glue (signature: {:?})\", msg, fn_def);\n-                    continue;\n-                },\n-                (None, Some(&Function::Closure(fn_def))) => {\n-                    trace!(\"{} closure glue for {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::NonCaptureClosureAsFnPtr(fn_def))) => {\n-                    trace!(\"{} non-capture closure as fn ptr glue for {}\", msg, dump_fn_def(fn_def));\n+                (None, Some(instance)) => {\n+                    trace!(\"{} {}\", msg, instance);\n                     continue;\n                 },\n                 (None, None) => {\n@@ -594,11 +494,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n-fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {\n-    let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n-    format!(\"function pointer: {}: {}\", name, fn_def.sig.skip_binder())\n-}\n-\n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {"}, {"sha": "79e940bee533ba0be7f83f1e919ce921574d40c8", "filename": "src/step.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -45,8 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             let mut new = Ok(0);\n             ConstantExtractor {\n                 span: stmt.source_info.span,\n-                substs: self.substs(),\n-                def_id: self.frame().def_id,\n+                instance: self.frame().instance,\n                 ecx: self,\n                 mir: Ref::clone(&mir),\n                 new_constants: &mut new,\n@@ -63,8 +62,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let mut new = Ok(0);\n         ConstantExtractor {\n             span: terminator.source_info.span,\n-            substs: self.substs(),\n-            def_id: self.frame().def_id,\n+            instance: self.frame().instance,\n             ecx: self,\n             mir: Ref::clone(&mir),\n             new_constants: &mut new,\n@@ -145,8 +143,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n     ecx: &'a mut EvalContext<'b, 'tcx>,\n     mir: MirRef<'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx subst::Substs<'tcx>,\n+    instance: ty::Instance<'tcx>,\n     new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n \n@@ -158,26 +155,24 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         span: Span,\n         shared: bool,\n     ) {\n-        let (def_id, substs) = self.ecx.resolve_associated_const(def_id, substs);\n-        let cid = GlobalId { def_id, substs, promoted: None };\n+        let instance = self.ecx.resolve_associated_const(def_id, substs);\n+        let cid = GlobalId { instance, promoted: None };\n         if self.ecx.globals.contains_key(&cid) {\n             return;\n         }\n         self.try(|this| {\n-            let mir = this.ecx.load_mir(def_id)?;\n+            let mir = this.ecx.load_mir(instance.def)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n             let mutable = !shared || mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe();\n             let cleanup = StackPopCleanup::MarkStatic(mutable);\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n             trace!(\"pushing stack frame for global: {}\", name);\n             this.ecx.push_stack_frame(\n-                def_id,\n+                instance,\n                 span,\n                 mir,\n-                substs,\n                 Lvalue::Global(cid),\n                 cleanup,\n-                Vec::new(),\n             )\n         });\n     }\n@@ -200,18 +195,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                if let ty::TyFnDef(..) = constant.ty.sty {\n-                    // No need to do anything here,\n-                    // because the type is the actual function, not the signature of the function.\n-                    // Thus we can simply create a zero sized allocation in `evaluate_operand`\n-                } else {\n-                    self.global_item(def_id, substs, constant.span, true);\n-                }\n+                self.global_item(def_id, substs, constant.span, true);\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n-                    def_id: self.def_id,\n-                    substs: self.substs,\n+                    instance: self.instance,\n                     promoted: Some(index),\n                 };\n                 if self.ecx.globals.contains_key(&cid) {\n@@ -220,16 +208,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 let mir = Ref::clone(&self.mir);\n                 let mir = Ref::map(mir, |mir| &mir.promoted[index]);\n                 self.try(|this| {\n-                    let ty = this.ecx.monomorphize(mir.return_ty, this.substs);\n+                    let ty = this.ecx.monomorphize(mir.return_ty, this.instance.substs);\n                     this.ecx.globals.insert(cid, Global::uninitialized(ty));\n                     trace!(\"pushing stack frame for {:?}\", index);\n-                    this.ecx.push_stack_frame(this.def_id,\n+                    this.ecx.push_stack_frame(this.instance,\n                                               constant.span,\n                                               mir,\n-                                              this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::MarkStatic(false),\n-                                              Vec::new())\n+                                              StackPopCleanup::MarkStatic(false))\n                 });\n             }\n         }"}, {"sha": "bc37730b7143896ff0761f2238f38944fb806219", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 63, "deletions": 205, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -1,224 +1,82 @@\n-use rustc::hir::def_id::DefId;\n-use rustc::traits;\n-use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{Substs, Kind};\n-use rustc::ty::{self, Ty};\n use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Kind;\n use syntax::codemap::Span;\n \n-use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, monomorphize_field_ty, StackPopCleanup};\n+use error::EvalResult;\n+use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Lvalue, LvalueExtra};\n use memory::Pointer;\n use value::PrimVal;\n use value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    /// Creates stack frames for all drop impls. See `drop` for the actual content.\n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n-        // add them to the stack in reverse order, because the impl that needs to run the last\n-        // is the one that needs to be at the bottom of the stack\n-        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n-            let mir = self.load_mir(drop_def_id)?;\n-            trace!(\"substs for drop glue: {:?}\", substs);\n-            self.push_stack_frame(\n-                drop_def_id,\n-                span,\n-                mir,\n-                substs,\n-                Lvalue::from_ptr(Pointer::zst_ptr()),\n-                StackPopCleanup::None,\n-                Vec::new(),\n-            )?;\n-            let mut arg_locals = self.frame().mir.args_iter();\n-            let first = arg_locals.next().expect(\"drop impl has self arg\");\n-            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n-            let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(self_arg, dest, ty)?;\n-        }\n-        Ok(())\n+    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+        trace!(\"drop_lvalue: {:#?}\", lval);\n+        let val = match self.force_allocation(lval)? {\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Ptr(vtable)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len as u128)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(PrimVal::Ptr(ptr)),\n+            _ => bug!(\"force_allocation broken\"),\n+        };\n+        self.drop(val, instance, ty, span)\n     }\n+    pub(crate) fn drop(&mut self, mut arg: Value, mut instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+        trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n \n-    /// push DefIds of drop impls and their argument on the given vector\n-    pub fn drop(\n-        &mut self,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx> {\n-        if !self.type_needs_drop(ty) {\n-            debug!(\"no need to drop {:?}\", ty);\n+        if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n+            trace!(\"nothing to do, aborting\");\n+            // we don't actually need to drop anything\n             return Ok(());\n         }\n-        trace!(\"need to drop {:?} at {:?}\", ty, lval);\n-\n-        match ty.sty {\n-            // special case `Box` to deallocate the inner allocation\n-            ty::TyAdt(ref def, _) if def.is_box() => {\n-                let contents_ty = ty.boxed_ty();\n-                let val = self.read_lvalue(lval);\n-                // we are going through the read_value path, because that already does all the\n-                // checks for the trait object types. We'd only be repeating ourselves here.\n-                let val = self.follow_by_ref_value(val, ty)?;\n-                trace!(\"box dealloc on {:?}\", val);\n-                match val {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n-                    Value::ByVal(ptr) => {\n-                        assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.to_ptr()?;\n-                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                    },\n-                    Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.to_ptr()?;\n-                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n-                        };\n-                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n-                    },\n-                }\n-                // We cannot use Box's destructor, because it is a no-op and only exists to reduce\n-                // the number of hacks required in the compiler around the Box type.\n-                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n-                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n-                // this is somewhat hacky, but hey, there's no representation difference between\n-                // pointers, `Box`es and references, so\n-                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n-                // is the same as\n-                // fn drop(&mut self) if Self is Box<T>\n-                drop.push((box_free_fn, val, substs));\n-            }\n-\n-            ty::TyAdt(adt_def, substs) => {\n-                // FIXME: some structs are represented as ByValPair\n-                let mut lval = self.force_allocation(lval)?;\n-                let (adt_ptr, extra) = lval.to_ptr_and_extra();\n-\n-                // run drop impl before the fields' drop impls\n-                if let Some(destructor) = adt_def.destructor(self.tcx) {\n-                    let trait_ref = ty::Binder(ty::TraitRef {\n-                        def_id: self.tcx.lang_items.drop_trait().unwrap(),\n-                        substs: self.tcx.mk_substs_trait(ty, &[]),\n-                    });\n-                    let vtable = match self.fulfill_obligation(trait_ref) {\n-                        traits::VtableImpl(data) => data,\n-                        _ => bug!(\"dtor for {:?} is not an impl???\", ty)\n-                    };\n-                    let val = match extra {\n-                        LvalueExtra::None => Value::ByVal(PrimVal::Ptr(adt_ptr)),\n-                        LvalueExtra::DowncastVariant(_) => bug!(\"downcast variant in drop\"),\n-                        LvalueExtra::Length(n) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::from_u128(n as u128)),\n-                        LvalueExtra::Vtable(vtable) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::Ptr(vtable)),\n-                    };\n-                    drop.push((destructor.did, val, vtable.substs));\n-                }\n-\n-                let layout = self.type_layout(ty)?;\n-                let fields = match *layout {\n-                    Layout::Univariant { .. } => &adt_def.struct_variant().fields,\n-                    Layout::General { .. } => {\n-                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n-                        let ptr = self.force_allocation(lval)?.to_ptr();\n-                        match adt_def.discriminants(self.tcx).position(|v| discr_val == v.to_u128_unchecked()) {\n-                            Some(i) => {\n-                                lval = Lvalue::Ptr {\n-                                    ptr,\n-                                    extra: LvalueExtra::DowncastVariant(i),\n-                                };\n-                                &adt_def.variants[i].fields\n-                            },\n-                            None => return Err(EvalError::InvalidDiscriminant),\n-                        }\n-                    },\n-                    Layout::StructWrappedNullablePointer { .. } |\n-                    Layout::RawNullablePointer { .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        assert_eq!(discr as usize as u128, discr);\n-                        &adt_def.variants[discr as usize].fields\n-                    },\n-                    Layout::CEnum { .. } => return Ok(()),\n-                    _ => bug!(\"{:?} is not an adt layout\", layout),\n-                };\n-                let tcx = self.tcx;\n-                self.drop_fields(\n-                    fields.iter().map(|field| monomorphize_field_ty(tcx, field, substs)),\n-                    lval,\n-                    ty,\n-                    drop,\n-                )?;\n-            }\n-\n-            ty::TyTuple(fields, _) =>\n-                self.drop_fields(fields.into_iter().cloned(), lval, ty, drop)?,\n-\n+        let mir = match ty.sty {\n             ty::TyDynamic(..) => {\n-                let (ptr, vtable) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n-                    _ => bug!(\"expected an lvalue with a vtable\"),\n+                let vtable = match arg {\n+                    Value::ByValPair(_, PrimVal::Ptr(vtable)) => vtable,\n+                    _ => bug!(\"expected fat ptr, got {:?}\", arg),\n                 };\n-                if let Some(real_ty) = self.read_drop_type_from_vtable(vtable)? {\n-                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                }\n-            }\n-\n-            ty::TySlice(elem_ty) => {\n-                let (ptr, len) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n-                    _ => bug!(\"expected an lvalue with a length\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..len {\n-                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n+                match self.read_drop_type_from_vtable(vtable)? {\n+                    Some(func) => {\n+                        instance = func;\n+                        self.load_mir(func.def)?\n+                    },\n+                    // no drop fn -> bail out\n+                    None => return Ok(()),\n                 }\n-            }\n-\n-            ty::TyArray(elem_ty, len) => {\n-                let lval = self.force_allocation(lval)?;\n-                let (ptr, extra) = match lval {\n-                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-                    _ => bug!(\"expected an lvalue with optional extra data\"),\n+            },\n+            ty::TyArray(elem, n) => {\n+                instance.substs = self.tcx.mk_substs([\n+                    Kind::from(elem),\n+                ].iter().cloned());\n+                let ptr = match arg {\n+                    Value::ByVal(PrimVal::Ptr(src_ptr)) => src_ptr,\n+                    _ => bug!(\"expected thin ptr, got {:?}\", arg),\n                 };\n-                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..(len as u64) {\n-                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n-                }\n-            }\n-\n-            ty::TyClosure(def_id, substs) => {\n-                let fields = substs.upvar_tys(def_id, self.tcx);\n-                self.drop_fields(fields, lval, ty, drop)?;\n-            }\n-\n-            _ => bug!(),\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn drop_fields<I>(\n-        &mut self,\n-        fields: I,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx>\n-        where I: Iterator<Item=Ty<'tcx>>,\n-    {\n-        trace!(\"drop_fields: {:?} of type {}\", lval, ty);\n-        for (i, field_ty) in fields.enumerate() {\n-            let field_lval = self.lvalue_field(lval, i, ty, field_ty)?;\n-            self.drop(field_lval, field_ty, drop)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+                arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(n as u128));\n+                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+            },\n+            ty::TySlice(elem) => {\n+                instance.substs = self.tcx.mk_substs([\n+                    Kind::from(elem),\n+                ].iter().cloned());\n+                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+            },\n+            _ => self.load_mir(instance.def)?,\n+        };\n+\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            Lvalue::from_ptr(Pointer::zst_ptr()),\n+            StackPopCleanup::None,\n+        )?;\n+\n+        let mut arg_locals = self.frame().mir.args_iter();\n+        assert_eq!(self.frame().mir.arg_count, 1);\n+        let arg_local = arg_locals.next().unwrap();\n+        let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+        let arg_ty = self.tcx.mk_mut_ptr(ty);\n+        self.write_value(arg, dest, arg_ty)\n     }\n }"}, {"sha": "bf5623e485bfeb01c771d77e2c07df6b0089148f", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -1,4 +1,3 @@\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Layout, Size, Align};\n use rustc::ty::subst::Substs;\n@@ -13,8 +12,7 @@ use value::{PrimVal, PrimValKind, Value};\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n         &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n@@ -30,8 +28,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let usize = self.tcx.types.usize;\n         let f32 = self.tcx.types.f32;\n         let f64 = self.tcx.types.f64;\n+        let substs = instance.substs;\n \n-        let intrinsic_name = &self.tcx.item_name(def_id).as_str()[..];\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"add_with_overflow\" =>\n                 self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?,\n@@ -171,35 +170,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n \n-            \"drop_in_place\" => {\n-                let ty = substs.type_at(0);\n-                trace!(\"drop in place on {}\", ty);\n-                let ptr_ty = self.tcx.mk_mut_ptr(ty);\n-                let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n-                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()?),\n-                    Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n-                        ptr: ptr.to_ptr()?,\n-                        extra: match self.tcx.struct_tail(ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ptr_ty),\n-                        },\n-                    },\n-                };\n-                let mut drops = Vec::new();\n-                self.drop(lvalue, ty, &mut drops)?;\n-                let span = {\n-                    let frame = self.frame();\n-                    frame.mir[frame.block].terminator().source_info.span\n-                };\n-                // need to change the block before pushing the drop impl stack frames\n-                // we could do this for all intrinsics before evaluating the intrinsics, but if\n-                // the evaluation fails, we should not have moved forward\n-                self.goto_block(target);\n-                return self.eval_drop_impls(drops, span);\n-            }\n-\n             \"sinf32\" | \"fabsf32\" | \"cosf32\" |\n             \"sqrtf32\" | \"expf32\" | \"exp2f32\" |\n             \"logf32\" | \"log10f32\" | \"log2f32\" |"}, {"sha": "03804ccd0bd5137e920cd66dcc6f1a1f3f9a9f88", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 223, "deletions": 200, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -1,22 +1,21 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n-use rustc_const_math::ConstInt;\n+use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::attr;\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, FunctionDefinition, Function};\n+use memory::Pointer;\n use value::PrimVal;\n use value::Value;\n+use rustc_data_structures::indexed_vec::Idx;\n \n-mod intrinsic;\n mod drop;\n+mod intrinsic;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n@@ -63,67 +62,50 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let func_ty = self.operand_ty(func);\n-                let fn_def = match func_ty.sty {\n-                    ty::TyFnPtr(bare_sig) => {\n-                        let bare_sig = self.erase_lifetimes(&bare_sig);\n+                let (fn_def, sig) = match func_ty.sty {\n+                    ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                        match fn_def {\n-                            Function::Concrete(fn_def) => {\n-                                // transmuting function pointers in miri is fine as long as the number of\n-                                // arguments and the abi don't change.\n-                                let sig = self.erase_lifetimes(&fn_def.sig);\n-                                if sig.abi != bare_sig.abi ||\n-                                    sig.variadic != bare_sig.variadic ||\n-                                    sig.inputs_and_output != bare_sig.inputs_and_output {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                }\n-                            },\n-                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                let sig = self.erase_lifetimes(&fn_def.sig);\n-                                assert_eq!(sig.abi, Abi::RustCall);\n-                                if sig.variadic != bare_sig.variadic ||\n-                                    sig.inputs().len() != 1 {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                }\n-                                if let ty::TyTuple(fields, _) = sig.inputs()[0].sty {\n-                                    if **fields != *bare_sig.inputs() {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                    }\n-                                } else {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n+                        let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let instance_ty = instance.def.def_ty(self.tcx);\n+                        let instance_ty = self.monomorphize(instance_ty, instance.substs);\n+                        match instance_ty.sty {\n+                            ty::TyFnDef(_, _, real_sig) => {\n+                                let sig = self.erase_lifetimes(&sig);\n+                                let real_sig = self.erase_lifetimes(&real_sig);\n+                                match instance.def {\n+                                    // FIXME: this needs checks for weird transmutes\n+                                    // we need to bail here, because noncapturing closures as fn ptrs fail the checks\n+                                    ty::InstanceDef::ClosureOnceShim{..} => {}\n+                                    _ => if sig.abi != real_sig.abi ||\n+                                        sig.variadic != real_sig.variadic ||\n+                                        sig.inputs_and_output != real_sig.inputs_and_output {\n+                                        return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n+                                    },\n                                 }\n                             },\n-                            other => return Err(EvalError::ExpectedConcreteFunction(other)),\n+                            ref other => bug!(\"instance def ty: {:?}\", other),\n                         }\n-                        self.memory.get_fn(fn_ptr.alloc_id)?\n+                        (instance, sig)\n                     },\n-                    ty::TyFnDef(def_id, substs, fn_ty) => Function::Concrete(FunctionDefinition {\n-                        def_id,\n-                        substs,\n-                        sig: fn_ty,\n-                    }),\n-\n+                    ty::TyFnDef(def_id, substs, sig) => (::eval_context::resolve(self.tcx, def_id, substs), sig),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return Err(EvalError::Unimplemented(msg));\n                     }\n                 };\n-                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span)?;\n+                let sig = self.erase_lifetimes(&sig);\n+                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span, sig)?;\n             }\n \n             Drop { ref location, target, .. } => {\n+                trace!(\"TerminatorKind::drop: {:?}, {:?}\", location, self.substs());\n                 let lval = self.eval_lvalue(location)?;\n-\n                 let ty = self.lvalue_ty(location);\n-\n-                // we can't generate the drop stack frames on the fly,\n-                // because that would change our call stack\n-                // and very much confuse the further processing of the drop glue\n-                let mut drops = Vec::new();\n-                self.drop(lval, ty, &mut drops)?;\n                 self.goto_block(target);\n-                self.eval_drop_impls(drops, terminator.source_info.span)?;\n+                let ty = ::eval_context::apply_param_substs(self.tcx, self.substs(), &ty);\n+\n+                let instance = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n+                self.drop_lvalue(lval, instance, ty, terminator.source_info.span)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n@@ -158,162 +140,241 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn eval_fn_call(\n         &mut self,\n-        fn_def: Function<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n+        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        use syntax::abi::Abi;\n-        match fn_def {\n-            // Intrinsics can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustIntrinsic => {\n-                let sig = self.erase_lifetimes(&sig);\n-                let ty = sig.output();\n-                let layout = self.type_layout(ty)?;\n+        trace!(\"eval_fn_call: {:#?}\", instance);\n+        match instance.def {\n+            ty::InstanceDef::Intrinsic(..) => {\n                 let (ret, target) = match destination {\n-                    Some(dest) if is_inhabited(self.tcx, ty) => dest,\n+                    Some(dest) => dest,\n                     _ => return Err(EvalError::Unreachable),\n                 };\n-                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n-                self.dump_local(ret);\n-                Ok(())\n-            },\n-            // C functions can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, sig, ..}) if sig.abi() == Abi::C => {\n-                let sig = self.erase_lifetimes(&sig);\n                 let ty = sig.output();\n-                let (ret, target) = destination.unwrap();\n-                self.call_c_abi(def_id, arg_operands, ret, ty)?;\n+                if !is_inhabited(self.tcx, ty) {\n+                    return Err(EvalError::Unreachable);\n+                }\n+                let layout = self.type_layout(ty)?;\n+                self.call_intrinsic(instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n-                self.goto_block(target);\n                 Ok(())\n             },\n-            Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-            Function::Concrete(FunctionDefinition { def_id, sig, substs }) if sig.abi() == Abi::Rust || sig.abi() == Abi::RustCall => {\n+            ty::InstanceDef::ClosureOnceShim{..} => {\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n+                }\n+                if self.eval_fn_call_inner(\n+                    instance,\n+                    destination,\n+                    span,\n+                )? {\n+                    return Ok(());\n+                }\n+                let mut arg_locals = self.frame().mir.args_iter();\n+                match sig.abi {\n+                    // closure as closure once\n+                    Abi::RustCall => {\n+                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n+                    },\n+                    // non capture closure as fn ptr\n+                    // need to inject zst ptr for closure object (aka do nothing)\n+                    // and need to pack arguments\n+                    Abi::Rust => {\n+                        trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n+                        trace!(\"arg_operands: {:?}\", arg_operands);\n+                        let local = arg_locals.nth(1).unwrap();\n+                        for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(local).field(mir::Field::new(i), arg_ty))?;\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n+                    },\n+                    _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n+                }\n+                Ok(())\n+            }\n+            ty::InstanceDef::Item(_) => {\n+                match sig.abi {\n+                    Abi::C => {\n+                        let ty = sig.output();\n+                        let (ret, target) = destination.unwrap();\n+                        self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n+                        self.dump_local(ret);\n+                        self.goto_block(target);\n+                        return Ok(());\n+                    },\n+                    Abi::Rust | Abi::RustCall => {},\n+                    _ => unimplemented!(),\n+                }\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n \n-                // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs, temporaries) =\n-                    if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs, &mut args)?\n-                    } else {\n-                        (def_id, substs, Vec::new())\n-                    };\n-\n-                // FIXME(eddyb) Detect ADT constructors more efficiently.\n-                if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n-                    let dids = adt_def.variants.iter().map(|v| v.did);\n-                    let discrs = adt_def.discriminants(self.tcx).map(ConstInt::to_u128_unchecked);\n-                    if let Some((_, disr_val)) = dids.zip(discrs).find(|&(did, _)| resolved_def_id == did) {\n-                        let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n-                        let dest_ty = self.tcx.item_type(adt_def.did);\n-                        let dest_layout = self.type_layout(dest_ty)?;\n-                        trace!(\"layout({:?}) = {:#?}\", dest_ty, dest_layout);\n-                        match *dest_layout {\n-                            Layout::Univariant { .. } => {\n-                                assert_eq!(disr_val, 0);\n-                                self.assign_fields(lvalue, dest_ty, args)?;\n-                            },\n-                            Layout::General { discr, ref variants, .. } => {\n-                                let discr_size = discr.size().bytes();\n-                                self.assign_discr_and_fields(\n-                                    lvalue,\n-                                    dest_ty,\n-                                    variants[disr_val as usize].offsets[0].bytes(),\n-                                    args,\n-                                    disr_val,\n-                                    disr_val as usize,\n-                                    discr_size,\n-                                )?;\n-                            },\n-                            Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                                if nndiscr as u128 == disr_val {\n-                                    self.assign_fields(lvalue, dest_ty, args)?;\n-                                } else {\n-                                    for (_, ty) in args {\n-                                        assert_eq!(self.type_size(ty)?, Some(0));\n-                                    }\n-                                    let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                if self.eval_fn_call_inner(\n+                    instance,\n+                    destination,\n+                    span,\n+                )? {\n+                    return Ok(());\n+                }\n \n-                                    // FIXME(solson)\n-                                    let dest = self.force_allocation(lvalue)?.to_ptr();\n+                let mut arg_locals = self.frame().mir.args_iter();\n+                trace!(\"ABI: {:?}\", sig.abi);\n+                trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n+                trace!(\"arg_operands: {:?}\", arg_operands);\n+                match sig.abi {\n+                    Abi::Rust => {\n+                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n+                    }\n+                    Abi::RustCall => {\n+                        assert_eq!(args.len(), 2);\n+\n+                        {   // write first argument\n+                            let first_local = arg_locals.next().unwrap();\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(first_local))?;\n+                            let (arg_val, arg_ty) = args.remove(0);\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n \n-                                    let dest = dest.offset(offset.bytes());\n-                                    let dest_size = self.type_size(ty)?\n-                                        .expect(\"bad StructWrappedNullablePointer discrfield\");\n-                                    self.memory.write_int(dest, 0, dest_size)?;\n+                        // unpack and write all other args\n+                        let (arg_val, arg_ty) = args.remove(0);\n+                        let layout = self.type_layout(arg_ty)?;\n+                        if let (&ty::TyTuple(fields, _), &Layout::Univariant { ref variant, .. }) = (&arg_ty.sty, layout) {\n+                            trace!(\"fields: {:?}\", fields);\n+                            if self.frame().mir.args_iter().count() == fields.len() + 1 {\n+                                let offsets = variant.offsets.iter().map(|s| s.bytes());\n+                                match arg_val {\n+                                    Value::ByRef(ptr) => {\n+                                        for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n+                                            let arg = Value::ByRef(ptr.offset(offset));\n+                                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                                            trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n+                                            self.write_value(arg, dest, ty)?;\n+                                        }\n+                                    },\n+                                    Value::ByVal(PrimVal::Undef) => {},\n+                                    other => {\n+                                        assert_eq!(fields.len(), 1);\n+                                        let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_locals.next().unwrap()))?;\n+                                        self.write_value(other, dest, fields[0])?;\n+                                    }\n                                 }\n-                            },\n-                            Layout::RawNullablePointer { .. } => {\n-                                assert_eq!(args.len(), 1);\n-                                let (val, ty) = args.pop().unwrap();\n-                                self.write_value(val, lvalue, ty)?;\n-                            },\n-                            _ => bug!(\"bad layout for tuple struct constructor: {:?}\", dest_layout),\n+                            } else {\n+                                trace!(\"manual impl of rust-call ABI\");\n+                                // called a manual impl of a rust-call function\n+                                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_locals.next().unwrap()))?;\n+                                self.write_value(arg_val, dest, arg_ty)?;\n+                            }\n+                        } else {\n+                            bug!(\"rust-call ABI tuple argument was {:?}, {:?}\", arg_ty, layout);\n                         }\n-                        self.goto_block(target);\n-                        return Ok(());\n                     }\n+                    _ => unimplemented!(),\n                 }\n-                self.eval_fn_call_inner(\n-                    resolved_def_id,\n-                    resolved_substs,\n-                    destination,\n-                    args,\n-                    temporaries,\n-                    span,\n-                )\n+                Ok(())\n             },\n-            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustCall => {\n-                let sig = self.erase_lifetimes(&sig);\n+            ty::InstanceDef::DropGlue(..) => {\n+                assert_eq!(arg_operands.len(), 1);\n+                assert_eq!(sig.abi, Abi::Rust);\n+                let val = self.eval_operand(&arg_operands[0])?;\n+                let ty = self.operand_ty(&arg_operands[0]);\n+                let (_, target) = destination.expect(\"diverging drop glue\");\n+                self.goto_block(target);\n+                // FIXME: deduplicate these matches\n+                let pointee_type = match ty.sty {\n+                    ty::TyRawPtr(ref tam) |\n+                    ty::TyRef(_, ref tam) => tam.ty,\n+                    ty::TyAdt(ref def, _) if def.is_box() => ty.boxed_ty(),\n+                    _ => bug!(\"can only deref pointer types\"),\n+                };\n+                self.drop(val, instance, pointee_type, span)\n+            },\n+            ty::InstanceDef::FnPtrShim(..) => {\n+                trace!(\"ABI: {}\", sig.abi);\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                args.insert(0, (\n-                    Value::ByVal(PrimVal::Undef),\n-                    sig.inputs()[0],\n-                ));\n-                self.eval_fn_call_inner(\n-                    def_id,\n-                    substs,\n+                if self.eval_fn_call_inner(\n+                    instance,\n+                    destination,\n+                    span,\n+                )? {\n+                    return Ok(());\n+                }\n+                let arg_locals = self.frame().mir.args_iter();\n+                match sig.abi {\n+                    Abi::Rust => {\n+                        args.remove(0);\n+                    },\n+                    Abi::RustCall => {},\n+                    _ => unimplemented!(),\n+                };\n+                for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                    self.write_value(arg_val, dest, arg_ty)?;\n+                }\n+                Ok(())\n+            },\n+            ty::InstanceDef::Virtual(_, idx) => {\n+                let ptr_size = self.memory.pointer_size();\n+                let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3)))?;\n+                let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                let mut arg_operands = arg_operands.to_vec();\n+                let ty = self.operand_ty(&arg_operands[0]);\n+                let ty = self.get_field_ty(ty, 0)?;\n+                match arg_operands[0] {\n+                    mir::Operand::Consume(ref mut lval) => *lval = lval.clone().field(mir::Field::new(0), ty),\n+                    _ => bug!(\"virtual call first arg cannot be a constant\"),\n+                }\n+                // recurse with concrete function\n+                self.eval_fn_call(\n+                    instance,\n                     destination,\n-                    args,\n-                    Vec::new(),\n+                    &arg_operands,\n                     span,\n+                    sig,\n                 )\n-            }\n-            Function::Concrete(fn_def) => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", fn_def.sig.abi()))),\n-            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:#?}\", other))),\n+            },\n         }\n     }\n \n+    /// Returns Ok(true) when the function was handled completely due to mir not being available\n     fn eval_fn_call_inner(\n         &mut self,\n-        resolved_def_id: DefId,\n-        resolved_substs: &'tcx Substs,\n+        instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        args: Vec<(Value, Ty<'tcx>)>,\n-        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n         span: Span,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"eval_fn_call_inner: {:#?}, {:#?}, {:#?}\", args, temporaries, destination);\n+    ) -> EvalResult<'tcx, bool> {\n+        trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", instance, destination);\n \n-        let mir = match self.load_mir(resolved_def_id) {\n+        // Only trait methods can have a Self parameter.\n+\n+        let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n                 match &path[..] {\n                     // let's just ignore all output for now\n                     \"std::io::_print\" => {\n                         self.goto_block(destination.unwrap().1);\n-                        return Ok(());\n+                        return Ok(true);\n                     },\n                     \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n                     \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n@@ -326,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let bool = self.tcx.types.bool;\n                         self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n                         self.goto_block(block);\n-                        return Ok(());\n+                        return Ok(true);\n                     }\n                     _ => {},\n                 }\n@@ -344,23 +405,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n \n         self.push_stack_frame(\n-            resolved_def_id,\n+            instance,\n             span,\n             mir,\n-            resolved_substs,\n             return_lvalue,\n             return_to_block,\n-            temporaries,\n         )?;\n \n-        let arg_locals = self.frame().mir.args_iter();\n-        assert_eq!(self.frame().mir.arg_count, args.len());\n-        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-            self.write_value(arg_val, dest, arg_ty)?;\n-        }\n-\n-        Ok(())\n+        Ok(false)\n     }\n \n     pub fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n@@ -529,34 +581,5 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // as if the call just completed and it's returning to the\n         // current frame.\n         Ok(())\n-    }\n-\n-    pub(crate) fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n-        if let Some((last, last_ty)) = args.pop() {\n-            let last_layout = self.type_layout(last_ty)?;\n-            match (&last_ty.sty, last_layout) {\n-                (&ty::TyTuple(fields, _),\n-                 &Layout::Univariant { ref variant, .. }) => {\n-                    let offsets = variant.offsets.iter().map(|s| s.bytes());\n-                    match last {\n-                        Value::ByRef(last_ptr) => {\n-                            for (offset, ty) in offsets.zip(fields) {\n-                                let arg = Value::ByRef(last_ptr.offset(offset));\n-                                args.push((arg, ty));\n-                            }\n-                        },\n-                        // propagate undefs\n-                        undef @ Value::ByVal(PrimVal::Undef) => {\n-                            for field_ty in fields {\n-                                args.push((undef, field_ty));\n-                            }\n-                        },\n-                        _ => bug!(\"rust-call ABI tuple argument was {:?}, but {:?} were expected\", last, fields),\n-                    }\n-                }\n-                ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-            }\n-        }\n-        Ok(())\n-    }\n+    }   \n }"}, {"sha": "77541a5b70fb4e7f254734b9521e4065db2e9434", "filename": "src/traits.rs", "status": "modified", "additions": 20, "deletions": 423, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -1,178 +1,17 @@\n-use rustc::traits::{self, Reveal, SelectionContext};\n+use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n use memory::Pointer;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n-use syntax::{ast, abi};\n+use syntax::ast;\n \n-use error::{EvalError, EvalResult};\n-use memory::Function;\n-use value::PrimVal;\n-use value::Value;\n+use error::EvalResult;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub(crate) fn trait_method(\n-        &mut self,\n-        trait_id: DefId,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<(Pointer, Ty<'tcx>)>)> {\n-        let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n-        let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n-\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n-\n-                Ok((did, substs, Vec::new()))\n-            }\n-\n-            traits::VtableClosure(vtable_closure) => {\n-                let trait_closure_kind = self.tcx\n-                    .lang_items\n-                    .fn_trait_kind(trait_id)\n-                    .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n-                let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n-                trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n-                self.unpack_fn_args(args)?;\n-                let mut temporaries = Vec::new();\n-                match (closure_kind, trait_closure_kind) {\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-                    (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n-\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                        // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n-                        // We want a `fn(self, ...)`.\n-                        // We can produce this by doing something like:\n-                        //\n-                        //     fn call_once(self, ...) { call_mut(&self, ...) }\n-                        //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-                        //\n-                        // These are both the same at trans time.\n-\n-                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n-                        // intermediate function call.\n-                        let ptr = match args[0].0 {\n-                            Value::ByRef(ptr) => ptr,\n-                            Value::ByVal(primval) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                let size = self.type_size(args[0].1)?.expect(\"closures are sized\");\n-                                self.memory.write_primval(ptr, primval, size)?;\n-                                ptr\n-                            },\n-                            Value::ByValPair(a, b) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n-                                ptr\n-                            },\n-                        };\n-                        temporaries.push((ptr, args[0].1));\n-                        args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n-                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n-                    }\n-\n-                    _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n-                }\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n-            }\n-\n-            traits::VtableFnPointer(vtable_fn_ptr) => {\n-                if let ty::TyFnDef(did, substs, _) = vtable_fn_ptr.fn_ty.sty {\n-                    args.remove(0);\n-                    self.unpack_fn_args(args)?;\n-                    Ok((did, substs, Vec::new()))\n-                } else {\n-                    bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n-                }\n-            }\n-\n-            traits::VtableObject(ref data) => {\n-                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n-                if args.is_empty() {\n-                    return Err(EvalError::VtableForArgumentlessMethod);\n-                }\n-                let (self_ptr, vtable) = args[0].0.expect_ptr_vtable_pair(&self.memory)?;\n-                let idx = idx + 3;\n-                let offset = idx * self.memory.pointer_size();\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n-                trace!(\"args: {:#?}\", args);\n-                match self.memory.get_fn(fn_ptr.alloc_id)? {\n-                    Function::FnDefAsTraitObject(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n-                        assert!(fn_def.sig.abi() != abi::Abi::RustCall);\n-                        assert_eq!(args.len(), 2);\n-                        // a function item turned into a closure trait object\n-                        // the first arg is just there to give use the vtable\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-                    Function::Concrete(fn_def) => {\n-                        let sig = self.erase_lifetimes(&fn_def.sig);\n-                        trace!(\"sig: {:#?}\", sig);\n-                        args[0] = (\n-                            Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            sig.inputs()[0],\n-                        );\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                        let sig = self.erase_lifetimes(&fn_def.sig);\n-                        args.insert(0, (\n-                            Value::ByVal(PrimVal::Undef),\n-                            sig.inputs()[0],\n-                        ));\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                    Function::Closure(fn_def) => {\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                    Function::FnPtrAsTraitObject(sig) => {\n-                        let sig = self.erase_lifetimes(&sig);\n-                        trace!(\"sig: {:#?}\", sig);\n-                        // the first argument was the fat ptr\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        let fn_ptr = self.memory.read_ptr(self_ptr)?;\n-                        let fn_def = match self.memory.get_fn(fn_ptr.alloc_id)? {\n-                            Function::Concrete(fn_def) => {\n-                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n-                                assert_eq!(sig, fn_def_sig);\n-                                fn_def\n-                            },\n-                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n-                                args.insert(0, (\n-                                    Value::ByVal(PrimVal::Undef),\n-                                    fn_def_sig.inputs()[0],\n-                                ));\n-                                fn_def\n-                            },\n-                            other => bug!(\"FnPtrAsTraitObject for {:?}\", other),\n-                        };\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                }\n-            },\n-            vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n-    }\n \n     pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n@@ -202,106 +41,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// The `trait_ref` encodes the erased self type. Hence if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n-    pub fn get_vtable(&mut self, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        let tcx = self.tcx;\n-\n+    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n-        let methods: Vec<_> = traits::supertraits(tcx, trait_ref).flat_map(|trait_ref| {\n-            match self.fulfill_obligation(trait_ref) {\n-                // Should default trait error here?\n-                traits::VtableDefaultImpl(_) |\n-                traits::VtableBuiltin(_) => {\n-                    Vec::new().into_iter()\n-                }\n-\n-                traits::VtableImpl(traits::VtableImplData { impl_def_id: id, substs, .. }) => {\n-                    self.get_vtable_methods(id, substs)\n-                        .into_iter()\n-                        .map(|opt_mth| opt_mth.map(|mth| {\n-                            let fn_ty = self.tcx.item_type(mth.method.def_id);\n-                            let fn_ty = match fn_ty.sty {\n-                                ty::TyFnDef(_, _, fn_ty) => fn_ty,\n-                                _ => bug!(\"bad function type: {}\", fn_ty),\n-                            };\n-                            let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, fn_ty)\n-                        }))\n-                        .collect::<Vec<_>>()\n-                        .into_iter()\n-                }\n-\n-                traits::VtableClosure(\n-                    traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        ..\n-                    }\n-                ) => {\n-                    let closure_type = self.tcx.closure_type(closure_def_id);\n-                    vec![Some(self.memory.create_closure_ptr(closure_def_id, substs, closure_type))].into_iter()\n-                }\n-\n-                // turn a function definition into a Fn trait object\n-                traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n-                    match fn_ty.sty {\n-                        ty::TyFnDef(did, substs, bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_as_trait_glue(did, substs, bare_fn_ty))].into_iter()\n-                        },\n-                        ty::TyFnPtr(bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_ptr_as_trait_glue(bare_fn_ty))].into_iter()\n-                        },\n-                        _ => bug!(\"bad VtableFnPointer fn_ty: {:#?}\", fn_ty.sty),\n-                    }\n-                }\n-\n-                traits::VtableObject(ref data) => {\n-                    // this would imply that the Self type being erased is\n-                    // an object type; this cannot happen because we\n-                    // cannot cast an unsized type into a trait object\n-                    bug!(\"cannot get vtable for an object type: {:?}\",\n-                         data);\n-                }\n-\n-                vtable @ traits::VtableParam(..) => {\n-                    bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                         trait_ref,\n-                         vtable);\n-                }\n-            }\n-        }).collect();\n-\n         let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n         let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.len() as u64), ptr_size)?;\n+        let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size)?;\n \n-        // in case there is no drop function to be called, this still needs to be initialized\n-        self.memory.write_usize(vtable, 0)?;\n-        if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n-            if let Some(destructor) = adt_def.destructor(self.tcx) {\n-                let fn_ty = match self.tcx.item_type(destructor.did).sty {\n-                    ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n-                    _ => bug!(\"drop method is not a TyFnDef\"),\n-                };\n-                let fn_ty = self.erase_lifetimes(&fn_ty);\n-                // The real type is taken from the self argument in `fn drop(&mut self)`\n-                let real_ty = match fn_ty.inputs()[0].sty {\n-                    ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n-                    _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n-                };\n-                let fn_ptr = self.memory.create_drop_glue(real_ty);\n-                self.memory.write_ptr(vtable, fn_ptr)?;\n-            }\n-        }\n+        let drop = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n+        let drop = self.memory.create_fn_alloc(drop);\n+        self.memory.write_ptr(vtable, drop)?;\n \n         self.memory.write_usize(vtable.offset(ptr_size), size)?;\n         self.memory.write_usize(vtable.offset(ptr_size * 2), align)?;\n \n-        for (i, method) in methods.into_iter().enumerate() {\n-            if let Some(method) = method {\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), method)?;\n+        for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n+            if let Some((def_id, substs)) = method {\n+                let instance = ::eval_context::resolve(self.tcx, def_id, substs);\n+                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), fn_ptr)?;\n             }\n         }\n \n@@ -310,7 +71,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(vtable)\n     }\n \n-    pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<Ty<'tcx>>> {\n+    pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         let drop_fn = self.memory.read_ptr(vtable)?;\n \n         // just a sanity check\n@@ -320,7 +81,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         if drop_fn == Pointer::from_int(0) {\n             Ok(None)\n         } else {\n-            self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue_real_ty().map(Some)\n+            self.memory.get_fn(drop_fn.alloc_id).map(Some)\n         }\n     }\n \n@@ -331,99 +92,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok((size, align))\n     }\n \n-    fn get_vtable_methods(&mut self, impl_id: DefId, substs: &'tcx Substs<'tcx>) -> Vec<Option<ImplMethod<'tcx>>> {\n-        debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n-\n-        let trait_id = match self.tcx.impl_trait_ref(impl_id) {\n-            Some(t_id) => t_id.def_id,\n-            None       => bug!(\"make_impl_vtable: don't know how to \\\n-                                make a vtable for a type impl!\")\n-        };\n-\n-        self.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-\n-        self.tcx\n-            .associated_items(trait_id)\n-            // Filter out non-method items.\n-            .filter_map(|trait_method_type| {\n-                if trait_method_type.kind != ty::AssociatedKind::Method {\n-                    return None;\n-                }\n-                debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                       trait_method_type);\n-\n-                let name = trait_method_type.name;\n-\n-                // Some methods cannot be called on an object; skip those.\n-                if !self.tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n-                    debug!(\"get_vtable_methods: not vtable safe\");\n-                    return Some(None);\n-                }\n-\n-                debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                       trait_method_type);\n-\n-                // the method may have some early-bound lifetimes, add\n-                // regions for those\n-                let method_substs = Substs::for_item(self.tcx, trait_method_type.def_id,\n-                                                     |_, _| self.tcx.mk_region(ty::ReErased),\n-                                                     |_, _| self.tcx.types.err);\n-\n-                // The substitutions we have are on the impl, so we grab\n-                // the method type from the impl to substitute into.\n-                let mth = get_impl_method(self.tcx, method_substs, impl_id, substs, name);\n-\n-                debug!(\"get_vtable_methods: mth={:?}\", mth);\n-\n-                // If this is a default method, it's possible that it\n-                // relies on where clauses that do not hold for this\n-                // particular set of type parameters. Note that this\n-                // method could then never be called, so we do not want to\n-                // try and trans it, in that case. Issue #23435.\n-                if mth.is_provided {\n-                    let predicates = self.tcx.item_predicates(trait_method_type.def_id).instantiate_own(self.tcx, mth.substs);\n-                    if !self.normalize_and_test_predicates(predicates.predicates) {\n-                        debug!(\"get_vtable_methods: predicates do not hold\");\n-                        return Some(None);\n-                    }\n-                }\n-\n-                Some(Some(mth))\n-            })\n-            .collect()\n-    }\n-\n-    /// Normalizes the predicates and checks whether they hold.  If this\n-    /// returns false, then either normalize encountered an error or one\n-    /// of the predicates did not hold. Used when creating vtables to\n-    /// check for unsatisfiable methods.\n-    fn normalize_and_test_predicates(&mut self, predicates: Vec<ty::Predicate<'tcx>>) -> bool {\n-        debug!(\"normalize_and_test_predicates(predicates={:?})\",\n-               predicates);\n-\n-        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let cause = traits::ObligationCause::dummy();\n-            let traits::Normalized { value: predicates, obligations } =\n-                traits::normalize(&mut selcx, cause.clone(), &predicates);\n-            for obligation in obligations {\n-                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-            }\n-            for predicate in predicates {\n-                let obligation = traits::Obligation::new(cause.clone(), predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-            }\n-\n-            fulfill_cx.select_all_or_error(&infcx).is_ok()\n-        })\n-    }\n-\n     pub(crate) fn resolve_associated_const(\n         &self,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n+    ) -> ty::Instance<'tcx> {\n         if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n             let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, substs));\n             let vtable = self.fulfill_obligation(trait_ref);\n@@ -432,86 +105,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let assoc_const_opt = self.tcx.associated_items(vtable_impl.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 if let Some(assoc_const) = assoc_const_opt {\n-                    return (assoc_const.def_id, vtable_impl.substs);\n+                    return ty::Instance::new(assoc_const.def_id, vtable_impl.substs);\n                 }\n             }\n         }\n-        (def_id, substs)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(super) struct ImplMethod<'tcx> {\n-    pub(super) method: ty::AssociatedItem,\n-    pub(super) substs: &'tcx Substs<'tcx>,\n-    pub(super) is_provided: bool,\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub(super) fn get_impl_method<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    substs: &'tcx Substs<'tcx>,\n-    impl_def_id: DefId,\n-    impl_substs: &'tcx Substs<'tcx>,\n-    name: ast::Name,\n-) -> ImplMethod<'tcx> {\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_substs: &'tcx Substs<'tcx>,\n-                             name: ast::Name)\n-                             -> (DefId, &'tcx Substs<'tcx>)\n-{\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id, substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"find_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            (node_item.item.def_id, substs)\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n+        ty::Instance::new(def_id, substs)\n     }\n }"}, {"sha": "d8da2de5d6df9f5f6642a7ab957cd1f660f60c7b", "filename": "tests/run-pass/bad_substs.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fbad_substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fbad_substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbad_substs.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let f: fn(i32) -> Option<i32> = Some::<i32>;\n+    f(42);\n+}"}, {"sha": "7db7e3b28e8e66c3728d00ceccef0b4539f44da4", "filename": "tests/run-pass/issue-20575.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fissue-20575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fissue-20575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-20575.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that overloaded calls work with zero arity closures\n+\n+// pretty-expanded FIXME #23616\n+\n+fn main() {\n+    let functions: [Box<Fn() -> Option<()>>; 1] = [Box::new(|| None)];\n+\n+    let _: Option<Vec<()>> = functions.iter().map(|f| (*f)()).collect();\n+}"}, {"sha": "badb833ee800bca94c2420c3dbf2b66e97d3fe29", "filename": "tests/run-pass/issue-3794.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32772f924b12af2cd40fe24cf59548cd81d3e6/tests%2Frun-pass%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-3794.rs?ref=9a32772f924b12af2cd40fe24cf59548cd81d3e6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+trait T {\n+    fn print(&self);\n+}\n+\n+#[derive(Debug)]\n+struct S {\n+    s: isize,\n+}\n+\n+impl T for S {\n+    fn print(&self) {\n+        println!(\"{:?}\", self);\n+    }\n+}\n+\n+fn print_t(t: &T) {\n+    t.print();\n+}\n+\n+fn print_s(s: &S) {\n+    s.print();\n+}\n+\n+pub fn main() {\n+    let s: Box<S> = box S { s: 5 };\n+    print_s(&*s);\n+    let t: Box<T> = s as Box<T>;\n+    print_t(&*t);\n+}"}]}