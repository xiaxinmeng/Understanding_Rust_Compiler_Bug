{"sha": "397c8e51480cc6c350433deefd8548e1455506c6", "node_id": "C_kwDOAAsO6NoAKDM5N2M4ZTUxNDgwY2M2YzM1MDQzM2RlZWZkODU0OGUxNDU1NTA2YzY", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-26T06:50:56Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-26T07:46:45Z"}, "message": "fix: don't try determining type of token inside macro calls", "tree": {"sha": "9a222f7f5e7c17407f558156a7527a894cbbdbfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a222f7f5e7c17407f558156a7527a894cbbdbfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397c8e51480cc6c350433deefd8548e1455506c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRwY+UACgkQ4laYqTBY\nYXEtRQ//RgwvpQczFW0m7cVofDnG6sL/m/t/IqmF93UqsxC/e4EXwxBtQzCqdAHj\npWD7mFcIRm8mY37TNZJDxlFNkcsoaNBonZCy+h7rm8gd3Nv/5h5fnHmeOSCQNjgd\nGMmB2qblATt+FBMpBfnhUsq41ypHM/5RZLPw2dY7jyIzBuQLp9hVLNZ80WGi0nUX\nMswFmPjkFdDOPCMfNuQcHKSxx3iqXc7KOocbMc4/TUa2PZsB1xRHukrElNTkztFU\nWjEKJR7EFLErJDFkfBCLxlOWPd/gA7sn0+Uoz+X3L/7VHPXwbc8JI50yKFrEwNRC\nakLJXKAbWnK0C10JZxCVRBHbBgxAF8rdAMjNJYmuczAuj6KEoVuXEjZxy11dUxsk\n+NXH/dDP5IAS99ggvLJnT2CpHR4hRywrqg+kKSXjLVXKg6gPjPvAUUFqL1Ei3RgO\njnKCFqqLKtt4ePl0DI2DK7JWEtlQSCBTeHl+18J+gdQNeh2xZ65XYPzm274x/A1c\nD3hQwAwoFqRK1qeOMHXEd/NAstv1S49nVMGnUhTNIt4HJ3S/PAiKJOSMteJfeMXY\nutKau2QC4slgxDgiCB+OOQv3YwgQ/pnmZ2ZVsCanVZjXCzVp61P10Lpo8bzhOGY+\nO5Gvt5haaIKTReB/hgFSyB89/bb4jD30UCm0Rxx6gDNAdQFy48o=\n=UO5C\n-----END PGP SIGNATURE-----", "payload": "tree 9a222f7f5e7c17407f558156a7527a894cbbdbfd\nparent 615aaa47510fae3a95d95cbd8b607c3695878161\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1685083856 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1685087205 +0900\n\nfix: don't try determining type of token inside macro calls\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397c8e51480cc6c350433deefd8548e1455506c6", "html_url": "https://github.com/rust-lang/rust/commit/397c8e51480cc6c350433deefd8548e1455506c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397c8e51480cc6c350433deefd8548e1455506c6/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "615aaa47510fae3a95d95cbd8b607c3695878161", "url": "https://api.github.com/repos/rust-lang/rust/commits/615aaa47510fae3a95d95cbd8b607c3695878161", "html_url": "https://github.com/rust-lang/rust/commit/615aaa47510fae3a95d95cbd8b607c3695878161"}], "stats": {"total": 87, "additions": 61, "deletions": 26}, "files": [{"sha": "6048990f7492c5151d77c972e14948d1391d9b5d", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/397c8e51480cc6c350433deefd8548e1455506c6/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c8e51480cc6c350433deefd8548e1455506c6/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=397c8e51480cc6c350433deefd8548e1455506c6", "patch": "@@ -38,32 +38,41 @@ pub(crate) fn goto_type_definition(\n     };\n     let range = token.text_range();\n     sema.descend_into_macros(token)\n-        .iter()\n+        .into_iter()\n         .filter_map(|token| {\n-            let ty = sema.token_ancestors_with_macros(token.clone()).find_map(|node| {\n-                let ty = match_ast! {\n-                    match node {\n-                        ast::Expr(it) => sema.type_of_expr(&it)?.original,\n-                        ast::Pat(it) => sema.type_of_pat(&it)?.original,\n-                        ast::SelfParam(it) => sema.type_of_self(&it)?,\n-                        ast::Type(it) => sema.resolve_type(&it)?,\n-                        ast::RecordField(it) => sema.to_def(&it).map(|d| d.ty(db.upcast()))?,\n-                        // can't match on RecordExprField directly as `ast::Expr` will match an iteration too early otherwise\n-                        ast::NameRef(it) => {\n-                            if let Some(record_field) = ast::RecordExprField::for_name_ref(&it) {\n-                                let (_, _, ty) = sema.resolve_record_field(&record_field)?;\n-                                ty\n-                            } else {\n-                                let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n-                                sema.resolve_record_pat_field(&record_field)?.1\n-                            }\n-                        },\n-                        _ => return None,\n-                    }\n-                };\n+            let ty = sema\n+                .token_ancestors_with_macros(token)\n+                // When `token` is within a macro call, we can't determine its type. Don't continue\n+                // this traversal because otherwise we'll end up returning the type of *that* macro\n+                // call, which is not what we want in general.\n+                //\n+                // Macro calls always wrap `TokenTree`s, so it's sufficient and efficient to test\n+                // if the current node is a `TokenTree`.\n+                .take_while(|node| !ast::TokenTree::can_cast(node.kind()))\n+                .find_map(|node| {\n+                    let ty = match_ast! {\n+                        match node {\n+                            ast::Expr(it) => sema.type_of_expr(&it)?.original,\n+                            ast::Pat(it) => sema.type_of_pat(&it)?.original,\n+                            ast::SelfParam(it) => sema.type_of_self(&it)?,\n+                            ast::Type(it) => sema.resolve_type(&it)?,\n+                            ast::RecordField(it) => sema.to_def(&it)?.ty(db.upcast()),\n+                            // can't match on RecordExprField directly as `ast::Expr` will match an iteration too early otherwise\n+                            ast::NameRef(it) => {\n+                                if let Some(record_field) = ast::RecordExprField::for_name_ref(&it) {\n+                                    let (_, _, ty) = sema.resolve_record_field(&record_field)?;\n+                                    ty\n+                                } else {\n+                                    let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n+                                    sema.resolve_record_pat_field(&record_field)?.1\n+                                }\n+                            },\n+                            _ => return None,\n+                        }\n+                    };\n \n-                Some(ty)\n-            });\n+                    Some(ty)\n+                });\n             ty\n         })\n         .for_each(|ty| {\n@@ -94,7 +103,7 @@ mod tests {\n     fn check(ra_fixture: &str) {\n         let (analysis, position, expected) = fixture::annotations(ra_fixture);\n         let navs = analysis.goto_type_definition(position).unwrap().unwrap().info;\n-        assert_ne!(navs.len(), 0);\n+        assert!(!navs.is_empty(), \"navigation is empty\");\n \n         let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n         let navs = navs\n@@ -104,7 +113,7 @@ mod tests {\n             .collect::<Vec<_>>();\n         let expected = expected\n             .into_iter()\n-            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .map(|(file_range, _)| file_range)\n             .sorted_by_key(cmp)\n             .collect::<Vec<_>>();\n         assert_eq!(expected, navs);\n@@ -198,6 +207,32 @@ id! {\n         );\n     }\n \n+    #[test]\n+    fn dont_collect_type_from_token_in_macro_call() {\n+        check(\n+            r#\"\n+struct DontCollectMe;\n+struct S;\n+     //^\n+\n+macro_rules! inner {\n+    ($t:tt) => { DontCollectMe }\n+}\n+macro_rules! m {\n+    ($t:ident) => {\n+        match $t {\n+            _ => inner!($t);\n+        }\n+    }\n+}\n+\n+fn test() {\n+    m!($0S);\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn goto_type_definition_for_param() {\n         check("}]}