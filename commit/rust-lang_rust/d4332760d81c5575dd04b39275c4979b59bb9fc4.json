{"sha": "d4332760d81c5575dd04b39275c4979b59bb9fc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MzMyNzYwZDgxYzU1NzVkZDA0YjM5Mjc1YzQ5NzliNTliYjlmYzQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:00:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "Better readability", "tree": {"sha": "b87fa6b8bf9ef53473ef0f54e46137382d1e8899", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b87fa6b8bf9ef53473ef0f54e46137382d1e8899"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4332760d81c5575dd04b39275c4979b59bb9fc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4332760d81c5575dd04b39275c4979b59bb9fc4", "html_url": "https://github.com/rust-lang/rust/commit/d4332760d81c5575dd04b39275c4979b59bb9fc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4332760d81c5575dd04b39275c4979b59bb9fc4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada", "html_url": "https://github.com/rust-lang/rust/commit/e0f02d233fa3e26e4f10bffacbaef11b6bcb0ada"}], "stats": {"total": 147, "additions": 145, "deletions": 2}, "files": [{"sha": "0df7cfe526697be5657fe71b354ad6563837b96a", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d4332760d81c5575dd04b39275c4979b59bb9fc4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4332760d81c5575dd04b39275c4979b59bb9fc4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=d4332760d81c5575dd04b39275c4979b59bb9fc4", "patch": "@@ -5,6 +5,7 @@ use crate::{\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n@@ -25,6 +26,7 @@ impl ast::AttrsOwner for SourceFile {}\n impl SourceFile {\n     pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -57,6 +59,7 @@ impl FnDef {\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n     pub(crate) syntax: SyntaxNode,\n@@ -76,6 +79,7 @@ impl RetType {\n     pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StructDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -101,6 +105,7 @@ impl StructDef {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -127,6 +132,7 @@ impl UnionDef {\n         support::child(&self.syntax)\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -147,6 +153,7 @@ impl RecordFieldDefList {\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -168,6 +175,7 @@ impl ast::AttrsOwner for RecordFieldDef {}\n impl ast::DocCommentsOwner for RecordFieldDef {}\n impl ast::TypeAscriptionOwner for RecordFieldDef {}\n impl RecordFieldDef {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -188,6 +196,7 @@ impl TupleFieldDefList {\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -208,6 +217,7 @@ impl ast::AttrsOwner for TupleFieldDef {}\n impl TupleFieldDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -232,6 +242,7 @@ impl EnumDef {\n     pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariantList {\n     pub(crate) syntax: SyntaxNode,\n@@ -252,6 +263,7 @@ impl EnumVariantList {\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n     pub(crate) syntax: SyntaxNode,\n@@ -276,6 +288,7 @@ impl EnumVariant {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -303,6 +316,7 @@ impl TraitDef {\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) syntax: SyntaxNode,\n@@ -327,6 +341,7 @@ impl Module {\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -348,6 +363,7 @@ impl ItemList {\n     pub fn impl_items(&self) -> AstChildren<ImplItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -376,6 +392,7 @@ impl ConstDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -404,6 +421,7 @@ impl StaticDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -432,6 +450,7 @@ impl TypeAliasDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -458,6 +477,7 @@ impl ImplDef {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n@@ -478,6 +498,7 @@ impl ParenType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n@@ -498,6 +519,7 @@ impl TupleType {\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n@@ -516,6 +538,7 @@ impl AstNode for NeverType {\n impl NeverType {\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n@@ -534,6 +557,7 @@ impl AstNode for PathType {\n impl PathType {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -555,6 +579,7 @@ impl PointerType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n@@ -577,6 +602,7 @@ impl ArrayType {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -597,6 +623,7 @@ impl SliceType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -620,6 +647,7 @@ impl ReferenceType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderType {\n     pub(crate) syntax: SyntaxNode,\n@@ -638,6 +666,7 @@ impl AstNode for PlaceholderType {\n impl PlaceholderType {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -660,6 +689,7 @@ impl FnPointerType {\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n@@ -680,6 +710,7 @@ impl ForType {\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -699,6 +730,7 @@ impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -718,6 +750,7 @@ impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n     pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -739,6 +772,7 @@ impl TupleExpr {\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -761,6 +795,7 @@ impl ArrayExpr {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -782,6 +817,7 @@ impl ParenExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -800,6 +836,7 @@ impl AstNode for PathExpr {\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LambdaExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -824,6 +861,7 @@ impl LambdaExpr {\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -844,6 +882,7 @@ impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -864,6 +903,7 @@ impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n     pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryBlockExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -884,6 +924,7 @@ impl TryBlockExpr {\n     pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -907,6 +948,7 @@ impl ForExpr {\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -928,6 +970,7 @@ impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -952,6 +995,7 @@ impl ContinueExpr {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -975,6 +1019,7 @@ impl BreakExpr {\n     }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n@@ -995,6 +1040,7 @@ impl Label {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1016,6 +1062,7 @@ impl BlockExpr {\n     pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1035,6 +1082,7 @@ impl ast::AttrsOwner for ReturnExpr {}\n impl ReturnExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1054,6 +1102,7 @@ impl ast::ArgListOwner for CallExpr {}\n impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MethodCallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1077,6 +1126,7 @@ impl MethodCallExpr {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1097,6 +1147,7 @@ impl IndexExpr {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1118,6 +1169,7 @@ impl FieldExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1139,6 +1191,7 @@ impl AwaitExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1159,6 +1212,7 @@ impl TryExpr {\n     pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1180,6 +1234,7 @@ impl CastExpr {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1202,6 +1257,7 @@ impl RefExpr {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1221,6 +1277,7 @@ impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1241,6 +1298,7 @@ impl BoxExpr {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1258,6 +1316,7 @@ impl AstNode for RangeExpr {\n }\n impl ast::AttrsOwner for RangeExpr {}\n impl RangeExpr {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1275,6 +1334,7 @@ impl AstNode for BinExpr {\n }\n impl ast::AttrsOwner for BinExpr {}\n impl BinExpr {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n@@ -1291,6 +1351,7 @@ impl AstNode for Literal {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Literal {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1312,6 +1373,7 @@ impl MatchExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1333,6 +1395,7 @@ impl MatchArmList {\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n@@ -1355,6 +1418,7 @@ impl MatchArm {\n     pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n@@ -1374,6 +1438,7 @@ impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordLit {\n     pub(crate) syntax: SyntaxNode,\n@@ -1393,6 +1458,7 @@ impl RecordLit {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn record_field_list(&self) -> Option<RecordFieldList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1415,6 +1481,7 @@ impl RecordFieldList {\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n     pub(crate) syntax: SyntaxNode,\n@@ -1436,6 +1503,7 @@ impl RecordField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1454,6 +1522,7 @@ impl AstNode for OrPat {\n impl OrPat {\n     pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1474,6 +1543,7 @@ impl ParenPat {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1494,6 +1564,7 @@ impl RefPat {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1513,6 +1584,7 @@ impl BoxPat {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BindPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1536,6 +1608,7 @@ impl BindPat {\n     pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1554,6 +1627,7 @@ impl AstNode for PlaceholderPat {\n impl PlaceholderPat {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1572,6 +1646,7 @@ impl AstNode for DotDotPat {\n impl DotDotPat {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1590,6 +1665,7 @@ impl AstNode for PathPat {\n impl PathPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SlicePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1610,6 +1686,7 @@ impl SlicePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1626,6 +1703,7 @@ impl AstNode for RangePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RangePat {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1644,6 +1722,7 @@ impl AstNode for LiteralPat {\n impl LiteralPat {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1662,6 +1741,7 @@ impl AstNode for MacroPat {\n impl MacroPat {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1683,6 +1763,7 @@ impl RecordPat {\n     }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPatList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1708,6 +1789,7 @@ impl RecordFieldPatList {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1729,6 +1811,7 @@ impl RecordFieldPat {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleStructPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1750,6 +1833,7 @@ impl TupleStructPat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1770,6 +1854,7 @@ impl TuplePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n     pub(crate) syntax: SyntaxNode,\n@@ -1791,6 +1876,7 @@ impl Visibility {\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n     pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n     pub(crate) syntax: SyntaxNode,\n@@ -1809,6 +1895,7 @@ impl AstNode for Name {\n impl Name {\n     pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n     pub(crate) syntax: SyntaxNode,\n@@ -1825,6 +1912,7 @@ impl AstNode for NameRef {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NameRef {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n@@ -1849,6 +1937,7 @@ impl MacroCall {\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1873,6 +1962,7 @@ impl Attr {\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -1889,6 +1979,7 @@ impl AstNode for TokenTree {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TokenTree {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1912,6 +2003,7 @@ impl TypeParamList {\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1934,6 +2026,7 @@ impl TypeParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1956,6 +2049,7 @@ impl ConstParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1977,6 +2071,7 @@ impl LifetimeParam {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n@@ -1999,6 +2094,7 @@ impl TypeBound {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2017,6 +2113,7 @@ impl AstNode for TypeBoundList {\n impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n@@ -2039,6 +2136,7 @@ impl WherePred {\n     }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -2058,6 +2156,7 @@ impl WhereClause {\n     pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Abi {\n     pub(crate) syntax: SyntaxNode,\n@@ -2074,6 +2173,7 @@ impl AstNode for Abi {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Abi {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -2094,6 +2194,7 @@ impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -2118,6 +2219,7 @@ impl LetStmt {\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n@@ -2139,6 +2241,7 @@ impl Condition {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Block {\n     pub(crate) syntax: SyntaxNode,\n@@ -2162,6 +2265,7 @@ impl Block {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2183,6 +2287,7 @@ impl ParamList {\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -2207,6 +2312,7 @@ impl SelfParam {\n     }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n     pub(crate) syntax: SyntaxNode,\n@@ -2228,6 +2334,7 @@ impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -2249,6 +2356,7 @@ impl UseItem {\n     pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -2270,6 +2378,7 @@ impl UseTree {\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Alias {\n     pub(crate) syntax: SyntaxNode,\n@@ -2289,6 +2398,7 @@ impl ast::NameOwner for Alias {}\n impl Alias {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2309,6 +2419,7 @@ impl UseTreeList {\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -2332,6 +2443,7 @@ impl ExternCrateItem {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2352,6 +2464,7 @@ impl ArgList {\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub(crate) syntax: SyntaxNode,\n@@ -2371,6 +2484,7 @@ impl Path {\n     pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n     pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n@@ -2396,6 +2510,7 @@ impl PathSegment {\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2421,6 +2536,7 @@ impl TypeArgList {\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -2439,6 +2555,7 @@ impl AstNode for TypeArg {\n impl TypeArg {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocTypeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -2460,6 +2577,7 @@ impl AssocTypeArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -2480,6 +2598,7 @@ impl LifetimeArg {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -2500,6 +2619,7 @@ impl ConstArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroItems {\n     pub(crate) syntax: SyntaxNode,\n@@ -2517,6 +2637,7 @@ impl AstNode for MacroItems {\n }\n impl ast::ModuleItemOwner for MacroItems {}\n impl MacroItems {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroStmts {\n     pub(crate) syntax: SyntaxNode,\n@@ -2536,6 +2657,7 @@ impl MacroStmts {\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -2557,6 +2679,7 @@ impl ExternItemList {\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n     pub(crate) syntax: SyntaxNode,\n@@ -2576,6 +2699,7 @@ impl ExternBlock {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n     pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MetaItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -2597,6 +2721,7 @@ impl MetaItem {\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -2616,6 +2741,7 @@ impl MacroDef {\n     pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum NominalDef {\n     StructDef(StructDef),\n@@ -2658,6 +2784,7 @@ impl AstNode for NominalDef {\n impl ast::NameOwner for NominalDef {}\n impl ast::TypeParamsOwner for NominalDef {}\n impl ast::AttrsOwner for NominalDef {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n     LifetimeParam(LifetimeParam),\n@@ -2697,6 +2824,7 @@ impl AstNode for GenericParam {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n     LifetimeArg(LifetimeArg),\n@@ -2742,6 +2870,7 @@ impl AstNode for GenericArg {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeRef {\n     ParenType(ParenType),\n@@ -2843,6 +2972,7 @@ impl AstNode for TypeRef {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ModuleItem {\n     StructDef(StructDef),\n@@ -2953,6 +3083,7 @@ impl AstNode for ModuleItem {\n impl ast::NameOwner for ModuleItem {}\n impl ast::AttrsOwner for ModuleItem {}\n impl ast::VisibilityOwner for ModuleItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ImplItem {\n     FnDef(FnDef),\n@@ -2994,6 +3125,7 @@ impl AstNode for ImplItem {\n }\n impl ast::NameOwner for ImplItem {}\n impl ast::AttrsOwner for ImplItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ExternItem {\n     FnDef(FnDef),\n@@ -3030,6 +3162,7 @@ impl AstNode for ExternItem {\n impl ast::NameOwner for ExternItem {}\n impl ast::AttrsOwner for ExternItem {}\n impl ast::VisibilityOwner for ExternItem {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n     TupleExpr(TupleExpr),\n@@ -3243,6 +3376,7 @@ impl AstNode for Expr {\n     }\n }\n impl ast::AttrsOwner for Expr {}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n     OrPat(OrPat),\n@@ -3356,6 +3490,7 @@ impl AstNode for Pat {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum RecordInnerPat {\n     RecordFieldPat(RecordFieldPat),\n@@ -3389,6 +3524,7 @@ impl AstNode for RecordInnerPat {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AttrInput {\n     Literal(Literal),\n@@ -3422,6 +3558,7 @@ impl AstNode for AttrInput {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n     LetStmt(LetStmt),\n@@ -3455,6 +3592,7 @@ impl AstNode for Stmt {\n         }\n     }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldDefList {\n     RecordFieldDefList(RecordFieldDefList),"}, {"sha": "f91befaac78a0bc4833d109333d974ef25be73d8", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4332760d81c5575dd04b39275c4979b59bb9fc4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4332760d81c5575dd04b39275c4979b59bb9fc4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=d4332760d81c5575dd04b39275c4979b59bb9fc4", "patch": "@@ -5,6 +5,7 @@ use crate::{\n     SyntaxKind::{self, *},\n     SyntaxToken,\n };\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Whitespace {\n     pub(crate) syntax: SyntaxToken,\n@@ -25,6 +26,7 @@ impl AstToken for Whitespace {\n     }\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Comment {\n     pub(crate) syntax: SyntaxToken,\n@@ -45,6 +47,7 @@ impl AstToken for Comment {\n     }\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct String {\n     pub(crate) syntax: SyntaxToken,\n@@ -65,6 +68,7 @@ impl AstToken for String {\n     }\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RawString {\n     pub(crate) syntax: SyntaxToken,"}, {"sha": "ff290bb33f2ab293f3420fe00f7e2420a28ad274", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4332760d81c5575dd04b39275c4979b59bb9fc4/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4332760d81c5575dd04b39275c4979b59bb9fc4/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=d4332760d81c5575dd04b39275c4979b59bb9fc4", "patch": "@@ -57,7 +57,8 @@ fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n     let pretty = crate::reformat(quote! {\n         use crate::{SyntaxKind::{self, *}, SyntaxToken, ast::AstToken};\n         #(#tokens)*\n-    })?;\n+    })?\n+    .replace(\"#[derive\", \"\\n#[derive\");\n     Ok(pretty)\n }\n \n@@ -215,7 +216,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     };\n \n     let ast = ast.to_string().replace(\"T ! [ \", \"T![\").replace(\" ] )\", \"])\");\n-    let pretty = crate::reformat(ast)?;\n+    let pretty = crate::reformat(ast)?.replace(\"#[derive\", \"\\n#[derive\");\n     Ok(pretty)\n }\n "}]}