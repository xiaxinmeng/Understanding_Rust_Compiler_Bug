{"sha": "85b50d03120cf7bd1beb472a78ce9427c0d8d06e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YjUwZDAzMTIwY2Y3YmQxYmViNDcyYTc4Y2U5NDI3YzBkOGQwNmU=", "commit": {"author": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2018-12-09T21:53:00Z"}, "committer": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2018-12-09T22:56:42Z"}, "message": "Add missing, non-panicking `maybe_new_parser_from_file` variant", "tree": {"sha": "a150975cffa630791e80c2ac189c83179f240f78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a150975cffa630791e80c2ac189c83179f240f78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85b50d03120cf7bd1beb472a78ce9427c0d8d06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85b50d03120cf7bd1beb472a78ce9427c0d8d06e", "html_url": "https://github.com/rust-lang/rust/commit/85b50d03120cf7bd1beb472a78ce9427c0d8d06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85b50d03120cf7bd1beb472a78ce9427c0d8d06e/comments", "author": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b755501043d5b27b39f94bcadd57c8d5dedfd6ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/b755501043d5b27b39f94bcadd57c8d5dedfd6ba", "html_url": "https://github.com/rust-lang/rust/commit/b755501043d5b27b39f94bcadd57c8d5dedfd6ba"}], "stats": {"total": 37, "additions": 29, "deletions": 8}, "files": [{"sha": "0fda08db67d6a92afeeb2067334dbd0fe1587618", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/85b50d03120cf7bd1beb472a78ce9427c0d8d06e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b50d03120cf7bd1beb472a78ce9427c0d8d06e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=85b50d03120cf7bd1beb472a78ce9427c0d8d06e", "patch": "@@ -15,7 +15,7 @@ use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use errors::{Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n+use errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n use ptr::P;\n@@ -192,6 +192,14 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a>\n     source_file_to_parser(sess, file_to_source_file(sess, path, None))\n }\n \n+/// Create a new parser, returning buffered diagnostics if the file doesn't\n+/// exist or from lexing the initial token stream.\n+pub fn maybe_new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path)\n+    -> Result<Parser<'a>, Vec<Diagnostic>> {\n+    let file = try_file_to_source_file(sess, path, None).map_err(|db| vec![db])?;\n+    maybe_source_file_to_parser(sess, file)\n+}\n+\n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the source_map, and return a parser.\n /// On an error, use the given span as the source of the problem.\n@@ -236,18 +244,31 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n \n // base abstractions\n \n+/// Given a session and a path and an optional span (for error reporting),\n+/// add the path to the session's source_map and return the new source_file or\n+/// error when a file can't be read.\n+fn try_file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n+                   -> Result<Lrc<SourceFile>, Diagnostic> {\n+    sess.source_map().load_file(path)\n+    .map_err(|e| {\n+        let msg = format!(\"couldn't read {}: {}\", path.display(), e);\n+        let mut diag = Diagnostic::new(Level::Fatal, &msg);\n+        if let Some(sp) = spanopt {\n+            diag.set_span(sp);\n+        }\n+        diag\n+    })\n+}\n+\n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's source_map and return the new source_file.\n fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                    -> Lrc<SourceFile> {\n-    match sess.source_map().load_file(path) {\n+    match try_file_to_source_file(sess, path, spanopt) {\n         Ok(source_file) => source_file,\n-        Err(e) => {\n-            let msg = format!(\"couldn't read {}: {}\", path.display(), e);\n-            match spanopt {\n-                Some(sp) => sess.span_diagnostic.span_fatal(sp, &msg).raise(),\n-                None => sess.span_diagnostic.fatal(&msg).raise()\n-            }\n+        Err(d) => {\n+            DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, d).emit();\n+            FatalError.raise();\n         }\n     }\n }"}]}