{"sha": "889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "node_id": "C_kwDOAAsO6NoAKDg4OWEzM2E1MDA5ODJjZmMyYzc5Y2VmZjFiMmNhZjg2YzBhZGJlYWE", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-10-19T13:23:23Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-01-02T19:57:38Z"}, "message": "WIP: Implement unwinding", "tree": {"sha": "dcdab7a7f2867436474ab1dfcd08e1640d956fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcdab7a7f2867436474ab1dfcd08e1640d956fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "html_url": "https://github.com/rust-lang/rust/commit/889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a54f243f61cc44034af3c483dbe8bd99b76ce15", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a54f243f61cc44034af3c483dbe8bd99b76ce15", "html_url": "https://github.com/rust-lang/rust/commit/0a54f243f61cc44034af3c483dbe8bd99b76ce15"}], "stats": {"total": 474, "additions": 383, "deletions": 91}, "files": [{"sha": "e52e742ec6cec153c016ce68a1aaa720bb12c0c0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -41,15 +41,13 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#f30cc2bd330f4fda3d625f305bdfd7e523e2d8f8\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#f30cc2bd330f4fda3d625f305bdfd7e523e2d8f8\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "26a0e92923d53059033032231b9e198fe8d81989", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -22,10 +22,10 @@ default = [\"master\"]\n master = [\"gccjit/master\"]\n \n [dependencies]\n-gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n+#gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n \n # Local copy.\n-#gccjit = { path = \"../gccjit.rs\" }\n+gccjit = { path = \"../gccjit.rs\" }\n \n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n target-lexicon = \"0.10.0\""}, {"sha": "a74750228ba0947405c62d278a954edd23a2ae94", "filename": "Readme.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -162,6 +162,14 @@ To print a debug representation of a tree:\n debug_tree(expr);\n ```\n \n+(defined in print-tree.h)\n+\n+To print a debug reprensentation of a gimple struct:\n+\n+```c\n+debug_gimple_stmt(gimple_struct)\n+```\n+\n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n \n ### How to use a custom-build rustc"}, {"sha": "9d692d599f6bef19852222ea918d3d942856f48c", "filename": "build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/build_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/build_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fbuild_sysroot.sh?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -16,7 +16,7 @@ rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n rm -r sysroot/ 2>/dev/null || true\n \n # Build libs\n-export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n     sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release"}, {"sha": "6bad0586c5baef299a4931f8f42f24657c95e313", "filename": "config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "b937f7e69ace6acdbd24d577b64a32f7bb610c2e", "filename": "src/asm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -352,8 +352,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     inputs.push(AsmInOperand {\n                         constraint: \"X\".into(),\n                         rust_idx,\n-                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n-                            .get_address(None),\n+                        val: get_fn(self.cx, instance, false).get_address(None),\n                     });\n                 }\n \n@@ -739,7 +738,7 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymFn { instance } => {\n-                            let function = self.rvalue_as_function(get_fn(self, instance));\n+                            let function = get_fn(self, instance, false);\n                             self.add_used_function(function);\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O)"}, {"sha": "0e98166a7cc8575ecd0fc72188b7b3321fc3722f", "filename": "src/base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -87,6 +87,16 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         let context = Context::default();\n+\n+        context.add_command_line_option(\"-fexceptions\");\n+        context.add_driver_option(\"-fexceptions\");\n+\n+        /*context.add_command_line_option(\"-fasynchronous-unwind-tables\");\n+        context.add_driver_option(\"-fasynchronous-unwind-tables\");\n+\n+        context.add_command_line_option(\"-funwind-tables\");\n+        context.add_driver_option(\"-funwind-tables\");*/\n+\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n@@ -147,6 +157,7 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         }\n \n         // TODO(bjorn3): Remove once unwinding is properly implemented\n+        // TODO: remove.\n         context.set_allow_unreachable_blocks(true);\n \n         {"}, {"sha": "68b664a3ba261f08a850dd6c0690f41922f1c7a6", "filename": "src/builder.rs", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -13,7 +13,7 @@ use gccjit::{\n     RValue,\n     ToRValue,\n     Type,\n-    UnaryOp,\n+    UnaryOp, FunctionType,\n };\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n@@ -372,10 +372,11 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+impl<'a, 'gcc, 'tcx> Deref for Builder<'a, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n-    fn deref(&self) -> &Self::Target {\n+    fn deref<'b>(&'b self) -> &'a Self::Target\n+    {\n         self.cx\n     }\n }\n@@ -393,7 +394,7 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Builder<'a, 'gcc, 'tcx> {\n         Builder::with_cx(cx, block)\n     }\n \n@@ -450,8 +451,36 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let try_block = self.current_func().new_block(\"try\");\n+\n+        let current_block = self.block.clone();\n+        self.block = try_block;\n+        let call = self.call(typ, func, args, None); // TODO: use funclet here?\n+        self.block = current_block;\n+\n+        let return_value = self.current_func()\n+            .new_local(None, call.get_type(), \"invokeResult\");\n+\n+        try_block.add_assignment(None, return_value, call);\n+\n+        try_block.end_with_jump(None, then);\n+\n+        self.block.add_try_catch(None, try_block, catch);\n+\n+        self.block.end_with_jump(None, then);\n+\n+        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // state need to be updated.\n+        // FIXME: not sure it's actually needed.\n+        self.switch_to_block(then);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n     fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        // TODO(bjorn3): Properly implement unwinding.\n         let call_site = self.call(typ, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n@@ -1160,23 +1189,56 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         aggregate_value\n     }\n \n-    fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n-    }\n-\n-    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n-        let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n+    fn set_personality_fn(&mut self, personality: RValue<'gcc>) {\n+        let personality = self.rvalue_as_function(personality); // FIXME: why calling\n+        //rvalue_as_function doesn't work?\n+        //let personality = unsafe { std::mem::transmute(personality) };\n+        #[cfg(feature=\"master\")]\n+        self.current_func().set_personality_function(personality);\n+        // FIXME: rustc manages to generate the symbol DW.ref.rust_eh_personality multiple times\n+        // for the same asm file, which causes an assembler error.\n+    }\n+\n+    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n+        self.set_personality_fn(pers_fn);\n+\n+        // FIXME: we're probably not creating a real cleanup pad here.\n+        // FIXME: FIXME: FIXME: It seems to be the actual problem:\n+        // libunwind finds a catch, so returns _URC_HANDLER_FOUND instead of _URC_CONTINUE_UNWIND.\n+        // TODO: can we generate a goto from the finally to the cleanup landing pad?\n+        // TODO: TODO: TODO: add this block to a cleanup_blocks variable and generate a try/finally instead if\n+        // the catch block for it is a cleanup block.\n+        //\n+        // TODO: look at TRY_CATCH_IS_CLEANUP, CLEANUP_POINT_EXPR, WITH_CLEANUP_EXPR, CLEANUP_EH_ONLY.\n+        let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = self.cx.context.new_rvalue_zero(self.int_type);\n+        let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+\n+        let field1_type = self.u8_type.make_pointer();\n+        let field1 = self.context.new_field(None, field1_type, \"landing_pad_field_1\");\n+        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_2\");\n         let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n-        self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n-            .to_rvalue()\n-        // TODO(antoyo): Properly implement unwinding.\n-        // the above is just to make the compilation work as it seems\n-        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n-    }\n-\n-    fn resume(&mut self, _exn: RValue<'gcc>) {\n-        // TODO(bjorn3): Properly implement unwinding.\n+        let value = self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\");\n+        let ptr = self.cx.context.new_cast(None, ptr, field1_type);\n+        self.block.add_assignment(None, value.access_field(None, field1), ptr);\n+        self.block.add_assignment(None, value.access_field(None, field2), zero); // TODO: set the proper value here (the type of exception?).\n+\n+        // Resume.\n+        let param = self.context.new_parameter(None, ptr.get_type(), \"exn\");\n+        // TODO: should we call __builtin_unwind_resume instead?\n+        // FIXME: should probably not called resume because it could be executed (I believe) in\n+        // normal (no exception) cases\n+        let unwind_resume = self.context.new_function(None, FunctionType::Extern, self.type_void(), &[param], \"_Unwind_Resume\", false);\n+        self.block.add_eval(None, self.context.new_call(None, unwind_resume, &[ptr]));\n+\n+        value.to_rvalue()\n+    }\n+\n+    fn resume(&mut self, exn: RValue<'gcc>) {\n+        let param = self.context.new_parameter(None, exn.get_type(), \"exn\");\n+        // TODO: should we call __builtin_unwind_resume instead?\n+        let unwind_resume = self.context.new_function(None, FunctionType::Extern, self.type_void(), &[param], \"_Unwind_Resume\", false);\n+        self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n         self.unreachable();\n     }\n "}, {"sha": "fea5df9b9b0d76eca1bb787f7e60e406ad1e759d", "filename": "src/callee.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -1,6 +1,6 @@\n #[cfg(feature=\"master\")]\n use gccjit::{FnAttribute, Visibility};\n-use gccjit::{FunctionType, RValue};\n+use gccjit::{FunctionType, RValue, Function};\n use rustc_codegen_ssa::traits::BaseTypeMethods;\n use rustc_middle::ty::{self, Instance, TypeVisitable};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n@@ -16,22 +16,31 @@ use crate::context::CodegenCx;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>, dont_cache: bool) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n+    let sym = tcx.symbol_name(instance).name;\n+\n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n+        if sym == \"rust_eh_personality\" {\n+            println!(\"Cached\");\n+        }\n         return func;\n     }\n \n-    let sym = tcx.symbol_name(instance).name;\n+    if sym == \"rust_eh_personality\" {\n+        println!(\"Not cached\");\n+    }\n \n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n         if let Some(func) = cx.get_declared_value(&sym) {\n+            unreachable!();\n+            /*\n             // Create a fn pointer with the new signature.\n             let ptrty = fn_abi.ptr_to_gcc_type(cx);\n \n@@ -64,11 +73,14 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             }\n             else {\n                 func\n-            }\n+            }*/\n         }\n         else {\n             cx.linkage.set(FunctionType::Extern);\n-            let func = cx.declare_fn(&sym, &fn_abi);\n+            /*if sym == \"rust_eh_personality\" {\n+                panic!();\n+            }*/\n+            let func = cx.declare_fn(&sym, &fn_abi, dont_cache);\n \n             attributes::from_fn_attrs(cx, func, instance);\n \n@@ -163,11 +175,15 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n                 }\n             }\n \n-            // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-            unsafe { std::mem::transmute(func) }\n+            func\n         };\n \n-    cx.function_instances.borrow_mut().insert(instance, func);\n+    //if !dont_cache {\n+    if sym == \"rust_eh_personality\" {\n+        println!(\"Caching here\");\n+    }\n+        cx.function_instances.borrow_mut().insert(instance, func);\n+    //}\n \n     func\n }"}, {"sha": "04371048380f17501dee47546980d7fffc702edf", "filename": "src/context.rs", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -1,17 +1,18 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type, FnAttribute};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n+    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n@@ -82,7 +83,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n-    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, Function<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n@@ -109,6 +110,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n+    pub rust_try_fn: Cell<Option<(Type<'gcc>, Function<'gcc>)>>,\n \n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n \n@@ -245,15 +247,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             struct_types: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n         }\n     }\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n-            \"{:?} ({:?}) is not a function\", value, value.get_type());\n+        // FIXME: seems like self.functions get overwritten for rust_eh_personality.\n+        /*debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+            \"{:?} is not a function\", function);*/\n         function\n     }\n \n@@ -325,9 +329,9 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n-        let func = get_fn(self, instance);\n-        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n-        func\n+        let func = get_fn(self, instance, false);\n+        *self.current_func.borrow_mut() = Some(func);\n+        unsafe { std::mem::transmute(func) }\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n@@ -338,8 +342,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 self.intrinsics.borrow()[func_name].clone()\n             }\n             else {\n-                let func = get_fn(self, instance);\n-                self.rvalue_as_function(func)\n+                get_fn(self, instance, false)\n             };\n         let ptr = func.get_address(None);\n \n@@ -377,31 +380,68 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             return llpersonality;\n         }\n         let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap().unwrap(),\n-            ),\n-            _ => {\n-                let _name = if wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                //let func = self.declare_func(name, self.type_i32(), &[], true);\n-                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n-                // unwinding support is added.\n-                self.context.new_rvalue_from_int(self.int_type, 0)\n-            }\n-        };\n+        let func =\n+            match tcx.lang_items().eh_personality() {\n+                Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                    // FIXME: this create an instance into self.functions and prevent the creating\n+                    // of the function defined in std.\n+                    let instance =\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            tcx.intern_substs(&[]),\n+                        )\n+                        .unwrap().unwrap();\n+\n+                    let symbol_name = tcx.symbol_name(instance).name;\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+                    self.linkage.set(FunctionType::Extern);\n+                    let func = self.declare_fn(symbol_name, &fn_abi, false);\n+                    //func.add_attribute(FnAttribute::Weak);\n+\n+                    /*let block = func.new_block(\"eh_personality_block\");\n+                    // NOTE: it seems this function is overwritten by the standard library, so just\n+                    // return a dummy value in this version.\n+                    let zero = self.context.new_rvalue_zero(self.type_u32());\n+                    block.end_with_return(None, zero);*/\n+\n+                    //*self.current_func.borrow_mut() = Some(func);\n+                    let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+                    func\n+                    /*self.get_fn(\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            tcx.intern_substs(&[]),\n+                        )\n+                        .unwrap().unwrap(),\n+                    )*/\n+                },\n+                _ => {\n+                    let name = if wants_msvc_seh(self.sess()) {\n+                        \"__CxxFrameHandler3\"\n+                    } else {\n+                        \"rust_eh_personality\"\n+                    };\n+                    let func = self.declare_func(name, self.type_i32(), &[], true);\n+                    //*self.current_func.borrow_mut() = Some(func);\n+                    // NOTE: this function is created multiple times and is overwritten by the\n+                    // standard library, so mark it as weak.\n+                    //func.add_attribute(FnAttribute::Weak);\n+                    //self.functions.borrow_mut().insert(name.to_string(), func);\n+                    /*let block = func.new_block(\"eh_personality_block\");\n+                    // NOTE: it seems this function is overwritten by the standard library, so just\n+                    // return a dummy value in this version.\n+                    let zero = self.context.new_rvalue_zero(self.type_i32());\n+                    block.end_with_return(None, zero);*/\n+                    unsafe { std::mem::transmute(func) }\n+                }\n+            };\n         // TODO(antoyo): apply target cpu attributes.\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n+        self.eh_personality.set(Some(func));\n+        func\n     }\n \n     fn sess(&self) -> &Session {"}, {"sha": "fdde82e8df7721428d2400e98922af41b0988c6c", "filename": "src/declare.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -38,12 +38,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n-        self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n-    }*/\n+    pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+        self.linkage.set(FunctionType::Extern);\n+        declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic, true)\n+    }\n \n     pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, global_kind, ty, name);\n@@ -71,17 +69,27 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let return_type = self.type_i32();\n         let variadic = false;\n         self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, &[self.type_i32(), const_string], variadic);\n+        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, &[self.type_i32(), const_string], variadic, false);\n         // NOTE: it is needed to set the current_func here as well, because get_fn() is not called\n         // for the main function.\n         *self.current_func.borrow_mut() = Some(func);\n         // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, dont_cache: bool) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n-        let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n+        /*static mut COUNTER: i32 = 0;\n+        if name.contains(\"personality\") {\n+            println!(\"{}: {}\", name, skip_cache);\n+            unsafe {\n+                COUNTER += 1;\n+                if COUNTER == 6 {\n+                    panic!(\"{}\", name);\n+                }\n+            }\n+        }*/\n+        let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic, dont_cache);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n         func\n     }\n@@ -100,7 +108,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool, dont_cache: bool) -> Function<'gcc> {\n     if name.starts_with(\"llvm.\") {\n         let intrinsic = llvm::intrinsic(name, cx);\n         cx.intrinsics.borrow_mut().insert(name.to_string(), intrinsic);\n@@ -115,7 +123,9 @@ fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*ll\n                 .map(|(index, param)| cx.context.new_parameter(None, *param, &format!(\"param{}\", index))) // TODO(antoyo): set name.\n                 .collect();\n             let func = cx.context.new_function(None, cx.linkage.get(), return_type, &params, mangle_name(name), variadic);\n-            cx.functions.borrow_mut().insert(name.to_string(), func);\n+            //if !dont_cache {\n+                cx.functions.borrow_mut().insert(name.to_string(), func);\n+            //}\n             func\n         };\n "}, {"sha": "511256e45a321a940591c709d97d72213b0990ff", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 146, "deletions": 7, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -1,22 +1,24 @@\n pub mod llvm;\n mod simd;\n \n+use std::iter;\n+\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n-use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, DerivedTypeMethods, IntrinsicCallMethods, MiscMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n-use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, LayoutOf};\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::spec::PanicStrategy;\n+use rustc_target::spec::{abi::Abi, PanicStrategy};\n \n-use crate::abi::GccType;\n+use crate::abi::{FnAbiGccExt, GccType};\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n@@ -1115,9 +1117,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n }\n \n-fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n     // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n         bx.call(bx.type_void(), try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n@@ -1129,6 +1131,143 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n         unimplemented!();\n     }\n     else {\n-        unimplemented!();\n+        codegen_gnu_try(bx, try_func, data, catch_func, dest);\n     }\n }\n+\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n+// instructions).\n+//\n+// This codegen is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n+fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    //use std::ops::Deref;\n+    //let cx: &CodegenCx<'gcc, '_> = bx.deref();\n+    let cx: &CodegenCx<'gcc, '_> = bx.cx;\n+    let (llty, func) = get_rust_try_fn(cx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n+        //      ret 1\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n+\n+        let func = bx.current_func();\n+        let try_func = func.get_param(0).to_rvalue();\n+        let data = func.get_param(1).to_rvalue();\n+        let catch_func = func.get_param(2).to_rvalue();\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+\n+        let current_block = bx.block.clone();\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The first value in this tuple is a pointer to the exception object\n+        // being thrown.  The second value is a \"selector\" indicating which of\n+        // the landing pad clauses the exception's type had been matched to.\n+        // rust_try ignores the selector.\n+        bx.switch_to_block(catch);\n+        /*let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n+        let vals = bx.landing_pad(lpad_ty, bx.eh_personality(), 1);\n+        let tydesc = bx.const_null(bx.type_i8p());\n+        bx.add_clause(vals, tydesc);\n+        let ptr = bx.extract_value(vals, 0);*/\n+\n+        let eh_pointer_builtin = bx.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n+        let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n+\n+        // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n+        // generate a try/catch.\n+        // FIXME: add a check in the libgccjit API to prevent this.\n+        bx.switch_to_block(current_block);\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+    });\n+\n+    let func = unsafe { std::mem::transmute(func) };\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llty, func, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n+fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n+        return llfn;\n+    }\n+\n+    // Define the type up front for the signature of the rust_try function.\n+    let tcx = cx.tcx;\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        [try_fn_ty, i8p, catch_fn_ty].into_iter(),\n+        &tcx.types.i32,\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n+    cx.rust_try_fn.set(Some(rust_try));\n+    rust_try\n+}\n+\n+// Helper function to give a Block to a closure to codegen a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+fn gen_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, name: &str, rust_fn_sig: ty::PolyFnSig<'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n+    let (typ, _, _, _) = fn_abi.gcc_type(cx);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    cx.linkage.set(FunctionType::Internal);\n+    let func = cx.declare_fn(name, fn_abi, false);\n+    let func_val = unsafe { std::mem::transmute(func) };\n+    cx.set_frame_pointer_type(func_val);\n+    cx.apply_target_cpu_attr(func_val);\n+    let block = Builder::append_block(cx, func_val, \"entry-block\");\n+    let bx = Builder::build(cx, block);\n+    codegen(bx);\n+    (typ, func)\n+}"}, {"sha": "09ffd8dc79833b4852fe2edf357e41885a2e8fce", "filename": "src/mono_item.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889a33a500982cfc2c79ceff1b2caf86c0adbeaa/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "patch": "@@ -35,7 +35,10 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let decl = self.declare_fn(symbol_name, &fn_abi);\n+        if symbol_name == \"rust_eh_personality\" {\n+            println!(\"********************* Generating real rust_eh_personality: {:?}\", base::linkage_to_gcc(linkage));\n+        }\n+        let decl = self.declare_fn(symbol_name, &fn_abi, false);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n         attributes::from_fn_attrs(self, decl, instance);\n@@ -59,5 +62,11 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+\n+        self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n+        if symbol_name == \"rust_eh_personality\" {\n+            println!(\"Caching here 2\");\n+        }\n+        self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}]}