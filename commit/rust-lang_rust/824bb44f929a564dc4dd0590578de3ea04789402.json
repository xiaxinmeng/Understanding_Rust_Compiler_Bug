{"sha": "824bb44f929a564dc4dd0590578de3ea04789402", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNGJiNDRmOTI5YTU2NGRjNGRkMDU5MDU3OGRlM2VhMDQ3ODk0MDI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-09T14:55:04Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:52:21Z"}, "message": "dlist: A new implementation of an owned doubly-linked list\n\nThis is an owned sendable linked list which allows insertion and\ndeletion at both ends, with fast traversal through iteration, and fast\nappend/prepend.\n\nIt is indended to replace the previous managed DList with exposed list\nnodes. It does not match it feature by feature, but DList could grow\nmore methods if needed.", "tree": {"sha": "a19dbf54f082179735ce9e92b0ea0f79599c43eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a19dbf54f082179735ce9e92b0ea0f79599c43eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/824bb44f929a564dc4dd0590578de3ea04789402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/824bb44f929a564dc4dd0590578de3ea04789402", "html_url": "https://github.com/rust-lang/rust/commit/824bb44f929a564dc4dd0590578de3ea04789402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/824bb44f929a564dc4dd0590578de3ea04789402/comments", "author": null, "committer": null, "parents": [{"sha": "06accaf22b51e729142ce952caa0102aae7aa2da", "url": "https://api.github.com/repos/rust-lang/rust/commits/06accaf22b51e729142ce952caa0102aae7aa2da", "html_url": "https://github.com/rust-lang/rust/commit/06accaf22b51e729142ce952caa0102aae7aa2da"}], "stats": {"total": 1748, "additions": 842, "deletions": 906}, "files": [{"sha": "d3132b373453986c246e16e76c4dee4bbb147c23", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 834, "deletions": 898, "changes": 1732, "blob_url": "https://github.com/rust-lang/rust/blob/824bb44f929a564dc4dd0590578de3ea04789402/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/824bb44f929a564dc4dd0590578de3ea04789402/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=824bb44f929a564dc4dd0590578de3ea04789402", "patch": "@@ -1,966 +1,902 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+\n+//! A doubly-linked list with owned nodes.\n+//!\n+//! The List allows pushing and popping elements at either end.\n+\n+\n+// List is constructed like a singly-linked list over the field `next`.\n+// including the last link being None; each Node owns its `next` field.\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// Backlinks over List::prev are raw pointers that form a full chain in\n+// the reverse direction.\n \n-/*!\n \n-A doubly-linked list. Supports O(1) head, tail, count, push, pop, etc.\n+use std::cast;\n+use std::cmp;\n+use std::util;\n+use std::iterator::FromIterator;\n \n-# Safety note\n+/// A doubly-linked list\n+pub struct List<T> {\n+    priv length: uint,\n+    priv list_head: Link<T>,\n+    priv list_tail: Rawlink<T>,\n+}\n \n-Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n+type Link<T> = Option<~Node<T>>;\n+type Rawlink<T> = Option<&'static Node<T>>;\n+// Rawlink uses &'static to have a small Option<&'> represenation.\n+// FIXME: Use a raw pointer like *mut Node if possible.\n+// FIXME: Causes infinite recursion in %? repr\n \n-*/\n+struct Node<T> {\n+    priv next: Link<T>,\n+    priv prev: Rawlink<T>,\n+    priv value: T,\n+}\n \n+/// List iterator\n+pub struct ForwardIterator<'self, T> {\n+    priv list: &'self List<T>,\n+    priv next: &'self Link<T>,\n+}\n \n-use std::managed;\n+/// List reverse iterator\n+pub struct ReverseIterator<'self, T> {\n+    priv list: &'self List<T>,\n+    priv next: Rawlink<T>,\n+}\n \n-pub type DListLink<T> = Option<@mut DListNode<T>>;\n+/// List mutable iterator\n+pub struct MutForwardIterator<'self, T> {\n+    priv list: &'self mut List<T>,\n+    priv curs: Rawlink<T>,\n+}\n \n-#[allow(missing_doc)]\n-pub struct DListNode<T> {\n-    data: T,\n-    linked: bool, // for assertions\n-    prev: DListLink<T>,\n-    next: DListLink<T>,\n+/// List mutable reverse iterator\n+pub struct MutReverseIterator<'self, T> {\n+    priv list: &'self mut List<T>,\n+    priv next: Rawlink<T>,\n }\n \n-#[allow(missing_doc)]\n-pub struct DList<T> {\n-    size: uint,\n-    hd: DListLink<T>,\n-    tl: DListLink<T>,\n+/// List consuming iterator\n+pub struct ConsumeIterator<T> {\n+    priv list: List<T>\n }\n \n-impl<T> DListNode<T> {\n-    fn assert_links(@mut self) {\n-        match self.next {\n-            Some(neighbour) => match neighbour.prev {\n-              Some(me) => if !managed::mut_ptr_eq(self, me) {\n-                  fail!(\"Asymmetric next-link in dlist node.\")\n-              },\n-              None => fail!(\"One-way next-link in dlist node.\")\n-            },\n-            None => ()\n-        }\n-        match self.prev {\n-            Some(neighbour) => match neighbour.next {\n-              Some(me) => if !managed::mut_ptr_eq(me, self) {\n-                  fail!(\"Asymmetric prev-link in dlist node.\")\n-              },\n-              None => fail!(\"One-way prev-link in dlist node.\")\n-            },\n-            None => ()\n-        }\n-    }\n+/// List reverse consuming iterator\n+pub struct ConsumeRevIterator<T> {\n+    priv list: List<T>\n }\n \n-impl<T> DListNode<T> {\n-    /// Get the next node in the list, if there is one.\n-    pub fn next_link(@mut self) -> DListLink<T> {\n-        self.assert_links();\n-        self.next\n+impl<T> Container for List<T> {\n+    /// O(1)\n+    fn is_empty(&self) -> bool {\n+        self.list_head.is_none()\n     }\n-    /// Get the next node in the list, failing if there isn't one.\n-    pub fn next_node(@mut self) -> @mut DListNode<T> {\n-        match self.next_link() {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"This dlist node has no next neighbour.\")\n-        }\n-    }\n-    /// Get the previous node in the list, if there is one.\n-    pub fn prev_link(@mut self) -> DListLink<T> {\n-        self.assert_links();\n-        self.prev\n-    }\n-    /// Get the previous node in the list, failing if there isn't one.\n-    pub fn prev_node(@mut self) -> @mut DListNode<T> {\n-        match self.prev_link() {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"This dlist node has no previous neighbour.\")\n-        }\n+    /// O(1)\n+    fn len(&self) -> uint {\n+        self.length\n     }\n }\n \n-/// Creates a new dlist node with the given data.\n-pub fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n-    @mut DListNode { data: data, linked: false, prev: None, next: None }\n+impl<T> Mutable for List<T> {\n+    /// Remove all elements from the List\n+    ///\n+    /// O(N)\n+    fn clear(&mut self) {\n+        *self = List::new()\n+    }\n }\n \n-/// Creates a new, empty dlist.\n-pub fn DList<T>() -> @mut DList<T> {\n-    @mut DList { size: 0, hd: None, tl: None }\n+/// Cast the raw link into a borrowed ref\n+fn resolve_rawlink<T>(lnk: &'static Node<T>) -> &mut Node<T> {\n+    unsafe { cast::transmute_mut(lnk) }\n }\n-\n-/// Creates a new dlist with a single element\n-pub fn from_elem<T>(data: T) -> @mut DList<T> {\n-    let list = DList();\n-    list.push(data);\n-    list\n+fn rawlink<T>(n: &mut Node<T>) -> Rawlink<T> {\n+    Some(unsafe { cast::transmute(n) })\n }\n \n-/// Creates a new dlist from a vector of elements, maintaining the same order\n-pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n-    do vec.iter().fold(DList()) |list,data| {\n-        // Iterating left-to-right -- add newly to the tail.\n-        list.push(copy *data);\n-        list\n+impl<T> List<T> {\n+    /// Create an empty List\n+    #[inline]\n+    pub fn new() -> List<T> {\n+        List{list_head: None, list_tail: None, length: 0}\n     }\n-}\n \n-/// Produce a list from a list of lists, leaving no elements behind in the\n-/// input. O(number of sub-lists).\n-pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n-    let result = DList();\n-    while !lists.is_empty() {\n-        result.append(lists.pop().get());\n+    /// Provide a reference to the front element, or None if the list is empty\n+    pub fn peek_front<'a>(&'a self) -> Option<&'a T> {\n+        self.list_head.chain_ref(|x| Some(&x.value))\n     }\n-    result\n-}\n \n-impl<T> DList<T> {\n-    fn new_link(data: T) -> DListLink<T> {\n-        Some(@mut DListNode {\n-            data: data,\n-            linked: true,\n-            prev: None,\n-            next: None\n-        })\n+    /// Provide a mutable reference to the front element, or None if the list is empty\n+    pub fn peek_front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        match self.list_head {\n+            None => None,\n+            Some(ref mut head) => Some(&mut head.value),\n+        }\n     }\n-    fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n-        // These asserts could be stronger if we had node-root back-pointers,\n-        // but those wouldn't allow for O(1) append.\n-        if self.size == 0 {\n-            fail!(\"This dlist is empty; that node can't be on it.\")\n+\n+    /// Provide a reference to the back element, or None if the list is empty\n+    pub fn peek_back<'a>(&'a self) -> Option<&'a T> {\n+        match self.list_tail {\n+            None => None,\n+            Some(tail) => Some(&resolve_rawlink(tail).value),\n         }\n-        if !nobe.linked { fail!(\"That node isn't linked to any dlist.\") }\n-        if !((nobe.prev.is_some()\n-              || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                 nobe)) &&\n-             (nobe.next.is_some()\n-              || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                 nobe))) {\n-            fail!(\"That node isn't on this dlist.\")\n+    }\n+\n+    /// Provide a mutable reference to the back element, or None if the list is empty\n+    pub fn peek_back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        match self.list_tail {\n+            None => None,\n+            Some(tail) => Some(&mut resolve_rawlink(tail).value),\n         }\n     }\n-    fn make_mine(&self, nobe: @mut DListNode<T>) {\n-        if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n-            fail!(\"Cannot insert node that's already on a dlist!\")\n+\n+    /// Add an element last in the list\n+    ///\n+    /// O(1)\n+    pub fn push_back(&mut self, elt: T) {\n+        match self.list_tail {\n+            None => return self.push_front(elt),\n+            Some(rtail) => {\n+                let mut new_tail = ~Node{value: elt, next: None, prev: self.list_tail};\n+                self.list_tail = rawlink(new_tail);\n+                let tail = resolve_rawlink(rtail);\n+                tail.next = Some(new_tail);\n+            }\n         }\n-        nobe.linked = true;\n+        self.length += 1;\n     }\n-    // Link two nodes together. If either of them are 'none', also sets\n-    // the head and/or tail pointers appropriately.\n+\n+    /// Remove the last element and return it, or None if the list is empty\n+    ///\n+    /// O(1)\n     #[inline]\n-    fn link(&mut self, before: DListLink<T>, after: DListLink<T>) {\n-        match before {\n-            Some(neighbour) => neighbour.next = after,\n-            None            => self.hd        = after\n-        }\n-        match after {\n-            Some(neighbour) => neighbour.prev = before,\n-            None            => self.tl        = before\n-        }\n-    }\n-    // Remove a node from the list.\n-    fn unlink(@mut self, nobe: @mut DListNode<T>) {\n-        self.assert_mine(nobe);\n-        assert!(self.size > 0);\n-        self.link(nobe.prev, nobe.next);\n-        nobe.prev = None; // Release extraneous references.\n-        nobe.next = None;\n-        nobe.linked = false;\n-        self.size -= 1;\n-    }\n-\n-    fn add_head(@mut self, nobe: DListLink<T>) {\n-        self.link(nobe, self.hd); // Might set tail too.\n-        self.hd = nobe;\n-        self.size += 1;\n-    }\n-    fn add_tail(@mut self, nobe: DListLink<T>) {\n-        self.link(self.tl, nobe); // Might set head too.\n-        self.tl = nobe;\n-        self.size += 1;\n-    }\n-    fn insert_left(@mut self,\n-                   nobe: DListLink<T>,\n-                   neighbour: @mut DListNode<T>) {\n-        self.assert_mine(neighbour);\n-        assert!(self.size > 0);\n-        self.link(neighbour.prev, nobe);\n-        self.link(nobe, Some(neighbour));\n-        self.size += 1;\n-    }\n-    fn insert_right(@mut self,\n-                    neighbour: @mut DListNode<T>,\n-                    nobe: DListLink<T>) {\n-        self.assert_mine(neighbour);\n-        assert!(self.size > 0);\n-        self.link(nobe, neighbour.next);\n-        self.link(Some(neighbour), nobe);\n-        self.size += 1;\n-    }\n-}\n-\n-impl<T> DList<T> {\n-    /**\n-     * Iterates through the current contents.\n-     *\n-     * Attempts to access this dlist during iteration are allowed (to\n-     * allow for e.g. breadth-first search with in-place enqueues), but\n-     * removing the current node is forbidden.\n-     */\n-    pub fn each(@mut self, f: &fn(v: &T) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { return false; }\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        match self.list_tail {\n+            None => None,\n+            Some(rtail) => {\n+                self.length -= 1;\n+                let tail = resolve_rawlink(rtail);\n+                let tail_own = match tail.prev {\n+                    None => {\n+                        self.list_tail = None;\n+                        self.list_head.swap_unwrap()\n+                    },\n+                    Some(rtail_prev) => {\n+                        self.list_tail = tail.prev;\n+                        resolve_rawlink(rtail_prev).next.swap_unwrap()\n+                    }\n+                };\n+                Some(tail_own.value)\n             }\n+        }\n+    }\n \n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(\"The dlist became empty during iteration??\")\n+    /// Add an element first in the list\n+    ///\n+    /// O(1)\n+    pub fn push_front(&mut self, elt: T) {\n+        let mut new_head = ~Node{value: elt, next: None, prev: None};\n+        match self.list_head {\n+            None => {\n+                self.list_tail = rawlink(new_head);\n+                self.list_head = Some(new_head);\n             }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+            Some(ref mut head) => {\n+                head.prev = rawlink(new_head);\n+                util::swap(head, &mut new_head);\n+                head.next = Some(new_head);\n             }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    /// Get the size of the list. O(1).\n-    pub fn len(@mut self) -> uint { self.size }\n-    /// Returns true if the list is empty. O(1).\n-    pub fn is_empty(@mut self) -> bool { self.len() == 0 }\n-\n-    /// Add data to the head of the list. O(1).\n-    pub fn push_head(@mut self, data: T) {\n-        self.add_head(DList::new_link(data));\n-    }\n-    /**\n-     * Add data to the head of the list, and get the new containing\n-     * node. O(1).\n-     */\n-    pub fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.add_head(nobe);\n-        nobe.get()\n-    }\n-    /// Add data to the tail of the list. O(1).\n-    pub fn push(@mut self, data: T) {\n-        self.add_tail(DList::new_link(data));\n-    }\n-    /**\n-     * Add data to the tail of the list, and get the new containing\n-     * node. O(1).\n-     */\n-    pub fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.add_tail(nobe);\n-        nobe.get()\n-    }\n-    /**\n-     * Insert data into the middle of the list, left of the given node.\n-     * O(1).\n-     */\n-    pub fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n-        self.insert_left(DList::new_link(data), neighbour);\n-    }\n-    /**\n-     * Insert an existing node in the middle of the list, left of the\n-     * given node. O(1).\n-     */\n-    pub fn insert_n_before(@mut self,\n-                           nobe: @mut DListNode<T>,\n-                           neighbour: @mut DListNode<T>) {\n-        self.make_mine(nobe);\n-        self.insert_left(Some(nobe), neighbour);\n-    }\n-    /**\n-     * Insert data in the middle of the list, left of the given node,\n-     * and get its containing node. O(1).\n-     */\n-    pub fn insert_before_n(@mut self,\n-                           data: T,\n-                           neighbour: @mut DListNode<T>)\n-                           -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.insert_left(nobe, neighbour);\n-        nobe.get()\n-    }\n-    /**\n-     * Insert data into the middle of the list, right of the given node.\n-     * O(1).\n-     */\n-    pub fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n-        self.insert_right(neighbour, DList::new_link(data));\n-    }\n-    /**\n-     * Insert an existing node in the middle of the list, right of the\n-     * given node. O(1).\n-     */\n-    pub fn insert_n_after(@mut self,\n-                          nobe: @mut DListNode<T>,\n-                          neighbour: @mut DListNode<T>) {\n-        self.make_mine(nobe);\n-        self.insert_right(neighbour, Some(nobe));\n-    }\n-    /**\n-     * Insert data in the middle of the list, right of the given node,\n-     * and get its containing node. O(1).\n-     */\n-    pub fn insert_after_n(@mut self,\n-                          data: T,\n-                          neighbour: @mut DListNode<T>)\n-                          -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.insert_right(neighbour, nobe);\n-        nobe.get()\n-    }\n-\n-    /// Remove a node from the head of the list. O(1).\n-    pub fn pop_n(@mut self) -> DListLink<T> {\n-        let hd = self.peek_n();\n-        hd.map(|nobe| self.unlink(*nobe));\n-        hd\n-    }\n-    /// Remove a node from the tail of the list. O(1).\n-    pub fn pop_tail_n(@mut self) -> DListLink<T> {\n-        let tl = self.peek_tail_n();\n-        tl.map(|nobe| self.unlink(*nobe));\n-        tl\n-    }\n-    /// Get the node at the list's head. O(1).\n-    pub fn peek_n(@mut self) -> DListLink<T> { self.hd }\n-    /// Get the node at the list's tail. O(1).\n-    pub fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n-\n-    /// Get the node at the list's head, failing if empty. O(1).\n-    pub fn head_n(@mut self) -> @mut DListNode<T> {\n-        match self.hd {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"Attempted to get the head of an empty dlist.\")\n-        }\n-    }\n-    /// Get the node at the list's tail, failing if empty. O(1).\n-    pub fn tail_n(@mut self) -> @mut DListNode<T> {\n-        match self.tl {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"Attempted to get the tail of an empty dlist.\")\n-        }\n-    }\n-\n-    /// Remove a node from anywhere in the list. O(1).\n-    pub fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n-\n-    /**\n-     * Empty another list onto the end of this list, joining this list's tail\n-     * to the other list's head. O(1).\n-     */\n-    pub fn append(@mut self, them: @mut DList<T>) {\n-        if managed::mut_ptr_eq(self, them) {\n-            fail!(\"Cannot append a dlist to itself!\")\n-        }\n-        if them.len() > 0 {\n-            self.link(self.tl, them.hd);\n-            self.tl    = them.tl;\n-            self.size += them.size;\n-            them.size  = 0;\n-            them.hd    = None;\n-            them.tl    = None;\n-        }\n-    }\n-    /**\n-     * Empty another list onto the start of this list, joining the other\n-     * list's tail to this list's head. O(1).\n-     */\n-    pub fn prepend(@mut self, them: @mut DList<T>) {\n-        if managed::mut_ptr_eq(self, them) {\n-            fail!(\"Cannot prepend a dlist to itself!\")\n-        }\n-        if them.len() > 0 {\n-            self.link(them.tl, self.hd);\n-            self.hd    = them.hd;\n-            self.size += them.size;\n-            them.size  = 0;\n-            them.hd    = None;\n-            them.tl    = None;\n-        }\n-    }\n-\n-    /// Reverse the list's elements in place. O(n).\n-    pub fn reverse(@mut self) {\n-        do self.hd.while_some |nobe| {\n-            let next_nobe = nobe.next;\n-            self.remove(nobe);\n-            self.make_mine(nobe);\n-            self.add_head(Some(nobe));\n-            next_nobe\n-        }\n-    }\n-\n-    /**\n-     * Remove everything from the list. This is important because the cyclic\n-     * links won't otherwise be automatically refcounted-collected. O(n).\n-     */\n-    pub fn clear(@mut self) {\n-        // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n-        // the GC would still be a hidden O(n). Better to be honest about it.\n-        while !self.is_empty() {\n-            let _ = self.pop_n();\n-        }\n-    }\n-\n-    /// Iterate over nodes.\n-    pub fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            if !f(nobe) { return false; }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    /// Check data structure integrity. O(n).\n-    pub fn assert_consistent(@mut self) {\n-        if self.hd.is_none() || self.tl.is_none() {\n-            assert!(self.hd.is_none() && self.tl.is_none());\n-        }\n-        // iterate forwards\n-        let mut count = 0;\n-        let mut link = self.peek_n();\n-        let mut rabbit = link;\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-            // check cycle\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().next;\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the first element and return it, or None if the list is empty\n+    ///\n+    /// O(1)\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        match self.list_head {\n+            None => None,\n+            ref mut head @ Some(*) => {\n+                self.length -= 1;\n+                match *head.swap_unwrap() {\n+                    Node{value: value, next: Some(next), prev: _} => {\n+                        let mut mnext = next;\n+                        mnext.prev = None;\n+                        *head = Some(mnext);\n+                        Some(value)\n+                    }\n+                    Node{value: value, next: None, prev: _} => {\n+                        self.list_tail = None;\n+                        *head = None;\n+                        Some(value)\n+                    }\n+                }\n             }\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().next;\n+        }\n+    }\n+\n+    /// Add all elements from `other` to the end of the list\n+    ///\n+    /// O(1)\n+    pub fn append(&mut self, other: List<T>) {\n+        match self.list_tail {\n+            None => *self = other,\n+            Some(rtail) => {\n+                match other {\n+                    List{list_head: None, list_tail: _, length: _} => return,\n+                    List{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n+                        let mut lnk_node = node;\n+                        let tail = resolve_rawlink(rtail);\n+                        lnk_node.prev = self.list_tail;\n+                        tail.next = Some(lnk_node);\n+                        self.list_tail = o_tail;\n+                        self.length += o_length;\n+                    }\n+                }\n             }\n-            if rabbit.is_some() {\n-                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+        }\n+    }\n+\n+    /// Add all elements from `other` to the beginning of the list\n+    ///\n+    /// O(1)\n+    pub fn prepend(&mut self, mut other: List<T>) {\n+        util::swap(self, &mut other);\n+        self.append(other);\n+    }\n+\n+    /// Insert `elt` before the first `x` in the list where `f(x, elt)` is true,\n+    /// or at the end.\n+    ///\n+    /// O(N)\n+    #[inline]\n+    pub fn insert_before(&mut self, elt: T, f: &fn(&T, &T) -> bool) {\n+        {\n+            let mut it = self.mut_iter();\n+            loop {\n+                match it.next() {\n+                    None => break,\n+                    Some(x) => if f(x, &elt) { it.insert_before(elt); return }\n+                }\n             }\n-            // advance\n-            link = nobe.next_link();\n-            count += 1;\n-        }\n-        assert_eq!(count, self.len());\n-        // iterate backwards - some of this is probably redundant.\n-        link = self.peek_tail_n();\n-        rabbit = link;\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-            // check cycle\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().prev;\n+        }\n+        self.push_back(elt);\n+    }\n+\n+    /// Merge, using the function `f`; take `a` if `f(a, b)` is true, else `b`.\n+    ///\n+    /// O(max(N, M))\n+    pub fn merge(&mut self, mut other: List<T>, f: &fn(&T, &T) -> bool) {\n+        {\n+            let mut it = self.mut_iter();\n+            loop {\n+                match (it.next(), other.peek_front()) {\n+                    (None   , _      ) => break,\n+                    (_      , None   ) => return,\n+                    (Some(x), Some(y)) => if f(x, y) { loop }\n+                }\n+                it.insert_before(other.pop_front().unwrap());\n             }\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().prev;\n+        }\n+        self.append(other);\n+    }\n+\n+\n+    /// Provide a forward iterator\n+    pub fn iter<'a>(&'a self) -> ForwardIterator<'a, T> {\n+        ForwardIterator{list: self, next: &self.list_head}\n+    }\n+\n+    /// Provide a reverse iterator\n+    pub fn rev_iter<'a>(&'a self) -> ReverseIterator<'a, T> {\n+        ReverseIterator{list: self, next: self.list_tail}\n+    }\n+\n+    /// Provide a forward iterator with mutable references\n+    pub fn mut_iter<'a>(&'a mut self) -> MutForwardIterator<'a, T> {\n+        MutForwardIterator{list: self, curs: None}\n+    }\n+\n+    /// Provide a reverse iterator with mutable references\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> MutReverseIterator<'a, T> {\n+        MutReverseIterator{list: self, next: self.list_tail}\n+    }\n+\n+\n+    /// Consume the list into an iterator yielding elements by value\n+    pub fn consume_iter(self) -> ConsumeIterator<T> {\n+        ConsumeIterator{list: self}\n+    }\n+\n+    /// Consume the list into an iterator yielding elements by value, in reverse\n+    pub fn consume_rev_iter(self) -> ConsumeRevIterator<T> {\n+        ConsumeRevIterator{list: self}\n+    }\n+}\n+\n+/// Insert sorted in ascending order\n+///\n+/// O(N)\n+impl<T: cmp::TotalOrd> List<T> {\n+    fn insert_ordered(&mut self, elt: T) {\n+        self.insert_before(elt, |a, b| a.cmp(b) != cmp::Less);\n+    }\n+}\n+\n+impl<'self, A> Iterator<&'self A> for ForwardIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self A> {\n+        match *self.next {\n+            None => None,\n+            Some(ref next) => {\n+                self.next = &next.next;\n+                Some(&next.value)\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.list.length))\n+    }\n+}\n+\n+// MutForwardIterator is different because it implements ListInsertCursor,\n+// and can modify the list during traversal, used in insert_when and merge.\n+impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        match self.curs {\n+            None => {\n+                match self.list.list_head {\n+                    None => None,\n+                    Some(ref mut head) => {\n+                        self.curs = rawlink(&mut **head);\n+                        Some(&mut head.value)\n+                    }\n+                }\n+            }\n+            Some(rcurs) => {\n+                match resolve_rawlink(rcurs).next {\n+                    None => None,\n+                    Some(ref mut head) => {\n+                        self.curs = rawlink(&mut **head);\n+                        Some(&mut head.value)\n+                    }\n+                }\n             }\n-            if rabbit.is_some() {\n-                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.list.length))\n+    }\n+}\n+\n+impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self A> {\n+        match self.next {\n+            None => None,\n+            Some(rnext) => {\n+                let prev = resolve_rawlink(rnext);\n+                self.next = prev.prev;\n+                Some(&prev.value)\n             }\n-            // advance\n-            link = nobe.prev_link();\n-            count -= 1;\n         }\n-        assert_eq!(count, 0);\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.list.length))\n     }\n }\n \n-impl<T:Copy> DList<T> {\n-    /// Remove data from the head of the list. O(1).\n-    pub fn pop(@mut self) -> Option<T> {\n-        self.pop_n().map(|nobe| copy nobe.data)\n+impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        match self.next {\n+            None => None,\n+            Some(rnext) => {\n+                let prev = resolve_rawlink(rnext);\n+                self.next = prev.prev;\n+                Some(&mut prev.value)\n+            }\n+        }\n     }\n \n-    /// Remove data from the tail of the list. O(1).\n-    pub fn pop_tail(@mut self) -> Option<T> {\n-        self.pop_tail_n().map(|nobe| copy nobe.data)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.list.length))\n     }\n+}\n+\n+// XXX: Should this be `pub`?\n+trait ListInsertCursor<A> {\n+    /// Insert `elt` just previous to the most recently yielded element\n+    fn insert_before(&mut self, elt: A);\n+}\n \n-    /// Get data at the list's head. O(1).\n-    pub fn peek(@mut self) -> Option<T> {\n-        self.peek_n().map(|nobe| copy nobe.data)\n+impl<'self, A> ListInsertCursor<A> for MutForwardIterator<'self, A> {\n+    fn insert_before(&mut self, elt: A) {\n+        match self.curs {\n+            None => self.list.push_front(elt),\n+            Some(rcurs) => {\n+                let node = resolve_rawlink(rcurs);\n+                let prev_node = match node.prev {\n+                    None => return self.list.push_front(elt),  // at head\n+                    Some(rprev) => resolve_rawlink(rprev),\n+                };\n+                let mut node_own = prev_node.next.swap_unwrap();\n+                let mut ins_node = ~Node{value: elt,\n+                                         next: None,\n+                                         prev: rawlink(prev_node)};\n+                node_own.prev = rawlink(ins_node);\n+                ins_node.next = Some(node_own);\n+                prev_node.next = Some(ins_node);\n+                self.list.length += 1;\n+            }\n+        }\n     }\n+}\n \n-    /// Get data at the list's tail. O(1).\n-    pub fn peek_tail(@mut self) -> Option<T> {\n-        self.peek_tail_n().map (|nobe| copy nobe.data)\n+impl<A> Iterator<A> for ConsumeIterator<A> {\n+    fn next(&mut self) -> Option<A> { self.list.pop_front() }\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.list.length, Some(self.list.length))\n     }\n+}\n \n-    /// Get data at the list's head, failing if empty. O(1).\n-    pub fn head(@mut self) -> T { copy self.head_n().data }\n+impl<A> Iterator<A> for ConsumeRevIterator<A> {\n+    fn next(&mut self) -> Option<A> { self.list.pop_back() }\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.list.length, Some(self.list.length))\n+    }\n+}\n \n-    /// Get data at the list's tail, failing if empty. O(1).\n-    pub fn tail(@mut self) -> T { copy self.tail_n().data }\n+impl<A, T: Iterator<A>> FromIterator<A, T> for List<A> {\n+    fn from_iterator(iterator: &mut T) -> List<A> {\n+        let mut ret = List::new();\n+        for iterator.advance |elt| { ret.push_back(elt); }\n+        ret\n+    }\n+}\n+\n+impl<A: Eq> Eq for List<A> {\n+    fn eq(&self, other: &List<A>) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+    }\n+    fn ne(&self, other: &List<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl<A: Clone> Clone for List<A> {\n+    fn clone(&self) -> List<A> {\n+        self.iter().transform(|x| x.clone()).collect()\n+    }\n+}\n+\n+#[cfg(test)]\n+fn check_links<T>(list: &List<T>) {\n+    let mut len = 0u;\n+    let mut last_ptr: Option<&Node<T>> = None;\n+    let mut node_ptr: &Node<T>;\n+    match list.list_head {\n+        None => { assert_eq!(0u, list.length); return }\n+        Some(ref node) => node_ptr = &**node,\n+    }\n+    loop {\n+        match (last_ptr, node_ptr.prev) {\n+            (None   , None      ) => {}\n+            (None   , _         ) => fail!(\"prev link for list_head\"),\n+            (Some(p), Some(pptr)) => {\n+                assert_eq!((p as *Node<T>) as uint, pptr as *Node<T> as uint);\n+            }\n+            _ => fail!(\"prev link is none, not good\"),\n+        }\n+        match node_ptr.next {\n+            Some(ref next) => {\n+                last_ptr = Some(node_ptr);\n+                node_ptr = &**next;\n+                len += 1;\n+            }\n+            None => {\n+                len += 1;\n+                break;\n+            }\n+        }\n+    }\n+    assert_eq!(len, list.length);\n+}\n+\n+#[test]\n+fn test_basic() {\n+    let mut m = List::new::<~int>();\n+    assert_eq!(m.pop_front(), None);\n+    assert_eq!(m.pop_back(), None);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_front(~1);\n+    assert_eq!(m.pop_front(), Some(~1));\n+    m.push_back(~2);\n+    m.push_back(~3);\n+    assert_eq!(m.len(), 2);\n+    assert_eq!(m.pop_front(), Some(~2));\n+    assert_eq!(m.pop_front(), Some(~3));\n+    assert_eq!(m.len(), 0);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_back(~1);\n+    m.push_back(~3);\n+    m.push_back(~5);\n+    m.push_back(~7);\n+    assert_eq!(m.pop_front(), Some(~1));\n+\n+    let mut n = List::new();\n+    n.push_front(2);\n+    n.push_front(3);\n+    {\n+        assert_eq!(n.peek_front().unwrap(), &3);\n+        let x = n.peek_front_mut().unwrap();\n+        assert_eq!(*x, 3);\n+        *x = 0;\n+    }\n+    {\n+        assert_eq!(n.peek_back().unwrap(), &2);\n+        let y = n.peek_back_mut().unwrap();\n+        assert_eq!(*y, 2);\n+        *y = 1;\n+    }\n+    assert_eq!(n.pop_front(), Some(0));\n+    assert_eq!(n.pop_front(), Some(1));\n+}\n+\n+#[cfg(test)]\n+fn generate_test() -> List<int> {\n+    list_from(&[0,1,2,3,4,5,6])\n }\n \n #[cfg(test)]\n-mod tests {\n+fn list_from<T: Copy>(v: &[T]) -> List<T> {\n+    v.iter().transform(|x| copy *x).collect()\n+}\n \n-    use super::*;\n+#[test]\n+fn test_append() {\n+    {\n+        let mut m = List::new();\n+        let mut n = List::new();\n+        n.push_back(2);\n+        m.append(n);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+    {\n+        let mut m = List::new();\n+        let n = List::new();\n+        m.push_back(2);\n+        m.append(n);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    let v = ~[1,2,3,4,5];\n+    let u = ~[9,8,1,2,3,4,5];\n+    let mut m = list_from(v);\n+    m.append(list_from(u));\n+    check_links(&m);\n+    let sum = v + u;\n+    assert_eq!(sum.len(), m.len());\n+    for sum.consume_iter().advance |elt| {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+}\n+\n+#[test]\n+fn test_prepend() {\n+    {\n+        let mut m = List::new();\n+        let mut n = List::new();\n+        n.push_back(2);\n+        m.prepend(n);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    let v = ~[1,2,3,4,5];\n+    let u = ~[9,8,1,2,3,4,5];\n+    let mut m = list_from(v);\n+    m.prepend(list_from(u));\n+    check_links(&m);\n+    let sum = u + v;\n+    assert_eq!(sum.len(), m.len());\n+    for sum.consume_iter().advance |elt| {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+}\n+\n+#[test]\n+fn test_iterator() {\n+    let m = generate_test();\n+    for m.iter().enumerate().advance |(i, elt)| {\n+        assert_eq!(i as int, *elt);\n+    }\n+    let mut n = List::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter();\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_rev_iter() {\n+    let m = generate_test();\n+    for m.rev_iter().enumerate().advance |(i, elt)| {\n+        assert_eq!((6 - i) as int, *elt);\n+    }\n+    let mut n = List::new();\n+    assert_eq!(n.rev_iter().next(), None);\n+    n.push_front(4);\n+    let mut it = n.rev_iter();\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let mut m = generate_test();\n+    let mut len = m.len();\n+    for m.mut_iter().enumerate().advance |(i, elt)| {\n+        assert_eq!(i as int, *elt);\n+        len -= 1;\n+    }\n+    assert_eq!(len, 0);\n+    let mut n = List::new();\n+    assert!(n.mut_iter().next().is_none());\n+    n.push_front(4);\n+    let mut it = n.mut_iter();\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_list_cursor() {\n+    let mut m = generate_test();\n+    let len = m.len();\n+    {\n+        let mut it = m.mut_iter();\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => it.insert_before(*elt * 2),\n+            }\n+        }\n+    }\n+    assert_eq!(m.len(), len * 2);\n+    check_links(&m);\n+}\n+\n+#[test]\n+fn test_merge() {\n+    let mut m = list_from([0, 1, 3, 5, 6, 7, 2]);\n+    let n = list_from([-1, 0, 0, 7, 7, 9]);\n+    let len = m.len() + n.len();\n+    m.merge(n, |a, b| a <= b);\n+    assert_eq!(m.len(), len);\n+    check_links(&m);\n+    let res = m.consume_iter().collect::<~[int]>();\n+    assert_eq!(res, ~[-1, 0, 0, 1, 0, 3, 5, 6, 7, 2, 7, 7, 9]);\n+}\n+\n+#[test]\n+fn test_insert_ordered() {\n+    let mut n = List::new();\n+    n.insert_ordered(1);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(1));\n+\n+    let mut m = List::new();\n+    m.push_back(2);\n+    m.push_back(4);\n+    m.insert_ordered(3);\n+    check_links(&m);\n+    assert_eq!(~[2,3,4], m.consume_iter().collect::<~[int]>());\n+}\n+\n+#[test]\n+fn test_mut_rev_iter() {\n+    let mut m = generate_test();\n+    for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n+        assert_eq!((6-i) as int, *elt);\n+    }\n+    let mut n = List::new();\n+    assert!(n.mut_rev_iter().next().is_none());\n+    n.push_front(4);\n+    let mut it = n.mut_rev_iter();\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_send() {\n+    let n = list_from([1,2,3]);\n+    do spawn {\n+        check_links(&n);\n+        assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n+    }\n+}\n+\n+#[test]\n+fn test_eq() {\n+    let mut n: List<u8> = list_from([]);\n+    let mut m = list_from([]);\n+    assert_eq!(&n, &m);\n+    n.push_front(1);\n+    assert!(n != m);\n+    m.push_back(1);\n+    assert_eq!(&n, &m);\n+}\n+\n+#[test]\n+fn test_fuzz() {\n+    for 25.times {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        fuzz_test(189);\n+    }\n+}\n \n-    #[test]\n-    fn test_dlist_concat() {\n-        let a = from_vec([1,2]);\n-        let b = from_vec([3,4]);\n-        let c = from_vec([5,6]);\n-        let d = from_vec([7,8]);\n-        let ab = from_vec([a,b]);\n-        let cd = from_vec([c,d]);\n-        let abcd = concat(concat(from_vec([ab,cd])));\n-        abcd.assert_consistent(); assert_eq!(abcd.len(), 8);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 1);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 2);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 3);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 4);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 5);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 6);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 7);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 8);\n-        abcd.assert_consistent(); assert!(abcd.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append() {\n-        let a = from_vec([1,2,3]);\n-        let b = from_vec([4,5,6]);\n-        a.append(b);\n-        assert_eq!(a.len(), 6);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append_empty() {\n-        let a = from_vec([1,2,3]);\n-        let b = DList::<int>();\n-        a.append(b);\n-        assert_eq!(a.len(), 3);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append_to_empty() {\n-        let a = DList::<int>();\n-        let b = from_vec([4,5,6]);\n-        a.append(b);\n-        assert_eq!(a.len(), 3);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append_two_empty() {\n-        let a = DList::<int>();\n-        let b = DList::<int>();\n-        a.append(b);\n-        assert_eq!(a.len(), 0);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent();\n-    }\n-    #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_dlist_append_self() {\n-        let a = DList::<int>();\n-        a.append(a);\n-    }\n-    #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_dlist_prepend_self() {\n-        let a = DList::<int>();\n-        a.prepend(a);\n-    }\n-    #[test]\n-    fn test_dlist_prepend() {\n-        let a = from_vec([1,2,3]);\n-        let b = from_vec([4,5,6]);\n-        b.prepend(a);\n-        assert_eq!(a.len(), 0);\n-        assert_eq!(b.len(), 6);\n-        a.assert_consistent();\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 1);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 2);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 3);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 4);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 5);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 6);\n-        b.assert_consistent(); assert!(b.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_reverse() {\n-        let a = from_vec([5,4,3,2,1]);\n-        a.reverse();\n-        assert_eq!(a.len(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_reverse_empty() {\n-        let a = DList::<int>();\n-        a.reverse();\n-        assert_eq!(a.len(), 0);\n-        a.assert_consistent();\n-    }\n-    #[test]\n-    fn test_dlist_each_node() {\n-        let a = from_vec([1,2,4,5]);\n-        for a.each_node |nobe| {\n-            if nobe.data > 3 {\n-                a.insert_before(3, nobe);\n+#[cfg(test)]\n+fn fuzz_test(sz: int) {\n+    use std::rand;\n+    use std::int;\n+\n+    let mut m = List::new::<int>();\n+    let mut v = ~[];\n+    for int::range(0i, sz) |i| {\n+        check_links(&m);\n+        let r: u8 = rand::random();\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                if v.len() > 0 { v.pop(); }\n+            }\n+            1 => {\n+                m.pop_front();\n+                if v.len() > 0 { v.shift(); }\n             }\n+            2 | 4 =>  {\n+                m.push_front(-i);\n+                v.unshift(-i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0u;\n+    for m.consume_iter().zip(v.iter()).advance |(a, &b)| {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+\n+#[cfg(test)]\n+mod test_bench {\n+    use extra::test;\n+\n+    use super::*;\n+\n+    #[bench]\n+    fn bench_collect_into(b: &mut test::BenchHarness) {\n+        let v = &[0, ..64];\n+        do b.iter {\n+            let _: List<int> = v.iter().transform(|&x|x).collect();\n+        }\n+    }\n+    #[bench]\n+    fn bench_collect_into_vec(b: &mut test::BenchHarness) {\n+        let v = &[0, ..64];\n+        do b.iter {\n+            let _: ~[int] = v.iter().transform(|&x|x).collect();\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_push_front(b: &mut test::BenchHarness) {\n+        let mut m = List::new::<int>();\n+        do b.iter {\n+            m.push_front(0);\n+        }\n+    }\n+    #[bench]\n+    fn bench_push_front_vec_size10(b: &mut test::BenchHarness) {\n+        let mut m = ~[0, ..10];\n+        do b.iter {\n+            m.unshift(0);\n+            m.pop(); // to keep it fair, dont' grow the vec\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_push_back(b: &mut test::BenchHarness) {\n+        let mut m = List::new::<int>();\n+        do b.iter {\n+            m.push_back(0);\n+        }\n+    }\n+    #[bench]\n+    fn bench_push_back_vec(b: &mut test::BenchHarness) {\n+        let mut m = ~[];\n+        do b.iter {\n+            m.push(0);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n+        let mut m = List::new::<int>();\n+        do b.iter {\n+            m.push_back(0);\n+            m.pop_back();\n+        }\n+    }\n+    #[bench]\n+    fn bench_push_back_pop_back_vec(b: &mut test::BenchHarness) {\n+        let mut m = ~[];\n+        do b.iter {\n+            m.push(0);\n+            m.pop();\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_iter(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let m: List<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.iter().advance |_| {}\n+        }\n+    }\n+    #[bench]\n+    fn bench_iter_mut(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let mut m: List<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.mut_iter().advance |_| {}\n+        }\n+    }\n+    #[bench]\n+    fn bench_iter_rev(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let m: List<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.rev_iter().advance |_| {}\n+        }\n+    }\n+    #[bench]\n+    fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let mut m: List<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.mut_rev_iter().advance |_| {}\n+        }\n+    }\n+    #[bench]\n+    fn bench_iter_vec(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        do b.iter {\n+            for v.iter().advance |_| {}\n         }\n-        assert_eq!(a.len(), 6);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_clear() {\n-        let a = from_vec([5,4,3,2,1]);\n-        a.clear();\n-        assert_eq!(a.len(), 0);\n-        a.assert_consistent();\n-    }\n-    #[test]\n-    fn test_dlist_is_empty() {\n-        let empty = DList::<int>();\n-        let full1 = from_vec([1,2,3]);\n-        assert!(empty.is_empty());\n-        assert!(!full1.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_head_tail() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n-    }\n-    #[test]\n-    fn test_dlist_pop() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.pop().get(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.head(), 2);\n-        assert_eq!(l.pop().get(), 2);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.head(), 3);\n-        assert_eq!(l.pop().get(), 3);\n-        assert!(l.is_empty());\n-        assert!(l.pop().is_none());\n-    }\n-    #[test]\n-    fn test_dlist_pop_tail() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.pop_tail().get(), 3);\n-        assert_eq!(l.tail(), 2);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.pop_tail().get(), 2);\n-        assert_eq!(l.tail(), 1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.pop_tail().get(), 1);\n-        assert!(l.is_empty());\n-        assert!(l.pop_tail().is_none());\n-    }\n-    #[test]\n-    fn test_dlist_push() {\n-        let l = DList::<int>();\n-        l.push(1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 1);\n-        l.push(2);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 2);\n-        l.push(3);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n-    }\n-    #[test]\n-    fn test_dlist_push_head() {\n-        let l = DList::<int>();\n-        l.push_head(3);\n-        assert_eq!(l.head(), 3);\n-        assert_eq!(l.tail(), 3);\n-        l.push_head(2);\n-        assert_eq!(l.head(), 2);\n-        assert_eq!(l.tail(), 3);\n-        l.push_head(1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n-    }\n-    #[test]\n-    fn test_dlist_break_early() {\n-        let l = from_vec([1,2,3,4,5]);\n-        let mut x = 0;\n-        for l.each |i| {\n-            x += 1;\n-            if (*i == 3) { break; }\n-        }\n-        assert_eq!(x, 3);\n-    }\n-    #[test]\n-    fn test_dlist_remove_head() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 2);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_mid() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_tail() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_one_two() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); l.remove(two);\n-        // and through and through, the vorpal blade went snicker-snack\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 3);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_one_three() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 2);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_two_three() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_remove_all() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); assert!(l.peek().is_none());\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_insert_n_before() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_n_before(three, two);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_insert_n_after() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_n_after(three, one);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_insert_before_head() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_before(3, one);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 3);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_insert_after_tail() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_after(3, two);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_asymmetric_link() {\n-        let l = DList::<int>();\n-        let _one = l.push_n(1);\n-        let two = l.push_n(2);\n-        two.prev = None;\n-        l.assert_consistent();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_cyclic_list() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let _two = l.push_n(2);\n-        let three = l.push_n(3);\n-        three.next = Some(one);\n-        one.prev = Some(three);\n-        l.assert_consistent();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_headless() {\n-        DList::<int>().head();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_before() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let two = l.push_n(2);\n-        l.insert_n_before(two, one);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_after() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let two = l.push_n(2);\n-        l.insert_n_after(one, two);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_before_orphan() {\n-        let l = DList::<int>();\n-        let one = new_dlist_node(1);\n-        let two = new_dlist_node(2);\n-        l.insert_n_before(one, two);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_after_orphan() {\n-        let l = DList::<int>();\n-        let one = new_dlist_node(1);\n-        let two = new_dlist_node(2);\n-        l.insert_n_after(two, one);\n     }\n }\n+"}, {"sha": "5a9072a68d8f76529dcf58358386d86bc0e082d7", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/824bb44f929a564dc4dd0590578de3ea04789402/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/824bb44f929a564dc4dd0590578de3ea04789402/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=824bb44f929a564dc4dd0590578de3ea04789402", "patch": "@@ -24,7 +24,7 @@ use std::trie::{TrieMap, TrieSet};\n use std::uint;\n use std::vec;\n use deque::Deque;\n-use dlist::DList;\n+use dlist::List;\n use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n@@ -652,24 +652,24 @@ impl<\n impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n-> Encodable<S> for @mut DList<T> {\n+> Encodable<S> for List<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.size) |s| {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n-    fn decode(d: &mut D) -> @mut DList<T> {\n-        let list = DList();\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for List<T> {\n+    fn decode(d: &mut D) -> List<T> {\n+        let mut list = List::new();\n         do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                list.push(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         list"}]}