{"sha": "5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYmYzYmY4NDFjYmU2NjZiYmVlMGU2ODJmNjBkOWQ1Yzc0Y2E3MDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-21T15:30:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-21T15:30:20Z"}, "message": "Auto merge of #38488 - srinivasreddy:rf_collections, r=aturon\n\nrun rustfmt on libcollections folder", "tree": {"sha": "a64dda6cdc14da1b075c2db1365146ef7770e8c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a64dda6cdc14da1b075c2db1365146ef7770e8c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "html_url": "https://github.com/rust-lang/rust/commit/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b38776c1f68c6fd47c1b2f7b7974efc7dd64901", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b38776c1f68c6fd47c1b2f7b7974efc7dd64901", "html_url": "https://github.com/rust-lang/rust/commit/1b38776c1f68c6fd47c1b2f7b7974efc7dd64901"}, {"sha": "6414e67dbaa27f8638b01a33f49e462e87ecfab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6414e67dbaa27f8638b01a33f49e462e87ecfab3", "html_url": "https://github.com/rust-lang/rust/commit/6414e67dbaa27f8638b01a33f49e462e87ecfab3"}], "stats": {"total": 198, "additions": 103, "deletions": 95}, "files": [{"sha": "c5d5ad27d2304923dc51aa9196933c78072475b6", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -225,7 +225,7 @@ pub struct BinaryHeap<T> {\n /// [`peek_mut()`]: struct.BinaryHeap.html#method.peek_mut\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n-    heap: &'a mut BinaryHeap<T>\n+    heap: &'a mut BinaryHeap<T>,\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n@@ -385,9 +385,7 @@ impl<T: Ord> BinaryHeap<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            Some(PeekMut {\n-                heap: self\n-            })\n+            Some(PeekMut { heap: self })\n         }\n     }\n \n@@ -1126,7 +1124,9 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T>\n+    where T: Ord\n+{\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n "}, {"sha": "e5bcf0d8e81797d97d2cf134f9a04aa16ac21de2", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -63,7 +63,9 @@ pub trait ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ToOwned for T where T: Clone {\n+impl<T> ToOwned for T\n+    where T: Clone\n+{\n     type Owned = T;\n     fn to_owned(&self) -> T {\n         self.clone()\n@@ -117,17 +119,19 @@ pub enum Cow<'a, B: ?Sized + 'a>\n {\n     /// Borrowed data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a B),\n+    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             &'a B),\n \n     /// Owned data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] <B as ToOwned>::Owned\n-    ),\n+    Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+          <B as ToOwned>::Owned),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Clone for Cow<'a, B>\n+    where B: ToOwned\n+{\n     fn clone(&self) -> Cow<'a, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -139,7 +143,9 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n     }\n }\n \n-impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Cow<'a, B>\n+    where B: ToOwned\n+{\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned.\n@@ -194,7 +200,9 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Deref for Cow<'a, B>\n+    where B: ToOwned\n+{\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -209,7 +217,9 @@ impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n+impl<'a, B: ?Sized> Ord for Cow<'a, B>\n+    where B: Ord + ToOwned\n+{\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n@@ -228,7 +238,9 @@ impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned {\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n+    where B: PartialOrd + ToOwned\n+{\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -273,7 +285,9 @@ impl<'a, B: ?Sized> Default for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n+impl<'a, B: ?Sized> Hash for Cow<'a, B>\n+    where B: Hash + ToOwned\n+{\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)"}, {"sha": "87bc5e59ef78c178cff569aa19dba980dd42ded5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -276,7 +276,8 @@ impl<E: CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n-impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike\n+impl<'a, E> IntoIterator for &'a EnumSet<E>\n+    where E: CLike\n {\n     type Item = E;\n     type IntoIter = Iter<E>;"}, {"sha": "e8c2e0b590213bb13e9f32b6e0f4bf90a4082337", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -225,15 +225,17 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => if let Some(other_head) = other.head.take() {\n-                unsafe {\n-                    (**tail).next = Some(other_head);\n-                    (**other_head).prev = Some(tail);\n-                }\n+            Some(tail) => {\n+                if let Some(other_head) = other.head.take() {\n+                    unsafe {\n+                        (**tail).next = Some(other_head);\n+                        (**other_head).prev = Some(tail);\n+                    }\n \n-                self.tail = other.tail.take();\n-                self.len += mem::replace(&mut other.len, 0);\n-            },\n+                    self.tail = other.tail.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n         }\n     }\n \n@@ -674,7 +676,10 @@ impl<T> LinkedList<T> {\n                reason = \"method name and placement protocol are subject to change\",\n                issue = \"30172\")]\n     pub fn front_place(&mut self) -> FrontPlace<T> {\n-        FrontPlace { list: self, node: IntermediateBox::make_place() }\n+        FrontPlace {\n+            list: self,\n+            node: IntermediateBox::make_place(),\n+        }\n     }\n \n     /// Returns a place for insertion at the back of the list.\n@@ -699,7 +704,10 @@ impl<T> LinkedList<T> {\n                reason = \"method name and placement protocol are subject to change\",\n                issue = \"30172\")]\n     pub fn back_place(&mut self) -> BackPlace<T> {\n-        BackPlace { list: self, node: IntermediateBox::make_place() }\n+        BackPlace {\n+            list: self,\n+            node: IntermediateBox::make_place(),\n+        }\n     }\n }\n \n@@ -852,7 +860,7 @@ impl<'a, T> IterMut<'a, T> {\n                 (**head).prev = node;\n \n                 self.list.len += 1;\n-            }\n+            },\n         }\n     }\n \n@@ -1135,9 +1143,15 @@ impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> { x }\n-    fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> { x }\n-    fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> { x }\n+    fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> {\n+        x\n+    }\n+    fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> {\n+        x\n+    }\n+    fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> {\n+        x\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1298,10 +1312,10 @@ mod tests {\n     fn test_send() {\n         let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n-        })\n+                check_links(&n);\n+                let a: &[_] = &[&1, &2, &3];\n+                assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n+            })\n             .join()\n             .ok()\n             .unwrap();"}, {"sha": "70cedce9a905e7bebaeb536b25eadae5f38c2af8", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -1697,11 +1697,7 @@ impl str {\n             debug_assert!('\u03a3'.len_utf8() == 2);\n             let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n                                 !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final {\n-                \"\u03c2\"\n-            } else {\n-                \"\u03c3\"\n-            });\n+            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {"}, {"sha": "157c762b4a7ed3767cb223852dd5a4c67681fef1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -542,11 +542,7 @@ impl String {\n             unsafe { *xs.get_unchecked(i) }\n         }\n         fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n-            if i >= total {\n-                0\n-            } else {\n-                unsafe_get(xs, i)\n-            }\n+            if i >= total { 0 } else { unsafe_get(xs, i) }\n         }\n \n         let mut res = String::with_capacity(total);\n@@ -976,7 +972,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         match ch.len_utf8() {\n             1 => self.vec.push(ch as u8),\n-            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0;4]).as_bytes()),\n+            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes()),\n         }\n     }\n \n@@ -1935,7 +1931,7 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n \n #[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n impl From<String> for Vec<u8> {\n-    fn from(string : String) -> Vec<u8> {\n+    fn from(string: String) -> Vec<u8> {\n         string.into_bytes()\n     }\n }"}, {"sha": "67621b860bf391c5ad964a8e2b9f5bd23aecebc8", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf3bf841cbe666bbee0e682f60d9d5c74ca709/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=5fbf3bf841cbe666bbee0e682f60d9d5c74ca709", "patch": "@@ -206,11 +206,7 @@ impl<T> VecDeque<T> {\n     unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n         #[allow(dead_code)]\n         fn diff(a: usize, b: usize) -> usize {\n-            if a <= b {\n-                b - a\n-            } else {\n-                a - b\n-            }\n+            if a <= b { b - a } else { a - b }\n         }\n         debug_assert!(cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n                       \"wrc dst={} src={} len={} cap={}\",\n@@ -552,8 +548,8 @@ impl<T> VecDeque<T> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n-                              .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-                              .expect(\"capacity overflow\");\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .expect(\"capacity overflow\");\n \n         if new_cap > self.capacity() {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n@@ -1293,9 +1289,7 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous,\n-               distance_to_tail <= distance_to_head,\n-               idx >= self.tail) {\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n@@ -1513,9 +1507,7 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous,\n-               distance_to_tail <= distance_to_head,\n-               idx >= self.tail) {\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) => {\n                 unsafe {\n                     // contiguous, remove closer to tail:\n@@ -1812,7 +1804,7 @@ fn wrap_index(index: usize, size: usize) -> usize {\n }\n \n /// Returns the two slices that cover the VecDeque's valid range\n-trait RingSlices : Sized {\n+trait RingSlices: Sized {\n     fn slice(self, from: usize, to: usize) -> Self;\n     fn split_at(self, i: usize) -> (Self, Self);\n \n@@ -1895,7 +1887,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+        where F: FnMut(Acc, Self::Item) -> Acc\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter().fold(accum, &mut f);\n@@ -1959,7 +1951,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+        where F: FnMut(Acc, Self::Item) -> Acc\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter_mut().fold(accum, &mut f);\n@@ -2082,17 +2074,15 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n             (_, 0) => {\n                 source_deque.head = drain_tail;\n             }\n-            _ => {\n-                unsafe {\n-                    if tail_len <= head_len {\n-                        source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                        source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                    } else {\n-                        source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                        source_deque.wrap_copy(drain_tail, drain_head, head_len);\n-                    }\n+            _ => unsafe {\n+                if tail_len <= head_len {\n+                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                } else {\n+                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n                 }\n-            }\n+            },\n         }\n     }\n }\n@@ -2288,18 +2278,16 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.cap().is_power_of_two()\n-                || (buf.cap() < (MINIMUM_CAPACITY + 1))\n-                || (buf.cap() == len)\n-            {\n+            if !buf.cap().is_power_of_two() || (buf.cap() < (MINIMUM_CAPACITY + 1)) ||\n+               (buf.cap() == len) {\n                 let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n             VecDeque {\n                 tail: 0,\n                 head: len,\n-                buf: buf\n+                buf: buf,\n             }\n         }\n     }\n@@ -2324,18 +2312,17 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                     // do this in at most three copy moves.\n                     if (cap - tail) > head {\n                         // right hand block is the long one; move that enough for the left\n-                        ptr::copy(\n-                            buf.offset(tail as isize),\n-                            buf.offset((tail - head) as isize),\n-                            cap - tail);\n+                        ptr::copy(buf.offset(tail as isize),\n+                                  buf.offset((tail - head) as isize),\n+                                  cap - tail);\n                         // copy left in the end\n                         ptr::copy(buf, buf.offset((cap - head) as isize), head);\n                         // shift the new thing to the start\n-                        ptr::copy(buf.offset((tail-head) as isize), buf, len);\n+                        ptr::copy(buf.offset((tail - head) as isize), buf, len);\n                     } else {\n                         // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.offset((cap-tail) as isize), head);\n-                        ptr::copy(buf.offset(tail as isize), buf, cap-tail);\n+                        ptr::copy(buf, buf.offset((cap - tail) as isize), head);\n+                        ptr::copy(buf.offset(tail as isize), buf, cap - tail);\n                     }\n                 } else {\n                     // Need to use N swaps to move the ring\n@@ -2576,8 +2563,8 @@ mod tests {\n \n                         // We should see the correct values in the VecDeque\n                         let expected: VecDeque<_> = (0..drain_start)\n-                                                        .chain(drain_end..len)\n-                                                        .collect();\n+                            .chain(drain_end..len)\n+                            .collect();\n                         assert_eq!(expected, tester);\n                     }\n                 }\n@@ -2693,19 +2680,19 @@ mod tests {\n             let cap = (2i32.pow(cap_pwr) - 1) as usize;\n \n             // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap+1)/2) {\n+            for len in 0..((cap + 1) / 2) {\n                 // Test contiguous cases\n-                for offset in 0..(cap-len) {\n+                for offset in 0..(cap - len) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap-len)..(cap-(len/2)) {\n+                for offset in (cap - len)..(cap - (len / 2)) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap-(len/2))..cap {\n+                for offset in (cap - (len / 2))..cap {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n             }\n@@ -2714,19 +2701,19 @@ mod tests {\n             // the ring will use swapping when:\n             // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n             //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap+1)/2)..cap {\n+            for len in ((cap + 1) / 2)..cap {\n                 // Test contiguous cases\n-                for offset in 0..(cap-len) {\n+                for offset in 0..(cap - len) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap-len)..(cap-(len/2)) {\n+                for offset in (cap - len)..(cap - (len / 2)) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap-(len/2))..cap {\n+                for offset in (cap - (len / 2))..cap {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n             }"}]}