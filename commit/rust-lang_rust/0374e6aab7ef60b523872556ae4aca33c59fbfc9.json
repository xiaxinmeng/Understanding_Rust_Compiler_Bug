{"sha": "0374e6aab7ef60b523872556ae4aca33c59fbfc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNzRlNmFhYjdlZjYwYjUyMzg3MjU1NmFlNGFjYTMzYzU5ZmJmYzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-27T04:51:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-09T16:13:51Z"}, "message": "rustc: Rearchitect lints to be emitted more eagerly\n\nIn preparation for incremental compilation this commit refactors the lint\nhandling infrastructure in the compiler to be more \"eager\" and overall more\nincremental-friendly. Many passes of the compiler can emit lints at various\npoints but before this commit all lints were buffered in a table to be emitted\nat the very end of compilation. This commit changes these lints to be emitted\nimmediately during compilation using pre-calculated lint level-related data\nstructures.\n\nLinting today is split into two phases, one set of \"early\" lints run on the\n`syntax::ast` and a \"late\" set of lints run on the HIR. This commit moves the\n\"early\" lints to running as late as possible in compilation, just before HIR\nlowering. This notably means that we're catching resolve-related lints just\nbefore HIR lowering. The early linting remains a pass very similar to how it was\nbefore, maintaining context of the current lint level as it walks the tree.\n\nPost-HIR, however, linting is structured as a method on the `TyCtxt` which\ntransitively executes a query to calculate lint levels. Each request to lint on\na `TyCtxt` will query the entire crate's 'lint level data structure' and then go\nfrom there about whether the lint should be emitted or not.\n\nThe query depends on the entire HIR crate but should be very quick to calculate\n(just a quick walk of the HIR) and the red-green system should notice that the\nlint level data structure rarely changes, and should hopefully preserve\nincrementality.\n\nOverall this resulted in a pretty big change to the test suite now that lints\nare emitted much earlier in compilation (on-demand vs only at the end). This in\nturn necessitated the addition of many `#![allow(warnings)]` directives\nthroughout the compile-fail test suite and a number of updates to the UI test\nsuite.", "tree": {"sha": "c5180d0a44285c4809afe9c328968482a2f26482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5180d0a44285c4809afe9c328968482a2f26482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0374e6aab7ef60b523872556ae4aca33c59fbfc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0374e6aab7ef60b523872556ae4aca33c59fbfc9", "html_url": "https://github.com/rust-lang/rust/commit/0374e6aab7ef60b523872556ae4aca33c59fbfc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0374e6aab7ef60b523872556ae4aca33c59fbfc9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2de81f4c97c8d1af685162f5a6faf8c89f6cd83", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2de81f4c97c8d1af685162f5a6faf8c89f6cd83", "html_url": "https://github.com/rust-lang/rust/commit/c2de81f4c97c8d1af685162f5a6faf8c89f6cd83"}], "stats": {"total": 2406, "additions": 1342, "deletions": 1064}, "files": [{"sha": "5b609f192e1c2b11d351febd6d23b72e3e99c2d6", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -521,6 +521,7 @@ define_dep_nodes!( <'tcx>\n     [] IsAllocator(DefId),\n     [] IsPanicRuntime(DefId),\n     [] ExternCrate(DefId),\n+    [] LintLevels,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "cd64348044fcbf463055ac04dbccde4b826054a4", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -625,8 +625,6 @@ for ty::TypeckTables<'tcx> {\n \n             ref cast_kinds,\n \n-            // FIXME(#41184): This is still ignored at the moment.\n-            lints: _,\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,"}, {"sha": "6ee06dc0a8163775af63b54ef02a158aa2e4091d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 198, "deletions": 573, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -23,29 +23,25 @@\n //! previous lint state is pushed onto a stack and the ast is then recursed\n //! upon.  As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n+\n use self::TargetLint::*;\n \n+use rustc_back::slice;\n+use lint::{EarlyLintPassObject, LateLintPassObject};\n+use lint::{Level, Lint, LintId, LintPass, LintBuffer};\n+use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n+use session::{config, early_error, Session};\n use traits::Reveal;\n use ty::{self, TyCtxt};\n-use session::{config, early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n-use lint::{EarlyLintPassObject, LateLintPassObject};\n-use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n-use lint::builtin;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use util::nodemap::FxHashMap;\n \n-use std::cmp;\n use std::default::Default as StdDefault;\n-use std::mem;\n-use std::fmt;\n use std::cell::{Ref, RefCell};\n-use syntax::attr;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n-use errors::{self, Diagnostic, DiagnosticBuilder};\n+use errors::DiagnosticBuilder;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n@@ -69,9 +65,6 @@ pub struct LintStore {\n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n \n-    /// Current levels of each lint, and where they were set.\n-    levels: LintLevels,\n-\n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n     lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n@@ -81,78 +74,23 @@ pub struct LintStore {\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n-\n-#[derive(Default)]\n-struct LintLevels {\n-    /// Current levels of each lint, and where they were set.\n-    levels: FxHashMap<LintId, LevelSource>,\n-\n-    /// Maximum level a lint can be\n-    lint_cap: Option<Level>,\n-}\n-\n-\n pub struct LintSession<'a, PassObject> {\n     /// Reference to the store of registered lints.\n     lints: Ref<'a, LintStore>,\n \n-    /// The current lint levels.\n-    levels: LintLevels,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    stack: Vec<(LintId, LevelSource)>,\n-\n     /// Trait objects for each lint pass.\n     passes: Option<Vec<PassObject>>,\n }\n \n \n-/// When you call `add_lint` on the session, you wind up storing one\n-/// of these, which records a \"potential lint\" at a particular point.\n-#[derive(PartialEq, RustcEncodable, RustcDecodable)]\n-pub struct EarlyLint {\n-    /// what lint is this? (e.g., `dead_code`)\n-    pub id: LintId,\n-\n-    /// the main message\n-    pub diagnostic: Diagnostic,\n-}\n-\n-impl fmt::Debug for EarlyLint {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"EarlyLint\")\n-            .field(\"id\", &self.id)\n-            .field(\"span\", &self.diagnostic.span)\n-            .field(\"diagnostic\", &self.diagnostic)\n-            .finish()\n-    }\n-}\n-\n-pub trait IntoEarlyLint {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint;\n-}\n-\n-impl<'a, S: Into<MultiSpan>> IntoEarlyLint for (S, &'a str) {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint {\n-        let (span, msg) = self;\n-        let mut diagnostic = Diagnostic::new(errors::Level::Warning, msg);\n-        diagnostic.set_span(span);\n-        EarlyLint {\n-            id,\n-            diagnostic,\n-        }\n-    }\n-}\n-\n-impl IntoEarlyLint for Diagnostic {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint {\n-        EarlyLint {\n-            id,\n-            diagnostic: self,\n-        }\n-    }\n+/// Lints that are buffered up early on in the `Session` before the\n+/// `LintLevels` is calculated\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+pub struct BufferedEarlyLint {\n+    pub lint_id: LintId,\n+    pub ast_id: ast::NodeId,\n+    pub span: MultiSpan,\n+    pub msg: String,\n }\n \n /// Extra information for a future incompatibility lint. See the call\n@@ -176,19 +114,27 @@ enum TargetLint {\n     Removed(String),\n }\n \n-enum FindLintError {\n+pub enum FindLintError {\n     NotFound,\n     Removed,\n }\n \n+pub enum CheckLintNameResult<'a> {\n+    Ok(&'a [LintId]),\n+    // Lint doesn't exist\n+    NoLint,\n+    // The lint is either renamed or removed. This is the warning\n+    // message.\n+    Warning(String),\n+}\n+\n impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n             by_name: FxHashMap(),\n-            levels: LintLevels::default(),\n             future_incompatible: FxHashMap(),\n             lint_groups: FxHashMap(),\n         }\n@@ -241,8 +187,6 @@ impl LintStore {\n                     (Some(sess), true)  => sess.err(&msg[..]),\n                 }\n             }\n-\n-            self.levels.set(id, (lint.default_level, Default));\n         }\n     }\n \n@@ -291,96 +235,93 @@ impl LintStore {\n         self.by_name.insert(name.into(), Removed(reason.into()));\n     }\n \n-    fn find_lint(&self, lint_name: &str) -> Result<LintId, FindLintError> {\n+    pub fn find_lints(&self, lint_name: &str) -> Result<Vec<LintId>, FindLintError> {\n         match self.by_name.get(lint_name) {\n-            Some(&Id(lint_id)) => Ok(lint_id),\n+            Some(&Id(lint_id)) => Ok(vec![lint_id]),\n             Some(&Renamed(_, lint_id)) => {\n-                Ok(lint_id)\n+                Ok(vec![lint_id])\n             },\n             Some(&Removed(_)) => {\n                 Err(FindLintError::Removed)\n             },\n-            None => Err(FindLintError::NotFound)\n-        }\n-    }\n-\n-    pub fn process_command_line(&mut self, sess: &Session) {\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            check_lint_name_cmdline(sess, self,\n-                                    &lint_name[..], level);\n-\n-            let lint_flag_val = Symbol::intern(&lint_name);\n-            match self.find_lint(&lint_name[..]) {\n-                Ok(lint_id) => self.levels.set(lint_id, (level, CommandLine(lint_flag_val))),\n-                Err(FindLintError::Removed) => { }\n-                Err(_) => {\n-                    match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n-                                                 .collect::<FxHashMap<&'static str,\n-                                                                      Vec<LintId>>>()\n-                                                 .get(&lint_name[..]) {\n-                        Some(v) => {\n-                            for lint_id in v {\n-                                self.levels.set(*lint_id, (level, CommandLine(lint_flag_val)));\n-                            }\n-                        }\n-                        None => {\n-                            // The lint or lint group doesn't exist.\n-                            // This is an error, but it was handled\n-                            // by check_lint_name_cmdline.\n-                        }\n-                    }\n+            None => {\n+                match self.lint_groups.get(lint_name) {\n+                    Some(v) => Ok(v.0.clone()),\n+                    None => Err(FindLintError::Removed)\n                 }\n             }\n         }\n-\n-        self.levels.set_lint_cap(sess.opts.lint_cap);\n     }\n-}\n-\n \n-impl LintLevels {\n-    fn get_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.get(&lint) {\n-            Some(&s) => s,\n-            None => (Allow, Default),\n-        }\n-    }\n+    // Checks the validity of lint names derived from the command line\n+    pub fn check_lint_name_cmdline(&self,\n+                                   sess: &Session,\n+                                   lint_name: &str,\n+                                   level: Level) {\n+        let db = match self.check_lint_name(lint_name) {\n+            CheckLintNameResult::Ok(_) => None,\n+            CheckLintNameResult::Warning(ref msg) => {\n+                Some(sess.struct_warn(msg))\n+            },\n+            CheckLintNameResult::NoLint => {\n+                Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n+            }\n+        };\n \n-    fn set(&mut self, lint: LintId, mut lvlsrc: LevelSource) {\n-        if let Some(cap) = self.lint_cap {\n-            lvlsrc.0 = cmp::min(lvlsrc.0, cap);\n-        }\n-        if lvlsrc.0 == Allow {\n-            self.levels.remove(&lint);\n-        } else {\n-            self.levels.insert(lint, lvlsrc);\n+        if let Some(mut db) = db {\n+            let msg = format!(\"requested on the command line with `{} {}`\",\n+                              match level {\n+                                  Level::Allow => \"-A\",\n+                                  Level::Warn => \"-W\",\n+                                  Level::Deny => \"-D\",\n+                                  Level::Forbid => \"-F\",\n+                              },\n+                              lint_name);\n+            db.note(&msg);\n+            db.emit();\n         }\n     }\n \n-    fn set_lint_cap(&mut self, lint_cap: Option<Level>) {\n-        self.lint_cap = lint_cap;\n-        if let Some(cap) = lint_cap {\n-            for (_, level) in &mut self.levels {\n-                level.0 = cmp::min(level.0, cap);\n+    /// Checks the name of a lint for its existence, and whether it was\n+    /// renamed or removed. Generates a DiagnosticBuilder containing a\n+    /// warning for renamed and removed lints. This is over both lint\n+    /// names from attributes and those passed on the command line. Since\n+    /// it emits non-fatal warnings and there are *two* lint passes that\n+    /// inspect attributes, this is only run from the late pass to avoid\n+    /// printing duplicate warnings.\n+    pub fn check_lint_name(&self, lint_name: &str) -> CheckLintNameResult {\n+        match self.by_name.get(lint_name) {\n+            Some(&Renamed(ref new_name, _)) => {\n+                CheckLintNameResult::Warning(\n+                    format!(\"lint {} has been renamed to {}\", lint_name, new_name)\n+                )\n+            },\n+            Some(&Removed(ref reason)) => {\n+                CheckLintNameResult::Warning(\n+                    format!(\"lint {} has been removed: {}\", lint_name, reason)\n+                )\n+            },\n+            None => {\n+                match self.lint_groups.get(lint_name) {\n+                    None => CheckLintNameResult::NoLint,\n+                    Some(ids) => CheckLintNameResult::Ok(&ids.0),\n+                }\n             }\n+            Some(&Id(ref id)) => CheckLintNameResult::Ok(slice::ref_slice(id)),\n         }\n     }\n }\n \n-\n impl<'a, PassObject: LintPassObject> LintSession<'a, PassObject> {\n     /// Creates a new `LintSession`, by moving out the `LintStore`'s initial\n     /// lint levels and pass objects. These can be restored using the `restore`\n     /// method.\n     fn new(store: &'a RefCell<LintStore>) -> LintSession<'a, PassObject> {\n         let mut s = store.borrow_mut();\n-        let levels = mem::replace(&mut s.levels, LintLevels::default());\n         let passes = PassObject::take_passes(&mut *s);\n         drop(s);\n         LintSession {\n             lints: store.borrow(),\n-            stack: Vec::new(),\n-            levels,\n             passes,\n         }\n     }\n@@ -389,17 +330,10 @@ impl<'a, PassObject: LintPassObject> LintSession<'a, PassObject> {\n     fn restore(self, store: &RefCell<LintStore>) {\n         drop(self.lints);\n         let mut s = store.borrow_mut();\n-        s.levels = self.levels;\n         PassObject::restore_passes(&mut *s, self.passes);\n     }\n-\n-    fn get_source(&self, lint_id: LintId) -> LevelSource {\n-        self.levels.get_source(lint_id)\n-    }\n }\n \n-\n-\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n@@ -416,6 +350,8 @@ pub struct LateContext<'a, 'tcx: 'a> {\n \n     /// The store of registered lints and the lint levels.\n     lint_sess: LintSession<'tcx, LateLintPassObject>,\n+\n+    last_ast_node_with_lint_attrs: ast::NodeId,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -427,8 +363,12 @@ pub struct EarlyContext<'a> {\n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n \n+    builder: LintLevelsBuilder<'a>,\n+\n     /// The store of registered lints and the lint levels.\n     lint_sess: LintSession<'a, EarlyLintPassObject>,\n+\n+    buffered: LintBuffer,\n }\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n@@ -442,135 +382,6 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n     $cx.lint_sess_mut().passes = Some(passes);\n }) }\n \n-/// Parse the lint attributes into a vector, with `Err`s for malformed lint\n-/// attributes. Writing this as an iterator is an enormous mess.\n-// See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n-    let mut out = vec![];\n-    for attr in attrs {\n-        let r = gather_attr(attr);\n-        out.extend(r.into_iter());\n-    }\n-    out\n-}\n-\n-pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n-    let mut out = vec![];\n-\n-    let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n-        None => return out,\n-        Some(lvl) => lvl,\n-    };\n-\n-    let meta = unwrap_or!(attr.meta(), return out);\n-    attr::mark_used(attr);\n-\n-    let metas = if let Some(metas) = meta.meta_item_list() {\n-        metas\n-    } else {\n-        out.push(Err(meta.span));\n-        return out;\n-    };\n-\n-    for li in metas {\n-        out.push(li.word().map_or(Err(li.span), |word| Ok((word.name(), level, word.span))));\n-    }\n-\n-    out\n-}\n-\n-/// Emit a lint as a warning or an error (or not at all)\n-/// according to `level`.\n-///\n-/// This lives outside of `Context` so it can be used by checks\n-/// in trans that run after the main lint pass is finished. Most\n-/// lints elsewhere in the compiler should call\n-/// `Session::add_lint()` instead.\n-pub fn raw_emit_lint<S: Into<MultiSpan>>(sess: &Session,\n-                                         lints: &LintStore,\n-                                         lint: &'static Lint,\n-                                         lvlsrc: LevelSource,\n-                                         span: Option<S>,\n-                                         msg: &str) {\n-    raw_struct_lint(sess, lints, lint, lvlsrc, span, msg).emit();\n-}\n-\n-pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n-                              lints: &LintStore,\n-                              lint: &'static Lint,\n-                              lvlsrc: LevelSource,\n-                              span: Option<S>,\n-                              msg: &str)\n-                              -> DiagnosticBuilder<'a>\n-    where S: Into<MultiSpan>\n-{\n-    let (level, source) = lvlsrc;\n-    if level == Allow {\n-        return sess.diagnostic().struct_dummy();\n-    }\n-\n-    let name = lint.name_lower();\n-\n-    // Except for possible note details, forbid behaves like deny.\n-    let effective_level = if level == Forbid { Deny } else { level };\n-\n-    let mut err = match (effective_level, span) {\n-        (Warn, Some(sp)) => sess.struct_span_warn(sp, &msg[..]),\n-        (Warn, None)     => sess.struct_warn(&msg[..]),\n-        (Deny, Some(sp)) => sess.struct_span_err(sp, &msg[..]),\n-        (Deny, None)     => sess.struct_err(&msg[..]),\n-        _ => bug!(\"impossible level in raw_emit_lint\"),\n-    };\n-\n-    match source {\n-        Default => {\n-            sess.diag_note_once(&mut err, lint,\n-                                &format!(\"#[{}({})] on by default\", level.as_str(), name));\n-        },\n-        CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Warn => \"-W\", Deny => \"-D\", Forbid => \"-F\",\n-                Allow => bug!(\"earlier conditional return should handle Allow case\")\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"requested on the command line with `{} {}`\",\n-                                             flag, hyphen_case_lint_name));\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"`{} {}` implied by `{} {}`\",\n-                                             flag, hyphen_case_lint_name, flag,\n-                                             hyphen_case_flag_val));\n-            }\n-        },\n-        Node(lint_attr_name, src) => {\n-            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"#[{}({})] implied by #[{}({})]\",\n-                                             level_str, name, level_str, lint_attr_name));\n-            }\n-        }\n-    }\n-\n-    // Check for future incompatibility lints and issue a stronger warning.\n-    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n-        let explanation = format!(\"this was previously accepted by the compiler \\\n-                                   but is being phased out; \\\n-                                   it will become a hard error in a future release!\");\n-        let citation = format!(\"for more information, see {}\",\n-                               future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n-\n-    err\n-}\n-\n-\n pub trait LintPassObject: Sized {\n     fn take_passes(store: &mut LintStore) -> Option<Vec<Self>>;\n     fn restore_passes(store: &mut LintStore, passes: Option<Vec<Self>>);\n@@ -607,67 +418,24 @@ pub trait LintContext<'tcx>: Sized {\n     fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n     fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n-    /// Get the level of `lint` at the current position of the lint\n-    /// traversal.\n-    fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lint_sess().get_source(LintId::of(lint)).0\n-    }\n-\n-    fn level_src(&self, lint: &'static Lint) -> Option<LevelSource> {\n-        let ref levels = self.lint_sess().levels;\n-        levels.levels.get(&LintId::of(lint)).map(|ls| match ls {\n-            &(Warn, _) => {\n-                let lint_id = LintId::of(builtin::WARNINGS);\n-                let warn_src = levels.get_source(lint_id);\n-                if warn_src.0 != Warn {\n-                    warn_src\n-                } else {\n-                    *ls\n-                }\n-            }\n-            _ => *ls\n-        })\n-    }\n-\n     fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n                                            lint: &'static Lint,\n                                            span: Option<S>,\n                                            msg: &str) {\n-        let (level, src) = match self.level_src(lint) {\n-            None => return,\n-            Some(pair) => pair,\n-        };\n-\n-        raw_emit_lint(&self.sess(), self.lints(), lint, (level, src), span, msg);\n+        self.lookup(lint, span, msg).emit();\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n                                   msg: &str)\n-                                  -> DiagnosticBuilder {\n-        let (level, src) = match self.level_src(lint) {\n-            None => return self.sess().diagnostic().struct_dummy(),\n-            Some(pair) => pair,\n-        };\n-\n-        raw_struct_lint(&self.sess(), self.lints(), lint, (level, src), span, msg)\n-    }\n+                                  -> DiagnosticBuilder;\n \n     /// Emit a lint at the appropriate level, for a particular span.\n     fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    fn early_lint(&self, early_lint: &EarlyLint) {\n-        let span = early_lint.diagnostic.span.primary_span().expect(\"early lint w/o primary span\");\n-        let mut err = self.struct_span_lint(early_lint.id.lint,\n-                                            span,\n-                                            &early_lint.diagnostic.message());\n-        err.copy_details_not_message(&early_lint.diagnostic);\n-        err.emit();\n-    }\n-\n     fn struct_span_lint<S: Into<MultiSpan>>(&self,\n                                             lint: &'static Lint,\n                                             span: S,\n@@ -680,12 +448,10 @@ pub trait LintContext<'tcx>: Sized {\n     fn span_lint_note(&self, lint: &'static Lint, span: Span, msg: &str,\n                       note_span: Span, note: &str) {\n         let mut err = self.lookup(lint, Some(span), msg);\n-        if self.current_level(lint) != Level::Allow {\n-            if note_span == span {\n-                err.note(note);\n-            } else {\n-                err.span_note(note_span, note);\n-            }\n+        if note_span == span {\n+            err.note(note);\n+        } else {\n+            err.span_note(note_span, note);\n         }\n         err.emit();\n     }\n@@ -695,9 +461,7 @@ pub trait LintContext<'tcx>: Sized {\n                       msg: &str, help: &str) {\n         let mut err = self.lookup(lint, Some(span), msg);\n         self.span_lint(lint, span, msg);\n-        if self.current_level(lint) != Level::Allow {\n-            err.span_help(span, help);\n-        }\n+        err.span_help(span, help);\n         err.emit();\n     }\n \n@@ -710,94 +474,10 @@ pub trait LintContext<'tcx>: Sized {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n                           attrs: &'tcx [ast::Attribute],\n                           f: F)\n-        where F: FnOnce(&mut Self),\n-    {\n-        // Parse all of the lint attributes, and then add them all to the\n-        // current dictionary of lint information. Along the way, keep a history\n-        // of what we changed so we can roll everything back after invoking the\n-        // specified closure\n-        let mut pushed = 0;\n-\n-        for result in gather_attrs(attrs) {\n-            let (is_group, lint_level_spans) = match result {\n-                Err(span) => {\n-                    span_err!(self.sess(), span, E0452,\n-                              \"malformed lint attribute\");\n-                    continue;\n-                }\n-                Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name.as_str()) {\n-                        Ok(lint_id) => (false, vec![(lint_id, level, span)]),\n-                        Err(FindLintError::NotFound) => {\n-                            match self.lints().lint_groups.get(&*lint_name.as_str()) {\n-                                Some(&(ref v, _)) => (true,\n-                                                      v.iter()\n-                                                      .map(|lint_id: &LintId|\n-                                                           (*lint_id, level, span))\n-                                                      .collect()),\n-                                None => {\n-                                    // The lint or lint group doesn't exist.\n-                                    // This is an error, but it was handled\n-                                    // by check_lint_name_attribute.\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                        Err(FindLintError::Removed) => continue,\n-                    }\n-                }\n-            };\n-\n-            let lint_attr_name = result.expect(\"lint attribute should be well-formed\").0;\n-\n-            for (lint_id, level, span) in lint_level_spans {\n-                let (now, now_source) = self.lint_sess().get_source(lint_id);\n-                if now == Forbid && level != Forbid {\n-                    let forbidden_lint_name = match now_source {\n-                        LintSource::Default => lint_id.to_string(),\n-                        LintSource::Node(name, _) => name.to_string(),\n-                        LintSource::CommandLine(name) => name.to_string(),\n-                    };\n-                    let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n-                                                            \"{}({}) overruled by outer forbid({})\",\n-                                                            level.as_str(), lint_attr_name,\n-                                                            forbidden_lint_name);\n-                    diag_builder.span_label(span, \"overruled by previous forbid\");\n-                    match now_source {\n-                        LintSource::Default => &mut diag_builder,\n-                        LintSource::Node(_, forbid_source_span) => {\n-                            diag_builder.span_label(forbid_source_span,\n-                                                    \"`forbid` level set here\")\n-                        },\n-                        LintSource::CommandLine(_) => {\n-                            diag_builder.note(\"`forbid` lint level was set on command line\")\n-                        }\n-                    }.emit();\n-                    if is_group { // don't set a separate error for every lint in the group\n-                        break;\n-                    }\n-                } else if now != level {\n-                    let cx = self.lint_sess_mut();\n-                    cx.stack.push((lint_id, (now, now_source)));\n-                    pushed += 1;\n-                    cx.levels.set(lint_id, (level, Node(lint_attr_name, span)));\n-                }\n-            }\n-        }\n-\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-\n-        // rollback\n-        let cx = self.lint_sess_mut();\n-        for _ in 0..pushed {\n-            let (lint, lvlsrc) = cx.stack.pop().unwrap();\n-            cx.levels.set(lint, lvlsrc);\n-        }\n-    }\n+        where F: FnOnce(&mut Self);\n }\n \n \n@@ -808,6 +488,16 @@ impl<'a> EarlyContext<'a> {\n             sess,\n             krate,\n             lint_sess: LintSession::new(&sess.lint_store),\n+            builder: LintLevelSets::builder(sess),\n+            buffered: sess.buffered_lints.borrow_mut().take().unwrap(),\n+        }\n+    }\n+\n+    fn check_id(&mut self, id: ast::NodeId) {\n+        for early_lint in self.buffered.take(id) {\n+            self.lookup_and_emit(early_lint.lint_id.lint,\n+                                 Some(early_lint.span.clone()),\n+                                 &early_lint.msg);\n         }\n     }\n }\n@@ -841,6 +531,32 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n         debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n+\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n+        let id = self.last_ast_node_with_lint_attrs;\n+        match span {\n+            Some(s) => self.tcx.struct_span_lint_node(lint, id, s, msg),\n+            None => self.tcx.struct_lint_node(lint, id, msg),\n+        }\n+    }\n+\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &'tcx [ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let prev = self.last_ast_node_with_lint_attrs;\n+        self.last_ast_node_with_lint_attrs = id;\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.last_ast_node_with_lint_attrs = prev;\n+    }\n }\n \n impl<'a> LintContext<'a> for EarlyContext<'a> {\n@@ -872,6 +588,28 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n+\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n+        self.builder.struct_lint(lint, span.map(|s| s.into()), msg)\n+    }\n+\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &'a [ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let push = self.builder.push(attrs);\n+        self.check_id(id);\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.builder.pop(push);\n+    }\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n@@ -893,15 +631,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n-    // Output any lints that were previously added to the session.\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        let lints = self.sess().lints.borrow_mut().take(id);\n-        for early_lint in lints.iter().chain(self.tables.lints.get(id)) {\n-            debug!(\"LateContext::visit_id: id={:?} early_lint={:?}\", id, early_lint);\n-            self.early_lint(early_lint);\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n@@ -917,7 +646,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_item, late_passes, it);\n                 hir_visit::walk_item(cx, it);\n@@ -927,7 +656,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_foreign_item, late_passes, it);\n                 hir_visit::walk_foreign_item(cx, it);\n@@ -942,7 +671,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(&e.attrs, |cx| {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n             run_lints!(cx, check_expr_post, late_passes, e);\n@@ -984,7 +713,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(&s.attrs, |cx| {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, late_passes, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n@@ -994,7 +723,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: ast::NodeId) {\n-        self.with_lint_attrs(&v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n@@ -1017,7 +746,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(&l.attrs, |cx| {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -1045,7 +774,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.id, |cx| {\n                 run_lints!(cx, check_trait_item, late_passes, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n@@ -1055,7 +784,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.id, |cx| {\n                 run_lints!(cx, check_impl_item, late_passes, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n@@ -1080,22 +809,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        check_lint_name_attribute(self, attr);\n         run_lints!(self, check_attribute, late_passes, attr);\n     }\n }\n \n impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     fn visit_item(&mut self, it: &'a ast::Item) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n             ast_visit::walk_item(cx, it);\n             run_lints!(cx, check_item_post, early_passes, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, early_passes, it);\n             ast_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, early_passes, it);\n@@ -1104,24 +832,27 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         run_lints!(self, check_pat, early_passes, p);\n+        self.check_id(p.id);\n         ast_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        self.with_lint_attrs(&e.attrs, |cx| {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n \n     fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n         run_lints!(self, check_stmt, early_passes, s);\n+        self.check_id(s.id);\n         ast_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, decl: &'a ast::FnDecl,\n                 span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n+        self.check_id(id);\n         ast_visit::walk_fn(self, fk, decl, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n@@ -1133,19 +864,20 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, early_passes, s, ident, g, item_id);\n+        self.check_id(s.id());\n         ast_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, early_passes, s, ident, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n-        self.with_lint_attrs(&s.attrs, |cx| {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, early_passes, s);\n             ast_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(&v.node.attrs, |cx| {\n+        self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, early_passes, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, early_passes, v, g);\n@@ -1154,6 +886,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         run_lints!(self, check_ty, early_passes, t);\n+        self.check_id(t.id);\n         ast_visit::walk_ty(self, t);\n     }\n \n@@ -1163,19 +896,21 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n         run_lints!(self, check_mod, early_passes, m, s, n);\n+        self.check_id(n);\n         ast_visit::walk_mod(self, m);\n         run_lints!(self, check_mod_post, early_passes, m, s, n);\n     }\n \n     fn visit_local(&mut self, l: &'a ast::Local) {\n-        self.with_lint_attrs(&l.attrs, |cx| {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'a ast::Block) {\n         run_lints!(self, check_block, early_passes, b);\n+        self.check_id(b.id);\n         ast_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, early_passes, b);\n     }\n@@ -1195,15 +930,15 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n-        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, early_passes, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n-        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, early_passes, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, early_passes, impl_item);\n@@ -1212,6 +947,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n         run_lints!(self, check_lifetime, early_passes, lt);\n+        self.check_id(lt.id);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &'a ast::LifetimeDef) {\n@@ -1220,11 +956,13 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n+        self.check_id(id);\n         ast_visit::walk_path(self, p);\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &'a ast::Path, item: &'a ast::PathListItem) {\n         run_lints!(self, check_path_list_item, early_passes, item);\n+        self.check_id(item.node.id);\n         ast_visit::walk_path_list_item(self, prefix, item);\n     }\n \n@@ -1233,110 +971,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_mac_def(&mut self, _mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        let lints = self.sess.lints.borrow_mut().take(id);\n-        for early_lint in lints {\n-            self.early_lint(&early_lint);\n-        }\n-    }\n-}\n-\n-enum CheckLintNameResult {\n-    Ok,\n-    // Lint doesn't exist\n-    NoLint,\n-    // The lint is either renamed or removed. This is the warning\n-    // message.\n-    Warning(String),\n-}\n-\n-/// Checks the name of a lint for its existence, and whether it was\n-/// renamed or removed. Generates a DiagnosticBuilder containing a\n-/// warning for renamed and removed lints. This is over both lint\n-/// names from attributes and those passed on the command line. Since\n-/// it emits non-fatal warnings and there are *two* lint passes that\n-/// inspect attributes, this is only run from the late pass to avoid\n-/// printing duplicate warnings.\n-fn check_lint_name(lint_cx: &LintStore,\n-                   lint_name: &str) -> CheckLintNameResult {\n-    match lint_cx.by_name.get(lint_name) {\n-        Some(&Renamed(ref new_name, _)) => {\n-            CheckLintNameResult::Warning(\n-                format!(\"lint {} has been renamed to {}\", lint_name, new_name)\n-            )\n-        },\n-        Some(&Removed(ref reason)) => {\n-            CheckLintNameResult::Warning(\n-                format!(\"lint {} has been removed: {}\", lint_name, reason)\n-            )\n-        },\n-        None => {\n-            match lint_cx.lint_groups.get(lint_name) {\n-                None => {\n-                    CheckLintNameResult::NoLint\n-                }\n-                Some(_) => {\n-                    /* lint group exists */\n-                    CheckLintNameResult::Ok\n-                }\n-            }\n-        }\n-        Some(_) => {\n-            /* lint exists */\n-            CheckLintNameResult::Ok\n-        }\n-    }\n-}\n-\n-// Checks the validity of lint names derived from attributes\n-fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n-    for result in gather_attr(attr) {\n-        match result {\n-            Err(_) => {\n-                // Malformed lint attr. Reported by with_lint_attrs\n-                continue;\n-            }\n-            Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lint_sess.lints, &lint_name.as_str()) {\n-                    CheckLintNameResult::Ok => (),\n-                    CheckLintNameResult::Warning(ref msg) => {\n-                        cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n-                                     span, msg);\n-                    }\n-                    CheckLintNameResult::NoLint => {\n-                        cx.span_lint(builtin::UNKNOWN_LINTS, span,\n-                                     &format!(\"unknown lint: `{}`\",\n-                                              lint_name));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Checks the validity of lint names derived from the command line\n-fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n-                           lint_name: &str, level: Level) {\n-    let db = match check_lint_name(lint_cx, lint_name) {\n-        CheckLintNameResult::Ok => None,\n-        CheckLintNameResult::Warning(ref msg) => {\n-            Some(sess.struct_warn(msg))\n-        },\n-        CheckLintNameResult::NoLint => {\n-            Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n-        }\n-    };\n-\n-    if let Some(mut db) = db {\n-        let msg = format!(\"requested on the command line with `{} {}`\",\n-                          match level {\n-                              Level::Allow => \"-A\",\n-                              Level::Warn => \"-W\",\n-                              Level::Deny => \"-D\",\n-                              Level::Forbid => \"-F\",\n-                          },\n-                          lint_name);\n-        db.note(&msg);\n-        db.emit();\n+        self.check_id(id);\n     }\n }\n \n@@ -1355,10 +990,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),\n+        last_ast_node_with_lint_attrs: ast::CRATE_NODE_ID,\n     };\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs, |cx| {\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, late_passes, krate);\n@@ -1368,16 +1004,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         run_lints!(cx, check_crate_post, late_passes, krate);\n     });\n \n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    if let Some((id, v)) = tcx.sess.lints.borrow().get_any() {\n-        for early_lint in v {\n-            span_bug!(early_lint.diagnostic.span.clone(),\n-                      \"unprocessed lint {:?} at {}\",\n-                      early_lint, tcx.hir.node_to_string(*id));\n-        }\n-    }\n-\n     // Put the lint store levels and passes back in the session.\n     cx.lint_sess.restore(&tcx.sess.lint_store);\n }\n@@ -1386,13 +1012,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     let mut cx = EarlyContext::new(sess, krate);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs, |cx| {\n-        // Lints may be assigned to the whole crate.\n-        let lints = cx.sess.lints.borrow_mut().take(ast::CRATE_NODE_ID);\n-        for early_lint in lints {\n-            cx.early_lint(&early_lint);\n-        }\n-\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, early_passes, krate);\n@@ -1405,11 +1025,11 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // Put the lint store levels and passes back in the session.\n     cx.lint_sess.restore(&sess.lint_store);\n \n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    for (_, v) in sess.lints.borrow().get_any() {\n-        for early_lint in v {\n-            span_bug!(early_lint.diagnostic.span.clone(), \"unprocessed lint {:?}\", early_lint);\n+    // Emit all buffered lints from early on in the session now that we've\n+    // calculated the lint levels for all AST nodes.\n+    for (_id, lints) in cx.buffered.map {\n+        for early_lint in lints {\n+            span_bug!(early_lint.span, \"failed to process bufferd lint here\");\n         }\n     }\n }\n@@ -1425,8 +1045,13 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lint(&s) {\n-                Ok(id) => Ok(id),\n+            match tcx.sess.lint_store.borrow().find_lints(&s) {\n+                Ok(ids) => {\n+                    if ids.len() != 0 {\n+                        panic!(\"invalid lint-id `{}`\", s);\n+                    }\n+                    Ok(ids[0])\n+                }\n                 Err(_) => panic!(\"invalid lint-id `{}`\", s),\n             }\n         })"}, {"sha": "ab9d4f75597b995897c05e588a501497e80181c4", "filename": "src/librustc/lint/levels.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -0,0 +1,343 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+\n+use errors::DiagnosticBuilder;\n+use hir::HirId;\n+use lint::builtin;\n+use lint::context::CheckLintNameResult;\n+use lint::{self, Lint, LintId, Level, LintSource};\n+use session::Session;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::MultiSpan;\n+use syntax::symbol::Symbol;\n+use util::nodemap::FxHashMap;\n+\n+pub struct LintLevelSets {\n+    list: Vec<LintSet>,\n+    lint_cap: Level,\n+}\n+\n+enum LintSet {\n+    CommandLine {\n+        // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+        // flag.\n+        specs: FxHashMap<LintId, (Level, LintSource)>,\n+    },\n+\n+    Node {\n+        specs: FxHashMap<LintId, (Level, LintSource)>,\n+        parent: u32,\n+    },\n+}\n+\n+impl LintLevelSets {\n+    pub fn new(sess: &Session) -> LintLevelSets {\n+        let mut me = LintLevelSets {\n+            list: Vec::new(),\n+            lint_cap: Level::Forbid,\n+        };\n+        me.process_command_line(sess);\n+        return me\n+    }\n+\n+    pub fn builder(sess: &Session) -> LintLevelsBuilder {\n+        LintLevelsBuilder::new(sess, LintLevelSets::new(sess))\n+    }\n+\n+    fn process_command_line(&mut self, sess: &Session) {\n+        let store = sess.lint_store.borrow();\n+        let mut specs = FxHashMap();\n+        self.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n+\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n+            store.check_lint_name_cmdline(sess, &lint_name, level);\n+\n+            // If the cap is less than this specified level, e.g. if we've got\n+            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n+            // this specification as the lint cap will set it to allow anyway.\n+            let level = cmp::min(level, self.lint_cap);\n+\n+            let lint_flag_val = Symbol::intern(lint_name);\n+            let ids = match store.find_lints(&lint_name) {\n+                Ok(ids) => ids,\n+                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n+            };\n+            for id in ids {\n+                let src = LintSource::CommandLine(lint_flag_val);\n+                specs.insert(id, (level, src));\n+            }\n+        }\n+\n+        self.list.push(LintSet::CommandLine {\n+            specs: specs,\n+        });\n+    }\n+\n+    fn get_lint_level(&self, lint: &'static Lint, idx: u32)\n+        -> (Level, LintSource)\n+    {\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx);\n+\n+        // If `level` is none then we actually assume the default level for this\n+        // lint.\n+        let mut level = level.unwrap_or(lint.default_level);\n+\n+        // If we're about to issue a warning, check at the last minute for any\n+        // directives against the warnings \"lint\". If, for example, there's an\n+        // `allow(warnings)` in scope then we want to respect that instead.\n+        if level == Level::Warn {\n+            let (warnings_level, warnings_src) =\n+                self.get_lint_id_level(LintId::of(lint::builtin::WARNINGS), idx);\n+            if let Some(configured_warning_level) = warnings_level {\n+                if configured_warning_level != Level::Warn {\n+                    level = configured_warning_level;\n+                    src = warnings_src;\n+                }\n+            }\n+        }\n+\n+        // Ensure that we never exceed the `--cap-lints` argument.\n+        level = cmp::min(level, self.lint_cap);\n+\n+        return (level, src)\n+    }\n+\n+    fn get_lint_id_level(&self, id: LintId, mut idx: u32)\n+        -> (Option<Level>, LintSource)\n+    {\n+        loop {\n+            match self.list[idx as usize] {\n+                LintSet::CommandLine { ref specs } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src)\n+                    }\n+                    return (None, LintSource::Default)\n+                }\n+                LintSet::Node { ref specs, parent } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src)\n+                    }\n+                    idx = parent;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct LintLevelsBuilder<'a> {\n+    sess: &'a Session,\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+    cur: u32,\n+    warn_about_weird_lints: bool,\n+}\n+\n+pub struct BuilderPush {\n+    prev: u32,\n+}\n+\n+impl<'a> LintLevelsBuilder<'a> {\n+    pub fn new(sess: &'a Session, sets: LintLevelSets) -> LintLevelsBuilder<'a> {\n+        assert_eq!(sets.list.len(), 1);\n+        LintLevelsBuilder {\n+            sess,\n+            sets,\n+            cur: 0,\n+            id_to_set: FxHashMap(),\n+            warn_about_weird_lints: sess.buffered_lints.borrow().is_some(),\n+        }\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be be\n+    /// passed to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attriutes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g. a #[forbid] can't be switched to\n+    ///   #[allow]\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub fn push(&mut self, attrs: &[ast::Attribute]) -> BuilderPush {\n+        let mut specs = FxHashMap();\n+        let store = self.sess.lint_store.borrow();\n+        let sess = self.sess;\n+        let bad_attr = |span| {\n+            span_err!(sess, span, E0452,\n+                      \"malformed lint attribute\");\n+        };\n+        for attr in attrs {\n+            let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            let meta = unwrap_or!(attr.meta(), continue);\n+            attr::mark_used(attr);\n+\n+            let metas = if let Some(metas) = meta.meta_item_list() {\n+                metas\n+            } else {\n+                bad_attr(meta.span);\n+                continue\n+            };\n+\n+            for li in metas {\n+                let word = match li.word() {\n+                    Some(word) => word,\n+                    None => {\n+                        bad_attr(li.span);\n+                        continue\n+                    }\n+                };\n+                let name = word.name();\n+                match store.check_lint_name(&name.as_str()) {\n+                    CheckLintNameResult::Ok(ids) => {\n+                        let src = LintSource::Node(name, li.span);\n+                        for id in ids {\n+                            specs.insert(*id, (level, src));\n+                        }\n+                    }\n+                    CheckLintNameResult::Warning(ref msg) => {\n+                        if self.warn_about_weird_lints {\n+                            self.struct_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n+                                             Some(li.span.into()),\n+                                             msg)\n+                                .emit();\n+                        }\n+                    }\n+                    CheckLintNameResult::NoLint => {\n+                        if self.warn_about_weird_lints {\n+                            self.struct_lint(builtin::UNKNOWN_LINTS,\n+                                             Some(li.span.into()),\n+                                             &format!(\"unknown lint: `{}`\", name))\n+                                .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (id, &(level, ref src)) in specs.iter() {\n+            if level == Level::Forbid {\n+                continue\n+            }\n+            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur) {\n+                (Some(Level::Forbid), src) => src,\n+                _ => continue,\n+            };\n+            let forbidden_lint_name = match forbid_src {\n+                LintSource::Default => id.to_string(),\n+                LintSource::Node(name, _) => name.to_string(),\n+                LintSource::CommandLine(name) => name.to_string(),\n+            };\n+            let (lint_attr_name, lint_attr_span) = match *src {\n+                LintSource::Node(name, span) => (name, span),\n+                _ => continue,\n+            };\n+            let mut diag_builder = struct_span_err!(self.sess,\n+                                                    lint_attr_span,\n+                                                    E0453,\n+                                                    \"{}({}) overruled by outer forbid({})\",\n+                                                    level.as_str(),\n+                                                    lint_attr_name,\n+                                                    forbidden_lint_name);\n+            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n+            match forbid_src {\n+                LintSource::Default => &mut diag_builder,\n+                LintSource::Node(_, forbid_source_span) => {\n+                    diag_builder.span_label(forbid_source_span,\n+                                            \"`forbid` level set here\")\n+                },\n+                LintSource::CommandLine(_) => {\n+                    diag_builder.note(\"`forbid` lint level was set on command line\")\n+                }\n+            }.emit();\n+            // don't set a separate error for every lint in the group\n+            break\n+        }\n+\n+        let prev = self.cur;\n+        if specs.len() > 0 {\n+            self.cur = self.sets.list.len() as u32;\n+            self.sets.list.push(LintSet::Node {\n+                specs: specs,\n+                parent: prev,\n+            });\n+        }\n+\n+        BuilderPush {\n+            prev: prev,\n+        }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.cur = push.prev;\n+    }\n+\n+    /// Used to emit a lint-related diagnostic based on the current state of\n+    /// this lint context.\n+    pub fn struct_lint(&self,\n+                       lint: &'static Lint,\n+                       span: Option<MultiSpan>,\n+                       msg: &str)\n+        -> DiagnosticBuilder<'a>\n+    {\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur);\n+        lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n+    }\n+\n+    /// Registers the ID provided with the current set of lints stored in\n+    /// this context.\n+    pub fn register_id(&mut self, id: HirId) {\n+        self.id_to_set.insert(id, self.cur);\n+    }\n+\n+    pub fn build(self) -> LintLevelSets {\n+        self.sets\n+    }\n+\n+    pub fn build_map(self) -> LintLevelMap {\n+        LintLevelMap {\n+            sets: self.sets,\n+            id_to_set: self.id_to_set,\n+        }\n+    }\n+}\n+\n+pub struct LintLevelMap {\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+}\n+\n+impl LintLevelMap {\n+    /// If the `id` was previously registered with `register_id` when building\n+    /// this `LintLevelMap` this returns the corresponding lint level and source\n+    /// of the lint level for the lint provided.\n+    ///\n+    /// If the `id` was not previously registered, returns `None`. If `None` is\n+    /// returned then the parent of `id` should be acquired and this function\n+    /// should be called again.\n+    pub fn level_and_source(&self, lint: &'static Lint, id: HirId)\n+        -> Option<(Level, LintSource)>\n+    {\n+        self.id_to_set.get(&id).map(|idx| {\n+            self.sets.get_lint_level(lint, *idx)\n+        })\n+    }\n+}"}, {"sha": "c64e1c08082a5637fcfbecf68eba67ebafac13e5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 227, "deletions": 9, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -31,20 +31,27 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n+use std::rc::Rc;\n+\n+use errors::DiagnosticBuilder;\n+use hir::def_id::{CrateNum, LOCAL_CRATE};\n+use hir::intravisit::{self, FnKind};\n use hir;\n-use hir::intravisit::FnKind;\n-use std::hash;\n+use session::Session;\n use std::ascii::AsciiExt;\n-use syntax_pos::Span;\n-use syntax::visit as ast_visit;\n+use std::hash;\n use syntax::ast;\n+use syntax::codemap::MultiSpan;\n use syntax::symbol::Symbol;\n+use syntax::visit as ast_visit;\n+use syntax_pos::Span;\n+use ty::TyCtxt;\n+use ty::maps::Providers;\n+use util::nodemap::NodeMap;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, FutureIncompatibleInfo, EarlyLint, IntoEarlyLint};\n-\n-pub use lint::table::LintTable;\n+                        check_crate, check_ast_crate,\n+                        FutureIncompatibleInfo, BufferedEarlyLint};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -351,4 +358,215 @@ pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n mod context;\n-mod table;\n+mod levels;\n+\n+pub use self::levels::{LintLevelSets, LintLevelMap};\n+\n+pub struct LintBuffer {\n+    map: NodeMap<Vec<BufferedEarlyLint>>,\n+}\n+\n+impl LintBuffer {\n+    pub fn new() -> LintBuffer {\n+        LintBuffer { map: NodeMap() }\n+    }\n+\n+    pub fn add_lint(&mut self,\n+                    lint: &'static Lint,\n+                    id: ast::NodeId,\n+                    sp: MultiSpan,\n+                    msg: &str) {\n+        let early_lint = BufferedEarlyLint {\n+            lint_id: LintId::of(lint),\n+            ast_id: id,\n+            span: sp,\n+            msg: msg.to_string(),\n+        };\n+        let arr = self.map.entry(id).or_insert(Vec::new());\n+        if !arr.contains(&early_lint) {\n+            arr.push(early_lint);\n+        }\n+    }\n+\n+    pub fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n+        self.map.remove(&id).unwrap_or(Vec::new())\n+    }\n+\n+    pub fn get_any(&self) -> Option<&[BufferedEarlyLint]> {\n+        let key = self.map.keys().next().map(|k| *k);\n+        key.map(|k| &self.map[&k][..])\n+    }\n+}\n+\n+pub fn struct_lint_level<'a>(sess: &'a Session,\n+                             lint: &'static Lint,\n+                             level: Level,\n+                             src: LintSource,\n+                             span: Option<MultiSpan>,\n+                             msg: &str)\n+    -> DiagnosticBuilder<'a>\n+{\n+    let mut err = match (level, span) {\n+        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n+        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n+        (Level::Warn, None) => sess.struct_warn(msg),\n+        (Level::Deny, Some(span)) |\n+        (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n+        (Level::Deny, None) |\n+        (Level::Forbid, None) => sess.struct_err(msg),\n+    };\n+\n+    let name = lint.name_lower();\n+    match src {\n+        LintSource::Default => {\n+            sess.diag_note_once(\n+                &mut err,\n+                lint,\n+                &format!(\"#[{}({})] on by default\", level.as_str(), name));\n+        }\n+        LintSource::CommandLine(lint_flag_val) => {\n+            let flag = match level {\n+                Level::Warn => \"-W\",\n+                Level::Deny => \"-D\",\n+                Level::Forbid => \"-F\",\n+                Level::Allow => panic!(),\n+            };\n+            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+            if lint_flag_val.as_str() == name {\n+                sess.diag_note_once(\n+                    &mut err,\n+                    lint,\n+                    &format!(\"requested on the command line with `{} {}`\",\n+                             flag, hyphen_case_lint_name));\n+            } else {\n+                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                sess.diag_note_once(\n+                    &mut err,\n+                    lint,\n+                    &format!(\"`{} {}` implied by `{} {}`\",\n+                             flag, hyphen_case_lint_name, flag,\n+                             hyphen_case_flag_val));\n+            }\n+        }\n+        LintSource::Node(lint_attr_name, src) => {\n+            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n+            if lint_attr_name.as_str() != name {\n+                let level_str = level.as_str();\n+                sess.diag_note_once(&mut err, lint,\n+                                    &format!(\"#[{}({})] implied by #[{}({})]\",\n+                                             level_str, name, level_str, lint_attr_name));\n+            }\n+        }\n+    }\n+\n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n+        let explanation = format!(\"this was previously accepted by the compiler \\\n+                                   but is being phased out; \\\n+                                   it will become a hard error in a future release!\");\n+        let citation = format!(\"for more information, see {}\",\n+                               future_incompatible.reference);\n+        err.warn(&explanation);\n+        err.note(&citation);\n+    }\n+\n+    return err\n+}\n+\n+fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n+    -> Rc<LintLevelMap>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+    let mut builder = LintLevelMapBuilder {\n+        levels: LintLevelSets::builder(tcx.sess),\n+        tcx: tcx,\n+    };\n+    let krate = tcx.hir.krate();\n+\n+    builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n+        intravisit::walk_crate(builder, krate);\n+    });\n+\n+    Rc::new(builder.levels.build_map())\n+}\n+\n+struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n+    levels: levels::LintLevelsBuilder<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &[ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let push = self.levels.push(attrs);\n+        self.levels.register_id(self.tcx.hir.definitions().node_to_hir_id(id));\n+        f(self);\n+        self.levels.pop(push);\n+    }\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+            intravisit::walk_item(builder, it);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n+        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+            intravisit::walk_foreign_item(builder, it);\n+        })\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+        self.with_lint_attrs(e.id, &e.attrs, |builder| {\n+            intravisit::walk_expr(builder, e);\n+        })\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.with_lint_attrs(s.id, &s.attrs, |builder| {\n+            intravisit::walk_struct_field(builder, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n+        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n+            intravisit::walk_variant(builder, v, g, item_id);\n+        })\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+        self.with_lint_attrs(l.id, &l.attrs, |builder| {\n+            intravisit::walk_local(builder, l);\n+        })\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |builder| {\n+            intravisit::walk_trait_item(builder, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |builder| {\n+            intravisit::walk_impl_item(builder, impl_item);\n+        });\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.lint_levels = lint_levels;\n+}"}, {"sha": "f2dab25229ae4e0ec3ed063c38dbd8b70d328637", "filename": "src/librustc/lint/table.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c2de81f4c97c8d1af685162f5a6faf8c89f6cd83/src%2Flibrustc%2Flint%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de81f4c97c8d1af685162f5a6faf8c89f6cd83/src%2Flibrustc%2Flint%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Ftable.rs?ref=c2de81f4c97c8d1af685162f5a6faf8c89f6cd83", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use syntax_pos::MultiSpan;\n-use util::nodemap::NodeMap;\n-\n-use super::{Lint, LintId, EarlyLint, IntoEarlyLint};\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct LintTable {\n-    map: NodeMap<Vec<EarlyLint>>\n-}\n-\n-impl LintTable {\n-    pub fn new() -> Self {\n-        LintTable { map: NodeMap() }\n-    }\n-\n-    pub fn add_lint<S: Into<MultiSpan>>(&mut self,\n-                                        lint: &'static Lint,\n-                                        id: ast::NodeId,\n-                                        sp: S,\n-                                        msg: String)\n-    {\n-        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n-    }\n-\n-    pub fn add_lint_diagnostic<M>(&mut self,\n-                                  lint: &'static Lint,\n-                                  id: ast::NodeId,\n-                                  msg: M)\n-        where M: IntoEarlyLint,\n-    {\n-        let lint_id = LintId::of(lint);\n-        let early_lint = msg.into_early_lint(lint_id);\n-        let arr = self.map.entry(id).or_insert(vec![]);\n-        if !arr.contains(&early_lint) {\n-            arr.push(early_lint);\n-        }\n-    }\n-\n-    pub fn get(&self, id: ast::NodeId) -> &[EarlyLint] {\n-        self.map.get(&id).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n-    pub fn take(&mut self, id: ast::NodeId) -> Vec<EarlyLint> {\n-        self.map.remove(&id).unwrap_or(vec![])\n-    }\n-\n-    pub fn transfer(&mut self, into: &mut LintTable) {\n-        into.map.extend(self.map.drain());\n-    }\n-\n-    /// Returns the first (id, lint) pair that is non-empty. Used to\n-    /// implement a sanity check in lints that all node-ids are\n-    /// visited.\n-    pub fn get_any(&self) -> Option<(&ast::NodeId, &Vec<EarlyLint>)> {\n-        self.map.iter()\n-                .filter(|&(_, v)| !v.is_empty())\n-                .next()\n-    }\n-}\n-"}, {"sha": "4e08bc90c7c3a5064bf80005a566bfdbc26e3bcc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -17,11 +17,11 @@ use hir::{self, Item_, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n-use middle::privacy;\n-use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use lint;\n+use middle::privacy;\n+use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n@@ -299,7 +299,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt,\n+                                    id: ast::NodeId,\n+                                    attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n     }\n@@ -315,14 +317,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n         return true;\n     }\n \n-    let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs) {\n-        match attr {\n-            Ok((name, lint::Allow, _)) if name == &*dead_code => return true,\n-            _ => (),\n-        }\n-    }\n-    false\n+    tcx.lint_level_at_node(lint::builtin::DEAD_CODE, id).0 == lint::Allow\n }\n \n // This visitor seeds items that\n@@ -338,14 +333,17 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder<'k> {\n+struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<ast::NodeId>,\n     krate: &'k hir::Crate,\n+    tcx: TyCtxt<'k, 'tcx, 'tcx>,\n }\n \n-impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n+impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                               item.id,\n+                                                               &item.attrs);\n         if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n@@ -360,7 +358,9 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                     match trait_item.node {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n-                            if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n+                            if has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                                trait_item.id,\n+                                                                &trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n                         }\n@@ -372,7 +372,9 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n-                            has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n+                            has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                             impl_item.id,\n+                                                             &impl_item.attrs) {\n                         self.worklist.push(impl_item_ref.id.node_id);\n                     }\n                 }\n@@ -408,6 +410,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut life_seeder = LifeSeeder {\n         worklist,\n         krate,\n+        tcx,\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n@@ -472,17 +475,19 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         !field.is_positional()\n             && !self.symbol_is_live(field.id, None)\n             && !is_marker_field\n-            && !has_allow_dead_code_or_lang_attr(&field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::Variant_) -> bool {\n         !self.symbol_is_live(variant.data.id(), None)\n-            && !has_allow_dead_code_or_lang_attr(&variant.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                 variant.data.id(),\n+                                                 &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n         !self.symbol_is_live(fi.id, None)\n-            && !has_allow_dead_code_or_lang_attr(&fi.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n     }\n \n     // id := node id of an item's definition.\n@@ -528,11 +533,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       node_type: &str) {\n         if !name.as_str().starts_with(\"_\") {\n             self.tcx\n-                .sess\n-                .add_lint(lint::builtin::DEAD_CODE,\n-                          id,\n-                          span,\n-                          format!(\"{} is never used: `{}`\", node_type, name));\n+                .lint_node(lint::builtin::DEAD_CODE,\n+                           id,\n+                           span,\n+                           &format!(\"{} is never used: `{}`\", node_type, name));\n         }\n     }\n }"}, {"sha": "fcf366788b22394a1901ccbc2e54bfae531076fe", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -56,11 +56,11 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         match self.unsafe_context.root {\n             SafeContext => {\n                 if is_lint {\n-                    self.tcx.sess.add_lint(lint::builtin::SAFE_EXTERN_STATICS,\n-                                           node_id,\n-                                           span,\n-                                           format!(\"{} requires unsafe function or \\\n-                                                    block (error E0133)\", description));\n+                    self.tcx.lint_node(lint::builtin::SAFE_EXTERN_STATICS,\n+                                       node_id,\n+                                       span,\n+                                       &format!(\"{} requires unsafe function or \\\n+                                                 block (error E0133)\", description));\n                 } else {\n                     // Report an error.\n                     struct_span_err!("}, {"sha": "070ad5159086e1607f9ae63ea5798cb0965322c2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1482,12 +1482,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"variable `{}` is assigned to, but never used\",\n-                                name));\n+                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                        &format!(\"variable `{}` is assigned to, but never used\",\n+                                 name));\n                 } else if name != \"self\" {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"unused variable: `{}`\", name));\n+                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                        &format!(\"unused variable: `{}`\", name));\n                 }\n             }\n             true\n@@ -1509,11 +1509,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn report_dead_assign(&self, id: NodeId, sp: Span, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value passed to `{}` is never read\", name));\n+                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                    &format!(\"value passed to `{}` is never read\", name));\n             } else {\n-                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value assigned to `{}` is never read\", name));\n+                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                    &format!(\"value assigned to `{}` is never read\", name));\n             }\n         }\n     }"}, {"sha": "5158c7e94af4c3025c1626cae5e91909fff1d599", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -493,7 +493,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"use of deprecated item\")\n             };\n \n-            self.sess.add_lint(lint::builtin::DEPRECATED, id, span, msg);\n+            self.lint_node(lint::builtin::DEPRECATED, id, span, &msg);\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n@@ -737,31 +737,31 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n-        sess.add_lint(lint::builtin::STABLE_FEATURES,\n+        tcx.lint_node(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,\n-                      format_stable_since_msg(version));\n+                      &format_stable_since_msg(version));\n     }\n \n     let index = tcx.stability.borrow();\n     for (used_lib_feature, level) in &index.used_features {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n                 if let &attr::StabilityLevel::Stable { since: ref version } = level {\n-                    sess.add_lint(lint::builtin::STABLE_FEATURES,\n+                    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,\n-                                  format_stable_since_msg(&version.as_str()));\n+                                  &format_stable_since_msg(&version.as_str()));\n                 }\n             }\n             None => ( /* used but undeclared, handled during the previous ast visit */ )\n         }\n     }\n \n     for &span in remaining_lib_features.values() {\n-        sess.add_lint(lint::builtin::UNUSED_FEATURES,\n+        tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,\n-                      \"unused or unknown feature\".to_string());\n+                      \"unused or unknown feature\");\n     }\n }"}, {"sha": "be39f95b98899b788a115303386b14d5d81b7746", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -79,7 +79,7 @@ pub struct Session {\n     // if the value stored here has been affected by path remapping.\n     pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<lint::LintTable>,\n+    pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n     /// Set of (LintId, Option<Span>, message) tuples tracking lint\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690).\n@@ -307,22 +307,15 @@ impl Session {\n         self.diagnostic().unimpl(msg)\n     }\n \n-    pub fn add_lint<S: Into<MultiSpan>>(&self,\n-                                        lint: &'static lint::Lint,\n-                                        id: ast::NodeId,\n-                                        sp: S,\n-                                        msg: String)\n-    {\n-        self.lints.borrow_mut().add_lint(lint, id, sp, msg);\n-    }\n-\n-    pub fn add_lint_diagnostic<M>(&self,\n-                                  lint: &'static lint::Lint,\n-                                  id: ast::NodeId,\n-                                  msg: M)\n-        where M: lint::IntoEarlyLint,\n-    {\n-        self.lints.borrow_mut().add_lint_diagnostic(lint, id, msg);\n+    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n+                                           lint: &'static lint::Lint,\n+                                           id: ast::NodeId,\n+                                           sp: S,\n+                                           msg: &str) {\n+        match *self.buffered_lints.borrow_mut() {\n+            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(), msg),\n+            None => bug!(\"can't buffer lints after HIR lowering\"),\n+        }\n     }\n \n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n@@ -708,7 +701,7 @@ pub fn build_session_(sopts: config::Options,\n         local_crate_source_file,\n         working_dir,\n         lint_store: RefCell::new(lint::LintStore::new()),\n-        lints: RefCell::new(lint::LintTable::new()),\n+        buffered_lints: RefCell::new(Some(lint::LintBuffer::new())),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         plugin_attributes: RefCell::new(Vec::new()),"}, {"sha": "f0fc6998c9e51735931516c79069d979302ebd6e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -499,11 +499,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // weird effect -- the diagnostic is reported as a lint, and\n         // the builder which is returned is marked as canceled.\n \n-        let mut err =\n-            struct_span_err!(self.tcx.sess,\n-                             error_span,\n-                             E0276,\n-                             \"impl has stricter requirements than trait\");\n+        let msg = \"impl has stricter requirements than trait\";\n+        let mut err = match lint_id {\n+            Some(node_id) => {\n+                self.tcx.struct_span_lint_node(EXTRA_REQUIREMENT_IN_IMPL,\n+                                               node_id,\n+                                               error_span,\n+                                               msg)\n+            }\n+            None => {\n+                struct_span_err!(self.tcx.sess,\n+                                 error_span,\n+                                 E0276,\n+                                 \"{}\", msg)\n+            }\n+        };\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.codemap().def_span(trait_item_span);\n@@ -514,13 +524,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             error_span,\n             format!(\"impl has extra requirement {}\", requirement));\n \n-        if let Some(node_id) = lint_id {\n-            self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n-                                              node_id,\n-                                              (*err).clone());\n-            err.cancel();\n-        }\n-\n         err\n     }\n "}, {"sha": "e843ba35ce520238404406b28869553d64da2561", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -512,11 +512,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             if raise_warning {\n-                tcx.sess.add_lint(lint::builtin::RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n-                                  obligation.cause.body_id,\n-                                  obligation.cause.span,\n-                                  format!(\"code relies on type inference rules which are likely \\\n-                                           to change\"));\n+                tcx.lint_node(lint::builtin::RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n+                              obligation.cause.body_id,\n+                              obligation.cause.span,\n+                              &format!(\"code relies on type inference rules which are likely \\\n+                                        to change\"));\n             }\n         }\n         Ok(ret)"}, {"sha": "6b9cbabf20e977887e59021f15c8b52f0b9775d7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,14 +11,15 @@\n //! type context book-keeping\n \n use dep_graph::DepGraph;\n+use errors::DiagnosticBuilder;\n use session::Session;\n-use lint;\n use middle;\n use hir::TraitMap;\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n+use lint::{self, Lint};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -58,6 +59,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n+use syntax::codemap::MultiSpan;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n@@ -254,9 +256,6 @@ pub struct TypeckTables<'tcx> {\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: NodeMap<ty::cast::CastKind>,\n \n-    /// Lints for the body of this fn generated by typeck.\n-    pub lints: lint::LintTable,\n-\n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n     pub used_trait_imports: DefIdSet,\n@@ -285,7 +284,6 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap(),\n             cast_kinds: NodeMap(),\n-            lints: lint::LintTable::new(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n@@ -1515,6 +1513,59 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n+\n+    pub fn lint_node<S: Into<MultiSpan>>(self,\n+                                         lint: &'static Lint,\n+                                         id: NodeId,\n+                                         span: S,\n+                                         msg: &str) {\n+        self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n+    }\n+\n+    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: NodeId)\n+        -> (lint::Level, lint::LintSource)\n+    {\n+        // Right now we insert a `with_ignore` node in the dep graph here to\n+        // ignore the fact that `lint_levels` below depends on the entire crate.\n+        // For now this'll prevent false positives of recompiling too much when\n+        // anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        self.dep_graph.with_ignore(|| {\n+            let sets = self.lint_levels(LOCAL_CRATE);\n+            loop {\n+                let hir_id = self.hir.definitions().node_to_hir_id(id);\n+                if let Some(pair) = sets.level_and_source(lint, hir_id) {\n+                    return pair\n+                }\n+                let next = self.hir.get_parent_node(id);\n+                if next == id {\n+                    bug!(\"lint traversal reached the root of the crate\");\n+                }\n+                id = next;\n+            }\n+        })\n+    }\n+\n+    pub fn struct_span_lint_node<S: Into<MultiSpan>>(self,\n+                                                     lint: &'static Lint,\n+                                                     id: NodeId,\n+                                                     span: S,\n+                                                     msg: &str)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        let (level, src) = self.lint_level_at_node(lint, id);\n+        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+    }\n+\n+    pub fn struct_lint_node(self, lint: &'static Lint, id: NodeId, msg: &str)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        let (level, src) = self.lint_level_at_node(lint, id);\n+        lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n+    }\n }\n \n pub trait InternAs<T: ?Sized, R> {"}, {"sha": "b871b36c948500100ab7f118a632d7dc6fa6a71e", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -12,6 +12,7 @@ use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n+use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference};\n use middle::privacy::AccessLevels;\n@@ -506,6 +507,12 @@ impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the lint levels for items in this crate\")\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -988,6 +995,8 @@ define_maps! { <'tcx>\n     [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n \n     [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+\n+    [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1059,3 +1068,7 @@ fn needs_drop_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstruct\n fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     DepConstructor::Layout\n }\n+\n+fn lint_levels<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LintLevels\n+}"}, {"sha": "a3f8aae472cae39e1d88465f0caeac5f74d73d15", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -23,7 +23,7 @@ use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::lint;\n-use rustc_errors::{Diagnostic, Level, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n@@ -351,12 +351,10 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             match arm_index {\n                                 // The arm with the user-specified pattern.\n                                 0 => {\n-                                    let mut diagnostic = Diagnostic::new(Level::Warning,\n-                                                                         \"unreachable pattern\");\n-                                    diagnostic.set_span(pat.span);\n-                                    cx.tcx.sess.add_lint_diagnostic(\n+                                    cx.tcx.lint_node(\n                                             lint::builtin::UNREACHABLE_PATTERNS,\n-                                            hir_pat.id, diagnostic);\n+                                        hir_pat.id, pat.span,\n+                                        \"unreachable pattern\");\n                                 },\n                                 // The arm with the wildcard pattern.\n                                 1 => {\n@@ -371,16 +369,18 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n                         hir::MatchSource::ForLoopDesugar |\n                         hir::MatchSource::Normal => {\n-                            let mut diagnostic = Diagnostic::new(Level::Warning,\n-                                                                 \"unreachable pattern\");\n-                            diagnostic.set_span(pat.span);\n+                            let mut err = cx.tcx.struct_span_lint_node(\n+                                lint::builtin::UNREACHABLE_PATTERNS,\n+                                hir_pat.id,\n+                                pat.span,\n+                                \"unreachable pattern\",\n+                            );\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                diagnostic.span_label(pat.span, \"this is an unreachable pattern\");\n-                                diagnostic.span_note(catchall, \"this pattern matches any value\");\n+                                err.span_label(pat.span, \"this is an unreachable pattern\");\n+                                err.span_note(catchall, \"this pattern matches any value\");\n                             }\n-                            cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n-                                                            hir_pat.id, diagnostic);\n+                            err.emit();\n                         },\n \n                         // Unreachable patterns in try expressions occur when one of the arms"}, {"sha": "3c01d4bafab2242764d35fa1b45b4f59abb30f57", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -638,7 +638,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         super::describe_lints(&sess.lint_store.borrow(), true);\n         return Err(CompileIncomplete::Stopped);\n     }\n-    sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n     // Currently, we ignore the name resolution data structures for the purposes of dependency\n     // tracking. Instead we will run name resolution and include its output in the hash of each\n@@ -708,8 +707,8 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         missing_fragment_specifiers.sort();\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n-            let msg = \"missing fragment specifier\".to_string();\n-            sess.add_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            let msg = \"missing fragment specifier\";\n+            sess.buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n         }\n         if ecx.parse_sess.span_diagnostic.err_count() - ecx.resolve_err_count > err_count {\n             ecx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -772,10 +771,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n \n-    time(time_passes,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n-\n     time(time_passes,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n@@ -800,6 +795,10 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         })\n     })?;\n \n+    time(time_passes,\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n@@ -908,6 +907,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n     cstore::provide_local(&mut local_providers);\n+    lint::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n@@ -1194,10 +1194,10 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          }\n                          Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n                          Some(_) => {\n-                             session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                              ast::CRATE_NODE_ID,\n-                                              a.span,\n-                                              \"invalid `crate_type` value\".to_string());\n+                             session.buffer_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                                 ast::CRATE_NODE_ID,\n+                                                 a.span,\n+                                                 \"invalid `crate_type` value\");\n                              None\n                          }\n                          _ => {"}, {"sha": "88432e64290316a85ef0bf6b35398fcea7feda13", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -36,7 +36,7 @@ use rustc::ty::{self, Ty};\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n-use lint::{Level, LateContext, LintContext, LintArray};\n+use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n \n use std::collections::HashSet;\n@@ -876,16 +876,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n                                              sp,\n                                              \"function cannot return without recurring\");\n-\n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n-            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n-                // offer some help to the programmer.\n-                for call in &self_call_spans {\n-                    db.span_note(*call, \"recursive call site\");\n-                }\n-                db.help(\"a `loop` may express intention \\\n-                         better if this is on purpose\");\n+            // offer some help to the programmer.\n+            for call in &self_call_spans {\n+                db.span_note(*call, \"recursive call site\");\n             }\n+            db.help(\"a `loop` may express intention \\\n+                     better if this is on purpose\");\n             db.emit();\n         }\n "}, {"sha": "2643ed2a3c07459faef968f4cfbf8c3e5d1b9d0f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -237,10 +237,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         self.check_trait_fn_not_const(sig.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, _| {\n-                                self.session.add_lint(lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n-                                                      trait_item.id, span,\n-                                                      \"patterns aren't allowed in methods \\\n-                                                       without bodies\".to_string());\n+                                self.session.buffer_lint(\n+                                    lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n+                                    trait_item.id, span,\n+                                    \"patterns aren't allowed in methods \\\n+                                     without bodies\");\n                             });\n                         }\n                     }\n@@ -252,7 +253,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if item.attrs.iter().any(|attr| attr.check_name(\"warn_directory_ownership\")) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n-                    self.session.add_lint(lint, item.id, item.span, msg.to_string());\n+                    self.session.buffer_lint(lint, item.id, item.span, msg);\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {"}, {"sha": "8443cc8267d1c87dc1fad2fe439cbd846db361ab", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -76,12 +76,12 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 ErroneousReferencedConstant(_) => {}\n                 TypeckError => {}\n                 _ => {\n-                    self.tcx.sess.add_lint(CONST_ERR,\n-                                           expr.id,\n-                                           expr.span,\n-                                           format!(\"constant evaluation error: {}. This will \\\n-                                                    become a HARD ERROR in the future\",\n-                                                   err.description().into_oneline()))\n+                    self.tcx.lint_node(CONST_ERR,\n+                                       expr.id,\n+                                       expr.span,\n+                                       &format!(\"constant evaluation error: {}. This will \\\n+                                                 become a HARD ERROR in the future\",\n+                                                err.description().into_oneline()));\n                 }\n             }\n         }\n@@ -260,10 +260,10 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     kind: LayoutError(ty::layout::LayoutError::Unknown(_)), ..\n                 }) => {}\n                 Err(msg) => {\n-                    self.tcx.sess.add_lint(CONST_ERR,\n-                                           ex.id,\n-                                           msg.span,\n-                                           msg.description().into_oneline().into_owned())\n+                    self.tcx.lint_node(CONST_ERR,\n+                                       ex.id,\n+                                       msg.span,\n+                                       &msg.description().into_oneline().into_owned());\n                 }\n             }\n         }"}, {"sha": "180d3dedf4b9ba9ba2cf467212999b96d69d410b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1345,11 +1345,11 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {\n-                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           node_id,\n-                                           self.span,\n-                                           format!(\"private trait `{}` in public \\\n-                                                    interface (error E0445)\", trait_ref));\n+                    self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                       node_id,\n+                                       self.span,\n+                                       &format!(\"private trait `{}` in public \\\n+                                                 interface (error E0445)\", trait_ref));\n                 }\n             }\n         }\n@@ -1393,11 +1393,11 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                         err.span_label(self.span, \"can't leak private type\");\n                         err.emit();\n                     } else {\n-                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               node_id,\n-                                               self.span,\n-                                               format!(\"private type `{}` in public \\\n-                                                        interface (error E0446)\", ty));\n+                        self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           self.span,\n+                                           &format!(\"private type `{}` in public \\\n+                                                     interface (error E0446)\", ty));\n                     }\n                 }\n             }"}, {"sha": "a8bb6619bbdda4b7ff9993e4bc27107df2da5b57", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -122,13 +122,13 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n                  directive.span.source_equal(&DUMMY_SP) => {}\n             ImportDirectiveSubclass::ExternCrate => {\n                 let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n-                let msg = \"unused extern crate\".to_string();\n-                resolver.session.add_lint(lint, directive.id, directive.span, msg);\n+                let msg = \"unused extern crate\";\n+             ;   resolver.session.buffer_lint(lint, directive.id, directive.span, msg)\n             }\n             ImportDirectiveSubclass::MacroUse => {\n                 let lint = lint::builtin::UNUSED_IMPORTS;\n-                let msg = \"unused `#[macro_use]` import\".to_string();\n-                resolver.session.add_lint(lint, directive.id, directive.span, msg);\n+                let msg = \"unused `#[macro_use]` import\";\n+                resolver.session.buffer_lint(lint, directive.id, directive.span, msg);\n             }\n             _ => {}\n         }\n@@ -160,9 +160,6 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n                           } else {\n                               String::new()\n                           });\n-        visitor.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                 *id,\n-                                 ms,\n-                                 msg);\n+        visitor.session.buffer_lint(lint::builtin::UNUSED_IMPORTS, *id, ms, &msg);\n     }\n }"}, {"sha": "b4f9ba4e8f78f29dbf961b707988156ac8192800", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -2552,9 +2552,10 @@ impl<'a> Resolver<'a> {\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.session.add_lint(lint, id, span,\n+                                self.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n-                                     reexports in outer modules\".to_string());\n+                                     reexports in outer modules\",\n+                                );\n                                 res = Some(PathResolution::new(ctor_def));\n                             }\n                         }\n@@ -2748,7 +2749,7 @@ impl<'a> Resolver<'a> {\n             };\n             if result.base_def() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n+                self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n             }\n         }\n \n@@ -3486,7 +3487,7 @@ impl<'a> Resolver<'a> {\n                 span.push_span_label(b1.span, msg1);\n                 span.push_span_label(b2.span, msg2);\n                 let msg = format!(\"`{}` is ambiguous\", name);\n-                self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n+                self.session.buffer_lint(lint::builtin::LEGACY_IMPORTS, id, span, &msg);\n             } else {\n                 let mut err =\n                     self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name));\n@@ -3607,8 +3608,8 @@ impl<'a> Resolver<'a> {\n \n     fn warn_legacy_self_import(&self, directive: &'a ImportDirective<'a>) {\n         let (id, span) = (directive.id, directive.span);\n-        let msg = \"`self` no longer imports values\".to_string();\n-        self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n+        let msg = \"`self` no longer imports values\";\n+        self.session.buffer_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n     }\n \n     fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) {"}, {"sha": "98eaa056177ef13c39f51fd05d9128df5dfdaa97", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -319,8 +319,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             };\n             if let Some((id, span)) = id_span {\n                 let lint = lint::builtin::UNUSED_MACROS;\n-                let msg = \"unused macro definition\".to_string();\n-                self.session.add_lint(lint, id, span, msg);\n+                let msg = \"unused macro definition\";\n+                self.session.buffer_lint(lint, id, span, msg);\n             } else {\n                 bug!(\"attempted to create unused macro error, but span not available\");\n             }"}, {"sha": "984ef3a44e1a1fed3911d482054928d75baa2bc8", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -745,8 +745,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0365), consider declaring with `pub`\",\n                                    ident);\n-                self.session.add_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                                      directive.id, directive.span, msg);\n+                self.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+                                         directive.id,\n+                                         directive.span,\n+                                         &msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be reexported\", ident)"}, {"sha": "2910d25486ed5ad714cf925f9ae24feaec9f71e6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -985,9 +985,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .span_label(data.span, \"only traits may use parentheses\")\n                     .emit();\n             } else {\n-                let msg = \"parenthesized parameters may only be used with a trait\".to_string();\n-                self.tcx().sess.add_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                                         ast::CRATE_NODE_ID, data.span, msg);\n+                let msg = \"parenthesized parameters may only be used with a trait\";\n+                self.tcx().lint_node(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+                                     ast::CRATE_NODE_ID, data.span, msg);\n             }\n         }\n     }"}, {"sha": "5f256eab9a9c8383a800882b1aa62a4bb9bfeca9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -291,25 +291,25 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n-            fcx.tables.borrow_mut().lints.add_lint(\n+            fcx.tcx.lint_node(\n                 lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                 self.expr.id,\n                 self.span,\n-                format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                         replaced by coercion, this might require type \\\n-                         ascription or a temporary variable\",\n-                        fcx.ty_to_string(t_expr),\n-                        fcx.ty_to_string(t_cast)));\n+                &format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                          replaced by coercion, this might require type \\\n+                          ascription or a temporary variable\",\n+                         fcx.ty_to_string(t_expr),\n+                         fcx.ty_to_string(t_cast)));\n         } else {\n-            fcx.tables.borrow_mut().lints.add_lint(\n+            fcx.tcx.lint_node(\n                 lint::builtin::TRIVIAL_CASTS,\n                 self.expr.id,\n                 self.span,\n-                format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                         replaced by coercion, this might require type \\\n-                         ascription or a temporary variable\",\n-                        fcx.ty_to_string(t_expr),\n-                        fcx.ty_to_string(t_cast)));\n+                &format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                          replaced by coercion, this might require type \\\n+                          ascription or a temporary variable\",\n+                         fcx.ty_to_string(t_expr),\n+                         fcx.ty_to_string(t_cast)));\n         }\n \n     }"}, {"sha": "6c9a6524d67819f02061bcbfb5bf593735e20043", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1713,10 +1713,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tables.borrow_mut().lints.add_lint(\n+            self.tcx().lint_node(\n                 lint::builtin::UNREACHABLE_CODE,\n                 id, span,\n-                format!(\"unreachable {}\", kind));\n+                &format!(\"unreachable {}\", kind));\n         }\n     }\n \n@@ -4746,8 +4746,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 let mut multispan = MultiSpan::from_span(lifetimes[0].span);\n                 multispan.push_span_label(span_late, note_msg.to_string());\n-                self.tcx.sess.add_lint(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n-                                       lifetimes[0].id, multispan, primary_msg.to_string());\n+                self.tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                   lifetimes[0].id, multispan, primary_msg);\n             }\n             return;\n         }"}, {"sha": "9e5cf5137c21f9f18c66d153c40f7e2cba5b620c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -43,7 +43,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n         wbcx.visit_cast_types();\n-        wbcx.visit_lints();\n         wbcx.visit_free_region_map();\n \n         let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n@@ -234,10 +233,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n     }\n \n-    fn visit_lints(&mut self) {\n-        self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n-    }\n-\n     fn visit_free_region_map(&mut self) {\n         let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n         let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");"}, {"sha": "e95d49f00bf76614741c1f0a349c7fc40067155a", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n         } else {\n             \"unused import\".to_string()\n         };\n-        self.tcx.sess.add_lint(lint::builtin::UNUSED_IMPORTS, id, span, msg);\n+        self.tcx.lint_node(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n     }\n }\n "}, {"sha": "fba32dbb889d9f195c5e1630019365862271ce2c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -999,12 +999,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if !allow_defaults && p.default.is_some() {\n             if !tcx.sess.features.borrow().default_type_parameter_fallback {\n-                tcx.sess.add_lint(\n+                tcx.lint_node(\n                     lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                     p.id,\n                     p.span,\n-                    format!(\"defaults for type parameters are only allowed in `struct`, \\\n-                             `enum`, `type`, or `trait` definitions.\"));\n+                    &format!(\"defaults for type parameters are only allowed in `struct`, \\\n+                              `enum`, `type`, or `trait` definitions.\"));\n             }\n         }\n "}, {"sha": "f42d1006bf5c1c18a3bdfe4539ce84879b54e68c", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,6 +11,7 @@\n // aux-build:attributes-included.rs\n \n #![feature(proc_macro, rustc_attrs)]\n+#![warn(unused)]\n \n extern crate attributes_included;\n "}, {"sha": "ccaf01932d46684001261207044f9f76f23c7751", "filename": "src/test/compile-fail/E0010.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2FE0010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2FE0010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0010.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(box_syntax)]\n+#![allow(warnings)]\n \n const CON : Box<i32> = box 0; //~ ERROR E0010\n                               //~| NOTE allocation not allowed in"}, {"sha": "c7d5665cd2c58482f12a3ff9a35cd77ddc1a3bdd", "filename": "src/test/compile-fail/E0394.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2FE0394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2FE0394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0394.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n static A: u32 = 0;\n static B: u32 = A;\n //~^ ERROR E0394"}, {"sha": "cb9fb973a01939e332b0bd3cc310be2c6312ac56", "filename": "src/test/compile-fail/bad-lint-cap2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -10,6 +10,7 @@\n \n // compile-flags: --cap-lints deny\n \n+#![warn(unused)]\n #![deny(warnings)]\n \n use std::option; //~ ERROR"}, {"sha": "c9394954c5fbd3485c99e74abf0a6e8b9f3d1ce6", "filename": "src/test/compile-fail/bad-lint-cap3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -10,6 +10,7 @@\n \n // compile-flags: --cap-lints warn\n \n+#![warn(unused)]\n #![deny(warnings)]\n #![feature(rustc_attrs)]\n "}, {"sha": "3642add32597b781cf416664c77ff0e6a418820b", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -12,6 +12,7 @@\n \n // gate-test-drop_types_in_const\n \n+#![allow(warnings)]\n #![feature(box_syntax)]\n \n use std::marker;"}, {"sha": "0fd41a17b2c9c0554a141b0695196be76ff9537f", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,7 +11,7 @@\n // Evaluation of constants in refutable patterns goes through\n // different compiler control-flow paths.\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, warnings)]\n \n use std::fmt;\n use std::{i8, i16, i32, i64, isize};"}, {"sha": "bc944948f3d8b846eb0a6e0208921680a0d52f1a", "filename": "src/test/compile-fail/const-match-pattern-arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n const x: bool = match Some(true) {\n     Some(value) => true,\n     //~^ ERROR: constant contains unimplemented expression type [E0019]"}, {"sha": "360895d30b0b7e39866ea4ba4e754299dbf1fb84", "filename": "src/test/compile-fail/feature-gate-dropck-ugeh.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -28,7 +28,6 @@ struct Foo<T> { data: Vec<T> }\n impl<T> Drop for Foo<T> {\n     #[unsafe_destructor_blind_to_params] // This is the UGEH attribute\n     //~^ ERROR unsafe_destructor_blind_to_params has been replaced\n-    //~^^ WARN: use of deprecated attribute\n     fn drop(&mut self) { }\n }\n "}, {"sha": "d8f9f5543e43964f7d84cc541190849d92f1ed99", "filename": "src/test/compile-fail/issue-14227.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics, warnings)]\n+\n extern {\n     pub static symbol: ();\n }"}, {"sha": "08c3f7a7c15451a6d5dcc647f555bc563f386b9c", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics)]\n+\n mod Y {\n     pub type X = usize;\n     extern {"}, {"sha": "cde1bbbe4927a427d1603026ce0ad771bf8a165f", "filename": "src/test/compile-fail/issue-17450.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)]\n+#![allow(dead_code, warnings)]\n \n static mut x: isize = 3;\n static mut y: isize = unsafe {"}, {"sha": "4857c2fb446b519e9097ea3154705d5f571c4397", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #[deny(warnings)]\n \n const foo: isize = 3;"}, {"sha": "8e0df283cdbebe839936be20c1dd597c7635ea12", "filename": "src/test/compile-fail/issue-17718-references.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n struct Struct { a: usize }\n \n const C: usize = 1;"}, {"sha": "5996c8e5438783fe2defdf81e9da1e12f9821386", "filename": "src/test/compile-fail/issue-18937.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -26,7 +26,7 @@ trait A<'a> {\n }\n \n impl<'a> A<'a> for B {\n-    fn foo<F>(&mut self, f: F) //~ ERROR E0276\n+    fn foo<F>(&mut self, f: F) //~ ERROR impl has stricter\n         //~^ WARNING future release\n         where F: fmt::Debug + 'static,\n     {"}, {"sha": "057c99f930510aa9a6add482b10a499f1b550991", "filename": "src/test/compile-fail/issue-28075.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -12,7 +12,7 @@\n \n // aux-build:lint_stability.rs\n \n-#![allow(unused_imports)]\n+#![allow(warnings)]\n \n extern crate lint_stability;\n "}, {"sha": "7d2541966a4810a3a2f6bebc0fb2b860e364e825", "filename": "src/test/compile-fail/issue-28113.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n const X: u8 =\n     || -> u8 { 5 }()\n     //~^ ERROR calls in constants are limited to constant functions"}, {"sha": "3c4d6b42b503dfc72956de56d5fd5346878ff5ec", "filename": "src/test/compile-fail/issue-28324.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics)]\n+\n extern {\n     static error_message_count: u32;\n }"}, {"sha": "d1af39a6c1872497cf27b4236535e6e76dcf6024", "filename": "src/test/compile-fail/issue-30730.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![deny(warnings)] //~ NOTE: lint level defined here\n use std::thread;\n //~^ ERROR: unused import"}, {"sha": "d5733f98193874735004ab2e09bfdf5dc1514176", "filename": "src/test/compile-fail/issue-37515.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n+#![warn(unused)]\n \n type Z = for<'x> Send;\n //~^ WARN type alias is never used"}, {"sha": "bd32317ae78086b3e709bd9a19a1859aed2f35b9", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(box_syntax)]\n #![feature(const_fn)]\n+#![allow(warnings)]\n \n use std::cell::RefCell;\n "}, {"sha": "9f84190ea18a1f3e8bb598ae2a53b89e1f038aba", "filename": "src/test/compile-fail/lint-removed-allow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,7 +11,8 @@\n // No warnings about removed lint when\n // allow(renamed_and_removed_lints)\n \n+#![allow(renamed_and_removed_lints)]\n+\n #[deny(raw_pointer_derive)]\n-#[allow(renamed_and_removed_lints)]\n #[deny(unused_variables)]\n fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "e1da5086612fd7d5eacb4bd77bce414550ada9e6", "filename": "src/test/compile-fail/lint-removed-cmdline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -16,5 +16,7 @@\n // error-pattern:lint raw_pointer_derive has been removed\n // error-pattern:requested on the command line with `-D raw_pointer_derive`\n \n+#![warn(unused)]\n+\n #[deny(warnings)]\n fn main() { let unused = (); }"}, {"sha": "ae010b64bfdfc75cfe945d07385ae90293638bbd", "filename": "src/test/compile-fail/lint-renamed-allow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,7 +11,8 @@\n // No warnings about renamed lint when\n // allow(renamed_and_removed_lints)\n \n+#![allow(renamed_and_removed_lints)]\n+\n #[deny(unknown_features)]\n-#[allow(renamed_and_removed_lints)]\n #[deny(unused)]\n fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "8443518b3f5681c682c188f1e98905768b50bb2b", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -13,9 +13,9 @@\n // aux-build:stability_cfg1.rs\n // aux-build:stability_cfg2.rs\n \n-#![deny(deprecated)]\n+#![warn(deprecated)]\n #![allow(dead_code)]\n-#![feature(staged_api, test_feature)]\n+#![feature(staged_api, test_feature, rustc_attrs)]\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -32,41 +32,41 @@ mod cross_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-\n-        deprecated_unstable(); //~ ERROR use of deprecated item\n-        foo.method_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        deprecated(); //~ WARN use of deprecated item\n+        foo.method_deprecated(); //~ WARN use of deprecated item\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+\n+        deprecated_unstable(); //~ WARN use of deprecated item\n+        foo.method_deprecated_unstable(); //~ WARN use of deprecated item\n+        Foo::method_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n \n         unstable();\n         foo.method_unstable();\n@@ -106,30 +106,30 @@ mod cross_crate {\n \n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n-        //~^ ERROR use of deprecated item\n+        //~^ WARN use of deprecated item\n \n-        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+        let _ = DeprecatedStruct { //~ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = DeprecatedUnstableStruct {\n-            //~^ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+            //~^ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item\n+        let _ = DeprecatedUnstableUnitStruct; //~ WARN use of deprecated item\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n-        let _ = Enum::DeprecatedUnstableVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item\n+        let _ = Enum::DeprecatedUnstableVariant; //~ WARN use of deprecated item\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item\n+        let _ = DeprecatedUnstableTupleStruct (1); //~ WARN use of deprecated item\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n \n@@ -138,28 +138,28 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n-        macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n-        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(deprecated_text()); //~ WARN use of deprecated item: text\n+        macro_test_arg!(deprecated_unstable_text()); //~ WARN use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ WARN use of deprecated item: text\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -175,10 +175,10 @@ mod cross_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -187,9 +187,9 @@ mod cross_crate {\n     struct S;\n \n     impl UnstableTrait for S { }\n-    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n+    impl DeprecatedTrait for S {} //~ WARN use of deprecated item: text\n     trait LocalTrait : UnstableTrait { }\n-    trait LocalTrait2 : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n+    trait LocalTrait2 : DeprecatedTrait { } //~ WARN use of deprecated item: text\n \n     impl Trait for S {\n         fn trait_stable(&self) {}\n@@ -208,7 +208,7 @@ mod inheritance {\n         stable_mod::unstable();\n         stable_mod::stable();\n \n-        unstable_mod::deprecated(); //~ ERROR use of deprecated item\n+        unstable_mod::deprecated(); //~ WARN use of deprecated item\n         unstable_mod::unstable();\n \n         let _ = Unstable::UnstableVariant;\n@@ -330,23 +330,23 @@ mod this_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        deprecated(); //~ WARN use of deprecated item\n+        foo.method_deprecated(); //~ WARN use of deprecated item\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n \n         unstable();\n         foo.method_unstable();\n@@ -385,34 +385,34 @@ mod this_crate {\n         <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct {\n-            //~^ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+            //~^ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -428,8 +428,8 @@ mod this_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -439,15 +439,15 @@ mod this_crate {\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n-        fn_in_body(); //~ ERROR use of deprecated item: text\n+        fn_in_body(); //~ WARN use of deprecated item: text\n     }\n \n     impl MethodTester {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n-            fn_in_body(); //~ ERROR use of deprecated item: text\n+            fn_in_body(); //~ WARN use of deprecated item: text\n         }\n     }\n \n@@ -459,9 +459,9 @@ mod this_crate {\n \n     struct S;\n \n-    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+    impl DeprecatedTrait for S { } //~ WARN use of deprecated item\n \n-    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+    trait LocalTrait : DeprecatedTrait { } //~ WARN use of deprecated item\n }\n \n-fn main() {}\n+#[rustc_error] fn main() {} //~ ERROR: compilation successful"}, {"sha": "5593499758346d37c7cd001c55e95cd0579e2716", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -9,16 +9,18 @@\n // except according to those terms.\n //\n \n-#![deny(overflowing_literals)]\n-#![deny(const_err)]\n+#![warn(overflowing_literals)]\n+#![warn(const_err)]\n+#![feature(rustc_attrs)]\n \n #[allow(unused_variables)]\n-fn main() {\n-    let x2: i8 = --128; //~ error: literal out of range for i8\n-    //~^ error: attempt to negate with overflow\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    let x2: i8 = --128; //~ warn: literal out of range for i8\n+    //~^ warn: attempt to negate with overflow\n \n-    let x = -3.40282357e+38_f32; //~ error: literal out of range for f32\n-    let x =  3.40282357e+38_f32; //~ error: literal out of range for f32\n-    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n-    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+    let x = -3.40282357e+38_f32; //~ warn: literal out of range for f32\n+    let x =  3.40282357e+38_f32; //~ warn: literal out of range for f32\n+    let x = -1.7976931348623159e+308_f64; //~ warn: literal out of range for f64\n+    let x =  1.7976931348623159e+308_f64; //~ warn: literal out of range for f64\n }"}, {"sha": "1d947684792dd9a78964528e836dedbc15ab5d13", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![allow(dead_code)]\n #![deny(non_snake_case)]\n "}, {"sha": "d056d6be806f7828b62aa20fbea8905e2155ba29", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types, trivial_numeric_casts)]"}, {"sha": "1e0cc0f5357fb6f7cce36fddfb8ab5130cb32567", "filename": "src/test/compile-fail/never-assign-dead-code.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -10,12 +10,12 @@\n \n // Test that an assignment of type ! makes the rest of the block dead code.\n \n-#![feature(never_type)]\n-#![deny(unused, unreachable_code)]\n+#![feature(never_type, rustc_attrs)]\n+#![warn(unused)]\n \n-fn main() {\n-    let x: ! = panic!(\"aah\"); //~ ERROR unused\n-    drop(x); //~ ERROR unreachable\n-    //~^ ERROR unreachable\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    let x: ! = panic!(\"aah\"); //~ WARN unused\n+    drop(x); //~ WARN unreachable\n+    //~^ WARN unreachable\n }\n-"}, {"sha": "4d41f8ba47d014334ed82e4e7e3ba01024df2bb8", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,6 +11,7 @@\n #![feature(associated_consts)]\n #![feature(conservative_impl_trait)]\n #![feature(decl_macro)]\n+#![allow(warnings)]\n \n mod m {\n     fn priv_fn() {}"}, {"sha": "a5581664f741859baa603fd7c7b140a73f850d60", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,6 +11,7 @@\n // aux-build:private-inferred-type.rs\n \n #![feature(conservative_impl_trait)]\n+#![allow(warnings)]\n \n extern crate private_inferred_type as ext;\n "}, {"sha": "a855b08f06691f8603411e21c6d921ffe4b0a1fc", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -14,6 +14,7 @@\n \n static mut a: Box<isize> = box 3;\n //~^ ERROR allocations are not allowed in statics\n-//~^^ ERROR destructors in statics are an unstable feature\n+//~| ERROR destructors in statics are an unstable feature\n+//~| WARN: constant evaluation error\n \n fn main() {}"}, {"sha": "46ea4a06a3bd8a41a9dcf2ecbc950bedb5eda83b", "filename": "src/test/compile-fail/unreachable-try-pattern.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(never_type)]\n-#![deny(unreachable_code)]\n-#![deny(unreachable_patterns)]\n+#![feature(never_type, rustc_attrs)]\n+#![warn(unreachable_code)]\n+#![warn(unreachable_patterns)]\n \n enum Void {}\n \n@@ -26,8 +26,8 @@ fn bar(x: Result<!, i32>) -> Result<u32, i32> {\n \n fn foo(x: Result<!, i32>) -> Result<u32, i32> {\n     let y = (match x { Ok(n) => Ok(n as u32), Err(e) => Err(e) })?;\n-    //~^ ERROR unreachable pattern\n-    //~| ERROR unreachable expression\n+    //~^ WARN unreachable pattern\n+    //~| WARN unreachable expression\n     Ok(y)\n }\n \n@@ -37,11 +37,12 @@ fn qux(x: Result<u32, Void>) -> Result<u32, i32> {\n \n fn vom(x: Result<u32, Void>) -> Result<u32, i32> {\n     let y = (match x { Ok(n) => Ok(n), Err(e) => Err(e) })?;\n-    //~^ ERROR unreachable pattern\n+    //~^ WARN unreachable pattern\n     Ok(y)\n }\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n     let _ = bar(Err(123));\n     let _ = foo(Err(123));\n     let _ = qux(Ok(123));"}, {"sha": "19ce2362134543b90d49bb515a0823bb2534eddb", "filename": "src/test/ui-fulldeps/lint-plugin-cmdline-allow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -14,6 +14,7 @@\n // compile-flags: -A test-lint\n \n #![feature(plugin)]\n+#![warn(unused)]\n #![plugin(lint_plugin_test)]\n \n fn lintme() { }"}, {"sha": "7c9c4e9903908d0741c4b0f9d25dbe56b14bab97", "filename": "src/test/ui-fulldeps/lint-plugin-cmdline-allow.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,8 +1,13 @@\n warning: function is never used: `lintme`\n-  --> $DIR/lint-plugin-cmdline-allow.rs:19:1\n+  --> $DIR/lint-plugin-cmdline-allow.rs:20:1\n    |\n-19 | fn lintme() { }\n+20 | fn lintme() { }\n    | ^^^^^^^^^^^^^^^\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/lint-plugin-cmdline-allow.rs:17:9\n+   |\n+17 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n "}, {"sha": "108d7e1ea22a15c17cf916ec8188c37168e0423f", "filename": "src/test/ui/check_match/issue-43253.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(exclusive_range_pattern)]\n+#![warn(unreachable_patterns)]\n \n fn main() {\n     // These cases should generate no warning.\n@@ -48,4 +49,4 @@ fn main() {\n         9...9 => {},\n         _ => {},\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a1cb3963914c9a42e98628f986ed424f8883eb92", "filename": "src/test/ui/check_match/issue-43253.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,20 +1,24 @@\n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:36:9\n+  --> $DIR/issue-43253.rs:37:9\n    |\n-36 |         9 => {},\n+37 |         9 => {},\n    |         ^\n    |\n-   = note: #[warn(unreachable_patterns)] on by default\n+note: lint level defined here\n+  --> $DIR/issue-43253.rs:12:9\n+   |\n+12 | #![warn(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:42:9\n+  --> $DIR/issue-43253.rs:43:9\n    |\n-42 |         8...9 => {},\n+43 |         8...9 => {},\n    |         ^^^^^\n \n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:48:9\n+  --> $DIR/issue-43253.rs:49:9\n    |\n-48 |         9...9 => {},\n+49 |         9...9 => {},\n    |         ^^^^^\n "}, {"sha": "e58251c846f8dae0da64f9c7f019431fd423ff24", "filename": "src/test/ui/compare-method/proj-outlives-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,4 +1,4 @@\n-error[E0276]: impl has stricter requirements than trait\n+error: impl has stricter requirements than trait\n   --> $DIR/proj-outlives-region.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;"}, {"sha": "95db68fea5cf73c534715e841758a84560b663dc", "filename": "src/test/ui/compare-method/region-unrelated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,4 +1,4 @@\n-error[E0276]: impl has stricter requirements than trait\n+error: impl has stricter requirements than trait\n   --> $DIR/region-unrelated.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;"}, {"sha": "5aea5f2ca06423823f51bbee89a1b0f0a66de551", "filename": "src/test/ui/lint/fn_must_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused_must_use)]\n \n struct MyStruct {\n     n: usize"}, {"sha": "20eb7452aea7163b200f252f09482f150b44ffff", "filename": "src/test/ui/lint/fn_must_use.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,14 +1,18 @@\n warning: unused return value of `need_to_use_this_value` which must be used: it's important\n-  --> $DIR/fn_must_use.rs:29:5\n+  --> $DIR/fn_must_use.rs:30:5\n    |\n-29 |     need_to_use_this_value();\n+30 |     need_to_use_this_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: #[warn(unused_must_use)] on by default\n+note: lint level defined here\n+  --> $DIR/fn_must_use.rs:11:9\n+   |\n+11 | #![warn(unused_must_use)]\n+   |         ^^^^^^^^^^^^^^^\n \n warning: unused return value of `MyStruct::need_to_use_this_method_value` which must be used\n-  --> $DIR/fn_must_use.rs:32:5\n+  --> $DIR/fn_must_use.rs:33:5\n    |\n-32 |     m.need_to_use_this_method_value();\n+33 |     m.need_to_use_this_method_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n "}, {"sha": "a79dacbc1c959c4388a8a597436f7f20fed30980", "filename": "src/test/ui/lint/outer-forbid.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -16,7 +16,13 @@\n \n #![forbid(unused, non_snake_case)]\n \n-#[allow(unused, unused_variables, bad_style)]\n+#[allow(unused_variables)]\n+fn foo() {}\n+\n+#[allow(unused)]\n+fn bar() {}\n+\n+#[allow(bad_style)]\n fn main() {\n     println!(\"hello forbidden world\")\n }"}, {"sha": "67a1f4f88adc64767addf31df7bcc2501c40674f", "filename": "src/test/ui/lint/outer-forbid.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,29 +1,29 @@\n-error[E0453]: allow(unused) overruled by outer forbid(unused)\n+error[E0453]: allow(unused_variables) overruled by outer forbid(unused)\n   --> $DIR/outer-forbid.rs:19:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |           ------ `forbid` level set here\n 18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |         ^^^^^^ overruled by previous forbid\n+19 | #[allow(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^ overruled by previous forbid\n \n-error[E0453]: allow(unused_variables) overruled by outer forbid(unused)\n-  --> $DIR/outer-forbid.rs:19:17\n+error[E0453]: allow(unused) overruled by outer forbid(unused)\n+  --> $DIR/outer-forbid.rs:22:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |           ------ `forbid` level set here\n-18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |                 ^^^^^^^^^^^^^^^^ overruled by previous forbid\n+...\n+22 | #[allow(unused)]\n+   |         ^^^^^^ overruled by previous forbid\n \n error[E0453]: allow(bad_style) overruled by outer forbid(non_snake_case)\n-  --> $DIR/outer-forbid.rs:19:35\n+  --> $DIR/outer-forbid.rs:25:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |                   -------------- `forbid` level set here\n-18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |                                   ^^^^^^^^^ overruled by previous forbid\n+...\n+25 | #[allow(bad_style)]\n+   |         ^^^^^^^^^ overruled by previous forbid\n \n error: aborting due to 3 previous errors\n "}, {"sha": "367a2560155588aa7ab644e28cd91e445a997b3b", "filename": "src/test/ui/path-lookahead.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fpath-lookahead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fpath-lookahead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpath-lookahead.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -10,6 +10,8 @@\n \n // run-pass\n \n+#![warn(unused)]\n+\n // Parser test for #37765\n \n fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`"}, {"sha": "9936a1eb81e2a9fdd39a3a24b25e6ea7dfad46e9", "filename": "src/test/ui/path-lookahead.stderr", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fpath-lookahead.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fpath-lookahead.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpath-lookahead.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,26 +1,31 @@\n warning: unnecessary parentheses around `return` value\n-  --> $DIR/path-lookahead.rs:16:10\n+  --> $DIR/path-lookahead.rs:18:10\n    |\n-16 |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n+18 |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(unused_parens)] on by default\n \n warning: function is never used: `with_parens`\n-  --> $DIR/path-lookahead.rs:15:1\n+  --> $DIR/path-lookahead.rs:17:1\n    |\n-15 | / fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`\n-16 | |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n-17 | | }\n+17 | / fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`\n+18 | |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n+19 | | }\n    | |_^\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/path-lookahead.rs:13:9\n+   |\n+13 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n \n warning: function is never used: `no_parens`\n-  --> $DIR/path-lookahead.rs:19:1\n+  --> $DIR/path-lookahead.rs:21:1\n    |\n-19 | / fn no_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `no_parens`\n-20 | |   return <T as ToString>::to_string(&arg);\n-21 | | }\n+21 | / fn no_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `no_parens`\n+22 | |   return <T as ToString>::to_string(&arg);\n+23 | | }\n    | |_^\n "}, {"sha": "9f4562fe297180fac5c8f86ca0321a64ebec014c", "filename": "src/test/ui/reachable/expr_unary.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,8 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_unary.rs:18:28\n+   |\n+18 |     let x: ! = ! { return; 22 };\n+   |                            ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_unary.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n error[E0600]: cannot apply unary operator `!` to type `!`\n   --> $DIR/expr_unary.rs:18:16\n    |\n 18 |     let x: ! = ! { return; 22 };\n    |                ^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "f59d2845108fbd93807eb638106ad5d603beac63", "filename": "src/test/ui/span/issue-24690.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -11,10 +11,13 @@\n //! A test to ensure that helpful `note` messages aren't emitted more often\n //! than necessary.\n \n-// Although there are three errors, we should only get two \"lint level defined\n+#![feature(rustc_attrs)]\n+\n+// Although there are three warnings, we should only get two \"lint level defined\n // here\" notes pointing at the `warnings` span, one for each error type.\n-#![deny(warnings)]\n+#![warn(unused)]\n \n+#[rustc_error]\n fn main() {\n     let theTwo = 2;\n     let theOtherTwo = 2;"}, {"sha": "4f1c870d87457b4448dab4f73b0737b7d3be4afa", "filename": "src/test/ui/span/issue-24690.stderr", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,34 +1,37 @@\n-error: variable `theTwo` should have a snake case name such as `the_two`\n-  --> $DIR/issue-24690.rs:19:9\n+warning: unused variable: `theOtherTwo`\n+  --> $DIR/issue-24690.rs:23:9\n    |\n-19 |     let theTwo = 2;\n-   |         ^^^^^^\n+23 |     let theOtherTwo = 2;\n+   |         ^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/issue-24690.rs:16:9\n+  --> $DIR/issue-24690.rs:18:9\n    |\n-16 | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: #[deny(non_snake_case)] implied by #[deny(warnings)]\n+18 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(unused_variables)] implied by #[warn(unused)]\n \n-error: variable `theOtherTwo` should have a snake case name such as `the_other_two`\n-  --> $DIR/issue-24690.rs:20:9\n+warning: variable `theTwo` should have a snake case name such as `the_two`\n+  --> $DIR/issue-24690.rs:22:9\n    |\n-20 |     let theOtherTwo = 2;\n-   |         ^^^^^^^^^^^\n+22 |     let theTwo = 2;\n+   |         ^^^^^^\n+   |\n+   = note: #[warn(non_snake_case)] on by default\n \n-error: unused variable: `theOtherTwo`\n-  --> $DIR/issue-24690.rs:20:9\n+warning: variable `theOtherTwo` should have a snake case name such as `the_other_two`\n+  --> $DIR/issue-24690.rs:23:9\n    |\n-20 |     let theOtherTwo = 2;\n+23 |     let theOtherTwo = 2;\n    |         ^^^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/issue-24690.rs:16:9\n-   |\n-16 | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: #[deny(unused_variables)] implied by #[deny(warnings)]\n \n-error: aborting due to 3 previous errors\n+error: compilation successful\n+  --> $DIR/issue-24690.rs:21:1\n+   |\n+21 | / fn main() {\n+22 | |     let theTwo = 2;\n+23 | |     let theOtherTwo = 2;\n+24 | |     println!(\"{}\", theTwo);\n+25 | | }\n+   | |_^\n "}, {"sha": "b7aae39c4692710c349a1b60586d84a60070fcdd", "filename": "src/test/ui/span/macro-span-replacement.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n+\n macro_rules! m {\n     ($a:tt $b:tt) => {\n         $b $a;"}, {"sha": "af03aa6a369082662b86b4618923a3362f0c82b4", "filename": "src/test/ui/span/macro-span-replacement.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,11 +1,16 @@\n warning: struct is never used: `S`\n-  --> $DIR/macro-span-replacement.rs:13:9\n+  --> $DIR/macro-span-replacement.rs:15:9\n    |\n-13 |         $b $a;\n+15 |         $b $a;\n    |         ^^^^^^\n ...\n-18 |     m!(S struct);\n+20 |     m!(S struct);\n    |     ------------- in this macro invocation\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/macro-span-replacement.rs:11:9\n+   |\n+11 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n "}, {"sha": "66536b29c0298dfa9ae0de164a8cfb0d9948f6cf", "filename": "src/test/ui/span/multispan-import-lint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n+\n use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n \n fn main() {"}, {"sha": "1fecdea7d0d06a2db513b990df57170d47a98e6c", "filename": "src/test/ui/span/multispan-import-lint.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1,8 +1,13 @@\n warning: unused imports: `Eq`, `Ord`, `PartialEq`, `PartialOrd`\n-  --> $DIR/multispan-import-lint.rs:11:16\n+  --> $DIR/multispan-import-lint.rs:13:16\n    |\n-11 | use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n+13 | use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n    |                ^^  ^^^       ^^^^^^^^^  ^^^^^^^^^^\n    |\n-   = note: #[warn(unused_imports)] on by default\n+note: lint level defined here\n+  --> $DIR/multispan-import-lint.rs:11:9\n+   |\n+11 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(unused_imports)] implied by #[warn(unused)]\n "}, {"sha": "769748c63c02ddb52000fc01d3d3e65909e6dea3", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0374e6aab7ef60b523872556ae4aca33c59fbfc9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0374e6aab7ef60b523872556ae4aca33c59fbfc9", "patch": "@@ -1156,9 +1156,21 @@ actual:\\n\\\n     fn compile_test(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let link_args = vec![\"-L\".to_owned(),\n-                             aux_dir.to_str().unwrap().to_owned()];\n-        let args = self.make_compile_args(link_args,\n+        let mut extra_args = vec![\"-L\".to_owned(),\n+                                  aux_dir.to_str().unwrap().to_owned()];\n+        match self.config.mode {\n+            CompileFail | Ui => {\n+                // compile-fail and ui tests tend to have tons of unused code as\n+                // it's just testing various pieces of the compile, but we don't\n+                // want to actually assert warnings about all this code. Instead\n+                // let's just ignore unused code warnings by defaults and tests\n+                // can turn it back on if needed.\n+                extra_args.push(\"-A\".to_owned());\n+                extra_args.push(\"unused\".to_owned());\n+            }\n+            _ => {}\n+        }\n+        let args = self.make_compile_args(extra_args,\n                                           &self.testpaths.file,\n                                           TargetLocation::ThisFile(self.make_exe_name()));\n         self.compose_and_run_compiler(args, None)"}]}