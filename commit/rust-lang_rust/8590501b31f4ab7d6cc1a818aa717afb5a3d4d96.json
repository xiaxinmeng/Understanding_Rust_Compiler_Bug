{"sha": "8590501b31f4ab7d6cc1a818aa717afb5a3d4d96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTA1MDFiMzFmNGFiN2Q2Y2MxYTgxOGFhNzE3YWZiNWEzZDRkOTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-19T14:02:48Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-24T18:34:10Z"}, "message": "Add E0270", "tree": {"sha": "9a88c8ce3c25c48a5435e11e58cfefdfd70e2379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a88c8ce3c25c48a5435e11e58cfefdfd70e2379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96", "html_url": "https://github.com/rust-lang/rust/commit/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4337e822fb043e3e3abd085ca6483f15f11d913a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4337e822fb043e3e3abd085ca6483f15f11d913a", "html_url": "https://github.com/rust-lang/rust/commit/4337e822fb043e3e3abd085ca6483f15f11d913a"}], "stats": {"total": 104, "additions": 87, "deletions": 17}, "files": [{"sha": "2aa31248503c1c79050e769905bbe985553bc5c4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 87, "deletions": 17, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8590501b31f4ab7d6cc1a818aa717afb5a3d4d96/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8590501b31f4ab7d6cc1a818aa717afb5a3d4d96", "patch": "@@ -573,8 +573,8 @@ implementation if the function is called with unparametrized substitutions\n (i.e., substitutions where none of the substituted types are themselves\n parametrized).\n \n-However, with trait objects we have to make a table containing _every object\n-that implements the trait_. Now, if it has type parameters, we need to add\n+However, with trait objects we have to make a table containing _every_ object\n+that implements the trait. Now, if it has type parameters, we need to add\n implementations for every type that implements the trait, and there could\n theoretically be an infinite number of types.\n \n@@ -609,9 +609,9 @@ fn call_foo(thing: Box<Trait>) {\n ```\n \n we don't just need to create a table of all implementations of all methods of\n-`Trait`, we need to create a table of all implementations of `foo()`, _for each\n-different type fed to `foo()`_. In this case this turns out to be (10 types\n-implementing `Trait`)*(3 types being fed to `foo()`) = 30 implementations!\n+`Trait`, we need to create such a table, for each different type fed to\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+types being fed to `foo()`) = 30 implementations!\n \n With real world traits these numbers can grow drastically.\n \n@@ -684,19 +684,19 @@ If the trait `Foo` was deriving from something like `Super<String>` or\n `Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n `get_a()` will definitely return an object of that type.\n \n-However, if it derives from `Super<Self>`, the method `get_a()` would return an\n-object of unknown type when called on the function, _even though `Super` is\n-object safe_. `Self` type parameters let us make object safe traits no longer\n-safe, so they are forbidden when specifying supertraits.\n+However, if it derives from `Super<Self>`, even though `Super` is object safe,\n+the method `get_a()` would return an object of unknown type when called on the\n+function. `Self` type parameters let us make object safe traits no longer safe,\n+so they are forbidden when specifying supertraits.\n \n There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n \"####,\n \n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an\n-integer literal and is therefore invalid.\n+representation. This error indicates that the value provided is not an integer\n+literal and is therefore invalid.\n \n For example, in the following code,\n \n@@ -708,18 +708,17 @@ enum Foo {\n \n we try to set the representation to a string.\n \n-There's no general fix for this; if you can work with an integer\n-then just set it to one:\n+There's no general fix for this; if you can work with an integer then just set\n+it to one:\n \n ```\n enum Foo {\n     Q = 32\n }\n ```\n \n-however if you actually wanted a mapping between variants\n-and non-integer objects, it may be preferable to use a method with\n-a match instead:\n+however if you actually wanted a mapping between variants and non-integer\n+objects, it may be preferable to use a method with a match instead:\n \n ```\n enum Foo { Q }\n@@ -1156,6 +1155,73 @@ It is advisable to find out what the unhandled cases are and check for them,\n returning an appropriate value or panicking if necessary.\n \"##,\n \n+E0270: r##\"\n+Rust lets you define functions which are known to never return, i.e. are\n+\"diverging\", by marking its return type as `!`.\n+\n+For example, the following functions never return:\n+\n+```\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+fn bar() -> ! {\n+    foo() // foo() is diverging, so this will diverge too\n+}\n+\n+fn baz() -> ! {\n+    panic!(); // this macro internally expands to a call to a diverging function\n+}\n+\n+```\n+\n+Such functions can be used in a place where a value is expected without\n+returning a value of that type,  for instance:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo() // diverging function called here\n+};\n+println!(\"{}\", y)\n+```\n+\n+If the third arm of the match block is reached, since `foo()` doesn't ever\n+return control to the match block, it is fine to use it in a place where an\n+integer was expected. The `match` block will never finish executing, and any\n+point where `y` (like the print statement) is needed will not be reached.\n+\n+However, if we had a diverging function that actually does finish execution\n+\n+```\n+fn foo() -> {\n+    loop {break;}\n+}\n+```\n+\n+then we would have an unknown value for `y` in the following code:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo()\n+};\n+println!(\"{}\", y);\n+```\n+\n+In the previous example, the print statement was never reached when the wildcard\n+match arm was hit, so we were okay with `foo()` not returning an integer that we\n+could set to `y`. But in this example, `foo()` actually does return control, so\n+the print statement will be executed with an uninitialized value.\n+\n+Obviously we cannot have functions which are allowed to be used in such\n+positions and yet can return control. So, if you are defining a function that\n+returns `!`, make sure that there is no way for it to actually finish executing.\n+\"##,\n+\n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n@@ -1292,6 +1358,11 @@ for v in &vs {\n ```\n \"##,\n \n+E0272: r##\"\n+\n+The `#[rustc_on_unimplemented]` attribute lets you specify\n+\"##,\n+\n E0277: r##\"\n You tried to use a type which doesn't implement some trait in a place which\n expected that trait. Erroneous code example:\n@@ -1716,7 +1787,6 @@ register_diagnostics! {\n //  E0134,\n //  E0135,\n     E0264, // unknown external lang item\n-    E0270, // computation may converge in a function marked as diverging\n     E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n     E0273, // rustc_on_unimplemented must have named format arguments\n     E0274, // rustc_on_unimplemented must have a value"}]}