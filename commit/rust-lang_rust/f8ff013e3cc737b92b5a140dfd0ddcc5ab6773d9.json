{"sha": "f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZmYwMTNlM2NjNzM3YjkyYjVhMTQwZGZkMGRkY2M1YWI2NzczZDk=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-08-28T01:26:36Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-08T01:41:07Z"}, "message": "Added a few utility classes, cleaned up the include order of .h files, and started to make the Rust kernel own domain message queues rather than the Rust domains themselves.", "tree": {"sha": "84daaf59d1eb899021e681927e1103cf08b91dd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84daaf59d1eb899021e681927e1103cf08b91dd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "html_url": "https://github.com/rust-lang/rust/commit/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffdb5fc8582c77eef7b3a30859eaa216872525a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffdb5fc8582c77eef7b3a30859eaa216872525a4", "html_url": "https://github.com/rust-lang/rust/commit/ffdb5fc8582c77eef7b3a30859eaa216872525a4"}], "stats": {"total": 361, "additions": 250, "deletions": 111}, "files": [{"sha": "f5aebfc42cdf6a1fc2e5b89a5fe9c047a72485cd", "filename": "src/Makefile", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -267,6 +267,7 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/rust_srv.cpp \\\n+              rt/rust_kernel.cpp \\\n               rt/memory_region.cpp\n \n RUNTIME_HDR := rt/globals.h \\\n@@ -283,11 +284,14 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/rust_message.h \\\n                rt/circular_buffer.h \\\n                rt/util/array_list.h \\\n+               rt/util/indexed_list.h \\\n+               rt/util/synchronized_indexed_list.h \\\n                rt/util/hash_map.h \\\n                rt/sync/sync.h \\\n                rt/sync/timer.h \\\n                rt/sync/lock_free_queue.h \\\n                rt/rust_srv.h \\\n+               rt/rust_kernel.h \\\n                rt/memory_region.h \\\n                rt/memory.h\n "}, {"sha": "43818de55140f378a554b1555dc1edc0914e1470", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -1,6 +1,5 @@\n #include \"rust_internal.h\"\n \n-\n struct\n command_line_args\n {\n@@ -80,6 +79,7 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc, char **argv)\n     {\n         rust_srv srv;\n         rust_dom dom(&srv, crate, \"main\");\n+        srv.kernel->register_domain(&dom);\n         command_line_args args(dom, argc, argv);\n \n         dom.log(rust_log::DOM, \"startup: %d args\", args.argc);\n@@ -99,6 +99,7 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc, char **argv)\n                              sizeof(main_args));\n \n         ret = dom.start_main_loop();\n+        srv.kernel->deregister_domain(&dom);\n     }\n \n #if !defined(__WIN32__)"}, {"sha": "66185727cffacfafef34f951498fbad819faa9e1", "filename": "src/rt/rust.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -17,10 +17,6 @@\n #define CDECL\n #endif\n \n-#include \"util/array_list.h\"\n-\n-#include \"rust_srv.h\"\n-\n /*\n  * Local Variables:\n  * fill-column: 78;"}, {"sha": "a1207ec738a2145be37d313d218e9214b74a62ed", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -4,9 +4,6 @@\n \n template class ptr_vec<rust_task>;\n \n-// Keeps track of all live domains, for debugging purposes.\n-array_list<rust_dom*> _live_domains;\n-\n rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate,\n                    const char *name) :\n     interrupt_flag(0),\n@@ -22,7 +19,8 @@ rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate,\n     caches(this),\n     root_task(NULL),\n     curr_task(NULL),\n-    rval(0)\n+    rval(0),\n+    _kernel(srv->kernel)\n {\n     logptr(\"new dom\", (uintptr_t)this);\n     isaac_init(this, &rctx);\n@@ -32,10 +30,6 @@ rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate,\n     pthread_attr_setdetachstate(&attr, true);\n #endif\n     root_task = new (this) rust_task(this, NULL, name);\n-\n-    if (_live_domains.replace(NULL, this) == false) {\n-        _live_domains.append(this);\n-    }\n }\n \n static void\n@@ -86,8 +80,6 @@ rust_dom::~rust_dom() {\n #endif\n     while (caches.length())\n         delete caches.pop();\n-\n-    _live_domains.replace(this, NULL);\n }\n \n void\n@@ -375,7 +367,7 @@ rust_dom::schedule_task() {\n  */\n bool\n rust_dom::is_deadlocked() {\n-    if (_live_domains.size() != 1) {\n+    if (_kernel->domains.length() != 1) {\n         // We cannot tell if we are deadlocked if other domains exists.\n         return false;\n     }\n@@ -388,20 +380,13 @@ rust_dom::is_deadlocked() {\n     if (_incoming_message_queue.is_empty() && blocked_tasks.length() > 0) {\n         // We have no messages to process, no running tasks to schedule\n         // and some blocked tasks therefore we are likely in a deadlock.\n-        log_state();\n+        _kernel->log_all_domain_state();\n         return true;\n     }\n \n     return false;\n }\n \n-void\n-rust_dom::log_all_state() {\n-    for (uint32_t i = 0; i < _live_domains.size(); i++) {\n-        _live_domains[i]->log_state();\n-    }\n-}\n-\n void\n rust_dom::log_state() {\n     if (!running_tasks.is_empty()) {"}, {"sha": "5c9c29533c40e5bdcf9578cec743a60a478dbd17", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -1,16 +1,6 @@\n-/*\n- * rust_dom.h\n- */\n-\n #ifndef RUST_DOM_H\n #define RUST_DOM_H\n \n-#include \"sync/lock_free_queue.h\"\n-#include \"util/hash_map.h\"\n-\n-#include \"rust_proxy.h\"\n-#include \"rust_message.h\"\n-\n struct rust_dom\n {\n     // Fields known to the compiler:\n@@ -37,6 +27,9 @@ struct rust_dom\n     rust_task *curr_task;\n     int rval;\n \n+    rust_kernel *_kernel;\n+    int32_t list_index;\n+\n     hash_map<rust_task *, rust_proxy<rust_task> *> _task_proxies;\n     hash_map<rust_port *, rust_proxy<rust_port> *> _port_proxies;\n "}, {"sha": "60d86f6116ceb082dce532bf10267574996f4b47", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 35, "deletions": 56, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -14,11 +14,8 @@\n \n #include <stdio.h>\n #include <string.h>\n-\n #include \"rust.h\"\n-\n #include \"rand.h\"\n-#include \"rust_log.h\"\n #include \"uthash.h\"\n \n #if defined(__WIN32__)\n@@ -39,9 +36,28 @@ extern \"C\" {\n #error \"Platform not supported.\"\n #endif\n \n+#include \"util/array_list.h\"\n+#include \"util/indexed_list.h\"\n+#include \"util/synchronized_indexed_list.h\"\n+#include \"util/hash_map.h\"\n #include \"sync/sync.h\"\n #include \"sync/timer.h\"\n #include \"sync/condition_variable.h\"\n+#include \"sync/lock_free_queue.h\"\n+\n+class rust_dom;\n+class rust_log;\n+class rust_task;\n+class rust_port;\n+class rust_chan;\n+struct rust_token;\n+class rust_kernel;\n+class rust_crate;\n+class rust_crate_cache;\n+\n+struct stk_seg;\n+struct type_desc;\n+struct frame_glue_fns;\n \n #ifndef __i386__\n #error \"Target CPU not supported.\"\n@@ -56,29 +72,13 @@ extern \"C\" {\n #define A(dom, e, s, ...) ((e) ? (void)0 : \\\n          (dom)->srv->fatal(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n \n-struct rust_task;\n-struct rust_port;\n-class rust_chan;\n-struct rust_token;\n-struct rust_dom;\n-class rust_crate;\n-class rust_crate_cache;\n-// class lockfree_queue;\n-\n-struct stk_seg;\n-struct type_desc;\n-struct frame_glue_fns;\n-\n // This drives our preemption scheme.\n \n static size_t const TIME_SLICE_IN_MS = 10;\n \n // Every reference counted object should derive from this base class.\n \n-template <typename T>\n-struct\n-rc_base\n-{\n+template <typename T> struct rc_base {\n     intptr_t ref_count;\n \n     void ref() {\n@@ -91,29 +91,25 @@ rc_base\n         }\n     }\n \n-  rc_base();\n-  ~rc_base();\n+    rc_base();\n+    ~rc_base();\n };\n \n-template <typename T>\n-struct\n-dom_owned\n-{\n+template <typename T> struct dom_owned {\n     rust_dom *get_dom() const {\n         return ((T*)this)->dom;\n     }\n+\n     void operator delete(void *ptr) {\n         ((T *)ptr)->dom->free(ptr);\n     }\n };\n \n-template <typename T>\n-struct\n-task_owned\n-{\n+template <typename T> struct task_owned {\n     rust_dom *get_dom() const {\n         return ((T *)this)->task->dom;\n     }\n+\n     void operator delete(void *ptr) {\n         ((T *)ptr)->task->dom->free(ptr);\n     }\n@@ -122,24 +118,16 @@ task_owned\n // A cond(ition) is something we can block on. This can be a channel\n // (writing), a port (reading) or a task (waiting).\n \n-struct\n-rust_cond\n-{\n-};\n+struct rust_cond { };\n \n // Helper class used regularly elsewhere.\n \n-template <typename T>\n-class\n-ptr_vec : public dom_owned<ptr_vec<T> >\n-{\n+template <typename T> class ptr_vec : public dom_owned<ptr_vec<T> > {\n     static const size_t INIT_SIZE = 8;\n-\n     rust_dom *dom;\n     size_t alloc;\n     size_t fill;\n     T **data;\n-\n public:\n     ptr_vec(rust_dom *dom);\n     ~ptr_vec();\n@@ -160,24 +148,16 @@ ptr_vec : public dom_owned<ptr_vec<T> >\n     void swap_delete(T* p);\n };\n \n+#include \"memory_region.h\"\n+#include \"rust_srv.h\"\n+#include \"rust_log.h\"\n+#include \"rust_proxy.h\"\n+#include \"rust_message.h\"\n+#include \"rust_kernel.h\"\n #include \"rust_dom.h\"\n-\n-template <typename T> inline T\n-check_null(rust_dom *dom, T value, char const *expr,\n-           char const *file, size_t line) {\n-    if (value == NULL) {\n-        dom->srv->fatal(expr, file, line, \"is null\");\n-    }\n-    return value;\n-}\n-\n-#define CHECK_NULL(dom, e) (check_null(dom, e, #e, __FILE__, __LINE__))\n-\n #include \"memory.h\"\n \n-struct\n-rust_timer\n-{\n+struct rust_timer {\n     // FIXME: This will probably eventually need replacement\n     // with something more sophisticated and integrated with\n     // an IO event-handling library, when we have such a thing.\n@@ -568,7 +548,6 @@ struct gc_alloc {\n };\n \n #include \"circular_buffer.h\"\n-#include \"rust_proxy.h\"\n #include \"rust_task.h\"\n #include \"rust_chan.h\"\n #include \"rust_port.h\""}, {"sha": "b82e46152fa1ef78f7453560d7756d07646b79c6", "filename": "src/rt/rust_kernel.cpp", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -0,0 +1,43 @@\n+#include \"rust_internal.h\"\n+\n+rust_kernel::rust_kernel(rust_srv *srv) :\n+    _region(srv->local_region),\n+    _log(srv, NULL),\n+    domains(srv->local_region),\n+    message_queues(srv->local_region) {\n+    // Nop.\n+}\n+\n+rust_kernel::~rust_kernel() {\n+    // Nop.\n+}\n+\n+void\n+rust_kernel::register_domain(rust_dom *dom) {\n+    domains.append(dom);\n+}\n+\n+void\n+rust_kernel::deregister_domain(rust_dom *dom) {\n+    domains.remove(dom);\n+}\n+\n+void\n+rust_kernel::log_all_domain_state() {\n+    log(rust_log::KERN, \"log_all_domain_state: %d domains\", domains.length());\n+    for (uint32_t i = 0; i < domains.length(); i++) {\n+        domains[i]->log_state();\n+    }\n+}\n+\n+void\n+rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n+    char buf[256];\n+    if (_log.is_tracing(type_bits)) {\n+        va_list args;\n+        va_start(args, fmt);\n+        vsnprintf(buf, sizeof(buf), fmt, args);\n+        _log.trace_ln(NULL, type_bits, buf);\n+        va_end(args);\n+    }\n+}"}, {"sha": "478d030c177f91258500d52d1141a8ce863f575f", "filename": "src/rt/rust_kernel.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -0,0 +1,21 @@\n+#ifndef RUST_KERNEL_H\n+#define RUST_KERNEL_H\n+\n+/**\n+ * A global object shared by all domains.\n+ */\n+class rust_kernel {\n+    memory_region &_region;\n+    rust_log _log;\n+public:\n+    synchronized_indexed_list<rust_dom> domains;\n+    synchronized_indexed_list<lock_free_queue<rust_message*> > message_queues;\n+    rust_kernel(rust_srv *srv);\n+    void register_domain(rust_dom *dom);\n+    void deregister_domain(rust_dom *dom);\n+    void log_all_domain_state();\n+    void log(uint32_t type_bits, char const *fmt, ...);\n+    virtual ~rust_kernel();\n+};\n+\n+#endif /* RUST_KERNEL_H */"}, {"sha": "fab5098d85a510f7009216d29308d807c8f69e5c", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -28,6 +28,7 @@ read_type_bit_mask() {\n         bits |= strstr(env_str, \"gc\") ? rust_log::GC : 0;\n         bits |= strstr(env_str, \"stdlib\") ? rust_log::STDLIB : 0;\n         bits |= strstr(env_str, \"special\") ? rust_log::SPECIAL : 0;\n+        bits |= strstr(env_str, \"kern\") ? rust_log::KERN : 0;\n         bits |= strstr(env_str, \"all\") ? rust_log::ALL : 0;\n         bits = strstr(env_str, \"none\") ? 0 : bits;\n     }\n@@ -150,7 +151,7 @@ rust_log::trace_ln(rust_task *task, char *message) {\n     uint32_t thread_id = hash((uint32_t) pthread_self());\n #endif\n     char prefix[1024] = \"\";\n-    if (_dom->name) {\n+    if (_dom && _dom->name) {\n         append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n                       thread_id, _dom->name);\n     } else {"}, {"sha": "66246eb60e49102493ed6478a866498b24038d1f", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -4,8 +4,6 @@\n class rust_dom;\n class rust_task;\n \n-\n-\n class rust_log {\n \n public:\n@@ -43,6 +41,7 @@ class rust_log {\n         GC = 0x800,\n         STDLIB = 0x1000,\n         SPECIAL = 0x2000,\n+        KERN = 0x4000,\n         ALL = 0xffffffff\n     };\n "}, {"sha": "d92235623de91fd193d7a38942ecd7d13b330731", "filename": "src/rt/rust_srv.cpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_srv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_srv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_srv.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -7,7 +7,8 @@\n \n rust_srv::rust_srv() :\n     local_region(this, false),\n-    synchronized_region(this, true) {\n+    synchronized_region(this, true),\n+    kernel(new rust_kernel(this)) {\n     // Nop.\n }\n \n@@ -73,8 +74,3 @@ rust_srv::warning(char const *expression,\n              expression, file, (int)line, buf);\n     log(msg);\n }\n-\n-rust_srv *\n-rust_srv::clone() {\n-    return new rust_srv();\n-}"}, {"sha": "ab646ae6a8f15667add38134eebb7c7079a81b22", "filename": "src/rt/rust_srv.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_srv.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_srv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_srv.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -1,17 +1,13 @@\n-/*\n- *\n- */\n-\n #ifndef RUST_SRV_H\n #define RUST_SRV_H\n \n-#include \"sync/spin_lock.h\"\n-#include \"memory_region.h\"\n+#include \"rust_internal.h\"\n \n class rust_srv {\n public:\n     memory_region local_region;\n     memory_region synchronized_region;\n+    rust_kernel *kernel;\n     virtual void log(char const *msg);\n     virtual void fatal(char const *expression,\n         char const *file,\n@@ -28,7 +24,6 @@ class rust_srv {\n     virtual void *realloc(void *, size_t);\n     rust_srv();\n     virtual ~rust_srv();\n-    virtual rust_srv *clone();\n };\n \n #endif /* RUST_SRV_H */"}, {"sha": "0e3961bc24ca55bd0fe69b3ad43d6ebae6e9af6d", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -567,11 +567,9 @@ static void *rust_thread_start(void *ptr)\n \n     // Start a new rust main loop for this thread.\n     dom->start_main_loop();\n-\n     rust_srv *srv = dom->srv;\n+    srv->kernel->deregister_domain(dom);\n     delete dom;\n-    delete srv;\n-\n     return 0;\n }\n \n@@ -611,10 +609,10 @@ upcall_new_thread(rust_task *task, const char *name) {\n     LOG_UPCALL_ENTRY(task);\n \n     rust_dom *old_dom = task->dom;\n-    rust_dom *new_dom = new rust_dom(old_dom->srv->clone(),\n+    rust_dom *new_dom = new rust_dom(old_dom->srv,\n                                      old_dom->root_crate,\n                                      name);\n-\n+    old_dom->srv->kernel->register_domain(new_dom);\n     task->log(rust_log::UPCALL | rust_log::MEM,\n               \"upcall new_thread(%s) = dom 0x%\" PRIxPTR \" task 0x%\" PRIxPTR,\n               name, new_dom, new_dom->root_task);"}, {"sha": "5ebc70f12fec1b70516e5c4a728cef04754ba234", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -98,6 +98,8 @@ class lock_free_queue {\n     }\n \n public:\n+    int32_t list_index;\n+\n     lock_free_queue() {\n         // We can only handle 64bit CAS for counted pointers, so this will\n         // not work with 64bit pointers."}, {"sha": "d869d43e3e236dd35b7c012f78062522d654e00c", "filename": "src/rt/util/indexed_list.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Futil%2Findexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Futil%2Findexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Findexed_list.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -0,0 +1,70 @@\n+#ifndef INDEXED_LIST_H\n+#define INDEXED_LIST_H\n+\n+#include <assert.h>\n+#include \"array_list.h\"\n+#include \"../memory_region.h\"\n+\n+class indexed_list_object {\n+public:\n+    int32_t list_index;\n+};\n+\n+/**\n+ * An array list of objects that are aware of their position in the list.\n+ * Normally, objects in this list should derive from the base class\n+ * \"indexed_list_object\" however because of nasty Rust compiler dependencies\n+ * on the layout of runtime objects we cannot always derive from this\n+ * base class, so instead we just enforce the informal protocol that any\n+ * object inserted in this list must define a \"int32_t list_index\" member.\n+ */\n+template<typename T> class indexed_list {\n+    memory_region &region;\n+    array_list<T*> list;\n+public:\n+    indexed_list(memory_region &region) : region(region) {}\n+    virtual int32_t append(T *value);\n+    virtual size_t length() {\n+        return list.size();\n+    }\n+    virtual bool is_empty() {\n+        return list.is_empty();\n+    }\n+    virtual int32_t remove(T* value);\n+    virtual T * operator[](int32_t index);\n+};\n+\n+template<typename T> int32_t\n+indexed_list<T>::append(T *value) {\n+    value->list_index = list.push(value);\n+    return value->list_index;\n+}\n+\n+/**\n+ * Swap delete the last object in the list with the specified object.\n+ */\n+template<typename T> int32_t\n+indexed_list<T>::remove(T *value) {\n+    assert (value->list_index >= 0);\n+    assert (value->list_index < (int32_t)list.size());\n+    int32_t removeIndex = value->list_index;\n+    T *last = list.pop();\n+    if (last->list_index == removeIndex) {\n+        last->list_index = -1;\n+        return removeIndex;\n+    } else {\n+        value->list_index = -1;\n+        list[removeIndex] = last;\n+        last->list_index = removeIndex;\n+        return removeIndex;\n+    }\n+}\n+\n+template <typename T> T *\n+indexed_list<T>::operator[](int32_t index) {\n+    T *value = list[index];\n+    assert(value->list_index == index);\n+    return value;\n+}\n+\n+#endif /* INDEXED_LIST_H */"}, {"sha": "ca02f6efdd2720e410e28221f94aed3fb8f60276", "filename": "src/rt/util/synchronized_indexed_list.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fsynchronized_indexed_list.h?ref=f8ff013e3cc737b92b5a140dfd0ddcc5ab6773d9", "patch": "@@ -0,0 +1,56 @@\n+#ifndef SYNCHRONIZED_INDEXED_LIST_H\n+#define SYNCHRONIZED_INDEXED_LIST_H\n+\n+#include \"indexed_list.h\"\n+\n+template<typename T> class synchronized_indexed_list :\n+    public indexed_list<T> {\n+    spin_lock _lock;\n+public:\n+    synchronized_indexed_list(memory_region &region) :\n+        indexed_list<T>(region) {\n+        // Nop.\n+    }\n+\n+    int32_t append(T *value) {\n+        int32_t index = 0;\n+        _lock.lock();\n+        index = indexed_list<T>::append(value);\n+        _lock.unlock();\n+        return index;\n+    }\n+\n+    size_t length() {\n+       size_t length = 0;\n+       _lock.lock();\n+       length = indexed_list<T>::length();\n+       _lock.unlock();\n+       return length;\n+    }\n+\n+    bool is_empty() {\n+        bool empty = false;\n+        _lock.lock();\n+        empty = indexed_list<T>::is_empty();\n+        _lock.unlock();\n+        return empty;\n+    }\n+\n+    int32_t remove(T* value) {\n+        size_t index = 0;\n+        _lock.lock();\n+        index = indexed_list<T>::remove(value);\n+        _lock.unlock();\n+        return index;\n+    }\n+\n+    T *operator[](size_t index) {\n+        T *value = NULL;\n+        _lock.lock();\n+        value = indexed_list<T>::operator[](index);\n+        _lock.unlock();\n+        return value;\n+    }\n+};\n+\n+#endif /* SYNCHRONIZED_INDEXED_LIST_H */"}]}