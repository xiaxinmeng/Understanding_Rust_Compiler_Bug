{"sha": "e30fb6a26f1ac406a346cbf79b41c92e84703a28", "node_id": "C_kwDOAAsO6NoAKGUzMGZiNmEyNmYxYWM0MDZhMzQ2Y2JmNzliNDFjOTJlODQ3MDNhMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-06T05:26:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-06T05:26:09Z"}, "message": "Auto merge of #102618 - aliemjay:simplify-closure-promote, r=compiler-errors\n\nrework applying closure requirements in borrowck\n\nPreviously the promoted closure constraints were registered under the category `ConstraintCategory::ClosureBounds` in `type_check::prove_closure_bounds()` and then mapped back their original category in `regions_infer::best_blame_constraint` using the complicated map `closure_bounds_mapping`.\n\nNow we're registering promoted constraints under their original category and span earlier in `type_check::prove_closure_bounds`.\n\nSee commit messages.\n\nFixes #99245", "tree": {"sha": "15810938d057970d6a45a82707f0c71b57fdecbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15810938d057970d6a45a82707f0c71b57fdecbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e30fb6a26f1ac406a346cbf79b41c92e84703a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e30fb6a26f1ac406a346cbf79b41c92e84703a28", "html_url": "https://github.com/rust-lang/rust/commit/e30fb6a26f1ac406a346cbf79b41c92e84703a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e30fb6a26f1ac406a346cbf79b41c92e84703a28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4ab2e064306c2c3e5b1d2efe1d5c0e1a6e0346a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ab2e064306c2c3e5b1d2efe1d5c0e1a6e0346a", "html_url": "https://github.com/rust-lang/rust/commit/a4ab2e064306c2c3e5b1d2efe1d5c0e1a6e0346a"}, {"sha": "02f78fdb940b913228953b7530c9e429ce35bb8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/02f78fdb940b913228953b7530c9e429ce35bb8a", "html_url": "https://github.com/rust-lang/rust/commit/02f78fdb940b913228953b7530c9e429ce35bb8a"}], "stats": {"total": 522, "additions": 173, "deletions": 349}, "files": [{"sha": "385f153174c3c2a9170b7b41957d67682efe0e17", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -163,6 +163,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n                 span: DUMMY_SP,\n                 category: ConstraintCategory::Internal,\n                 variance_info: VarianceDiagInfo::default(),\n+                from_closure: false,\n             })\n         } else {\n             None"}, {"sha": "9d9c4abb0aa57c460961d9dca8b8478dafbd9f0c", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -96,6 +96,9 @@ pub struct OutlivesConstraint<'tcx> {\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,\n+\n+    /// If this constraint is promoted from closure requirements.\n+    pub from_closure: bool,\n }\n \n impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {"}, {"sha": "196ddbe8d5046696ad2e1756d1a89acc3dda9598", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     // Try to convert the lower-bound region into something named we can print for the user.\n                     let lower_bound_region = self.to_error_region(type_test.lower_bound);\n \n-                    let type_test_span = type_test.locations.span(&self.body);\n+                    let type_test_span = type_test.span;\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);"}, {"sha": "4e0205f8d43a14616d40ebb23361979b907bbd8f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -242,7 +242,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         mut liveness_constraints,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n     } = constraints;\n@@ -264,7 +263,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n         liveness_constraints,"}, {"sha": "cc9450999525a9550be1ebdc942ec12270cdc0cd", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -74,8 +74,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort_by_key(|c| (c.sup, c.sub));\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category, span, variance_info: _ } =\n-                constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, span, .. } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "94e9e05e5d640936be66ffb5bec23018b3d0a82f", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 145, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -6,10 +6,9 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n@@ -19,9 +18,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::{\n-    self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_span::Span;\n \n use crate::{\n@@ -89,10 +86,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// `member_region_scc`.\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n-    /// Map closure bounds to a `Span` that should be used for error reporting.\n-    closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -221,8 +214,8 @@ pub struct TypeTest<'tcx> {\n     /// The region `'x` that the type must outlive.\n     pub lower_bound: RegionVid,\n \n-    /// Where did this constraint arise and why?\n-    pub locations: Locations,\n+    /// The span to blame.\n+    pub span: Span,\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n@@ -265,10 +258,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        closure_bounds_mapping: FxHashMap<\n-            Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n-        >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n@@ -310,7 +299,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n-            closure_bounds_mapping,\n             universe_causes,\n             scc_universes,\n             scc_representatives,\n@@ -882,13 +870,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if deduplicate_errors.insert((\n                 erased_generic_kind,\n                 type_test.lower_bound,\n-                type_test.locations,\n+                type_test.span,\n             )) {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n-                     type_test.locations={:?}\",\n-                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n+                     type_test.span={:?}\",\n+                    erased_generic_kind, type_test.lower_bound, type_test.span,\n                 );\n \n                 errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n@@ -931,7 +919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n+        let TypeTest { generic_kind, lower_bound, span: _, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let Some(subject) = self.try_promote_type_test_subject(infcx, generic_ty) else {\n@@ -959,7 +947,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                 subject,\n                 outlived_free_region: static_r,\n-                blame_span: locations.span(body),\n+                blame_span: type_test.span,\n                 category: ConstraintCategory::Boring,\n             });\n \n@@ -1011,7 +999,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let requirement = ClosureOutlivesRequirement {\n                     subject,\n                     outlived_free_region: upper_bound,\n-                    blame_span: locations.span(body),\n+                    blame_span: type_test.span,\n                     category: ConstraintCategory::Boring,\n                 };\n                 debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n@@ -1804,18 +1792,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn retrieve_closure_constraint_info(\n-        &self,\n-        constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n-        match constraint.locations {\n-            Locations::All(_) => None,\n-            Locations::Single(loc) => {\n-                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n-            }\n-        }\n-    }\n-\n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n@@ -1921,6 +1897,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span: p_c.definition_span,\n                     category: ConstraintCategory::OpaqueType,\n                     variance_info: ty::VarianceDiagInfo::default(),\n+                    from_closure: false,\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -2066,31 +2043,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n-            .map(|constraint| {\n-                let (category, span, from_closure, cause_code) =\n-                    if constraint.category == ConstraintCategory::ClosureBounds {\n-                        if let Some((category, span)) =\n-                            self.retrieve_closure_constraint_info(*constraint)\n-                        {\n-                            (category, span, true, ObligationCauseCode::MiscObligation)\n-                        } else {\n-                            (\n-                                constraint.category,\n-                                constraint.span,\n-                                false,\n-                                ObligationCauseCode::MiscObligation,\n-                            )\n-                        }\n-                    } else {\n-                        (constraint.category, constraint.span, false, cause_code.clone())\n-                    };\n-                BlameConstraint {\n-                    category,\n-                    from_closure,\n-                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n-                    variance_info: constraint.variance_info,\n-                    outlives_constraint: *constraint,\n-                }\n+            .map(|constraint| BlameConstraint {\n+                category: constraint.category,\n+                from_closure: constraint.from_closure,\n+                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                variance_info: constraint.variance_info,\n+                outlives_constraint: *constraint,\n             })\n             .collect();\n         debug!(\"categorized_path={:#?}\", categorized_path);\n@@ -2274,92 +2232,6 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'tcx> {\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n-}\n-\n-impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n-    /// Given an instance T of the closure type, this method\n-    /// instantiates the \"extra\" requirements that we computed for the\n-    /// closure into the inference context. This has the effect of\n-    /// adding new outlives obligations to existing variables.\n-    ///\n-    /// As described on `ClosureRegionRequirements`, the extra\n-    /// requirements are expressed in terms of regionvids that index\n-    /// into the free regions that appear on the closure type. So, to\n-    /// do this, we first copy those regions out from the type T into\n-    /// a vector. Then we can just index into that vector to extract\n-    /// out the corresponding region from T and apply the\n-    /// requirements.\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n-        debug!(\n-            \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n-            closure_def_id, closure_substs\n-        );\n-\n-        // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n-        // relating to one another.\n-        let closure_mapping = &UniversalRegions::closure_mapping(\n-            tcx,\n-            closure_substs,\n-            self.num_external_vids,\n-            closure_def_id.expect_local(),\n-        );\n-        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n-\n-        // Create the predicates.\n-        self.outlives_requirements\n-            .iter()\n-            .map(|outlives_requirement| {\n-                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-                match outlives_requirement.subject {\n-                    ClosureOutlivesSubject::Region(region) => {\n-                        let region = closure_mapping[region];\n-                        debug!(\n-                            \"apply_requirements: region={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            region, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(\n-                                region.into(),\n-                                outlived_region,\n-                            )),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-\n-                    ClosureOutlivesSubject::Ty(ty) => {\n-                        debug!(\n-                            \"apply_requirements: ty={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            ty, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n     pub category: ConstraintCategory<'tcx>,"}, {"sha": "ce7f857e27310aa64b01f6d2529c08cd96ff00de", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -1,10 +1,10 @@\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, ConstraintCategory};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -38,6 +38,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     locations: Locations,\n     span: Span,\n     category: ConstraintCategory<'tcx>,\n+    from_closure: bool,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -64,6 +65,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             span,\n             category,\n             constraints,\n+            from_closure: false,\n         }\n     }\n \n@@ -81,30 +83,70 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for query_constraint in outlives {\n-            self.convert(query_constraint);\n+        for (predicate, constraint_category) in outlives {\n+            // At the moment, we never generate any \"higher-ranked\"\n+            // region constraints like `for<'a> 'a: 'b`. At some point\n+            // when we move to universes, we will, and this assertion\n+            // will start to fail.\n+            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n+            });\n+\n+            self.convert(predicate, *constraint_category);\n         }\n     }\n \n-    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    /// Given an instance of the closure type, this method instantiates the \"extra\" requirements\n+    /// that we computed for the closure. This has the effect of adding new outlives obligations\n+    /// to existing region variables in `closure_substs`.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn apply_closure_requirements(\n+        &mut self,\n+        closure_requirements: &ClosureRegionRequirements<'tcx>,\n+        closure_def_id: DefId,\n+        closure_substs: ty::SubstsRef<'tcx>,\n+    ) {\n+        // Extract the values of the free regions in `closure_substs`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping = &UniversalRegions::closure_mapping(\n+            self.tcx,\n+            closure_substs,\n+            closure_requirements.num_external_vids,\n+            closure_def_id.expect_local(),\n+        );\n+        debug!(?closure_mapping);\n+\n+        // Create the predicates.\n+        let backup = (self.category, self.span, self.from_closure);\n+        self.from_closure = true;\n+        for outlives_requirement in &closure_requirements.outlives_requirements {\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            let subject = match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n+                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+            };\n+\n+            self.category = outlives_requirement.category;\n+            self.span = outlives_requirement.blame_span;\n+            self.convert(ty::OutlivesPredicate(subject, outlived_region), self.category);\n+        }\n+        (self.category, self.span, self.from_closure) = backup;\n+    }\n+\n+    fn convert(\n+        &mut self,\n+        predicate: ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>,\n+        constraint_category: ConstraintCategory<'tcx>,\n+    ) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n         let ConstraintConversion {\n             tcx, region_bound_pairs, implicit_region_bound, param_env, ..\n         } = *self;\n \n-        // At the moment, we never generate any \"higher-ranked\"\n-        // region constraints like `for<'a> 'a: 'b`. At some point\n-        // when we move to universes, we will, and this assertion\n-        // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-            });\n-\n-        let constraint_category = query_constraint.1;\n-\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n@@ -127,10 +169,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n-            GenericArgKind::Const(_) => {\n-                // Consts cannot outlive one another, so we\n-                // don't need to handle any relations here.\n-            }\n+            GenericArgKind::Const(_) => unreachable!(),\n         }\n     }\n \n@@ -160,7 +199,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n-        TypeTest { generic_kind, lower_bound, locations: self.locations, verify_bound }\n+        TypeTest { generic_kind, lower_bound, span: self.span, verify_bound }\n     }\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n@@ -188,6 +227,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             sub,\n             sup,\n             variance_info: ty::VarianceDiagInfo::default(),\n+            from_closure: self.from_closure,\n         });\n     }\n "}, {"sha": "50af229baaaedf297abc0ab836c3a655b6fbdb7c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 18, "deletions": 87, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n+use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n@@ -61,7 +61,7 @@ use crate::{\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n-    region_infer::{ClosureRegionRequirementsExt, TypeTest},\n+    region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n     Upvar,\n@@ -144,7 +144,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n-        closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n         universe_causes: FxHashMap::default(),\n     };\n@@ -584,8 +583,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n-        let mut type_tests = Default::default();\n-        let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n         // Don't try to add borrow_region facts for the promoted MIR\n@@ -596,11 +593,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n                 &mut constraints,\n             );\n-            mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n-            mem::swap(\n-                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n-                &mut closure_bounds,\n-            );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.liveness_constraints,\n                 &mut liveness_constraints,\n@@ -621,13 +613,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         swap_constraints(self);\n \n         let locations = location.to_locations();\n-\n-        // Use location of promoted const in collected constraints\n-        for type_test in type_tests.iter() {\n-            let mut type_test = type_test.clone();\n-            type_test.locations = locations;\n-            self.cx.borrowck_context.constraints.type_tests.push(type_test)\n-        }\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = constraint.clone();\n             constraint.locations = locations;\n@@ -653,18 +638,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     .add_element(region, location);\n             }\n         }\n-\n-        if !closure_bounds.is_empty() {\n-            let combined_bounds_mapping =\n-                closure_bounds.into_iter().flat_map(|(_, value)| value).collect();\n-            let existing = self\n-                .cx\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, combined_bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple promoteds/closures at the same location.\");\n-        }\n     }\n \n     fn sanitize_projection(\n@@ -941,9 +914,6 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n@@ -2562,6 +2532,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 span: location.to_locations().span(body),\n                                 category,\n                                 variance_info: ty::VarianceDiagInfo::default(),\n+                                from_closure: false,\n                             });\n \n                             match mutbl {\n@@ -2679,62 +2650,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = QueryRegionConstraints {\n-                outlives: closure_region_requirements.apply_requirements(\n-                    tcx,\n-                    def_id.to_def_id(),\n-                    substs,\n-                ),\n-\n-                // Presently, closures never propagate member\n-                // constraints to their parents -- they are enforced\n-                // locally.  This is largely a non-issue as member\n-                // constraints only come from `-> impl Trait` and\n-                // friends which don't appear (thus far...) in\n-                // closures.\n-                member_constraints: vec![],\n-            };\n-\n-            let bounds_mapping = closure_constraints\n-                .outlives\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(idx, constraint)| {\n-                    let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                        });\n-\n-                    match k1.unpack() {\n-                        GenericArgKind::Lifetime(r1) => {\n-                            // constraint is r1: r2\n-                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n-                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n-                            let outlives_requirements =\n-                                &closure_region_requirements.outlives_requirements[idx];\n-                            Some((\n-                                (r1_vid, r2_vid),\n-                                (outlives_requirements.category, outlives_requirements.blame_span),\n-                            ))\n-                        }\n-                        GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                    }\n-                })\n-                .collect();\n-\n-            let existing = self\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple closures at the same location.\");\n-\n-            self.push_region_constraints(\n+        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx,\n+                self.borrowck_context.universal_regions,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n                 location.to_locations(),\n-                ConstraintCategory::ClosureBounds,\n-                &closure_constraints,\n+                DUMMY_SP,                   // irrelevant; will be overrided.\n+                ConstraintCategory::Boring, // same as above.\n+                &mut self.borrowck_context.constraints,\n+            )\n+            .apply_closure_requirements(\n+                &closure_requirements,\n+                def_id.to_def_id(),\n+                substs,\n             );\n         }\n "}, {"sha": "94d51032866098954d19b99b974014e9b6189625", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -136,6 +136,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 span: self.locations.span(self.type_checker.body),\n                 category: self.category,\n                 variance_info: info,\n+                from_closure: false,\n             },\n         );\n     }"}, {"sha": "3ed90aed2350d4d8003b4b89440ad63973dc1540", "filename": "src/test/ui/consts/issue-102117.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -14,11 +14,11 @@ pub struct VTable {\n impl VTable {\n     pub fn new<T>() -> &'static Self {\n         const {\n-          //~^ ERROR the parameter type `T` may not live long enough\n-          //~| ERROR the parameter type `T` may not live long enough\n             &VTable {\n                 layout: Layout::new::<T>(),\n                 type_id: TypeId::of::<T>(),\n+                //~^ ERROR the parameter type `T` may not live long enough\n+                //~| ERROR the parameter type `T` may not live long enough\n                 drop_in_place: unsafe {\n                     transmute::<unsafe fn(*mut T), unsafe fn(*mut ())>(drop_in_place::<T>)\n                 },"}, {"sha": "f42bcf90fb756b684a696abcca579c076e44e8f6", "filename": "src/test/ui/consts/issue-102117.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -1,31 +1,19 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-102117.rs:16:9\n+  --> $DIR/issue-102117.rs:19:26\n    |\n-LL | /         const {\n-LL | |\n-LL | |\n-LL | |             &VTable {\n-...  |\n-LL | |             }\n-LL | |         }\n-   | |_________^ ...so that the type `T` will meet its required lifetime bounds\n+LL |                 type_id: TypeId::of::<T>(),\n+   |                          ^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |\n LL |     pub fn new<T: 'static>() -> &'static Self {\n    |                 +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-102117.rs:16:9\n+  --> $DIR/issue-102117.rs:19:26\n    |\n-LL | /         const {\n-LL | |\n-LL | |\n-LL | |             &VTable {\n-...  |\n-LL | |             }\n-LL | |         }\n-   | |_________^ ...so that the type `T` will meet its required lifetime bounds\n+LL |                 type_id: TypeId::of::<T>(),\n+   |                          ^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "e321da53d5668bd61237ae89c268518b023ef549", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -21,6 +21,7 @@ fn foo<T>() {\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` may not live long enough\n+    //~| ERROR `T` may not live long enough\n     //\n     // FIXME: This error is bogus, but it arises because we try to validate\n     // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving"}, {"sha": "5485570cecd76eb0d1c245163c250b07ad3729fa", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -22,6 +22,17 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-91139.rs:14:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'static>() {\n+   |         +++++++++\n+\n error: `T` does not live long enough\n   --> $DIR/issue-91139.rs:14:58\n    |\n@@ -57,6 +68,6 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |                                                          ^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0310`."}, {"sha": "cda781d8e263797618aeb54741b0a17188ac1ae4", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -30,8 +30,6 @@ where\n     T: Trait<'a>,\n {\n     establish_relationships(value, |value| {\n-        //~^ ERROR the parameter type `T` may not live long enough\n-\n         // This function call requires that\n         //\n         // (a) T: Trait<'a>\n@@ -43,6 +41,7 @@ where\n         // The latter does not hold.\n \n         require(value);\n+        //~^ ERROR the parameter type `T` may not live long enough\n     });\n }\n "}, {"sha": "038a5e11f88ce7205027cd009984d57bbe7d4b97", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -23,17 +23,10 @@ LL | |     T: Trait<'a>,\n    = note: defining type: supply::<'_#1r, T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/propagate-from-trait-match.rs:32:36\n+  --> $DIR/propagate-from-trait-match.rs:43:9\n    |\n-LL |       establish_relationships(value, |value| {\n-   |  ____________________________________^\n-LL | |\n-LL | |\n-LL | |         // This function call requires that\n-...  |\n-LL | |         require(value);\n-LL | |     });\n-   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+LL |         require(value);\n+   |         ^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "d8b26f0b0171ed54e0db51d9d006422c387b8d3b", "filename": "src/test/ui/nll/issue-98589-closures-relate-named-regions.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98589-closures-relate-named-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98589-closures-relate-named-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98589-closures-relate-named-regions.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -35,21 +35,21 @@ LL |     || { None::<&'a &'b ()>; };\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-98589-closures-relate-named-regions.rs:26:5\n+  --> $DIR/issue-98589-closures-relate-named-regions.rs:26:10\n    |\n LL |     || { None::<&'a T>; };\n-   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |          ^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |\n LL | fn test_early_type<'a: 'a, T: 'a>() {\n    |                             ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-98589-closures-relate-named-regions.rs:32:5\n+  --> $DIR/issue-98589-closures-relate-named-regions.rs:32:10\n    |\n LL |     || { None::<&'a T>; };\n-   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |          ^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "7a325e2e998f36ce1161dfab0ba8fc80ffbfb4d3", "filename": "src/test/ui/nll/issue-98693.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -13,8 +13,8 @@ where\n \n fn test<T>() {\n     || {\n-        //~^ ERROR the parameter type `T` may not live long enough\n         assert_static::<T>();\n+        //~^ ERROR the parameter type `T` may not live long enough\n     };\n }\n "}, {"sha": "15ca38aa25dce03c871d4aac4a596ff7b6f88f34", "filename": "src/test/ui/nll/issue-98693.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -1,11 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-98693.rs:15:5\n+  --> $DIR/issue-98693.rs:16:9\n    |\n-LL | /     || {\n-LL | |\n-LL | |         assert_static::<T>();\n-LL | |     };\n-   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+LL |         assert_static::<T>();\n+   |         ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "d949e29b2b812a6f48b3ff3baa04ca47b887cc8b", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-implied-bounds.rs:30:18\n+  --> $DIR/projection-implied-bounds.rs:30:36\n    |\n LL |     twice(value, |value_ref, item| invoke2(value_ref, item));\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "4933b93486831bca0718ff8ed462004aff97cc40", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -23,10 +23,10 @@ LL | |     T: Iterator,\n    = note: defining type: no_region::<'_#1r, T>\n \n error[E0309]: the associated type `<T as Iterator>::Item` may not live long enough\n-  --> $DIR/projection-no-regions-closure.rs:25:23\n+  --> $DIR/projection-no-regions-closure.rs:25:31\n    |\n LL |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iterator>::Item: 'a`...\n    = note: ...so that the type `<T as Iterator>::Item` will meet its required lifetime bounds\n@@ -80,10 +80,10 @@ LL | |     T: 'b + Iterator,\n    = note: defining type: wrong_region::<'_#1r, '_#2r, T>\n \n error[E0309]: the associated type `<T as Iterator>::Item` may not live long enough\n-  --> $DIR/projection-no-regions-closure.rs:42:23\n+  --> $DIR/projection-no-regions-closure.rs:42:31\n    |\n LL |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iterator>::Item: 'a`...\n    = note: ...so that the type `<T as Iterator>::Item` will meet its required lifetime bounds"}, {"sha": "dbda04c42c5c76753695d88cfa113878f62f9e2d", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -25,10 +25,10 @@ LL | |     T: Anything<'b>,\n    = note: defining type: no_relationships_late::<'_#1r, T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:45:29\n+  --> $DIR/projection-one-region-closure.rs:45:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                                       ^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |\n@@ -75,10 +75,10 @@ LL | |     'a: 'a,\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:56:29\n+  --> $DIR/projection-one-region-closure.rs:56:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                                       ^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "90f04914286c15f511b38bfecf9eefcfe90d8b16", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -24,10 +24,10 @@ LL | |     T: Anything<'b, 'c>,\n    = note: defining type: no_relationships_late::<'_#1r, '_#2r, T>\n \n error[E0309]: the associated type `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:38:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:38:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                       ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType: 'a`...\n    = note: ...so that the type `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType` will meet its required lifetime bounds\n@@ -58,10 +58,10 @@ LL | |     'a: 'a,\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, '_#3r, T>\n \n error[E0309]: the associated type `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:48:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                       ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: 'a`...\n    = note: ...so that the type `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType` will meet its required lifetime bounds\n@@ -167,17 +167,20 @@ LL | |     T: Anything<'b, 'b>,\n    = note: defining type: two_regions::<'_#1r, T>\n \n error: lifetime may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:87:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:87:5\n    |\n LL | fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of the type `Cell<&'_#8r ()>`, which makes the generic argument `&'_#8r ()` invariant\n+   = note: the struct `Cell<T>` is invariant over the parameter `T`\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:97:29"}, {"sha": "f316a551cffa69543a0d779222a8b56f23cae16d", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -44,10 +44,10 @@ LL | fn generic_fail<'a, T>(cell: Cell<&'a ()>, value: T) {\n    = note: defining type: generic_fail::<T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-approximate-lower-bound.rs:29:24\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:29:31\n    |\n LL |     twice(cell, value, |a, b| invoke(a, b));\n-   |                        ^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                               ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "35979c8bf5171304a0b0dc61299e45b2e087bf4c", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -23,10 +23,10 @@ LL | |     T: Debug,\n    = note: defining type: no_region::<'_#1r, T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:23\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:27\n    |\n LL |     with_signature(x, |y| y)\n-   |                       ^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                           ^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |"}, {"sha": "b8028761050414c50f5ab74599b48403b9028aae", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -25,13 +25,12 @@ where\n #[rustc_regions]\n fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n     with_signature(a, b, |x, y| {\n-        //~^ ERROR the parameter type `T` may not live long enough\n-        //\n         // See `correct_region`, which explains the point of this\n         // test.  The only difference is that, in the case of this\n         // function, there is no where clause *anywhere*, and hence we\n         // get an error (but reported by the closure creator).\n         require(&x, &y)\n+        //~^ ERROR the parameter type `T` may not live long enough\n     })\n }\n \n@@ -62,9 +61,9 @@ where\n     T: 'b,\n {\n     with_signature(a, b, |x, y| {\n-        //~^ ERROR the parameter type `T` may not live long enough\n         // See `correct_region`\n         require(&x, &y)\n+        //~^ ERROR the parameter type `T` may not live long enough\n     })\n }\n "}, {"sha": "4c97db58c6c3db9c9828b700f309f68514855d52", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e30fb6a26f1ac406a346cbf79b41c92e84703a28/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=e30fb6a26f1ac406a346cbf79b41c92e84703a28", "patch": "@@ -22,25 +22,18 @@ LL | fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n    = note: defining type: no_region::<T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:27:26\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:32:9\n    |\n-LL |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-LL | |\n-LL | |         //\n-LL | |         // See `correct_region`, which explains the point of this\n-...  |\n-LL | |         require(&x, &y)\n-LL | |     })\n-   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+LL |         require(&x, &y)\n+   |         ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |\n LL | fn no_region<'a, T: 'a>(a: Cell<&'a ()>, b: T) {\n    |                   ++++\n \n note: external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:43:26\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:42:26\n    |\n LL |     with_signature(a, b, |x, y| {\n    |                          ^^^^^^\n@@ -54,7 +47,7 @@ LL |     with_signature(a, b, |x, y| {\n    = note: where T: '_#2r\n \n note: no external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:39:1\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:1\n    |\n LL | / fn correct_region<'a, T>(a: Cell<&'a ()>, b: T)\n LL | | where\n@@ -64,7 +57,7 @@ LL | |     T: 'a,\n    = note: defining type: correct_region::<'_#1r, T>\n \n note: external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:64:26\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:63:26\n    |\n LL |     with_signature(a, b, |x, y| {\n    |                          ^^^^^^\n@@ -79,7 +72,7 @@ LL |     with_signature(a, b, |x, y| {\n    = note: where T: '_#2r\n \n note: no external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:60:1\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:59:1\n    |\n LL | / fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n LL | | where\n@@ -89,23 +82,18 @@ LL | |     T: 'b,\n    = note: defining type: wrong_region::<'_#1r, T>\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:64:26\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:65:9\n    |\n-LL |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-LL | |\n-LL | |         // See `correct_region`\n-LL | |         require(&x, &y)\n-LL | |     })\n-   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+LL |         require(&x, &y)\n+   |         ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n help: consider adding an explicit lifetime bound...\n    |\n LL |     T: 'b + 'a,\n    |           ++++\n \n note: external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:77:26\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n    |\n LL |     with_signature(a, b, |x, y| {\n    |                          ^^^^^^\n@@ -119,7 +107,7 @@ LL |     with_signature(a, b, |x, y| {\n    = note: where T: '_#3r\n \n note: no external requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:72:1\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:71:1\n    |\n LL | / fn outlives_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n LL | | where"}]}