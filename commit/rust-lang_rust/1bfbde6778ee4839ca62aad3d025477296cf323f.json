{"sha": "1bfbde6778ee4839ca62aad3d025477296cf323f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZmJkZTY3NzhlZTQ4MzljYTYyYWFkM2QwMjU0NzcyOTZjZjMyM2Y=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-07-16T18:59:23Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:37Z"}, "message": "Add comparison and shuffle SIMD intrinsics.\n\n- simd_eq, simd_ne, simd_lt, simd_le, simd_gt, simd_ge\n- simd_shuffleNNN", "tree": {"sha": "eaa1ba1437f0eb4ea5f92d78e1e5479b4254f40f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaa1ba1437f0eb4ea5f92d78e1e5479b4254f40f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bfbde6778ee4839ca62aad3d025477296cf323f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfbde6778ee4839ca62aad3d025477296cf323f", "html_url": "https://github.com/rust-lang/rust/commit/1bfbde6778ee4839ca62aad3d025477296cf323f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bfbde6778ee4839ca62aad3d025477296cf323f/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4425840dac441e1050319893882177d040c4f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4425840dac441e1050319893882177d040c4f3", "html_url": "https://github.com/rust-lang/rust/commit/4f4425840dac441e1050319893882177d040c4f3"}], "stats": {"total": 175, "additions": 163, "deletions": 12}, "files": [{"sha": "c6944e7b75659a5e90362d9c74f22862cc391e48", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=1bfbde6778ee4839ca62aad3d025477296cf323f", "patch": "@@ -348,17 +348,14 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n                                       t: Ty<'tcx>,\n+                                      ret_ty: Type,\n                                       op: ast::BinOp_,\n                                       debug_loc: DebugLoc)\n                                       -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n-            // The comparison operators for floating point vectors are challenging.\n-            // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n-            // then bitcast to a floating point vector, the result will be `-NaN`\n-            // for each truth value. Because of this they are unsupported.\n-            bcx.sess().bug(\"compare_simd_types: comparison operators \\\n-                            not supported for floating point SIMD types\")\n+            let cmp = bin_op_to_fcmp_predicate(bcx.ccx(), op);\n+            return SExt(bcx, FCmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n@@ -370,7 +367,7 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), val_ty(lhs))\n+    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty)\n }\n \n // Iterates through the elements of a structural type."}, {"sha": "9ba45e0d481a3e04315a496603b028e1877343b4", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=1bfbde6778ee4839ca62aad3d025477296cf323f", "patch": "@@ -1797,7 +1797,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if is_simd {\n-            base::compare_simd_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n+            base::compare_simd_types(bcx, lhs, rhs, intype, val_ty(lhs), op.node, binop_debug_loc)\n         } else {\n             base::compare_scalar_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         }"}, {"sha": "489c54dc6e2d262fdd939e0b5e7807d3d189378b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=1bfbde6778ee4839ca62aad3d025477296cf323f", "patch": "@@ -800,7 +800,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 _ => C_null(llret_ty)\n             }\n         }\n-\n+        (_, name) if name.starts_with(\"simd_\") => {\n+            generic_simd_intrinsic(bcx, name,\n+                                   substs,\n+                                   callee_ty,\n+                                   &llargs,\n+                                   ret_ty, llret_ty,\n+                                   call_debug_location,\n+                                   call_info)\n+        }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {\n@@ -1263,3 +1271,125 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n     return rust_try\n }\n+\n+fn generic_simd_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      name: &str,\n+                                      _substs: subst::Substs<'tcx>,\n+                                      callee_ty: Ty<'tcx>,\n+                                      llargs: &[ValueRef],\n+                                      ret_ty: Ty<'tcx>,\n+                                      llret_ty: Type,\n+                                      call_debug_location: DebugLoc,\n+                                      call_info: NodeIdAndSpan) -> ValueRef {\n+    let tcx = bcx.tcx();\n+    let arg_tys = match callee_ty.sty {\n+        ty::TyBareFn(_, ref f) => {\n+            bcx.tcx().erase_late_bound_regions(&f.sig.inputs())\n+        }\n+        _ => unreachable!()\n+    };\n+\n+    let comparison = match name {\n+        \"simd_eq\" => Some(ast::BiEq),\n+        \"simd_ne\" => Some(ast::BiNe),\n+        \"simd_lt\" => Some(ast::BiLt),\n+        \"simd_le\" => Some(ast::BiLe),\n+        \"simd_gt\" => Some(ast::BiGt),\n+        \"simd_ge\" => Some(ast::BiGe),\n+        _ => None\n+    };\n+\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                bcx.sess().span_err(call_info.span, &format!($($fmt)*));\n+                return C_null(llret_ty)\n+            }\n+        }\n+    }\n+\n+    if let Some(cmp_op) = comparison {\n+        assert_eq!(arg_tys.len(), 2);\n+        // we need nominal equality here, not LLVM (structural)\n+        // equality\n+        require!(arg_tys[0] == arg_tys[1],\n+                 \"SIMD comparison intrinsic monomorphised with different input types\");\n+        require!(arg_tys[0].is_simd(tcx),\n+                 \"SIMD comparison intrinsic monomorphised for non-SIMD argument type\");\n+        require!(ret_ty.is_simd(tcx),\n+                 \"SIMD comparison intrinsic monomorphised for non-SIMD return type\");\n+\n+        let in_len = arg_tys[0].simd_size(tcx);\n+        let out_len = ret_ty.simd_size(tcx);\n+        require!(in_len == out_len,\n+                 \"SIMD comparison intrinsic monomorphised for non-SIMD argument type\");\n+        require!(llret_ty.element_type().kind() == llvm::Integer,\n+                 \"SIMD comparison intrinsic monomorphised with non-integer return\");\n+\n+        return compare_simd_types(bcx,\n+                                  llargs[0],\n+                                  llargs[1],\n+                                  arg_tys[0].simd_type(tcx),\n+                                  llret_ty,\n+                                  cmp_op,\n+                                  call_debug_location)\n+    }\n+\n+    if name.starts_with(\"simd_shuffle\") {\n+        let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n+            Ok(n) => n,\n+            Err(_) => tcx.sess.span_bug(call_info.span,\n+                                          \"bad `simd_shuffle` instruction only caught in trans?\")\n+        };\n+        assert_eq!(llargs.len(), 2 + n);\n+\n+        require!(arg_tys[0] == arg_tys[1],\n+                 \"SIMD shuffle intrinsic monomorphised with different input types\");\n+        require!(ret_ty.is_simd(tcx),\n+                 \"SIMD shuffle intrinsic monomorphised for non-SIMD return type\");\n+\n+        let in_len = arg_tys[0].simd_size(tcx);\n+        let out_len = ret_ty.simd_size(tcx);\n+        require!(out_len == n,\n+                 \"SIMD shuffle intrinsic monomorphised with return type of length {} (expected {})\",\n+                 out_len, n);\n+        require!(arg_tys[0].simd_type(tcx) == ret_ty.simd_type(tcx),\n+                 \"SIMD shuffle intrinsic monomorphised with different \\\n+                  input and return element types\");\n+\n+        let total_len = in_len as u64 * 2;\n+\n+        let indices: Option<Vec<_>> = llargs[2..]\n+            .iter()\n+            .enumerate()\n+            .map(|(i, val)| {\n+                let arg_idx = i + 2;\n+                let c = const_to_opt_uint(*val);\n+                match c {\n+                    None => {\n+                        bcx.sess().span_err(call_info.span,\n+                                            &format!(\"SIMD shuffle intrinsic argument #{} \\\n+                                                      is not a constant\",\n+                                                     arg_idx));\n+                        None\n+                    }\n+                    Some(idx) if idx >= total_len => {\n+                        bcx.sess().span_err(call_info.span,\n+                                            &format!(\"SIMD shuffle intrinsic argument #{} \\\n+                                                      is out of bounds (limit {})\",\n+                                                     arg_idx, total_len));\n+                        None\n+                    }\n+                    Some(idx) => Some(C_i32(bcx.ccx(), idx as i32)),\n+                }\n+            })\n+            .collect();\n+        let indices = match indices {\n+            Some(i) => i,\n+            None => return C_null(llret_ty)\n+        };\n+\n+        return ShuffleVector(bcx, llargs[0], llargs[1], C_vector(&indices))\n+    }\n+    C_null(llret_ty)\n+}"}, {"sha": "749bc8ab2942bfd6b7fe0a95e880a268636a626f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1bfbde6778ee4839ca62aad3d025477296cf323f", "patch": "@@ -110,6 +110,7 @@ use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n use std::collections::HashSet;\n+use std::iter;\n use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -5091,6 +5092,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n     let tcx = ccx.tcx;\n     let name = it.ident.name.as_str();\n+    let mut infer_ctxt = None;\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n@@ -5338,7 +5340,28 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"discriminant_value\" => (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n-                                    param(ccx, 0))], tcx.types.u64),\n+                                   param(ccx, 0))], tcx.types.u64),\n+            \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n+                (2, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 1))\n+            }\n+            name if name.starts_with(\"simd_shuffle\") => {\n+                match name[\"simd_shuffle\".len()..].parse() {\n+                    Ok(n) => {\n+                        let mut params = vec![param(ccx, 0), param(ccx, 0)];\n+                        params.extend(iter::repeat(tcx.types.u32).take(n));\n+\n+                        let ictxt = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                        let ret = ictxt.next_ty_var();\n+                        infer_ctxt = Some(ictxt);\n+                        (2, params, ret)\n+                    }\n+                    Err(_) => {\n+                        span_err!(tcx.sess, it.span, E0439,\n+                                  \"invalid `simd_shuffle`, needs length: `{}`\", name);\n+                        return\n+                    }\n+                }\n+            }\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n@@ -5381,7 +5404,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n              i_n_tps, n_tps);\n     } else {\n         require_same_types(tcx,\n-                           None,\n+                           infer_ctxt.as_ref(),\n                            false,\n                            it.span,\n                            i_ty.ty,"}, {"sha": "093ffc6a9963e147f4498048500d4a1404fa92b0", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfbde6778ee4839ca62aad3d025477296cf323f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1bfbde6778ee4839ca62aad3d025477296cf323f", "patch": "@@ -2800,5 +2800,6 @@ register_diagnostics! {\n            // type because its default value `{}` references the type `Self`\"\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n-    E0436  // functional record update requires a struct\n+    E0436,  // functional record update requires a struct\n+    E0439 // invalid `simd_shuffle`, needs length: `{}`\n }"}]}