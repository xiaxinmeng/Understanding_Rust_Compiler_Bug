{"sha": "1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "node_id": "C_kwDOAAsO6NoAKDFiM2E1ZjI5ZGQ5ZjliYTlkZTBkNTAxODU3ZDQ2MDNhNTRlMTU3MDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-30T02:53:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-30T02:53:09Z"}, "message": "Auto merge of #91125 - eskarn:llvm-passes-plugin-support, r=nagisa\n\nAllow loading LLVM plugins with both legacy and new pass manager\n\nOpening a draft PR to get feedback and start discussion on this feature. There is already a codegen option `passes` which allow giving a list of LLVM pass names, however we currently can't use a LLVM pass plugin (as described here : https://llvm.org/docs/WritingAnLLVMPass.html), the only available passes are the LLVM built-in ones.\n\nThe proposed modification would be to add another codegen option `pass-plugins`, which can be set with a list of paths to shared library files. These libraries are loaded using the LLVM function `PassPlugin::Load`, which calls the expected symbol `lvmGetPassPluginInfo`, and register the pipeline parsing and optimization callbacks.\n\nAn example usage with a single plugin and 3 passes would look like this in the `.cargo/config`:\n\n```toml\nrustflags = [\n    \"-C\", \"pass-plugins=/tmp/libLLVMPassPlugin\",\n    \"-C\", \"passes=pass1 pass2 pass3\",\n]\n```\nThis would give the same functionality as the opt LLVM tool directly integrated in rust build system.\n\nAdditionally, we can also not specify the `passes` option, and use a plugin which inserts passes in the optimization pipeline, as one could do using clang.", "tree": {"sha": "6b8341cb67fcb92877c2a02bf9dc68926207f620", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b8341cb67fcb92877c2a02bf9dc68926207f620"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "html_url": "https://github.com/rust-lang/rust/commit/1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d331cb710f0dd969d779510a49a3bafc7f78a54e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d331cb710f0dd969d779510a49a3bafc7f78a54e", "html_url": "https://github.com/rust-lang/rust/commit/d331cb710f0dd969d779510a49a3bafc7f78a54e"}, {"sha": "f431df0d7f4f56e5c4c6a73023126e1b02104436", "url": "https://api.github.com/repos/rust-lang/rust/commits/f431df0d7f4f56e5c4c6a73023126e1b02104436", "html_url": "https://github.com/rust-lang/rust/commit/f431df0d7f4f56e5c4c6a73023126e1b02104436"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "ddba43cd1f16e67b2655dddee4436f3f7dab6943", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -3,7 +3,7 @@ use crate::back::write::{\n };\n use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{self, build_string, False, True};\n-use crate::{LlvmCodegenBackend, ModuleLlvm};\n+use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{\n@@ -596,7 +596,10 @@ pub(crate) fn run_pass_manager(\n     //      tools/lto/LTOCodeGenerator.cpp\n     debug!(\"running the pass manager\");\n     unsafe {\n-        if write::should_use_new_llvm_pass_manager(cgcx, config) {\n+        if llvm_util::should_use_new_llvm_pass_manager(\n+            &config.new_llvm_pass_manager,\n+            &cgcx.target_arch,\n+        ) {\n             let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n             let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n             write::optimize_with_new_llvm_pass_manager("}, {"sha": "fd7c58c8e32e2b7b22f2a25c5380cd489f3da595", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -416,21 +416,6 @@ fn get_pgo_sample_use_path(config: &ModuleConfig) -> Option<CString> {\n         .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n }\n \n-pub(crate) fn should_use_new_llvm_pass_manager(\n-    cgcx: &CodegenContext<LlvmCodegenBackend>,\n-    config: &ModuleConfig,\n-) -> bool {\n-    // The new pass manager is enabled by default for LLVM >= 13.\n-    // This matches Clang, which also enables it since Clang 13.\n-\n-    // FIXME: There are some perf issues with the new pass manager\n-    // when targeting s390x, so it is temporarily disabled for that\n-    // arch, see https://github.com/rust-lang/rust/issues/89609\n-    config\n-        .new_llvm_pass_manager\n-        .unwrap_or_else(|| cgcx.target_arch != \"s390x\" && llvm_util::get_version() >= (13, 0, 0))\n-}\n-\n pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -473,6 +458,8 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n \n     let extra_passes = config.passes.join(\",\");\n \n+    let llvm_plugins = config.llvm_plugins.join(\",\");\n+\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n@@ -502,6 +489,8 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         selfprofile_after_pass_callback,\n         extra_passes.as_ptr().cast(),\n         extra_passes.len(),\n+        llvm_plugins.as_ptr().cast(),\n+        llvm_plugins.len(),\n     );\n     result.into_result().map_err(|()| llvm_err(diag_handler, \"failed to run LLVM passes\"))\n }\n@@ -530,7 +519,10 @@ pub(crate) unsafe fn optimize(\n     }\n \n     if let Some(opt_level) = config.opt_level {\n-        if should_use_new_llvm_pass_manager(cgcx, config) {\n+        if llvm_util::should_use_new_llvm_pass_manager(\n+            &config.new_llvm_pass_manager,\n+            &cgcx.target_arch,\n+        ) {\n             let opt_stage = match cgcx.lto {\n                 Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n                 Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,"}, {"sha": "9c05a9d71429a6de285bc9fd714b76c64f79e2fe", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -2313,6 +2313,8 @@ extern \"C\" {\n         end_callback: SelfProfileAfterPassCallback,\n         ExtraPasses: *const c_char,\n         ExtraPassesLen: size_t,\n+        LLVMPlugins: *const c_char,\n+        LLVMPluginsLen: size_t,\n     ) -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(\n         M: &Module,"}, {"sha": "71834b20fb7804f3e4f179970735de408f1f4e3e", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -121,14 +121,20 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    // Register LLVM plugins by loading them into the compiler process.\n-    for plugin in &sess.opts.debugging_opts.llvm_plugins {\n-        let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n-        debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n-\n-        // Intentionally leak the dynamic library. We can't ever unload it\n-        // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n+    // Use the legacy plugin registration if we don't use the new pass manager\n+    if !should_use_new_llvm_pass_manager(\n+        &sess.opts.debugging_opts.new_llvm_pass_manager,\n+        &sess.target.arch,\n+    ) {\n+        // Register LLVM plugins by loading them into the compiler process.\n+        for plugin in &sess.opts.debugging_opts.llvm_plugins {\n+            let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n+            debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n+\n+            // Intentionally leak the dynamic library. We can't ever unload it\n+            // since the library can make things that will live arbitrarily long.\n+            mem::forget(lib);\n+        }\n     }\n \n     rustc_llvm::initialize_available_targets();\n@@ -411,3 +417,13 @@ pub fn tune_cpu(sess: &Session) -> Option<&str> {\n     let name = sess.opts.debugging_opts.tune_cpu.as_ref()?;\n     Some(handle_native(name))\n }\n+\n+pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_arch: &str) -> bool {\n+    // The new pass manager is enabled by default for LLVM >= 13.\n+    // This matches Clang, which also enables it since Clang 13.\n+\n+    // FIXME: There are some perf issues with the new pass manager\n+    // when targeting s390x, so it is temporarily disabled for that\n+    // arch, see https://github.com/rust-lang/rust/issues/89609\n+    user_opt.unwrap_or_else(|| target_arch != \"s390x\" && llvm_util::get_version() >= (13, 0, 0))\n+}"}, {"sha": "0281fd929c5fe9234666a205dd49ca4ac58739db", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -113,6 +113,7 @@ pub struct ModuleConfig {\n     pub inline_threshold: Option<u32>,\n     pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n+    pub llvm_plugins: Vec<String>,\n }\n \n impl ModuleConfig {\n@@ -260,6 +261,7 @@ impl ModuleConfig {\n             inline_threshold: sess.opts.cg.inline_threshold,\n             new_llvm_pass_manager: sess.opts.debugging_opts.new_llvm_pass_manager,\n             emit_lifetime_markers: sess.emit_lifetime_markers(),\n+            llvm_plugins: if_regular!(sess.opts.debugging_opts.llvm_plugins.clone(), vec![]),\n         }\n     }\n "}, {"sha": "f06fc3edf58595ea5a518089acc474f9f0a7993e", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1b3a5f29dd9f9ba9de0d501857d4603a54e15707/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=1b3a5f29dd9f9ba9de0d501857d4603a54e15707", "patch": "@@ -17,6 +17,7 @@\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Object/IRObjectFile.h\"\n #include \"llvm/Passes/PassBuilder.h\"\n+#include \"llvm/Passes/PassPlugin.h\"\n #include \"llvm/Passes/StandardInstrumentations.h\"\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n@@ -753,7 +754,8 @@ LLVMRustOptimizeWithNewPassManager(\n     void* LlvmSelfProfiler,\n     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,\n     LLVMRustSelfProfileAfterPassCallback AfterPassCallback,\n-    const char *ExtraPasses, size_t ExtraPassesLen) {\n+    const char *ExtraPasses, size_t ExtraPassesLen,\n+    const char *LLVMPlugins, size_t LLVMPluginsLen) {\n   Module *TheModule = unwrap(ModuleRef);\n   TargetMachine *TM = unwrap(TMRef);\n   OptimizationLevel OptLevel = fromRust(OptLevelRust);\n@@ -924,6 +926,20 @@ LLVMRustOptimizeWithNewPassManager(\n     }\n   }\n \n+  if (LLVMPluginsLen) {\n+    auto PluginsStr = StringRef(LLVMPlugins, LLVMPluginsLen);\n+    SmallVector<StringRef> Plugins;\n+    PluginsStr.split(Plugins, ',', -1, false);\n+    for (auto PluginPath: Plugins) {\n+      auto Plugin = PassPlugin::Load(PluginPath.str());\n+      if (!Plugin) {\n+        LLVMRustSetLastError((\"Failed to load pass plugin\" + PluginPath.str()).c_str());\n+        continue;\n+      }\n+      Plugin->registerPassBuilderCallbacks(PB);\n+    }\n+  }\n+\n #if LLVM_VERSION_GE(13, 0)\n   ModulePassManager MPM;\n #else"}]}