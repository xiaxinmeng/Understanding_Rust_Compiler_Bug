{"sha": "9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkODNjYzgzMzFhZGIwMDk4YmFkMWQ2ZjE4NjNiMGY2MTJjNmYyYzM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-04T18:50:05Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-11T21:34:01Z"}, "message": "Handle `impl Trait` where `Trait` has an assoc type with missing bounds\n\nFix #69638.", "tree": {"sha": "d9837f6aa9c322912771c2429feadde84881494e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9837f6aa9c322912771c2429feadde84881494e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "html_url": "https://github.com/rust-lang/rust/commit/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82734e56b2a50d38e0937d08f559d15dbe8e46b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82734e56b2a50d38e0937d08f559d15dbe8e46b", "html_url": "https://github.com/rust-lang/rust/commit/e82734e56b2a50d38e0937d08f559d15dbe8e46b"}], "stats": {"total": 229, "additions": 208, "deletions": 21}, "files": [{"sha": "ca2d0a8c3edd806abedeb7f33427666dc924d416", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 131, "deletions": 21, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "patch": "@@ -163,58 +163,168 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         let suggest_restriction =\n-            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n+            |generics: &hir::Generics<'_>,\n+             msg,\n+             err: &mut DiagnosticBuilder<'_>,\n+             fn_sig: Option<&hir::FnSig<'_>>| {\n+                // Type parameter needs more bounds. The trivial case is `T` `where T: Bound`, but\n+                // it can also be an `impl Trait` param that needs to be decomposed to a type\n+                // param for cleaner code.\n                 let span = generics.where_clause.span_for_predicates_or_empty_place();\n                 if !span.from_expansion() && span.desugaring_kind().is_none() {\n-                    err.span_suggestion(\n-                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n-                        &format!(\"consider further restricting {}\", msg),\n-                        format!(\n-                            \"{} {} \",\n-                            if !generics.where_clause.predicates.is_empty() {\n-                                \",\"\n-                            } else {\n-                                \" where\"\n+                    // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n+                    if let Some((name, fn_sig)) = fn_sig.and_then(|sig| {\n+                        projection.and_then(|p| {\n+                            // Shenanigans to get the `Trait` from the `impl Trait`.\n+                            match p.self_ty().kind {\n+                                ty::Param(param) if param.name.as_str().starts_with(\"impl \") => {\n+                                    let n = param.name.as_str();\n+                                    // `fn foo(t: impl Trait)`\n+                                    //                 ^^^^^ get this string\n+                                    n.split_whitespace()\n+                                        .skip(1)\n+                                        .next()\n+                                        .map(|n| (n.to_string(), sig))\n+                                }\n+                                _ => None,\n+                            }\n+                        })\n+                    }) {\n+                        // FIXME: Cleanup.\n+                        let mut ty_spans = vec![];\n+                        let impl_name = format!(\"impl {}\", name);\n+                        for i in fn_sig.decl.inputs {\n+                            if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = i.kind {\n+                                match path.segments {\n+                                    [segment] if segment.ident.to_string() == impl_name => {\n+                                        // `fn foo(t: impl Trait)`\n+                                        //            ^^^^^^^^^^ get this to suggest\n+                                        //                       `T` instead\n+\n+                                        // There might be more than one `impl Trait`.\n+                                        ty_spans.push(i.span);\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                        }\n+\n+                        let type_param = format!(\"{}: {}\", \"T\", name);\n+                        // FIXME: modify the `trait_ref` instead of string shenanigans.\n+                        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n+                        let pred = trait_ref.without_const().to_predicate().to_string();\n+                        let pred = pred.replace(&impl_name, \"T\");\n+                        let mut sugg = vec![\n+                            match generics\n+                                .params\n+                                .iter()\n+                                .filter(|p| match p.kind {\n+                                    hir::GenericParamKind::Type {\n+                                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                        ..\n+                                    } => false,\n+                                    _ => true,\n+                                })\n+                                .last()\n+                            {\n+                                // `fn foo(t: impl Trait)`\n+                                //        ^ suggest `<T: Trait>` here\n+                                None => (generics.span, format!(\"<{}>\", type_param)),\n+                                Some(param) => {\n+                                    (param.span.shrink_to_hi(), format!(\", {}\", type_param))\n+                                }\n                             },\n-                            trait_ref.without_const().to_predicate(),\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n+                            (\n+                                // `fn foo(t: impl Trait)`\n+                                //                       ^ suggest `where <T as Trait>::A: Bound`\n+                                generics\n+                                    .where_clause\n+                                    .span_for_predicates_or_empty_place()\n+                                    .shrink_to_hi(),\n+                                format!(\n+                                    \"{} {} \",\n+                                    if !generics.where_clause.predicates.is_empty() {\n+                                        \",\"\n+                                    } else {\n+                                        \" where\"\n+                                    },\n+                                    pred,\n+                                ),\n+                            ),\n+                        ];\n+                        sugg.extend(ty_spans.into_iter().map(|s| (s, \"T\".to_string())));\n+                        // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n+                        err.multipart_suggestion(\n+                            \"introduce a type parameter with a trait bound instead of using \\\n+                             `impl Trait`\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        // Trivial case: `T` needs an extra bound.\n+                        err.span_suggestion(\n+                            generics\n+                                .where_clause\n+                                .span_for_predicates_or_empty_place()\n+                                .shrink_to_hi(),\n+                            &format!(\"consider further restricting {}\", msg),\n+                            format!(\n+                                \"{} {} \",\n+                                if !generics.where_clause.predicates.is_empty() {\n+                                    \",\"\n+                                } else {\n+                                    \" where\"\n+                                },\n+                                trait_ref.without_const().to_predicate(),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n             };\n \n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n         let mut hir_id = body_id;\n         while let Some(node) = self.tcx.hir().find(hir_id) {\n+            debug!(\n+                \"suggest_restricting_param_bound {:?} {:?} {:?} {:?}\",\n+                trait_ref, self_ty.kind, projection, node\n+            );\n             match node {\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n                     kind: hir::TraitItemKind::Fn(..),\n                     ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\", err);\n+                    suggest_restriction(&generics, \"`Self`\", err, None);\n                     return;\n                 }\n \n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n-                    kind: hir::TraitItemKind::Fn(..),\n+                    kind: hir::TraitItemKind::Fn(fn_sig, ..),\n                     ..\n                 })\n                 | hir::Node::ImplItem(hir::ImplItem {\n                     generics,\n-                    kind: hir::ImplItemKind::Fn(..),\n+                    kind: hir::ImplItemKind::Fn(fn_sig, ..),\n                     ..\n                 })\n-                | hir::Node::Item(\n-                    hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. }\n-                    | hir::Item { kind: hir::ItemKind::Trait(_, _, generics, _, _), .. }\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(fn_sig, generics, _), ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\", err, Some(fn_sig));\n+                    return;\n+                }\n+                hir::Node::Item(\n+                    hir::Item { kind: hir::ItemKind::Trait(_, _, generics, _, _), .. }\n                     | hir::Item { kind: hir::ItemKind::Impl { generics, .. }, .. },\n                 ) if projection.is_some() => {\n                     // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\", err);\n+                    suggest_restriction(&generics, \"the associated type\", err, None);\n                     return;\n                 }\n "}, {"sha": "bef9ba9f91f7451392f1f607e647dc28de60d643", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs?ref=9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "patch": "@@ -0,0 +1,29 @@\n+// The double space in `impl  Iterator` is load bearing! We want to make sure we don't regress by\n+// accident if the internal string representation changes.\n+#[rustfmt::skip]\n+fn foo(constraints: impl  Iterator) {\n+    for constraint in constraints {\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn bar<T>(t: T, constraints: impl Iterator) where T: std::fmt::Debug {\n+    for constraint in constraints {\n+        qux(t);\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn baz(t: impl std::fmt::Debug, constraints: impl Iterator) {\n+    for constraint in constraints {\n+        qux(t);\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn qux(_: impl std::fmt::Debug) {}\n+\n+fn main() {}"}, {"sha": "5f84e6d44ea9de9ea62644f4aef94adfce64ed16", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr?ref=9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "patch": "@@ -0,0 +1,48 @@\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:6:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |    ---         --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn foo<T: Iterator>(constraints: T) where <T as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |       ^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:14:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |    ---         --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn bar<T, T: Iterator>(t: T, constraints: T) where T: std::fmt::Debug, <T as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |         ^^^^^^^^^^^^^                     ^                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:22:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |    ---         --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn baz<T: Iterator>(t: impl std::fmt::Debug, constraints: T) where <T as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |       ^^^^^^^^^^^^^                                       ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}