{"sha": "1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNzFmMGJkMjUxOWQ2M2I0MjdlYTM2YTc1MmY3ZGUzMmJjNWE3YTI=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-03-10T11:44:33Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-03-14T12:39:58Z"}, "message": "Add MVP for chalkification", "tree": {"sha": "9448a5e7b6ea07b201f9598b9f2d63930f3f8f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9448a5e7b6ea07b201f9598b9f2d63930f3f8f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "html_url": "https://github.com/rust-lang/rust/commit/1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "html_url": "https://github.com/rust-lang/rust/commit/8c4ff22a2d745097197c659ef9e3b04b8ceeb070"}], "stats": {"total": 519, "additions": 519, "deletions": 0}, "files": [{"sha": "744e3a5eaabccb4c2dd346506152aecf55c64b79", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -648,6 +648,8 @@ define_dep_nodes!( <'tcx>\n     [] GetSymbolExportLevel(DefId),\n \n     [input] Features,\n+\n+    [] ProgramClausesFor(DefId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "868ce831d13e07bcbe733d7b01856c2e5e193cc1", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -1286,3 +1286,86 @@ impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n impl_stable_hash_for!(enum infer::canonical::Certainty {\n     Proven, Ambiguous\n });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::WhereClauseAtom::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Implemented(ref trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            ProjectionEq(ref projection) => projection.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::DomainGoal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Holds(ref where_clause) |\n+            WellFormed(ref where_clause) |\n+            FromEnv(ref where_clause) => where_clause.hash_stable(hcx, hasher),\n+\n+            WellFormedTy(ref ty) => ty.hash_stable(hcx, hasher),\n+            FromEnvTy(ref ty) => ty.hash_stable(hcx, hasher),\n+            RegionOutlives(ref predicate) => predicate.hash_stable(hcx, hasher),\n+            TypeOutlives(ref predicate) => predicate.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::LeafGoal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::LeafGoal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            DomainGoal(ref domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Goal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Implies(ref hypotheses, ref goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+            And(ref goal1, ref goal2) => {\n+                goal1.hash_stable(hcx, hasher);\n+                goal2.hash_stable(hcx, hasher);\n+            }\n+            Not(ref goal) => goal.hash_stable(hcx, hasher),\n+            Leaf(ref leaf_goal) => leaf_goal.hash_stable(hcx, hasher),\n+            Quantified(quantifier, ref goal) => {\n+                quantifier.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum traits::QuantifierKind {\n+    Universal,\n+    Existential\n+});\n+\n+impl_stable_hash_for!(struct traits::ProgramClause<'tcx> {\n+    consequence,\n+    conditions\n+});"}, {"sha": "4f7e66628d4845c171731bff15233e6de0c37864", "filename": "src/librustc/traits/lowering.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Flowering.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::{self, ImplPolarity};\n+use hir::def_id::DefId;\n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use ty::{self, PolyTraitPredicate, TraitPredicate, PolyProjectionPredicate, TyCtxt, Predicate};\n+use super::{DomainGoal, ProgramClause, WhereClauseAtom};\n+use rustc_data_structures::sync::Lrc;\n+use syntax::ast;\n+\n+trait Lower<T> {\n+    fn lower(&self) -> T;\n+}\n+\n+impl<T, U> Lower<Vec<U>> for Vec<T> where T: Lower<U> {\n+    fn lower(&self) -> Vec<U> {\n+        self.iter().map(|item| item.lower()).collect()\n+    }\n+}\n+\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for PolyTraitPredicate<'tcx> {\n+    fn lower(&self) -> WhereClauseAtom<'tcx> {\n+        WhereClauseAtom::Implemented(*self)\n+    }\n+}\n+\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for PolyProjectionPredicate<'tcx> {\n+    fn lower(&self) -> WhereClauseAtom<'tcx> {\n+        WhereClauseAtom::ProjectionEq(*self)\n+    }\n+}\n+\n+impl<'tcx, T> Lower<DomainGoal<'tcx>> for T where T: Lower<WhereClauseAtom<'tcx>> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        DomainGoal::Holds(self.lower())\n+    }\n+}\n+\n+impl<'tcx> Lower<DomainGoal<'tcx>> for Predicate<'tcx> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        use self::Predicate::*;\n+\n+        match *self {\n+            Trait(predicate) => predicate.lower(),\n+            RegionOutlives(predicate) => DomainGoal::RegionOutlives(predicate),\n+            TypeOutlives(predicate) => DomainGoal::TypeOutlives(predicate),\n+            Projection(predicate) => predicate.lower(),\n+            WellFormed(ty) => DomainGoal::WellFormedTy(ty),\n+            ObjectSafe(..) |\n+            ClosureKind(..) |\n+            Subtype(..) |\n+            ConstEvaluatable(..) => unimplemented!(),\n+\n+        }\n+    }\n+}\n+\n+pub fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Lrc<Vec<ProgramClause<'tcx>>>\n+{\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir.expect_item(node_id);\n+    match item.node {\n+        hir::ItemImpl(..) => program_clauses_for_impl(tcx, def_id),\n+        _ => Lrc::new(vec![]),\n+    }\n+}\n+\n+fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Lrc<Vec<ProgramClause<'tcx>>>\n+{\n+    if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n+        return Lrc::new(vec![]);\n+    }\n+\n+    let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n+    let trait_ref = ty::Binder(TraitPredicate { trait_ref }).lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+\n+    let clause = ProgramClause {\n+        consequence: trait_ref,\n+        conditions: where_clauses.into_iter().map(|wc| wc.into()).collect(),\n+    };\n+\n+    Lrc::new(vec![clause])\n+}\n+\n+pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if !tcx.features().rustc_attrs {\n+        return;\n+    }\n+\n+    let mut visitor = ClauseDumper { tcx };\n+    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+}\n+\n+struct ClauseDumper<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl <'a, 'tcx> ClauseDumper<'a, 'tcx > {\n+    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir.local_def_id(node_id);\n+        for attr in attrs {\n+            if attr.check_name(\"rustc_dump_program_clauses\") {\n+                let clauses = self.tcx.program_clauses_for(def_id);\n+                for clause in &*clauses {\n+                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", clause)).emit();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.process_attrs(item.id, &item.attrs);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.process_attrs(s.id, &s.attrs);\n+        intravisit::walk_struct_field(self, s);\n+    }\n+}"}, {"sha": "8b2f96ce87557f90e157669142200441f1fbf49b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -29,6 +29,7 @@ use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n+use std::convert::From;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -62,6 +63,7 @@ mod specialize;\n mod structural_impls;\n pub mod trans;\n mod util;\n+mod lowering;\n \n pub mod query;\n \n@@ -244,6 +246,59 @@ pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum WhereClauseAtom<'tcx> {\n+    Implemented(ty::PolyTraitPredicate<'tcx>),\n+    ProjectionEq(ty::PolyProjectionPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClauseAtom<'tcx>),\n+    WellFormed(WhereClauseAtom<'tcx>),\n+    FromEnv(WhereClauseAtom<'tcx>),\n+    WellFormedTy(Ty<'tcx>),\n+    FromEnvTy(Ty<'tcx>),\n+    RegionOutlives(ty::PolyRegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::PolyTypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum LeafGoal<'tcx> {\n+    DomainGoal(DomainGoal<'tcx>),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Goal<'tcx> {\n+    Implies(Vec<DomainGoal<'tcx>>, Box<Goal<'tcx>>),\n+    And(Box<Goal<'tcx>>, Box<Goal<'tcx>>),\n+    Not(Box<Goal<'tcx>>),\n+    Leaf(LeafGoal<'tcx>),\n+    Quantified(QuantifierKind, Box<ty::Binder<Goal<'tcx>>>)\n+}\n+\n+impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n+    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n+        Goal::Leaf(LeafGoal::DomainGoal(domain_goal))\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ProgramClause<'tcx> {\n+    pub consequence: DomainGoal<'tcx>,\n+    pub conditions: Vec<Goal<'tcx>>,\n+}\n+\n+pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    lowering::dump_program_clauses(tcx)\n+}\n+\n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n #[derive(Clone,Debug)]\n@@ -915,6 +970,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        program_clauses_for: lowering::program_clauses_for,\n         vtable_methods,\n         substitute_normalize_and_test_predicates,\n         ..*providers"}, {"sha": "62881013c4c5e444e3f1995627cb63cfe15bcfa3", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -425,3 +425,186 @@ BraceStructTypeFoldableImpl! {\n         obligations\n     } where T: TypeFoldable<'tcx>\n }\n+\n+impl<'tcx> fmt::Display for traits::WhereClauseAtom<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::WhereClauseAtom::*;\n+        match *self {\n+            Implemented(ref trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(ref projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::DomainGoal::*;\n+        use traits::WhereClauseAtom::*;\n+        match *self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(Implemented(ref trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            WellFormed(ProjectionEq(ref projection)) => write!(fmt, \"WellFormed({})\", projection),\n+            FromEnv(Implemented(ref trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            FromEnv(ProjectionEq(ref projection)) => write!(fmt, \"FromEnv({})\", projection),\n+            WellFormedTy(ref ty) => write!(fmt, \"WellFormed({})\", ty),\n+            FromEnvTy(ref ty) => write!(fmt, \"FromEnv({})\", ty),\n+            RegionOutlives(ref predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n+            TypeOutlives(ref predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::QuantifierKind::*;\n+        match *self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::LeafGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::LeafGoal::*;\n+        match *self {\n+            DomainGoal(ref domain_goal) => write!(fmt, \"{}\", domain_goal),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::Goal::*;\n+        match *self {\n+            Implies(ref hypotheses, ref goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(ref goal1, ref goal2) => write!(fmt, \"({}, {})\", goal1, goal2),\n+            Not(ref goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            Leaf(ref goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, ref goal) => {\n+                // FIXME: appropriate binder names\n+                write!(fmt, \"{}<> {{ {} }}\", qkind, goal.skip_binder())\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{}\", self.consequence)?;\n+        if self.conditions.is_empty() {\n+            write!(fmt, \".\")?;\n+        } else {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in self.conditions.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use traits::WhereClauseAtom::*;\n+        match *self {\n+            Implemented(ref trait_ref) => Implemented(trait_ref.fold_with(folder)),\n+            ProjectionEq(ref projection) => ProjectionEq(projection.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use traits::WhereClauseAtom::*;\n+        match *self {\n+            Implemented(ref trait_ref) => trait_ref.visit_with(visitor),\n+            ProjectionEq(ref projection) => projection.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use traits::DomainGoal::*;\n+        match *self {\n+            Holds(ref wc) => Holds(wc.fold_with(folder)),\n+            WellFormed(ref wc) => WellFormed(wc.fold_with(folder)),\n+            FromEnv(ref wc) => FromEnv(wc.fold_with(folder)),\n+            WellFormedTy(ref ty) => WellFormedTy(ty.fold_with(folder)),\n+            FromEnvTy(ref ty) => FromEnvTy(ty.fold_with(folder)),\n+            RegionOutlives(ref predicate) => RegionOutlives(predicate.fold_with(folder)),\n+            TypeOutlives(ref predicate) => TypeOutlives(predicate.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use traits::DomainGoal::*;\n+        match *self {\n+            Holds(ref wc) |\n+            WellFormed(ref wc) |\n+            FromEnv(ref wc) => wc.visit_with(visitor),\n+            WellFormedTy(ref ty) |\n+            FromEnvTy(ref ty) => ty.visit_with(visitor),\n+            RegionOutlives(ref predicate) => predicate.visit_with(visitor),\n+            TypeOutlives(ref predicate) => predicate.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::LeafGoal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use traits::LeafGoal::*;\n+        match *self {\n+            DomainGoal(ref domain_goal) => DomainGoal(domain_goal.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use traits::LeafGoal::*;\n+        match *self {\n+            DomainGoal(ref domain_goal) => domain_goal.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use traits::Goal::*;\n+        match *self {\n+            Implies(ref hypotheses, ref goal) => {\n+                Implies(\n+                    hypotheses.iter().map(|hyp| hyp.fold_with(folder)).collect(),\n+                    goal.fold_with(folder)\n+                )\n+            },\n+            And(ref goal1, ref goal2) => And(goal1.fold_with(folder), goal2.fold_with(folder)),\n+            Not(ref goal) => Not(goal.fold_with(folder)),\n+            Leaf(ref leaf_goal) => Leaf(leaf_goal.fold_with(folder)),\n+            Quantified(qkind, ref goal) => Quantified(qkind, goal.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use traits::Goal::*;\n+        match *self {\n+            Implies(ref hypotheses, ref goal) => {\n+                hypotheses.iter().any(|hyp| hyp.visit_with(visitor)) || goal.visit_with(visitor)\n+            }\n+            And(ref goal1, ref goal2) => goal1.visit_with(visitor) || goal2.visit_with(visitor),\n+            Not(ref goal) => goal.visit_with(visitor),\n+            Leaf(ref leaf_goal) => leaf_goal.visit_with(visitor),\n+            Quantified(_, ref goal) => goal.visit_with(visitor),\n+        }\n+    }\n+}"}, {"sha": "abda7a2cd09ecfcdead140bf865718347c75171b", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -681,6 +681,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefId) -> String {\n+        format!(\"generating chalk-style clauses\")\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "087c7d6d44df6e5737d1df52e87c728fc34d94c0", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -38,6 +38,7 @@ use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n+use traits::ProgramClause;\n use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n@@ -417,6 +418,8 @@ define_maps! { <'tcx>\n         -> usize,\n \n     [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n+\n+    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<ProgramClause<'tcx>>>,\n }\n \n //////////////////////////////////////////////////////////////////////"}, {"sha": "dd65d4b4190718ff5fbcfdf49bb1235bff36a1f7", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -935,6 +935,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n+\n+        DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n     }\n \n     true"}, {"sha": "69257e3e1139274b1502fd1899a53b3c42de46d8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -1089,6 +1089,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n         time(sess, \"lint checking\", || lint::check_crate(tcx));\n \n+        time(time_passes, \"dumping chalk-like clauses\", || traits::dump_program_clauses(tcx));\n+\n         return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n }"}, {"sha": "ea2d907331a6df5bbc4a9e69e99638c4a7eac87f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -831,6 +831,13 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                           across crates and will never be stable\",\n                                                           cfg_fn!(rustc_attrs))),\n \n+    (\"rustc_dump_program_clauses\", Whitelisted, Gated(Stability::Unstable,\n+                                                     \"rustc_attrs\",\n+                                                     \"the `#[rustc_dump_program_clauses]` \\\n+                                                      attribute is just used for rustc unit \\\n+                                                      tests and will never be stable\",\n+                                                     cfg_fn!(rustc_attrs))),\n+\n     // RFC #2094\n     (\"nll\", Whitelisted, Gated(Stability::Unstable,\n                                \"nll\","}, {"sha": "2083ada6d2de5481b7177e8f246ffceadcdc9cad", "filename": "src/test/ui/chalkify/lower_impl.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+trait Foo { }\n+\n+#[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-\n+impl<T: 'static> Foo for T where T: Iterator<Item = i32> { }\n+\n+fn main() {\n+    println!(\"hello\");\n+}"}, {"sha": "8645e4506efa89c4c57fa59eef96f9894718fc01", "filename": "src/test/ui/chalkify/lower_impl.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1271f0bd2519d63b427ea36a752f7de32bc5a7a2/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr?ref=1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "patch": "@@ -0,0 +1,8 @@\n+error: Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T : 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized)\n+  --> $DIR/lower_impl.rs:15:1\n+   |\n+LL | #[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}