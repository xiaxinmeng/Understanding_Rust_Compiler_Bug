{"sha": "fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMWRmZDJiMjBiMjU2Yjk5ZjQwZjZmNjQyMWY3YzdlMTJjMjNlNDE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-16T19:38:27Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-17T17:47:45Z"}, "message": "Refactor some more\n\nType-relative paths (`<T>::foo`) also need to work in type context, for example\n`<T>::Item` is legal. So rather than returning the type ref from the resolver\nfunction, just check it before.", "tree": {"sha": "4ac1178549999db25d67fd7358c4a705cfe629fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac1178549999db25d67fd7358c4a705cfe629fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "html_url": "https://github.com/rust-lang/rust/commit/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "406280e52f20e25af609d947efbed8b352ca1249", "url": "https://api.github.com/repos/rust-lang/rust/commits/406280e52f20e25af609d947efbed8b352ca1249", "html_url": "https://github.com/rust-lang/rust/commit/406280e52f20e25af609d947efbed8b352ca1249"}], "stats": {"total": 157, "additions": 100, "deletions": 57}, "files": [{"sha": "39d1b7e46f3b976fa83cf206824da2342ded6f6d", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "patch": "@@ -190,6 +190,13 @@ impl Path {\n     pub fn expand_macro_expr(&self) -> Option<Name> {\n         self.as_ident().and_then(|name| Some(name.clone()))\n     }\n+\n+    pub fn is_type_relative(&self) -> bool {\n+        match self.kind {\n+            PathKind::Type(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GenericArgs {"}, {"sha": "a23c8792ad84c89b10718cb03511ed1e5eaac49e", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "patch": "@@ -15,7 +15,6 @@ use crate::{\n     name::{Name, SELF_PARAM, SELF_TYPE},\n     nameres::{CrateDefMap, CrateModuleId, PerNs},\n     path::{Path, PathKind},\n-    type_ref::TypeRef,\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n };\n@@ -65,10 +64,9 @@ pub enum TypeNs {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ResolveValueResult<'a> {\n+pub enum ResolveValueResult {\n     ValueNs(ValueNs),\n     Partial(TypeNs, usize),\n-    TypeRef(&'a TypeRef),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -131,6 +129,9 @@ impl Resolver {\n         db: &impl HirDatabase,\n         path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n+        if path.is_type_relative() {\n+            return None;\n+        }\n         let first_name = &path.segments.first()?.name;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n@@ -189,11 +190,10 @@ impl Resolver {\n         &self,\n         db: &impl HirDatabase,\n         path: &'p Path,\n-    ) -> Option<ResolveValueResult<'p>> {\n-        if let PathKind::Type(type_ref) = &path.kind {\n-            return Some(ResolveValueResult::TypeRef(type_ref));\n+    ) -> Option<ResolveValueResult> {\n+        if path.is_type_relative() {\n+            return None;\n         }\n-\n         let n_segments = path.segments.len();\n         let tmp = SELF_PARAM;\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n@@ -284,7 +284,7 @@ impl Resolver {\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n-            ResolveValueResult::Partial(..) | ResolveValueResult::TypeRef(_) => None,\n+            ResolveValueResult::Partial(..) => None,\n         }\n     }\n "}, {"sha": "181be0fcc31a3b623c79848a03c28d459c9489d5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "patch": "@@ -48,8 +48,7 @@ use crate::{\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, AssocItem, ConstData, DefWithBody, Either, FnData, Function, HasBody, Name, Path,\n-    StructField,\n+    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Name, Path, StructField,\n };\n \n mod unify;\n@@ -468,16 +467,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n-\n-        let (value, self_subst) = match value_or_partial {\n-            ResolveValueResult::ValueNs(it) => (it, None),\n-            ResolveValueResult::Partial(def, remaining_index) => {\n-                self.resolve_assoc_item(Either::A(def), path, remaining_index, id)?\n+        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n+            if path.segments.is_empty() {\n+                // This can't actually happen syntax-wise\n+                return None;\n             }\n-            ResolveValueResult::TypeRef(type_ref) => {\n-                let ty = self.make_ty(type_ref);\n-                self.resolve_assoc_item(Either::B(ty), path, 0, id)?\n+            let ty = self.make_ty(type_ref);\n+            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n+            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            self.resolve_ty_assoc_item(\n+                ty,\n+                path.segments.last().expect(\"path had at least one segment\"),\n+                id,\n+            )?\n+        } else {\n+            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n+\n+            match value_or_partial {\n+                ResolveValueResult::ValueNs(it) => (it, None),\n+                ResolveValueResult::Partial(def, remaining_index) => {\n+                    self.resolve_assoc_item(def, path, remaining_index, id)?\n+                }\n             }\n         };\n \n@@ -508,15 +518,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_assoc_item(\n         &mut self,\n-        // mut def_or_ty: Either<TypeNs, Ty>,\n         def: TypeNs,\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         assert!(remaining_index < path.segments.len());\n-        let krate = self.resolver.krate()?;\n-\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n         // the segments before that, we need to get either a type or a trait ref.\n@@ -525,11 +532,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let remaining_segments = &path.segments[remaining_index..];\n         let is_before_last = remaining_segments.len() == 1;\n \n-        let (def, substs) = match (def, is_before_last) {\n+        match (def, is_before_last) {\n             (TypeNs::Trait(_trait), true) => {\n-                // Associated item of trait, e.g. `Default::default`\n-                // FIXME\n-                return None;\n+                // FIXME Associated item of trait, e.g. `Default::default`\n+                None\n             }\n             (def, _) => {\n                 // Either we already have a type (e.g. `Vec::new`), or we have a\n@@ -550,29 +556,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n-                // Find impl\n-                let def = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n-                    crate::ImplItem::Method(func) => {\n-                        if segment.name == func.name(self.db) {\n-                            Some(ValueNs::Function(func))\n-                        } else {\n-                            None\n-                        }\n-                    }\n \n-                    crate::ImplItem::Const(konst) => {\n-                        if segment.name == konst.name(self.db) {\n-                            Some(ValueNs::Const(konst))\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    crate::ImplItem::TypeAlias(_) => None,\n-                })?;\n-                let self_types = self.find_self_types(&def, ty);\n-                (def, self_types)\n+                self.resolve_ty_assoc_item(ty, segment, id)\n             }\n-        };\n+        }\n+    }\n+\n+    fn resolve_ty_assoc_item(\n+        &mut self,\n+        ty: Ty,\n+        segment: &crate::path::PathSegment,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        if let Ty::Unknown = ty {\n+            return None;\n+        }\n+\n+        let krate = self.resolver.krate()?;\n+\n+        // Find impl\n+        // FIXME: consider trait candidates\n+        let def = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n+            crate::ImplItem::Method(func) => {\n+                if segment.name == func.name(self.db) {\n+                    Some(ValueNs::Function(func))\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            crate::ImplItem::Const(konst) => {\n+                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                    Some(ValueNs::Const(konst))\n+                } else {\n+                    None\n+                }\n+            }\n+            crate::ImplItem::TypeAlias(_) => None,\n+        })?;\n+        let substs = self.find_self_types(&def, ty);\n \n         self.write_assoc_resolution(\n             id,"}, {"sha": "e6cd5d0be750f3da88a4cb316a8db2b31ff2569f", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=fe1dfd2b20b256b99f40f6f6421f7c7e12c23e41", "patch": "@@ -86,6 +86,24 @@ impl Ty {\n         }\n     }\n \n+    pub(crate) fn from_type_relative_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        ty: Ty,\n+        remaining_segments: &[PathSegment],\n+    ) -> Ty {\n+        if remaining_segments.len() == 1 {\n+            // resolve unselected assoc types\n+            let segment = &remaining_segments[0];\n+            Ty::select_associated_type(db, resolver, ty, segment)\n+        } else if remaining_segments.len() > 1 {\n+            // FIXME report error (ambiguous associated type)\n+            Ty::Unknown\n+        } else {\n+            ty\n+        }\n+    }\n+\n     pub(crate) fn from_partly_resolved_hir_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -140,20 +158,16 @@ impl Ty {\n             TypeNs::EnumVariant(_) => return Ty::Unknown,\n         };\n \n-        if remaining_segments.len() == 1 {\n-            // resolve unselected assoc types\n-            let segment = &remaining_segments[0];\n-            Ty::select_associated_type(db, resolver, ty, segment)\n-        } else if remaining_segments.len() > 1 {\n-            // FIXME report error (ambiguous associated type)\n-            Ty::Unknown\n-        } else {\n-            ty\n-        }\n+        Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n     }\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n+        if let crate::PathKind::Type(type_ref) = &path.kind {\n+            let ty = Ty::from_hir(db, resolver, &type_ref);\n+            let remaining_segments = &path.segments[..];\n+            return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n+        }\n         let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n             Some(it) => it,\n             None => return Ty::Unknown,"}]}