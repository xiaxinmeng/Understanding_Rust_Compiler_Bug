{"sha": "212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMmQ3NGYxZTdkYjNkMWNkM2VlYzczN2FlMjBhY2JjYjczYTkxZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T23:36:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T23:36:07Z"}, "message": "Auto merge of #45436 - zilbuz:issue-44837, r=nikomatsakis\n\nMIR-borrowck: add permisson checks to `fn access_lvalue`\n\nWIP : Some FIXME left and some broken tests.\n\nFix #44837", "tree": {"sha": "218543b8112ff70a5463fe120bf5cfda107bad1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/218543b8112ff70a5463fe120bf5cfda107bad1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "html_url": "https://github.com/rust-lang/rust/commit/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e21df8020d0d1a37d2856117b1be2f1a91d8bc42", "url": "https://api.github.com/repos/rust-lang/rust/commits/e21df8020d0d1a37d2856117b1be2f1a91d8bc42", "html_url": "https://github.com/rust-lang/rust/commit/e21df8020d0d1a37d2856117b1be2f1a91d8bc42"}, {"sha": "cbad2e5720fd251fcd7cbe9648fd7671373a71e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbad2e5720fd251fcd7cbe9648fd7671373a71e7", "html_url": "https://github.com/rust-lang/rust/commit/cbad2e5720fd251fcd7cbe9648fd7671373a71e7"}], "stats": {"total": 285, "additions": 260, "deletions": 25}, "files": [{"sha": "aa07a6b070e9e9ccd6dfde1a22cb784d8c3f551b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "patch": "@@ -10,8 +10,9 @@\n \n //! misc. type-system utilities too small to deserve their own file\n \n+use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use hir::map::DefPathData;\n+use hir::map::{DefPathData, Node};\n use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n@@ -648,6 +649,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => bug!(),\n         }\n     }\n+\n+    /// Check if the node pointed to by def_id is a mutable static item\n+    pub fn is_static_mut(&self, def_id: DefId) -> bool {\n+        if let Some(node) = self.hir.get_if_local(def_id) {\n+            match node {\n+                Node::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n+                }) => true,\n+                Node::NodeForeignItem(&hir::ForeignItem {\n+                    node: hir::ForeignItemStatic(_, mutbl), ..\n+                }) => mutbl,\n+                _ => false\n+            }\n+        } else {\n+            match self.describe_def(def_id) {\n+                Some(Def::Static(_, mutbl)) => mutbl,\n+                _ => false\n+            }\n+        }\n+    }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "c56631d429cb4fd214f483f3ef4a13dba10916f5", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 154, "deletions": 2, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "patch": "@@ -10,6 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n+use rustc::hir;\n use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n@@ -447,9 +448,12 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n-        // FIXME: also need to check permissions (e.g. reject mut\n-        // borrow of immutable ref, moves through non-`Box`-ref)\n+\n         let (sd, rw) = kind;\n+\n+        // Check permissions\n+        self.check_access_permissions(lvalue_span, rw);\n+\n         self.each_borrow_involving_path(\n             context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n@@ -861,6 +865,154 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n+\n+    /// Check the permissions for the given lvalue and read or write kind\n+    fn check_access_permissions(&self, (lvalue, span): (&Lvalue<'tcx>, Span), kind: ReadOrWrite) {\n+        match kind {\n+            Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n+                if let Err(_lvalue_err) = self.is_unique(lvalue) {\n+                    span_bug!(span, \"&unique borrow for `{}` should not fail\",\n+                        self.describe_lvalue(lvalue));\n+                }\n+            },\n+            Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => {\n+                if let Err(lvalue_err) = self.is_mutable(lvalue) {\n+                    let mut err = self.tcx.cannot_borrow_path_as_mutable(span,\n+                        &format!(\"immutable item `{}`\",\n+                                  self.describe_lvalue(lvalue)),\n+                        Origin::Mir);\n+                    err.span_label(span, \"cannot borrow as mutable\");\n+\n+                    if lvalue != lvalue_err {\n+                        err.note(&format!(\"Value not mutable causing this error: `{}`\",\n+                            self.describe_lvalue(lvalue_err)));\n+                    }\n+\n+                    err.emit();\n+                }\n+            },\n+            _ => {}// Access authorized\n+        }\n+    }\n+\n+    /// Can this value be written or borrowed mutably\n+    fn is_mutable<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.mutability {\n+                    Mutability::Not => Err(lvalue),\n+                    Mutability::Mut => Ok(())\n+                }\n+            },\n+            Lvalue::Static(ref static_) => {\n+                if !self.tcx.is_static_mut(static_.def_id) {\n+                    Err(lvalue)\n+                } else {\n+                    Ok(())\n+                }\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                        // `Box<T>` owns its content, so mutable if its location is mutable\n+                        if base_ty.is_box() {\n+                            return self.is_mutable(&proj.base);\n+                        }\n+\n+                        // Otherwise we check the kind of deref to decide\n+                        match base_ty.sty {\n+                            ty::TyRef(_, tnm) => {\n+                                match tnm.mutbl {\n+                                    // Shared borrowed data is never mutable\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // Mutably borrowed data is mutable, but only if we have a\n+                                    // unique path to the `&mut`\n+                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                }\n+                            },\n+                            ty::TyRawPtr(tnm) => {\n+                                match tnm.mutbl {\n+                                    // `*const` raw pointers are not mutable\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // `*mut` raw pointers are always mutable, regardless of context\n+                                    // The users have to check by themselve.\n+                                    hir::MutMutable => Ok(()),\n+                                }\n+                            },\n+                            // Deref should only be for reference, pointers or boxes\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                        }\n+                    },\n+                    // All other projections are owned by their base path, so mutable if\n+                    // base path is mutable\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex{..} |\n+                    ProjectionElem::Subslice{..} |\n+                    ProjectionElem::Downcast(..) =>\n+                        self.is_mutable(&proj.base)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Does this lvalue have a unique path\n+    fn is_unique<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+        match *lvalue {\n+            Lvalue::Local(..) => {\n+                // Local variables are unique\n+                Ok(())\n+            },\n+            Lvalue::Static(..) => {\n+                // Static variables are not\n+                Err(lvalue)\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                        // `Box<T>` referent is unique if box is a unique spot\n+                        if base_ty.is_box() {\n+                            return self.is_unique(&proj.base);\n+                        }\n+\n+                        // Otherwise we check the kind of deref to decide\n+                        match base_ty.sty {\n+                            ty::TyRef(_, tnm) => {\n+                                match tnm.mutbl {\n+                                    // lvalue represent an aliased location\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // `&mut T` is as unique as the context in which it is found\n+                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                }\n+                            },\n+                            ty::TyRawPtr(tnm) => {\n+                                match tnm.mutbl {\n+                                    // `*mut` can be aliased, but we leave it to user\n+                                    hir::MutMutable => Ok(()),\n+                                    // `*const` is treated the same as `*mut`\n+                                    hir::MutImmutable => Ok(()),\n+                                }\n+                            },\n+                            // Deref should only be for reference, pointers or boxes\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                        }\n+                    },\n+                    // Other projections are unique if the base is unique\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex{..} |\n+                    ProjectionElem::Subslice{..} |\n+                    ProjectionElem::Downcast(..) =>\n+                        self.is_unique(&proj.base)\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "cbf1b0b089917106313101cb3682fef5ba481072", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "patch": "@@ -14,9 +14,8 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::maps::Providers;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir;\n-use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::{DefPathData, Node};\n+use rustc::hir::map::DefPathData;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, UNUSED_UNSAFE};\n use rustc::mir::*;\n use rustc::mir::visit::{LvalueContext, Visitor};\n@@ -189,7 +188,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // locals are safe\n             }\n             &Lvalue::Static(box Static { def_id, ty: _ }) => {\n-                if self.is_static_mut(def_id) {\n+                if self.tcx.is_static_mut(def_id) {\n                     self.require_unsafe(\"use of mutable static\");\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;\n@@ -208,24 +207,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n-    fn is_static_mut(&self, def_id: DefId) -> bool {\n-        if let Some(node) = self.tcx.hir.get_if_local(def_id) {\n-            match node {\n-                Node::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n-                }) => true,\n-                Node::NodeForeignItem(&hir::ForeignItem {\n-                    node: hir::ForeignItemStatic(_, mutbl), ..\n-                }) => mutbl,\n-                _ => false\n-            }\n-        } else {\n-            match self.tcx.describe_def(def_id) {\n-                Some(Def::Static(_, mutbl)) => mutbl,\n-                _ => false\n-            }\n-        }\n-    }\n     fn require_unsafe(&mut self,\n                       description: &'static str)\n     {"}, {"sha": "0366d4d134a55adf8d2bd312e336a8b1077c776c", "filename": "src/test/compile-fail/E0596.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Ftest%2Fcompile-fail%2FE0596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Ftest%2Fcompile-fail%2FE0596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0596.rs?ref=212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn main() {\n     let x = 1;\n-    let y = &mut x; //~ ERROR E0596\n+    let y = &mut x; //[ast]~ ERROR [E0596]\n+                    //[mir]~^ ERROR (Ast) [E0596]\n+                    //[mir]~| ERROR (Mir) [E0596]\n }"}, {"sha": "fbe219102edbcfc5f66d909c9b057fabaf66429a", "filename": "src/test/compile-fail/borrowck/borrowck-access-permissions.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-access-permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d74f1e7db3d1cd3eec737ae20acbcb73a91ff/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-access-permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-access-permissions.rs?ref=212d74f1e7db3d1cd3eec737ae20acbcb73a91ff", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+static static_x : i32 = 1;\n+static mut static_x_mut : i32 = 1;\n+\n+fn main() {\n+    let x = 1;\n+    let mut x_mut = 1;\n+\n+    { // borrow of local\n+        let _y1 = &mut x; //[ast]~ ERROR [E0596]\n+                          //[mir]~^ ERROR (Ast) [E0596]\n+                          //[mir]~| ERROR (Mir) [E0596]\n+        let _y2 = &mut x_mut; // No error\n+    }\n+\n+    { // borrow of static\n+        let _y1 = &mut static_x; //[ast]~ ERROR [E0596]\n+                                 //[mir]~^ ERROR (Ast) [E0596]\n+                                 //[mir]~| ERROR (Mir) [E0596]\n+        unsafe { let _y2 = &mut static_x_mut; } // No error\n+    }\n+\n+    { // borrow of deref to box\n+        let box_x = Box::new(1);\n+        let mut box_x_mut = Box::new(1);\n+\n+        let _y1 = &mut *box_x; //[ast]~ ERROR [E0596]\n+                              //[mir]~^ ERROR (Ast) [E0596]\n+                              //[mir]~| ERROR (Mir) [E0596]\n+        let _y2 = &mut *box_x_mut; // No error\n+    }\n+\n+    { // borrow of deref to reference\n+        let ref_x = &x;\n+        let ref_x_mut = &mut x_mut;\n+\n+        let _y1 = &mut *ref_x; //[ast]~ ERROR [E0596]\n+                              //[mir]~^ ERROR (Ast) [E0596]\n+                              //[mir]~| ERROR (Mir) [E0596]\n+        let _y2 = &mut *ref_x_mut; // No error\n+    }\n+\n+    { // borrow of deref to pointer\n+        let ptr_x : *const _ = &x;\n+        let ptr_mut_x : *mut _ = &mut x_mut;\n+\n+        unsafe {\n+            let _y1 = &mut *ptr_x; //[ast]~ ERROR [E0596]\n+                                  //[mir]~^ ERROR (Ast) [E0596]\n+                                  //[mir]~| ERROR (Mir) [E0596]\n+            let _y2 = &mut *ptr_mut_x; // No error\n+        }\n+    }\n+\n+    { // borrowing mutably through an immutable reference\n+        struct Foo<'a> { f: &'a mut i32, g: &'a i32 };\n+        let mut foo = Foo { f: &mut x_mut, g: &x };\n+        let foo_ref = &foo;\n+        let _y = &mut *foo_ref.f; //[ast]~ ERROR [E0389]\n+                                 //[mir]~^ ERROR (Ast) [E0389]\n+                                 //[mir]~| ERROR (Mir) [E0596]\n+                                 // FIXME: Wrong error in MIR\n+    }\n+}"}]}