{"sha": "1889b3c7b52c1070734dc449d4119c5e5cf991a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ODliM2M3YjUyYzEwNzA3MzRkYzQ0OWQ0MTE5YzVlNWNmOTkxYTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-15T19:11:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-15T19:11:51Z"}, "message": "Merge #2264\n\n2264: move impls to hir-def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b92568825de2a5cb2950295d35fac8e3bd9fac15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b92568825de2a5cb2950295d35fac8e3bd9fac15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1889b3c7b52c1070734dc449d4119c5e5cf991a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzvh3CRBK7hj4Ov3rIwAAdHIIAIEYTmnuGVWE4kWECYvlrink\n+q7CSUobWGyKnL5Fuf0A8lRk+V+ff2lp08Cp/28WLP8BpouJdHQu2odI2SqY3EvR\nVXxSKINpng7XqTNoxwNVQyQFM1ekYI+h1y9XG/u5EukyveRy9zHaMBMUP3rk6auN\nMyxASUEf0qUDvZB9TKTK+68HweJ49G6n1XEw/xqIH4J9hHUTvp+qbVENEgIAlbxz\n/b2bXvvtIwJzKA3hvNyxT8aO1eIxWMvyr6f2BH5kxxUz+atBib2+xuMU0jchCJ8l\nP7OCbiywo8N6DYYfL64gz4H7OEPVlEk7w+V32vYPVm1L/9KxWy7eUGQYrVnhcoY=\n=Ac4E\n-----END PGP SIGNATURE-----\n", "payload": "tree b92568825de2a5cb2950295d35fac8e3bd9fac15\nparent 0516a32ed0f8add1a999be579ff9d8966a241f67\nparent b21829f7edd71fb14911fc6ba47fe715757e415f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573845111 +0000\ncommitter GitHub <noreply@github.com> 1573845111 +0000\n\nMerge #2264\n\n2264: move impls to hir-def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1889b3c7b52c1070734dc449d4119c5e5cf991a4", "html_url": "https://github.com/rust-lang/rust/commit/1889b3c7b52c1070734dc449d4119c5e5cf991a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1889b3c7b52c1070734dc449d4119c5e5cf991a4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0516a32ed0f8add1a999be579ff9d8966a241f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/0516a32ed0f8add1a999be579ff9d8966a241f67", "html_url": "https://github.com/rust-lang/rust/commit/0516a32ed0f8add1a999be579ff9d8966a241f67"}, {"sha": "b21829f7edd71fb14911fc6ba47fe715757e415f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b21829f7edd71fb14911fc6ba47fe715757e415f", "html_url": "https://github.com/rust-lang/rust/commit/b21829f7edd71fb14911fc6ba47fe715757e415f"}], "stats": {"total": 611, "additions": 241, "deletions": 370}, "files": [{"sha": "731cc1fffbeae5c36ca23155d2b0842aadaf604a", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+    CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -29,7 +29,6 @@ use crate::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n         TypeAliasId,\n     },\n-    impl_block::ImplBlock,\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{InferenceResult, Namespace, TraitRef},\n@@ -243,12 +242,8 @@ impl Module {\n     }\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n-        let module_impl_blocks = db.impls_in_module(self);\n-        module_impl_blocks\n-            .impls\n-            .iter()\n-            .map(|(impl_id, _)| ImplBlock::from_id(self, impl_id))\n-            .collect()\n+        let def_map = db.crate_def_map(self.id.krate);\n+        def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n     fn with_module_id(self, module_id: CrateModuleId) -> Module {\n@@ -693,8 +688,7 @@ impl Function {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n@@ -759,8 +753,7 @@ impl Const {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n@@ -973,8 +966,7 @@ impl TypeAlias {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n@@ -1137,3 +1129,8 @@ pub struct GenericParam {\n     pub(crate) parent: GenericDef,\n     pub(crate) idx: u32,\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImplBlock {\n+    pub(crate) id: ImplId,\n+}"}, {"sha": "276b0774fbede4b731e864afa7b188c3289b1c03", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -10,22 +10,21 @@ use crate::{\n     debug::HirDebugDatabase,\n     generics::{GenericDef, GenericParams},\n     ids,\n-    impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n         InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, FnData, Function, Module, Static, StructField, Trait,\n-    TypeAlias,\n+    Const, ConstData, Crate, DefWithBody, FnData, Function, ImplBlock, Module, Static, StructField,\n+    Trait, TypeAlias,\n };\n \n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n-    EnumDataQuery, ExprScopesQuery, InternDatabase, InternDatabaseStorage, RawItemsQuery,\n-    RawItemsWithSourceMapQuery, StructDataQuery,\n+    EnumDataQuery, ExprScopesQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n+    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -42,15 +41,6 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(ModuleImplBlocks::impls_in_module_with_source_map_query)]\n-    fn impls_in_module_with_source_map(\n-        &self,\n-        module: Module,\n-    ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>);\n-\n-    #[salsa::invoke(ModuleImplBlocks::impls_in_module_query)]\n-    fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;\n-\n     #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n     fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n \n@@ -128,7 +118,7 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n     #[salsa::interned]\n-    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    fn intern_chalk_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;"}, {"sha": "f2203e99532e0505a46a5fd8b65250f11a34510b", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -3,9 +3,9 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, DefWithBodyId, EnumVariantId, ModuleDefId};\n+use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, ModuleDefId};\n \n-use crate::{Adt, DefWithBody, EnumVariant, ModuleDef};\n+use crate::{Adt, AssocItem, DefWithBody, EnumVariant, ModuleDef};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -27,6 +27,7 @@ from_id![\n     (hir_def::StaticId, crate::Static),\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n+    (hir_def::ImplId, crate::ImplBlock),\n     (hir_expand::MacroDefId, crate::MacroDef)\n ];\n \n@@ -71,3 +72,13 @@ impl From<DefWithBody> for DefWithBodyId {\n         }\n     }\n }\n+\n+impl From<AssocItemId> for AssocItem {\n+    fn from(def: AssocItemId) -> Self {\n+        match def {\n+            AssocItemId::FunctionId(it) => AssocItem::Function(it.into()),\n+            AssocItemId::TypeAliasId(it) => AssocItem::TypeAlias(it.into()),\n+            AssocItemId::ConstId(it) => AssocItem::Const(it.into()),\n+        }\n+    }\n+}"}, {"sha": "ec56dfa6ac602154a8fd64c4b1c6dd02fb0e06a8", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -82,14 +82,8 @@ impl FromSource for TypeAlias {\n impl FromSource for ImplBlock {\n     type Ast = ast::ImplBlock;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let module_src = crate::ModuleSource::from_child_node(\n-            db,\n-            src.file_id.original_file(db),\n-            &src.ast.syntax(),\n-        );\n-        let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n-        let impls = module.impl_blocks(db);\n-        impls.into_iter().find(|b| b.source(db) == src)\n+        let id = from_source(db, src)?;\n+        Some(ImplBlock { id })\n     }\n }\n "}, {"sha": "0c2bb8fee3eb15f50e1c658dee2a2c2e108493c5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 23, "deletions": 237, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -1,88 +1,38 @@\n //! FIXME: write short doc here\n \n-use rustc_hash::FxHashMap;\n-use std::sync::Arc;\n-\n-use hir_def::{attr::Attr, type_ref::TypeRef};\n-use hir_expand::hygiene::Hygiene;\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n-use ra_cfg::CfgOptions;\n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    AstPtr,\n-};\n+use hir_def::{type_ref::TypeRef, AstItemDef};\n+use ra_syntax::ast::{self};\n \n use crate::{\n-    code_model::{Module, ModuleSource},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     generics::HasGenericParams,\n-    ids::LocationCtx,\n-    ids::MacroCallLoc,\n     resolve::Resolver,\n     ty::Ty,\n-    AssocItem, AstId, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n-    TypeAlias,\n+    AssocItem, Crate, HasSource, ImplBlock, Module, Source, TraitRef,\n };\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImplSourceMap {\n-    map: ArenaMap<ImplId, Source<AstPtr<ast::ImplBlock>>>,\n-}\n-\n-impl ImplSourceMap {\n-    fn insert(&mut self, impl_id: ImplId, file_id: HirFileId, impl_block: &ast::ImplBlock) {\n-        let source = Source { file_id, ast: AstPtr::new(impl_block) };\n-        self.map.insert(impl_id, source)\n-    }\n-\n-    pub fn get(&self, db: &impl AstDatabase, impl_id: ImplId) -> Source<ast::ImplBlock> {\n-        let src = self.map[impl_id];\n-        let root = src.file_syntax(db);\n-        src.map(|ptr| ptr.to_node(&root))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImplBlock {\n-    module: Module,\n-    impl_id: ImplId,\n-}\n-\n impl HasSource for ImplBlock {\n     type Ast = ast::ImplBlock;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ImplBlock> {\n-        let source_map = db.impls_in_module_with_source_map(self.module).1;\n-        source_map.get(db, self.impl_id)\n+        self.id.source(db)\n     }\n }\n \n impl ImplBlock {\n-    pub(crate) fn containing(\n-        module_impl_blocks: Arc<ModuleImplBlocks>,\n-        item: AssocItem,\n-    ) -> Option<ImplBlock> {\n-        let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n-        Some(ImplBlock { module: module_impl_blocks.module, impl_id })\n-    }\n-\n-    pub(crate) fn from_id(module: Module, impl_id: ImplId) -> ImplBlock {\n-        ImplBlock { module, impl_id }\n-    }\n-\n-    pub fn id(&self) -> ImplId {\n-        self.impl_id\n-    }\n-\n-    pub fn module(&self) -> Module {\n-        self.module\n+    pub(crate) fn containing(db: &impl DefDatabase, item: AssocItem) -> Option<ImplBlock> {\n+        let module = item.module(db);\n+        let crate_def_map = db.crate_def_map(module.id.krate);\n+        crate_def_map[module.id.module_id].impls.iter().copied().map(ImplBlock::from).find(|it| {\n+            db.impl_data(it.id).items().iter().copied().map(AssocItem::from).any(|it| it == item)\n+        })\n     }\n \n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n-        db.impls_in_module(self.module).impls[self.impl_id].target_trait().cloned()\n+        db.impl_data(self.id).target_trait().cloned()\n     }\n \n     pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n-        db.impls_in_module(self.module).impls[self.impl_id].target_type().clone()\n+        db.impl_data(self.id).target_type().clone()\n     }\n \n     pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n@@ -95,191 +45,27 @@ impl ImplBlock {\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n+        db.impl_data(self.id).items().iter().map(|it| (*it).into()).collect()\n     }\n \n     pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n-        db.impls_in_module(self.module).impls[self.impl_id].negative\n+        db.impl_data(self.id).is_negative()\n+    }\n+\n+    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+        self.id.module(db).into()\n+    }\n+\n+    pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n+        Crate { crate_id: self.module(db).id.krate }\n     }\n \n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n-        let r = self.module().resolver(db);\n+        let r = self.module(db).resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         let r = r.push_impl_block_scope(self.clone());\n         r\n     }\n }\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImplData {\n-    target_trait: Option<TypeRef>,\n-    target_type: TypeRef,\n-    items: Vec<AssocItem>,\n-    negative: bool,\n-}\n-\n-impl ImplData {\n-    pub(crate) fn from_ast(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: HirFileId,\n-        module: Module,\n-        node: &ast::ImplBlock,\n-    ) -> Self {\n-        let target_trait = node.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let ctx = LocationCtx::new(db, module.id, file_id);\n-        let negative = node.is_negative();\n-        let items = if let Some(item_list) = node.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        ImplData { target_trait, target_type, items, negative }\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.target_trait.as_ref()\n-    }\n-\n-    pub fn target_type(&self) -> &TypeRef {\n-        &self.target_type\n-    }\n-\n-    pub fn items(&self) -> &[AssocItem] {\n-        &self.items\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ImplId(pub RawId);\n-impl_arena_id!(ImplId);\n-\n-/// The collection of impl blocks is a two-step process: first we collect the\n-/// blocks per-module; then we build an index of all impl blocks in the crate.\n-/// This way, we avoid having to do this process for the whole crate whenever\n-/// a file is changed; as long as the impl blocks in the file don't change,\n-/// we don't need to do the second step again.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ModuleImplBlocks {\n-    pub(crate) module: Module,\n-    pub(crate) impls: Arena<ImplId, ImplData>,\n-    impls_by_def: FxHashMap<AssocItem, ImplId>,\n-}\n-\n-impl ModuleImplBlocks {\n-    pub(crate) fn impls_in_module_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: Module,\n-    ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n-        let mut source_map = ImplSourceMap::default();\n-        let crate_graph = db.crate_graph();\n-        let cfg_options = crate_graph.cfg_options(module.id.krate);\n-\n-        let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n-        (Arc::new(result), Arc::new(source_map))\n-    }\n-\n-    pub(crate) fn impls_in_module_query(\n-        db: &impl DefDatabase,\n-        module: Module,\n-    ) -> Arc<ModuleImplBlocks> {\n-        db.impls_in_module_with_source_map(module).0\n-    }\n-\n-    fn collect(\n-        db: &(impl DefDatabase + AstDatabase),\n-        cfg_options: &CfgOptions,\n-        module: Module,\n-        source_map: &mut ImplSourceMap,\n-    ) -> Self {\n-        let mut m = ModuleImplBlocks {\n-            module,\n-            impls: Arena::default(),\n-            impls_by_def: FxHashMap::default(),\n-        };\n-\n-        let src = m.module.definition_source(db);\n-        match &src.ast {\n-            ModuleSource::SourceFile(node) => {\n-                m.collect_from_item_owner(db, cfg_options, source_map, node, src.file_id)\n-            }\n-            ModuleSource::Module(node) => {\n-                let item_list = node.item_list().expect(\"inline module should have item list\");\n-                m.collect_from_item_owner(db, cfg_options, source_map, &item_list, src.file_id)\n-            }\n-        };\n-        m\n-    }\n-\n-    fn collect_from_item_owner(\n-        &mut self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        cfg_options: &CfgOptions,\n-        source_map: &mut ImplSourceMap,\n-        owner: &dyn ast::ModuleItemOwner,\n-        file_id: HirFileId,\n-    ) {\n-        let hygiene = Hygiene::new(db, file_id);\n-        for item in owner.items_with_macros() {\n-            match item {\n-                ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n-                    let attrs = Attr::from_attrs_owner(&impl_block_ast, &hygiene);\n-                    if attrs.map_or(false, |attrs| {\n-                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n-                    }) {\n-                        continue;\n-                    }\n-\n-                    let impl_block = ImplData::from_ast(db, file_id, self.module, &impl_block_ast);\n-                    let id = self.impls.alloc(impl_block);\n-                    for &impl_item in &self.impls[id].items {\n-                        self.impls_by_def.insert(impl_item, id);\n-                    }\n-\n-                    source_map.insert(id, file_id, &impl_block_ast);\n-                }\n-                ast::ItemOrMacro::Item(_) => (),\n-                ast::ItemOrMacro::Macro(macro_call) => {\n-                    let attrs = Attr::from_attrs_owner(&macro_call, &hygiene);\n-                    if attrs.map_or(false, |attrs| {\n-                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n-                    }) {\n-                        continue;\n-                    }\n-\n-                    //FIXME: we should really cut down on the boilerplate required to process a macro\n-                    let ast_id = AstId::new(file_id, db.ast_id_map(file_id).ast_id(&macro_call));\n-                    if let Some(path) =\n-                        macro_call.path().and_then(|path| Path::from_src(path, &hygiene))\n-                    {\n-                        if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n-                        {\n-                            let call_id = db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n-                            let file_id = call_id.as_file(MacroFileKind::Items);\n-                            if let Some(item_list) =\n-                                db.parse_or_expand(file_id).and_then(ast::MacroItems::cast)\n-                            {\n-                                self.collect_from_item_owner(\n-                                    db,\n-                                    cfg_options,\n-                                    source_map,\n-                                    &item_list,\n-                                    file_id,\n-                                )\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "fa2ef8a1739d19d61b536d76e9a2946495d5663d", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -25,7 +25,7 @@ impl LangItemTarget {\n         Some(match self {\n             LangItemTarget::Enum(e) => e.module(db).krate(),\n             LangItemTarget::Function(f) => f.module(db).krate(),\n-            LangItemTarget::ImplBlock(i) => i.module().krate(),\n+            LangItemTarget::ImplBlock(i) => i.krate(db),\n             LangItemTarget::Static(s) => s.module(db).krate(),\n             LangItemTarget::Struct(s) => s.module(db).krate(),\n             LangItemTarget::Trait(t) => t.module(db).krate(),"}, {"sha": "da33c959152ca3c3aee693878d8939ed5603de8d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -54,12 +54,11 @@ mod test_db;\n #[cfg(test)]\n mod marks;\n \n-use hir_expand::AstId;\n-\n-use crate::{ids::MacroFileKind, resolve::Resolver};\n+use crate::resolve::Resolver;\n \n pub use crate::{\n     adt::VariantDef,\n+    code_model::ImplBlock,\n     code_model::{\n         attrs::{AttrDef, Attrs},\n         docs::{DocDef, Docs, Documentation},\n@@ -72,7 +71,6 @@ pub use crate::{\n     from_source::FromSource,\n     generics::GenericDef,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n-    impl_block::ImplBlock,\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{"}, {"sha": "79b92180a69decda7fd522e265a21c321b48eb8c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -15,9 +15,8 @@ use crate::{\n     db::{DefDatabase, HirDatabase},\n     expr::{ExprScopes, PatId, ScopeId},\n     generics::GenericParams,\n-    impl_block::ImplBlock,\n-    Adt, Const, DefWithBody, Enum, EnumVariant, Function, Local, MacroDef, ModuleDef, PerNs,\n-    Static, Struct, Trait, TypeAlias,\n+    Adt, Const, DefWithBody, Enum, EnumVariant, Function, ImplBlock, Local, MacroDef, ModuleDef,\n+    PerNs, Static, Struct, Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]"}, {"sha": "9aad2d3fe73bced740806125e626803d3e7d09c9", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 22, "deletions": 58, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -5,16 +5,14 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n-    impl_block::{ImplBlock, ImplId},\n     resolve::Resolver,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n-    AssocItem, Crate, Function, Module, Mutability, Name, Trait,\n+    AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n };\n \n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -39,65 +37,46 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    /// To make sense of the CrateModuleIds, we need the source root.\n-    krate: Crate,\n-    impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n+    impls: FxHashMap<TyFingerprint, Vec<ImplBlock>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<ImplBlock>>,\n }\n \n impl CrateImplBlocks {\n-    pub fn lookup_impl_blocks<'a>(&'a self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + 'a {\n+    pub(crate) fn impls_in_crate_query(\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+    ) -> Arc<CrateImplBlocks> {\n+        let mut crate_impl_blocks =\n+            CrateImplBlocks { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n+        if let Some(module) = krate.root_module(db) {\n+            crate_impl_blocks.collect_recursive(db, module);\n+        }\n+        Arc::new(crate_impl_blocks)\n+    }\n+    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + '_ {\n         let fingerprint = TyFingerprint::for_impl(ty);\n-        fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+        fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait<'a>(\n-        &'a self,\n-        tr: Trait,\n-    ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplBlock> + '_ {\n+        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n     }\n \n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n-        self.impls.values().chain(self.impls_by_trait.values()).flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+        self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n \n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        let module_impl_blocks = db.impls_in_module(module);\n-\n-        for (impl_id, _) in module_impl_blocks.impls.iter() {\n-            let impl_block = ImplBlock::from_id(module_impl_blocks.module, impl_id);\n-\n+        for impl_block in module.impl_blocks(db) {\n             let target_ty = impl_block.target_ty(db);\n \n             if impl_block.target_trait(db).is_some() {\n                 if let Some(tr) = impl_block.target_trait_ref(db) {\n-                    self.impls_by_trait\n-                        .entry(tr.trait_)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.id.module_id, impl_id));\n+                    self.impls_by_trait.entry(tr.trait_).or_default().push(impl_block);\n                 }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls\n-                        .entry(target_ty_fp)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.id.module_id, impl_id));\n+                    self.impls.entry(target_ty_fp).or_default().push(impl_block);\n                 }\n             }\n         }\n@@ -106,21 +85,6 @@ impl CrateImplBlocks {\n             self.collect_recursive(db, child);\n         }\n     }\n-\n-    pub(crate) fn impls_in_crate_query(\n-        db: &impl HirDatabase,\n-        krate: Crate,\n-    ) -> Arc<CrateImplBlocks> {\n-        let mut crate_impl_blocks = CrateImplBlocks {\n-            krate,\n-            impls: FxHashMap::default(),\n-            impls_by_trait: FxHashMap::default(),\n-        };\n-        if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n-        }\n-        Arc::new(crate_impl_blocks)\n-    }\n }\n \n fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {"}, {"sha": "68304b950caf834fcc4b511542c890048abb3a3f", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -191,11 +191,11 @@ impl ToChalk for Impl {\n     type Chalk = chalk_ir::ImplId;\n \n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n-        db.intern_impl(self).into()\n+        db.intern_chalk_impl(self).into()\n     }\n \n     fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> Impl {\n-        db.lookup_intern_impl(impl_id.into())\n+        db.lookup_intern_chalk_impl(impl_id.into())\n     }\n }\n \n@@ -630,7 +630,7 @@ fn impl_block_datum(\n         .target_trait_ref(db)\n         .expect(\"FIXME handle unresolved impl block trait ref\")\n         .subst(&bound_vars);\n-    let impl_type = if impl_block.module().krate() == krate {\n+    let impl_type = if impl_block.krate(db) == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External"}, {"sha": "348aca07f13d008ab671b5611b07ae952a713d38", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -8,30 +8,32 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n+    imp::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    DefWithBodyId, EnumId, StructOrUnionId,\n+    DefWithBodyId, EnumId, ImplId, ItemLoc, StructOrUnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n-    fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    fn intern_function(&self, loc: ItemLoc<ast::FnDef>) -> crate::FunctionId;\n     #[salsa::interned]\n-    fn intern_struct_or_union(&self, loc: crate::ItemLoc<ast::StructDef>)\n-        -> crate::StructOrUnionId;\n+    fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> crate::StructOrUnionId;\n     #[salsa::interned]\n-    fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n+    fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> crate::EnumId;\n     #[salsa::interned]\n-    fn intern_const(&self, loc: crate::ItemLoc<ast::ConstDef>) -> crate::ConstId;\n+    fn intern_const(&self, loc: ItemLoc<ast::ConstDef>) -> crate::ConstId;\n     #[salsa::interned]\n-    fn intern_static(&self, loc: crate::ItemLoc<ast::StaticDef>) -> crate::StaticId;\n+    fn intern_static(&self, loc: ItemLoc<ast::StaticDef>) -> crate::StaticId;\n     #[salsa::interned]\n-    fn intern_trait(&self, loc: crate::ItemLoc<ast::TraitDef>) -> crate::TraitId;\n+    fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> crate::TraitId;\n     #[salsa::interned]\n-    fn intern_type_alias(&self, loc: crate::ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+    fn intern_type_alias(&self, loc: ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+    #[salsa::interned]\n+    fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> crate::ImplId;\n }\n \n #[salsa::query_group(DefDatabase2Storage)]\n@@ -54,6 +56,9 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(ImplData::impl_data_query)]\n+    fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n "}, {"sha": "717991c405fac6dd683946c67f5eadecc792ac39", "filename": "crates/ra_hir_def/src/imp.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimp.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -0,0 +1,71 @@\n+//! Defines hir-level representation of impls.\n+//!\n+//! The handling is similar, but is not quite the same as for other items,\n+//! because `impl`s don't have names.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast;\n+\n+use crate::{\n+    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstId, FunctionId, ImplId,\n+    LocationCtx, TypeAliasId,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    target_trait: Option<TypeRef>,\n+    target_type: TypeRef,\n+    items: Vec<AssocItemId>,\n+    negative: bool,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n+        let src = id.source(db);\n+        let items = db.ast_id_map(src.file_id);\n+\n+        let target_trait = src.ast.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.ast.target_type());\n+        let negative = src.ast.is_negative();\n+\n+        let items = if let Some(item_list) = src.ast.item_list() {\n+            let ctx = LocationCtx::new(db, id.module(db), src.file_id);\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => {\n+                        FunctionId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                    ast::ImplItem::ConstDef(it) => {\n+                        ConstId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        TypeAliasId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let res = ImplData { target_trait, target_type, items, negative };\n+        Arc::new(res)\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.target_type\n+    }\n+\n+    pub fn items(&self) -> &[AssocItemId] {\n+        &self.items\n+    }\n+\n+    pub fn is_negative(&self) -> bool {\n+        self.negative\n+    }\n+}"}, {"sha": "0a59c4ad7721ecfe1d455915fe38cd51438c446b", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -13,6 +13,7 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n+pub mod imp;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n@@ -321,6 +322,18 @@ impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImplId(salsa::InternId);\n+impl_intern_key!(ImplId);\n+impl AstItemDef<ast::ImplBlock> for ImplId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ImplBlock>) -> Self {\n+        db.intern_impl(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ImplBlock> {\n+        db.lookup_intern_impl(self)\n+    }\n+}\n+\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n         $(\n@@ -384,3 +397,15 @@ pub enum DefWithBodyId {\n }\n \n impl_froms!(DefWithBodyId: FunctionId, ConstId, StaticId);\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocItemId {\n+    FunctionId(FunctionId),\n+    ConstId(ConstId),\n+    TypeAliasId(TypeAliasId),\n+}\n+// FIXME: not every function, ... is actually an assoc item. maybe we should make\n+// sure that you can only turn actual assoc items into AssocItemIds. This would\n+// require not implementing From, and instead having some checked way of\n+// casting them, and somehow making the constructors private, which would be annoying.\n+impl_froms!(AssocItemId: FunctionId, ConstId, TypeAliasId);"}, {"sha": "49e33ccc4ed8c587c0e5cc30fc711763bbd48063", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -73,7 +73,7 @@ use crate::{\n         diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n     },\n     path::Path,\n-    AstId, CrateModuleId, FunctionId, ModuleDefId, ModuleId, TraitId,\n+    AstId, CrateModuleId, FunctionId, ImplId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -122,6 +122,7 @@ pub struct ModuleData {\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n     pub definition: Option<FileId>,\n+    pub impls: Vec<ImplId>,\n }\n \n #[derive(Default, Debug, PartialEq, Eq, Clone)]"}, {"sha": "c9ccb90239f5261b6d9bdab36b63a585f7a16da6", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -19,7 +19,7 @@ use crate::{\n         per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n+    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId, ImplId,\n     LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, StructOrUnionId, TraitId, TypeAliasId,\n     UnionId,\n };\n@@ -571,6 +571,15 @@ where\n                         .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n                     raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n                     raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+                    raw::RawItemKind::Impl(imp) => {\n+                        let module = ModuleId {\n+                            krate: self.def_collector.def_map.krate,\n+                            module_id: self.module_id,\n+                        };\n+                        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n+                        let imp_id = ImplId::from_ast_id(ctx, self.raw_items[imp].ast_id);\n+                        self.def_collector.def_map.modules[self.module_id].impls.push(imp_id)\n+                    }\n                 }\n             }\n         }"}, {"sha": "a0a2c7273c6b254a86123886fd4a6e396392f0a0", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -28,6 +28,7 @@ pub struct RawItems {\n     imports: Arena<ImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n+    impls: Arena<Impl, ImplData>,\n     /// items for top-level module\n     items: Vec<RawItem>,\n }\n@@ -121,6 +122,13 @@ impl Index<Macro> for RawItems {\n     }\n }\n \n+impl Index<Impl> for RawItems {\n+    type Output = ImplData;\n+    fn index(&self, idx: Impl) -> &ImplData {\n+        &self.impls[idx]\n+    }\n+}\n+\n // Avoid heap allocation on items without attributes.\n type Attrs = Option<Arc<[Attr]>>;\n \n@@ -142,6 +150,7 @@ pub(super) enum RawItemKind {\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n+    Impl(Impl),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -203,6 +212,15 @@ pub(super) struct MacroData {\n     pub(super) builtin: bool,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(super) struct Impl(RawId);\n+impl_arena_id!(Impl);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) struct ImplData {\n+    pub(super) ast_id: FileAstId<ast::ImplBlock>,\n+}\n+\n struct RawItemsCollector {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n@@ -236,8 +254,8 @@ impl RawItemsCollector {\n                 self.add_extern_crate_item(current_module, extern_crate);\n                 return;\n             }\n-            ast::ModuleItem::ImplBlock(_) => {\n-                // impls don't participate in name resolution\n+            ast::ModuleItem::ImplBlock(it) => {\n+                self.add_impl(current_module, it);\n                 return;\n             }\n             ast::ModuleItem::StructDef(it) => {\n@@ -376,6 +394,13 @@ impl RawItemsCollector {\n         self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n \n+    fn add_impl(&mut self, current_module: Option<Module>, imp: ast::ImplBlock) {\n+        let attrs = self.parse_attrs(&imp);\n+        let ast_id = self.source_ast_id_map.ast_id(&imp);\n+        let imp = self.raw_items.impls.alloc(ImplData { ast_id });\n+        self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n+    }\n+\n     fn push_import(\n         &mut self,\n         current_module: Option<Module>,"}, {"sha": "5c9dec13efae0acec8f928bfbdaeaabed31c0228", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -271,7 +271,6 @@ impl RootDatabase {\n         self.query(hir::db::AstIdMapQuery).sweep(sweep);\n \n         self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n-        self.query(hir::db::ImplsInModuleWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);\n \n         self.query(hir::db::ExprScopesQuery).sweep(sweep);\n@@ -314,8 +313,6 @@ impl RootDatabase {\n             hir::db::RawItemsWithSourceMapQuery\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery\n-            hir::db::ImplsInModuleWithSourceMapQuery\n-            hir::db::ImplsInModuleQuery\n             hir::db::GenericParamsQuery\n             hir::db::FnDataQuery\n             hir::db::TypeAliasDataQuery\n@@ -340,6 +337,7 @@ impl RootDatabase {\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n+            hir::db::ImplDataQuery\n             hir::db::TraitSolveQuery\n         ];\n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));"}, {"sha": "00690e44962416056be199811db2bcf5b37e93f6", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1889b3c7b52c1070734dc449d4119c5e5cf991a4/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=1889b3c7b52c1070734dc449d4119c5e5cf991a4", "patch": "@@ -114,8 +114,6 @@ pub(crate) fn classify_name_ref(\n     file_id: FileId,\n     name_ref: &ast::NameRef,\n ) -> Option<NameDefinition> {\n-    use PathResolution::*;\n-\n     let _p = profile(\"classify_name_ref\");\n \n     let parent = name_ref.syntax().parent()?;\n@@ -163,26 +161,26 @@ pub(crate) fn classify_name_ref(\n     let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(db, &path)?;\n     match resolved {\n-        Def(def) => Some(from_module_def(db, def, Some(container))),\n-        AssocItem(item) => Some(from_assoc_item(db, item)),\n-        Local(local) => {\n+        PathResolution::Def(def) => Some(from_module_def(db, def, Some(container))),\n+        PathResolution::AssocItem(item) => Some(from_assoc_item(db, item)),\n+        PathResolution::Local(local) => {\n             let container = local.module(db);\n             let kind = NameKind::Local(local);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n-        GenericParam(par) => {\n+        PathResolution::GenericParam(par) => {\n             // FIXME: get generic param def\n             let kind = NameKind::GenericParam(par);\n             Some(NameDefinition { kind, container, visibility })\n         }\n-        Macro(def) => {\n+        PathResolution::Macro(def) => {\n             let kind = NameKind::Macro(def);\n             Some(NameDefinition { kind, container, visibility })\n         }\n-        SelfType(impl_block) => {\n+        PathResolution::SelfType(impl_block) => {\n             let ty = impl_block.target_ty(db);\n             let kind = NameKind::SelfType(ty);\n-            let container = impl_block.module();\n+            let container = impl_block.module(db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n     }"}]}