{"sha": "c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "node_id": "C_kwDOAAsO6NoAKGM4NGNlYTljMjVlOGRiNzNiMWI1ODBhYjljN2Y3Mjk4NWEwNWRhNGQ", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-10-13T21:14:37Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-01-07T22:55:36Z"}, "message": "Flatten InferredCaptureInformation\n\nMin capture computation can already handle the same place appearing twice,\nand previous commits made CaptureInfo construction very cheap, so just\ndelegate all work to min capture and let InferBorrowKind and\nprocess_collected_capture_information handle everything linearly.", "tree": {"sha": "18ff16b36355329353c11a99bb83d8f9ba523689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ff16b36355329353c11a99bb83d8f9ba523689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "html_url": "https://github.com/rust-lang/rust/commit/c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "html_url": "https://github.com/rust-lang/rust/commit/52db6b9d02a22eb1f54ea5f045d3744c98edd50f"}], "stats": {"total": 276, "additions": 168, "deletions": 108}, "files": [{"sha": "8d3c70b05734fe7be65cb4b90e49ac305d940883", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 67, "deletions": 80, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -33,7 +33,6 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -72,7 +71,7 @@ enum PlaceAncestryRelation {\n /// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n /// during capture analysis. Information in this map feeds into the minimum capture\n /// analysis pass.\n-type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo>;\n+type InferredCaptureInformation<'tcx> = Vec<(Place<'tcx>, ty::CaptureInfo)>;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -258,7 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         capture_kind,\n                     };\n \n-                    capture_information.insert(place, fake_info);\n+                    capture_information.push((place, fake_info));\n                 }\n             }\n \n@@ -384,76 +383,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) -> (InferredCaptureInformation<'tcx>, ty::ClosureKind, Option<(Span, Place<'tcx>)>) {\n-        let mut processed: InferredCaptureInformation<'tcx> = Default::default();\n-\n         let mut closure_kind = ty::ClosureKind::LATTICE_BOTTOM;\n         let mut origin: Option<(Span, Place<'tcx>)> = None;\n \n-        for (place, mut capture_info) in capture_information {\n-            // Apply rules for safety before inferring closure kind\n-            let (place, capture_kind) =\n-                restrict_capture_precision(place, capture_info.capture_kind);\n-            capture_info.capture_kind = capture_kind;\n+        let processed = capture_information\n+            .into_iter()\n+            .map(|(place, mut capture_info)| {\n+                // Apply rules for safety before inferring closure kind\n+                let (place, capture_kind) =\n+                    restrict_capture_precision(place, capture_info.capture_kind);\n \n-            let (place, capture_kind) =\n-                truncate_capture_for_optimization(place, capture_info.capture_kind);\n-            capture_info.capture_kind = capture_kind;\n+                let (place, capture_kind) = truncate_capture_for_optimization(place, capture_kind);\n \n-            let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n-                self.tcx.hir().span(usage_expr)\n-            } else {\n-                unreachable!()\n-            };\n+                let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n+                    self.tcx.hir().span(usage_expr)\n+                } else {\n+                    unreachable!()\n+                };\n \n-            let updated = match capture_info.capture_kind {\n-                ty::UpvarCapture::ByValue => match closure_kind {\n-                    ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                        (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n-                    }\n-                    // If closure is already FnOnce, don't update\n-                    ty::ClosureKind::FnOnce => (closure_kind, origin),\n-                },\n+                let updated = match capture_kind {\n+                    ty::UpvarCapture::ByValue => match closure_kind {\n+                        ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                            (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n+                        }\n+                        // If closure is already FnOnce, don't update\n+                        ty::ClosureKind::FnOnce => (closure_kind, origin.take()),\n+                    },\n \n-                ty::UpvarCapture::ByRef(\n-                    ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                ) => {\n-                    match closure_kind {\n-                        ty::ClosureKind::Fn => {\n-                            (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                    ty::UpvarCapture::ByRef(\n+                        ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                    ) => {\n+                        match closure_kind {\n+                            ty::ClosureKind::Fn => {\n+                                (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                            }\n+                            // Don't update the origin\n+                            ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => {\n+                                (closure_kind, origin.take())\n+                            }\n                         }\n-                        // Don't update the origin\n-                        ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => (closure_kind, origin),\n                     }\n-                }\n-\n-                _ => (closure_kind, origin),\n-            };\n \n-            closure_kind = updated.0;\n-            origin = updated.1;\n+                    _ => (closure_kind, origin.take()),\n+                };\n \n-            let (place, capture_kind) = match capture_clause {\n-                hir::CaptureBy::Value => adjust_for_move_closure(place, capture_info.capture_kind),\n-                hir::CaptureBy::Ref => {\n-                    adjust_for_non_move_closure(place, capture_info.capture_kind)\n-                }\n-            };\n+                closure_kind = updated.0;\n+                origin = updated.1;\n \n-            // This restriction needs to be applied after we have handled adjustments for `move`\n-            // closures. We want to make sure any adjustment that might make us move the place into\n-            // the closure gets handled.\n-            let (place, capture_kind) =\n-                restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n+                let (place, capture_kind) = match capture_clause {\n+                    hir::CaptureBy::Value => adjust_for_move_closure(place, capture_kind),\n+                    hir::CaptureBy::Ref => adjust_for_non_move_closure(place, capture_kind),\n+                };\n \n-            capture_info.capture_kind = capture_kind;\n+                // This restriction needs to be applied after we have handled adjustments for `move`\n+                // closures. We want to make sure any adjustment that might make us move the place into\n+                // the closure gets handled.\n+                let (place, capture_kind) =\n+                    restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n \n-            let capture_info = if let Some(existing) = processed.get(&place) {\n-                determine_capture_info(*existing, capture_info)\n-            } else {\n-                capture_info\n-            };\n-            processed.insert(place, capture_info);\n-        }\n+                capture_info.capture_kind = capture_kind;\n+                (place, capture_info)\n+            })\n+            .collect();\n \n         (processed, closure_kind, origin)\n     }\n@@ -609,8 +600,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !descendant_found {\n                 for possible_ancestor in min_cap_list.iter_mut() {\n                     match determine_place_ancestry_relation(&place, &possible_ancestor.place) {\n+                        PlaceAncestryRelation::SamePlace => {\n+                            ancestor_found = true;\n+                            possible_ancestor.info = determine_capture_info(\n+                                possible_ancestor.info,\n+                                updated_capture_info,\n+                            );\n+\n+                            // Only one related place will be in the list.\n+                            break;\n+                        }\n                         // current place is descendant of possible_ancestor\n-                        PlaceAncestryRelation::Descendant | PlaceAncestryRelation::SamePlace => {\n+                        PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n                             let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n \n@@ -630,7 +631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // we need to keep the ancestor's `path_expr_id`\n                             possible_ancestor.info.path_expr_id = backup_path_expr_id;\n \n-                            // Only one ancestor of the current place will be in the list.\n+                            // Only one related place will be in the list.\n                             break;\n                         }\n                         _ => {}\n@@ -1532,7 +1533,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn log_capture_analysis_first_pass(\n         &self,\n         closure_def_id: rustc_hir::def_id::DefId,\n-        capture_information: &FxIndexMap<Place<'tcx>, ty::CaptureInfo>,\n+        capture_information: &InferredCaptureInformation<'tcx>,\n         closure_span: Span,\n     ) {\n         if self.should_log_capture_analysis(closure_def_id) {\n@@ -1759,20 +1760,6 @@ struct InferBorrowKind<'a, 'tcx> {\n     fake_reads: Vec<(Place<'tcx>, FakeReadCause, hir::HirId)>,\n }\n \n-impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n-    fn adjust_capture_info(&mut self, place: Place<'tcx>, capture_info: ty::CaptureInfo) {\n-        match self.capture_information.get_mut(&place) {\n-            Some(curr_info) => {\n-                *curr_info = determine_capture_info(*curr_info, capture_info);\n-            }\n-            None => {\n-                debug!(\"Capturing new place {:?}, capture_info={:?}\", place, capture_info);\n-                self.capture_information.insert(place, capture_info);\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n         let PlaceBase::Upvar(_) = place.base else { return };\n@@ -1797,14 +1784,14 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else { return };\n         assert_eq!(self.closure_def_id, upvar_id.closure_expr_id);\n \n-        self.adjust_capture_info(\n+        self.capture_information.push((\n             place_with_id.place.clone(),\n             ty::CaptureInfo {\n                 capture_kind_expr_id: Some(diag_expr_id),\n                 path_expr_id: Some(diag_expr_id),\n                 capture_kind: ty::UpvarCapture::ByValue,\n             },\n-        );\n+        ));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -1835,14 +1822,14 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n         }\n \n-        self.adjust_capture_info(\n+        self.capture_information.push((\n             place,\n             ty::CaptureInfo {\n                 capture_kind_expr_id: Some(diag_expr_id),\n                 path_expr_id: Some(diag_expr_id),\n                 capture_kind,\n             },\n-        );\n+        ));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "2bcbd792e3a834186f1a86a1eb420fe1e21ed468", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -15,6 +15,7 @@ fn main() {\n         //~^ NOTE: Capturing m[] -> MutBorrow\n         //~| NOTE: Min Capture m[] -> MutBorrow\n         m[1] += 40;\n+        //~^ NOTE: Capturing m[] -> MutBorrow\n     };\n \n     c();"}, {"sha": "129b26456ce1d5a6fd6abed645cac3303100c3f4", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -15,7 +15,7 @@ LL | |\n LL | |\n LL | |         m[0] += 10;\n ...  |\n-LL | |         m[1] += 40;\n+LL | |\n LL | |     };\n    | |_____^\n    |\n@@ -24,6 +24,11 @@ note: Capturing m[] -> MutBorrow\n    |\n LL |         m[0] += 10;\n    |         ^\n+note: Capturing m[] -> MutBorrow\n+  --> $DIR/arrays-completely-captured.rs:17:9\n+   |\n+LL |         m[1] += 40;\n+   |         ^\n \n error: Min Capture analysis includes:\n   --> $DIR/arrays-completely-captured.rs:11:5\n@@ -33,7 +38,7 @@ LL | |\n LL | |\n LL | |         m[0] += 10;\n ...  |\n-LL | |         m[1] += 40;\n+LL | |\n LL | |     };\n    | |_____^\n    |"}, {"sha": "6c65a7bf87b96c4aa6c4884175315f7092acb7d5", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -15,6 +15,8 @@ fn arrays() {\n     //~| ERROR: Min Capture analysis includes:\n         let [a, b, .., e] = arr;\n         //~^ NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Capturing arr[Index] -> ByValue\n         //~| NOTE: Min Capture arr[] -> ByValue\n         assert_eq!(a, \"A\");\n         assert_eq!(b, \"B\");"}, {"sha": "44fbe6d8158f221c07538151a3b2a0d4422fbf84", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.stderr", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -8,7 +8,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure_patterns.rs:36:13\n+  --> $DIR/destructure_patterns.rs:38:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/destructure_patterns.rs:56:13\n+  --> $DIR/destructure_patterns.rs:58:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,6 +42,16 @@ note: Capturing arr[Index] -> ByValue\n    |\n LL |         let [a, b, .., e] = arr;\n    |                             ^^^\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/destructure_patterns.rs:16:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/destructure_patterns.rs:16:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n \n error: Min Capture analysis includes:\n   --> $DIR/destructure_patterns.rs:13:5\n@@ -62,7 +72,7 @@ LL |         let [a, b, .., e] = arr;\n    |                             ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/destructure_patterns.rs:39:5\n+  --> $DIR/destructure_patterns.rs:41:5\n    |\n LL | /     || {\n LL | |\n@@ -74,18 +84,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing p[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n note: Capturing p[(2, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n \n error: Min Capture analysis includes:\n-  --> $DIR/destructure_patterns.rs:39:5\n+  --> $DIR/destructure_patterns.rs:41:5\n    |\n LL | /     || {\n LL | |\n@@ -97,18 +107,18 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture p[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n note: Min Capture p[(2, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:42:58\n+  --> $DIR/destructure_patterns.rs:44:58\n    |\n LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n    |                                                          ^\n \n error: First Pass analysis includes:\n-  --> $DIR/destructure_patterns.rs:59:5\n+  --> $DIR/destructure_patterns.rs:61:5\n    |\n LL | /     || {\n LL | |\n@@ -120,23 +130,23 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing t[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Capturing t[(2, 0),(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n \n error: Min Capture analysis includes:\n-  --> $DIR/destructure_patterns.rs:59:5\n+  --> $DIR/destructure_patterns.rs:61:5\n    |\n LL | /     || {\n LL | |\n@@ -148,17 +158,17 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture t[(0, 0)] -> MutBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^\n note: Min Capture t[(2, 0),(0, 0)] -> ByValue\n-  --> $DIR/destructure_patterns.rs:62:54\n+  --> $DIR/destructure_patterns.rs:64:54\n    |\n LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n    |                                                      ^"}, {"sha": "46b54846e32ebdc1960692c7ca0204bec7ac94f6", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/union.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -0,0 +1,25 @@\n+// edition:2021\n+\n+// Test that we point to the correct location that results a union being captured.\n+// Union is special because it can't be disjointly captured.\n+\n+union A {\n+    y: u32,\n+    x: (),\n+}\n+\n+fn main() {\n+    let mut a = A { y: 1 };\n+    let mut c = || {\n+    //~^ borrow of `a.y` occurs here\n+        let _ = unsafe { &a.y };\n+        let _ = &mut a;\n+        //~^ borrow occurs due to use in closure\n+        let _ = unsafe { &mut a.y };\n+    };\n+    a.y = 1;\n+    //~^ cannot assign to `a.y` because it is borrowed [E0506]\n+    //~| assignment to borrowed `a.y` occurs here\n+    c();\n+    //~^ borrow later used here\n+}"}, {"sha": "7c34e2336c867487444c10479c9d8b43e81cfad8", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/union.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Funion.stderr?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -0,0 +1,18 @@\n+error[E0506]: cannot assign to `a.y` because it is borrowed\n+  --> $DIR/union.rs:20:5\n+   |\n+LL |     let mut c = || {\n+   |                 -- borrow of `a.y` occurs here\n+...\n+LL |         let _ = &mut a;\n+   |                      - borrow occurs due to use in closure\n+...\n+LL |     a.y = 1;\n+   |     ^^^^^^^ assignment to borrowed `a.y` occurs here\n+...\n+LL |     c();\n+   |     - borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "22eae744b80806b57b3d9ceff67e23f95d3d265a", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -40,6 +40,7 @@ fn main() {\n         //~| NOTE: Min Capture p[(1, 0)] -> MutBorrow\n         c2();\n         println!(\"{}\", p.y);\n+        //~^ NOTE: Capturing p[(1, 0)] -> ImmBorrow\n     };\n \n     c1();"}, {"sha": "a50d0c6a182bc5f393668d272012648120311532", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -58,7 +58,7 @@ LL | |\n LL | |\n LL | |         println!(\"{}\", p.x);\n ...  |\n-LL | |         println!(\"{}\", p.y);\n+LL | |\n LL | |     };\n    | |_____^\n    |\n@@ -72,6 +72,11 @@ note: Capturing p[(1, 0)] -> MutBorrow\n    |\n LL |         || p.y += incr;\n    |            ^^^\n+note: Capturing p[(1, 0)] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:42:24\n+   |\n+LL |         println!(\"{}\", p.y);\n+   |                        ^^^\n \n error: Min Capture analysis includes:\n   --> $DIR/nested-closure.rs:22:5\n@@ -81,7 +86,7 @@ LL | |\n LL | |\n LL | |         println!(\"{}\", p.x);\n ...  |\n-LL | |         println!(\"{}\", p.y);\n+LL | |\n LL | |     };\n    | |_____^\n    |"}, {"sha": "3ed780f51c73b6b6f4a54130faccad04c9afbdfc", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -48,6 +48,7 @@ fn test_alignment_affected() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let z1: &String = &foo.x;\n+        //~^ NOTE: Capturing foo[] -> ImmBorrow\n         let z2: &mut u16 = &mut foo.y;\n         //~^ NOTE: Capturing foo[] -> MutBorrow\n         //~| NOTE: Min Capture foo[] -> MutBorrow"}, {"sha": "580061ebc6ed900c675df833ae6988d13f564d40", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84cea9c25e8db73b1b580ab9c7f72985a05da4d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr?ref=c84cea9c25e8db73b1b580ab9c7f72985a05da4d", "patch": "@@ -17,7 +17,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/repr_packed.rs:78:13\n+  --> $DIR/repr_packed.rs:79:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -83,8 +83,13 @@ LL | |         println!(\"({}, {})\", z1, z2);\n LL | |     };\n    | |_____^\n    |\n+note: Capturing foo[] -> ImmBorrow\n+  --> $DIR/repr_packed.rs:50:28\n+   |\n+LL |         let z1: &String = &foo.x;\n+   |                            ^^^^^\n note: Capturing foo[] -> MutBorrow\n-  --> $DIR/repr_packed.rs:51:33\n+  --> $DIR/repr_packed.rs:52:33\n    |\n LL |         let z2: &mut u16 = &mut foo.y;\n    |                                 ^^^^^\n@@ -102,13 +107,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture foo[] -> MutBorrow\n-  --> $DIR/repr_packed.rs:51:33\n+  --> $DIR/repr_packed.rs:52:33\n    |\n LL |         let z2: &mut u16 = &mut foo.y;\n    |                                 ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/repr_packed.rs:81:5\n+  --> $DIR/repr_packed.rs:82:5\n    |\n LL | /     || {\n LL | |\n@@ -120,18 +125,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing foo[] -> ImmBorrow\n-  --> $DIR/repr_packed.rs:84:24\n+  --> $DIR/repr_packed.rs:85:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^\n note: Capturing foo[(0, 0)] -> ByValue\n-  --> $DIR/repr_packed.rs:88:18\n+  --> $DIR/repr_packed.rs:89:18\n    |\n LL |         let _z = foo.x;\n    |                  ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/repr_packed.rs:81:5\n+  --> $DIR/repr_packed.rs:82:5\n    |\n LL | /     || {\n LL | |\n@@ -143,7 +148,7 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture foo[] -> ByValue\n-  --> $DIR/repr_packed.rs:84:24\n+  --> $DIR/repr_packed.rs:85:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^ foo[] used here"}]}