{"sha": "d257b376084ce18ae351e1f89989e36433515d24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNTdiMzc2MDg0Y2UxOGFlMzUxZTFmODk5ODllMzY0MzM1MTVkMjQ=", "commit": {"author": {"name": "John Kleint", "email": "jk@hinge.co", "date": "2014-10-22T03:30:09Z"}, "committer": {"name": "John Kleint", "email": "jk@hinge.co", "date": "2014-10-27T03:41:51Z"}, "message": "Guide: motivate Box and Rc pointers with need, uses, benefits, and examples.\n\nExplain that Rust has different pointer types because there is a\ntradeoff between flexibility and efficiency. Motivate boxes as\nfixed-size containers of variable-sized objects. Clarify that Box and Rc\nare pointer types that you deref with * just like references. Stick to\nexplaining the semantics and avoid implementation details.  Scope isn't\nthe most accurate framework to think about deallocation (since you\nreturn boxes and otherwise move values out of scopes); it's more \"when\nthe value is done being used,\" i.e., lifetime. Provide a connection\nbetween Rust's pointer types by locating them on a flexibiltiy /\nperformance scale. Explain the compiler can't statically analyze\nlifetimes with multiple owners; hence the need for (runtime) reference\ncounting.", "tree": {"sha": "b3ba06d972b39e1c32ed39f7e3b35cb1f5c28a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3ba06d972b39e1c32ed39f7e3b35cb1f5c28a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d257b376084ce18ae351e1f89989e36433515d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d257b376084ce18ae351e1f89989e36433515d24", "html_url": "https://github.com/rust-lang/rust/commit/d257b376084ce18ae351e1f89989e36433515d24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d257b376084ce18ae351e1f89989e36433515d24/comments", "author": null, "committer": null, "parents": [{"sha": "f037452447f5f46deb26e1c483fe88fb51a19198", "url": "https://api.github.com/repos/rust-lang/rust/commits/f037452447f5f46deb26e1c483fe88fb51a19198", "html_url": "https://github.com/rust-lang/rust/commit/f037452447f5f46deb26e1c483fe88fb51a19198"}], "stats": {"total": 122, "additions": 78, "deletions": 44}, "files": [{"sha": "2a74eba0c3326bad2634c306543c2b3c9150208a", "filename": "src/doc/guide.md", "status": "modified", "additions": 78, "deletions": 44, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d257b376084ce18ae351e1f89989e36433515d24/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/d257b376084ce18ae351e1f89989e36433515d24/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=d257b376084ce18ae351e1f89989e36433515d24", "patch": "@@ -3637,40 +3637,72 @@ pub fn as_maybe_owned(&self) -> MaybeOwned<'a> { ... }\n \n ## Boxes\n \n-All of our references so far have been to variables we've created on the stack.\n-In Rust, the simplest way to allocate heap variables is using a *box*.  To\n-create a box, use the `box` keyword:\n+Most of the types we've seen so far have a fixed size or number of components.\n+The compiler needs this fact to lay out values in memory. However, some data\n+structures, such as a linked list, do not have a fixed size. You might think to\n+implement a linked list with an enum that's either a `Node` or the end of the\n+list (`Nil`), like this:\n+\n+```{rust,ignore}\n+enum List {             // error: illegal recursive enum type\n+    Node(u32, List),\n+    Nil\n+}\n+```\n+\n+But the compiler complains that the type is recursive, that is, it could be\n+arbitrarily large. To remedy this, Rust provides a fixed-size container called\n+a **box** that can hold any type. You can box up any value with the `box`\n+keyword. Our boxed List gets the type `Box<List>` (more on the notation when we\n+get to generics):\n \n ```{rust}\n-let x = box 5i;\n+enum List {\n+    Node(u32, Box<List>),\n+    Nil\n+}\n+\n+fn main() {\n+    let list = Node(0, box Node(1, box Nil));\n+}\n ```\n \n-This allocates an integer `5` on the heap, and creates a binding `x` that\n-refers to it. The great thing about boxed pointers is that we don't have to\n-manually free this allocation! If we write\n+A box dynamically allocates memory to hold its contents. The great thing about\n+Rust is that that memory is *automatically*, *efficiently*, and *predictably*\n+deallocated when you're done with the box.\n+\n+A box is a pointer type, and you access what's inside using the `*` operator,\n+just like regular references. This (rather silly) example dynamically allocates\n+an integer `5` and makes `x` a pointer to it:\n \n ```{rust}\n {\n     let x = box 5i;\n-    // do stuff\n+    println!(\"{}\", *x);     // Prints 5\n }\n ```\n \n-then Rust will automatically free `x` at the end of the block. This isn't\n-because Rust has a garbage collector -- it doesn't. Instead, when `x` goes out\n-of scope, Rust `free`s `x`. This Rust code will do the same thing as the\n-following C code:\n+The great thing about boxes is that we don't have to manually free this\n+allocation! Instead, when `x` reaches the end of its lifetime -- in this case,\n+when it goes out of scope at the end of the block -- Rust `free`s `x`. This\n+isn't because Rust has a garbage collector (it doesn't). Instead, by tracking\n+the ownership and lifetime of a variable (with a little help from you, the\n+programmer), the compiler knows precisely when it is no longer used.\n+\n+The Rust code above will do the same thing as the following C code:\n \n ```{c,ignore}\n {\n     int *x = (int *)malloc(sizeof(int));\n-    // do stuff\n+    if (!x) abort();\n+    *x = 5;\n+    printf(\"%d\\n\", *x);\n     free(x);\n }\n ```\n \n-This means we get the benefits of manual memory management, but the compiler\n-ensures that we don't do something wrong. We can't forget to `free` our memory.\n+We get the benefits of manual memory management, while ensuring we don't\n+introduce any bugs. We can't forget to `free` our memory.\n \n Boxes are the sole owner of their contents, so you cannot take a mutable\n reference to them and then use the original box:\n@@ -3706,48 +3738,50 @@ let mut x = box 5i;\n *x;\n ```\n \n-## Rc and Arc\n-\n-Sometimes, you need to allocate something on the heap, but give out multiple\n-references to the memory. Rust's `Rc<T>` (pronounced 'arr cee tee') and\n-`Arc<T>` types (again, the `T` is for generics, we'll learn more later) provide\n-you with this ability.  **Rc** stands for 'reference counted,' and **Arc** for\n-'atomically reference counted.' This is how Rust keeps track of the multiple\n-owners: every time we make a new reference to the `Rc<T>`, we add one to its\n-internal 'reference count.' Every time a reference goes out of scope, we\n-subtract one from the count. When the count is zero, the `Rc<T>` can be safely\n-deallocated. `Arc<T>` is almost identical to `Rc<T>`, except for one thing: The\n-'atomically' in 'Arc' means that increasing and decreasing the count uses a\n-thread-safe mechanism to do so. Why two types? `Rc<T>` is faster, so if you're\n-not in a multi-threaded scenario, you can have that advantage. Since we haven't\n-talked about threading yet in Rust, we'll show you `Rc<T>` for the rest of this\n-section.\n+Boxes are simple and efficient pointers to dynamically allocated values with a\n+single owner. They are useful for tree-like structures where the lifetime of a\n+child depends solely on the lifetime of its (single) parent. If you need a\n+value that must persist as long as any of several referrers, read on.\n \n-To create an `Rc<T>`, use `Rc::new()`:\n+## Rc and Arc\n \n-```{rust}\n-use std::rc::Rc;\n+Sometimes, you need a variable that is referenced from multiple places\n+(immutably!), lasting as long as any of those places, and disappearing when it\n+is no longer referenced. For instance, in a graph-like data structure, a node\n+might be referenced from all of its neighbors. In this case, it is not possible\n+for the compiler to determine ahead of time when the value can be freed -- it\n+needs a little run-time support.\n \n-let x = Rc::new(5i);\n-```\n+Rust's **Rc** type provides shared ownership of a dynamically allocated value\n+that is automatically freed at the end of its last owner's lifetime. (`Rc`\n+stands for 'reference counted,' referring to the way these library types are\n+implemented.) This provides more flexibility than single-owner boxes, but has\n+some runtime overhead.\n \n-To create a second reference, use the `.clone()` method:\n+To create an `Rc` value, use `Rc::new()`. To create a second owner, use the\n+`.clone()` method:\n \n ```{rust}\n use std::rc::Rc;\n \n let x = Rc::new(5i);\n let y = x.clone();\n+\n+println!(\"{} {}\", *x, *y);      // Prints 5 5\n ```\n \n-The `Rc<T>` will live as long as any of its references are alive. After they\n-all go out of scope, the memory will be `free`d.\n+The `Rc` will live as long as any of its owners are alive. After that, the\n+memory will be `free`d.\n+\n+**Arc** is an 'atomically reference counted' value, identical to `Rc` except\n+that ownership can be safely shared among multiple threads. Why two types?\n+`Arc` has more overhead, so if you're not in a multi-threaded scenario, you\n+don't have to pay the price.\n \n-If you use `Rc<T>` or `Arc<T>`, you have to be careful about introducing\n-cycles. If you have two `Rc<T>`s that point to each other, the reference counts\n-will never drop to zero, and you'll have a memory leak. To learn more, check\n-out [the section on `Rc<T>` and `Arc<T>` in the pointers\n-guide](guide-pointers.html#rc-and-arc).\n+If you use `Rc` or `Arc`, you have to be careful about introducing cycles. If\n+you have two `Rc`s that point to each other, they will happily keep each other\n+alive forever, creating a memory leak. To learn more, check out [the section on\n+`Rc` and `Arc` in the pointers guide](guide-pointers.html#rc-and-arc).\n \n # Patterns\n "}]}