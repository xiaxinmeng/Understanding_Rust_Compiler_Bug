{"sha": "29856180a8ba8e0d217d2df1bd4e8de0efe293f7", "node_id": "C_kwDOAAsO6NoAKDI5ODU2MTgwYThiYThlMGQyMTdkMmRmMWJkNGU4ZGUwZWZlMjkzZjc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-05T13:35:33Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-05T13:41:24Z"}, "message": "Simplify ReplacementMap.", "tree": {"sha": "74276f748bb9ca1b4923ffef0415cca34ea1f9c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74276f748bb9ca1b4923ffef0415cca34ea1f9c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29856180a8ba8e0d217d2df1bd4e8de0efe293f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29856180a8ba8e0d217d2df1bd4e8de0efe293f7", "html_url": "https://github.com/rust-lang/rust/commit/29856180a8ba8e0d217d2df1bd4e8de0efe293f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29856180a8ba8e0d217d2df1bd4e8de0efe293f7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e05ab04e54f2531198bb61c32ad2232d682a63c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e05ab04e54f2531198bb61c32ad2232d682a63c", "html_url": "https://github.com/rust-lang/rust/commit/8e05ab04e54f2531198bb61c32ad2232d682a63c"}], "stats": {"total": 193, "additions": 109, "deletions": 84}, "files": [{"sha": "26acd406ed8a9f81616240e55d6b533d680ed79c", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 109, "deletions": 84, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/29856180a8ba8e0d217d2df1bd4e8de0efe293f7/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29856180a8ba8e0d217d2df1bd4e8de0efe293f7/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=29856180a8ba8e0d217d2df1bd4e8de0efe293f7", "patch": "@@ -1,11 +1,10 @@\n use crate::MirPass;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{excluded_locals, iter_fields};\n \n pub struct ScalarReplacementOfAggregates;\n@@ -26,13 +25,13 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n             let replacements = compute_flattening(tcx, body, escaping);\n             debug!(?replacements);\n             let all_dead_locals = replace_flattened_locals(tcx, body, replacements);\n-            if !all_dead_locals.is_empty() && tcx.sess.mir_opt_level() >= 4 {\n+            if !all_dead_locals.is_empty() {\n                 for local in excluded.indices() {\n-                    excluded[local] |= all_dead_locals.contains(local) ;\n+                    excluded[local] |= all_dead_locals.contains(local);\n                 }\n                 excluded.raw.resize(body.local_decls.len(), false);\n             } else {\n-                break\n+                break;\n             }\n         }\n     }\n@@ -111,36 +110,29 @@ fn escaping_locals(excluded: &IndexVec<Local, bool>, body: &Body<'_>) -> BitSet<\n \n #[derive(Default, Debug)]\n struct ReplacementMap<'tcx> {\n-    fields: FxIndexMap<PlaceRef<'tcx>, Local>,\n     /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n     /// and deinit statement and debuginfo.\n-    fragments: IndexVec<Local, Option<Vec<(&'tcx [PlaceElem<'tcx>], Local)>>>,\n+    fragments: IndexVec<Local, Option<IndexVec<Field, Option<(Ty<'tcx>, Local)>>>>,\n }\n \n impl<'tcx> ReplacementMap<'tcx> {\n-    fn gather_debug_info_fragments(\n-        &self,\n-        place: PlaceRef<'tcx>,\n-    ) -> Option<Vec<VarDebugInfoFragment<'tcx>>> {\n-        let mut fragments = Vec::new();\n-        let Some(parts) = &self.fragments[place.local] else { return None };\n-        for (proj, replacement_local) in parts {\n-            if proj.starts_with(place.projection) {\n-                fragments.push(VarDebugInfoFragment {\n-                    projection: proj[place.projection.len()..].to_vec(),\n-                    contents: Place::from(*replacement_local),\n-                });\n-            }\n-        }\n-        Some(fragments)\n+    fn replace_place(&self, tcx: TyCtxt<'tcx>, place: PlaceRef<'tcx>) -> Option<Place<'tcx>> {\n+        let &[PlaceElem::Field(f, _), ref rest @ ..] = place.projection else { return None; };\n+        let fields = self.fragments[place.local].as_ref()?;\n+        let (_, new_local) = fields[f]?;\n+        Some(Place { local: new_local, projection: tcx.intern_place_elems(&rest) })\n     }\n \n     fn place_fragments(\n         &self,\n         place: Place<'tcx>,\n-    ) -> Option<&Vec<(&'tcx [PlaceElem<'tcx>], Local)>> {\n+    ) -> Option<impl Iterator<Item = (Field, Ty<'tcx>, Local)> + '_> {\n         let local = place.as_local()?;\n-        self.fragments[local].as_ref()\n+        let fields = self.fragments[local].as_ref()?;\n+        Some(fields.iter_enumerated().filter_map(|(field, &opt_ty_local)| {\n+            let (ty, local) = opt_ty_local?;\n+            Some((field, ty, local))\n+        }))\n     }\n }\n \n@@ -153,8 +145,7 @@ fn compute_flattening<'tcx>(\n     body: &mut Body<'tcx>,\n     escaping: BitSet<Local>,\n ) -> ReplacementMap<'tcx> {\n-    let mut fields = FxIndexMap::default();\n-    let mut fragments = IndexVec::from_elem(None::<Vec<_>>, &body.local_decls);\n+    let mut fragments = IndexVec::from_elem(None, &body.local_decls);\n \n     for local in body.local_decls.indices() {\n         if escaping.contains(local) {\n@@ -169,14 +160,10 @@ fn compute_flattening<'tcx>(\n             };\n             let new_local =\n                 body.local_decls.push(LocalDecl { ty: field_ty, user_ty: None, ..decl.clone() });\n-            let place = Place::from(local)\n-                .project_deeper(&[PlaceElem::Field(field, field_ty)], tcx)\n-                .as_ref();\n-            fields.insert(place, new_local);\n-            fragments[local].get_or_insert_default().push((place.projection, new_local));\n+            fragments.get_or_insert_with(local, IndexVec::new).insert(field, (field_ty, new_local));\n         });\n     }\n-    ReplacementMap { fields, fragments }\n+    ReplacementMap { fragments }\n }\n \n /// Perform the replacement computed by `compute_flattening`.\n@@ -186,8 +173,10 @@ fn replace_flattened_locals<'tcx>(\n     replacements: ReplacementMap<'tcx>,\n ) -> BitSet<Local> {\n     let mut all_dead_locals = BitSet::new_empty(body.local_decls.len());\n-    for p in replacements.fields.keys() {\n-        all_dead_locals.insert(p.local);\n+    for (local, replacements) in replacements.fragments.iter_enumerated() {\n+        if replacements.is_some() {\n+            all_dead_locals.insert(local);\n+        }\n     }\n     debug!(?all_dead_locals);\n     if all_dead_locals.is_empty() {\n@@ -197,7 +186,7 @@ fn replace_flattened_locals<'tcx>(\n     let mut visitor = ReplacementVisitor {\n         tcx,\n         local_decls: &body.local_decls,\n-        replacements,\n+        replacements: &replacements,\n         all_dead_locals,\n         patch: MirPatch::new(body),\n     };\n@@ -223,21 +212,23 @@ struct ReplacementVisitor<'tcx, 'll> {\n     /// This is only used to compute the type for `VarDebugInfoContents::Composite`.\n     local_decls: &'ll LocalDecls<'tcx>,\n     /// Work to do.\n-    replacements: ReplacementMap<'tcx>,\n+    replacements: &'ll ReplacementMap<'tcx>,\n     /// This is used to check that we are not leaving references to replaced locals behind.\n     all_dead_locals: BitSet<Local>,\n     patch: MirPatch<'tcx>,\n }\n \n-impl<'tcx, 'll> ReplacementVisitor<'tcx, 'll> {\n-    fn replace_place(&self, place: PlaceRef<'tcx>) -> Option<Place<'tcx>> {\n-        if let &[PlaceElem::Field(..), ref rest @ ..] = place.projection {\n-            let pr = PlaceRef { local: place.local, projection: &place.projection[..1] };\n-            let local = self.replacements.fields.get(&pr)?;\n-            Some(Place { local: *local, projection: self.tcx.intern_place_elems(&rest) })\n-        } else {\n-            None\n+impl<'tcx> ReplacementVisitor<'tcx, '_> {\n+    fn gather_debug_info_fragments(&self, local: Local) -> Option<Vec<VarDebugInfoFragment<'tcx>>> {\n+        let mut fragments = Vec::new();\n+        let parts = self.replacements.place_fragments(local.into())?;\n+        for (field, ty, replacement_local) in parts {\n+            fragments.push(VarDebugInfoFragment {\n+                projection: vec![PlaceElem::Field(field, ty)],\n+                contents: Place::from(replacement_local),\n+            });\n         }\n+        Some(fragments)\n     }\n }\n \n@@ -246,21 +237,30 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n         self.tcx\n     }\n \n+    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n+        if let Some(repl) = self.replacements.replace_place(self.tcx, place.as_ref()) {\n+            *place = repl\n+        } else {\n+            self.super_place(place, context, location)\n+        }\n+    }\n+\n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         match statement.kind {\n+            // Duplicate storage and deinit statements, as they pretty much apply to all fields.\n             StatementKind::StorageLive(l) => {\n-                if let Some(final_locals) = &self.replacements.fragments[l] {\n-                    for &(_, fl) in final_locals {\n+                if let Some(final_locals) = self.replacements.place_fragments(l.into()) {\n+                    for (_, _, fl) in final_locals {\n                         self.patch.add_statement(location, StatementKind::StorageLive(fl));\n                     }\n                     statement.make_nop();\n                 }\n                 return;\n             }\n             StatementKind::StorageDead(l) => {\n-                if let Some(final_locals) = &self.replacements.fragments[l] {\n-                    for &(_, fl) in final_locals {\n+                if let Some(final_locals) = self.replacements.place_fragments(l.into()) {\n+                    for (_, _, fl) in final_locals {\n                         self.patch.add_statement(location, StatementKind::StorageDead(fl));\n                     }\n                     statement.make_nop();\n@@ -269,7 +269,7 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n             }\n             StatementKind::Deinit(box place) => {\n                 if let Some(final_locals) = self.replacements.place_fragments(place) {\n-                    for &(_, fl) in final_locals {\n+                    for (_, _, fl) in final_locals {\n                         self.patch\n                             .add_statement(location, StatementKind::Deinit(Box::new(fl.into())));\n                     }\n@@ -278,48 +278,80 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                 }\n             }\n \n-            StatementKind::Assign(box (place, Rvalue::Aggregate(_, ref operands))) => {\n-                if let Some(final_locals) = self.replacements.place_fragments(place) {\n-                    for &(projection, fl) in final_locals {\n-                        let &[PlaceElem::Field(index, _)] = projection else { bug!() };\n-                        let index = index.as_usize();\n-                        let rvalue = Rvalue::Use(operands[index].clone());\n-                        self.patch.add_statement(\n-                            location,\n-                            StatementKind::Assign(Box::new((fl.into(), rvalue))),\n-                        );\n+            // We have `a = Struct { 0: x, 1: y, .. }`.\n+            // We replace it by\n+            // ```\n+            // a_0 = x\n+            // a_1 = y\n+            // ...\n+            // ```\n+            StatementKind::Assign(box (place, Rvalue::Aggregate(_, ref mut operands))) => {\n+                if let Some(local) = place.as_local()\n+                    && let Some(final_locals) = &self.replacements.fragments[local]\n+                {\n+                    // This is ok as we delete the statement later.\n+                    let operands = std::mem::take(operands);\n+                    for (&opt_ty_local, mut operand) in final_locals.iter().zip(operands) {\n+                        if let Some((_, new_local)) = opt_ty_local {\n+                            // Replace mentions of SROA'd locals that appear in the operand.\n+                            self.visit_operand(&mut operand, location);\n+\n+                            let rvalue = Rvalue::Use(operand);\n+                            self.patch.add_statement(\n+                                location,\n+                                StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n+                            );\n+                        }\n                     }\n                     statement.make_nop();\n                     return;\n                 }\n             }\n \n+            // We have `a = some constant`\n+            // We add the projections.\n+            // ```\n+            // a_0 = a.0\n+            // a_1 = a.1\n+            // ...\n+            // ```\n+            // ConstProp will pick up the pieces and replace them by actual constants.\n             StatementKind::Assign(box (place, Rvalue::Use(Operand::Constant(_)))) => {\n                 if let Some(final_locals) = self.replacements.place_fragments(place) {\n-                    for &(projection, fl) in final_locals {\n-                        let rvalue =\n-                            Rvalue::Use(Operand::Move(place.project_deeper(projection, self.tcx)));\n+                    for (field, ty, new_local) in final_locals {\n+                        let rplace = self.tcx.mk_place_field(place, field, ty);\n+                        let rvalue = Rvalue::Use(Operand::Move(rplace));\n                         self.patch.add_statement(\n                             location,\n-                            StatementKind::Assign(Box::new((fl.into(), rvalue))),\n+                            StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n                         );\n                     }\n-                    self.all_dead_locals.remove(place.local);\n+                    // We still need `place.local` to exist, so don't make it nop.\n                     return;\n                 }\n             }\n \n+            // We have `a = move? place`\n+            // We replace it by\n+            // ```\n+            // a_0 = move? place.0\n+            // a_1 = move? place.1\n+            // ...\n+            // ```\n             StatementKind::Assign(box (lhs, Rvalue::Use(ref op))) => {\n-                let (rplace, copy) = match op {\n+                let (rplace, copy) = match *op {\n                     Operand::Copy(rplace) => (rplace, true),\n                     Operand::Move(rplace) => (rplace, false),\n                     Operand::Constant(_) => bug!(),\n                 };\n                 if let Some(final_locals) = self.replacements.place_fragments(lhs) {\n-                    for &(projection, fl) in final_locals {\n-                        let rplace = rplace.project_deeper(projection, self.tcx);\n+                    for (field, ty, new_local) in final_locals {\n+                        let rplace = self.tcx.mk_place_field(rplace, field, ty);\n                         debug!(?rplace);\n-                        let rplace = self.replace_place(rplace.as_ref()).unwrap_or(rplace);\n+                        let rplace = self\n+                            .replacements\n+                            .replace_place(self.tcx, rplace.as_ref())\n+                            .unwrap_or(rplace);\n                         debug!(?rplace);\n                         let rvalue = if copy {\n                             Rvalue::Use(Operand::Copy(rplace))\n@@ -328,7 +360,7 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                         };\n                         self.patch.add_statement(\n                             location,\n-                            StatementKind::Assign(Box::new((fl.into(), rvalue))),\n+                            StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n                         );\n                     }\n                     statement.make_nop();\n@@ -341,22 +373,14 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n         self.super_statement(statement, location)\n     }\n \n-    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if let Some(repl) = self.replace_place(place.as_ref()) {\n-            *place = repl\n-        } else {\n-            self.super_place(place, context, location)\n-        }\n-    }\n-\n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_var_debug_info(&mut self, var_debug_info: &mut VarDebugInfo<'tcx>) {\n         match &mut var_debug_info.value {\n             VarDebugInfoContents::Place(ref mut place) => {\n-                if let Some(repl) = self.replace_place(place.as_ref()) {\n+                if let Some(repl) = self.replacements.replace_place(self.tcx, place.as_ref()) {\n                     *place = repl;\n-                } else if let Some(fragments) =\n-                    self.replacements.gather_debug_info_fragments(place.as_ref())\n+                } else if let Some(local) = place.as_local()\n+                    && let Some(fragments) = self.gather_debug_info_fragments(local)\n                 {\n                     let ty = place.ty(self.local_decls, self.tcx).ty;\n                     var_debug_info.value = VarDebugInfoContents::Composite { ty, fragments };\n@@ -367,12 +391,13 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                 debug!(?fragments);\n                 fragments\n                     .drain_filter(|fragment| {\n-                        if let Some(repl) = self.replace_place(fragment.contents.as_ref()) {\n+                        if let Some(repl) =\n+                            self.replacements.replace_place(self.tcx, fragment.contents.as_ref())\n+                        {\n                             fragment.contents = repl;\n                             false\n-                        } else if let Some(frg) = self\n-                            .replacements\n-                            .gather_debug_info_fragments(fragment.contents.as_ref())\n+                        } else if let Some(local) = fragment.contents.as_local()\n+                            && let Some(frg) = self.gather_debug_info_fragments(local)\n                         {\n                             new_fragments.extend(frg.into_iter().map(|mut f| {\n                                 f.projection.splice(0..0, fragment.projection.iter().copied());"}]}