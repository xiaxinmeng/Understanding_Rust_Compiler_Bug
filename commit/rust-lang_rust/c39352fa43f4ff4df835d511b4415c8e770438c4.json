{"sha": "c39352fa43f4ff4df835d511b4415c8e770438c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTM1MmZhNDNmNGZmNGRmODM1ZDUxMWI0NDE1YzhlNzcwNDM4YzQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-24T15:44:32Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-24T16:29:27Z"}, "message": "Fill in type params in 'add missing impl members' assist", "tree": {"sha": "cb7daa51f218a87aa94874aef28130c1ca2b0245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7daa51f218a87aa94874aef28130c1ca2b0245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c39352fa43f4ff4df835d511b4415c8e770438c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c39352fa43f4ff4df835d511b4415c8e770438c4", "html_url": "https://github.com/rust-lang/rust/commit/c39352fa43f4ff4df835d511b4415c8e770438c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c39352fa43f4ff4df835d511b4415c8e770438c4/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa49b79bda5b7cafbaa33c302a9974133d34c52b", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa49b79bda5b7cafbaa33c302a9974133d34c52b", "html_url": "https://github.com/rust-lang/rust/commit/aa49b79bda5b7cafbaa33c302a9974133d34c52b"}], "stats": {"total": 188, "additions": 151, "deletions": 37}, "files": [{"sha": "28152f724427cb893c011dcd47295099e14a4bba", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=c39352fa43f4ff4df835d511b4415c8e770438c4", "patch": "@@ -46,7 +46,7 @@ pub(crate) enum Assist {\n ///\n /// Note, however, that we don't actually use such two-phase logic at the\n /// moment, because the LSP API is pretty awkward in this place, and it's much\n-/// easier to just compute the edit eagerly :-)#[derive(Debug, Clone)]\n+/// easier to just compute the edit eagerly :-)\n #[derive(Debug)]\n pub(crate) struct AssistCtx<'a, DB> {\n     pub(crate) db: &'a DB,"}, {"sha": "bc49e71fec690a352df9465adfd228ad3f40c958", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 117, "deletions": 14, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=c39352fa43f4ff4df835d511b4415c8e770438c4", "patch": "@@ -1,3 +1,5 @@\n+use std::collections::HashMap;\n+\n use hir::{db::HirDatabase, HasSource};\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner},\n@@ -17,26 +19,26 @@ enum AddMissingImplMembersMode {\n // Adds scaffold for required impl members.\n //\n // ```\n-// trait T {\n+// trait Trait<T> {\n //     Type X;\n-//     fn foo(&self);\n+//     fn foo(&self) -> T;\n //     fn bar(&self) {}\n // }\n //\n-// impl T for () {<|>\n+// impl Trait<u32> for () {<|>\n //\n // }\n // ```\n // ->\n // ```\n-// trait T {\n+// trait Trait<T> {\n //     Type X;\n-//     fn foo(&self);\n+//     fn foo(&self) -> T;\n //     fn bar(&self) {}\n // }\n //\n-// impl T for () {\n-//     fn foo(&self) { unimplemented!() }\n+// impl Trait<u32> for () {\n+//     fn foo(&self) -> u32 { unimplemented!() }\n //\n // }\n // ```\n@@ -54,27 +56,27 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx<impl HirDatabase>) -> Opti\n // Adds scaffold for overriding default impl members.\n //\n // ```\n-// trait T {\n+// trait Trait {\n //     Type X;\n //     fn foo(&self);\n //     fn bar(&self) {}\n // }\n //\n-// impl T for () {\n+// impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}<|>\n //\n // }\n // ```\n // ->\n // ```\n-// trait T {\n+// trait Trait {\n //     Type X;\n //     fn foo(&self);\n //     fn bar(&self) {}\n // }\n //\n-// impl T for () {\n+// impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}\n //     fn bar(&self) {}\n@@ -99,7 +101,7 @@ fn add_missing_impl_members_inner(\n     let impl_node = ctx.find_node_at_offset::<ast::ImplBlock>()?;\n     let impl_item_list = impl_node.item_list()?;\n \n-    let trait_def = {\n+    let (trait_, trait_def) = {\n         let analyzer = ctx.source_analyzer(impl_node.syntax(), None);\n \n         resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n@@ -132,10 +134,25 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n+    let file_id = ctx.frange.file_id;\n+    let db = ctx.db;\n+\n     ctx.add_assist(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n+        let substs = get_syntactic_substs(impl_node).unwrap_or_default();\n+        let generic_def: hir::GenericDef = trait_.into();\n+        let substs_by_param: HashMap<_, _> = generic_def\n+            .params(db)\n+            .into_iter()\n+            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n+            .skip(1)\n+            .zip(substs.into_iter())\n+            .collect();\n         let items = missing_items\n             .into_iter()\n+            .map(|it| {\n+                substitute_type_params(db, hir::InFile::new(file_id.into(), it), &substs_by_param)\n+            })\n             .map(|it| match it {\n                 ast::ImplItem::FnDef(def) => ast::ImplItem::FnDef(add_body(def)),\n                 _ => it,\n@@ -160,21 +177,73 @@ fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     }\n }\n \n+// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n+// trait ref, and then go from the types in the substs back to the syntax)\n+// FIXME: This should be a general utility (not even just for assists)\n+fn get_syntactic_substs(impl_block: ast::ImplBlock) -> Option<Vec<ast::TypeRef>> {\n+    let target_trait = impl_block.target_trait()?;\n+    let path_type = match target_trait {\n+        ast::TypeRef::PathType(path) => path,\n+        _ => return None,\n+    };\n+    let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n+    let mut result = Vec::new();\n+    for type_arg in type_arg_list.type_args() {\n+        let type_arg: ast::TypeArg = type_arg;\n+        result.push(type_arg.type_ref()?);\n+    }\n+    Some(result)\n+}\n+\n+// FIXME: This should be a general utility (not even just for assists)\n+fn substitute_type_params<N: AstNode>(\n+    db: &impl HirDatabase,\n+    node: hir::InFile<N>,\n+    substs: &HashMap<hir::TypeParam, ast::TypeRef>,\n+) -> N {\n+    let type_param_replacements = node\n+        .value\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::TypeRef::cast)\n+        .filter_map(|n| {\n+            let path = match &n {\n+                ast::TypeRef::PathType(path_type) => path_type.path()?,\n+                _ => return None,\n+            };\n+            let analyzer = hir::SourceAnalyzer::new(db, node.with_value(n.syntax()), None);\n+            let resolution = analyzer.resolve_path(db, &path)?;\n+            match resolution {\n+                hir::PathResolution::TypeParam(tp) => Some((n, substs.get(&tp)?.clone())),\n+                _ => None,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if type_param_replacements.is_empty() {\n+        node.value\n+    } else {\n+        edit::replace_descendants(&node.value, type_param_replacements.into_iter())\n+    }\n+}\n+\n /// Given an `ast::ImplBlock`, resolves the target trait (the one being\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n     db: &impl HirDatabase,\n     analyzer: &hir::SourceAnalyzer,\n     impl_block: &ast::ImplBlock,\n-) -> Option<ast::TraitDef> {\n+) -> Option<(hir::Trait, ast::TraitDef)> {\n     let ast_path = impl_block\n         .target_trait()\n         .map(|it| it.syntax().clone())\n         .and_then(ast::PathType::cast)?\n         .path()?;\n \n     match analyzer.resolve_path(db, &ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).value),\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => {\n+            Some((def, def.source(db).value))\n+        }\n         _ => None,\n     }\n }\n@@ -280,6 +349,40 @@ impl Foo for S {\n         );\n     }\n \n+    #[test]\n+    fn fill_in_type_params_1() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo<T> { fn foo(&self, t: T) -> &T; }\n+struct S;\n+impl Foo<u32> for S { <|> }\",\n+            \"\n+trait Foo<T> { fn foo(&self, t: T) -> &T; }\n+struct S;\n+impl Foo<u32> for S {\n+    <|>fn foo(&self, t: u32) -> &u32 { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_in_type_params_2() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+trait Foo<T> { fn foo(&self, t: T) -> &T; }\n+struct S;\n+impl<U> Foo<U> for S { <|> }\",\n+            \"\n+trait Foo<T> { fn foo(&self, t: T) -> &T; }\n+struct S;\n+impl<U> Foo<U> for S {\n+    <|>fn foo(&self, t: U) -> &U { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn test_cursor_after_empty_impl_block() {\n         check_assist("}, {"sha": "7d84dc8fb64154cbc680998b755a43bf1ef15f7c", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=c39352fa43f4ff4df835d511b4415c8e770438c4", "patch": "@@ -101,26 +101,26 @@ fn doctest_add_impl_default_members() {\n     check(\n         \"add_impl_default_members\",\n         r#####\"\n-trait T {\n+trait Trait {\n     Type X;\n     fn foo(&self);\n     fn bar(&self) {}\n }\n \n-impl T for () {\n+impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}<|>\n \n }\n \"#####,\n         r#####\"\n-trait T {\n+trait Trait {\n     Type X;\n     fn foo(&self);\n     fn bar(&self) {}\n }\n \n-impl T for () {\n+impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n     fn bar(&self) {}\n@@ -135,25 +135,25 @@ fn doctest_add_impl_missing_members() {\n     check(\n         \"add_impl_missing_members\",\n         r#####\"\n-trait T {\n+trait Trait<T> {\n     Type X;\n-    fn foo(&self);\n+    fn foo(&self) -> T;\n     fn bar(&self) {}\n }\n \n-impl T for () {<|>\n+impl Trait<u32> for () {<|>\n \n }\n \"#####,\n         r#####\"\n-trait T {\n+trait Trait<T> {\n     Type X;\n-    fn foo(&self);\n+    fn foo(&self) -> T;\n     fn bar(&self) {}\n }\n \n-impl T for () {\n-    fn foo(&self) { unimplemented!() }\n+impl Trait<u32> for () {\n+    fn foo(&self) -> u32 { unimplemented!() }\n \n }\n \"#####,"}, {"sha": "76d8f85f1ef65cf4306afb30571f47b173ee159d", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39352fa43f4ff4df835d511b4415c8e770438c4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=c39352fa43f4ff4df835d511b4415c8e770438c4", "patch": "@@ -644,6 +644,17 @@ impl_froms!(\n     Const\n );\n \n+impl GenericDef {\n+    pub fn params(self, db: &impl HirDatabase) -> Vec<TypeParam> {\n+        let generics: Arc<hir_def::generics::GenericParams> = db.generic_params(self.into());\n+        generics\n+            .types\n+            .iter()\n+            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n+            .collect()\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBody,"}, {"sha": "ecf206f71f67e41689f67053bf11dded58d1b4ab", "filename": "docs/user/assists.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c39352fa43f4ff4df835d511b4415c8e770438c4/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/c39352fa43f4ff4df835d511b4415c8e770438c4/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=c39352fa43f4ff4df835d511b4415c8e770438c4", "patch": "@@ -98,26 +98,26 @@ Adds scaffold for overriding default impl members.\n \n ```rust\n // BEFORE\n-trait T {\n+trait Trait {\n     Type X;\n     fn foo(&self);\n     fn bar(&self) {}\n }\n \n-impl T for () {\n+impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\u2503\n \n }\n \n // AFTER\n-trait T {\n+trait Trait {\n     Type X;\n     fn foo(&self);\n     fn bar(&self) {}\n }\n \n-impl T for () {\n+impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n     fn bar(&self) {}\n@@ -131,25 +131,25 @@ Adds scaffold for required impl members.\n \n ```rust\n // BEFORE\n-trait T {\n+trait Trait<T> {\n     Type X;\n-    fn foo(&self);\n+    fn foo(&self) -> T;\n     fn bar(&self) {}\n }\n \n-impl T for () {\u2503\n+impl Trait<u32> for () {\u2503\n \n }\n \n // AFTER\n-trait T {\n+trait Trait<T> {\n     Type X;\n-    fn foo(&self);\n+    fn foo(&self) -> T;\n     fn bar(&self) {}\n }\n \n-impl T for () {\n-    fn foo(&self) { unimplemented!() }\n+impl Trait<u32> for () {\n+    fn foo(&self) -> u32 { unimplemented!() }\n \n }\n ```"}]}