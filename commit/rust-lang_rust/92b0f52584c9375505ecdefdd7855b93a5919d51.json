{"sha": "92b0f52584c9375505ecdefdd7855b93a5919d51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjBmNTI1ODRjOTM3NTUwNWVjZGVmZGQ3ODU1YjkzYTU5MTlkNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-15T12:29:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-15T12:29:53Z"}, "message": "Auto merge of #62667 - petrochenkov:printattr2, r=Mark-Simulacrum\n\npprust: Improve pretty-printing of delimited token groups\n\nThe commit \"Do not convert attributes into `MetaItem`s for printing\" fixes https://github.com/rust-lang/rust/issues/62628.\n\nOther commits fix regressions from abandoning `MetaItem`s, and make formatting for attributes, macro calls, macro definitions and other delimited token groups better and more consistent.\n\nr? @Mark-Simulacrum", "tree": {"sha": "b47ac35a70dd95d012dd20443237a72a444d340c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47ac35a70dd95d012dd20443237a72a444d340c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b0f52584c9375505ecdefdd7855b93a5919d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b0f52584c9375505ecdefdd7855b93a5919d51", "html_url": "https://github.com/rust-lang/rust/commit/92b0f52584c9375505ecdefdd7855b93a5919d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b0f52584c9375505ecdefdd7855b93a5919d51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5480b47d7f9e708300d3ba319869f21cd1ffd487", "url": "https://api.github.com/repos/rust-lang/rust/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487", "html_url": "https://github.com/rust-lang/rust/commit/5480b47d7f9e708300d3ba319869f21cd1ffd487"}, {"sha": "0cdd18d0a7b9d3c52017b57eecda6e198e9512b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cdd18d0a7b9d3c52017b57eecda6e198e9512b1", "html_url": "https://github.com/rust-lang/rust/commit/0cdd18d0a7b9d3c52017b57eecda6e198e9512b1"}], "stats": {"total": 604, "additions": 350, "deletions": 254}, "files": [{"sha": "3e571baaa4e518397c02e99ec985873466a39e00", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -4,7 +4,7 @@ use syntax::source_map::{SourceMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::{Comments, PrintState};\n+use syntax::print::pprust::{self, Comments, PrintState};\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n@@ -90,6 +90,15 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n+\n+    fn print_ident(&mut self, ident: ast::Ident) {\n+        self.s.word(pprust::ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.ann.post(self, AnnNode::Name(&ident.name))\n+    }\n+\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, _colons_before_params: bool) {\n+        span_bug!(args.span(), \"AST generic args printed by HIR pretty-printer\");\n+    }\n }\n \n pub const INDENT_UNIT: usize = 4;\n@@ -1442,15 +1451,6 @@ impl<'a> State<'a> {\n         self.s.word(i.to_string())\n     }\n \n-    pub fn print_ident(&mut self, ident: ast::Ident) {\n-        if ident.is_raw_guess() {\n-            self.s.word(format!(\"r#{}\", ident.name));\n-        } else {\n-            self.s.word(ident.as_str().to_string());\n-        }\n-        self.ann.post(self, AnnNode::Name(&ident.name))\n-    }\n-\n     pub fn print_name(&mut self, name: ast::Name) {\n         self.print_ident(ast::Ident::with_empty_ctxt(name))\n     }"}, {"sha": "6cfc1b77e03feeb3505f475f63d1b11449ddc819", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -6,7 +6,7 @@ pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::parse::token;\n+use crate::parse::token::{self, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n@@ -1298,6 +1298,16 @@ impl Mac_ {\n     }\n }\n \n+impl MacDelimiter {\n+    crate fn to_token(self) -> DelimToken {\n+        match self {\n+            MacDelimiter::Parenthesis => DelimToken::Paren,\n+            MacDelimiter::Bracket => DelimToken::Bracket,\n+            MacDelimiter::Brace => DelimToken::Brace,\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MacroDef {\n     pub tokens: TokenStream,"}, {"sha": "dc656222fbc1082659d2915a62abe979dccc5169", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1328,7 +1328,7 @@ mod tests {\n                 matches_codepattern,\n                 \"matches_codepattern\",\n                 pprust::to_string(|s| fake_print_crate(s, &krate)),\n-                \"macro_rules! zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n+                \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string());\n         })\n     }\n }"}, {"sha": "16e0bace925842eb69eb6d762259f2a1975ed8b0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 198, "deletions": 175, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -4,7 +4,7 @@ use crate::ast::{Attribute, MacDelimiter, GenericArg};\n use crate::util::parser::{self, AssocOp, Fixity};\n use crate::attr;\n use crate::source_map::{self, SourceMap, Spanned};\n-use crate::parse::token::{self, BinOpToken, Nonterminal, Token, TokenKind};\n+use crate::parse::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n use crate::parse::lexer::comments;\n use crate::parse::{self, ParseSess};\n use crate::print::pp::{self, Breaks};\n@@ -20,6 +20,11 @@ use syntax_pos::{DUMMY_SP, FileName, Span};\n \n use std::borrow::Cow;\n \n+pub enum MacHeader<'a> {\n+    Path(&'a ast::Path),\n+    Keyword(&'static str),\n+}\n+\n pub enum AnnNode<'a> {\n     Ident(&'a ast::Ident),\n     Name(&'a ast::Name),\n@@ -188,7 +193,7 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n }\n \n /// Print an ident from AST, `$crate` is converted into its respective crate name.\n-fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n+pub fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n     ident_to_string(ident.name, is_raw, Some(ident.span))\n }\n \n@@ -446,6 +451,8 @@ impl std::ops::DerefMut for State<'_> {\n \n pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefMut {\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n+    fn print_ident(&mut self, ident: ast::Ident);\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n         where F: FnMut(&mut Self, &T),\n@@ -596,17 +603,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         }\n     }\n \n-    fn print_attribute_path(&mut self, path: &ast::Path) {\n-        for (i, segment) in path.segments.iter().enumerate() {\n-            if i > 0 {\n-                self.word(\"::\");\n-            }\n-            if segment.ident.name != kw::PathRoot {\n-                self.word(ast_ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n-            }\n-        }\n-    }\n-\n     fn print_attribute(&mut self, attr: &ast::Attribute) {\n         self.print_attribute_inline(attr, false)\n     }\n@@ -625,13 +621,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n                 ast::AttrStyle::Inner => self.word(\"#![\"),\n                 ast::AttrStyle::Outer => self.word(\"#[\"),\n             }\n-            if let Some(mi) = attr.meta() {\n-                self.print_meta_item(&mi);\n-            } else {\n-                self.print_attribute_path(&attr.path);\n-                self.space();\n-                self.print_tts(attr.tokens.clone(), true);\n+            self.ibox(0);\n+            match attr.tokens.trees().next() {\n+                Some(TokenTree::Delimited(_, delim, tts)) => {\n+                    self.print_mac_common(\n+                        Some(MacHeader::Path(&attr.path)), false, None, delim, tts, true, attr.span\n+                    );\n+                }\n+                tree => {\n+                    self.print_path(&attr.path, false, 0);\n+                    if tree.is_some() {\n+                        self.space();\n+                        self.print_tts(attr.tokens.clone(), true);\n+                    }\n+                }\n             }\n+            self.end();\n             self.word(\"]\");\n         }\n     }\n@@ -650,15 +655,15 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n         match item.node {\n-            ast::MetaItemKind::Word => self.print_attribute_path(&item.path),\n+            ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.print_attribute_path(&item.path);\n+                self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_literal(value);\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.print_attribute_path(&item.path);\n+                self.print_path(&item.path, false, 0);\n                 self.popen();\n                 self.commasep(Consistent,\n                               &items[..],\n@@ -687,36 +692,90 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n                     _ => {}\n                 }\n             }\n-            TokenTree::Delimited(_, delim, tts) => {\n-                self.word(token_kind_to_string(&token::OpenDelim(delim)));\n-                self.space();\n-                self.print_tts(tts, convert_dollar_crate);\n-                self.space();\n-                self.word(token_kind_to_string(&token::CloseDelim(delim)))\n-            },\n+            TokenTree::Delimited(dspan, delim, tts) => {\n+                self.print_mac_common(\n+                    None, false, None, delim, tts, convert_dollar_crate, dspan.entire()\n+                );\n+            }\n         }\n     }\n \n     fn print_tts(&mut self, tts: tokenstream::TokenStream, convert_dollar_crate: bool) {\n-        self.ibox(0);\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n                 self.space();\n             }\n             self.print_tt(tt, convert_dollar_crate);\n         }\n+    }\n+\n+    fn print_mac_common(\n+        &mut self,\n+        header: Option<MacHeader<'_>>,\n+        has_bang: bool,\n+        ident: Option<ast::Ident>,\n+        delim: DelimToken,\n+        tts: TokenStream,\n+        convert_dollar_crate: bool,\n+        span: Span,\n+    ) {\n+        if delim == DelimToken::Brace {\n+            self.cbox(INDENT_UNIT);\n+        }\n+        match header {\n+            Some(MacHeader::Path(path)) => self.print_path(path, false, 0),\n+            Some(MacHeader::Keyword(kw)) => self.word(kw),\n+            None => {}\n+        }\n+        if has_bang {\n+            self.word(\"!\");\n+        }\n+        if let Some(ident) = ident {\n+            self.nbsp();\n+            self.print_ident(ident);\n+        }\n+        match delim {\n+            DelimToken::Brace => {\n+                if header.is_some() || has_bang || ident.is_some() {\n+                    self.nbsp();\n+                }\n+                self.word(\"{\");\n+                if !tts.is_empty() {\n+                    self.space();\n+                }\n+            }\n+            _ => self.word(token_kind_to_string(&token::OpenDelim(delim))),\n+        }\n+        self.ibox(0);\n+        self.print_tts(tts, convert_dollar_crate);\n         self.end();\n+        match delim {\n+            DelimToken::Brace => self.bclose(span),\n+            _ => self.word(token_kind_to_string(&token::CloseDelim(delim))),\n+        }\n     }\n-}\n \n-impl<'a> PrintState<'a> for State<'a> {\n-    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n-        &mut self.comments\n+    fn print_path(&mut self, path: &ast::Path, colons_before_params: bool, depth: usize) {\n+        self.maybe_print_comment(path.span.lo());\n+\n+        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n+            if i > 0 {\n+                self.word(\"::\")\n+            }\n+            self.print_path_segment(segment, colons_before_params);\n+        }\n     }\n-}\n \n-impl<'a> State<'a> {\n-    crate fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n+    fn print_path_segment(&mut self, segment: &ast::PathSegment, colons_before_params: bool) {\n+        if segment.ident.name != kw::PathRoot {\n+            self.print_ident(segment.ident);\n+            if let Some(ref args) = segment.args {\n+                self.print_generic_args(args, colons_before_params);\n+            }\n+        }\n+    }\n+\n+    fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n         let w = w.into();\n         // outer-box is consistent\n         self.cbox(INDENT_UNIT);\n@@ -728,36 +787,103 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn bopen(&mut self) {\n-        self.s.word(\"{\");\n+    fn bopen(&mut self) {\n+        self.word(\"{\");\n         self.end(); // close the head-box\n     }\n \n-    crate fn bclose_maybe_open(&mut self, span: syntax_pos::Span, close_box: bool) {\n+    fn bclose_maybe_open(&mut self, span: syntax_pos::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n         self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n     }\n-    crate fn bclose(&mut self, span: syntax_pos::Span) {\n+\n+    fn bclose(&mut self, span: syntax_pos::Span) {\n         self.bclose_maybe_open(span, true)\n     }\n \n-    crate fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n-        if !self.s.is_beginning_of_line() {\n-            self.s.break_offset(n, off)\n+    fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n+        if !self.is_beginning_of_line() {\n+            self.break_offset(n, off)\n         } else {\n-            if off != 0 && self.s.last_token().is_hardbreak_tok() {\n+            if off != 0 && self.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n+                self.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> PrintState<'a> for State<'a> {\n+    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n+        &mut self.comments\n+    }\n+\n+    fn print_ident(&mut self, ident: ast::Ident) {\n+        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.ann.post(self, AnnNode::Ident(&ident))\n+    }\n+\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool) {\n+        if colons_before_params {\n+            self.s.word(\"::\")\n+        }\n+\n+        match *args {\n+            ast::GenericArgs::AngleBracketed(ref data) => {\n+                self.s.word(\"<\");\n+\n+                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n+                    s.print_generic_arg(generic_arg)\n+                });\n+\n+                let mut comma = data.args.len() != 0;\n+\n+                for constraint in data.constraints.iter() {\n+                    if comma {\n+                        self.word_space(\",\")\n+                    }\n+                    self.print_ident(constraint.ident);\n+                    self.s.space();\n+                    match constraint.kind {\n+                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n+                            self.word_space(\"=\");\n+                            self.print_type(ty);\n+                        }\n+                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n+                            self.print_type_bounds(\":\", &*bounds);\n+                        }\n+                    }\n+                    comma = true;\n+                }\n+\n+                self.s.word(\">\")\n+            }\n+\n+            ast::GenericArgs::Parenthesized(ref data) => {\n+                self.s.word(\"(\");\n+                self.commasep(\n+                    Inconsistent,\n+                    &data.inputs,\n+                    |s, ty| s.print_type(ty));\n+                self.s.word(\")\");\n+\n+                if let Some(ref ty) = data.output {\n+                    self.space_if_not_bol();\n+                    self.word_space(\"->\");\n+                    self.print_type(ty);\n+                }\n             }\n         }\n     }\n+}\n \n+impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) {\n@@ -1231,33 +1357,24 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n             }\n             ast::ItemKind::Mac(ref mac) => {\n-                if item.ident.name == kw::Invalid {\n-                    self.print_mac(mac);\n-                    match mac.node.delim {\n-                        MacDelimiter::Brace => {}\n-                        _ => self.s.word(\";\"),\n-                    }\n-                } else {\n-                    self.print_path(&mac.node.path, false, 0);\n-                    self.s.word(\"! \");\n-                    self.print_ident(item.ident);\n-                    self.cbox(INDENT_UNIT);\n-                    self.popen();\n-                    self.print_tts(mac.node.stream(), true);\n-                    self.pclose();\n-                    self.s.word(\";\");\n-                    self.end();\n+                self.print_mac(mac);\n+                match mac.node.delim {\n+                    MacDelimiter::Brace => {}\n+                    _ => self.s.word(\";\"),\n                 }\n             }\n-            ast::ItemKind::MacroDef(ref tts) => {\n-                self.s.word(\"macro_rules! \");\n-                self.print_ident(item.ident);\n-                self.cbox(INDENT_UNIT);\n-                self.popen();\n-                self.print_tts(tts.stream(), true);\n-                self.pclose();\n-                self.s.word(\";\");\n-                self.end();\n+            ast::ItemKind::MacroDef(ref macro_def) => {\n+                let (kw, has_bang) =\n+                    if macro_def.legacy { (\"macro_rules\", true) } else { (\"macro\", false) };\n+                self.print_mac_common(\n+                    Some(MacHeader::Keyword(kw)),\n+                    has_bang,\n+                    Some(item.ident),\n+                    DelimToken::Brace,\n+                    macro_def.stream(),\n+                    true,\n+                    item.span,\n+                );\n             }\n         }\n         self.ann.post(self, AnnNode::Item(item))\n@@ -1645,25 +1762,17 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_mac(&mut self, m: &ast::Mac) {\n-        self.print_path(&m.node.path, false, 0);\n-        self.s.word(\"!\");\n-        match m.node.delim {\n-            MacDelimiter::Parenthesis => self.popen(),\n-            MacDelimiter::Bracket => self.s.word(\"[\"),\n-            MacDelimiter::Brace => {\n-                self.head(\"\");\n-                self.bopen();\n-            }\n-        }\n-        self.print_tts(m.node.stream(), true);\n-        match m.node.delim {\n-            MacDelimiter::Parenthesis => self.pclose(),\n-            MacDelimiter::Bracket => self.s.word(\"]\"),\n-            MacDelimiter::Brace => self.bclose(m.span),\n-        }\n+        self.print_mac_common(\n+            Some(MacHeader::Path(&m.node.path)),\n+            true,\n+            None,\n+            m.node.delim.to_token(),\n+            m.node.stream(),\n+            true,\n+            m.span,\n+        );\n     }\n \n-\n     fn print_call_post(&mut self, args: &[P<ast::Expr>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, args);\n@@ -2204,11 +2313,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n-        self.ann.post(self, AnnNode::Ident(&ident))\n-    }\n-\n     crate fn print_usize(&mut self, i: usize) {\n         self.s.word(i.to_string())\n     }\n@@ -2218,31 +2322,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n-    fn print_path(&mut self,\n-                  path: &ast::Path,\n-                  colons_before_params: bool,\n-                  depth: usize) {\n-        self.maybe_print_comment(path.span.lo());\n-\n-        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n-            if i > 0 {\n-                self.s.word(\"::\")\n-            }\n-            self.print_path_segment(segment, colons_before_params);\n-        }\n-    }\n-\n-    fn print_path_segment(&mut self,\n-                          segment: &ast::PathSegment,\n-                          colons_before_params: bool) {\n-        if segment.ident.name != kw::PathRoot {\n-            self.print_ident(segment.ident);\n-            if let Some(ref args) = segment.args {\n-                self.print_generic_args(args, colons_before_params);\n-            }\n-        }\n-    }\n-\n     fn print_qpath(&mut self,\n                    path: &ast::Path,\n                    qself: &ast::QSelf,\n@@ -2266,62 +2345,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_generic_args(&mut self,\n-                          args: &ast::GenericArgs,\n-                          colons_before_params: bool)\n-    {\n-        if colons_before_params {\n-            self.s.word(\"::\")\n-        }\n-\n-        match *args {\n-            ast::GenericArgs::AngleBracketed(ref data) => {\n-                self.s.word(\"<\");\n-\n-                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n-                    s.print_generic_arg(generic_arg)\n-                });\n-\n-                let mut comma = data.args.len() != 0;\n-\n-                for constraint in data.constraints.iter() {\n-                    if comma {\n-                        self.word_space(\",\")\n-                    }\n-                    self.print_ident(constraint.ident);\n-                    self.s.space();\n-                    match constraint.kind {\n-                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n-                            self.word_space(\"=\");\n-                            self.print_type(ty);\n-                        }\n-                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n-                            self.print_type_bounds(\":\", &*bounds);\n-                        }\n-                    }\n-                    comma = true;\n-                }\n-\n-                self.s.word(\">\")\n-            }\n-\n-            ast::GenericArgs::Parenthesized(ref data) => {\n-                self.s.word(\"(\");\n-                self.commasep(\n-                    Inconsistent,\n-                    &data.inputs,\n-                    |s, ty| s.print_type(ty));\n-                self.s.word(\")\");\n-\n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol();\n-                    self.word_space(\"->\");\n-                    self.print_type(ty);\n-                }\n-            }\n-        }\n-    }\n-\n     crate fn print_pat(&mut self, pat: &ast::Pat) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));"}, {"sha": "bcd6ffaaf815b6cf443f43c750bdf89d48db8076", "filename": "src/test/pretty/attr-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-literals.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -5,10 +5,10 @@\n #![feature(rustc_attrs)]\n \n fn main() {\n-    #![rustc_dummy(\"hi\", 1, 2, 1.012, pi = 3.14, bye, name(\"John\"))]\n+    #![rustc_dummy(\"hi\" , 1 , 2 , 1.012 , pi = 3.14 , bye , name (\"John\"))]\n     #[rustc_dummy = 8]\n     fn f() { }\n \n-    #[rustc_dummy(1, 2, 3)]\n+    #[rustc_dummy(1 , 2 , 3)]\n     fn g() { }\n }"}, {"sha": "bb2c4bb558e57dd10a9d073e2ca2daba1adce345", "filename": "src/test/pretty/attr-tokens-raw-ident.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -0,0 +1,7 @@\n+// Keywords in attribute paths are printed as raw idents,\n+// but keywords in attribute arguments are not.\n+\n+// pp-exact\n+\n+#[rustfmt::r#final(final)]\n+fn main() { }"}, {"sha": "47a7dac95b9c5081cf936c03538e84c12925ea9b", "filename": "src/test/pretty/cast-lt.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fcast-lt.pp", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fcast-lt.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fcast-lt.pp?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -8,6 +8,6 @@\n // pretty-mode:expanded\n // pp-exact:cast-lt.pp\n \n-macro_rules! negative(( $ e : expr ) => { $ e < 0 });\n+macro_rules! negative { ($ e : expr) => { $ e < 0 } }\n \n fn main() { (1 as i32) < 0; }"}, {"sha": "768f27ad23a8ebc9a3306b7aa998502e6981f5cb", "filename": "src/test/pretty/delimited-token-groups.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -0,0 +1,49 @@\n+// pp-exact\n+\n+#![feature(rustc_attrs)]\n+\n+macro_rules! mac { ($ ($ tt : tt) *) => () }\n+\n+mac! {\n+    struct S { field1 : u8 , field2 : u16 , } impl Clone for S\n+    {\n+        fn clone () -> S\n+        {\n+            panic ! () ;\n+\n+        }\n+    }\n+}\n+\n+mac! {\n+    a\n+    (aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+     aaaaaaaa aaaaaaaa) a\n+    [aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+     aaaaaaaa aaaaaaaa] a\n+    {\n+        aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+        aaaaaaaa aaaaaaaa aaaaaaaa\n+    } a\n+}\n+\n+mac!(aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+     aaaaaaaa aaaaaaaa);\n+mac![aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+     aaaaaaaa aaaaaaaa];\n+mac! {\n+    aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+    aaaaaaaa aaaaaaaa\n+}\n+\n+#[rustc_dummy(aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+              aaaaaaaa aaaaaaaa aaaaaaaa)]\n+#[rustc_dummy[aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+              aaaaaaaa aaaaaaaa aaaaaaaa]]\n+#[rustc_dummy {\n+      aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\n+      aaaaaaaa aaaaaaaa\n+  }]\n+#[rustc_dummy =\n+  \"aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\"]\n+fn main() { }"}, {"sha": "02951395e70b440491cab26889ef5c1301bda97c", "filename": "src/test/pretty/issue-30731.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fissue-30731.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fissue-30731.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-30731.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -5,4 +5,4 @@\n // pretty-compare-only\n // pp-exact\n \n-fn main() { b!{ } c }\n+fn main() { b! { } c }"}, {"sha": "bd839d35421993cec5cc6011d8c0a62bceb838a9", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -29,8 +29,8 @@\n \n \n \n-                  (($crate::fmt::format as\n-                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n+                  ((::alloc::fmt::format as\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n                                                                                                            as\n                                                                                                            fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n                                                                                                                                                                                                                             as"}, {"sha": "39677d1dc2da35de91493176b7afbc03e1aca3b1", "filename": "src/test/pretty/macro.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmacro.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -0,0 +1,7 @@\n+// pp-exact\n+\n+#![feature(decl_macro)]\n+\n+macro mac { ($ arg : expr) => { $ arg + $ arg } }\n+\n+fn main() { }"}, {"sha": "02d93238dd6435497b797b9939c5b31bce5305f4", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -111,29 +111,29 @@ fn _8() {\n }\n \n fn _9() {\n-    macro_rules! stmt_mac((  ) => { let _ = (  ) ; });\n+    macro_rules! stmt_mac { () => { let _ = () ; } }\n \n     #[rustc_dummy]\n     stmt_mac!();\n \n     #[rustc_dummy]\n-    stmt_mac!{ };\n+    stmt_mac! { };\n \n     #[rustc_dummy]\n     stmt_mac![];\n \n     #[rustc_dummy]\n-    stmt_mac!{ }\n+    stmt_mac! { }\n \n     let _ = ();\n }\n \n-macro_rules! expr_mac((  ) => { (  ) });\n+macro_rules! expr_mac { () => { () } }\n \n fn _10() {\n     let _ = #[rustc_dummy] expr_mac!();\n     let _ = #[rustc_dummy] expr_mac![];\n-    let _ = #[rustc_dummy] expr_mac!{ };\n+    let _ = #[rustc_dummy] expr_mac! { };\n }\n \n fn _11() {\n@@ -236,7 +236,7 @@ fn _11() {\n     || #[rustc_dummy] return;\n     let _ = #[rustc_dummy] expr_mac!();\n     let _ = #[rustc_dummy] expr_mac![];\n-    let _ = #[rustc_dummy] expr_mac!{ };\n+    let _ = #[rustc_dummy] expr_mac! { };\n     let _ = #[rustc_dummy] Foo{#![rustc_dummy] data: (),};\n     let _ = #[rustc_dummy] Foo{#![rustc_dummy] ..s};\n     let _ = #[rustc_dummy] Foo{#![rustc_dummy] data: (), ..s};"}, {"sha": "570dece023dea363973a3926098d65806834b318", "filename": "src/test/run-make-fulldeps/pretty-expanded-hygiene/input.pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-make-fulldeps%2Fpretty-expanded-hygiene%2Finput.pp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-make-fulldeps%2Fpretty-expanded-hygiene%2Finput.pp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-expanded-hygiene%2Finput.pp.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1,9 +1,9 @@\n // minimal junk\n-#![feature(no_core)]\n-#![no_core]\n+#![feature /* 0#0 */(no_core)]\n+#![no_core /* 0#0 */]\n \n-macro_rules! foo /* 60#0 */(( $ x : ident ) => { y + $ x });\n+macro_rules! foo /* 0#0 */ { ($ x : ident) => { y + $ x } }\n \n-fn bar /* 62#0 */() { let x /* 59#2 */ = 1; y /* 61#4 */ + x /* 59#5 */ }\n+fn bar /* 0#0 */() { let x /* 0#0 */ = 1; y /* 0#1 */ + x /* 0#0 */ }\n \n-fn y /* 61#0 */() { }\n+fn y /* 0#0 */() { }"}, {"sha": "7e46260d5163f7282e633e67da4a696b378b9c47", "filename": "src/test/run-pass/macros/syntax-extension-source-utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-pass%2Fmacros%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-pass%2Fmacros%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fsyntax-extension-source-utils.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n     assert_eq!(column!(), 16);\n     assert_eq!(indirect_line!(), 19);\n     assert!((file!().ends_with(\"syntax-extension-source-utils.rs\")));\n-    assert_eq!(stringify!((2*3) + 5).to_string(), \"( 2 * 3 ) + 5\".to_string());\n+    assert_eq!(stringify!((2*3) + 5).to_string(), \"(2 * 3) + 5\".to_string());\n     assert!(include!(\"syntax-extension-source-utils-files/includeme.\\\n                       fragment\").to_string()\n            == \"victory robot 6\".to_string());\n@@ -33,5 +33,5 @@ pub fn main() {\n     // The Windows tests are wrapped in an extra module for some reason\n     assert!((m1::m2::where_am_i().ends_with(\"m1::m2\")));\n \n-    assert_eq!((36, \"( 2 * 3 ) + 5\"), (line!(), stringify!((2*3) + 5)));\n+    assert_eq!((36, \"(2 * 3) + 5\"), (line!(), stringify!((2*3) + 5)));\n }"}, {"sha": "3e6af67a9f4124ea82a8e61fe1d605e294286396", "filename": "src/test/run-pass/proc-macro/auxiliary/derive-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-pass%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Frun-pass%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -10,7 +10,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(B, attributes(B, C))]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"#[B [ arbitrary tokens ]]\"));\n+    assert!(input.contains(\"#[B[arbitrary tokens]]\"));\n     assert!(input.contains(\"struct B {\"));\n     assert!(input.contains(\"#[C]\"));\n     \"\".parse().unwrap()"}, {"sha": "321545740cf486f430d6b51584bebc9f6caa6b06", "filename": "src/test/ui/editions/edition-keywords-2015-2018-expansion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -7,8 +7,8 @@ LL |     produces_async! {}\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n help: you can escape reserved keywords to use them as identifiers\n    |\n-LL | (  ) => ( pub fn r#async (  ) {  } )\n-   |                  ^^^^^^^\n+LL | () => (pub fn r#async () { })\n+   |               ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3c4a153353447f2b2778f1959941e5f32b680003", "filename": "src/test/ui/editions/edition-keywords-2018-2015-parsing.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -31,10 +31,10 @@ LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n \n error: macro expansion ends with an incomplete expression: expected one of `move`, `|`, or `||`\n-  --> <::edition_kw_macro_2015::passes_ident macros>:1:25\n+  --> <::edition_kw_macro_2015::passes_ident macros>:1:22\n    |\n-LL | ( $ i : ident ) => ( $ i )\n-   |                         ^ expected one of `move`, `|`, or `||` here\n+LL | ($ i : ident) => ($ i)\n+   |                      ^ expected one of `move`, `|`, or `||` here\n    | \n   ::: $DIR/edition-keywords-2018-2015-parsing.rs:16:8\n    |"}, {"sha": "8942e3ce430a8e71edab78f36f89efa5bfbd5cdc", "filename": "src/test/ui/editions/edition-keywords-2018-2018-expansion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -7,8 +7,8 @@ LL |     produces_async! {}\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n help: you can escape reserved keywords to use them as identifiers\n    |\n-LL | (  ) => ( pub fn r#async (  ) {  } )\n-   |                  ^^^^^^^\n+LL | () => (pub fn r#async () { })\n+   |               ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "46aa9ca34e17c05c626c4913c49af776e4b8e0c7", "filename": "src/test/ui/editions/edition-keywords-2018-2018-parsing.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -31,10 +31,10 @@ LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n \n error: macro expansion ends with an incomplete expression: expected one of `move`, `|`, or `||`\n-  --> <::edition_kw_macro_2018::passes_ident macros>:1:25\n+  --> <::edition_kw_macro_2018::passes_ident macros>:1:22\n    |\n-LL | ( $ i : ident ) => ( $ i )\n-   |                         ^ expected one of `move`, `|`, or `||` here\n+LL | ($ i : ident) => ($ i)\n+   |                      ^ expected one of `move`, `|`, or `||` here\n    | \n   ::: $DIR/edition-keywords-2018-2018-parsing.rs:16:8\n    |"}, {"sha": "e7bd141ccd5ae94dc3b1b2fdb149d991dc698735", "filename": "src/test/ui/macro_backtrace/main.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -24,10 +24,10 @@ LL |       ping!();\n    | \n   ::: <::ping::ping macros>:1:1\n    |\n-LL |   (  ) => { pong ! (  ) ; }\n-   |   -------------------------\n-   |   |         |\n-   |   |         in this macro invocation\n+LL |   () => { pong ! () ; }\n+   |   ---------------------\n+   |   |       |\n+   |   |       in this macro invocation\n    |   in this expansion of `ping!`\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `error`\n@@ -44,34 +44,34 @@ LL |       deep!();\n    | \n   ::: <::ping::deep macros>:1:1\n    |\n-LL |   (  ) => { foo ! (  ) ; }\n-   |   ------------------------\n-   |   |         |\n-   |   |         in this macro invocation (#2)\n+LL |   () => { foo ! () ; }\n+   |   --------------------\n+   |   |       |\n+   |   |       in this macro invocation (#2)\n    |   in this expansion of `deep!` (#1)\n    | \n   ::: <::ping::foo macros>:1:1\n    |\n-LL |   (  ) => { bar ! (  ) ; }\n-   |   ------------------------\n-   |   |         |\n-   |   |         in this macro invocation (#3)\n+LL |   () => { bar ! () ; }\n+   |   --------------------\n+   |   |       |\n+   |   |       in this macro invocation (#3)\n    |   in this expansion of `foo!` (#2)\n    | \n   ::: <::ping::bar macros>:1:1\n    |\n-LL |   (  ) => { ping ! (  ) ; }\n-   |   -------------------------\n-   |   |         |\n-   |   |         in this macro invocation (#4)\n+LL |   () => { ping ! () ; }\n+   |   ---------------------\n+   |   |       |\n+   |   |       in this macro invocation (#4)\n    |   in this expansion of `bar!` (#3)\n    | \n   ::: <::ping::ping macros>:1:1\n    |\n-LL |   (  ) => { pong ! (  ) ; }\n-   |   -------------------------\n-   |   |         |\n-   |   |         in this macro invocation (#5)\n+LL |   () => { pong ! () ; }\n+   |   ---------------------\n+   |   |       |\n+   |   |       in this macro invocation (#5)\n    |   in this expansion of `ping!` (#4)\n \n error: aborting due to 3 previous errors"}, {"sha": "287f7b297d5c60350dc226b1597808d37969789c", "filename": "src/test/ui/macros/trace-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -5,5 +5,5 @@ LL |     println!(\"Hello, World!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: expanding `println! { \"Hello, World!\" }`\n-   = note: to `{ $crate :: io :: _print ( format_args_nl ! ( \"Hello, World!\" ) ) ; }`\n+   = note: to `{ $crate :: io :: _print (format_args_nl ! (\"Hello, World!\")) ; }`\n "}, {"sha": "f06e6581ff7fb0b2cb9a160a473b5d3e770522a8", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -17,7 +17,7 @@ LL |     my_faulty_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: expanding `my_faulty_macro! {  }`\n-   = note: to `my_faulty_macro ! ( bcd ) ;`\n+   = note: to `my_faulty_macro ! (bcd) ;`\n    = note: expanding `my_faulty_macro! { bcd }`\n \n error: recursion limit reached while expanding the macro `my_recursive_macro`\n@@ -38,13 +38,13 @@ LL |     my_recursive_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n+   = note: to `my_recursive_macro ! () ;`\n    = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n+   = note: to `my_recursive_macro ! () ;`\n    = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n+   = note: to `my_recursive_macro ! () ;`\n    = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n+   = note: to `my_recursive_macro ! () ;`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "faf31712156654edaf1f5431c435c1d5af7388a7", "filename": "src/test/ui/proc-macro/attribute-spans-preserved.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-spans-preserved.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-spans-preserved.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-spans-preserved.stdout?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1 +1 @@\n-fn main (  ) { let y : u32 = \"z\" ; { let x : u32 = \"y\" ; } }\n+fn main () { let y : u32 = \"z\" ; { let x : u32 = \"y\" ; } }"}, {"sha": "0fe02a9a34d18ba21e9d74841d54d2db183b3bf0", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "a499e1362ec0bba94c0d17779067d9a631be7b9c", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1,5 +1,5 @@\n PRINT-ATTR INPUT (DISPLAY): struct A(identity!(crate :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( identity ! ( $crate :: S ) ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -55,7 +55,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct B ( identity ! ( $crate :: S ) ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct B (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "72b02ebcb76f450e80ce4937ce4c59b1c197e856", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/92b0f52584c9375505ecdefdd7855b93a5919d51/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=92b0f52584c9375505ecdefdd7855b93a5919d51", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -80,7 +80,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -120,7 +120,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -161,7 +161,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -202,7 +202,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}]}