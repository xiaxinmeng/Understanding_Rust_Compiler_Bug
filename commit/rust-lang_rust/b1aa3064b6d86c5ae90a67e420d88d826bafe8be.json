{"sha": "b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "node_id": "C_kwDOAAsO6NoAKGIxYWEzMDY0YjZkODZjNWFlOTBhNjdlNDIwZDg4ZDgyNmJhZmU4YmU", "commit": {"author": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-05T15:43:44Z"}, "committer": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-09T09:47:06Z"}, "message": "Address PR comments", "tree": {"sha": "61e209d33154673478fe6f51dcea0ff9603a9528", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e209d33154673478fe6f51dcea0ff9603a9528"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "html_url": "https://github.com/rust-lang/rust/commit/b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/comments", "author": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9c8d32f2d7984545816ee07e1e7213b36013f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9c8d32f2d7984545816ee07e1e7213b36013f0", "html_url": "https://github.com/rust-lang/rust/commit/dd9c8d32f2d7984545816ee07e1e7213b36013f0"}], "stats": {"total": 148, "additions": 85, "deletions": 63}, "files": [{"sha": "5d6409874d8f9590a7e101e4dc74ed7222e4515d", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::get_vec_init_kind;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{path_to_local_id, peel_hir_expr_while, ty::is_uninit_value_valid_for_ty, SpanlessEq};\n+use clippy_utils::higher::get_vec_init_kind;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -16,10 +17,14 @@ declare_clippy_lint! {\n     /// `with_capacity()` or `reserve()`.\n     ///\n     /// ### Why is this bad?\n-    /// It creates a `Vec` with uninitialized data, which leads to an\n+    /// It creates a `Vec` with uninitialized data, which leads to\n     /// undefined behavior with most safe operations.\n+    ///\n     /// Notably, uninitialized `Vec<u8>` must not be used with generic `Read`.\n     ///\n+    /// ### Known Problems\n+    /// This lint only checks directly adjacent statements.\n+    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// let mut vec: Vec<u8> = Vec::with_capacity(1000);\n@@ -52,16 +57,20 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UninitVec => [UNINIT_VEC]);\n \n+// FIXME: update to a visitor-based implementation.\n+// Threads: https://github.com/rust-lang/rust-clippy/pull/7682#discussion_r710998368\n impl<'tcx> LateLintPass<'tcx> for UninitVec {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        for w in block.stmts.windows(2) {\n-            if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = w[1].kind {\n-                handle_uninit_vec_pair(cx, &w[0], expr);\n+        if !in_external_macro(cx.tcx.sess, block.span) {\n+            for w in block.stmts.windows(2) {\n+                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = w[1].kind {\n+                    handle_uninit_vec_pair(cx, &w[0], expr);\n+                }\n             }\n-        }\n \n-        if let (Some(stmt), Some(expr)) = (block.stmts.last(), block.expr) {\n-            handle_uninit_vec_pair(cx, stmt, expr);\n+            if let (Some(stmt), Some(expr)) = (block.stmts.last(), block.expr) {\n+                handle_uninit_vec_pair(cx, stmt, expr);\n+            }\n         }\n     }\n }\n@@ -79,6 +88,8 @@ fn handle_uninit_vec_pair(\n         if let ty::Adt(_, substs) = vec_ty.kind();\n         // Check T of Vec<T>\n         if !is_uninit_value_valid_for_ty(cx, substs.type_at(0));\n+        // `#[allow(...)]` attribute can be set on enclosing unsafe block of `set_len()`\n+        if !is_lint_allowed(cx, UNINIT_VEC, maybe_set_len.hir_id);\n         then {\n             // FIXME: #7698, false positive of the internal lints\n             #[allow(clippy::collapsible_span_lint_calls)]"}, {"sha": "b92b6ca4f4380f981ee9f9ed163d44470994555c", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::source::snippet;\n-use clippy_utils::{get_vec_init_kind, path_to_local, path_to_local_id, VecInitKind};\n+use clippy_utils::{path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, Stmt, StmtKind};"}, {"sha": "d60ddbd3c562dadfcb00fe7d1559db91fcf4f746", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -2,11 +2,14 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n+use crate::ty::is_type_diagnostic_item;\n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n+use rustc_hir::{\n+    Arm, Block, BorrowKind, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath, StmtKind, UnOp,\n+};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n@@ -632,3 +635,51 @@ impl PanicExpn<'tcx> {\n         }\n     }\n }\n+\n+/// A parsed `Vec` initialization expression\n+#[derive(Clone, Copy)]\n+pub enum VecInitKind {\n+    /// `Vec::new()`\n+    New,\n+    /// `Vec::default()` or `Default::default()`\n+    Default,\n+    /// `Vec::with_capacity(123)`\n+    WithLiteralCapacity(u64),\n+    /// `Vec::with_capacity(slice.len())`\n+    WithExprCapacity(HirId),\n+}\n+\n+/// Checks if given expression is an initialization of `Vec` and returns its kind.\n+pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    return args.get(0).and_then(|arg| {\n+                        if_chain! {\n+                            if let ExprKind::Lit(lit) = &arg.kind;\n+                            if let LitKind::Int(num, _) = lit.node;\n+                            then {\n+                                Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n+                            } else {\n+                                Some(VecInitKind::WithExprCapacity(arg.hir_id))\n+                            }\n+                        }\n+                    });\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n+            {\n+                return Some(VecInitKind::Default);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}"}, {"sha": "09eee78f0d1ffeb339cc1c11d6ff91dde1145281", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -93,7 +93,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type, is_type_diagnostic_item};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -1789,53 +1789,6 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n     }\n }\n \n-#[derive(Clone, Copy)]\n-pub enum VecInitKind {\n-    /// `Vec::new()`\n-    New,\n-    /// `Vec::default()` or `Default::default()`\n-    Default,\n-    /// `Vec::with_capacity(123)`\n-    WithLiteralCapacity(u64),\n-    /// `Vec::with_capacity(slice.len())`\n-    WithExprCapacity(HirId),\n-}\n-\n-/// Checks if given expression is an initialization of `Vec` and returns its kind.\n-pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n-    if let ExprKind::Call(func, args) = expr.kind {\n-        match func.kind {\n-            ExprKind::Path(QPath::TypeRelative(ty, name))\n-                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n-            {\n-                if name.ident.name == sym::new {\n-                    return Some(VecInitKind::New);\n-                } else if name.ident.name.as_str() == \"with_capacity\" {\n-                    return args.get(0).and_then(|arg| {\n-                        if_chain! {\n-                            if let ExprKind::Lit(lit) = &arg.kind;\n-                            if let LitKind::Int(num, _) = lit.node;\n-                            then {\n-                                Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n-                            } else {\n-                                Some(VecInitKind::WithExprCapacity(arg.hir_id))\n-                            }\n-                        }\n-                    });\n-                }\n-            }\n-            ExprKind::Path(QPath::Resolved(_, path))\n-                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n-                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n-            {\n-                return Some(VecInitKind::Default);\n-            }\n-            _ => (),\n-        }\n-    }\n-    None\n-}\n-\n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let mut child_id = expr.hir_id;"}, {"sha": "e43c5756021452e30e5f0fdb5706858a5c7237c8", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -183,6 +183,5 @@ pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n-pub const VEC_SET_LEN: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"set_len\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}, {"sha": "c8f9067e549f0285eacd0c9347de217e91b99d36", "filename": "tests/ui/uninit_vec.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1aa3064b6d86c5ae90a67e420d88d826bafe8be/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=b1aa3064b6d86c5ae90a67e420d88d826bafe8be", "patch": "@@ -48,6 +48,13 @@ fn main() {\n         my_vec.vec.set_len(200);\n     }\n \n+    // Test `#[allow(...)]` attributes on inner unsafe block (shouldn't trigger)\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    #[allow(clippy::uninit_vec)]\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n     // MaybeUninit-wrapped types should not be detected\n     unsafe {\n         let mut vec: Vec<MaybeUninit<u8>> = Vec::with_capacity(1000);\n@@ -64,7 +71,7 @@ fn main() {\n     let mut vec1: Vec<u8> = Vec::with_capacity(1000);\n     let mut vec2: Vec<u8> = Vec::with_capacity(1000);\n     unsafe {\n-        vec1.reserve(200);\n-        vec2.reserve(200);\n+        vec1.set_len(200);\n+        vec2.set_len(200);\n     }\n }"}]}