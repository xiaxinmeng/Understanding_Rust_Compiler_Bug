{"sha": "c684df103e05a15d4e0403b5fca1197f16d15703", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ODRkZjEwM2UwNWExNWQ0ZTA0MDNiNWZjYTExOTdmMTZkMTU3MDM=", "commit": {"author": {"name": "novalis", "email": "novalis@novalis.org", "date": "2013-09-06T01:18:55Z"}, "committer": {"name": "novalis", "email": "novalis@novalis.org", "date": "2013-09-07T13:14:52Z"}, "message": "Handle global log levels (fixes #6033)", "tree": {"sha": "23f761a8426877be5aa85ec0cbeb80ee03b4375f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f761a8426877be5aa85ec0cbeb80ee03b4375f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c684df103e05a15d4e0403b5fca1197f16d15703", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c684df103e05a15d4e0403b5fca1197f16d15703", "html_url": "https://github.com/rust-lang/rust/commit/c684df103e05a15d4e0403b5fca1197f16d15703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c684df103e05a15d4e0403b5fca1197f16d15703/comments", "author": {"login": "novalis", "id": 77003, "node_id": "MDQ6VXNlcjc3MDAz", "avatar_url": "https://avatars.githubusercontent.com/u/77003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/novalis", "html_url": "https://github.com/novalis", "followers_url": "https://api.github.com/users/novalis/followers", "following_url": "https://api.github.com/users/novalis/following{/other_user}", "gists_url": "https://api.github.com/users/novalis/gists{/gist_id}", "starred_url": "https://api.github.com/users/novalis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/novalis/subscriptions", "organizations_url": "https://api.github.com/users/novalis/orgs", "repos_url": "https://api.github.com/users/novalis/repos", "events_url": "https://api.github.com/users/novalis/events{/privacy}", "received_events_url": "https://api.github.com/users/novalis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "novalis", "id": 77003, "node_id": "MDQ6VXNlcjc3MDAz", "avatar_url": "https://avatars.githubusercontent.com/u/77003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/novalis", "html_url": "https://github.com/novalis", "followers_url": "https://api.github.com/users/novalis/followers", "following_url": "https://api.github.com/users/novalis/following{/other_user}", "gists_url": "https://api.github.com/users/novalis/gists{/gist_id}", "starred_url": "https://api.github.com/users/novalis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/novalis/subscriptions", "organizations_url": "https://api.github.com/users/novalis/orgs", "repos_url": "https://api.github.com/users/novalis/repos", "events_url": "https://api.github.com/users/novalis/events{/privacy}", "received_events_url": "https://api.github.com/users/novalis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c891fa326d28818582a653e588463c45f82e5795", "url": "https://api.github.com/repos/rust-lang/rust/commits/c891fa326d28818582a653e588463c45f82e5795", "html_url": "https://github.com/rust-lang/rust/commit/c891fa326d28818582a653e588463c45f82e5795"}], "stats": {"total": 136, "additions": 100, "deletions": 36}, "files": [{"sha": "8a4aba3eb8792d0713df1ae62b02146e4325abed", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 100, "deletions": 36, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c684df103e05a15d4e0403b5fca1197f16d15703/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c684df103e05a15d4e0403b5fca1197f16d15703/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=c684df103e05a15d4e0403b5fca1197f16d15703", "patch": "@@ -15,13 +15,12 @@ use rt::util::dumb_println;\n use str::StrSlice;\n use str::raw::from_c_str;\n use u32;\n-use u32::{min};\n use unstable::raw::Closure;\n use vec::ImmutableVector;\n \n \n struct LogDirective {\n-    name: ~str,\n+    name: Option<~str>,\n     level: u32\n }\n \n@@ -74,7 +73,7 @@ static log_level_names : &'static[&'static str] = &'static[\"error\", \"warn\", \"inf\n fn parse_log_level(level: &str) -> Option<u32> {\n     let num = u32::from_str(level);\n     let mut log_level;\n-    match (num) {\n+    match num {\n         Some(num) => {\n             if num < MAX_LOG_LEVEL {\n                 log_level = Some(num);\n@@ -84,9 +83,9 @@ fn parse_log_level(level: &str) -> Option<u32> {\n         }\n         _ => {\n             let position = log_level_names.iter().position(|&name| name == level);\n-            match (position) {\n+            match position {\n                 Some(position) => {\n-                    log_level = Some(min(MAX_LOG_LEVEL, (position + 1) as u32))\n+                    log_level = Some(u32::min(MAX_LOG_LEVEL, (position + 1) as u32))\n                 },\n                 _ => {\n                     log_level = None;\n@@ -108,8 +107,22 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n     for s in spec.split_iter(',') {\n         let parts: ~[&str] = s.split_iter('=').collect();\n         let mut log_level;\n+        let mut name = Some(parts[0].to_owned());\n         match parts.len() {\n-            1 => log_level = MAX_LOG_LEVEL,\n+            1 => {\n+                //if the single argument is a log-level string or number,\n+                //treat that as a global fallback\n+                let possible_log_level = parse_log_level(parts[0]);\n+                match possible_log_level {\n+                    Some(num) => {\n+                        name = None;\n+                        log_level = num;\n+                    },\n+                    _ => {\n+                        log_level = MAX_LOG_LEVEL\n+                    }\n+                }\n+            }\n             2 => {\n                 let possible_log_level = parse_log_level(parts[1]);\n                 match possible_log_level {\n@@ -129,7 +142,7 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n                 loop;\n             }\n         }\n-        let dir = LogDirective {name: parts[0].to_owned(), level: log_level};\n+        let dir = LogDirective {name: name, level: log_level};\n         dirs.push(dir);\n     }\n     return dirs;\n@@ -139,18 +152,30 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n /// of log directives\n fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n-    let mut longest_match = 0;\n+    let mut longest_match = -1i;\n     unsafe {\n         for dir in dirs.iter() {\n-            let name = from_c_str((*entry).name);\n-            if name.starts_with(dir.name) && dir.name.len() > longest_match {\n-                longest_match = dir.name.len();\n-                new_lvl = dir.level;\n-            }\n+            match dir.name {\n+                None => {\n+                    if longest_match == -1 {\n+                        longest_match = 0;\n+                        new_lvl = dir.level;\n+                    }\n+                }\n+                Some(ref dir_name) => {\n+                    let name = from_c_str((*entry).name);\n+                    let len = dir_name.len() as int;\n+                    if name.starts_with(*dir_name) &&\n+                        len >= longest_match {\n+                        longest_match = len;\n+                        new_lvl = dir.level;\n+                    }\n+                }\n+            };\n         }\n         *(*entry).log_level = new_lvl;\n     }\n-    if longest_match > 0 { return 1; } else { return 0; }\n+    if longest_match >= 0 { return 1; } else { return 0; }\n }\n \n #[fixed_stack_segment] #[inline(never)]\n@@ -264,54 +289,66 @@ extern {\n // Tests for parse_logging_spec()\n #[test]\n fn parse_logging_spec_valid() {\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n     assert_eq!(dirs.len(), 3);\n-    assert!(dirs[0].name == ~\"crate1::mod1\");\n+    assert!(dirs[0].name == Some(~\"crate1::mod1\"));\n     assert_eq!(dirs[0].level, 1);\n \n-    assert!(dirs[1].name == ~\"crate1::mod2\");\n+    assert!(dirs[1].name == Some(~\"crate1::mod2\"));\n     assert_eq!(dirs[1].level, MAX_LOG_LEVEL);\n \n-    assert!(dirs[2].name == ~\"crate2\");\n+    assert!(dirs[2].name == Some(~\"crate2\"));\n     assert_eq!(dirs[2].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_crate() {\n     // test parse_logging_spec with multiple = in specification\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == ~\"crate2\");\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_log_level() {\n     // test parse_logging_spec with 'noNumber' as log level\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == ~\"crate2\");\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_string_log_level() {\n     // test parse_logging_spec with 'warn' as log level\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == ~\"crate2\");\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n     assert_eq!(dirs[0].level, 2);\n }\n \n+#[test]\n+fn parse_logging_spec_global() {\n+    // test parse_logging_spec with no crate\n+    let dirs = parse_logging_spec(~\"warn,crate2=4\");\n+    assert_eq!(dirs.len(), 2);\n+    assert!(dirs[0].name == None);\n+    assert_eq!(dirs[0].level, 2);\n+    assert!(dirs[1].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[1].level, 4);\n+}\n+\n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-    LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate1::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 2);\n             assert!(m == 1);\n@@ -322,11 +359,12 @@ fn update_entry_match_full_path() {\n #[test]\n fn update_entry_no_match() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate3::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n             assert!(m == 0);\n@@ -337,11 +375,12 @@ fn update_entry_no_match() {\n #[test]\n fn update_entry_match_beginning() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate2::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 3);\n             assert!(m == 1);\n@@ -352,14 +391,39 @@ fn update_entry_match_beginning() {\n #[test]\n fn update_entry_match_beginning_longest_match() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}, LogDirective {name: ~\"crate2::mod\", level: 4}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3},\n+                 LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate2::mod1\".to_c_str().with_ref |ptr| {\n-            let entry = &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry = &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 4);\n             assert!(m == 1);\n         }\n     }\n }\n+\n+#[test]\n+fn update_entry_match_default() {\n+    use c_str::ToCStr;\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: None, level: 3}\n+                ];\n+    let level = &mut 0;\n+    unsafe {\n+        do \"crate1::mod1\".to_c_str().with_ref |ptr| {\n+            let entry= &ModEntry {name: ptr, log_level: level};\n+            let m = update_entry(dirs, transmute(entry));\n+            assert!(*entry.log_level == 2);\n+            assert!(m == 1);\n+        }\n+        do \"crate2::mod2\".to_c_str().with_ref |ptr| {\n+            let entry= &ModEntry {name: ptr, log_level: level};\n+            let m = update_entry(dirs, transmute(entry));\n+            assert!(*entry.log_level == 3);\n+            assert!(m == 1);\n+        }\n+    }\n+}"}]}