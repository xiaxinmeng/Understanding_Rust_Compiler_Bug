{"sha": "1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "node_id": "C_kwDOAAsO6NoAKDFkMWZlY2ZmMGZiYjcyNzkxOTA2N2ExYTZhNWQyOGQzMGM2OTNjZDM", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-04-01T17:23:47Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-04-26T12:16:54Z"}, "message": "`needless_late_init`: ignore `if let`, `let mut` and significant drops", "tree": {"sha": "df0b46e6e147b5625b217df837a2ce10dfc448e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0b46e6e147b5625b217df837a2ce10dfc448e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "html_url": "https://github.com/rust-lang/rust/commit/1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9938daf5bcf3b1f2ee0b79f9d85d5460b1137f72", "url": "https://api.github.com/repos/rust-lang/rust/commits/9938daf5bcf3b1f2ee0b79f9d85d5460b1137f72", "html_url": "https://github.com/rust-lang/rust/commit/9938daf5bcf3b1f2ee0b79f9d85d5460b1137f72"}], "stats": {"total": 360, "additions": 221, "deletions": 139}, "files": [{"sha": "a34ed58c9c35914c14f0402b4f8af2efb3be21ec", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -2,17 +2,16 @@ use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::ty::needs_ordered_drop;\n use clippy_utils::{higher, match_def_path};\n use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{\n     intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, LangItem, Node, Pat, PatKind, QPath, UnOp,\n+    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n@@ -32,59 +31,6 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }\n }\n \n-/// Checks if the drop order for a type matters. Some std types implement drop solely to\n-/// deallocate memory. For these types, and composites containing them, changing the drop order\n-/// won't result in any observable side effects.\n-fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-}\n-\n-fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n-    if !seen.insert(ty) {\n-        return false;\n-    }\n-    if !ty.needs_drop(cx.tcx, cx.param_env) {\n-        false\n-    } else if !cx\n-        .tcx\n-        .lang_items()\n-        .drop_trait()\n-        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-    {\n-        // This type doesn't implement drop, so no side effects here.\n-        // Check if any component type has any.\n-        match ty.kind() {\n-            ty::Tuple(fields) => fields.iter().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n-            ty::Adt(adt, subs) => adt\n-                .all_fields()\n-                .map(|f| f.ty(cx.tcx, subs))\n-                .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            _ => true,\n-        }\n-    }\n-    // Check for std types which implement drop, but only for memory allocation.\n-    else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-        || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-        || is_type_diagnostic_item(cx, ty, sym::Rc)\n-        || is_type_diagnostic_item(cx, ty, sym::Arc)\n-        || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-        || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-        || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-        || match_type(cx, ty, &paths::WEAK_RC)\n-        || match_type(cx, ty, &paths::WEAK_ARC)\n-    {\n-        // Check all of the generic arguments.\n-        if let ty::Adt(_, subs) = ty.kind() {\n-            subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-        } else {\n-            true\n-        }\n-    } else {\n-        true\n-    }\n-}\n-\n // Extract the generic arguments out of a type\n fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     if_chain! {\n@@ -115,7 +61,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                 // e.g. In `(String::new(), 0).1` the string is a temporary value.\n                 ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n                     if !matches!(expr.kind, ExprKind::Path(_)) {\n-                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(expr);\n@@ -126,7 +72,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                 // e.g. In `(vec![0])[0]` the vector is a temporary value.\n                 ExprKind::Index(base, index) => {\n                     if !matches!(base.kind, ExprKind::Path(_)) {\n-                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(base);\n@@ -143,7 +89,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                             .typeck_results()\n                             .type_dependent_def_id(expr.hir_id)\n                             .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                        if self_by_ref && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(self_arg);\n@@ -243,7 +189,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // scrutinee would be, so they have to be considered as well.\n     // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n     // for the duration if body.\n-    let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n \n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {"}, {"sha": "a863a7990ca8cd2afb834d9ab6e413101c70cc00", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -1,10 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::visitors::{expr_visitor, is_local_used};\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::{expr_visitor, expr_visitor_no_bodies, is_local_used};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{\n+    BindingAnnotation, Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt,\n+    StmtKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n@@ -73,6 +77,31 @@ fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) ->\n     seen\n }\n \n+fn contains_let(cond: &Expr<'_>) -> bool {\n+    let mut seen = false;\n+    expr_visitor_no_bodies(|expr| {\n+        if let ExprKind::Let(_) = expr.kind {\n+            seen = true;\n+        }\n+\n+        !seen\n+    })\n+    .visit_expr(cond);\n+\n+    seen\n+}\n+\n+fn stmt_needs_ordered_drop(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n+    let StmtKind::Local(local) = stmt.kind else { return false };\n+    !local.pat.walk_short(|pat| {\n+        if let PatKind::Binding(.., None) = pat.kind {\n+            !needs_ordered_drop(cx, cx.typeck_results().pat_ty(pat))\n+        } else {\n+            true\n+        }\n+    })\n+}\n+\n #[derive(Debug)]\n struct LocalAssign {\n     lhs_id: HirId,\n@@ -187,11 +216,14 @@ fn first_usage<'tcx>(\n     local_stmt_id: HirId,\n     block: &'tcx Block<'tcx>,\n ) -> Option<Usage<'tcx>> {\n+    let significant_drop = needs_ordered_drop(cx, cx.typeck_results().node_type(binding_id));\n+\n     block\n         .stmts\n         .iter()\n         .skip_while(|stmt| stmt.hir_id != local_stmt_id)\n         .skip(1)\n+        .take_while(|stmt| !significant_drop || !stmt_needs_ordered_drop(cx, stmt))\n         .find(|&stmt| is_local_used(cx, stmt, binding_id))\n         .and_then(|stmt| match stmt.kind {\n             StmtKind::Expr(expr) => Some(Usage {\n@@ -258,7 +290,7 @@ fn check<'tcx>(\n                 },\n             );\n         },\n-        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+        ExprKind::If(cond, then_expr, Some(else_expr)) if !contains_let(cond) => {\n             let (applicability, suggestions) = assignment_suggestions(cx, binding_id, [then_expr, else_expr])?;\n \n             span_lint_and_then(\n@@ -338,7 +370,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessLateInit {\n             if let Local {\n                 init: None,\n                 pat: &Pat {\n-                    kind: PatKind::Binding(_, binding_id, _, None),\n+                    kind: PatKind::Binding(BindingAnnotation::Unannotated, binding_id, _, None),\n                     ..\n                 },\n                 source: LocalSource::Normal,"}, {"sha": "901e3e5390c5dbbe9a4ac6d54a6adaaa0a737ec7", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -3,11 +3,11 @@\n #![allow(clippy::module_name_repetitions)]\n \n use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, TyKind, Unsafety};\n+use rustc_hir::{Expr, LangItem, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n@@ -22,7 +22,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr, path_res};\n+use crate::{match_def_path, must_use_attr, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -83,6 +83,20 @@ pub fn get_associated_type<'tcx>(\n         })\n }\n \n+/// Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type\n+/// implements a trait marked with a diagnostic item use [`implements_trait`].\n+///\n+/// For a further exploitation what diagnostic items are see [diagnostic items] in\n+/// rustc-dev-guide.\n+///\n+/// [Diagnostic Items]: https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html\n+pub fn get_type_diagnostic_name(cx: &LateContext<'_>, ty: Ty<'_>) -> Option<Symbol> {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.get_diagnostic_name(adt.did()),\n+        _ => None,\n+    }\n+}\n+\n /// Returns true if ty has `iter` or `iter_mut` methods\n pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n@@ -319,6 +333,57 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     }\n }\n \n+/// Checks if the drop order for a type matters. Some std types implement drop solely to\n+/// deallocate memory. For these types, and composites containing them, changing the drop order\n+/// won't result in any observable side effects.\n+pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+        if !seen.insert(ty) {\n+            return false;\n+        }\n+        if !ty.has_significant_drop(cx.tcx, cx.param_env) {\n+            false\n+        }\n+        // Check for std types which implement drop, but only for memory allocation.\n+        else if is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+            || matches!(\n+                get_type_diagnostic_name(cx, ty),\n+                Some(sym::HashSet | sym::Rc | sym::Arc | sym::cstring_type)\n+            )\n+            || match_type(cx, ty, &paths::WEAK_RC)\n+            || match_type(cx, ty, &paths::WEAK_ARC)\n+        {\n+            // Check all of the generic arguments.\n+            if let ty::Adt(_, subs) = ty.kind() {\n+                subs.types().any(|ty| needs_ordered_drop_inner(cx, ty, seen))\n+            } else {\n+                true\n+            }\n+        } else if !cx\n+            .tcx\n+            .lang_items()\n+            .drop_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n+            // This type doesn't implement drop, so no side effects here.\n+            // Check if any component type has any.\n+            match ty.kind() {\n+                ty::Tuple(fields) => fields.iter().any(|ty| needs_ordered_drop_inner(cx, ty, seen)),\n+                ty::Array(ty, _) => needs_ordered_drop_inner(cx, *ty, seen),\n+                ty::Adt(adt, subs) => adt\n+                    .all_fields()\n+                    .map(|f| f.ty(cx.tcx, subs))\n+                    .any(|ty| needs_ordered_drop_inner(cx, ty, seen)),\n+                _ => true,\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+}\n+\n /// Peels off all references on the type. Returns the underlying type and the number of references\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {"}, {"sha": "54e66b391b8d8a46068df048cf91c17bf8a5d03c", "filename": "tests/ui/needless_late_init.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.rs?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -1,5 +1,15 @@\n-#![allow(unused)]\n-#![allow(clippy::let_unit_value)]\n+#![feature(let_chains)]\n+#![allow(unused, clippy::nonminimal_bool, clippy::let_unit_value)]\n+\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n+use std::rc::Rc;\n+\n+struct SignificantDrop;\n+impl std::ops::Drop for SignificantDrop {\n+    fn drop(&mut self) {\n+        println!(\"dropped\");\n+    }\n+}\n \n fn main() {\n     let a;\n@@ -18,13 +28,6 @@ fn main() {\n         b = \"five\"\n     }\n \n-    let c;\n-    if let Some(n) = Some(5) {\n-        c = n;\n-    } else {\n-        c = -50;\n-    }\n-\n     let d;\n     if true {\n         let temp = 5;\n@@ -37,7 +40,7 @@ fn main() {\n     if true {\n         e = format!(\"{} {}\", a, b);\n     } else {\n-        e = format!(\"{}\", c);\n+        e = format!(\"{}\", n);\n     }\n \n     let f;\n@@ -53,7 +56,27 @@ fn main() {\n         panic!();\n     }\n \n-    println!(\"{}\", a);\n+    // Drop order only matters if both are significant\n+    let x;\n+    let y = SignificantDrop;\n+    x = 1;\n+\n+    let x;\n+    let y = 1;\n+    x = SignificantDrop;\n+\n+    let x;\n+    // types that should be considered insignificant\n+    let y = 1;\n+    let y = \"2\";\n+    let y = String::new();\n+    let y = vec![3.0];\n+    let y = HashMap::<usize, usize>::new();\n+    let y = BTreeMap::<usize, usize>::new();\n+    let y = HashSet::<usize>::new();\n+    let y = BTreeSet::<usize>::new();\n+    let y = Box::new(4);\n+    x = SignificantDrop;\n }\n \n async fn in_async() -> &'static str {\n@@ -177,5 +200,32 @@ fn does_not_lint() {\n     }\n     in_macro!();\n \n-    println!(\"{}\", x);\n+    // ignore if-lets - https://github.com/rust-lang/rust-clippy/issues/8613\n+    let x;\n+    if let Some(n) = Some(\"v\") {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n+\n+    let x;\n+    if true && let Some(n) = Some(\"let chains too\") {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n+\n+    // ignore mut bindings\n+    // https://github.com/shepmaster/twox-hash/blob/b169c16d86eb8ea4a296b0acb9d00ca7e3c3005f/src/sixty_four.rs#L88-L93\n+    // https://github.com/dtolnay/thiserror/blob/21c26903e29cb92ba1a7ff11e82ae2001646b60d/tests/test_generics.rs#L91-L100\n+    let mut x: usize;\n+    x = 1;\n+    x = 2;\n+    x = 3;\n+\n+    // should not move the declaration if `x` has a significant drop, and there\n+    // is another binding with a significant drop between it and the first usage\n+    let x;\n+    let y = SignificantDrop;\n+    x = SignificantDrop;\n }"}, {"sha": "015c173561ac335ba17c0a30d960b257b3ddc255", "filename": "tests/ui/needless_late_init.stderr", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.stderr?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -1,5 +1,5 @@\n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:5:5\n+  --> $DIR/needless_late_init.rs:15:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -21,7 +21,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:14:5\n+  --> $DIR/needless_late_init.rs:24:5\n    |\n LL |     let b;\n    |     ^^^^^^\n@@ -42,28 +42,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:21:5\n-   |\n-LL |     let c;\n-   |     ^^^^^^\n-   |\n-help: declare `c` here\n-   |\n-LL |     let c = if let Some(n) = Some(5) {\n-   |     +++++++\n-help: remove the assignments from the branches\n-   |\n-LL ~         n\n-LL |     } else {\n-LL ~         -50\n-   |\n-help: add a semicolon after the `if` expression\n-   |\n-LL |     };\n-   |      +\n-\n-error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:28:5\n+  --> $DIR/needless_late_init.rs:31:5\n    |\n LL |     let d;\n    |     ^^^^^^\n@@ -84,7 +63,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:36:5\n+  --> $DIR/needless_late_init.rs:39:5\n    |\n LL |     let e;\n    |     ^^^^^^\n@@ -97,15 +76,15 @@ help: remove the assignments from the branches\n    |\n LL ~         format!(\"{} {}\", a, b)\n LL |     } else {\n-LL ~         format!(\"{}\", c)\n+LL ~         format!(\"{}\", n)\n    |\n help: add a semicolon after the `if` expression\n    |\n LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:43:5\n+  --> $DIR/needless_late_init.rs:46:5\n    |\n LL |     let f;\n    |     ^^^^^^\n@@ -121,7 +100,7 @@ LL +         1 => \"three\",\n    | \n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:49:5\n+  --> $DIR/needless_late_init.rs:52:5\n    |\n LL |     let g: usize;\n    |     ^^^^^^^^^^^^^\n@@ -140,9 +119,42 @@ help: add a semicolon after the `if` expression\n LL |     };\n    |      +\n \n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:60:5\n+   |\n+LL |     let x;\n+   |     ^^^^^^\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = 1;\n+   |     ~~~~~\n+\n error: unneeded late initialization\n   --> $DIR/needless_late_init.rs:64:5\n    |\n+LL |     let x;\n+   |     ^^^^^^\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = SignificantDrop;\n+   |     ~~~~~\n+\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:68:5\n+   |\n+LL |     let x;\n+   |     ^^^^^^\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = SignificantDrop;\n+   |     ~~~~~\n+\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:87:5\n+   |\n LL |     let a;\n    |     ^^^^^^\n    |\n@@ -162,7 +174,7 @@ LL |     };\n    |      +\n \n error: unneeded late initialization\n-  --> $DIR/needless_late_init.rs:81:5\n+  --> $DIR/needless_late_init.rs:104:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -182,5 +194,5 @@ help: add a semicolon after the `match` expression\n LL |     };\n    |      +\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "724477e8691df1df790fcdb3efa62cccb49da932", "filename": "tests/ui/needless_late_init_fixable.fixed", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.fixed?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -15,11 +15,5 @@ fn main() {\n     let d: usize = 1;\n \n     \n-    let mut e = 1;\n-    e = 2;\n-\n-    \n-    let h = format!(\"{}\", e);\n-\n-    println!(\"{}\", a);\n+    let e = format!(\"{}\", d);\n }"}, {"sha": "3e6bd36367275dd2f2a55118f3da9dd0fd8da22d", "filename": "tests/ui/needless_late_init_fixable.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.rs?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -14,12 +14,6 @@ fn main() {\n     let d: usize;\n     d = 1;\n \n-    let mut e;\n-    e = 1;\n-    e = 2;\n-\n-    let h;\n-    h = format!(\"{}\", e);\n-\n-    println!(\"{}\", a);\n+    let e;\n+    e = format!(\"{}\", d);\n }"}, {"sha": "c97cd93fd2fe88a72153c6ca57586386409f6bbd", "filename": "tests/ui/needless_late_init_fixable.stderr", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d1fecff0fbb727919067a1a6a5d28d30c693cd3/tests%2Fui%2Fneedless_late_init_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.stderr?ref=1d1fecff0fbb727919067a1a6a5d28d30c693cd3", "patch": "@@ -46,24 +46,13 @@ LL |     let d: usize = 1;\n error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:17:5\n    |\n-LL |     let mut e;\n-   |     ^^^^^^^^^^\n-   |\n-help: declare `e` here\n-   |\n-LL |     let mut e = 1;\n-   |     ~~~~~~~~~\n-\n-error: unneeded late initialization\n-  --> $DIR/needless_late_init_fixable.rs:21:5\n-   |\n-LL |     let h;\n+LL |     let e;\n    |     ^^^^^^\n    |\n-help: declare `h` here\n+help: declare `e` here\n    |\n-LL |     let h = format!(\"{}\", e);\n+LL |     let e = format!(\"{}\", d);\n    |     ~~~~~\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}]}