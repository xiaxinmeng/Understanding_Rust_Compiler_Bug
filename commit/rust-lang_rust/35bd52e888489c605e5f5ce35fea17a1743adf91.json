{"sha": "35bd52e888489c605e5f5ce35fea17a1743adf91", "node_id": "C_kwDOAAsO6NoAKDM1YmQ1MmU4ODg0ODljNjA1ZTVmNWNlMzVmZWExN2ExNzQzYWRmOTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-14T05:58:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-14T05:58:41Z"}, "message": "Rollup merge of #110279 - GuillaumeGomez:compiler-macro-derive, r=notriddle\n\nrustdoc: Correctly handle built-in compiler proc-macros as proc-macro and not macro\n\nPart of https://github.com/rust-lang/rust/issues/110111.\n\nThere were actually one issue split in two parts:\n * Compiler built-in proc-macro were incorrectly considered as macros and not proc-macros.\n * Re-exports of compiler built-in proc-macros were considering them as macros.\n\nBoth issues can be fixed by looking at the `MacroKind` variant instead of just relying on information extracted later on.\n\nr? ``@fmease``", "tree": {"sha": "2f92ada596e712dda0340f60c0977532a988b9cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f92ada596e712dda0340f60c0977532a988b9cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35bd52e888489c605e5f5ce35fea17a1743adf91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOOuRCRBK7hj4Ov3rIwAAxCQIACNg2Ag51uMtIVKqV2K64XjJ\nDkwb1FCqX2f4UAD7Pax64CgxpLfnkTxcAKdxXqW6YYg4U6Ijkf3M6Wj5QpEUSLfy\nLWUzmS0A1QoPZlNbfozsV5SV41zPhF4/fxFG0q1fy7bjgMCVLmEZxDZekV6va/2P\nVxvRO05fqjBrTmwhwGZFVOftRIq4BPc8aKlqRJfqricYhAK+X+yYe5vZi0knuK+b\nbPaMdJ0uDRWvRnx/2UlltMLFFlkRJ9wc/ZLFMXg9XQ2hL2ZQ/V0U7Kulggu2PwKf\nl5JmnFZVhbndcMk0R4EktNKIothmwlkHKBdin3Frh1crrSUszifAGDIUFXeCDYs=\n=Jtre\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f92ada596e712dda0340f60c0977532a988b9cc\nparent f3c69552493b74de1644a3ab5dba0a762d6f3305\nparent 80c43232177c1a04ef11bd8103b56b67f69b669c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681451921 +0200\ncommitter GitHub <noreply@github.com> 1681451921 +0200\n\nRollup merge of #110279 - GuillaumeGomez:compiler-macro-derive, r=notriddle\n\nrustdoc: Correctly handle built-in compiler proc-macros as proc-macro and not macro\n\nPart of https://github.com/rust-lang/rust/issues/110111.\n\nThere were actually one issue split in two parts:\n * Compiler built-in proc-macro were incorrectly considered as macros and not proc-macros.\n * Re-exports of compiler built-in proc-macros were considering them as macros.\n\nBoth issues can be fixed by looking at the `MacroKind` variant instead of just relying on information extracted later on.\n\nr? ``@fmease``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35bd52e888489c605e5f5ce35fea17a1743adf91", "html_url": "https://github.com/rust-lang/rust/commit/35bd52e888489c605e5f5ce35fea17a1743adf91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35bd52e888489c605e5f5ce35fea17a1743adf91/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3c69552493b74de1644a3ab5dba0a762d6f3305", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c69552493b74de1644a3ab5dba0a762d6f3305", "html_url": "https://github.com/rust-lang/rust/commit/f3c69552493b74de1644a3ab5dba0a762d6f3305"}, {"sha": "80c43232177c1a04ef11bd8103b56b67f69b669c", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c43232177c1a04ef11bd8103b56b67f69b669c", "html_url": "https://github.com/rust-lang/rust/commit/80c43232177c1a04ef11bd8103b56b67f69b669c"}], "stats": {"total": 122, "additions": 78, "deletions": 44}, "files": [{"sha": "cc5d13808b2f5437905a90012fbeaaf95cf337c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/35bd52e888489c605e5f5ce35fea17a1743adf91/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bd52e888489c605e5f5ce35fea17a1743adf91/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=35bd52e888489c605e5f5ce35fea17a1743adf91", "patch": "@@ -111,7 +111,7 @@ pub(crate) fn try_inline(\n             clean::ConstantItem(build_const(cx, did))\n         }\n         Res::Def(DefKind::Macro(kind), did) => {\n-            let mac = build_macro(cx, did, name, import_def_id);\n+            let mac = build_macro(cx, did, name, import_def_id, kind);\n \n             let type_kind = match kind {\n                 MacroKind::Bang => ItemType::Macro,\n@@ -651,18 +651,24 @@ fn build_macro(\n     def_id: DefId,\n     name: Symbol,\n     import_def_id: Option<DefId>,\n+    macro_kind: MacroKind,\n ) -> clean::ItemKind {\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n-        LoadedMacro::MacroDef(item_def, _) => {\n-            if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n-                clean::MacroItem(clean::Macro {\n-                    source: utils::display_macro_source(cx, name, def, def_id, vis),\n-                })\n-            } else {\n-                unreachable!()\n+        LoadedMacro::MacroDef(item_def, _) => match macro_kind {\n+            MacroKind::Bang => {\n+                if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n+                    let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n+                    clean::MacroItem(clean::Macro {\n+                        source: utils::display_macro_source(cx, name, def, def_id, vis),\n+                    })\n+                } else {\n+                    unreachable!()\n+                }\n             }\n-        }\n+            MacroKind::Derive | MacroKind::Attr => {\n+                clean::ProcMacroItem(clean::ProcMacro { kind: macro_kind, helpers: Vec::new() })\n+            }\n+        },\n         LoadedMacro::ProcMacro(ext) => clean::ProcMacroItem(clean::ProcMacro {\n             kind: ext.macro_kind(),\n             helpers: ext.helper_attrs,"}, {"sha": "6ceba1b1f8e2224f10086c696d191e08d806a0f0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35bd52e888489c605e5f5ce35fea17a1743adf91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bd52e888489c605e5f5ce35fea17a1743adf91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35bd52e888489c605e5f5ce35fea17a1743adf91", "patch": "@@ -909,6 +909,38 @@ fn clean_ty_generics<'tcx>(\n     }\n }\n \n+fn clean_proc_macro<'tcx>(\n+    item: &hir::Item<'tcx>,\n+    name: &mut Symbol,\n+    kind: MacroKind,\n+    cx: &mut DocContext<'tcx>,\n+) -> ItemKind {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    if kind == MacroKind::Derive &&\n+        let Some(derive_name) = attrs\n+            .lists(sym::proc_macro_derive)\n+            .find_map(|mi| mi.ident())\n+    {\n+        *name = derive_name.name;\n+    }\n+\n+    let mut helpers = Vec::new();\n+    for mi in attrs.lists(sym::proc_macro_derive) {\n+        if !mi.has_name(sym::attributes) {\n+            continue;\n+        }\n+\n+        if let Some(list) = mi.meta_item_list() {\n+            for inner_mi in list {\n+                if let Some(ident) = inner_mi.ident() {\n+                    helpers.push(ident.name);\n+                }\n+            }\n+        }\n+    }\n+    ProcMacroItem(ProcMacro { kind, helpers })\n+}\n+\n fn clean_fn_or_proc_macro<'tcx>(\n     item: &hir::Item<'tcx>,\n     sig: &hir::FnSig<'tcx>,\n@@ -930,31 +962,7 @@ fn clean_fn_or_proc_macro<'tcx>(\n         }\n     });\n     match macro_kind {\n-        Some(kind) => {\n-            if kind == MacroKind::Derive {\n-                *name = attrs\n-                    .lists(sym::proc_macro_derive)\n-                    .find_map(|mi| mi.ident())\n-                    .expect(\"proc-macro derives require a name\")\n-                    .name;\n-            }\n-\n-            let mut helpers = Vec::new();\n-            for mi in attrs.lists(sym::proc_macro_derive) {\n-                if !mi.has_name(sym::attributes) {\n-                    continue;\n-                }\n-\n-                if let Some(list) = mi.meta_item_list() {\n-                    for inner_mi in list {\n-                        if let Some(ident) = inner_mi.ident() {\n-                            helpers.push(ident.name);\n-                        }\n-                    }\n-                }\n-            }\n-            ProcMacroItem(ProcMacro { kind, helpers })\n-        }\n+        Some(kind) => clean_proc_macro(item, name, kind, cx),\n         None => {\n             let mut func = clean_function(cx, sig, generics, FunctionArgs::Body(body_id));\n             clean_fn_decl_legacy_const_generics(&mut func, attrs);\n@@ -2247,16 +2255,17 @@ fn clean_maybe_renamed_item<'tcx>(\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),\n-            // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, generics, body_id) => {\n-                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-            }\n-            ItemKind::Macro(ref macro_def, _) => {\n+            ItemKind::Macro(ref macro_def, MacroKind::Bang) => {\n                 let ty_vis = cx.tcx.visibility(def_id);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n             }\n+            ItemKind::Macro(_, macro_kind) => clean_proc_macro(item, &mut name, macro_kind, cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n             ItemKind::Trait(_, _, generics, bounds, item_ids) => {\n                 let items = item_ids\n                     .iter()"}, {"sha": "489ec924c1fcf15e10c6ed7648ee686680e7edee", "filename": "tests/rustdoc/compiler-derive-proc-macro.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35bd52e888489c605e5f5ce35fea17a1743adf91/tests%2Frustdoc%2Fcompiler-derive-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bd52e888489c605e5f5ce35fea17a1743adf91/tests%2Frustdoc%2Fcompiler-derive-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fcompiler-derive-proc-macro.rs?ref=35bd52e888489c605e5f5ce35fea17a1743adf91", "patch": "@@ -0,0 +1,15 @@\n+// This test ensures that compiler builtin proc-macros are considered as such.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// Each compiler builtin proc-macro has a trait equivalent so we should have\n+// a trait section as well.\n+// @count - '//*[@id=\"main-content\"]//*[@class=\"small-section-header\"]' 2\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"small-section-header\"]' 'Traits'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"small-section-header\"]' 'Derive Macros'\n+\n+// Now checking the correct file is generated as well.\n+// @has 'foo/derive.Clone.html'\n+// @!has 'foo/macro.Clone.html'\n+pub use std::clone::Clone;"}, {"sha": "42f760cff6a7ca574bac16673ddf5b4d65131ef2", "filename": "tests/rustdoc/macro_pub_in_module.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35bd52e888489c605e5f5ce35fea17a1743adf91/tests%2Frustdoc%2Fmacro_pub_in_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bd52e888489c605e5f5ce35fea17a1743adf91/tests%2Frustdoc%2Fmacro_pub_in_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fmacro_pub_in_module.rs?ref=35bd52e888489c605e5f5ce35fea17a1743adf91", "patch": "@@ -7,22 +7,26 @@\n #![crate_name = \"krate\"]\n #![no_core]\n \n- // @has external_crate/some_module/macro.external_macro.html\n-  // @!has external_crate/macro.external_macro.html\n+// @has external_crate/some_module/macro.external_macro.html\n+// @!has external_crate/macro.external_macro.html\n extern crate external_crate;\n \n pub mod inner {\n     // @has krate/inner/macro.raw_const.html\n     // @!has krate/macro.raw_const.html\n     pub macro raw_const() {}\n \n-    // @has krate/inner/macro.test.html\n+    // @has krate/inner/attr.test.html\n     // @!has krate/macro.test.html\n+    // @!has krate/inner/macro.test.html\n+    // @!has krate/attr.test.html\n     #[rustc_builtin_macro]\n     pub macro test($item:item) {}\n \n-    // @has krate/inner/macro.Clone.html\n+    // @has krate/inner/derive.Clone.html\n+    // @!has krate/inner/macro.Clone.html\n     // @!has krate/macro.Clone.html\n+    // @!has krate/derive.Clone.html\n     #[rustc_builtin_macro]\n     pub macro Clone($item:item) {}\n "}]}