{"sha": "0319b31f74d901bf578d96515dbe8c98a2b00497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTliMzFmNzRkOTAxYmY1NzhkOTY1MTVkYmU4Yzk4YTJiMDA0OTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-14T14:36:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-14T14:36:42Z"}, "message": "Merge pull request #1159 from bjorn3/driver_refactorings\n\nDriver refactorings", "tree": {"sha": "5942178415987b5f3b789c3b970f1c17825f0d53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5942178415987b5f3b789c3b970f1c17825f0d53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0319b31f74d901bf578d96515dbe8c98a2b00497", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgdv36CRBK7hj4Ov3rIwAAdHIIAFNmPdmYOCD1HA/khLJkZm21\nCjIpaaOIjaoAi2TUejmEoE55RRUWckbiHaCyFj60lNHO0EbIpMekSJmRylq06jmO\nbtbg3Rzj1Ee9SQTnGOaKHhI1IYlKYLUjZI3AAdNLaFZ9b9j+J7JwhqLFvD5WWNtM\nceEnFvn9sNc6zfa2UhIo65NlaUGS+v5cjLckj1C2aDCVXzv45Tx/N5NoXIcIzYDV\nvXUXlYaJklgc74Rybtk7RuvJLwODrZVHhEDxW+XnsJj5xOKaI+F0rH/L07gxDyuN\ngQGlQNDE2LUFsq50rHCR2j8UkbdPZmIpGEv4rCLhNxE4V2QvanM9jGA3m/zLVwc=\n=xrbN\n-----END PGP SIGNATURE-----\n", "payload": "tree 5942178415987b5f3b789c3b970f1c17825f0d53\nparent 542e73e8ac1696e09fd5be277a0dc2aa137b7c4e\nparent 69102dbcf732a82c4e87252bd7887f7d8065134c\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1618411002 +0200\ncommitter GitHub <noreply@github.com> 1618411002 +0200\n\nMerge pull request #1159 from bjorn3/driver_refactorings\n\nDriver refactorings"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0319b31f74d901bf578d96515dbe8c98a2b00497", "html_url": "https://github.com/rust-lang/rust/commit/0319b31f74d901bf578d96515dbe8c98a2b00497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0319b31f74d901bf578d96515dbe8c98a2b00497/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "542e73e8ac1696e09fd5be277a0dc2aa137b7c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/542e73e8ac1696e09fd5be277a0dc2aa137b7c4e", "html_url": "https://github.com/rust-lang/rust/commit/542e73e8ac1696e09fd5be277a0dc2aa137b7c4e"}, {"sha": "69102dbcf732a82c4e87252bd7887f7d8065134c", "url": "https://api.github.com/repos/rust-lang/rust/commits/69102dbcf732a82c4e87252bd7887f7d8065134c", "html_url": "https://github.com/rust-lang/rust/commit/69102dbcf732a82c4e87252bd7887f7d8065134c"}], "stats": {"total": 544, "additions": 255, "deletions": 289}, "files": [{"sha": "9009a532c54dcc91ac5ea9943a48ba63f0803bc9", "filename": ".vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Fsettings.json?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -1,6 +1,6 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.runBuildScripts\": true,\n     \"rust-analyzer.linkedProjects\": ["}, {"sha": "f450f366787136ff1896ebc78bef58a66596299f", "filename": "src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -71,8 +71,8 @@ pub(crate) fn import_function<'tcx>(\n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, self.cx.module, inst);\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.module, inst);\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         if self.clif_comments.enabled() {\n             self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -89,8 +89,8 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n-        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));"}, {"sha": "a09e32577869e7452c6ad1bb007e5c80c5629630", "filename": "src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::sym;\n pub(crate) fn codegen(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n ) -> bool {\n     let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n         use rustc_middle::middle::dependency_format::Linkage;\n@@ -29,7 +29,7 @@ pub(crate) fn codegen(\n \n fn codegen_inner(\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n ) {\n     let usize_ty = module.target_config().pointer_type();"}, {"sha": "069166f7b68a015dbe8263c22cf75a1be139e2e6", "filename": "src/base.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -9,7 +9,11 @@ use rustc_target::abi::call::FnAbi;\n use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n-pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n+pub(crate) fn codegen_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) {\n     let tcx = cx.tcx;\n \n     let _inst_guard =\n@@ -20,8 +24,8 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n \n     // Declare function\n     let symbol_name = tcx.symbol_name(instance);\n-    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n+    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -40,11 +44,12 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n         (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         cx,\n+        module,\n         tcx,\n         pointer_type,\n         vtables: FxHashMap::default(),\n@@ -94,7 +99,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n \n-    fx.constants_cx.finalize(fx.tcx, &mut *fx.cx.module);\n+    fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n     // Store function in context\n     let context = &mut cx.cached_context;\n@@ -114,16 +119,15 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     // instruction, which doesn't have an encoding.\n     context.compute_cfg();\n     context.compute_domtree();\n-    context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n-    context.dce(cx.module.isa()).unwrap();\n+    context.eliminate_unreachable_code(module.isa()).unwrap();\n+    context.dce(module.isa()).unwrap();\n     // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n     // Define function\n-    let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n             .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n@@ -134,7 +138,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"opt\",\n-        Some(cx.module.isa()),\n+        Some(module.isa()),\n         instance,\n         &context,\n         &clif_comments,\n@@ -149,7 +153,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     }\n \n     // Define debuginfo for function\n-    let isa = cx.module.isa();\n+    let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n@@ -654,7 +658,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -834,7 +838,7 @@ fn codegen_stmt<'tcx>(\n             let elem_size: u64 = pointee.size.bytes();\n             let bytes =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n-            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+            fx.bcx.call_memcpy(fx.module.target_config(), dst, src, bytes);\n         }\n     }\n }"}, {"sha": "92e4435565ee7575d0e77e8756f1f8040b7de0ce", "filename": "src/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -228,8 +228,9 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n     pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n@@ -341,7 +342,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.cx.module.isa().triple()\n+        self.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -354,15 +355,14 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .cx\n             .module\n             .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n+        let _ = self.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n+        let local_msg_id = self.module.declare_data_in_func(msg_id, self.bcx.func);\n         if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }"}, {"sha": "e59a0cb0a23237bfe0b4fd0164909db4d8a98e49", "filename": "src/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -5,10 +5,14 @@ fn bool_env_var(key: &str) -> bool {\n     env::var(key).as_ref().map(|val| &**val) == Ok(\"1\")\n }\n \n+/// The mode to use for compilation.\n #[derive(Copy, Clone, Debug)]\n pub enum CodegenMode {\n+    /// AOT compile the crate. This is the default.\n     Aot,\n+    /// JIT compile and execute the crate.\n     Jit,\n+    /// JIT compile and execute the crate, but only compile functions the first time they are used.\n     JitLazy,\n }\n \n@@ -25,6 +29,7 @@ impl FromStr for CodegenMode {\n     }\n }\n \n+/// Configuration of cg_clif as passed in through `-Cllvm-args` and various env vars.\n #[derive(Clone, Debug)]\n pub struct BackendConfig {\n     /// Should the crate be AOT compiled or JIT executed.\n@@ -76,6 +81,7 @@ impl Default for BackendConfig {\n }\n \n impl BackendConfig {\n+    /// Parse the configuration passed in using `-Cllvm-args`.\n     pub fn from_opts(opts: &[String]) -> Result<Self, String> {\n         fn parse_bool(name: &str, value: &str) -> Result<bool, String> {\n             value.parse().map_err(|_| format!(\"failed to parse value `{}` for {}\", value, name))"}, {"sha": "0a0e02d26394e7fee322ae991fe41e915a9e34b9", "filename": "src/constant.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::ConstKind;\n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n \n-use crate::{prelude::*, CodegenCx};\n+use crate::prelude::*;\n \n pub(crate) struct ConstantCx {\n     todo: Vec<TodoItem>,\n@@ -78,19 +78,19 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     all_constants_ok\n }\n \n-pub(crate) fn codegen_static(cx: &mut CodegenCx<'_, '_>, def_id: DefId) {\n+pub(crate) fn codegen_static(tcx: TyCtxt<'_>, module: &mut dyn Module, def_id: DefId) {\n     let mut constants_cx = ConstantCx::new();\n     constants_cx.todo.push(TodoItem::Static(def_id));\n-    constants_cx.finalize(cx.tcx, &mut *cx.module);\n+    constants_cx.finalize(tcx, module);\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n     }\n@@ -103,8 +103,8 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     }\n@@ -191,29 +191,28 @@ pub(crate) fn codegen_const_value<'tcx>(\n                             fx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n                             let data_id = data_id_for_alloc_id(\n                                 &mut fx.constants_cx,\n-                                fx.cx.module,\n+                                fx.module,\n                                 ptr.alloc_id,\n                                 alloc.mutability,\n                             );\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id =\n-                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n+                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                             let local_func_id =\n-                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                                fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             }\n@@ -255,9 +254,9 @@ fn pointer_for_allocation<'tcx>(\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n     let data_id =\n-        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.cx.module, alloc_id, alloc.mutability);\n+        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, alloc.mutability);\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n     }"}, {"sha": "ca7083cccb88f22d9a146281ad44576db1e110f4", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -5,17 +5,19 @@ use crate::prelude::*;\n use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n \n use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n+use gimli::RunTimeEndian;\n \n use crate::backend::WriteDebugInfo;\n \n-pub(crate) struct UnwindContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) struct UnwindContext {\n+    endian: RunTimeEndian,\n     frame_table: FrameTable,\n     cie_id: Option<CieId>,\n }\n \n-impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+impl UnwindContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+        let endian = super::target_endian(tcx);\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n@@ -28,7 +30,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext { tcx, frame_table, cie_id }\n+        UnwindContext { endian, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -54,8 +56,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -71,33 +72,32 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     #[cfg(feature = \"jit\")]\n-    pub(crate) unsafe fn register_jit(\n-        self,\n-        jit_module: &cranelift_jit::JITModule,\n-    ) -> Option<UnwindRegistry> {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+    pub(crate) unsafe fn register_jit(self, jit_module: &cranelift_jit::JITModule) {\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n-            return None;\n+            return;\n         }\n \n         let mut eh_frame = eh_frame.0.relocate_for_jit(jit_module);\n \n         // GCC expects a terminating \"empty\" length, so write a 0 length at the end of the table.\n         eh_frame.extend(&[0, 0, 0, 0]);\n \n-        let mut registrations = Vec::new();\n+        // FIXME support unregistering unwind tables once cranelift-jit supports deallocating\n+        // individual functions\n+        #[allow(unused_variables)]\n+        let (eh_frame, eh_frame_len, _) = Vec::into_raw_parts(eh_frame);\n \n         // =======================================================================\n         // Everything after this line up to the end of the file is loosly based on\n         // https://github.com/bytecodealliance/wasmtime/blob/4471a82b0c540ff48960eca6757ccce5b1b5c3e4/crates/jit/src/unwind/systemv.rs\n         #[cfg(target_os = \"macos\")]\n         {\n             // On macOS, `__register_frame` takes a pointer to a single FDE\n-            let start = eh_frame.as_ptr();\n-            let end = start.add(eh_frame.len());\n+            let start = eh_frame;\n+            let end = start.add(eh_frame_len);\n             let mut current = start;\n \n             // Walk all of the entries in the frame table and register them\n@@ -107,7 +107,6 @@ impl<'tcx> UnwindContext<'tcx> {\n                 // Skip over the CIE\n                 if current != start {\n                     __register_frame(current);\n-                    registrations.push(current as usize);\n                 }\n \n                 // Move to the next table entry (+4 because the length itself is not inclusive)\n@@ -117,41 +116,12 @@ impl<'tcx> UnwindContext<'tcx> {\n         #[cfg(not(target_os = \"macos\"))]\n         {\n             // On other platforms, `__register_frame` will walk the FDEs until an entry of length 0\n-            let ptr = eh_frame.as_ptr();\n-            __register_frame(ptr);\n-            registrations.push(ptr as usize);\n+            __register_frame(eh_frame);\n         }\n-\n-        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n \n-/// Represents a registry of function unwind information for System V ABI.\n-pub(crate) struct UnwindRegistry {\n-    _frame_table: Vec<u8>,\n-    registrations: Vec<usize>,\n-}\n-\n extern \"C\" {\n     // libunwind import\n     fn __register_frame(fde: *const u8);\n-    fn __deregister_frame(fde: *const u8);\n-}\n-\n-impl Drop for UnwindRegistry {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // libgcc stores the frame entries as a linked list in decreasing sort order\n-            // based on the PC value of the registered entry.\n-            //\n-            // As we store the registrations in increasing order, it would be O(N^2) to\n-            // deregister in that order.\n-            //\n-            // To ensure that we just pop off the first element in the list upon every\n-            // deregistration, walk our list of registrations backwards.\n-            for fde in self.registrations.iter().rev() {\n-                __deregister_frame(*fde as *const _);\n-            }\n-        }\n-    }\n }"}, {"sha": "3ff96d710e58e2a461c07fe710b0633b25a631b4", "filename": "src/driver/aot.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -31,7 +31,7 @@ fn emit_module(\n     kind: ModuleKind,\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n-    unwind_context: UnwindContext<'_>,\n+    unwind_context: UnwindContext,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -107,21 +107,22 @@ fn module_codegen(\n \n     let isa = crate::build_isa(tcx.sess, &backend_config);\n     let mut module = crate::backend::make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n-    assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n         backend_config.clone(),\n-        &mut module,\n+        module.isa(),\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n-    super::predefine_mono_items(&mut cx, &mono_items);\n+    super::predefine_mono_items(tcx, &mut module, &mono_items);\n     for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n+                cx.tcx\n+                    .sess\n+                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n             }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(&mut cx, def_id),\n+            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n@@ -133,26 +134,24 @@ fn module_codegen(\n             }\n         }\n     }\n-    let (global_asm, debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut cx.unwind_context, false);\n \n     let codegen_result = emit_module(\n         tcx,\n         &backend_config,\n         cgu.name().as_str().to_string(),\n         ModuleKind::Regular,\n         module,\n-        debug,\n-        unwind_context,\n+        cx.debug_context,\n+        cx.unwind_context,\n     );\n \n-    codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n+    codegen_global_asm(tcx, &cgu.name().as_str(), &cx.global_asm);\n \n     codegen_result\n }\n \n-pub(super) fn run_aot(\n+pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,"}, {"sha": "63ac02f83b92c4c137f5b7e8a3c2f4529369a642", "filename": "src/driver/jit.rs", "status": "modified", "additions": 93, "deletions": 102, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -1,4 +1,4 @@\n-//! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n+//! The JIT driver uses [`cranelift_jit`] to JIT execute programs without writing any object\n //! files.\n \n use std::cell::RefCell;\n@@ -8,32 +8,62 @@ use std::os::raw::{c_char, c_int};\n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n-use rustc_session::config::EntryFnType;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n-thread_local! {\n-    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n-    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+struct JitState {\n+    backend_config: BackendConfig,\n+    jit_module: JITModule,\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n-    if !tcx.sess.opts.output_types.should_codegen() {\n-        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n-    }\n+thread_local! {\n+    static LAZY_JIT_STATE: RefCell<Option<JitState>> = RefCell::new(None);\n+}\n \n+fn create_jit_module<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    backend_config: &BackendConfig,\n+    hotswap: bool,\n+) -> (JITModule, CodegenCx<'tcx>) {\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n+    let isa = crate::build_isa(tcx.sess, backend_config);\n     let mut jit_builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());\n-    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n+    jit_builder.hotswap(hotswap);\n     crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n-    assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n+\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), jit_module.isa(), false);\n+\n+    crate::allocator::codegen(tcx, &mut jit_module, &mut cx.unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(\n+        tcx,\n+        &mut jit_module,\n+        &mut cx.unwind_context,\n+        true,\n+    );\n+\n+    (jit_module, cx)\n+}\n+\n+pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n+        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`\");\n+    }\n+\n+    if !tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable) {\n+        tcx.sess.fatal(\"can't jit non-executable crate\");\n+    }\n+\n+    let (mut jit_module, mut cx) = create_jit_module(\n+        tcx,\n+        &backend_config,\n+        matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n+    );\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n@@ -44,44 +74,38 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), &mut jit_module, false);\n-\n     super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n-        super::predefine_mono_items(&mut cx, &mono_items);\n+        super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n         for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n                 },\n                 MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(&mut cx, def_id);\n+                    crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n                 }\n                 MonoItem::GlobalAsm(item_id) => {\n-                    let item = cx.tcx.hir().item(item_id);\n+                    let item = tcx.hir().item(item_id);\n                     tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n     });\n \n-    let (global_asm, _debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    jit_module.finalize_definitions();\n-\n-    if !global_asm.is_empty() {\n+    if !cx.global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n-\n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-    let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n+    unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n         \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n@@ -97,61 +121,27 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n-    BACKEND_CONFIG.with(|tls_backend_config| {\n-        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    let start_sig = Signature {\n+        params: vec![\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+        ],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n+        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+    };\n+    let start_func_id = jit_module.declare_function(\"main\", Linkage::Import, &start_sig).unwrap();\n+    let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n+\n+    LAZY_JIT_STATE.with(|lazy_jit_state| {\n+        let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+        assert!(lazy_jit_state.is_none());\n+        *lazy_jit_state = Some(JitState { backend_config, jit_module });\n     });\n \n-    let (main_def_id, entry_ty) = tcx.entry_fn(LOCAL_CRATE).unwrap();\n-    let instance = Instance::mono(tcx, main_def_id.to_def_id()).polymorphize(tcx);\n-\n-    match entry_ty {\n-        EntryFnType::Main => {\n-            // FIXME set program arguments somehow\n-\n-            let main_sig = Signature {\n-                params: vec![],\n-                returns: vec![],\n-                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-            };\n-            let main_func_id = jit_module\n-                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &main_sig)\n-                .unwrap();\n-            let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n-\n-            CURRENT_MODULE.with(|current_module| {\n-                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n-            });\n-\n-            let f: extern \"C\" fn() = unsafe { ::std::mem::transmute(finalized_main) };\n-            f();\n-            std::process::exit(0);\n-        }\n-        EntryFnType::Start => {\n-            let start_sig = Signature {\n-                params: vec![\n-                    AbiParam::new(jit_module.target_config().pointer_type()),\n-                    AbiParam::new(jit_module.target_config().pointer_type()),\n-                ],\n-                returns: vec![AbiParam::new(\n-                    jit_module.target_config().pointer_type(), /*isize*/\n-                )],\n-                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-            };\n-            let start_func_id = jit_module\n-                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &start_sig)\n-                .unwrap();\n-            let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n-\n-            CURRENT_MODULE.with(|current_module| {\n-                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n-            });\n-\n-            let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n-                unsafe { ::std::mem::transmute(finalized_start) };\n-            let ret = f(args.len() as c_int, argv.as_ptr());\n-            std::process::exit(ret);\n-        }\n-    }\n+    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+        unsafe { ::std::mem::transmute(finalized_start) };\n+    let ret = f(args.len() as c_int, argv.as_ptr());\n+    std::process::exit(ret);\n }\n \n #[no_mangle]\n@@ -160,24 +150,23 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         // lift is used to ensure the correct lifetime for instance.\n         let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n \n-        CURRENT_MODULE.with(|jit_module| {\n-            let mut jit_module = jit_module.borrow_mut();\n-            let jit_module = jit_module.as_mut().unwrap();\n-            let backend_config =\n-                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n+        LAZY_JIT_STATE.with(|lazy_jit_state| {\n+            let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+            let lazy_jit_state = lazy_jit_state.as_mut().unwrap();\n+            let jit_module = &mut lazy_jit_state.jit_module;\n+            let backend_config = lazy_jit_state.backend_config.clone();\n \n             let name = tcx.symbol_name(instance).name.to_string();\n             let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n             let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance));\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n \n-            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n-            assert!(global_asm.is_empty());\n+            assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n-            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            unsafe { cx.unwind_context.register_jit(&jit_module) };\n             jit_module.get_finalized_function(func_id)\n         })\n     })\n@@ -247,35 +236,37 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name.to_string();\n-    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let func_id = module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n-    let jit_fn = cx\n-        .module\n+    let jit_fn = module\n         .declare_function(\n             \"__clif_jit_fn\",\n             Linkage::Import,\n             &Signature {\n-                call_conv: cx.module.target_config().default_call_conv,\n+                call_conv: module.target_config().default_call_conv,\n                 params: vec![AbiParam::new(pointer_type)],\n                 returns: vec![AbiParam::new(pointer_type)],\n             },\n         )\n         .unwrap();\n \n-    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    cx.cached_context.clear();\n+    let trampoline = &mut cx.cached_context.func;\n+    trampoline.signature = sig.clone();\n+\n     let mut builder_ctx = FunctionBuilderContext::new();\n-    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+    let mut trampoline_builder = FunctionBuilder::new(trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n@@ -290,10 +281,10 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    cx.module\n+    module\n         .define_function(\n             func_id,\n-            &mut Context::for_function(trampoline),\n+            &mut cx.cached_context,\n             &mut NullTrapSink {},\n             &mut NullStackMapSink {},\n         )"}, {"sha": "393cde3e9ad27b66944aa468843b68907ec1cba8", "filename": "src/driver/mod.rs", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -1,63 +1,37 @@\n-//! Drivers are responsible for calling [`codegen_mono_item`] and performing any further actions\n-//! like JIT executing or writing object files.\n+//! Drivers are responsible for calling [`codegen_fn`] or [`codegen_static`] for each mono item and\n+//! performing any further actions like JIT executing or writing object files.\n+//!\n+//! [`codegen_fn`]: crate::base::codegen_fn\n+//! [`codegen_static`]: crate::constant::codegen_static\n \n-use std::any::Any;\n-\n-use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n-use crate::CodegenMode;\n \n-mod aot;\n+pub(crate) mod aot;\n #[cfg(feature = \"jit\")]\n-mod jit;\n-\n-pub(crate) fn codegen_crate(\n-    tcx: TyCtxt<'_>,\n-    metadata: EncodedMetadata,\n-    need_metadata_module: bool,\n-    backend_config: crate::BackendConfig,\n-) -> Box<dyn Any> {\n-    tcx.sess.abort_if_errors();\n-\n-    match backend_config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n-        CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable =\n-                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n-            if !is_executable {\n-                tcx.sess.fatal(\"can't jit non-executable crate\");\n-            }\n-\n-            #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, backend_config);\n-\n-            #[cfg(not(feature = \"jit\"))]\n-            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n-        }\n-    }\n-}\n+pub(crate) mod jit;\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    cx.tcx.sess.time(\"predefine functions\", || {\n-        let is_compiler_builtins = cx.tcx.is_compiler_builtins(LOCAL_CRATE);\n+    tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let name = tcx.symbol_name(instance).name.to_string();\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n+                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(\n                         mono_item,\n                         linkage,\n                         visibility,\n                         is_compiler_builtins,\n                     );\n-                    cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                    module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n             }"}, {"sha": "669a6d35075b4fed74ac79cafb35a9108e6ee47f", "filename": "src/inline_asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -201,7 +201,6 @@ fn call_inline_asm<'tcx>(\n     }\n \n     let inline_asm_func = fx\n-        .cx\n         .module\n         .declare_function(\n             asm_name,\n@@ -213,7 +212,7 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(inline_asm_func, asm_name);\n     }"}, {"sha": "d08271f853b50eb62d63e2ab4de882ce53d7ec25", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -498,10 +498,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -517,10 +517,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         size_of_val, <T> (c ptr) {\n@@ -670,7 +670,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg."}, {"sha": "5a75b9be0cb690d96e6b5866a81cf938f82f9be5", "filename": "src/lib.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private, decl_macro, never_type, hash_drain_filter)]\n+#![feature(rustc_private, decl_macro, never_type, hash_drain_filter, vec_into_raw_parts)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n@@ -33,6 +33,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::settings::{self, Configurable};\n \n pub use crate::config::*;\n@@ -118,42 +119,36 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'m, 'tcx: 'm> {\n+/// The codegen context holds any information shared between the codegen of individual functions\n+/// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n+struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    module: &'m mut dyn Module,\n     global_asm: String,\n     cached_context: Context,\n     debug_context: Option<DebugContext<'tcx>>,\n-    unwind_context: UnwindContext<'tcx>,\n+    unwind_context: UnwindContext,\n }\n \n-impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+impl<'tcx> CodegenCx<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         backend_config: BackendConfig,\n-        module: &'m mut dyn Module,\n+        isa: &dyn TargetIsa,\n         debug_info: bool,\n     ) -> Self {\n-        let unwind_context = UnwindContext::new(\n-            tcx,\n-            module.isa(),\n-            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n-        );\n-        let debug_context =\n-            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n+        assert_eq!(pointer_ty(tcx), isa.pointer_type());\n+\n+        let unwind_context =\n+            UnwindContext::new(tcx, isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n+        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n         CodegenCx {\n             tcx,\n-            module,\n             global_asm: String::new(),\n             cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n         }\n     }\n-\n-    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        (self.global_asm, self.debug_context, self.unwind_context)\n-    }\n }\n \n pub struct CraneliftCodegenBackend {\n@@ -186,13 +181,23 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n+        tcx.sess.abort_if_errors();\n         let config = if let Some(config) = self.config.clone() {\n             config\n         } else {\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n-        driver::codegen_crate(tcx, metadata, need_metadata_module, config)\n+        match config.codegen_mode {\n+            CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n+            CodegenMode::Jit | CodegenMode::JitLazy => {\n+                #[cfg(feature = \"jit\")]\n+                let _: ! = driver::jit::run_jit(tcx, config);\n+\n+                #[cfg(not(feature = \"jit\"))]\n+                tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            }\n+        }\n     }\n \n     fn join_codegen("}, {"sha": "4beb6c65a7791e15f7e89c6fb18cb44a5e65ec9b", "filename": "src/main_shim.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -9,9 +9,10 @@ use crate::prelude::*;\n pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n+    is_jit: bool,\n ) {\n-    let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n+    let (main_def_id, is_main_fn) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n             def_id.to_def_id(),\n             match entry_ty {\n@@ -23,18 +24,19 @@ pub(crate) fn maybe_create_entry_wrapper(\n     };\n \n     let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-    if module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+    if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n-        unwind_context: &mut UnwindContext<'_>,\n+        unwind_context: &mut UnwindContext,\n         rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n+        ignore_lang_start_wrapper: bool,\n+        is_main_fn: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -74,7 +76,12 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n-            let call_inst = if use_start_lang_item {\n+            let result = if is_main_fn && ignore_lang_start_wrapper {\n+                // regular main fn, but ignoring #[lang = \"start\"] as we are running in the jit\n+                // FIXME set program arguments somehow\n+                bcx.ins().call(main_func_ref, &[]);\n+                bcx.ins().iconst(m.target_config().pointer_type(), 0)\n+            } else if is_main_fn {\n                 let start_def_id = tcx.require_lang_item(LangItem::Start, None);\n                 let start_instance = Instance::resolve(\n                     tcx,\n@@ -90,13 +97,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             } else {\n                 // using user-defined start fn\n-                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(main_func_ref, &[arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             };\n \n-            let result = bcx.inst_results(call_inst)[0];\n             bcx.ins().return_(&[result]);\n             bcx.seal_all_blocks();\n             bcx.finalize();"}, {"sha": "978a1e722ddd29e385880f0a2617b13392144e5c", "filename": "src/metadata.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -14,6 +14,18 @@ use rustc_target::spec::Target;\n \n use crate::backend::WriteMetadata;\n \n+/// The metadata loader used by cg_clif.\n+///\n+/// The metadata is stored in the same format as cg_llvm.\n+///\n+/// # Metadata location\n+///\n+/// <dl>\n+/// <dt>rlib</dt>\n+/// <dd>The metadata can be found in the `lib.rmeta` file inside of the ar archive.</dd>\n+/// <dt>dylib</dt>\n+/// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n+/// </dl>\n pub(crate) struct CraneliftMetadataLoader;\n \n fn load_metadata_with("}, {"sha": "819c8b51558a051321ef9f1670c2771f6937b301", "filename": "src/trap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -4,7 +4,6 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n-        .cx\n         .module\n         .declare_function(\n             \"puts\",\n@@ -16,7 +15,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             },\n         )\n         .unwrap();\n-    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }"}, {"sha": "9a572c3501f925b7adc726c64e30755e9ade2fef", "filename": "src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.cx.module.target_config(),\n+                    fx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,"}, {"sha": "29e960bb84db7b260fa841c4475c7314189951c6", "filename": "src/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0319b31f74d901bf578d96515dbe8c98a2b00497/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=0319b31f74d901bf578d96515dbe8c98a2b00497", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn get_vtable<'tcx>(\n         data_id\n     };\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        fx.cx.module,\n+        fx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                fx.cx.module,\n+                fx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -132,16 +132,16 @@ fn build_vtable<'tcx>(\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n \n-    let data_id = fx.cx.module.declare_anonymous_data(false, false).unwrap();\n+    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    fx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}]}