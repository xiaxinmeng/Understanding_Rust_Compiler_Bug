{"sha": "27f41b7001913e5d3741b8a1c3623483876673fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZjQxYjcwMDE5MTNlNWQzNzQxYjhhMWMzNjIzNDgzODc2NjczZmI=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-11-02T19:09:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-02T19:09:42Z"}, "message": "Rollup merge of #37513 - michaelwoerister:hash-panic-spans, r=nikomatsakis\n\nICH: Hash expression spans if their source location is captured for panics.\n\nSince the location of some expressions is captured in error message constants, it has an influence on machine code and consequently we need to take them into account by the incr. comp. hash. This PR makes this happen for `+, -, *, /, %` and for array indexing -- let me know if I forgot anything.\n\nIn the future we might want to change the codegen strategy for those error messages, so that they are stored in a separate object file with a stable symbol name, so that only this object file has to be regenerated when source locations change. This strategy would also eliminate unnecessary duplications due  to monomorphization, as @arielb1 has pointed out on IRC. I opened https://github.com/rust-lang/rust/issues/37512, so we don't forget about this.\n\nr? @nikomatsakis", "tree": {"sha": "e62fb18d8659c153799c5e091aa1ab150fe24eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e62fb18d8659c153799c5e091aa1ab150fe24eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f41b7001913e5d3741b8a1c3623483876673fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f41b7001913e5d3741b8a1c3623483876673fb", "html_url": "https://github.com/rust-lang/rust/commit/27f41b7001913e5d3741b8a1c3623483876673fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f41b7001913e5d3741b8a1c3623483876673fb/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62e026be5a4d65ebdd79e1e3fcf75085351a363e", "url": "https://api.github.com/repos/rust-lang/rust/commits/62e026be5a4d65ebdd79e1e3fcf75085351a363e", "html_url": "https://github.com/rust-lang/rust/commit/62e026be5a4d65ebdd79e1e3fcf75085351a363e"}, {"sha": "0e391bf22c4810cdb2f0e026037b4b9d1234c679", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e391bf22c4810cdb2f0e026037b4b9d1234c679", "html_url": "https://github.com/rust-lang/rust/commit/0e391bf22c4810cdb2f0e026037b4b9d1234c679"}], "stats": {"total": 562, "additions": 527, "deletions": 35}, "files": [{"sha": "80c41f855ba5c95508e60369a9020879bc650e77", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 103, "deletions": 35, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=27f41b7001913e5d3741b8a1c3623483876673fb", "patch": "@@ -21,6 +21,7 @@ use self::SawTyComponent::*;\n use self::SawTraitOrImplItemComponent::*;\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n+use syntax::attr;\n use syntax::parse::token;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use rustc::hir;\n@@ -53,6 +54,7 @@ pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n     hash_spans: bool,\n     codemap: &'a mut CachingCodemapView<'tcx>,\n+    overflow_checks_enabled: bool,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n@@ -62,12 +64,16 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n                codemap: &'a mut CachingCodemapView<'tcx>,\n                hash_spans: bool)\n                -> Self {\n+        let check_overflow = tcx.sess.opts.debugging_opts.force_overflow_checks\n+            .unwrap_or(tcx.sess.opts.debug_assertions);\n+\n         StrictVersionHashVisitor {\n             st: st,\n             tcx: tcx,\n             def_path_hashes: def_path_hashes,\n             hash_spans: hash_spans,\n             codemap: codemap,\n+            overflow_checks_enabled: check_overflow,\n         }\n     }\n \n@@ -83,7 +89,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n     fn hash_span(&mut self, span: Span) {\n-        debug_assert!(self.hash_spans);\n         debug!(\"hash_span: st={:?}\", self.st);\n \n         // If this is not an empty or invalid span, we want to hash the last\n@@ -241,37 +246,80 @@ enum SawExprComponent<'a> {\n     SawExprRepeat,\n }\n \n-fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+// The boolean returned indicates whether the span of this expression is always\n+// significant, regardless of debuginfo.\n+fn saw_expr<'a>(node: &'a Expr_,\n+                overflow_checks_enabled: bool)\n+                -> (SawExprComponent<'a>, bool) {\n+    let binop_can_panic_at_runtime = |binop| {\n+        match binop {\n+            BiAdd |\n+            BiSub |\n+            BiMul => overflow_checks_enabled,\n+\n+            BiDiv |\n+            BiRem => true,\n+\n+            BiAnd |\n+            BiOr |\n+            BiBitXor |\n+            BiBitAnd |\n+            BiBitOr |\n+            BiShl |\n+            BiShr |\n+            BiEq |\n+            BiLt |\n+            BiLe |\n+            BiNe |\n+            BiGe |\n+            BiGt => false\n+        }\n+    };\n+\n+    let unop_can_panic_at_runtime = |unop| {\n+        match unop {\n+            UnDeref |\n+            UnNot => false,\n+            UnNeg => overflow_checks_enabled,\n+        }\n+    };\n+\n     match *node {\n-        ExprBox(..)              => SawExprBox,\n-        ExprArray(..)            => SawExprArray,\n-        ExprCall(..)             => SawExprCall,\n-        ExprMethodCall(..)       => SawExprMethodCall,\n-        ExprTup(..)              => SawExprTup,\n-        ExprBinary(op, ..)       => SawExprBinary(op.node),\n-        ExprUnary(op, _)         => SawExprUnary(op),\n-        ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-        ExprCast(..)             => SawExprCast,\n-        ExprType(..)             => SawExprType,\n-        ExprIf(..)               => SawExprIf,\n-        ExprWhile(..)            => SawExprWhile,\n-        ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n-        ExprMatch(..)            => SawExprMatch,\n-        ExprClosure(cc, _, _, _) => SawExprClosure(cc),\n-        ExprBlock(..)            => SawExprBlock,\n-        ExprAssign(..)           => SawExprAssign,\n-        ExprAssignOp(op, ..)     => SawExprAssignOp(op.node),\n-        ExprField(_, name)       => SawExprField(name.node.as_str()),\n-        ExprTupField(_, id)      => SawExprTupField(id.node),\n-        ExprIndex(..)            => SawExprIndex,\n-        ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-        ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-        ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n-        ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n-        ExprRet(..)              => SawExprRet,\n-        ExprInlineAsm(ref a,..)  => SawExprInlineAsm(a),\n-        ExprStruct(..)           => SawExprStruct,\n-        ExprRepeat(..)           => SawExprRepeat,\n+        ExprBox(..)              => (SawExprBox, false),\n+        ExprArray(..)            => (SawExprArray, false),\n+        ExprCall(..)             => (SawExprCall, false),\n+        ExprMethodCall(..)       => (SawExprMethodCall, false),\n+        ExprTup(..)              => (SawExprTup, false),\n+        ExprBinary(op, ..)       => {\n+            (SawExprBinary(op.node), binop_can_panic_at_runtime(op.node))\n+        }\n+        ExprUnary(op, _)         => {\n+            (SawExprUnary(op), unop_can_panic_at_runtime(op))\n+        }\n+        ExprLit(ref lit)         => (SawExprLit(lit.node.clone()), false),\n+        ExprCast(..)             => (SawExprCast, false),\n+        ExprType(..)             => (SawExprType, false),\n+        ExprIf(..)               => (SawExprIf, false),\n+        ExprWhile(..)            => (SawExprWhile, false),\n+        ExprLoop(_, id)          => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n+        ExprMatch(..)            => (SawExprMatch, false),\n+        ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n+        ExprBlock(..)            => (SawExprBlock, false),\n+        ExprAssign(..)           => (SawExprAssign, false),\n+        ExprAssignOp(op, ..)     => {\n+            (SawExprAssignOp(op.node), binop_can_panic_at_runtime(op.node))\n+        }\n+        ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n+        ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n+        ExprIndex(..)            => (SawExprIndex, true),\n+        ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n+        ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n+        ExprBreak(id)            => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n+        ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n+        ExprRet(..)              => (SawExprRet, false),\n+        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n+        ExprStruct(..)           => (SawExprStruct, false),\n+        ExprRepeat(..)           => (SawExprRepeat, false),\n     }\n }\n \n@@ -421,10 +469,13 @@ macro_rules! hash_attrs {\n \n macro_rules! hash_span {\n     ($visitor:expr, $span:expr) => ({\n-        if $visitor.hash_spans {\n+        hash_span!($visitor, $span, false)\n+    });\n+    ($visitor:expr, $span:expr, $force:expr) => ({\n+        if $force || $visitor.hash_spans {\n             $visitor.hash_span($span);\n         }\n-    })\n+    });\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n@@ -474,10 +525,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n-        SawExpr(saw_expr(&ex.node)).hash(self.st);\n+        let (saw_expr, force_span) = saw_expr(&ex.node,\n+                                              self.overflow_checks_enabled);\n+        SawExpr(saw_expr).hash(self.st);\n         // No need to explicitly hash the discriminant here, since we are\n         // implicitly hashing the discriminant of SawExprComponent.\n-        hash_span!(self, ex.span);\n+        hash_span!(self, ex.span, force_span);\n         hash_attrs!(self, &ex.attrs);\n         visit::walk_expr(self, ex)\n     }\n@@ -519,6 +572,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n+        self.maybe_enable_overflow_checks(&i.attrs);\n+\n         SawItem(saw_item(&i.node)).hash(self.st);\n         hash_span!(self, i.span);\n         hash_attrs!(self, &i.attrs);\n@@ -545,6 +601,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n+\n+        self.maybe_enable_overflow_checks(&ti.attrs);\n+\n         SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n         hash_span!(self, ti.span);\n         hash_attrs!(self, &ti.attrs);\n@@ -553,6 +612,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n+\n+        self.maybe_enable_overflow_checks(&ii.attrs);\n+\n         SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n         hash_span!(self, ii.span);\n         hash_attrs!(self, &ii.attrs);\n@@ -842,4 +904,10 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         indices.sort_by_key(|index| get_key(&items[*index]));\n         indices\n     }\n+\n+    fn maybe_enable_overflow_checks(&mut self, item_attrs: &[ast::Attribute]) {\n+        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n+            self.overflow_checks_enabled = true;\n+        }\n+    }\n }"}, {"sha": "f5f4c0042b4328cd1363b03be64e46208ebee180", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=27f41b7001913e5d3741b8a1c3623483876673fb", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for exprs that can panic at runtime (e.g. because of bounds checking). For\n+// these expressions an error message containing their source location is\n+// generated, so their hash must always depend on their location in the source\n+// code, not just when debuginfo is enabled.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -C debug-assertions\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Indexing expression ---------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+\n+\n+// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n+\n+// bitwise ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+\n+// logical ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}"}, {"sha": "b84b7f5f378aad93d89386c88b1293c15ada10b2", "filename": "src/test/incremental/hashes/panic_exprs_no_overflow_checks.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f41b7001913e5d3741b8a1c3623483876673fb/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs?ref=27f41b7001913e5d3741b8a1c3623483876673fb", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for exprs that can panic at runtime (e.g. because of bounds checking). For\n+// these expressions an error message containing their source location is\n+// generated, so their hash must always depend on their location in the source\n+// code, not just when debuginfo is enabled.\n+\n+// As opposed to the panic_exprs.rs test case, this test case checks that things\n+// behave as expected when overflow checks are off:\n+//\n+// - Addition, subtraction, and multiplication do not change the ICH, unless\n+//   the function containing them is marked with rustc_inherit_overflow_checks.\n+// - Division by zero and bounds checks always influence the ICH\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -Z force-overflow-checks=off\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Indexing expression ---------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n+    -val\n+}\n+\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+\n+\n+// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n+\n+// bitwise ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+\n+// logical ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}"}]}