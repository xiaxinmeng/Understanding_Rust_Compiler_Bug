{"sha": "2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "node_id": "C_kwDOAAsO6NoAKDJmMWI3Y2VkY2Y1MDQ0YmE2MjA2NDZjNjc1OGJiYjk5ZjQ2YjhkOTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T18:25:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T18:25:23Z"}, "message": "Auto merge of #14971 - lowr:fix/captured-item-ty-outer-binder, r=HKalbasi\n\nfix: consider outer binders when folding captured items' type\n\nFixes #14966\n\nBasically, the crash is caused by us producing a broken type and passing it to chalk: `&dyn for<type> [for<> Implemented(^1.0: A<^0.0>)]` (notice the innermost bound var `^0.0` has no corresponding binder). It's created in `CapturedItemWithoutTy::with_ty()`, which didn't consider outer binders when folding types to replace placeholders with bound variables.\n\nThe fix is one-liner, but I've also refactored the surrounding code a little.", "tree": {"sha": "02d99bfb992f95b21ebb779d541dbdf020a3d29c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02d99bfb992f95b21ebb779d541dbdf020a3d29c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "html_url": "https://github.com/rust-lang/rust/commit/2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5545961df2d23ead445de4ba86a67b0c15bd09a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5545961df2d23ead445de4ba86a67b0c15bd09a8", "html_url": "https://github.com/rust-lang/rust/commit/5545961df2d23ead445de4ba86a67b0c15bd09a8"}, {"sha": "f549cacc1d3fb09fd682fa4e0c29d45e8bd179a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f549cacc1d3fb09fd682fa4e0c29d45e8bd179a3", "html_url": "https://github.com/rust-lang/rust/commit/f549cacc1d3fb09fd682fa4e0c29d45e8bd179a3"}], "stats": {"total": 170, "additions": 102, "deletions": 68}, "files": [{"sha": "80f32e96ee63f4b8cb712df1d04e7edb84687e8a", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "patch": "@@ -367,6 +367,10 @@ pub enum PointerCast {\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n+///\n+/// When you add a field that stores types (including `Substitution` and the like), don't forget\n+/// `resolve_completely()`'ing  them in `InferenceContext::resolve_all()`. Inference variables must\n+/// not appear in the final inference result.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n@@ -576,6 +580,30 @@ impl<'a> InferenceContext<'a> {\n     // there is no problem in it being `pub(crate)`, remove this comment.\n     pub(crate) fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n+        // Destructure every single field so whenever new fields are added to `InferenceResult` we\n+        // don't forget to handle them here.\n+        let InferenceResult {\n+            method_resolutions,\n+            field_resolutions: _,\n+            variant_resolutions: _,\n+            assoc_resolutions,\n+            diagnostics,\n+            type_of_expr,\n+            type_of_pat,\n+            type_of_binding,\n+            type_of_rpit,\n+            type_of_for_iterator,\n+            type_mismatches,\n+            standard_types: _,\n+            pat_adjustments,\n+            binding_modes: _,\n+            expr_adjustments,\n+            // Types in `closure_info` have already been `resolve_completely()`'d during\n+            // `InferenceContext::infer_closures()` (in `HirPlace::ty()` specifically), so no need\n+            // to resolve them here.\n+            closure_info: _,\n+            mutated_bindings_in_closure: _,\n+        } = &mut result;\n \n         table.fallback_if_possible();\n \n@@ -584,26 +612,26 @@ impl<'a> InferenceContext<'a> {\n \n         // make sure diverging type variables are marked as such\n         table.propagate_diverging_flag();\n-        for ty in result.type_of_expr.values_mut() {\n+        for ty in type_of_expr.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_pat.values_mut() {\n+        for ty in type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_binding.values_mut() {\n+        for ty in type_of_binding.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_rpit.values_mut() {\n+        for ty in type_of_rpit.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_for_iterator.values_mut() {\n+        for ty in type_of_for_iterator.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for mismatch in result.type_mismatches.values_mut() {\n+        for mismatch in type_mismatches.values_mut() {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n         }\n-        result.diagnostics.retain_mut(|diagnostic| {\n+        diagnostics.retain_mut(|diagnostic| {\n             use InferenceDiagnostic::*;\n             match diagnostic {\n                 ExpectedFunction { found: ty, .. }\n@@ -631,16 +659,16 @@ impl<'a> InferenceContext<'a> {\n             }\n             true\n         });\n-        for (_, subst) in result.method_resolutions.values_mut() {\n+        for (_, subst) in method_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }\n-        for (_, subst) in result.assoc_resolutions.values_mut() {\n+        for (_, subst) in assoc_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }\n-        for adjustment in result.expr_adjustments.values_mut().flatten() {\n+        for adjustment in expr_adjustments.values_mut().flatten() {\n             adjustment.target = table.resolve_completely(adjustment.target.clone());\n         }\n-        for adjustment in result.pat_adjustments.values_mut().flatten() {\n+        for adjustment in pat_adjustments.values_mut().flatten() {\n             *adjustment = table.resolve_completely(adjustment.clone());\n         }\n         result"}, {"sha": "23189f383e0e6ff8aff13f819af2011a81e505ad", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "patch": "@@ -5,7 +5,7 @@ use std::{cmp, collections::HashMap, convert::Infallible, mem};\n use chalk_ir::{\n     cast::Cast,\n     fold::{FallibleTypeFolder, TypeFoldable},\n-    AliasEq, AliasTy, BoundVar, ConstData, DebruijnIndex, FnSubst, Mutability, TyKind, WhereClause,\n+    AliasEq, AliasTy, BoundVar, DebruijnIndex, FnSubst, Mutability, TyKind, WhereClause,\n };\n use hir_def::{\n     data::adt::VariantData,\n@@ -26,8 +26,8 @@ use crate::{\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n     utils::{self, generics, Generics},\n-    Adjust, Adjustment, Binders, BindingMode, ChalkTraitId, ClosureId, ConstValue, DynTy,\n-    FnPointer, FnSig, Interner, Substitution, Ty, TyExt,\n+    Adjust, Adjustment, Binders, BindingMode, ChalkTraitId, ClosureId, DynTy, FnPointer, FnSig,\n+    Interner, Substitution, Ty, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -236,6 +236,24 @@ pub(crate) struct CapturedItemWithoutTy {\n \n impl CapturedItemWithoutTy {\n     fn with_ty(self, ctx: &mut InferenceContext<'_>) -> CapturedItem {\n+        let ty = self.place.ty(ctx).clone();\n+        let ty = match &self.kind {\n+            CaptureKind::ByValue => ty,\n+            CaptureKind::ByRef(bk) => {\n+                let m = match bk {\n+                    BorrowKind::Mut { .. } => Mutability::Mut,\n+                    _ => Mutability::Not,\n+                };\n+                TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n+            }\n+        };\n+        return CapturedItem {\n+            place: self.place,\n+            kind: self.kind,\n+            span: self.span,\n+            ty: replace_placeholder_with_binder(ctx.db, ctx.owner, ty),\n+        };\n+\n         fn replace_placeholder_with_binder(\n             db: &dyn HirDatabase,\n             owner: DefWithBodyId,\n@@ -266,56 +284,28 @@ impl CapturedItemWithoutTy {\n                     let Some(idx) = self.generics.param_idx(x) else {\n                         return Err(());\n                     };\n-                    Ok(ConstData {\n-                        ty,\n-                        value: ConstValue::BoundVar(BoundVar::new(outer_binder, idx)),\n-                    }\n-                    .intern(Interner))\n+                    Ok(BoundVar::new(outer_binder, idx).to_const(Interner, ty))\n                 }\n \n                 fn try_fold_free_placeholder_ty(\n                     &mut self,\n                     idx: chalk_ir::PlaceholderIndex,\n-                    _outer_binder: DebruijnIndex,\n+                    outer_binder: DebruijnIndex,\n                 ) -> std::result::Result<Ty, Self::Error> {\n                     let x = from_placeholder_idx(self.db, idx);\n                     let Some(idx) = self.generics.param_idx(x) else {\n                         return Err(());\n                     };\n-                    Ok(TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n-                        .intern(Interner))\n+                    Ok(BoundVar::new(outer_binder, idx).to_ty(Interner))\n                 }\n             }\n-            let g_def = match owner {\n-                DefWithBodyId::FunctionId(f) => Some(f.into()),\n-                DefWithBodyId::StaticId(_) => None,\n-                DefWithBodyId::ConstId(f) => Some(f.into()),\n-                DefWithBodyId::VariantId(f) => Some(f.into()),\n-            };\n-            let Some(generics) = g_def.map(|g_def| generics(db.upcast(), g_def)) else {\n+            let Some(generic_def) = owner.as_generic_def_id() else {\n                 return Binders::empty(Interner, ty);\n             };\n-            let filler = &mut Filler { db, generics };\n+            let filler = &mut Filler { db, generics: generics(db.upcast(), generic_def) };\n             let result = ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST).unwrap_or(ty);\n             make_binders(db, &filler.generics, result)\n         }\n-        let ty = self.place.ty(ctx).clone();\n-        let ty = match &self.kind {\n-            CaptureKind::ByValue => ty,\n-            CaptureKind::ByRef(bk) => {\n-                let m = match bk {\n-                    BorrowKind::Mut { .. } => Mutability::Mut,\n-                    _ => Mutability::Not,\n-                };\n-                TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n-            }\n-        };\n-        CapturedItem {\n-            place: self.place,\n-            kind: self.kind,\n-            span: self.span,\n-            ty: replace_placeholder_with_binder(ctx.db, ctx.owner, ty),\n-        }\n     }\n }\n "}, {"sha": "ca4268b8fb00c558dfc54d1652e51365e3a27b88", "filename": "crates/hir-ty/src/mir/eval/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "patch": "@@ -640,3 +640,37 @@ fn main() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn regression_14966() {\n+    check_pass(\n+        r#\"\n+//- minicore: fn, copy, coerce_unsized\n+trait A<T> {\n+    fn a(&self) {}\n+}\n+impl A<()> for () {}\n+\n+struct B;\n+impl B {\n+    pub fn b<T>(s: &dyn A<T>) -> Self {\n+        B\n+    }\n+}\n+struct C;\n+impl C {\n+    fn c<T>(a: &dyn A<T>) -> Self {\n+        let mut c = C;\n+        let b = B::b(a);\n+        c.d(|| a.a());\n+        c\n+    }\n+    fn d(&mut self, f: impl FnOnce()) {}\n+}\n+\n+fn main() {\n+    C::c(&());\n+}\n+\"#,\n+    );\n+}"}, {"sha": "ce3f7a8e510264aab566ef6068f41bbed19d765f", "filename": "crates/hir-ty/src/mir/monomorphization.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1b7cedcf5044ba620646c6758bbb99f46b8d95/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs?ref=2f1b7cedcf5044ba620646c6758bbb99f46b8d95", "patch": "@@ -303,13 +303,7 @@ pub fn monomorphized_mir_body_query(\n     subst: Substitution,\n     trait_env: Arc<crate::TraitEnvironment>,\n ) -> Result<Arc<MirBody>, MirLowerError> {\n-    let g_def = match owner {\n-        DefWithBodyId::FunctionId(f) => Some(f.into()),\n-        DefWithBodyId::StaticId(_) => None,\n-        DefWithBodyId::ConstId(f) => Some(f.into()),\n-        DefWithBodyId::VariantId(f) => Some(f.into()),\n-    };\n-    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let generics = owner.as_generic_def_id().map(|g_def| generics(db.upcast(), g_def));\n     let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n     let body = db.mir_body(owner)?;\n     let mut body = (*body).clone();\n@@ -334,13 +328,7 @@ pub fn monomorphized_mir_body_for_closure_query(\n     trait_env: Arc<crate::TraitEnvironment>,\n ) -> Result<Arc<MirBody>, MirLowerError> {\n     let (owner, _) = db.lookup_intern_closure(closure.into());\n-    let g_def = match owner {\n-        DefWithBodyId::FunctionId(f) => Some(f.into()),\n-        DefWithBodyId::StaticId(_) => None,\n-        DefWithBodyId::ConstId(f) => Some(f.into()),\n-        DefWithBodyId::VariantId(f) => Some(f.into()),\n-    };\n-    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let generics = owner.as_generic_def_id().map(|g_def| generics(db.upcast(), g_def));\n     let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n     let body = db.mir_body_for_closure(closure)?;\n     let mut body = (*body).clone();\n@@ -356,13 +344,7 @@ pub fn monomorphize_mir_body_bad(\n     trait_env: Arc<crate::TraitEnvironment>,\n ) -> Result<MirBody, MirLowerError> {\n     let owner = body.owner;\n-    let g_def = match owner {\n-        DefWithBodyId::FunctionId(f) => Some(f.into()),\n-        DefWithBodyId::StaticId(_) => None,\n-        DefWithBodyId::ConstId(f) => Some(f.into()),\n-        DefWithBodyId::VariantId(f) => Some(f.into()),\n-    };\n-    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let generics = owner.as_generic_def_id().map(|g_def| generics(db.upcast(), g_def));\n     let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n     filler.fill_body(&mut body)?;\n     Ok(body)"}]}