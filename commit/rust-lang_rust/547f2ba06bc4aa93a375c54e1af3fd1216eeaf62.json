{"sha": "547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "node_id": "C_kwDOAAsO6NoAKDU0N2YyYmEwNmJjNGFhOTNhMzc1YzU0ZTFhZjNmZDEyMTZlZWFmNjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T10:11:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T10:11:59Z"}, "message": "Auto merge of #86988 - thomcc:chunky-splitz-says-no-checking, r=the8472\n\nCarefully remove bounds checks from some chunk iterator functions\n\nSo, I was writing code that requires the equivalent of `rchunks(N).rev()` (which isn't the same as forward `chunks(N)` \u2014 in particular, if the buffer length is not a multiple of `N`, I must handle the \"remainder\" first).\n\nI happened to look at the codegen output of the function (I was actually interested in whether or not a nested loop was being unrolled \u2014 it was), and noticed that in the outer `rchunks(n).rev()` loop, LLVM seemed to be unable to remove the bounds checks from the iteration: https://rust.godbolt.org/z/Tnz4MYY8f (this panic was from the split_at in `RChunks::next_back`).\n\nAfter doing some experimentation, it seems all of the `next_back` in the non-exact chunk iterators have the issue: (`Chunks::next_back`, `RChunks::next_back`, `ChunksMut::next_back`, and `RChunksMut::next_back`)...\n\nEven worse, the forward `rchunks` iterators sometimes have the issue as well (... but only sometimes). For example https://rust.godbolt.org/z/oGhbqv53r has bounds checks, but if I uncomment the loop body, it manages to remove the check (which is bizarre, since I'd expect the opposite...). I suspect it's highly dependent on the surrounding code, so I decided to remove the bounds checks from them anyway. Overall, this change includes:\n- All `next_back` functions on the non-`Exact` iterators (e.g. `R?Chunks(Mut)?`).\n- All `next` functions on the non-exact rchunks iterators (e.g. `RChunks(Mut)?`).\n\nI wasn't able to catch any of the other chunk iterators failing to remove the bounds checks (I checked iterations over `r?chunks(_exact)?(_mut)?` with constant chunk sizes under `-O3`, `-Os`, and `-Oz`), which makes sense, since these were the cases where it was harder to prove the bounds check correct to remove...\n\nIn fact, it took quite a bit of thinking to convince myself that using unchecked_ here was valid \u2014 so I'm not really surprised that LLVM had trouble (although compilers are slightly better at this sort of reasoning than humans). A consequence of that is the fact that the `// SAFETY` comment for these are... kinda long...\n\n---\n\nI didn't do this for, or even think about it for, any of the other iteration methods; just `next` and `next_back` (where it mattered). If this PR is accepted, I'll file a follow up for someone (possibly me) to look at the others later (in particular, `nth`/`nth_back` looked like they had similar logic), but I wanted to do this now, as IMO `next`/`next_back` are the most important here, since they're what gets used by the iteration protocol.\n\n---\n\nNote: While I don't expect this to impact performance directly, the panic is a side effect, which would otherwise not exist in these loops. That is, this could prevent the compiler from being able to move/remove/otherwise rework a loop over these iterators (as an example, it could not delete the code for a loop whose body computes a value which doesn't get used).\n\nAlso, some like to be able to have confidence this code has no panicking branches in the optimized code, and \"no bounds checks\" is kinda part of the selling point of Rust's iterators anyway.", "tree": {"sha": "ef2b8b7d4bcdc6cd8c67e63b406c7245a8d71603", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2b8b7d4bcdc6cd8c67e63b406c7245a8d71603"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "html_url": "https://github.com/rust-lang/rust/commit/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e8201ca75ebadc341c20c92ad24a4122c83991", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e8201ca75ebadc341c20c92ad24a4122c83991", "html_url": "https://github.com/rust-lang/rust/commit/93e8201ca75ebadc341c20c92ad24a4122c83991"}, {"sha": "9c62455e2f5c6b5a35a8e567dab673e725196162", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c62455e2f5c6b5a35a8e567dab673e725196162", "html_url": "https://github.com/rust-lang/rust/commit/9c62455e2f5c6b5a35a8e567dab673e725196162"}], "stats": {"total": 144, "additions": 137, "deletions": 7}, "files": [{"sha": "d260cc69469cf00b5c512c3804090fba8ea403d5", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "patch": "@@ -1476,7 +1476,21 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            // SAFETY: split_at_unchecked requires the argument be less than or\n+            // equal to the length. This is guaranteed, but subtle: `chunksz`\n+            // will always either be `self.v.len() % self.chunk_size`, which\n+            // will always evaluate to strictly less than `self.v.len()` (or\n+            // panic, in the case that `self.chunk_size` is zero), or it can be\n+            // `self.chunk_size`, in the case that the length is exactly\n+            // divisible by the chunk size.\n+            //\n+            // While it seems like using `self.chunk_size` in this case could\n+            // lead to a value greater than `self.v.len()`, it cannot: if\n+            // `self.chunk_size` were greater than `self.v.len()`, then\n+            // `self.v.len() % self.chunk_size` would return nonzero (note that\n+            // in this branch of the `if`, we already know that `self.v` is\n+            // non-empty).\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };\n             self.v = fst;\n             Some(snd)\n         }\n@@ -1641,7 +1655,8 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = mem::replace(&mut self.v, &mut []);\n             let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            // SAFETY: Similar to `Chunks::next_back`\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n             self.v = head;\n             Some(tail)\n         }\n@@ -2410,8 +2425,14 @@ impl<'a, T> Iterator for RChunks<'a, T> {\n         if self.v.is_empty() {\n             None\n         } else {\n-            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n-            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            let len = self.v.len();\n+            let chunksz = cmp::min(len, self.chunk_size);\n+            // SAFETY: split_at_unchecked just requires the argument be less\n+            // than the length. This could only happen if the expression `len -\n+            // chunksz` overflows. This could only happen if `chunksz > len`,\n+            // which is impossible as we initialize it as the `min` of `len` and\n+            // `self.chunk_size`.\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(len - chunksz) };\n             self.v = fst;\n             Some(snd)\n         }\n@@ -2485,7 +2506,8 @@ impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let (fst, snd) = self.v.split_at(chunksz);\n+            // SAFETY: similar to Chunks::next_back\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(chunksz) };\n             self.v = snd;\n             Some(fst)\n         }\n@@ -2571,7 +2593,12 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n             let tmp = mem::replace(&mut self.v, &mut []);\n             let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            // SAFETY: split_at_mut_unchecked just requires the argument be less\n+            // than the length. This could only happen if the expression\n+            // `tmp_len - sz` overflows. This could only happen if `sz >\n+            // tmp_len`, which is impossible as we initialize it as the `min` of\n+            // `self.v.len()` (e.g. `tmp_len`) and `self.chunk_size`.\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n             self.v = head;\n             Some(tail)\n         }\n@@ -2649,7 +2676,8 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(sz);\n+            // SAFETY: Similar to `Chunks::next_back`\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(sz) };\n             self.v = tail;\n             Some(head)\n         }"}, {"sha": "88cbd7352a2141b59341f41ffe4ee3b727c39e18", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547f2ba06bc4aa93a375c54e1af3fd1216eeaf62/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=547f2ba06bc4aa93a375c54e1af3fd1216eeaf62", "patch": "@@ -251,6 +251,40 @@ fn test_chunks_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_next() {\n+    let v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks(2);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next().unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+    assert_eq!(c.next(), None);\n+\n+    let v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.chunks(3);\n+    assert_eq!(c.next().unwrap(), &[0, 1, 2]);\n+    assert_eq!(c.next().unwrap(), &[3, 4, 5]);\n+    assert_eq!(c.next().unwrap(), &[6, 7]);\n+    assert_eq!(c.next(), None);\n+}\n+\n+#[test]\n+fn test_chunks_next_back() {\n+    let v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks(2);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+    assert_eq!(c.next_back().unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[0, 1]);\n+    assert_eq!(c.next_back(), None);\n+\n+    let v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.chunks(3);\n+    assert_eq!(c.next_back().unwrap(), &[6, 7]);\n+    assert_eq!(c.next_back().unwrap(), &[3, 4, 5]);\n+    assert_eq!(c.next_back().unwrap(), &[0, 1, 2]);\n+    assert_eq!(c.next_back(), None);\n+}\n+\n #[test]\n fn test_chunks_nth_back() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -809,6 +843,40 @@ fn test_rchunks_nth_back() {\n     assert_eq!(c2.next_back(), None);\n }\n \n+#[test]\n+fn test_rchunks_next() {\n+    let v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks(2);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+    assert_eq!(c.next().unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.rchunks(3);\n+    assert_eq!(c.next().unwrap(), &[5, 6, 7]);\n+    assert_eq!(c.next().unwrap(), &[2, 3, 4]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_next_back() {\n+    let v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks(2);\n+    assert_eq!(c.next_back().unwrap(), &[0, 1]);\n+    assert_eq!(c.next_back().unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+    assert_eq!(c.next_back(), None);\n+\n+    let v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.rchunks(3);\n+    assert_eq!(c.next_back().unwrap(), &[0, 1]);\n+    assert_eq!(c.next_back().unwrap(), &[2, 3, 4]);\n+    assert_eq!(c.next_back().unwrap(), &[5, 6, 7]);\n+    assert_eq!(c.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -874,6 +942,40 @@ fn test_rchunks_mut_nth_back() {\n     assert_eq!(c2.next_back(), None);\n }\n \n+#[test]\n+fn test_rchunks_mut_next() {\n+    let mut v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_mut(2);\n+    assert_eq!(c.next().unwrap(), &mut [4, 5]);\n+    assert_eq!(c.next().unwrap(), &mut [2, 3]);\n+    assert_eq!(c.next().unwrap(), &mut [0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let mut v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.rchunks_mut(3);\n+    assert_eq!(c.next().unwrap(), &mut [5, 6, 7]);\n+    assert_eq!(c.next().unwrap(), &mut [2, 3, 4]);\n+    assert_eq!(c.next().unwrap(), &mut [0, 1]);\n+    assert_eq!(c.next(), None);\n+}\n+\n+#[test]\n+fn test_rchunks_mut_next_back() {\n+    let mut v = [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_mut(2);\n+    assert_eq!(c.next_back().unwrap(), &mut [0, 1]);\n+    assert_eq!(c.next_back().unwrap(), &mut [2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &mut [4, 5]);\n+    assert_eq!(c.next_back(), None);\n+\n+    let mut v = [0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut c = v.rchunks_mut(3);\n+    assert_eq!(c.next_back().unwrap(), &mut [0, 1]);\n+    assert_eq!(c.next_back().unwrap(), &mut [2, 3, 4]);\n+    assert_eq!(c.next_back().unwrap(), &mut [5, 6, 7]);\n+    assert_eq!(c.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}]}