{"sha": "1a1de5bf899a15cd97f2a113add070bec46cf209", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMWRlNWJmODk5YTE1Y2Q5N2YyYTExM2FkZDA3MGJlYzQ2Y2YyMDk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-06T12:54:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-25T18:55:04Z"}, "message": "Add a new AST-only type variant `ImplicitSelf`", "tree": {"sha": "0dc5974aa8d68043dc9db9dee7c74aeec7dad68d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dc5974aa8d68043dc9db9dee7c74aeec7dad68d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a1de5bf899a15cd97f2a113add070bec46cf209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1de5bf899a15cd97f2a113add070bec46cf209", "html_url": "https://github.com/rust-lang/rust/commit/1a1de5bf899a15cd97f2a113add070bec46cf209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a1de5bf899a15cd97f2a113add070bec46cf209/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5660a004862e5f7634084fd6e9c6e09f60f60121", "url": "https://api.github.com/repos/rust-lang/rust/commits/5660a004862e5f7634084fd6e9c6e09f60f60121", "html_url": "https://github.com/rust-lang/rust/commit/5660a004862e5f7634084fd6e9c6e09f60f60121"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "f8cd3053f544ba63197dc5b812a7fd5b24c1d9a9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -269,7 +269,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                Infer => hir::TyInfer,\n+                Infer | ImplicitSelf => hir::TyInfer,\n                 Vec(ref ty) => hir::TyVec(self.lower_ty(ty)),\n                 Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 Rptr(ref region, ref mt) => {\n@@ -787,23 +787,24 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n+        let hir_sig = hir::MethodSig {\n+            generics: self.lower_generics(&sig.generics),\n+            abi: sig.abi,\n+            unsafety: self.lower_unsafety(sig.unsafety),\n+            constness: self.lower_constness(sig.constness),\n+            decl: self.lower_fn_decl(&sig.decl),\n+        };\n         // Check for `self: _` and `self: &_`\n-        if !sig.self_shortcut {\n-            match sig.decl.get_self().map(|eself| eself.node) {\n-                Some(SelfKind::Value(..)) | Some(SelfKind::Region(..)) => {\n+        if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n+            match hir_sig.decl.get_self().map(|eself| eself.node) {\n+                Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n                     self.id_assigner.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n                         \"the type placeholder `_` is not allowed within types on item signatures\");\n                 }\n                 _ => {}\n             }\n         }\n-        hir::MethodSig {\n-            generics: self.lower_generics(&sig.generics),\n-            abi: sig.abi,\n-            unsafety: self.lower_unsafety(sig.unsafety),\n-            constness: self.lower_constness(sig.constness),\n-            decl: self.lower_fn_decl(&sig.decl),\n-        }\n+        hir_sig\n     }\n \n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {"}, {"sha": "9f21b47c34a7d31bd44afc9fb9ab44d8e696c69d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -1387,8 +1387,6 @@ pub struct MethodSig {\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n-    /// A short form of self argument was used (`self`, `&self` etc, but not `self: TYPE`).\n-    pub self_shortcut: bool,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1639,6 +1637,8 @@ pub enum TyKind {\n     /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n+    /// Inferred type of a `self` or `&self` argument in a method.\n+    ImplicitSelf,\n     // A macro in the type position.\n     Mac(Mac),\n }\n@@ -1696,8 +1696,8 @@ impl Arg {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n             if ident.node.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n-                    TyKind::Infer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::Infer => {\n+                    TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n@@ -1719,7 +1719,7 @@ impl Arg {\n     pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n-            node: TyKind::Infer,\n+            node: TyKind::ImplicitSelf,\n             span: DUMMY_SP,\n         });\n         let arg = |mutbl, ty, span| Arg {"}, {"sha": "8a53342d05a83626cb9016e8c3865a4eafecc64d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -1128,7 +1128,6 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n     (ast::MethodSig {\n         generics: fld.fold_generics(sig.generics),\n         abi: sig.abi,\n-        self_shortcut: sig.self_shortcut,\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: rewritten_fn_decl"}, {"sha": "aeedafc9f2eb35b22323afc165128fe5bae587d5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -375,7 +375,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyKind::Infer => node,\n+            TyKind::Infer | TyKind::ImplicitSelf => node,\n             TyKind::Vec(ty) => TyKind::Vec(fld.fold_ty(ty)),\n             TyKind::Ptr(mt) => TyKind::Ptr(fld.fold_mt(mt)),\n             TyKind::Rptr(region, mt) => {\n@@ -1066,7 +1066,6 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),\n         abi: sig.abi,\n-        self_shortcut: sig.self_shortcut,\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl)"}, {"sha": "da3312ae0fc5ac7d9fdd345b00c08b9399bdde8e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -1310,7 +1310,7 @@ impl<'a> Parser<'a> {\n                 let ident = p.parse_ident()?;\n                 let mut generics = p.parse_generics()?;\n \n-                let (d, self_shortcut) = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                let d = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n@@ -1324,7 +1324,6 @@ impl<'a> Parser<'a> {\n                     decl: d,\n                     generics: generics,\n                     abi: abi,\n-                    self_shortcut: self_shortcut,\n                 };\n \n                 let body = match p.token {\n@@ -4617,7 +4616,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns the parsed optional self argument and whether a self shortcut was used.\n-    fn parse_self_arg(&mut self) -> PResult<'a, (Option<Arg>, bool)> {\n+    fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n             token::Ident(ident) => { this.bump(); codemap::respan(this.last_span, ident) }\n@@ -4656,7 +4655,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n-                    return Ok((None, false));\n+                    return Ok(None);\n                 }\n             }\n             token::BinOp(token::Star) => {\n@@ -4676,7 +4675,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n                     (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n                 } else {\n-                    return Ok((None, false));\n+                    return Ok(None);\n                 }\n             }\n             token::Ident(..) => {\n@@ -4703,27 +4702,24 @@ impl<'a> Parser<'a> {\n                         (SelfKind::Value(Mutability::Mutable), eself_ident)\n                     }\n                 } else {\n-                    return Ok((None, false));\n+                    return Ok(None);\n                 }\n             }\n-            _ => return Ok((None, false)),\n+            _ => return Ok(None),\n         };\n \n-        let self_shortcut = if let SelfKind::Explicit(..) = eself { false } else { true };\n         let eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n-        Ok((Some(Arg::from_self(eself, eself_ident)), self_shortcut))\n+        Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n \n     /// Parse the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F)\n-                                  -> PResult<'a, (P<FnDecl>, bool)>\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> PResult<'a, P<FnDecl>>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n     {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n         // Parse optional self argument\n-        let (self_arg, self_shortcut) = self.parse_self_arg()?;\n+        let self_arg = self.parse_self_arg()?;\n \n         // Parse the rest of the function parameter list.\n         let sep = SeqSep::trailing_allowed(token::Comma);\n@@ -4745,11 +4741,11 @@ impl<'a> Parser<'a> {\n \n         // Parse closing paren and return type.\n         self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok((P(FnDecl {\n+        Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty()?,\n             variadic: false\n-        }), self_shortcut))\n+        }))\n     }\n \n     // parse the |arg, arg| header on a lambda\n@@ -4942,13 +4938,12 @@ impl<'a> Parser<'a> {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let (decl, self_shortcut) = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n+            let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             Ok((ident, inner_attrs, ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: generics,\n                 abi: abi,\n-                self_shortcut: self_shortcut,\n                 unsafety: unsafety,\n                 constness: constness,\n                 decl: decl"}, {"sha": "416bfab89124dc58e906c12ed212602dbd6cb09d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -1030,6 +1030,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer => {\n                 word(&mut self.s, \"_\")?;\n             }\n+            ast::TyKind::ImplicitSelf => {\n+                unreachable!();\n+            }\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m, token::Paren)?;\n             }"}, {"sha": "51613effea6a479edb80783e350a3d7410cda9c9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -348,7 +348,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        TyKind::Infer => {}\n+        TyKind::Infer | TyKind::ImplicitSelf => {}\n         TyKind::Mac(ref mac) => {\n             visitor.visit_mac(mac)\n         }"}, {"sha": "9095230df630a339e5b63a74e7095501aee1b039", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1de5bf899a15cd97f2a113add070bec46cf209/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1a1de5bf899a15cd97f2a113add070bec46cf209", "patch": "@@ -860,8 +860,6 @@ impl<'a> MethodDef<'a> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n-        // derive doesn't generate `self: TYPE` forms\n-        let self_shortcut = explicit_self.is_some();\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self, respan(trait_.span, keywords::SelfValue.ident()))\n@@ -894,7 +892,6 @@ impl<'a> MethodDef<'a> {\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: fn_generics,\n                 abi: abi,\n-                self_shortcut: self_shortcut,\n                 unsafety: unsafety,\n                 constness: ast::Constness::NotConst,\n                 decl: fn_decl"}]}