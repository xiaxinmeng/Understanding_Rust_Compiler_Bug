{"sha": "7828c3dd2858d8f3a0448484d8093e22719dbda0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MjhjM2RkMjg1OGQ4ZjNhMDQ0ODQ4NGQ4MDkzZTIyNzE5ZGJkYTA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-10-09T19:17:22Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-10-29T15:43:07Z"}, "message": "Rename fail! to panic!\n\nhttps://github.com/rust-lang/rfcs/pull/221\n\nThe current terminology of \"task failure\" often causes problems when\nwriting or speaking about code. You often want to talk about the\npossibility of an operation that returns a Result \"failing\", but cannot\nbecause of the ambiguity with task failure. Instead, you have to speak\nof \"the failing case\" or \"when the operation does not succeed\" or other\ncircumlocutions.\n\nLikewise, we use a \"Failure\" header in rustdoc to describe when\noperations may fail the task, but it would often be helpful to separate\nout a section describing the \"Err-producing\" case.\n\nWe have been steadily moving away from task failure and toward Result as\nan error-handling mechanism, so we should optimize our terminology\naccordingly: Result-producing functions should be easy to describe.\n\nTo update your code, rename any call to `fail!` to `panic!` instead.\nAssuming you have not created your own macro named `panic!`, this\nwill work on UNIX based systems:\n\n    grep -lZR 'fail!' . | xargs -0 -l sed -i -e 's/fail!/panic!/g'\n\nYou can of course also do this by hand.\n\n[breaking-change]", "tree": {"sha": "2d2b106b02526219463d877d480782027ffe1f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d2b106b02526219463d877d480782027ffe1f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7828c3dd2858d8f3a0448484d8093e22719dbda0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7828c3dd2858d8f3a0448484d8093e22719dbda0", "html_url": "https://github.com/rust-lang/rust/commit/7828c3dd2858d8f3a0448484d8093e22719dbda0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7828c3dd2858d8f3a0448484d8093e22719dbda0/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bc545373df4c81ba223a8bece14cbc27eb85a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc545373df4c81ba223a8bece14cbc27eb85a4d", "html_url": "https://github.com/rust-lang/rust/commit/3bc545373df4c81ba223a8bece14cbc27eb85a4d"}], "stats": {"total": 3241, "additions": 1623, "deletions": 1618}, "files": [{"sha": "caf1c8c314dbb1186722eddb92d0a12d5f91b811", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n     let config = parse_config(args);\n \n     if config.valgrind_path.is_none() && config.force_valgrind {\n-        fail!(\"Can't find Valgrind to run Valgrind tests\");\n+        panic!(\"Can't find Valgrind to run Valgrind tests\");\n     }\n \n     log_config(&config);\n@@ -94,20 +94,20 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n         println!(\"\");\n-        fail!()\n+        panic!()\n     }\n \n     let matches =\n         &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n           Ok(m) => m,\n-          Err(f) => fail!(\"{}\", f)\n+          Err(f) => panic!(\"{}\", f)\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n         println!(\"\");\n-        fail!()\n+        panic!()\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n@@ -120,7 +120,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n             Ok(re) => Some(re),\n             Err(e) => {\n                 println!(\"failed to parse filter /{}/: {}\", s, e);\n-                fail!()\n+                panic!()\n             }\n         }\n     } else {\n@@ -263,7 +263,7 @@ pub fn run_tests(config: &Config) {\n     let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}\n-        Ok(false) => fail!(\"Some tests failed\"),\n+        Ok(false) => panic!(\"Some tests failed\"),\n         Err(e) => {\n             println!(\"I/O failure during tests: {}\", e);\n         }"}, {"sha": "b7b94ca6d0df5673dabdb43dd06eb646bb8336cc", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -305,7 +305,7 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n           }\n-          n => fail!(\"Expected 1 or 2 strings, not {}\", n)\n+          n => panic!(\"Expected 1 or 2 strings, not {}\", n)\n         }\n     })\n }\n@@ -350,7 +350,7 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n     let components: Vec<&str> = version_string.trim().split('.').collect();\n \n     if components.len() != 2 {\n-        fail!(\"{}\", error_string);\n+        panic!(\"{}\", error_string);\n     }\n \n     let major: int = FromStr::from_str(components[0]).expect(error_string);"}, {"sha": "a9edad3add61e47babf1862a5f50101cff4abed0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -39,7 +39,7 @@ pub fn run(config: Config, testfile: String) {\n \n         \"arm-linux-androideabi\" => {\n             if !config.adb_device_status {\n-                fail!(\"android device not available\");\n+                panic!(\"android device not available\");\n             }\n         }\n \n@@ -316,7 +316,7 @@ actual:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n                      expected, actual);\n-            fail!();\n+            panic!();\n         }\n     }\n \n@@ -1453,7 +1453,7 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n \n fn error(err: &str) { println!(\"\\nerror: {}\", err); }\n \n-fn fatal(err: &str) -> ! { error(err); fail!(); }\n+fn fatal(err: &str) -> ! { error(err); panic!(); }\n \n fn fatal_proc_rec(err: &str, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n@@ -1471,7 +1471,7 @@ stderr:\\n\\\n \\n\",\n              err, proc_res.status, proc_res.cmdline, proc_res.stdout,\n              proc_res.stderr);\n-    fail!();\n+    panic!();\n }\n \n fn _arm_exec_compiled_test(config: &Config,"}, {"sha": "a116cc33690db101236ef9d512e12ec1c6759045", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -31,7 +31,7 @@ pub fn get_os(triple: &str) -> &'static str {\n             return os\n         }\n     }\n-    fail!(\"Cannot determine OS from triple\");\n+    panic!(\"Cannot determine OS from triple\");\n }\n \n #[cfg(target_os = \"windows\")]"}, {"sha": "9a2531f094c17e5b0e2773b4fd2292278970ce5a", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -94,9 +94,9 @@ code should need to run is a stack.\n \n `match` being exhaustive has some useful properties. First, if every\n possibility is covered by the `match`, adding further variants to the `enum`\n-in the future will prompt a compilation failure, rather than runtime failure.\n+in the future will prompt a compilation failure, rather than runtime panic.\n Second, it makes cost explicit. In general, only safe way to have a\n-non-exhaustive match would be to fail the task if nothing is matched, though\n+non-exhaustive match would be to panic the task if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's\n easy to ignore certain cases by using the `_` wildcard:"}, {"sha": "0a8f9b2ffaa6548f5d74485e7ed7bd992cfeb1ce", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -65,14 +65,15 @@ Data values in the language can only be constructed through a fixed set of initi\n * There is no global inter-crate namespace; all name management occurs within a crate.\n  * Using another crate binds the root of _its_ namespace into the user's namespace.\n \n-## Why is failure unwinding non-recoverable within a task? Why not try to \"catch exceptions\"?\n+## Why is panic unwinding non-recoverable within a task? Why not try to \"catch exceptions\"?\n \n In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with tasks playing the role of a \"hard\" isolation boundary between separate heaps.\n \n Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of \"catch\" logic:\n \n * Failure _logging_ is done by the integrated logging subsystem.\n-* _Recovery_ after a failure is done by trapping a task failure from _outside_ the task, where other tasks are known to be unaffected.\n+* _Recovery_ after a panic is done by trapping a task panic from _outside_\n+  the task, where other tasks are known to be unaffected.\n * _Cleanup_ of resources is done by RAII-style objects with destructors.\n \n Cleanup through RAII-style destructors is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time)."}, {"sha": "3a87271ede7d85572c4ac36225f8678bdaf1c6c0", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -191,7 +191,7 @@ the stack of the task which is spawned.\n \n Foreign libraries often hand off ownership of resources to the calling code.\n When this occurs, we must use Rust's destructors to provide safety and guarantee\n-the release of these resources (especially in the case of failure).\n+the release of these resources (especially in the case of panic).\n \n # Callbacks from C code to Rust functions\n "}, {"sha": "ae020037bc594ee6c2eb37156e57ac5cac3cd6a3", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -240,7 +240,7 @@ match x {\n                 // complicated stuff goes here\n                 return result + val;\n             },\n-            _ => fail!(\"Didn't get good_2\")\n+            _ => panic!(\"Didn't get good_2\")\n         }\n     }\n     _ => return 0 // default value\n@@ -284,7 +284,7 @@ macro_rules! biased_match (\n biased_match!((x)       ~ (Good1(g1, val)) else { return 0 };\n               binds g1, val )\n biased_match!((g1.body) ~ (Good2(result) )\n-                  else { fail!(\"Didn't get good_2\") };\n+                  else { panic!(\"Didn't get good_2\") };\n               binds result )\n // complicated stuff goes here\n return result + val;\n@@ -397,7 +397,7 @@ macro_rules! biased_match (\n # fn f(x: T1) -> uint {\n biased_match!(\n     (x)       ~ (Good1(g1, val)) else { return 0 };\n-    (g1.body) ~ (Good2(result) ) else { fail!(\"Didn't get Good2\") };\n+    (g1.body) ~ (Good2(result) ) else { panic!(\"Didn't get Good2\") };\n     binds val, result )\n // complicated stuff goes here\n return result + val;"}, {"sha": "4eaca64560ca21d3b677c7d891d96f57996e2034", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -8,10 +8,10 @@ relates to the Rust type system, and introduce the fundamental library\n abstractions for constructing concurrent programs.\n \n Tasks provide failure isolation and recovery. When a fatal error occurs in Rust\n-code as a result of an explicit call to `fail!()`, an assertion failure, or\n+code as a result of an explicit call to `panic!()`, an assertion failure, or\n another invalid operation, the runtime system destroys the entire task. Unlike\n in languages such as Java and C++, there is no way to `catch` an exception.\n-Instead, tasks may monitor each other for failure.\n+Instead, tasks may monitor each other to see if they panic.\n \n Tasks use Rust's type system to provide strong memory safety guarantees.  In\n particular, the type system guarantees that tasks cannot induce a data race\n@@ -317,19 +317,19 @@ spawn(proc() {\n # }\n ```\n \n-# Handling task failure\n+# Handling task panics\n \n-Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n-(which can also be written with an error string as an argument: `fail!(\n-~reason)`) and the `assert!` construct (which effectively calls `fail!()` if a\n+Rust has a built-in mechanism for raising exceptions. The `panic!()` macro\n+(which can also be written with an error string as an argument: `panic!(\n+~reason)`) and the `assert!` construct (which effectively calls `panic!()` if a\n boolean expression is false) are both ways to raise exceptions. When a task\n raises an exception, the task unwinds its stack\u2014running destructors and\n freeing memory along the way\u2014and then exits. Unlike exceptions in C++,\n-exceptions in Rust are unrecoverable within a single task: once a task fails,\n+exceptions in Rust are unrecoverable within a single task: once a task panics,\n there is no way to \"catch\" the exception.\n \n-While it isn't possible for a task to recover from failure, tasks may notify\n-each other of failure. The simplest way of handling task failure is with the\n+While it isn't possible for a task to recover from panicking, tasks may notify\n+each other if they panic. The simplest way of handling a panic is with the\n `try` function, which is similar to `spawn`, but immediately blocks and waits\n for the child task to finish. `try` returns a value of type\n `Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n@@ -346,7 +346,7 @@ let result: Result<int, Box<std::any::Any + Send>> = task::try(proc() {\n     if some_condition() {\n         calculate_result()\n     } else {\n-        fail!(\"oops!\");\n+        panic!(\"oops!\");\n     }\n });\n assert!(result.is_err());\n@@ -355,18 +355,18 @@ assert!(result.is_err());\n Unlike `spawn`, the function spawned using `try` may return a value, which\n `try` will dutifully propagate back to the caller in a [`Result`] enum. If the\n child task terminates successfully, `try` will return an `Ok` result; if the\n-child task fails, `try` will return an `Error` result.\n+child task panics, `try` will return an `Error` result.\n \n [`Result`]: std/result/index.html\n \n-> *Note:* A failed task does not currently produce a useful error\n+> *Note:* A panicked task does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the\n > future, it may be possible for tasks to intercept the value passed to\n-> `fail!()`.\n+> `panic!()`.\n \n-But not all failures are created equal. In some cases you might need to abort\n+But not all panics are created equal. In some cases you might need to abort\n the entire program (perhaps you're writing an assert which, if it trips,\n indicates an unrecoverable logic error); in other cases you might want to\n-contain the failure at a certain boundary (perhaps a small piece of input from\n+contain the panic at a certain boundary (perhaps a small piece of input from\n the outside world, which you happen to be processing in parallel, is malformed\n such that the processing task cannot proceed)."}, {"sha": "9d15f55f33f69c3b46ac4d3c2e5cc3cb5b3c6a63", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -49,7 +49,7 @@ value. To run the tests in a crate, it must be compiled with the\n `--test` flag: `rustc myprogram.rs --test -o myprogram-tests`. Running\n the resulting executable will run all the tests in the crate. A test\n is considered successful if its function returns; if the task running\n-the test fails, through a call to `fail!`, a failed `assert`, or some\n+the test fails, through a call to `panic!`, a failed `assert`, or some\n other (`assert_eq`, ...) means, then the test fails.\n \n When compiling a crate with the `--test` flag `--cfg test` is also\n@@ -77,7 +77,7 @@ test on windows you can write `#[cfg_attr(windows, ignore)]`.\n \n Tests that are intended to fail can be annotated with the\n `should_fail` attribute. The test will be run, and if it causes its\n-task to fail then the test will be counted as successful; otherwise it\n+task to panic then the test will be counted as successful; otherwise it\n will be counted as a failure. For example:\n \n ~~~test_harness"}, {"sha": "cade043a7931fa708e3c18d0cb95c671d6e88d89", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -182,7 +182,7 @@ code:\n - implement the `Drop` for resource clean-up via a destructor, and use\n   RAII (Resource Acquisition Is Initialization). This reduces the need\n   for any manual memory management by users, and automatically ensures\n-  that clean-up is always run, even when the task fails.\n+  that clean-up is always run, even when the task panics.\n - ensure that any data stored behind a raw pointer is destroyed at the\n   appropriate time.\n \n@@ -504,7 +504,7 @@ The second of these three functions, `eh_personality`, is used by the\n failure mechanisms of the compiler. This is often mapped to GCC's\n personality function (see the\n [libstd implementation](std/rt/unwind/index.html) for more\n-information), but crates which do not trigger failure can be assured\n+information), but crates which do not trigger a panic can be assured\n that this function is never called. The final function, `fail_fmt`, is\n also used by the failure mechanisms of the compiler.\n "}, {"sha": "53ed2af9cd9aa30694f41c936e6e4c5903d2b7ee", "filename": "src/doc/guide.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -5213,17 +5213,17 @@ immediately.\n \n ## Success and failure\n \n-Tasks don't always succeed, they can also fail. A task that wishes to fail\n-can call the `fail!` macro, passing a message:\n+Tasks don't always succeed, they can also panic. A task that wishes to panic \n+can call the `panic!` macro, passing a message:\n \n ```{rust}\n spawn(proc() {\n-    fail!(\"Nope.\");\n+    panic!(\"Nope.\");\n });\n ```\n \n-If a task fails, it is not possible for it to recover. However, it can\n-notify other tasks that it has failed. We can do this with `task::try`:\n+If a task panics, it is not possible for it to recover. However, it can\n+notify other tasks that it has panicked. We can do this with `task::try`:\n \n ```{rust}\n use std::task;\n@@ -5233,14 +5233,14 @@ let result = task::try(proc() {\n     if rand::random() {\n         println!(\"OK\");\n     } else {\n-        fail!(\"oops!\");\n+        panic!(\"oops!\");\n     }\n });\n ```\n \n-This task will randomly fail or succeed. `task::try` returns a `Result`\n+This task will randomly panic or succeed. `task::try` returns a `Result`\n type, so we can handle the response like any other computation that may\n-fail.\n+panic.\n \n # Macros\n "}, {"sha": "d83d3cbb1ebca7af54b537690ce039166aef1306", "filename": "src/doc/reference.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -817,15 +817,15 @@ mod math {\n     type Complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n         /* ... */\n-# fail!();\n+# panic!();\n     }\n     fn cos(f: f64) -> f64 {\n         /* ... */\n-# fail!();\n+# panic!();\n     }\n     fn tan(f: f64) -> f64 {\n         /* ... */\n-# fail!();\n+# panic!();\n     }\n }\n ```\n@@ -1194,12 +1194,12 @@ output slot type would normally be. For example:\n ```\n fn my_err(s: &str) -> ! {\n     println!(\"{}\", s);\n-    fail!();\n+    panic!();\n }\n ```\n \n We call such functions \"diverging\" because they never return a value to the\n-caller. Every control path in a diverging function must end with a `fail!()` or\n+caller. Every control path in a diverging function must end with a `panic!()` or\n a call to another diverging function on every control path. The `!` annotation\n does *not* denote a type. Rather, the result type of a diverging function is a\n special type called $\\bot$ (\"bottom\") that unifies with any type. Rust has no\n@@ -1212,7 +1212,7 @@ were declared without the `!` annotation, the following code would not\n typecheck:\n \n ```\n-# fn my_err(s: &str) -> ! { fail!() }\n+# fn my_err(s: &str) -> ! { panic!() }\n \n fn f(i: int) -> int {\n    if i == 42 {\n@@ -2259,7 +2259,7 @@ These types help drive the compiler's analysis\n   : Allocate memory on the exchange heap.\n * `closure_exchange_malloc`\n   : ___Needs filling in___\n-* `fail_`\n+* `panic`\n   : Abort the program with an error.\n * `fail_bounds_check`\n   : Abort the program with a bounds check error.\n@@ -2866,11 +2866,11 @@ be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access is\n bounds-checked at run-time. When the check fails, it will put the task in a\n-_failing state_.\n+_panicked state_.\n \n ```{should-fail}\n ([1, 2, 3, 4])[0];\n-([\"a\", \"b\"])[10]; // fails\n+([\"a\", \"b\"])[10]; // panics\n ```\n \n ### Unary operator expressions\n@@ -3300,9 +3300,9 @@ enum List<X> { Nil, Cons(X, Box<List<X>>) }\n let x: List<int> = Cons(10, box Cons(11, box Nil));\n \n match x {\n-    Cons(_, box Nil) => fail!(\"singleton list\"),\n+    Cons(_, box Nil) => panic!(\"singleton list\"),\n     Cons(..)         => return,\n-    Nil              => fail!(\"empty list\")\n+    Nil              => panic!(\"empty list\")\n }\n ```\n \n@@ -3373,7 +3373,7 @@ match x {\n         return;\n     }\n     _ => {\n-        fail!();\n+        panic!();\n     }\n }\n ```\n@@ -3395,7 +3395,7 @@ fn is_sorted(list: &List) -> bool {\n         Cons(x, ref r @ box Cons(_, _)) => {\n             match *r {\n                 box Cons(y, _) => (x <= y) && is_sorted(&**r),\n-                _ => fail!()\n+                _ => panic!()\n             }\n         }\n     }\n@@ -3459,7 +3459,7 @@ may refer to the variables bound within the pattern they follow.\n let message = match maybe_digit {\n   Some(x) if x < 10 => process_digit(x),\n   Some(x) => process_other(x),\n-  None => fail!()\n+  None => panic!()\n };\n ```\n \n@@ -4091,7 +4091,7 @@ cause transitions between the states. The lifecycle states of a task are:\n \n * running\n * blocked\n-* failing\n+* panicked \n * dead\n \n A task begins its lifecycle &mdash; once it has been spawned &mdash; in the\n@@ -4103,21 +4103,21 @@ it makes a blocking communication call. When the call can be completed &mdash;\n when a message arrives at a sender, or a buffer opens to receive a message\n &mdash; then the blocked task will unblock and transition back to *running*.\n \n-A task may transition to the *failing* state at any time, due being killed by\n-some external event or internally, from the evaluation of a `fail!()` macro.\n-Once *failing*, a task unwinds its stack and transitions to the *dead* state.\n+A task may transition to the *panicked* state at any time, due being killed by\n+some external event or internally, from the evaluation of a `panic!()` macro.\n+Once *panicking*, a task unwinds its stack and transitions to the *dead* state.\n Unwinding the stack of a task is done by the task itself, on its own control\n stack. If a value with a destructor is freed during unwinding, the code for the\n destructor is run, also on the task's control stack. Running the destructor\n code causes a temporary transition to a *running* state, and allows the\n destructor code to cause any subsequent state transitions. The original task\n-of unwinding and failing thereby may suspend temporarily, and may involve\n+of unwinding and panicking thereby may suspend temporarily, and may involve\n (recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n outermost unwinding activity will continue until the stack is unwound and the\n task transitions to the *dead* state. There is no way to \"recover\" from task\n-failure. Once a task has temporarily suspended its unwinding in the *failing*\n-state, failure occurring from within this destructor results in *hard* failure.\n-A hard failure currently results in the process aborting.\n+panics. Once a task has temporarily suspended its unwinding in the *panicking*\n+state, a panic occurring from within this destructor results in *hard* panic.\n+A hard panic currently results in the process aborting.\n \n A task in the *dead* state cannot transition to other states; it exists only to\n have its termination status inspected by other tasks, and/or to await"}, {"sha": "4b995631467b5fe3e90fbb667cad99fe72bcae3e", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -169,7 +169,7 @@ directive.\n \n ~~~md\n ```should_fail\n-// This code block is expected to generate a failure when run\n+// This code block is expected to generate a panic when run\n ```\n ~~~\n \n@@ -189,7 +189,7 @@ were passed to the compiler using the `test_harness` directive.\n ```test_harness\n #[test]\n fn foo() {\n-    fail!(\"oops! (will run & register as failure)\")\n+    panic!(\"oops! (will run & register as a failed test)\")\n }\n ```\n ~~~"}, {"sha": "a4345e061640db7a38cee5783f350956d2a2ab6c", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -131,7 +131,7 @@ fn str_to_binop(s: &str) -> BinOpToken {\n         \"|\"     => token::Or,\n         \"<<\"    => token::Shl,\n         \">>\"    => token::Shr,\n-        _       => fail!(\"Bad binop str `{}`\", s),\n+        _       => panic!(\"Bad binop str `{}`\", s),\n     }\n }\n \n@@ -276,7 +276,7 @@ fn main() {\n                                 warn!(\"Different names for {} and {}\", rustc_tok, antlr_tok);\n                             }\n                         }\n-                        _ => fail!(\"{} is not {}\", antlr_tok, rustc_tok)\n+                        _ => panic!(\"{} is not {}\", antlr_tok, rustc_tok)\n                     },)*\n                     ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }"}, {"sha": "f543826fe01878a2ff58ab70dfccb4a20523bc4b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -227,9 +227,9 @@ impl<T: Sync + Send> Drop for Arc<T> {\n impl<T: Sync + Send> Weak<T> {\n     /// Attempts to upgrade this weak reference to a strong reference.\n     ///\n-    /// This method will fail to upgrade this reference if the strong reference\n-    /// count has already reached 0, but if there are still other active strong\n-    /// references this function will return a new strong reference to the data.\n+    /// This method will not upgrade this reference if the strong reference count has already\n+    /// reached 0, but if there are still other active strong references this function will return\n+    /// a new strong reference to the data.\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 is must never be above 0."}, {"sha": "09404af70273381330b2701b4b16531744f775f5", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -148,11 +148,11 @@ mod test {\n \n         match a.downcast::<uint>() {\n             Ok(a) => { assert!(a == box 8u); }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n         match b.downcast::<Test>() {\n             Ok(a) => { assert!(a == box Test); }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n \n         let a = box 8u as Box<Any>;"}, {"sha": "924dd5ffed62cd300c4e5d3190ce046efbad844d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -69,7 +69,7 @@ impl Chunk {\n /// element). When the arena is destroyed, it iterates through all of its\n /// chunks, and uses the tydesc information to trace through the objects,\n /// calling the destructors on them. One subtle point that needs to be\n-/// addressed is how to handle failures while running the user provided\n+/// addressed is how to handle panics while running the user provided\n /// initializer function. It is important to not run the destructor on\n /// uninitialized objects, but how to detect them is somewhat subtle. Since\n /// `alloc()` can be invoked recursively, it is not sufficient to simply exclude\n@@ -162,7 +162,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n // We encode whether the object a tydesc describes has been\n // initialized in the arena in the low bit of the tydesc pointer. This\n-// is necessary in order to properly do cleanup if a failure occurs\n+// is necessary in order to properly do cleanup if a panic occurs\n // during an initializer.\n #[inline]\n fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> uint {\n@@ -337,10 +337,9 @@ fn test_arena_destructors_fail() {\n         // things interesting.\n         arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n-    // Now, fail while allocating\n+    // Now, panic while allocating\n     arena.alloc::<Rc<int>>(|| {\n-        // Now fail.\n-        fail!();\n+        panic!();\n     });\n }\n "}, {"sha": "6b491096e7da47c9d74805030aba2db07d6ef004", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -68,7 +68,7 @@ pub struct Node<K, V> {\n \n impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n-    /// `Found` will be yielded with the matching index. If it fails to find an exact match,\n+    /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n     pub fn search(&self, key: &K) -> SearchResult {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V)."}, {"sha": "22d487bd3a0dbf36c15204578915395b234acab0", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -760,11 +760,11 @@ mod tests {\n         loop {\n             match (last_ptr, node_ptr.prev.resolve_immut()) {\n                 (None   , None      ) => {}\n-                (None   , _         ) => fail!(\"prev link for list_head\"),\n+                (None   , _         ) => panic!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n                     assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n                 }\n-                _ => fail!(\"prev link is none, not good\"),\n+                _ => panic!(\"prev link is none, not good\"),\n             }\n             match node_ptr.next {\n                 Some(ref next) => {"}, {"sha": "20ad5b6334f323cf2ff39619bc4b33f4e19b6309", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -527,8 +527,8 @@ pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]\n mod std {\n-    pub use core::fmt;      // necessary for fail!()\n-    pub use core::option;   // necessary for fail!()\n+    pub use core::fmt;      // necessary for panic!()\n+    pub use core::option;   // necessary for panic!()\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n     pub use hash;           // deriving(Hash)"}, {"sha": "5f05ab7a9069394916c31ed5f669cf59bbe323d5", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -152,7 +152,7 @@ impl<T> RingBuf<T> {\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n         match *self.elts.get_mut(idx) {\n-            None => fail!(),\n+            None => panic!(),\n             Some(ref mut v) => v\n         }\n     }\n@@ -460,7 +460,7 @@ impl<A> Index<uint, A> for RingBuf<A> {\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n         let idx = self.raw_index(*i);\n         match self.elts[idx] {\n-            None => fail!(),\n+            None => panic!(),\n             Some(ref v) => v,\n         }\n     }"}, {"sha": "3f60a6d633097bf6bf7bfce73057e23825c42a42", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1181,7 +1181,7 @@ mod tests {\n                 3 => assert!(v == [2, 3, 1]),\n                 4 => assert!(v == [2, 1, 3]),\n                 5 => assert!(v == [1, 2, 3]),\n-                _ => fail!(),\n+                _ => panic!(),\n             }\n         }\n     }\n@@ -1391,7 +1391,7 @@ mod tests {\n             }\n         }\n \n-        // shouldn't fail/crash\n+        // shouldn't panic\n         let mut v: [uint, .. 0] = [];\n         v.sort();\n \n@@ -1545,7 +1545,7 @@ mod tests {\n     #[should_fail]\n     fn test_from_fn_fail() {\n         Vec::from_fn(100, |v| {\n-            if v == 50 { fail!() }\n+            if v == 50 { panic!() }\n             box 0i\n         });\n     }\n@@ -1562,7 +1562,7 @@ mod tests {\n         impl Clone for S {\n             fn clone(&self) -> S {\n                 self.f.set(self.f.get() + 1);\n-                if self.f.get() == 10 { fail!() }\n+                if self.f.get() == 10 { panic!() }\n                 S { f: self.f, boxes: self.boxes.clone() }\n             }\n         }\n@@ -1577,7 +1577,7 @@ mod tests {\n         let mut v = vec![];\n         v.grow_fn(100, |i| {\n             if i == 50 {\n-                fail!()\n+                panic!()\n             }\n             (box 0i, Rc::new(0i))\n         })\n@@ -1591,7 +1591,7 @@ mod tests {\n         let mut i = 0u;\n         for _ in v.permutations() {\n             if i == 2 {\n-                fail!()\n+                panic!()\n             }\n             i += 1;\n         }\n@@ -2189,7 +2189,7 @@ mod bench {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {fail!()}\n+            if sum == 0 {panic!()}\n         })\n     }\n "}, {"sha": "3b509f37c47053b85531d75a22703c6e4bb09bf2", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -511,7 +511,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => panic!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "5dd3be4ec8fd4daff1ac9d1f80b790efdf5e9553", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1367,7 +1367,7 @@ mod tests {\n         // original problem code path anymore.)\n         let s = String::from_str(\"\");\n         let _bytes = s.as_bytes();\n-        fail!();\n+        panic!();\n     }\n \n     #[test]\n@@ -1586,7 +1586,7 @@ mod tests {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n-                fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+                panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n         }\n     }\n@@ -1598,7 +1598,7 @@ mod tests {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n-                fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+                panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n         }\n     }"}, {"sha": "b61f26688a2ee3cb78fba64e7a5d00e675d53b0a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -504,7 +504,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[unstable = \"the failure conventions for strings are under development\"]\n+    #[unstable = \"the panic conventions for strings are under development\"]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.as_slice().is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -545,10 +545,10 @@ impl String {\n     /// This is a O(n) operation as it requires copying every element in the\n     /// buffer.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `idx` does not lie on a character boundary, then this function will\n-    /// fail.\n+    /// panic.\n     ///\n     /// # Example\n     ///\n@@ -559,7 +559,7 @@ impl String {\n     /// assert_eq!(s.remove(0), Some('o'));\n     /// assert_eq!(s.remove(0), None);\n     /// ```\n-    #[unstable = \"the failure semantics of this function and return type \\\n+    #[unstable = \"the panic semantics of this function and return type \\\n                   may change\"]\n     pub fn remove(&mut self, idx: uint) -> Option<char> {\n         let len = self.len();\n@@ -582,11 +582,11 @@ impl String {\n     /// This is a O(n) operation as it requires copying every element in the\n     /// buffer.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n-    /// this function will fail.\n-    #[unstable = \"the failure semantics of this function are uncertain\"]\n+    /// this function will panic.\n+    #[unstable = \"the panic semantics of this function are uncertain\"]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);"}, {"sha": "feb4c11a061a576be42e63e9d4b4ee6441b6c0b1", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -490,7 +490,7 @@ impl<K, V> TreeMap<K, V> {\n     /// let new_ua = \"Safari/156.0\";\n     /// match t.find_with_mut(|k| \"User-Agent\".cmp(k)) {\n     ///    Some(x) => *x = new_ua,\n-    ///    None => fail!(),\n+    ///    None => panic!(),\n     /// }\n     ///\n     /// assert_eq!(t.find(&\"User-Agent\"), Some(&new_ua));\n@@ -1616,7 +1616,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n       }\n     }\n     return match node.take() {\n-        Some(box TreeNode{value, ..}) => Some(value), None => fail!()\n+        Some(box TreeNode{value, ..}) => Some(value), None => panic!()\n     };\n }\n \n@@ -1726,7 +1726,7 @@ mod test_treemap {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-          None => fail!(), Some(x) => *x = new\n+          None => panic!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }\n@@ -1739,7 +1739,7 @@ mod test_treemap {\n         assert!(m.insert(\"t5\", 14));\n         let new = 100;\n         match m.find_with_mut(|k| \"t5\".cmp(k)) {\n-          None => fail!(), Some(x) => *x = new\n+          None => panic!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find_with(|k| \"t5\".cmp(k)), Some(&new));\n     }"}, {"sha": "d02190e08247e0ca1c2deafd2e68e4f9d28c1102", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -834,7 +834,7 @@ fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n             *child = Internal(new);\n             return ret;\n         }\n-        _ => fail!(\"unreachable code\"),\n+        _ => panic!(\"unreachable code\"),\n     }\n }\n \n@@ -844,7 +844,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n       External(stored, _) if stored == key => {\n         match mem::replace(child, Nothing) {\n             External(_, value) => (Some(value), true),\n-            _ => fail!()\n+            _ => panic!()\n         }\n       }\n       External(..) => (None, false),\n@@ -1057,7 +1057,7 @@ mod test_map {\n         assert!(m.insert(5u, 14i));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => panic!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "759f9ec7d3f0361780f7edb0eb5c08f5327f5a12", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -583,7 +583,7 @@ impl<T> Vec<T> {\n     pub fn reserve_additional(&mut self, extra: uint) {\n         if self.cap - self.len < extra {\n             match self.len.checked_add(&extra) {\n-                None => fail!(\"Vec::reserve_additional: `uint` overflow\"),\n+                None => panic!(\"Vec::reserve_additional: `uint` overflow\"),\n                 Some(new_cap) => self.reserve(new_cap)\n             }\n         }\n@@ -699,12 +699,12 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"waiting on failure semantics\"]\n+    #[unstable = \"waiting on panic semantics\"]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n             while len < self.len {\n-                // decrement len before the read(), so a failure on Drop doesn't\n+                // decrement len before the read(), so a panic on Drop doesn't\n                 // re-drop the just-failed value.\n                 self.len -= 1;\n                 ptr::read(self.as_slice().unsafe_get(self.len));\n@@ -960,9 +960,9 @@ impl<T> Vec<T> {\n     /// Inserts an element at position `index` within the vector, shifting all\n     /// elements after position `i` one position to the right.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `index` is not between `0` and the vector's length (both\n+    /// Panics if `index` is not between `0` and the vector's length (both\n     /// bounds inclusive).\n     ///\n     /// # Example\n@@ -974,7 +974,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[unstable = \"failure semantics need settling\"]\n+    #[unstable = \"panic semantics need settling\"]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -1011,7 +1011,7 @@ impl<T> Vec<T> {\n     /// // v is unchanged:\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[unstable = \"failure semantics need settling\"]\n+    #[unstable = \"panic semantics need settling\"]\n     pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n@@ -1353,7 +1353,7 @@ impl<T: PartialEq> Vec<T> {\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `PartialEq` comparisons could fail, so we\n+            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n             // must ensure that the vector is in a valid state at all time.\n             //\n             // The way that we handle this is by using swaps; we iterate\n@@ -1520,7 +1520,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n         if self.len == self.cap {\n             let old_size = self.cap * mem::size_of::<T>();\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size { fail!(\"capacity overflow\") }\n+            if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n             }\n@@ -1877,7 +1877,7 @@ impl<T> Vec<T> {\n                     // +-+-+-+-+-+-+-+-+-+\n                     //          |         |\n                     //          end_u     end_t\n-                    // We must not fail here, one cell is marked as `T`\n+                    // We must not panic here, one cell is marked as `T`\n                     // although it is not `T`.\n \n                     pv.start_t = pv.start_t.offset(1);\n@@ -1888,9 +1888,9 @@ impl<T> Vec<T> {\n                     // +-+-+-+-+-+-+-+-+-+\n                     //          |         |\n                     //          end_u     end_t\n-                    // We may fail again.\n+                    // We may panic again.\n \n-                    // The function given by the user might fail.\n+                    // The function given by the user might panic.\n                     let u = f(t);\n \n                     ptr::write(pv.end_u, u);\n@@ -1901,7 +1901,7 @@ impl<T> Vec<T> {\n                     // +-+-+-+-+-+-+-+-+-+\n                     //          |         |\n                     //          end_u     end_t\n-                    // We should not fail here, because that would leak the `U`\n+                    // We should not panic here, because that would leak the `U`\n                     // pointed to by `end_u`.\n \n                     pv.end_u = pv.end_u.offset(1);\n@@ -1912,7 +1912,7 @@ impl<T> Vec<T> {\n                     // +-+-+-+-+-+-+-+-+-+\n                     //            |       |\n                     //            end_u   end_t\n-                    // We may fail again.\n+                    // We may panic again.\n                 }\n             }\n \n@@ -1926,10 +1926,10 @@ impl<T> Vec<T> {\n             //              end_u\n             // Extract `vec` and prevent the destructor of\n             // `PartialVecNonZeroSized` from running. Note that none of the\n-            // function calls can fail, thus no resources can be leaked (as the\n+            // function calls can panic, thus no resources can be leaked (as the\n             // `vec` member of `PartialVec` is the only one which holds\n             // allocations -- and it is returned from this function. None of\n-            // this can fail.\n+            // this can panic.\n             unsafe {\n                 let vec_len = pv.vec.len();\n                 let vec_cap = pv.vec.capacity();\n@@ -1953,24 +1953,24 @@ impl<T> Vec<T> {\n             while pv.num_t != 0 {\n                 unsafe {\n                     // Create a `T` out of thin air and decrement `num_t`. This\n-                    // must not fail between these steps, as otherwise a\n+                    // must not panic between these steps, as otherwise a\n                     // destructor of `T` which doesn't exist runs.\n                     let t = mem::uninitialized();\n                     pv.num_t -= 1;\n \n-                    // The function given by the user might fail.\n+                    // The function given by the user might panic.\n                     let u = f(t);\n \n                     // Forget the `U` and increment `num_u`. This increment\n                     // cannot overflow the `uint` as we only do this for a\n                     // number of times that fits into a `uint` (and start with\n-                    // `0`). Again, we should not fail between these steps.\n+                    // `0`). Again, we should not panic between these steps.\n                     mem::forget(u);\n                     pv.num_u += 1;\n                 }\n             }\n             // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n-            // destructor of the latter will not run. None of this can fail.\n+            // destructor of the latter will not run. None of this can panic.\n             let mut result = Vec::new();\n             unsafe { result.set_len(pv.num_u); }\n             result\n@@ -2292,7 +2292,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let BadElem(ref mut x) = *self;\n                 if *x == 0xbadbeef {\n-                    fail!(\"BadElem failure: 0xbadbeef\")\n+                    panic!(\"BadElem panic: 0xbadbeef\")\n                 }\n             }\n         }"}, {"sha": "f272465e796260d268a39946575b295b9d5fd45e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -599,8 +599,8 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n         SeqCst  => intrinsics::atomic_store(dst, val),\n-        Acquire => fail!(\"there is no such thing as an acquire store\"),\n-        AcqRel  => fail!(\"there is no such thing as an acquire/release store\"),\n+        Acquire => panic!(\"there is no such thing as an acquire store\"),\n+        AcqRel  => panic!(\"there is no such thing as an acquire/release store\"),\n     }\n }\n \n@@ -610,8 +610,8 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n         SeqCst  => intrinsics::atomic_load(dst),\n-        Release => fail!(\"there is no such thing as a release load\"),\n-        AcqRel  => fail!(\"there is no such thing as an acquire/release load\"),\n+        Release => panic!(\"there is no such thing as a release load\"),\n+        AcqRel  => panic!(\"there is no such thing as an acquire/release load\"),\n     }\n }\n \n@@ -737,7 +737,7 @@ pub fn fence(order: Ordering) {\n             Release => intrinsics::atomic_fence_rel(),\n             AcqRel  => intrinsics::atomic_fence_acqrel(),\n             SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n+            Relaxed => panic!(\"there is no such thing as a relaxed fence\")\n         }\n     }\n }"}, {"sha": "9d3fa9deed7739025b8ce2c56197aebb731c105b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -31,7 +31,7 @@\n //! tracked statically, at compile time. Because `RefCell` borrows are\n //! dynamic it is possible to attempt to borrow a value that is\n //! already mutably borrowed; when this happens it results in task\n-//! failure.\n+//! panic.\n //!\n //! # When to choose interior mutability\n //!\n@@ -109,7 +109,7 @@\n //!         // Recursive call to return the just-cached value.\n //!         // Note that if we had not let the previous borrow\n //!         // of the cache fall out of scope then the subsequent\n-//!         // recursive borrow would cause a dynamic task failure.\n+//!         // recursive borrow would cause a dynamic task panic.\n //!         // This is the major hazard of using `RefCell`.\n //!         self.minimum_spanning_tree()\n //!     }\n@@ -281,7 +281,7 @@ impl<T> RefCell<T> {\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n-            None => fail!(\"RefCell<T> already mutably borrowed\")\n+            None => panic!(\"RefCell<T> already mutably borrowed\")\n         }\n     }\n \n@@ -314,7 +314,7 @@ impl<T> RefCell<T> {\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n-            None => fail!(\"RefCell<T> already borrowed\")\n+            None => panic!(\"RefCell<T> already borrowed\")\n         }\n     }\n "}, {"sha": "5d9553cbbbd570acfa5c904f434163a967934b48", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -120,7 +120,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail!(\"to_digit: radix is too high (maximum 36)\");\n+        panic!(\"to_digit: radix is too high (maximum 36)\");\n     }\n     let val = match c {\n       '0' ... '9' => c as uint - ('0' as uint),\n@@ -147,7 +147,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix is too high (maximum 36)\");\n+        panic!(\"from_digit: radix is to high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {"}, {"sha": "a17169f62c8be16b36c9477b06025b6e46cce42f", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -60,7 +60,7 @@ impl<T> Finally<T> for fn() -> T {\n \n /**\n  * The most general form of the `finally` functions. The function\n- * `try_fn` will be invoked first; whether or not it fails, the\n+ * `try_fn` will be invoked first; whether or not it panics, the\n  * function `finally_fn` will be invoked next. The two parameters\n  * `mutate` and `drop` are used to thread state through the two\n  * closures. `mutate` is used for any shared, mutable state that both\n@@ -69,7 +69,7 @@ impl<T> Finally<T> for fn() -> T {\n  *\n  * **WARNING:** While shared, mutable state between the try and finally\n  * function is often necessary, one must be very careful; the `try`\n- * function could have failed at any point, so the values of the shared\n+ * function could have panicked at any point, so the values of the shared\n  * state may be inconsistent.\n  *\n  * # Example"}, {"sha": "79191c5a2b426183ee0cf11253e8b5f2ad101188", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -94,7 +94,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         _ => ()\n     }\n@@ -127,7 +127,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         ExpDec => {\n             let (exp, exp_base) = match exp_format {\n                 ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                ExpNone => fail!(\"unreachable\"),\n+                ExpNone => panic!(\"unreachable\"),\n             };\n \n             (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n@@ -299,7 +299,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n             buf[end] = match exp_format {\n                 ExpDec if exp_upper => 'E',\n                 ExpDec if !exp_upper => 'e',\n-                _ => fail!(\"unreachable\"),\n+                _ => panic!(\"unreachable\"),\n             } as u8;\n             end += 1;\n "}, {"sha": "22d8ba63b20ecd3e4bbf6a56846238c18a471dc4", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -92,7 +92,7 @@ macro_rules! radix {\n             fn digit(&self, x: u8) -> u8 {\n                 match x {\n                     $($x => $conv,)+\n-                    x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+                    x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n                 }\n             }\n         }\n@@ -126,7 +126,7 @@ impl GenericRadix for Radix {\n         match x {\n             x @  0 ... 9 => b'0' + x,\n             x if x < self.base() => b'a' + (x - 10),\n-            x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+            x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n         }\n     }\n }"}, {"sha": "6370e55332efb75faa848fb2a4e68f78f6059a8b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -40,8 +40,8 @@\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n //!   `&fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n-//!   the failure message, the file at which failure was invoked, and the line.\n-//!   It is up to consumers of this core library to define this failure\n+//!   the panic message, the file at which panic was invoked, and the line.\n+//!   It is up to consumers of this core library to define this panic\n //!   function; it is only required to never return.\n \n // Since libcore defines many fundamental lang items, all tests live in a\n@@ -111,7 +111,7 @@ pub mod atomic;\n pub mod bool;\n pub mod cell;\n pub mod char;\n-pub mod failure;\n+pub mod panicking;\n pub mod finally;\n pub mod iter;\n pub mod option;\n@@ -129,7 +129,7 @@ pub mod fmt;\n \n #[doc(hidden)]\n mod core {\n-    pub use failure;\n+    pub use panicking;\n }\n \n #[doc(hidden)]"}, {"sha": "9ba67bb2e47dca2d283c17bbfd1f97a44f86873c", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,15 +10,15 @@\n \n #![macro_escape]\n \n-/// Entry point of failure, for details, see std::macros\n+/// Entry point of task panic, for details, see std::macros\n #[macro_export]\n-macro_rules! fail(\n+macro_rules! panic(\n     () => (\n-        fail!(\"{}\", \"explicit failure\")\n+        panic!(\"{}\", \"explicit panic\")\n     );\n     ($msg:expr) => ({\n         static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n-        ::core::failure::fail(&_MSG_FILE_LINE)\n+        ::core::panicking::panic(&_MSG_FILE_LINE)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n         // a closure can't have return type !, so we need a full\n@@ -31,7 +31,7 @@ macro_rules! fail(\n         // as returning !. We really do want this to be inlined, however,\n         // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n         // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to fail!()\n+        // up with the number of calls to panic!()\n         //\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n@@ -40,7 +40,7 @@ macro_rules! fail(\n         #[inline(always)]\n         fn _run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n             static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-            ::core::failure::fail_fmt(fmt, &_FILE_LINE)\n+            ::core::panicking::panic_fmt(fmt, &_FILE_LINE)\n         }\n         format_args!(_run_fmt, $fmt, $($arg)*)\n     });\n@@ -51,12 +51,12 @@ macro_rules! fail(\n macro_rules! assert(\n     ($cond:expr) => (\n         if !$cond {\n-            fail!(concat!(\"assertion failed: \", stringify!($cond)))\n+            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n     ($cond:expr, $($arg:tt)*) => (\n         if !$cond {\n-            fail!($($arg)*)\n+            panic!($($arg)*)\n         }\n     );\n )\n@@ -78,7 +78,7 @@ macro_rules! assert_eq(\n         let c1 = $cond1;\n         let c2 = $cond2;\n         if c1 != c2 || c2 != c1 {\n-            fail!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+            panic!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n         }\n     })\n )\n@@ -130,4 +130,4 @@ macro_rules! write(\n )\n \n #[macro_export]\n-macro_rules! unreachable( () => (fail!(\"unreachable code\")) )\n+macro_rules! unreachable( () => (panic!(\"unreachable code\")) )"}, {"sha": "525d588d70f1dfab3929f6fff3e04bce3f65a5d6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1349,7 +1349,7 @@ checked_impl!(CheckedMul, checked_mul, i16, intrinsics::i16_mul_with_overflow)\n checked_impl!(CheckedMul, checked_mul, i32, intrinsics::i32_mul_with_overflow)\n checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n \n-/// Performs division that returns `None` instead of failing on division by zero and instead of\n+/// Performs division that returns `None` instead of panicking on division by zero and instead of\n /// wrapping around on underflow and overflow.\n pub trait CheckedDiv: Div<Self, Self> {\n     /// Divides two numbers, checking for underflow, overflow and division by zero. If any of that"}, {"sha": "522eb8336376e28327c3448dc38167665bb4145a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -291,9 +291,9 @@ impl<T> Option<T> {\n \n     /// Unwraps an option, yielding the content of a `Some`\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the value is a `None` with a custom failure message provided by\n+    /// Fails if the value is a `None` with a custom panic message provided by\n     /// `msg`.\n     ///\n     /// # Example\n@@ -312,19 +312,19 @@ impl<T> Option<T> {\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n-            None => fail!(\"{}\", msg),\n+            None => panic!(\"{}\", msg),\n         }\n     }\n \n     /// Returns the inner `T` of a `Some(T)`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the self value equals `None`.\n+    /// Panics if the self value equals `None`.\n     ///\n     /// # Safety note\n     ///\n-    /// In general, because this function may fail, its use is discouraged.\n+    /// In general, because this function may panic, its use is discouraged.\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     ///\n@@ -344,7 +344,7 @@ impl<T> Option<T> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n-            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n+            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n "}, {"sha": "cda21b6ecfa7dc17c50de296388956efc731adb4", "filename": "src/libcore/panicking.rs", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Failure support for libcore\n+//! Panic support for libcore\n //!\n-//! The core library cannot define failure, but it does *declare* failure. This\n-//! means that the functions inside of libcore are allowed to fail, but to be\n-//! useful an upstream crate must define failure for libcore to use. The current\n-//! interface for failure is:\n+//! The core library cannot define panicking, but it does *declare* panicking. This\n+//! means that the functions inside of libcore are allowed to panic, but to be\n+//! useful an upstream crate must define panicking for libcore to use. The current\n+//! interface for panicking is:\n //!\n //! ```ignore\n-//! fn fail_impl(fmt: &fmt::Arguments, &(&'static str, uint)) -> !;\n+//! fn panic_impl(fmt: &fmt::Arguments, &(&'static str, uint)) -> !;\n //! ```\n //!\n-//! This definition allows for failing with any general message, but it does not\n-//! allow for failing with a `~Any` value. The reason for this is that libcore\n+//! This definition allows for panicking with any general message, but it does not\n+//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n //! is not allowed to allocate.\n //!\n-//! This module contains a few other failure functions, but these are just the\n-//! necessary lang items for the compiler. All failure is funneled through this\n+//! This module contains a few other panicking functions, but these are just the\n+//! necessary lang items for the compiler. All panics are funneled through this\n //! one function. Currently, the actual symbol is declared in the standard\n //! library, but the location of this may change over time.\n \n@@ -34,36 +34,36 @@ use fmt;\n use intrinsics;\n \n #[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"fail\"]\n-pub fn fail(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n+#[lang=\"panic\"]\n+pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n     let (expr, file, line) = *expr_file_line;\n     let ref file_line = (file, line);\n     format_args!(|args| -> () {\n-        fail_fmt(args, file_line);\n+        panic_fmt(args, file_line);\n     }, \"{}\", expr);\n \n     unsafe { intrinsics::abort() }\n }\n \n #[cold] #[inline(never)]\n-#[lang=\"fail_bounds_check\"]\n-fn fail_bounds_check(file_line: &(&'static str, uint),\n+#[lang=\"panic_bounds_check\"]\n+fn panic_bounds_check(file_line: &(&'static str, uint),\n                      index: uint, len: uint) -> ! {\n     format_args!(|args| -> () {\n-        fail_fmt(args, file_line);\n+        panic_fmt(args, file_line);\n     }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n     unsafe { intrinsics::abort() }\n }\n \n #[cold] #[inline(never)]\n-pub fn fail_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(ctypes)]\n     extern {\n-        #[lang = \"fail_fmt\"]\n-        fn fail_impl(fmt: &fmt::Arguments, file: &'static str,\n+        #[lang = \"panic_fmt\"]\n+        fn panic_impl(fmt: &fmt::Arguments, file: &'static str,\n                         line: uint) -> !;\n \n     }\n     let (file, line) = *file_line;\n-    unsafe { fail_impl(fmt, file, line) }\n+    unsafe { panic_impl(fmt, file, line) }\n }", "previous_filename": "src/libcore/failure.rs"}, {"sha": "5e2f5529e8d4971d80b149fb0ea65e97ba7a5405", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -76,7 +76,7 @@\n //!     unsafe {\n //!         let my_num: *mut int = libc::malloc(mem::size_of::<int>() as libc::size_t) as *mut int;\n //!         if my_num.is_null() {\n-//!             fail!(\"failed to allocate memory\");\n+//!             panic!(\"failed to allocate memory\");\n //!         }\n //!         libc::free(my_num as *mut libc::c_void);\n //!     }"}, {"sha": "82da972f68a3568ca0785ea664b105a3073e22be", "filename": "src/libcore/result.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -123,8 +123,8 @@\n //! warning (by default, controlled by the `unused_must_use` lint).\n //!\n //! You might instead, if you don't want to handle the error, simply\n-//! fail, by converting to an `Option` with `ok`, then asserting\n-//! success with `expect`. This will fail if the write fails, proving\n+//! panic, by converting to an `Option` with `ok`, then asserting\n+//! success with `expect`. This will panic if the write fails, proving\n //! a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n@@ -250,29 +250,29 @@\n //! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n //! ```\n //!\n-//! # `Result` vs. `fail!`\n+//! # `Result` vs. `panic!`\n //!\n-//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n-//! errors. Callers should always be able to avoid failure if they\n+//! `Result` is for recoverable errors; `panic!` is for unrecoverable\n+//! errors. Callers should always be able to avoid panics if they\n //! take the proper precautions, for example, calling `is_some()`\n //! on an `Option` type before calling `unwrap`.\n //!\n-//! The suitability of `fail!` as an error handling mechanism is\n+//! The suitability of `panic!` as an error handling mechanism is\n //! limited by Rust's lack of any way to \"catch\" and resume execution\n-//! from a thrown exception. Therefore using failure for error\n-//! handling requires encapsulating fallible code in a task. Calling\n-//! the `fail!` macro, or invoking `fail!` indirectly should be\n-//! avoided as an error reporting strategy. Failure is only for\n-//! unrecoverable errors and a failing task is typically the sign of\n+//! from a thrown exception. Therefore using panics for error\n+//! handling requires encapsulating code that may panic in a task.\n+//! Calling the `panic!` macro, or invoking `panic!` indirectly should be\n+//! avoided as an error reporting strategy. Panics is only for\n+//! unrecoverable errors and a panicking task is typically the sign of\n //! a bug.\n //!\n //! A module that instead returns `Results` is alerting the caller\n-//! that failure is possible, and providing precise control over how\n+//! that panics are possible, and providing precise control over how\n //! it is handled.\n //!\n-//! Furthermore, failure may not be recoverable at all, depending on\n-//! the context. The caller of `fail!` should assume that execution\n-//! will not resume after failure, that failure is catastrophic.\n+//! Furthermore, panics may not be recoverable at all, depending on\n+//! the context. The caller of `panic!` should assume that execution\n+//! will not resume after the panic, that a panic is catastrophic.\n \n #![stable]\n \n@@ -764,9 +764,9 @@ impl<T, E> Result<T, E> {\n impl<T, E: Show> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the value is an `Err`, with a custom failure message provided\n+    /// Panics if the value is an `Err`, with a custom panic message provided\n     /// by the `Err`'s value.\n     ///\n     /// # Example\n@@ -778,32 +778,32 @@ impl<T, E: Show> Result<T, E> {\n     ///\n     /// ```{.should_fail}\n     /// let x: Result<uint, &str> = Err(\"emergency failure\");\n-    /// x.unwrap(); // fails with `emergency failure`\n+    /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n         }\n     }\n }\n \n impl<T: Show, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the value is an `Ok`, with a custom failure message provided\n+    /// Panics if the value is an `Ok`, with a custom panic message provided\n     /// by the `Ok`'s value.\n     ///\n     /// # Example\n     ///\n     /// ```{.should_fail}\n     /// let x: Result<uint, &str> = Ok(2u);\n-    /// x.unwrap_err(); // fails with `2`\n+    /// x.unwrap_err(); // panics with `2`\n     /// ```\n     ///\n     /// ```\n@@ -815,7 +815,7 @@ impl<T: Show, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n             Err(e) => e\n         }\n     }"}, {"sha": "ff1db992844d6f3382ec1e7389e03dd0802db6cb", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1460,7 +1460,7 @@ pub trait StrSlice for Sized? {\n     ///\n     /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n     ///\n-    /// // these will fail:\n+    /// // these will panic:\n     /// // byte 2 lies within `\u00f6`:\n     /// // s.slice(2, 3);\n     ///\n@@ -1832,7 +1832,7 @@ pub trait StrSlice for Sized? {\n #[inline(never)]\n fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n     assert!(begin <= end);\n-    fail!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n+    panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n }\n \n@@ -1986,8 +1986,8 @@ impl StrSlice for str {\n         if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n         match (begin_byte, end_byte) {\n-            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n-            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (None, _) => panic!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => panic!(\"slice_chars: `end` is beyond end of string\"),\n             (Some(a), Some(b)) => unsafe { raw::slice_bytes(self, a, b) }\n         }\n     }"}, {"sha": "7c832e90ed96bac6bcf18e6aaa92ecbdcd577134", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -56,12 +56,12 @@ fn any_downcast_ref() {\n \n     match a.downcast_ref::<uint>() {\n         Some(&5) => {}\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match a.downcast_ref::<Test>() {\n         None => {}\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n }\n \n@@ -79,35 +79,35 @@ fn any_downcast_mut() {\n             assert_eq!(*x, 5u);\n             *x = 612;\n         }\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(x) => {\n             assert_eq!(*x, 7u);\n             *x = 413;\n         }\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match a_r.downcast_mut::<Test>() {\n         None => (),\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match b_r.downcast_mut::<Test>() {\n         None => (),\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match a_r.downcast_mut::<uint>() {\n         Some(&612) => {}\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(&413) => {}\n-        x => fail!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {}\", x)\n     }\n }\n "}, {"sha": "032f5f7194117e8d8596075b1b8c18c4382a2d75", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -35,7 +35,7 @@ fn test_fail() {\n         &mut i, (),\n         |i, ()| {\n             *i = 10;\n-            fail!();\n+            panic!();\n         },\n         |i| {\n             assert!(failing());"}, {"sha": "98db377b0d576aa46cc18b56ca7d9714f0620070", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -373,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice_or_fail(&0, &0).iter().all(|_| fail!()));\n+    assert!(v.slice_or_fail(&0, &0).iter().all(|_| panic!()));\n }\n \n #[test]\n@@ -382,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice_or_fail(&0, &0).iter().any(|_| fail!()));\n+    assert!(!v.slice_or_fail(&0, &0).iter().any(|_| panic!()));\n }\n \n #[test]\n@@ -528,13 +528,13 @@ fn test_rposition() {\n \n #[test]\n #[should_fail]\n-fn test_rposition_fail() {\n+fn test_rposition_panic() {\n     let v = [(box 0i, box 0i), (box 0i, box 0i),\n              (box 0i, box 0i), (box 0i, box 0i)];\n     let mut i = 0i;\n     v.iter().rposition(|_elt| {\n         if i == 2 {\n-            fail!()\n+            panic!()\n         }\n         i += 1;\n         false\n@@ -678,12 +678,12 @@ fn test_random_access_cycle() {\n fn test_double_ended_range() {\n     assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n     for _ in range(10i, 0).rev() {\n-        fail!(\"unreachable\");\n+        panic!(\"unreachable\");\n     }\n \n     assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n     for _ in range(10u, 0).rev() {\n-        fail!(\"unreachable\");\n+        panic!(\"unreachable\");\n     }\n }\n "}, {"sha": "18444fc424082d4d56e4a44dd109b089b0b3733c", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -139,14 +139,14 @@ fn test_unwrap() {\n \n #[test]\n #[should_fail]\n-fn test_unwrap_fail1() {\n+fn test_unwrap_panic1() {\n     let x: Option<int> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_fail]\n-fn test_unwrap_fail2() {\n+fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();\n }\n@@ -233,7 +233,7 @@ fn test_collect() {\n     assert!(v == None);\n \n     // test that it does not take more elements than it needs\n-    let mut functions = [|| Some(()), || None, || fail!()];\n+    let mut functions = [|| Some(()), || None, || panic!()];\n \n     let v: Option<Vec<()>> = functions.iter_mut().map(|f| (*f)()).collect();\n "}, {"sha": "92124e2f299cd9c730ac793a6e468ca3ef2e8311", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -81,7 +81,7 @@ fn test_collect() {\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n-    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n+    let mut functions = [|| Ok(()), || Err(1i), || panic!()];\n \n     let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n@@ -113,7 +113,7 @@ pub fn test_unwrap_or_else() {\n         if msg == \"I got this.\" {\n             50i\n         } else {\n-            fail!(\"BadBad\")\n+            panic!(\"BadBad\")\n         }\n     }\n \n@@ -126,12 +126,12 @@ pub fn test_unwrap_or_else() {\n \n #[test]\n #[should_fail]\n-pub fn test_unwrap_or_else_failure() {\n+pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> int {\n         if msg == \"I got this.\" {\n             50i\n         } else {\n-            fail!(\"BadBad\")\n+            panic!(\"BadBad\")\n         }\n     }\n "}, {"sha": "24b7802097409cedecb09e0a0f48d5a05b5e30a5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -61,7 +61,7 @@\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n-//!         Err(f) => { fail!(f.to_string()) }\n+//!         Err(f) => { panic!(f.to_string()) }\n //!     };\n //!     if matches.opt_present(\"h\") {\n //!         print_usage(program.as_slice(), opts);\n@@ -243,7 +243,7 @@ impl OptGroup {\n         } = (*self).clone();\n \n         match (short_name.len(), long_name.len()) {\n-            (0,0) => fail!(\"this long-format option was given no name\"),\n+            (0,0) => panic!(\"this long-format option was given no name\"),\n             (0,_) => Opt {\n                 name: Long((long_name)),\n                 hasarg: hasarg,\n@@ -269,7 +269,7 @@ impl OptGroup {\n                     }\n                 )\n             },\n-            (_,_) => fail!(\"something is wrong with the long-form opt\")\n+            (_,_) => panic!(\"something is wrong with the long-form opt\")\n         }\n     }\n }\n@@ -278,7 +278,7 @@ impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n         match find_opt(self.opts.as_slice(), Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => fail!(\"No option '{}' defined\", nm)\n+            None => panic!(\"No option '{}' defined\", nm)\n         }\n     }\n \n@@ -530,8 +530,10 @@ impl fmt::Show for Fail_ {\n /// Parse command line arguments according to the provided options.\n ///\n /// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n-/// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on\n-/// failure: use the `Show` implementation of `Fail_` to display\n+/// `opt_str`, etc. to interrogate results.\n+/// # Failure\n+///\n+/// Returns `Err(Fail_)` on failure: use the `Show` implementation of `Fail_` to display\n /// information about it.\n pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n@@ -688,7 +690,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push_str(short_name.as_slice());\n                 row.push(' ');\n             }\n-            _ => fail!(\"the short name should only be 1 ascii char long\"),\n+            _ => panic!(\"the short name should only be 1 ascii char long\"),\n         }\n \n         // long option\n@@ -852,7 +854,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n \n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                            => fail!(\"word starting with {} longer than limit!\",\n+                            => panic!(\"word starting with {} longer than limit!\",\n                                     ss.slice(last_start, i + 1)),\n             (B, Cr, OverLim)  => {\n                 *cont = it(ss.slice(slice_start, last_end));\n@@ -951,7 +953,7 @@ mod tests {\n             assert!(m.opt_present(\"t\"));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => { fail!(\"test_reqopt failed (long arg)\"); }\n+          _ => { panic!(\"test_reqopt failed (long arg)\"); }\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n@@ -961,7 +963,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => { fail!(\"test_reqopt failed (short arg)\"); }\n+          _ => { panic!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n@@ -972,7 +974,7 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -983,12 +985,12 @@ mod tests {\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -999,7 +1001,7 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1016,7 +1018,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n@@ -1026,7 +1028,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1040,7 +1042,7 @@ mod tests {\n             assert!(!m.opt_present(\"test\"));\n             assert!(!m.opt_present(\"t\"));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1051,12 +1053,12 @@ mod tests {\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1067,7 +1069,7 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1082,15 +1084,15 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert!(m.opt_present(\"t\"));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert!(m.opt_present(\"t\"));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1104,7 +1106,7 @@ mod tests {\n             assert!(!m.opt_present(\"test\"));\n             assert!(!m.opt_present(\"t\"));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1117,7 +1119,7 @@ mod tests {\n           Err(f) => {\n             check_fail_type(f, UnexpectedArgument_);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1128,7 +1130,7 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1143,7 +1145,7 @@ mod tests {\n \n             assert!(m.free[0] == \"20\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1157,7 +1159,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1170,7 +1172,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1183,7 +1185,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1196,7 +1198,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1209,7 +1211,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1224,7 +1226,7 @@ mod tests {\n             assert_eq!(m.opt_count(\"verbose\"), 4);\n             assert_eq!(m.opt_count(\"v\"), 4);\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1241,7 +1243,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n@@ -1251,7 +1253,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1265,7 +1267,7 @@ mod tests {\n             assert!(!m.opt_present(\"test\"));\n             assert!(!m.opt_present(\"t\"));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1276,12 +1278,12 @@ mod tests {\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1300,7 +1302,7 @@ mod tests {\n               assert!(pair[0] == \"20\".to_string());\n               assert!(pair[1] == \"30\".to_string());\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1311,12 +1313,12 @@ mod tests {\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n         let short_args = vec!(\"-u\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1365,7 +1367,7 @@ mod tests {\n             assert!(pair[1] == \"-60 70\".to_string());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n-          _ => fail!()\n+          _ => panic!()\n         }\n     }\n \n@@ -1379,7 +1381,7 @@ mod tests {\n         let matches_single = &match getopts(args_single.as_slice(),\n                                             opts.as_slice()) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => panic!()\n         };\n         assert!(matches_single.opts_present([\"e\".to_string()]));\n         assert!(matches_single.opts_present([\"encrypt\".to_string(), \"e\".to_string()]));\n@@ -1399,7 +1401,7 @@ mod tests {\n         let matches_both = &match getopts(args_both.as_slice(),\n                                           opts.as_slice()) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => panic!()\n         };\n         assert!(matches_both.opts_present([\"e\".to_string()]));\n         assert!(matches_both.opts_present([\"encrypt\".to_string()]));\n@@ -1424,7 +1426,7 @@ mod tests {\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => panic!()\n         };\n         assert!(matches.opts_present([\"L\".to_string()]));\n         assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"foo\".to_string());\n@@ -1440,7 +1442,7 @@ mod tests {\n                      optflagmulti(\"v\", \"verbose\", \"Verbose\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n-          result::Err(e) => fail!( \"{}\", e )\n+          result::Err(e) => panic!( \"{}\", e )\n         };\n         assert!(matches.opts_present([\"L\".to_string()]));\n         assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"verbose\".to_string());"}, {"sha": "b476f46833bdb04e8df531807b4f3826a228e3cf", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -73,13 +73,13 @@ impl BasicLoop {\n             RunRemote(i) => {\n                 match self.remotes.iter_mut().find(|& &(id, _)| id == i) {\n                     Some(&(_, ref mut f)) => f.call(),\n-                    None => fail!(\"bad remote: {}\", i),\n+                    None => panic!(\"bad remote: {}\", i),\n                 }\n             }\n             RemoveRemote(i) => {\n                 match self.remotes.iter().position(|&(id, _)| id == i) {\n                     Some(i) => { self.remotes.remove(i).unwrap(); }\n-                    None => fail!(\"bad remote: {}\", i),\n+                    None => panic!(\"bad remote: {}\", i),\n                 }\n             }\n         }"}, {"sha": "2d3e85cc833f3460a4ebb4b5f30332ef4269dded", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -102,14 +102,14 @@ impl Context {\n             // Right before we switch to the new context, set the new context's\n             // stack limit in the OS-specified TLS slot. This also  means that\n             // we cannot call any more rust functions after record_stack_bounds\n-            // returns because they would all likely fail due to the limit being\n+            // returns because they would all likely panic due to the limit being\n             // invalid for the current task. Lucky for us `rust_swap_registers`\n             // is a C function so we don't have to worry about that!\n             match in_context.stack_bounds {\n                 Some((lo, hi)) => stack::record_rust_managed_stack_bounds(lo, hi),\n                 // If we're going back to one of the original contexts or\n                 // something that's possibly not a \"normal task\", then reset\n-                // the stack limit to 0 to make morestack never fail\n+                // the stack limit to 0 to make morestack never panic\n                 None => stack::record_rust_managed_stack_bounds(0, uint::MAX),\n             }\n             rust_swap_registers(out_regs, in_regs);"}, {"sha": "fcebfeac292987f4c12c24d3766a817daf0da1fa", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -168,7 +168,7 @@\n //! drop(handle);\n //!\n //! // Required to shut down this scheduler pool.\n-//! // The task will fail if `shutdown` is not called.\n+//! // The task will panic if `shutdown` is not called.\n //! pool.shutdown();\n //! # }\n //! ```\n@@ -511,7 +511,7 @@ impl TaskState {\n impl Drop for SchedPool {\n     fn drop(&mut self) {\n         if self.threads.len() > 0 {\n-            fail!(\"dropping a M:N scheduler pool that wasn't shut down\");\n+            panic!(\"dropping a M:N scheduler pool that wasn't shut down\");\n         }\n     }\n }"}, {"sha": "b1c2695ac7d276826e88774487925455a33becbb", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -761,7 +761,7 @@ impl Scheduler {\n         // task-local lock around this block. The resumption of the task in\n         // context switching will bounce on the lock, thereby waiting for this\n         // block to finish, eliminating the race mentioned above.\n-        // fail!(\"should never return!\");\n+        // panic!(\"should never return!\");\n         //\n         // To actually maintain a handle to the lock, we use an unsafe pointer\n         // to it, but we're guaranteed that the task won't exit until we've\n@@ -806,7 +806,7 @@ impl Scheduler {\n             coroutine.recycle(&mut sched.stack_pool);\n             sched.task_state.decrement();\n         });\n-        fail!(\"should never return!\");\n+        panic!(\"should never return!\");\n     }\n \n     pub fn run_task(self: Box<Scheduler>,\n@@ -1054,7 +1054,7 @@ mod test {\n                 task.put_runtime(green);\n                 return ret;\n             }\n-            None => fail!()\n+            None => panic!()\n         }\n     }\n \n@@ -1202,8 +1202,8 @@ mod test {\n                     }))) => {\n                         *id == sched_id\n                     }\n-                    TypeGreen(None) => { fail!(\"task without home\"); }\n-                    TypeSched => { fail!(\"expected green task\"); }\n+                    TypeGreen(None) => { panic!(\"task without home\"); }\n+                    TypeSched => { panic!(\"expected green task\"); }\n                 };\n                 task.put();\n                 ret"}, {"sha": "6c33e7cc619fde8c5874783ae9e0e8b5b505f732", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -67,23 +67,23 @@ impl Runtime for SimpleTask {\n         }\n     }\n \n-    // These functions are all unimplemented and fail as a result. This is on\n+    // These functions are all unimplemented and panic as a result. This is on\n     // purpose. A \"simple task\" is just that, a very simple task that can't\n     // really do a whole lot. The only purpose of the task is to get us off our\n     // feet and running.\n-    fn yield_now(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n-    fn maybe_yield(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n+    fn yield_now(self: Box<SimpleTask>, _cur_task: Box<Task>) { panic!() }\n+    fn maybe_yield(self: Box<SimpleTask>, _cur_task: Box<Task>) { panic!() }\n     fn spawn_sibling(self: Box<SimpleTask>,\n                      _cur_task: Box<Task>,\n                      _opts: TaskOpts,\n                      _f: proc():Send) {\n-        fail!()\n+        panic!()\n     }\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n-    fn stack_bounds(&self) -> (uint, uint) { fail!() }\n-    fn stack_guard(&self) -> Option<uint> { fail!() }\n+    fn stack_bounds(&self) -> (uint, uint) { panic!() }\n+    fn stack_guard(&self) -> Option<uint> { panic!() }\n     fn can_block(&self) -> bool { true }\n-    fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { fail!() }\n+    fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { panic!() }\n }\n \n pub fn task() -> Box<Task> {"}, {"sha": "7d6c82cb0c325f9c64c9b6979419a9cc83e335c2", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -24,7 +24,7 @@ pub struct Stack {\n // Try to use MAP_STACK on platforms that support it (it's what we're doing\n // anyway), but some platforms don't support it at all. For example, it appears\n // that there's a bug in freebsd that MAP_STACK implies MAP_FIXED (so it always\n-// fails): http://lists.freebsd.org/pipermail/freebsd-bugs/2011-July/044840.html\n+// panics): http://lists.freebsd.org/pipermail/freebsd-bugs/2011-July/044840.html\n //\n // DragonFly BSD also seems to suffer from the same problem. When MAP_STACK is\n // used, it returns the same `ptr` multiple times.\n@@ -37,7 +37,7 @@ static STACK_FLAGS: libc::c_int = libc::MAP_PRIVATE | libc::MAP_ANON;\n static STACK_FLAGS: libc::c_int = 0;\n \n impl Stack {\n-    /// Allocate a new stack of `size`. If size = 0, this will fail. Use\n+    /// Allocate a new stack of `size`. If size = 0, this will panic. Use\n     /// `dummy_stack` if you want a zero-sized stack.\n     pub fn new(size: uint) -> Stack {\n         // Map in a stack. Eventually we might be able to handle stack\n@@ -47,15 +47,15 @@ impl Stack {\n         let stack = match MemoryMap::new(size, [MapReadable, MapWritable,\n                                          MapNonStandardFlags(STACK_FLAGS)]) {\n             Ok(map) => map,\n-            Err(e) => fail!(\"mmap for stack of size {} failed: {}\", size, e)\n+            Err(e) => panic!(\"mmap for stack of size {} failed: {}\", size, e)\n         };\n \n         // Change the last page to be inaccessible. This is to provide safety;\n         // when an FFI function overflows it will (hopefully) hit this guard\n         // page. It isn't guaranteed, but that's why FFI is unsafe. buf.data is\n         // guaranteed to be aligned properly.\n         if !protect_last_page(&stack) {\n-            fail!(\"Could not memory-protect guard page. stack={}, errno={}\",\n+            panic!(\"Could not memory-protect guard page. stack={}, errno={}\",\n                   stack.data(), errno());\n         }\n "}, {"sha": "0c549fa66c10335752ea794950eab537384d6457", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -443,7 +443,7 @@ impl Runtime for GreenTask {\n         self.put_task(cur_task);\n \n         // First, set up a bomb which when it goes off will restore the local\n-        // task unless its disarmed. This will allow us to gracefully fail from\n+        // task unless its disarmed. This will allow us to gracefully panic from\n         // inside of `configure` which allocates a new task.\n         struct Bomb { inner: Option<Box<GreenTask>> }\n         impl Drop for Bomb {\n@@ -529,11 +529,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn smoke_fail() {\n+    fn smoke_panic() {\n         let (tx, rx) = channel::<int>();\n         spawn_opts(TaskOpts::new(), proc() {\n             let _tx = tx;\n-            fail!()\n+            panic!()\n         });\n         assert_eq!(rx.recv_opt(), Err(()));\n     }\n@@ -550,11 +550,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn smoke_opts_fail() {\n+    fn smoke_opts_panic() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        spawn_opts(opts, proc() { fail!() });\n+        spawn_opts(opts, proc() { panic!() });\n         assert!(rx.recv().is_err());\n     }\n \n@@ -597,7 +597,7 @@ mod tests {\n                     Some(ops) => {\n                         task.put_runtime(ops);\n                     }\n-                    None => fail!(),\n+                    None => panic!(),\n                 }\n                 Local::put(task);\n                 tx.send(());"}, {"sha": "832f61d8d663d6cfaabd956e03f3a2710e8bbc61", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -255,17 +255,17 @@ impl Logger for DefaultLogger {\n                        record.level,\n                        record.module_path,\n                        record.args) {\n-            Err(e) => fail!(\"failed to log: {}\", e),\n+            Err(e) => panic!(\"failed to log: {}\", e),\n             Ok(()) => {}\n         }\n     }\n }\n \n impl Drop for DefaultLogger {\n     fn drop(&mut self) {\n-        // FIXME(#12628): is failure the right thing to do?\n+        // FIXME(#12628): is panicking the right thing to do?\n         match self.handle.flush() {\n-            Err(e) => fail!(\"failed to flush a logger: {}\", e),\n+            Err(e) => panic!(\"failed to flush a logger: {}\", e),\n             Ok(()) => {}\n         }\n     }"}, {"sha": "f616295c73d1b1aafbcf7e6b61b684ea97d6e4ef", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -523,7 +523,7 @@ mod tests {\n                 assert_eq!(buf[2], 's' as u8);\n                 assert_eq!(buf[3], 't' as u8);\n             }\n-            r => fail!(\"invalid read: {}\", r)\n+            r => panic!(\"invalid read: {}\", r),\n         }\n \n         assert!(writer.inner_read(buf).is_err());\n@@ -547,7 +547,7 @@ mod tests {\n                     assert_eq!(buf[2], 's' as u8);\n                     assert_eq!(buf[3], 't' as u8);\n                 }\n-                r => fail!(\"invalid read: {}\", r)\n+                r => panic!(\"invalid read: {}\", r)\n             }\n         }\n     }"}, {"sha": "f764470f37d89051743484485c322383adb79875", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -710,7 +710,7 @@ impl UnixAcceptor {\n         if new_handle == libc::INVALID_HANDLE_VALUE {\n             let ret = Err(super::last_error());\n             // If our disconnection fails, then there's not really a whole lot\n-            // that we can do, so fail the task.\n+            // that we can do, so panic\n             let err = unsafe { libc::DisconnectNamedPipe(handle) };\n             assert!(err != 0);\n             return ret;"}, {"sha": "fed4a46b9df7fc8376e0bf6a44e0871fa337c84f", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -600,7 +600,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                             handle: ptr::null_mut()\n                         })\n                     }\n-                    Ok(..) => fail!(\"short read on the cloexec pipe\"),\n+                    Ok(..) => panic!(\"short read on the cloexec pipe\"),\n                 };\n             }\n             // And at this point we've reached a special time in the life of the\n@@ -944,7 +944,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     let mut status = 0 as c_int;\n     if deadline == 0 {\n         return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n-            -1 => fail!(\"unknown waitpid error: {}\", super::last_error().code),\n+            -1 => panic!(\"unknown waitpid error: {}\", super::last_error().code),\n             _ => Ok(translate_status(status)),\n         }\n     }\n@@ -1069,7 +1069,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n                     continue\n                 }\n \n-                n => fail!(\"error in select {} ({})\", os::errno(), n),\n+                n => panic!(\"error in select {} ({})\", os::errno(), n),\n             }\n \n             // Process any pending messages\n@@ -1149,7 +1149,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n                 n if n > 0 => { ret = true; }\n                 0 => return true,\n                 -1 if util::wouldblock() => return ret,\n-                n => fail!(\"bad read {} ({})\", os::last_os_error(), n),\n+                n => panic!(\"bad read {} ({})\", os::last_os_error(), n),\n             }\n         }\n     }\n@@ -1172,7 +1172,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n         } {\n             1 => {}\n             -1 if util::wouldblock() => {} // see above comments\n-            n => fail!(\"bad error on write fd: {} {}\", n, os::errno()),\n+            n => panic!(\"bad error on write fd: {} {}\", n, os::errno()),\n         }\n     }\n }\n@@ -1192,7 +1192,7 @@ fn waitpid_nowait(pid: pid_t) -> Option<rtio::ProcessExit> {\n         }) {\n             n if n == pid => Some(translate_status(status)),\n             0 => None,\n-            n => fail!(\"unknown waitpid error `{}`: {}\", n,\n+            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n                        super::last_error().code),\n         }\n     }"}, {"sha": "38895f2a8f96a90b56061600e70a3f6a142af893", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -194,7 +194,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             }\n \n             -1 if os::errno() == libc::EINTR as int => {}\n-            n => fail!(\"helper thread failed in select() with error: {} ({})\",\n+            n => panic!(\"helper thread panicked in select() with error: {} ({})\",\n                        n, os::last_os_error())\n         }\n     }\n@@ -227,7 +227,7 @@ impl Timer {\n         };\n         while unsafe { libc::nanosleep(&to_sleep, &mut to_sleep) } != 0 {\n             if os::errno() as int != libc::EINTR as int {\n-                fail!(\"failed to sleep, but not because of EINTR?\");\n+                panic!(\"failed to sleep, but not because of EINTR?\");\n             }\n         }\n     }"}, {"sha": "4da088cccb334e6955f9c2a2d580736fc5cef285", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -142,7 +142,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n         exit_code = Some(run(main.take().unwrap()));\n     }).destroy());\n     unsafe { rt::cleanup(); }\n-    // If the exit code wasn't set, then the task block must have failed.\n+    // If the exit code wasn't set, then the task block must have panicked.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n }\n "}, {"sha": "e702c12bdffe384cf2e7e5d38bc920c4334a152d", "filename": "src/libnative/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -297,11 +297,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn smoke_fail() {\n+    fn smoke_panic() {\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n             let _tx = tx;\n-            fail!()\n+            panic!()\n         });\n         assert_eq!(rx.recv_opt(), Err(()));\n     }\n@@ -318,11 +318,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn smoke_opts_fail() {\n+    fn smoke_opts_panic() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        NativeSpawner.spawn(opts, proc() { fail!() });\n+        NativeSpawner.spawn(opts, proc() { panic!() });\n         assert!(rx.recv().is_err());\n     }\n \n@@ -365,7 +365,7 @@ mod tests {\n                     Some(ops) => {\n                         task.put_runtime(ops);\n                     }\n-                    None => fail!(),\n+                    None => panic!(),\n                 }\n                 Local::put(task);\n                 tx.send(());"}, {"sha": "06bd04814c00b4784069f3a5abf5a5c15e8c960d", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -129,7 +129,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         for item in items.iter_mut() {\n             running_total = match running_total.checked_add(&item.weight) {\n                 Some(n) => n,\n-                None => fail!(\"WeightedChoice::new called with a total weight \\\n+                None => panic!(\"WeightedChoice::new called with a total weight \\\n                                larger than a uint can contain\")\n             };\n "}, {"sha": "405b70492a3aa4c9a0f722ca1a03cdb05aa75d17", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -92,7 +92,7 @@ pub trait Rng {\n     /// not be relied upon.\n     ///\n     /// This method should guarantee that `dest` is entirely filled\n-    /// with new data, and may fail if this is impossible\n+    /// with new data, and may panic if this is impossible\n     /// (e.g. reading past the end of a file that is being used as the\n     /// source of randomness).\n     ///\n@@ -375,7 +375,7 @@ impl Rng for XorShiftRng {\n }\n \n impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n-    /// Reseed an XorShiftRng. This will fail if `seed` is entirely 0.\n+    /// Reseed an XorShiftRng. This will panic if `seed` is entirely 0.\n     fn reseed(&mut self, seed: [u32, .. 4]) {\n         assert!(!seed.iter().all(|&x| x == 0),\n                 \"XorShiftRng.reseed called with an all zero seed.\");\n@@ -386,7 +386,7 @@ impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n         self.w = seed[3];\n     }\n \n-    /// Create a new XorShiftRng. This will fail if `seed` is entirely 0.\n+    /// Create a new XorShiftRng. This will panic if `seed` is entirely 0.\n     fn from_seed(seed: [u32, .. 4]) -> XorShiftRng {\n         assert!(!seed.iter().all(|&x| x == 0),\n                 \"XorShiftRng::from_seed called with an all zero seed.\");\n@@ -446,7 +446,7 @@ pub struct Closed01<F>(pub F);\n \n #[cfg(not(test))]\n mod std {\n-    pub use core::{option, fmt}; // fail!()\n+    pub use core::{option, fmt}; // panic!()\n }\n \n #[cfg(test)]"}, {"sha": "3410a8745b1f4a481dd705f0f38bc9893d59e74d", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -244,7 +244,7 @@ pub mod reader {\n             Some(d) => d,\n             None => {\n                 error!(\"failed to find block with tag {}\", tg);\n-                fail!();\n+                panic!();\n             }\n         }\n     }"}, {"sha": "53d2ea62a2ad060e4617ee87d8c22561fb539776", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -240,13 +240,13 @@ impl<'r> Compiler<'r> {\n     /// Sets the left and right locations of a `Split` instruction at index\n     /// `i` to `pc1` and `pc2`, respectively.\n     /// If the instruction at index `i` isn't a `Split` instruction, then\n-    /// `fail!` is called.\n+    /// `panic!` is called.\n     #[inline]\n     fn set_split(&mut self, i: InstIdx, pc1: InstIdx, pc2: InstIdx) {\n         let split = self.insts.get_mut(i);\n         match *split {\n             Split(_, _) => *split = Split(pc1, pc2),\n-            _ => fail!(\"BUG: Invalid split index.\"),\n+            _ => panic!(\"BUG: Invalid split index.\"),\n         }\n     }\n \n@@ -260,13 +260,13 @@ impl<'r> Compiler<'r> {\n \n     /// Sets the location of a `Jump` instruction at index `i` to `pc`.\n     /// If the instruction at index `i` isn't a `Jump` instruction, then\n-    /// `fail!` is called.\n+    /// `panic!` is called.\n     #[inline]\n     fn set_jump(&mut self, i: InstIdx, pc: InstIdx) {\n         let jmp = self.insts.get_mut(i);\n         match *jmp {\n             Jump(_) => *jmp = Jump(pc),\n-            _ => fail!(\"BUG: Invalid jump index.\"),\n+            _ => panic!(\"BUG: Invalid jump index.\"),\n         }\n     }\n }"}, {"sha": "691dd2a3a6ced434fb2f101c32b03213434241c7", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -31,7 +31,7 @@\n //! use regex::Regex;\n //! let re = match Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\") {\n //!     Ok(re) => re,\n-//!     Err(err) => fail!(\"{}\", err),\n+//!     Err(err) => panic!(\"{}\", err),\n //! };\n //! assert_eq!(re.is_match(\"2014-01-01\"), true);\n //! ```"}, {"sha": "e62fc3602c21609aa3a7c5167fdd73426a3d2e3c", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -117,15 +117,15 @@ impl BuildAst {\n     fn flags(&self) -> Flags {\n         match *self {\n             Paren(flags, _, _) => flags,\n-            _ => fail!(\"Cannot get flags from {}\", self),\n+            _ => panic!(\"Cannot get flags from {}\", self),\n         }\n     }\n \n     fn capture(&self) -> Option<uint> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, c, _) => Some(c),\n-            _ => fail!(\"Cannot get capture group from {}\", self),\n+            _ => panic!(\"Cannot get capture group from {}\", self),\n         }\n     }\n \n@@ -139,7 +139,7 @@ impl BuildAst {\n                     Some(name.clone())\n                 }\n             }\n-            _ => fail!(\"Cannot get capture name from {}\", self),\n+            _ => panic!(\"Cannot get capture name from {}\", self),\n         }\n     }\n \n@@ -153,7 +153,7 @@ impl BuildAst {\n     fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n             Expr(x) => Ok(x),\n-            _ => fail!(\"Tried to unwrap non-AST item: {}\", self),\n+            _ => panic!(\"Tried to unwrap non-AST item: {}\", self),\n         }\n     }\n }\n@@ -321,7 +321,7 @@ impl<'a> Parser<'a> {\n         }\n         let rep: Repeater = match c {\n             '?' => ZeroOne, '*' => ZeroMore, '+' => OneMore,\n-            _ => fail!(\"Not a valid repeater operator.\"),\n+            _ => panic!(\"Not a valid repeater operator.\"),\n         };\n \n         match self.peek(1) {\n@@ -393,7 +393,7 @@ impl<'a> Parser<'a> {\n                             continue\n                         }\n                         Some(ast) =>\n-                            fail!(\"Expected Class AST but got '{}'\", ast),\n+                            panic!(\"Expected Class AST but got '{}'\", ast),\n                         // Just drop down and try to add as a regular character.\n                         None => {},\n                     },\n@@ -408,7 +408,7 @@ impl<'a> Parser<'a> {\n                             return self.err(\n                                 \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n                                  sequences inside a character class.\"),\n-                        ast => fail!(\"Unexpected AST item '{}'\", ast),\n+                        ast => panic!(\"Unexpected AST item '{}'\", ast),\n                     }\n                 }\n                 _ => {},"}, {"sha": "d352739f853e969615e8acacfa621a11f7c67810", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -76,7 +76,7 @@ pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> {\n /// # use regex::Regex;\n /// let re = match Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\") {\n ///     Ok(re) => re,\n-///     Err(err) => fail!(\"{}\", err),\n+///     Err(err) => panic!(\"{}\", err),\n /// };\n /// assert_eq!(re.find(\"phone: 111-222-3333\"), Some((7, 19)));\n /// ```"}, {"sha": "e1c24a902fa10deb19da5f74d735c638c99ebc54", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -15,7 +15,7 @@ use stdtest::Bencher;\n use regex::{Regex, NoExpand};\n \n fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) {\n-    b.iter(|| if !re.is_match(text) { fail!(\"no match\") });\n+    b.iter(|| if !re.is_match(text) { panic!(\"no match\") });\n }\n \n #[bench]\n@@ -143,7 +143,7 @@ macro_rules! throughput(\n         fn $name(b: &mut Bencher) {\n             let text = gen_text($size);\n             b.bytes = $size;\n-            b.iter(|| if $regex.is_match(text.as_slice()) { fail!(\"match\") });\n+            b.iter(|| if $regex.is_match(text.as_slice()) { panic!(\"match\") });\n         }\n     );\n )"}, {"sha": "7f014b4eb68a699817393a27e1c59d158b1dc7be", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -30,7 +30,7 @@ macro_rules! regex(\n     ($re:expr) => (\n         match ::regex::Regex::new($re) {\n             Ok(re) => re,\n-            Err(err) => fail!(\"{}\", err),\n+            Err(err) => panic!(\"{}\", err),\n         }\n     );\n )"}, {"sha": "f93a3d51251f9c884a20cd75b8b4aacbdaa5a0d3", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -75,7 +75,7 @@ macro_rules! noparse(\n             let re = $re;\n             match Regex::new(re) {\n                 Err(_) => {},\n-                Ok(_) => fail!(\"Regex '{}' should cause a parse error.\", re),\n+                Ok(_) => panic!(\"Regex '{}' should cause a parse error.\", re),\n             }\n         }\n     );\n@@ -133,7 +133,7 @@ macro_rules! mat(\n                 sgot = sgot[0..sexpect.len()]\n             }\n             if sexpect != sgot {\n-                fail!(\"For RE '{}' against '{}', expected '{}' but got '{}'\",\n+                panic!(\"For RE '{}' against '{}', expected '{}' but got '{}'\",\n                       $re, text, sexpect, sgot);\n             }\n         }"}, {"sha": "1a53db89196b8fbdb7f79376f5006faa4476ecdb", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -85,7 +85,7 @@ struct Diagnostic {\n \n // We use an Arc instead of just returning a list of diagnostics from the\n // child task because we need to make sure that the messages are seen even\n-// if the child task fails (for example, when `fatal` is called).\n+// if the child task panics (for example, when `fatal` is called).\n #[deriving(Clone)]\n struct SharedEmitter {\n     buffer: Arc<Mutex<Vec<Diagnostic>>>,\n@@ -133,7 +133,7 @@ impl Emitter for SharedEmitter {\n \n     fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n                    _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n-        fail!(\"SharedEmitter doesn't support custom_emit\");\n+        panic!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n \n@@ -897,19 +897,19 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(future);\n     }\n \n-    let mut failed = false;\n+    let mut panicked = false;\n     for future in futures.into_iter() {\n         match future.unwrap() {\n             Ok(()) => {},\n             Err(_) => {\n-                failed = true;\n+                panicked = true;\n             },\n         }\n         // Display any new diagnostics.\n         diag_emitter.dump(sess.diagnostic().handler());\n     }\n-    if failed {\n-        sess.fatal(\"aborting due to worker thread failure\");\n+    if panicked {\n+        sess.fatal(\"aborting due to worker thread panic\");\n     }\n }\n "}, {"sha": "43687a31453d013a4fd4dd515620e24cf6703542", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -898,7 +898,7 @@ mod test {\n         let matches =\n             &match getopts([\"--test\".to_string()], optgroups().as_slice()) {\n               Ok(m) => m,\n-              Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f)\n+              Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new([]);\n         let sessopts = build_session_options(matches);\n@@ -916,7 +916,7 @@ mod test {\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {\n-                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n+                panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n               }\n             };\n         let registry = diagnostics::registry::Registry::new([]);"}, {"sha": "fbdc0db166524df8a971c43f932d0b65b9be00d4", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -269,7 +269,7 @@ Available lint options:\n             println!(\"Compiler plugins can provide additional lints and lint groups. To see a \\\n                       listing of these, re-run `rustc -W help` with a crate filename.\");\n         }\n-        (false, _, _) => fail!(\"didn't load lint plugins but got them anyway!\"),\n+        (false, _, _) => panic!(\"didn't load lint plugins but got them anyway!\"),\n         (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n         (true, l, g) => {\n             if l > 0 {\n@@ -424,7 +424,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n pub fn early_error(msg: &str) -> ! {\n     let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n     emitter.emit(None, msg, None, diagnostic::Fatal);\n-    fail!(diagnostic::FatalError);\n+    panic!(diagnostic::FatalError);\n }\n \n pub fn early_warn(msg: &str) {\n@@ -466,7 +466,7 @@ pub fn monitor(f: proc():Send) {\n     match task.try(f) {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n-            // Task failed without emitting a fatal diagnostic\n+            // Task panicked without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n                 let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n \n@@ -475,13 +475,13 @@ pub fn monitor(f: proc():Send) {\n                 if !value.is::<diagnostic::ExplicitBug>() {\n                     emitter.emit(\n                         None,\n-                        \"unexpected failure\",\n+                        \"unexpected panic\",\n                         None,\n                         diagnostic::Bug);\n                 }\n \n                 let xs = [\n-                    \"the compiler hit an unexpected failure path. this is a bug.\".to_string(),\n+                    \"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                     format!(\"we would appreciate a bug report: {}\",\n                             BUG_REPORT_URL),\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n@@ -503,11 +503,11 @@ pub fn monitor(f: proc():Send) {\n                 }\n             }\n \n-            // Fail so the process returns a failure code, but don't pollute the\n+            // Panic so the process returns a failure code, but don't pollute the\n             // output with some unnecessary failure messages, we've already\n             // printed everything that we needed to.\n             io::stdio::set_stderr(box io::util::NullWriter);\n-            fail!();\n+            panic!();\n         }\n     }\n }"}, {"sha": "0a7cfdeeadc2abb63ebd81b3755312881e3dc9be", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -444,7 +444,7 @@ pub fn pretty_print_input(sess: Session,\n             let r = io::File::create(&p);\n             match r {\n                 Ok(w) => box w as Box<Writer+'static>,\n-                Err(e) => fail!(\"print-print failed to open {} due to {}\",\n+                Err(e) => panic!(\"print-print failed to open {} due to {}\",\n                                 p.display(), e),\n             }\n         }"}, {"sha": "35754fc584ffd02d6bf6db31a2a04bf0127b75a8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -190,7 +190,7 @@ impl LintPass for TypeLimits {\n                                     return;\n                                 }\n                             }\n-                            _ => fail!()\n+                            _ => panic!()\n                         };\n                     },\n                     ty::ty_uint(t) => {\n@@ -201,7 +201,7 @@ impl LintPass for TypeLimits {\n                         let lit_val: u64 = match lit.node {\n                             ast::LitByte(_v) => return,  // _v is u8, within range by definition\n                             ast::LitInt(v, _) => v,\n-                            _ => fail!()\n+                            _ => panic!()\n                         };\n                         if  lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n@@ -216,7 +216,7 @@ impl LintPass for TypeLimits {\n                                 Some(f) => f,\n                                 None => return\n                             },\n-                            _ => fail!()\n+                            _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n@@ -237,7 +237,7 @@ impl LintPass for TypeLimits {\n                 ast::BiGt => v >= min && v <  max,\n                 ast::BiGe => v >  min && v <= max,\n                 ast::BiEq | ast::BiNe => v >= min && v <= max,\n-                _ => fail!()\n+                _ => panic!()\n             }\n         }\n \n@@ -301,7 +301,7 @@ impl LintPass for TypeLimits {\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n                             _ => return true\n                         },\n-                        _ => fail!()\n+                        _ => panic!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n@@ -312,7 +312,7 @@ impl LintPass for TypeLimits {\n                             ast::LitInt(v, _) => v,\n                             _ => return true\n                         },\n-                        _ => fail!()\n+                        _ => panic!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             def::DefTy(..) => {\n                 let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().find(&ty_id) {\n                     Some(&ty::atttce_resolved(t)) => t,\n-                    _ => fail!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                    _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {"}, {"sha": "8e4095df45a8fa5e9457f94a7bbc0e9d70507dae", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -166,7 +166,7 @@ impl LintStore {\n     fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.find_equiv(&new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n-            _ => fail!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n+            _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n     }\n@@ -388,7 +388,7 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n             format!(\"{} [-{} {}]\", msg,\n                     match level {\n                         Warn => 'W', Deny => 'D', Forbid => 'F',\n-                        Allow => fail!()\n+                        Allow => panic!()\n                     }, name.replace(\"_\", \"-\"))\n         },\n         Node(src) => {"}, {"sha": "43d0156d72770f8e080341a783936ed7334ee1c1", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -174,7 +174,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let err = |s: &str| {\n         match (sp, sess) {\n-            (_, None) => fail!(\"{}\", s),\n+            (_, None) => panic!(\"{}\", s),\n             (Some(sp), Some(sess)) => sess.span_err(sp, s),\n             (None, Some(sess)) => sess.err(s),\n         }"}, {"sha": "e9e7d1de59db38bf4fe2b6acaaebf35bc535949d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -94,7 +94,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n \n fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {\n     match maybe_find_item(item_id, items) {\n-       None => fail!(\"lookup_item: id not found: {}\", item_id),\n+       None => panic!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n@@ -153,7 +153,7 @@ fn item_family(item: rbml::Doc) -> Family {\n       'S' => Struct,\n       'g' => PublicField,\n       'N' => InheritedField,\n-       c => fail!(\"unexpected family char: {}\", c)\n+       c => panic!(\"unexpected family char: {}\", c)\n     }\n }\n \n@@ -164,7 +164,7 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n             match reader::doc_as_u8(visibility_doc) as char {\n                 'y' => ast::Public,\n                 'i' => ast::Inherited,\n-                _ => fail!(\"unknown visibility character\")\n+                _ => panic!(\"unknown visibility character\")\n             }\n         }\n     }\n@@ -707,7 +707,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n         match ch as char {\n             'i' => ast::MutImmutable,\n             'm' => ast::MutMutable,\n-            _ => fail!(\"unknown mutability character: `{}`\", ch as char),\n+            _ => panic!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n \n@@ -725,7 +725,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n                 ty::ReEmpty,\n                 get_mutability(string.as_bytes()[1]))\n         }\n-        _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n+        _ => panic!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }\n \n@@ -739,7 +739,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n         match item_sort(doc) {\n             'r' | 'p' => impl_items.push(ty::MethodTraitItemId(def_id)),\n             't' => impl_items.push(ty::TypeTraitItemId(def_id)),\n-            _ => fail!(\"unknown impl item sort\"),\n+            _ => panic!(\"unknown impl item sort\"),\n         }\n         true\n     });\n@@ -760,7 +760,7 @@ pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n         }\n         't' => (name, TypeTraitItemKind),\n         c => {\n-            fail!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n+            panic!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n                    in metadata: `{}`\", c)\n         }\n     }\n@@ -811,7 +811,7 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n                 container: container,\n             }))\n         }\n-        _ => fail!(\"unknown impl/trait item sort\"),\n+        _ => panic!(\"unknown impl/trait item sort\"),\n     }\n }\n \n@@ -825,7 +825,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n         match item_sort(mth) {\n             'r' | 'p' => result.push(ty::MethodTraitItemId(def_id)),\n             't' => result.push(ty::TypeTraitItemId(def_id)),\n-            _ => fail!(\"unknown trait item sort\"),\n+            _ => panic!(\"unknown trait item sort\"),\n         }\n         true\n     });\n@@ -937,7 +937,7 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n                 match item_family(impl_method_doc) {\n                     StaticMethod => fn_style = ast::NormalFn,\n                     UnsafeStaticMethod => fn_style = ast::UnsafeFn,\n-                    _ => fail!()\n+                    _ => panic!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n@@ -998,7 +998,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n     match family {\n       PublicField => ast::Public,\n       InheritedField => ast::Inherited,\n-      _ => fail!()\n+      _ => panic!()\n     }\n }\n \n@@ -1207,7 +1207,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n                 node: did.node,\n             }\n         }\n-        None => fail!(\"didn't find a crate in the cnum_map\")\n+        None => panic!(\"didn't find a crate in the cnum_map\")\n     }\n }\n \n@@ -1314,7 +1314,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = from_str(cnum).unwrap();\n         let cnum = match cdata.cnum_map.find(&cnum) {\n             Some(&n) => n,\n-            None => fail!(\"didn't find a crate in the cnum_map\")\n+            None => panic!(\"didn't find a crate in the cnum_map\")\n         };\n         result.push((cnum, if link == \"d\" {\n             cstore::RequireDynamic"}, {"sha": "98ce6942d4818e5fae8f6e6ec6e6d27d367af25c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -187,13 +187,13 @@ pub fn get_or_default_sysroot() -> Path {\n         path.and_then(|path|\n             match myfs::realpath(&path) {\n                 Ok(canon) => Some(canon),\n-                Err(e) => fail!(\"failed to get realpath: {}\", e),\n+                Err(e) => panic!(\"failed to get realpath: {}\", e),\n             })\n     }\n \n     match canonicalize(os::self_exe_name()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n-        None => fail!(\"can't determine value for sysroot\")\n+        None => panic!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "a52d02ccca77375e17c7a9840ebc63440d778a23", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -260,7 +260,7 @@ fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n                 parse_vec_per_param_space(\n                     st, |st| parse_region(st, |x,y| conv(x,y))))\n         }\n-        _ => fail!(\"parse_bound_region: bad input\")\n+        _ => panic!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -282,7 +282,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n             ty::BrFresh(id)\n         }\n         'e' => ty::BrEnv,\n-        _ => fail!(\"parse_bound_region: bad input\")\n+        _ => panic!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -327,15 +327,15 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n       'e' => {\n         ty::ReStatic\n       }\n-      _ => fail!(\"parse_region: bad input\")\n+      _ => panic!(\"parse_region: bad input\")\n     }\n }\n \n fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n-      _ => fail!(\"parse_opt: bad input\")\n+      _ => panic!(\"parse_opt: bad input\")\n     }\n }\n \n@@ -374,7 +374,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           'D' => return ty::mk_mach_int(ast::TyI64),\n           'f' => return ty::mk_mach_float(ast::TyF32),\n           'F' => return ty::mk_mach_float(ast::TyF64),\n-          _ => fail!(\"parse_ty: bad numeric type\")\n+          _ => panic!(\"parse_ty: bad numeric type\")\n         }\n       }\n       'c' => return ty::mk_char(),\n@@ -474,7 +474,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'e' => {\n           return ty::mk_err();\n       }\n-      c => { fail!(\"unexpected char in type string: {}\", c);}\n+      c => { panic!(\"unexpected char in type string: {}\", c);}\n     }\n }\n \n@@ -527,7 +527,7 @@ fn parse_fn_style(c: char) -> FnStyle {\n     match c {\n         'u' => UnsafeFn,\n         'n' => NormalFn,\n-        _ => fail!(\"parse_fn_style: bad fn_style {}\", c)\n+        _ => panic!(\"parse_fn_style: bad fn_style {}\", c)\n     }\n }\n \n@@ -543,7 +543,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n         'm' => ast::Many,\n-        _ => fail!(\"parse_onceness: bad onceness\")\n+        _ => panic!(\"parse_onceness: bad onceness\")\n     }\n }\n \n@@ -587,7 +587,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     let variadic = match next(st) {\n         'V' => true,\n         'N' => false,\n-        r => fail!(format!(\"bad variadic: {}\", r)),\n+        r => panic!(format!(\"bad variadic: {}\", r)),\n     };\n     let output = match peek(st) {\n         'z' => {\n@@ -609,20 +609,20 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         error!(\"didn't find ':' when parsing def id\");\n-        fail!();\n+        panic!();\n     }\n \n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => fail!(\"internal error: parse_def_id: crate number expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as ast::NodeId,\n-       None => fail!(\"internal error: parse_def_id: id expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }\n@@ -688,7 +688,7 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n                 return builtin_bounds;\n             }\n             c => {\n-                fail!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n+                panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n             }\n         }\n     }\n@@ -714,7 +714,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 return param_bounds;\n             }\n             c => {\n-                fail!(\"parse_bounds: bad bounds ('{}')\", c)\n+                panic!(\"parse_bounds: bad bounds ('{}')\", c)\n             }\n         }\n     }"}, {"sha": "f6d85a8eb018f68ccb2c746aa997148b84adac7d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -341,7 +341,7 @@ impl Folder for NestedItemsDropper {\n                             ast::DeclItem(_) => false,\n                         }\n                     }\n-                    ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n+                    ast::StmtMac(..) => panic!(\"unexpanded macro in astencode\")\n                 };\n                 if use_stmt {\n                     Some(stmt)\n@@ -795,7 +795,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                   3 => {\n                     typeck::vtable_error\n                   }\n-                  _ => fail!(\"bad enum variant\")\n+                  _ => panic!(\"bad enum variant\")\n                 })\n             })\n         }).unwrap()\n@@ -1488,7 +1488,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         }).unwrap()\n                     }\n \n-                    _ => fail!(\"..\")\n+                    _ => panic!(\"..\")\n                 })\n             })\n         }).unwrap()\n@@ -1618,7 +1618,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n                         ty::AdjustDerefRef(auto_deref_ref)\n                     }\n-                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                    _ => panic!(\"bad enum variant for ty::AutoAdjustment\")\n                 })\n             })\n         }).unwrap()\n@@ -1695,7 +1695,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n                         ty::AutoUnsafe(m, a)\n                     }\n-                    _ => fail!(\"bad enum variant for ty::AutoRef\")\n+                    _ => panic!(\"bad enum variant for ty::AutoRef\")\n                 })\n             })\n         }).unwrap()\n@@ -1736,7 +1736,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                                      substs: substs };\n                         ty::UnsizeVtable(ty_trait, self_ty)\n                     }\n-                    _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n+                    _ => panic!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })\n         }).unwrap()\n@@ -1762,7 +1762,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 0 => ty::FnUnboxedClosureKind,\n                 1 => ty::FnMutUnboxedClosureKind,\n                 2 => ty::FnOnceUnboxedClosureKind,\n-                _ => fail!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+                _ => panic!(\"bad enum variant for ty::UnboxedClosureKind\"),\n             })\n         }).unwrap();\n         ty::UnboxedClosure {\n@@ -2032,6 +2032,6 @@ fn test_simplification() {\n         assert!(pprust::item_to_string(&*item_out) ==\n                 pprust::item_to_string(&*item_exp));\n       }\n-      _ => fail!()\n+      _ => panic!()\n     }\n }"}, {"sha": "9d4d9fcf9a9d74714975ff7848e028c5940d06d7", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -133,10 +133,10 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n                                  which defines the `Drop` trait\",\n                                 b.ty.user_string(bccx.tcx)).as_slice());\n                 },\n-                _ => fail!(\"this path should not cause illegal move\")\n+                _ => panic!(\"this path should not cause illegal move\")\n             }\n         }\n-        _ => fail!(\"this path should not cause illegal move\")\n+        _ => panic!(\"this path should not cause illegal move\")\n     }\n }\n "}, {"sha": "ae8e975e843b00e4ca50f7ae1c64503775256003", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -284,9 +284,9 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n             ast::ExprProc(_, ref block) |\n             ast::ExprFnBlock(_, _, ref block) |\n             ast::ExprUnboxedFn(_, _, _, ref block) => { block.id }\n-            _ => fail!(\"encountered non-closure id: {}\", closure_id)\n+            _ => panic!(\"encountered non-closure id: {}\", closure_id)\n         },\n-        _ => fail!(\"encountered non-expr id: {}\", closure_id)\n+        _ => panic!(\"encountered non-expr id: {}\", closure_id)\n     }\n }\n "}, {"sha": "612c9a00bbef40ee0a4efe6b8e1c5aaee5d84743", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -88,7 +88,7 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n     let opt_cfgindex = index.find(&id).map(|&i|i);\n     opt_cfgindex.unwrap_or_else(|| {\n-        fail!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n+        panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n     })\n }\n "}, {"sha": "f88269ccac947fedc3583f299966cb6582837f11", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -74,7 +74,7 @@ impl Def {\n                 local_def(id)\n             }\n \n-            DefPrimTy(_) => fail!()\n+            DefPrimTy(_) => panic!()\n         }\n     }\n "}, {"sha": "08202897558fb69f13146d4e9cdbe1350cd248ec", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -264,18 +264,18 @@ lets_do_this! {\n \n     StrEqFnLangItem,                 \"str_eq\",                  str_eq_fn;\n \n-    // A number of failure-related lang items. The `fail` item corresponds to\n-    // divide-by-zero and various failure cases with `match`. The\n-    // `fail_bounds_check` item is for indexing arrays.\n+    // A number of panic-related lang items. The `panic` item corresponds to\n+    // divide-by-zero and various panic cases with `match`. The\n+    // `panic_bounds_check` item is for indexing arrays.\n     //\n     // The `begin_unwind` lang item has a predefined symbol name and is sort of\n     // a \"weak lang item\" in the sense that a crate is not required to have it\n     // defined to use it, but a final product is required to define it\n     // somewhere. Additionally, there are restrictions on crates that use a weak\n     // lang item, but do not have it defined.\n-    FailFnLangItem,                  \"fail\",                    fail_fn;\n-    FailBoundsCheckFnLangItem,       \"fail_bounds_check\",       fail_bounds_check_fn;\n-    FailFmtLangItem,                 \"fail_fmt\",                fail_fmt;\n+    PanicFnLangItem,                 \"panic\",                   panic_fn;\n+    PanicBoundsCheckFnLangItem,      \"panic_bounds_check\",      panic_bounds_check_fn;\n+    PanicFmtLangItem,                \"panic_fmt\",               panic_fmt;\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;"}, {"sha": "f9810120d211b6bbb6bd9d342f68454e890381da", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -93,7 +93,7 @@\n  * These are described in the `specials` struct:\n  *\n  * - `exit_ln`: a live node that is generated to represent every 'exit' from\n- *   the function, whether it be by explicit return, fail, or other means.\n+ *   the function, whether it be by explicit return, panic, or other means.\n  *\n  * - `fallthrough_ln`: a live node that represents a fallthrough\n  *\n@@ -400,7 +400,7 @@ fn visit_fn(ir: &mut IrMaps,\n     visit::walk_fn(&mut fn_maps, fk, decl, body, sp);\n \n     // Special nodes and variables:\n-    // - exit_ln represents the end of the fn, either by return or fail\n+    // - exit_ln represents the end of the fn, either by return or panic\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n     let specials = Specials {"}, {"sha": "32e373f5851c069cc678129e8ef297a4b307ab74", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -157,7 +157,7 @@ impl RegionMaps {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         match self.scope_map.borrow().find(&id) {\n             Some(&r) => r,\n-            None => { fail!(\"no enclosing scope for id {}\", id); }\n+            None => { panic!(\"no enclosing scope for id {}\", id); }\n         }\n     }\n \n@@ -167,7 +167,7 @@ impl RegionMaps {\n          */\n         match self.var_map.borrow().find(&var_id) {\n             Some(&r) => r,\n-            None => { fail!(\"no enclosing scope for id {}\", var_id); }\n+            None => { panic!(\"no enclosing scope for id {}\", var_id); }\n         }\n     }\n "}, {"sha": "7af4739d409156b3b6b1d6ec58f315758aee369e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -728,7 +728,7 @@ impl NameBindings {\n     fn get_module(&self) -> Rc<Module> {\n         match self.get_module_if_available() {\n             None => {\n-                fail!(\"get_module called on a node with no module \\\n+                panic!(\"get_module called on a node with no module \\\n                        definition!\")\n             }\n             Some(module_def) => module_def\n@@ -1910,7 +1910,7 @@ impl<'a> Resolver<'a> {\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            fail!(\"didn't expect `{}`\", def);\n+            panic!(\"didn't expect `{}`\", def);\n           }\n         }\n     }\n@@ -2618,7 +2618,7 @@ impl<'a> Resolver<'a> {\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"value result should be known at this point\");\n+                panic!(\"value result should be known at this point\");\n             }\n         }\n         match type_result {\n@@ -2641,7 +2641,7 @@ impl<'a> Resolver<'a> {\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"type result should be known at this point\");\n+                panic!(\"type result should be known at this point\");\n             }\n         }\n \n@@ -5161,7 +5161,7 @@ impl<'a> Resolver<'a> {\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n                     None => {\n-                        fail!(\"resolved name in the value namespace to a \\\n+                        panic!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");\n                     }\n                     Some(def) => {\n@@ -5191,7 +5191,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                panic!(\"unexpected indeterminate result\");\n             }\n             Failed(err) => {\n                 match err {\n@@ -5389,7 +5389,7 @@ impl<'a> Resolver<'a> {\n                                                  msg.as_slice()));\n                 return None;\n             }\n-            Indeterminate => fail!(\"indeterminate unexpected\"),\n+            Indeterminate => panic!(\"indeterminate unexpected\"),\n             Success((resulting_module, resulting_last_private)) => {\n                 containing_module = resulting_module;\n                 last_private = resulting_last_private;\n@@ -5451,7 +5451,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                panic!(\"indeterminate unexpected\");\n             }\n \n             Success((resulting_module, resulting_last_private)) => {\n@@ -5537,7 +5537,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                panic!(\"unexpected indeterminate result\");\n             }\n             Failed(err) => {\n                 match err {\n@@ -6155,7 +6155,7 @@ impl<'a> Resolver<'a> {\n                 type_used: _\n             }) => (v, t),\n             Some(_) => {\n-                fail!(\"we should only have LastImport for `use` directives\")\n+                panic!(\"we should only have LastImport for `use` directives\")\n             }\n             _ => return,\n         };"}, {"sha": "b986d4dd591f382c80198502dc3b925c90a382e2", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -177,7 +177,7 @@ impl Substs {\n          */\n \n         match self.regions {\n-            ErasedRegions => fail!(\"Erased regions only expected in trans\"),\n+            ErasedRegions => panic!(\"Erased regions only expected in trans\"),\n             NonerasedRegions(ref r) => r\n         }\n     }\n@@ -190,7 +190,7 @@ impl Substs {\n          */\n \n         match self.regions {\n-            ErasedRegions => fail!(\"Erased regions only expected in trans\"),\n+            ErasedRegions => panic!(\"Erased regions only expected in trans\"),\n             NonerasedRegions(ref mut r) => r\n         }\n     }\n@@ -249,7 +249,7 @@ impl ParamSpace {\n             0 => TypeSpace,\n             1 => SelfSpace,\n             2 => FnSpace,\n-            _ => fail!(\"Invalid ParamSpace: {}\", u)\n+            _ => panic!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n }"}, {"sha": "f53b5331eddeb7a2624abc37ff50571272f9745f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -235,7 +235,7 @@ impl<'a> ConstantExpr<'a> {\n         let ConstantExpr(other_expr) = other;\n         match const_eval::compare_lit_exprs(tcx, expr, other_expr) {\n             Some(val1) => val1 == 0,\n-            None => fail!(\"compare_list_exprs: type mismatch\"),\n+            None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -734,7 +734,7 @@ impl FailureHandler {\n     fn handle_fail(&self, bcx: Block) {\n         match *self {\n             Infallible =>\n-                fail!(\"attempted to fail in an infallible failure handler!\"),\n+                panic!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n                 Br(bcx, basic_block),\n             Unreachable =>"}, {"sha": "1f737cae86f9241e679b8369fcb09fc0c191f84f", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -586,7 +586,7 @@ fn generic_type_of(cx: &CrateContext,\n                                  Type::array(&Type::i64(cx), align_units),\n                 a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n-                _ => fail!(\"unsupported enum alignment: {}\", align)\n+                _ => panic!(\"unsupported enum alignment: {}\", align)\n             };\n             assert_eq!(machine::llalign_of_min(cx, pad_ty), align);\n             assert_eq!(align_s % discr_size, 0);"}, {"sha": "ae8f944cab100d9dbc07d44e6a65b0c8f6e4d3cf", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -291,7 +291,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n              RustCall,\n              Some(llenvironment_type))\n         }\n-        _ => fail!(\"expected closure or fn\")\n+        _ => panic!(\"expected closure or fn\")\n     };\n \n     let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n@@ -2349,7 +2349,7 @@ fn register_fn(ccx: &CrateContext,\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n         }\n-        _ => fail!(\"expected bare rust fn\")\n+        _ => panic!(\"expected bare rust fn\")\n     };\n \n     let llfn = decl_rust_fn(ccx, node_type, sym.as_slice());\n@@ -2744,7 +2744,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     llfn\n                 }\n \n-                _ => fail!(\"get_item_val: weird result in table\")\n+                _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n             match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n@@ -2811,7 +2811,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let args = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => args,\n                 ast::StructVariantKind(_) => {\n-                    fail!(\"struct variant kind unexpected in get_item_val\")\n+                    panic!(\"struct variant kind unexpected in get_item_val\")\n                 }\n             };\n             assert!(args.len() != 0u);\n@@ -2827,7 +2827,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::ItemEnum(_, _) => {\n                     register_fn(ccx, (*v).span, sym, id, ty)\n                 }\n-                _ => fail!(\"NodeVariant, shouldn't happen\")\n+                _ => panic!(\"NodeVariant, shouldn't happen\")\n             };\n             set_inline_hint(llfn);\n             llfn"}, {"sha": "895f03ec2c79de7ccb4f9625c739d44d8e497a5b", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -30,7 +30,7 @@ pub fn terminate(cx: Block, _: &str) {\n \n pub fn check_not_terminated(cx: Block) {\n     if cx.terminated.get() {\n-        fail!(\"already terminated!\");\n+        panic!(\"already terminated!\");\n     }\n }\n \n@@ -45,7 +45,7 @@ pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n // terminated, we're saying that trying to add any further statements in the\n // block is an error. On the other hand, if something is unreachable, that\n // means that the block was terminated in some way that we don't want to check\n-// for (fail/break/return statements, call to diverging functions, etc), and\n+// for (panic/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n pub fn RetVoid(cx: Block) {"}, {"sha": "d8cf8dbb7959f3331a19d55601b7238f479819c1", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -50,7 +50,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_align: unhandled type\")\n+        _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -80,7 +80,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "9f51e153a0fc9baa54ceda10187f611d641bbe80", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -50,7 +50,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -80,7 +80,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "54fd20ff995b5b04ff3eb1c92eb80f0f738ca7f9", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -111,7 +111,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let elt = ty.element_type();\n                 ty_align(elt)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => panic!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -140,7 +140,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => panic!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -235,7 +235,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     i += 1u;\n                 }\n             }\n-            _ => fail!(\"classify: unhandled type\")\n+            _ => panic!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -328,7 +328,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64(ccx));\n             }\n-            _ => fail!(\"llregtype: unhandled class\")\n+            _ => panic!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }"}, {"sha": "1f4a0dadc0209e20f2c19729b419997482b28c17", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -689,9 +689,9 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n-    // this cleanup is to ensure that, should a failure occur while\n+    // this cleanup is to ensure that, should a panic occur while\n     // evaluating argument N, the values for arguments 0...N-1 are all\n-    // cleaned up. If no failure occurs, the values are handed off to\n+    // cleaned up. If no panic occurs, the values are handed off to\n     // the callee, and hence none of the cleanups in this temporary\n     // scope will ever execute.\n     let fcx = bcx.fcx;\n@@ -704,7 +704,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let (abi, ret_ty) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n         ty::ty_closure(ref f) => (f.abi, f.sig.output),\n-        _ => fail!(\"expected bare rust fn or closure in trans_call_inner\")\n+        _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n     let (llfn, llenv, llself) = match callee.data {\n@@ -847,7 +847,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n-            _ => fail!(\"expected arg exprs.\")\n+            _ => panic!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n                          args,\n@@ -1141,7 +1141,7 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx, arg_datum.to_appropriate_datum(bcx));\n \n             // Technically, ownership of val passes to the callee.\n-            // However, we must cleanup should we fail before the\n+            // However, we must cleanup should we panic before the\n             // callee is actually invoked.\n             val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n         }"}, {"sha": "e5825d7a38f1538988cdda83f51eaa2adfd7982f", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -477,16 +477,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn needs_invoke(&self) -> bool {\n         /*!\n          * Returns true if there are pending cleanups that should\n-         * execute on failure.\n+         * execute on panic.\n          */\n \n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n     fn get_landing_pad(&'blk self) -> BasicBlockRef {\n         /*!\n-         * Returns a basic block to branch to in the event of a failure.\n-         * This block will run the failure cleanups and eventually\n+         * Returns a basic block to branch to in the event of a panic.\n+         * This block will run the panic cleanups and eventually\n          * invoke the LLVM `Resume` instruction.\n          */\n \n@@ -497,7 +497,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         let orig_scopes_len = self.scopes_len();\n         assert!(orig_scopes_len > 0);\n \n-        // Remove any scopes that do not have cleanups on failure:\n+        // Remove any scopes that do not have cleanups on panic:\n         let mut popped_scopes = vec!();\n         while !self.top_scope(|s| s.needs_invoke()) {\n             debug!(\"top scope does not need invoke\");"}, {"sha": "60b107c049f412c9cefa031ca3882de4eb623b81", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -603,7 +603,7 @@ pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n     match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n         32 => assert!(v < (1<<31) && v >= -(1<<31)),\n         64 => {},\n-        n => fail!(\"unsupported target size: {}\", n)\n+        n => panic!(\"unsupported target size: {}\", n)\n     }\n \n     C_integral(ccx.int_type(), v as u64, true)\n@@ -615,7 +615,7 @@ pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n     match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n         32 => assert!(v < (1<<32)),\n         64 => {},\n-        n => fail!(\"unsupported target size: {}\", n)\n+        n => panic!(\"unsupported target size: {}\", n)\n     }\n \n     C_integral(ccx.int_type(), v, false)"}, {"sha": "955fcbfab842f93655bb3e3b748b4ee04f4c3d9b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -453,7 +453,7 @@ impl LocalCrateContext {\n     /// Create a dummy `CrateContext` from `self` and  the provided\n     /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n     /// not actually be an element of `shared.local_ccxs`, which can cause some\n-    /// operations to `fail` unexpectedly.\n+    /// operations to panic unexpectedly.\n     ///\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n@@ -527,7 +527,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n         match declare_intrinsic(self, key) {\n             Some(v) => return v,\n-            None => fail!()\n+            None => panic!()\n         }\n     }\n "}, {"sha": "013483d0003c31e5ca4c43a5181afeffd286e819", "filename": "src/librustc/middle/trans/doc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -132,7 +132,7 @@ cleanup arranged, and the slot from `rvalue_scratch_datum` does not.\n ## The Cleanup module\n \n The cleanup module tracks what values need to be cleaned up as scopes\n-are exited, either via failure or just normal control flow. The basic\n+are exited, either via panic or just normal control flow. The basic\n idea is that the function context maintains a stack of cleanup scopes\n that are pushed/popped as we traverse the AST tree. There is typically\n at least one cleanup scope per AST node; some AST nodes may introduce\n@@ -142,9 +142,9 @@ Cleanup items can be scheduled into any of the scopes on the stack.\n Typically, when a scope is popped, we will also generate the code for\n each of its cleanups at that time. This corresponds to a normal exit\n from a block (for example, an expression completing evaluation\n-successfully without failure). However, it is also possible to pop a\n+successfully without panic). However, it is also possible to pop a\n block *without* executing its cleanups; this is typically used to\n-guard intermediate values that must be cleaned up on failure, but not\n+guard intermediate values that must be cleaned up on panic, but not\n if everything goes right. See the section on custom scopes below for\n more details.\n \n@@ -170,21 +170,21 @@ drop uninitialized memory. If the initialization itself produces\n byproducts that need to be freed, then you should use temporary custom\n scopes to ensure that those byproducts will get freed on unwind.  For\n example, an expression like `box foo()` will first allocate a box in the\n-heap and then call `foo()` -- if `foo()` should fail, this box needs\n+heap and then call `foo()` -- if `foo()` should panic, this box needs\n to be *shallowly* freed.\n \n ### Long-distance jumps\n \n In addition to popping a scope, which corresponds to normal control\n flow exiting the scope, we may also *jump out* of a scope into some\n earlier scope on the stack. This can occur in response to a `return`,\n-`break`, or `continue` statement, but also in response to failure. In\n+`break`, or `continue` statement, but also in response to panic. In\n any of these cases, we will generate a series of cleanup blocks for\n each of the scopes that is exited. So, if the stack contains scopes A\n ... Z, and we break out of a loop whose corresponding cleanup scope is\n X, we would generate cleanup blocks for the cleanups in X, Y, and Z.\n After cleanup is done we would branch to the exit point for scope X.\n-But if failure should occur, we would generate cleanups for all the\n+But if panic should occur, we would generate cleanups for all the\n scopes from A to Z and then resume the unwind process afterwards.\n \n To avoid generating tons of code, we cache the cleanup blocks that we\n@@ -211,7 +211,7 @@ the basic blocks where control should flow after a \"continue\" or\n \n Custom cleanup scopes are used for a variety of purposes. The most\n common though is to handle temporary byproducts, where cleanup only\n-needs to occur on failure. The general strategy is to push a custom\n+needs to occur on panic. The general strategy is to push a custom\n cleanup scope, schedule *shallow* cleanups into the custom scope, and\n then pop the custom scope (without transing the cleanups) when\n execution succeeds normally. This way the cleanups are only trans'd on\n@@ -229,7 +229,7 @@ We would basically:\n 5. Pop the scope C.\n 6. Return the box as an rvalue.\n \n-This way, if a failure occurs while transing `expr`, the custom\n+This way, if a panic occurs while transing `expr`, the custom\n cleanup scope C is pushed and hence the box will be freed. The trans\n code for `expr` itself is responsible for freeing any other byproducts\n that may be in play."}, {"sha": "4d004c85f6e5f1ce47b3c93e23bef00d0a8426cd", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1263,7 +1263,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n      * Helper for enumerating the field types of structs, enums, or records.\n      * The optional node ID here is the node ID of the path identifying the enum\n      * variant in use. If none, this cannot possibly an enum variant (so, if it\n-     * is and `node_id_opt` is none, this function fails).\n+     * is and `node_id_opt` is none, this function panics).\n      */\n \n     match ty::get(ty).sty {\n@@ -1421,7 +1421,7 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     // This scope holds intermediates that must be cleaned should\n-    // failure occur before the ADT as a whole is ready.\n+    // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n     // First we trans the base, if we have one, to the dest"}, {"sha": "d979024c1607666be5405e8c52e19bb063402913", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -551,7 +551,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let c = llvm_calling_convention(ccx, fn_ty.abi);\n             c.unwrap_or(llvm::CCallConv)\n         }\n-        _ => fail!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n+        _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n     let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil()));\n     add_argument_attributes(&tys, llfn);\n@@ -575,7 +575,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let c = llvm_calling_convention(ccx, fn_ty.abi);\n             c.unwrap_or(llvm::CCallConv)\n         }\n-        _ => fail!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n+        _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n     };\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);"}, {"sha": "fb85e6198666726d1bad7c346059f782b86e8ba0", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -244,7 +244,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n         // Be sure to put all of the fields into a scope so we can use an invoke\n         // instruction to call the user destructor but still call the field\n-        // destructors if the user destructor fails.\n+        // destructors if the user destructor panics.\n         let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n \n         // Class dtors have no explicit args, so the params should"}, {"sha": "2455970b6a64d37616734e4056192ca85ca66100", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -147,7 +147,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n \n     let ret_ty = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref f) => f.sig.output,\n-        _ => fail!(\"expected bare_fn in trans_intrinsic_call\")\n+        _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);\n     let name = token::get_ident(foreign_item.ident);"}, {"sha": "db433167298cea8db4b8a8a13174c861122c0c1f", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -193,7 +193,7 @@ pub fn trans_static_method_callee(bcx: Block,\n                 };\n                 ident.name\n             }\n-            _ => fail!(\"callee is not a trait method\")\n+            _ => panic!(\"callee is not a trait method\")\n         }\n     } else {\n         csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()"}, {"sha": "5c8287c0030d43b804c9ce75e4e1940055f1bade", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -315,7 +315,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         return bcx;\n                     }\n \n-                    // Some cleanup would be required in the case in which failure happens\n+                    // Some cleanup would be required in the case in which panic happens\n                     // during a copy. But given that copy constructors are not overridable,\n                     // this can only happen as a result of OOM. So we just skip out on the\n                     // cleanup since things would *probably* be broken at that point anyways."}, {"sha": "f08fd20314a6635fc99d326bb541f6da57c04445", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -308,7 +308,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => fail!(\"llvm_float_width called on a non-float type\")\n+            _ => panic!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n }"}, {"sha": "649dbbacc698447789e7e9de9fd8d9b31ec8e480", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -237,7 +237,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n-        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n+        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n@@ -266,7 +266,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         match ty::get(ty::unsized_part_of_type(cx.tcx(), t)).sty {\n             ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n-            _ => fail!(\"Unexpected type returned from unsized_part_of_type : {}\",\n+            _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n                        t.repr(cx.tcx()))\n         }\n     }"}, {"sha": "edb67f7fddf8b3f971dd7538964dbf0f11b27204", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -2083,7 +2083,7 @@ pub fn simd_type(cx: &ctxt, ty: t) -> t {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n-        _ => fail!(\"simd_type called on invalid type\")\n+        _ => panic!(\"simd_type called on invalid type\")\n     }\n }\n \n@@ -2093,7 +2093,7 @@ pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n         }\n-        _ => fail!(\"simd_size called on invalid type\")\n+        _ => panic!(\"simd_size called on invalid type\")\n     }\n }\n \n@@ -2564,7 +2564,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 // the current crate; therefore, the only type parameters that\n                 // could be in scope are those defined in the current crate.\n                 // If this assertion fails, it is likely because of a\n-                // failure in the cross-crate inlining code to translate a\n+                // failure of the cross-crate inlining code to translate a\n                 // def-id.\n                 assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n \n@@ -3097,7 +3097,7 @@ pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n         _ => {\n             assert!(type_is_sized(cx, ty),\n                     \"unsized_part_of_type failed even though ty is unsized\");\n-            fail!(\"called unsized_part_of_type with sized ty\");\n+            panic!(\"called unsized_part_of_type with sized ty\");\n         }\n     }\n }\n@@ -3229,7 +3229,7 @@ pub fn fn_is_variadic(fty: t) -> bool {\n         ty_bare_fn(ref f) => f.sig.variadic,\n         ty_closure(ref f) => f.sig.variadic,\n         ref s => {\n-            fail!(\"fn_is_variadic() called on non-fn type: {}\", s)\n+            panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3239,7 +3239,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail!(\"ty_fn_sig() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_sig() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3249,7 +3249,7 @@ pub fn ty_fn_abi(fty: t) -> abi::Abi {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.abi,\n         ty_closure(ref f) => f.abi,\n-        _ => fail!(\"ty_fn_abi() called on non-fn type\"),\n+        _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n     }\n }\n \n@@ -3259,7 +3259,7 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail!(\"ty_fn_args() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_args() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3273,7 +3273,7 @@ pub fn ty_closure_store(fty: t) -> TraitStore {\n             UniqTraitStore\n         }\n         ref s => {\n-            fail!(\"ty_closure_store() called on non-closure type: {}\", s)\n+            panic!(\"ty_closure_store() called on non-closure type: {}\", s)\n         }\n     }\n }\n@@ -3283,7 +3283,7 @@ pub fn ty_fn_ret(fty: t) -> FnOutput {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail!(\"ty_fn_ret() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3735,7 +3735,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // Special case `Box<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n-                None => fail!(\"no def for place\"),\n+                None => panic!(\"no def for place\"),\n             };\n             let def_id = definition.def_id();\n             if tcx.lang_items.exchange_heap() == Some(def_id) {\n@@ -3760,7 +3760,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n       ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::StmtMac(..) => fail!(\"unexpanded macro in trans\")\n+      ast::StmtMac(..) => panic!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -4068,7 +4068,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.krate == ast::LOCAL_CRATE {\n-        fail!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n+        panic!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());"}, {"sha": "da1e7e24571a6e45552b8bb151455b59d3324b5d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -937,7 +937,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                     tcx.map.node_to_string(id.node)).as_slice());\n                     }\n                     def::DefPrimTy(_) => {\n-                        fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n+                        panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     def::DefAssociatedTy(trait_type_id) => {\n                         let path_str = tcx.map.path_to_string("}, {"sha": "97c6cf24f0e1900a31efa8ab15699897dbae3b0c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -259,7 +259,7 @@ pub fn check_match(fcx: &FnCtxt,\n     // bottom the type lattice, and we'll be moving up the lattice as\n     // we process each arm. (Note that any match with 0 arms is matching\n     // on any empty type and is therefore unreachable; should the flow\n-    // of execution reach it, we will fail, so bottom is an appropriate\n+    // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n     let result_ty = arms.iter().fold(fcx.infcx().next_diverging_ty_var(), |result_ty, arm| {\n         check_expr(fcx, &*arm.body);"}, {"sha": "7527160c825ae17cc7f7229e50ef23069ef9a59a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -916,7 +916,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             // FIXME(#6129). Default methods can't deal with autoref.\n             //\n             // I am a horrible monster and I pray for death. Currently\n-            // the default method code fails when you try to reborrow\n+            // the default method code panics when you try to reborrow\n             // because it is not handling types correctly. In lieu of\n             // fixing that, I am introducing this horrible hack. - ndm\n             self_mt.mutbl == MutImmutable && ty::type_is_self(self_mt.ty)\n@@ -1034,7 +1034,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                         ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n                     })\n             }\n-            _ => fail!(\"Expected ty_trait in auto_slice_trait\")\n+            _ => panic!(\"Expected ty_trait in auto_slice_trait\")\n         }\n     }\n \n@@ -1767,7 +1767,7 @@ impl Candidate {\n                 ImplSource(def_id)\n             }\n             MethodStaticUnboxedClosure(..) => {\n-                fail!(\"MethodStaticUnboxedClosure only used in trans\")\n+                panic!(\"MethodStaticUnboxedClosure only used in trans\")\n             }\n             MethodTypeParam(ref param) => {\n                 TraitSource(param.trait_ref.def_id)"}, {"sha": "a5624dcc2fcd3f9b503d2579d4663e60d4eed690", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -100,7 +100,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     fn object_trait<'a>(t: &'a ty::t) -> &'a ty::TyTrait {\n         match ty::get(*t).sty {\n             ty::ty_trait(ref ty_trait) => &**ty_trait,\n-            _ => fail!(\"expected ty_trait\")\n+            _ => panic!(\"expected ty_trait\")\n         }\n     }\n "}, {"sha": "a569053507cf88ff96d8ef7ef565e70e066177a2", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -90,7 +90,7 @@ fn get_base_type(inference_context: &InferCtxt,\n                    get(original_type).sty);\n             None\n         }\n-        ty_trait(..) => fail!(\"should have been caught\")\n+        ty_trait(..) => panic!(\"should have been caught\")\n     }\n }\n \n@@ -116,7 +116,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                             Some(def_id)\n                         }\n                         _ => {\n-                            fail!(\"get_base_type() returned a type that wasn't an \\\n+                            panic!(\"get_base_type() returned a type that wasn't an \\\n                                    enum, struct, or trait\");\n                         }\n                     }\n@@ -125,7 +125,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                     Some(def_id)\n                 }\n                 _ => {\n-                    fail!(\"get_base_type() returned a type that wasn't an \\\n+                    panic!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");\n                 }\n             }"}, {"sha": "847d8e88bde88b25c8a5fed7e14e631e15777dfc", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1593,7 +1593,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return pty;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n-        ast::ItemForeignMod(_) | ast::ItemMac(_) => fail!(),\n+        ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }\n }\n "}, {"sha": "fbf2918c2921af615a48b22314310b3b45e54290", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -210,7 +210,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n \n             // NB---I do not believe this algorithm computes\n             // (necessarily) the GLB.  As written it can\n-            // spuriously fail.  In particular, if there is a case\n+            // spuriously fail. In particular, if there is a case\n             // like: |fn(&a)| and fn(fn(&b)), where a and b are\n             // free, it will return fn(&c) where c = GLB(a,b).  If\n             // however this GLB is not defined, then the result is"}, {"sha": "d2a77f906b5356954a205746c63f69599369e59d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -603,7 +603,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.commit_unconditionally(|| self.try(|| f()))\n     }\n \n-    /// Execute `f`, unroll bindings on failure\n+    /// Execute `f`, unroll bindings on panic\n     pub fn try<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();"}, {"sha": "80213d43ec4378a43e7eee7058e6e97c009ae875", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         while undo_log.len() > snapshot.length + 1 {\n             match undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n-                    fail!(\"Failure to observe stack discipline\");\n+                    panic!(\"Failure to observe stack discipline\");\n                 }\n                 Mark | CommitedSnapshot => { }\n                 AddVar(vid) => {\n@@ -916,7 +916,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n-        // it.  Otherwise fail.\n+        // it. Otherwise fail.\n         debug!(\"intersect_scopes(scope_a={}, scope_b={}, region_a={}, region_b={})\",\n                scope_a, scope_b, region_a, region_b);\n         match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {"}, {"sha": "5b1ee7c64b4a37c7ffe8ca8160b8ea896b4380f8", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -67,7 +67,7 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n             e.messages.remove(i);\n         }\n         None => {\n-            fail!(\"Unexpected error: {} Expected: {}\",\n+            panic!(\"Unexpected error: {} Expected: {}\",\n                   msg, e.messages);\n         }\n     }\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail!(\"no item found: `{}`\", names.connect(\"::\"));\n+                panic!(\"no item found: `{}`\", names.connect(\"::\"));\n             }\n         };\n \n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_subtype(&self, a: ty::t, b: ty::t) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n-            Err(ref e) => fail!(\"Encountered error: {}\",\n+            Err(ref e) => panic!(\"Encountered error: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n@@ -232,15 +232,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail!(\"{} is not a subtype of {}, but it should be\",\n+            panic!(\"{} is not a subtype of {}, but it should be\",\n                   self.ty_to_string(a),\n                   self.ty_to_string(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail!(\"{} is a subtype of {}, but it shouldn't be\",\n+            panic!(\"{} is a subtype of {}, but it shouldn't be\",\n                   self.ty_to_string(a),\n                   self.ty_to_string(b));\n         }\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n-            Err(ref e) => fail!(\"unexpected error computing LUB: {}\",\n+            Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n-                fail!(\"unexpected error in LUB: {}\",\n+                panic!(\"unexpected error in LUB: {}\",\n                       ty::type_err_to_str(self.infcx.tcx, e))\n             }\n         }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"unexpected error computing LUB: {}\", e)\n+                panic!(\"unexpected error computing LUB: {}\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing LUB: {}\", self.ty_to_string(t))\n+                panic!(\"unexpected success computing LUB: {}\", self.ty_to_string(t))\n             }\n         }\n     }\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing GLB: {}\", self.ty_to_string(t))\n+                panic!(\"unexpected success computing GLB: {}\", self.ty_to_string(t))\n             }\n         }\n     }"}, {"sha": "63094ceaabdf962e701ad0e08f5cbfbf3a0301aa", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -102,7 +102,7 @@ impl TypeVariableTable {\n \n         let relations = match old_value {\n             Bounded(b) => b,\n-            Known(_) => fail!(\"Asked to instantiate variable that is \\\n+            Known(_) => panic!(\"Asked to instantiate variable that is \\\n                                already instantiated\")\n         };\n \n@@ -172,7 +172,7 @@ impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n \n fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n     match v.value {\n-        Known(_) => fail!(\"var_sub_var: variable is known\"),\n+        Known(_) => panic!(\"var_sub_var: variable is known\"),\n         Bounded(ref mut relations) => relations\n     }\n }"}, {"sha": "d93e985190cffccacc7a5afa3eaa3b962cda4571", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -245,7 +245,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n \n impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n     fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n-        fail!(\"Nothing to reverse\");\n+        panic!(\"Nothing to reverse\");\n     }\n }\n "}, {"sha": "c8214a743de73338245a17712afef8daa64db50a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match tcx.named_region_map.find(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n-            Some(_) => fail!(\"should not encounter non early-bound cases\"),\n+            Some(_) => panic!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is\n             // itself a lifetime binding: use it as the decl_id.\n@@ -597,11 +597,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             assert!(is_lifetime(&tcx.map, param_id));\n             let parent_id = tcx.map.get_parent(decl_id);\n             let parent = tcx.map.find(parent_id).unwrap_or_else(\n-                || fail!(\"tcx.map missing entry for id: {}\", parent_id));\n+                || panic!(\"tcx.map missing entry for id: {}\", parent_id));\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n-                fail!(\"invalid parent: {:s} for {:s}\",\n+                panic!(\"invalid parent: {:s} for {:s}\",\n                       tcx.map.node_to_string(parent_id),\n                       tcx.map.node_to_string(param_id));\n             } } }"}, {"sha": "e107ac73d79953abada2ca9709972f0e667582de", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n ) )\n \n weak_lang_items!(\n-    fail_fmt,           FailFmtLangItem,            rust_begin_unwind;\n+    panic_fmt,          PanicFmtLangItem,            rust_begin_unwind;\n     stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n )"}, {"sha": "99e870a901e0893240a9acb87a6ccf4559d041f4", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -64,7 +64,7 @@ impl Registry {\n             Decorator(ext) => Decorator(ext),\n             Modifier(ext) => Modifier(ext),\n             // there's probably a nicer way to signal this:\n-            LetSyntaxTT(_, _) => fail!(\"can't register a new LetSyntax!\"),\n+            LetSyntaxTT(_, _) => panic!(\"can't register a new LetSyntax!\"),\n         }));\n     }\n "}, {"sha": "8885d86d4da3637602e8d9372dd77ed342039fe4", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -148,7 +148,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n             match self.undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n                     // This indicates a failure to obey the stack discipline.\n-                    fail!(\"Cannot rollback an uncommitted snapshot\");\n+                    panic!(\"Cannot rollback an uncommitted snapshot\");\n                 }\n \n                 CommittedSnapshot => {"}, {"sha": "2e58a8dab3b3905289a3ee4b96f50e292f2b6f99", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -91,7 +91,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             handler.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n                              e).as_slice());\n             handler.abort_if_errors();\n-            fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n+            panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n     }\n }"}, {"sha": "4c62ba54ac427c00e1ac3ee7ef060ded5ec8dda6", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -206,7 +206,7 @@ mod test {\n             os: abi::OsLinux,\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || fail!(),\n+            get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n@@ -220,7 +220,7 @@ mod test {\n             os: abi::OsFreebsd,\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || fail!(),\n+            get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n@@ -234,7 +234,7 @@ mod test {\n             os: abi::OsDragonfly,\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || fail!(),\n+            get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n@@ -248,7 +248,7 @@ mod test {\n             os: abi::OsMacos,\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n-            get_install_prefix_lib_path: || fail!(),\n+            get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));"}, {"sha": "96a15213c5ed6ffcedc40da07d28827f8cc7b4a0", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -59,18 +59,18 @@ impl ToBits for u64 {\n     }\n }\n \n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n-        fail!(\"numeric overflow occurred.\")\n+        panic!(\"numeric overflow occurred.\")\n     }\n \n     match bits.checked_add(&new_low_bits) {\n         Some(x) => return x,\n-        None => fail!(\"numeric overflow occurred.\")\n+        None => panic!(\"numeric overflow occurred.\")\n     }\n }\n "}, {"sha": "01a5767aeb2560b5fa5b3f60d6825b5c4c5252d1", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -347,7 +347,7 @@ mod svh_visitor {\n             } else {\n                 // It is not possible to observe any kind of macro\n                 // invocation at this stage except `macro_rules!`.\n-                fail!(\"reached macro somehow: {}\",\n+                panic!(\"reached macro somehow: {}\",\n                       pprust::to_string(|pp_state| pp_state.print_mac(macro)));\n             }\n "}, {"sha": "967e1fbb70021eb885abf9887f12127d609b4318", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -174,7 +174,7 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt,\n     clean::Function {\n         decl: match ty::get(t.ty).sty {\n             ty::ty_bare_fn(ref f) => (did, &f.sig).clean(cx),\n-            _ => fail!(\"bad function\"),\n+            _ => panic!(\"bad function\"),\n         },\n         generics: (&t.generics, subst::FnSpace).clean(cx),\n         fn_style: style,\n@@ -308,7 +308,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                             generics: generics,\n                         })\n                     }\n-                    _ => fail!(\"not a tymethod\"),\n+                    _ => panic!(\"not a tymethod\"),\n                 };\n                 Some(item)\n             }\n@@ -382,7 +382,7 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n                 decoder::DlDef(..) => {}\n                 // All impls were inlined above\n                 decoder::DlImpl(..) => {}\n-                decoder::DlField => fail!(\"unimplemented field\"),\n+                decoder::DlField => panic!(\"unimplemented field\"),\n             }\n         });\n     }"}, {"sha": "7c8f4ba8f65c7bb5f345142e4b0947cba142835a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1259,7 +1259,7 @@ impl Clean<Type> for ast::Ty {\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n             TyBot => Bottom,\n-            ref x => fail!(\"Unimplemented type {}\", x),\n+            ref x => panic!(\"Unimplemented type {}\", x),\n         }\n     }\n }\n@@ -1354,9 +1354,9 @@ impl Clean<Type> for ty::t {\n \n             ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n \n-            ty::ty_infer(..) => fail!(\"ty_infer\"),\n-            ty::ty_open(..) => fail!(\"ty_open\"),\n-            ty::ty_err => fail!(\"ty_err\"),\n+            ty::ty_infer(..) => panic!(\"ty_infer\"),\n+            ty::ty_open(..) => panic!(\"ty_open\"),\n+            ty::ty_err => panic!(\"ty_err\"),\n         }\n     }\n }\n@@ -2068,9 +2068,9 @@ fn name_from_pat(p: &ast::Pat) -> String {\n                   which is silly in function arguments\");\n             \"()\".to_string()\n         },\n-        PatRange(..) => fail!(\"tried to get argument name from PatRange, \\\n+        PatRange(..) => panic!(\"tried to get argument name from PatRange, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(..) => fail!(\"tried to get argument name from pat_vec, \\\n+        PatVec(..) => panic!(\"tried to get argument name from pat_vec, \\\n                              which is not allowed in function arguments\"),\n         PatMac(..) => {\n             warn!(\"can't document the name of a function argument \\\n@@ -2092,7 +2092,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n     debug!(\"searching for {} in defmap\", id);\n     let def = match tcx.def_map.borrow().find(&id) {\n         Some(&k) => k,\n-        None => fail!(\"unresolved id not in defmap\")\n+        None => panic!(\"unresolved id not in defmap\")\n     };\n \n     match def {"}, {"sha": "a89b20c949b4040b2a14c4f674a06e5b1a3a9d57", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -128,7 +128,7 @@ mod imp {\n             };\n             if ret == -1 {\n                 unsafe { libc::close(fd); }\n-                fail!(\"could not lock `{}`\", p.display())\n+                panic!(\"could not lock `{}`\", p.display())\n             }\n             Lock { fd: fd }\n         }\n@@ -197,7 +197,7 @@ mod imp {\n                                   ptr::null_mut())\n             };\n             if handle == libc::INVALID_HANDLE_VALUE {\n-                fail!(\"create file error: {}\", os::last_os_error());\n+                panic!(\"create file error: {}\", os::last_os_error());\n             }\n             let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n             let ret = unsafe {\n@@ -206,7 +206,7 @@ mod imp {\n             };\n             if ret == 0 {\n                 unsafe { libc::CloseHandle(handle); }\n-                fail!(\"could not lock `{}`: {}\", p.display(),\n+                panic!(\"could not lock `{}`: {}\", p.display(),\n                       os::last_os_error())\n             }\n             Lock { handle: handle }"}, {"sha": "f9177c8d61578797a79a5af5f234f287edcb591c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -499,7 +499,7 @@ impl fmt::Show for clean::Type {\n                 }\n             }\n             clean::Unique(..) => {\n-                fail!(\"should have been cleaned\")\n+                panic!(\"should have been cleaned\")\n             }\n         }\n     }"}, {"sha": "b7dfd811574a3c1e955b22fe2654143c80775c66", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1042,7 +1042,7 @@ impl Context {\n     /// sure it always points to the top (relatively)\n     fn recurse<T>(&mut self, s: String, f: |&mut Context| -> T) -> T {\n         if s.len() == 0 {\n-            fail!(\"Unexpected empty destination: {}\", self.current);\n+            panic!(\"Unexpected empty destination: {}\", self.current);\n         }\n         let prev = self.dst.clone();\n         self.dst.push(s.as_slice());"}, {"sha": "5f404238beb30dda938e463612fc9eea68aa0989", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -243,13 +243,13 @@ pub fn main_args(args: &[String]) -> int {\n         Some(\"html\") | None => {\n             match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\"))) {\n                 Ok(()) => {}\n-                Err(e) => fail!(\"failed to generate documentation: {}\", e),\n+                Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n             match json_output(krate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n                 Ok(()) => {}\n-                Err(e) => fail!(\"failed to write json: {}\", e),\n+                Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n         }\n         Some(s) => {\n@@ -480,7 +480,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n-        Err(e) => fail!(\"Rust generated JSON is invalid: {}\", e)\n+        Err(e) => panic!(\"Rust generated JSON is invalid: {}\", e)\n     };\n \n     json.insert(\"crate\".to_string(), crate_json);"}, {"sha": "642abf924ae71ddde749533891b1bbab8a0572b1", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -192,15 +192,15 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n     cmd.env(DynamicLibrary::envvar(), newpath.as_slice());\n \n     match cmd.output() {\n-        Err(e) => fail!(\"couldn't run the test: {}{}\", e,\n+        Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n                         if e.kind == io::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\"\n                         } else { \"\" }),\n         Ok(out) => {\n             if should_fail && out.status.success() {\n-                fail!(\"test executable succeeded when it should have failed\");\n+                panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n-                fail!(\"test executable failed:\\n{}\",\n+                panic!(\"test executable failed:\\n{}\",\n                       str::from_utf8(out.error.as_slice()));\n             }\n         }"}, {"sha": "1cafc38f826c96542552ad22bea00f7131c75807", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -249,7 +249,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                 self.visit_item(&**i, None, om);\n                             }\n                         }\n-                        _ => { fail!(\"glob not mapped to a module\"); }\n+                        _ => { panic!(\"glob not mapped to a module\"); }\n                     }\n                 } else {\n                     self.visit_item(it, renamed, om);\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.foreigns.push(fm.clone());\n             }\n             ast::ItemMac(_) => {\n-                fail!(\"rustdoc: macros should be gone, after expansion\");\n+                panic!(\"rustdoc: macros should be gone, after expansion\");\n             }\n         }\n     }"}, {"sha": "20a63f655b8ff9d2166ac7e7a6c862b0d869e1be", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -160,14 +160,14 @@ mod imp {\n     }\n \n     pub fn take() -> Option<Vec<Vec<u8>>> {\n-        fail!()\n+        panic!()\n     }\n \n     pub fn put(_args: Vec<Vec<u8>>) {\n-        fail!()\n+        panic!()\n     }\n \n     pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        fail!()\n+        panic!()\n     }\n }"}, {"sha": "ddb4df4fdc5386479c34954e84dd63c4620fc33a", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -101,7 +101,7 @@ impl Clone for CString {\n     fn clone(&self) -> CString {\n         let len = self.len() + 1;\n         let buf = unsafe { libc::malloc(len as libc::size_t) } as *mut libc::c_char;\n-        if buf.is_null() { fail!(\"out of memory\") }\n+        if buf.is_null() { panic!(\"out of memory\") }\n         unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n         CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n     }\n@@ -394,7 +394,7 @@ impl<'a> ToCStr for &'a [u8] {\n     unsafe fn to_c_str_unchecked(&self) -> CString {\n         let self_len = self.len();\n         let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-        if buf.is_null() { fail!(\"out of memory\") }\n+        if buf.is_null() { panic!(\"out of memory\") }\n \n         ptr::copy_memory(buf, self.as_ptr(), self_len);\n         *buf.offset(self_len as int) = 0;"}, {"sha": "9a8bd3cdfc81cc6e35b555fff82adceb554fdc44", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -101,7 +101,7 @@ pub trait Runtime {\n     fn wrap(self: Box<Self>) -> Box<Any+'static>;\n }\n \n-/// The default error code of the rust runtime if the main task fails instead\n+/// The default error code of the rust runtime if the main task panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: int = 101;\n "}, {"sha": "5d9e20b07de9aaa6610c6c016f58f626dc453160", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -134,7 +134,7 @@ unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n             *slot = Some(TreeMap::new());\n             match *slot {\n                 Some(ref mut map_ptr) => { return Some(map_ptr) }\n-                None => fail!(\"unreachable code\"),\n+                None => panic!(\"unreachable code\"),\n             }\n         }\n     }\n@@ -161,12 +161,12 @@ impl<T: 'static> KeyValue<T> {\n     /// If this key is already present in TLD, then the previous value is\n     /// replaced with the provided data, and then returned.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function will fail if the key is present in TLD and currently on\n+    /// This function will panic if the key is present in TLD and currently on\n     /// loan with the `get` method.\n     ///\n-    /// It will also fail if there is no local task (because the current thread\n+    /// It will also panic if there is no local task (because the current thread\n     /// is not owned by the runtime).\n     ///\n     /// # Example\n@@ -181,7 +181,7 @@ impl<T: 'static> KeyValue<T> {\n     pub fn replace(&'static self, data: Option<T>) -> Option<T> {\n         let map = match unsafe { get_local_map() } {\n             Some(map) => map,\n-            None => fail!(\"must have a local task to insert into TLD\"),\n+            None => panic!(\"must have a local task to insert into TLD\"),\n         };\n         let keyval = key_to_key_value(self);\n \n@@ -233,7 +233,7 @@ impl<T: 'static> KeyValue<T> {\n                     }\n                     _ => {\n                         // Refcount is 2+, which means we have a live borrow.\n-                        fail!(\"TLD value cannot be replaced because it is already borrowed\");\n+                        panic!(\"TLD value cannot be replaced because it is already borrowed\");\n                     }\n                 }\n             }\n@@ -369,7 +369,7 @@ impl TLDValue {\n         unsafe fn d<T>(p: *mut ()) {\n             let value_box = p as *mut TLDValueBox<T>;\n             debug_assert!(*(*value_box).refcount.get() < 2, \"TLDValue destructed while borrowed\");\n-            // use a RAII type here to ensure we always deallocate even if we fail while\n+            // use a RAII type here to ensure we always deallocate even if we panic while\n             // running the destructor for the value.\n             struct Guard<T> {\n                 p: *mut TLDValueBox<T>\n@@ -495,7 +495,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_tls_cleanup_on_failure() {\n+    fn test_tls_cleanup_on_panic() {\n         static STR_KEY: Key<String> = &KeyValueKey;\n         static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n         static INT_KEY: Key<int> = &KeyValueKey;\n@@ -505,11 +505,11 @@ mod tests {\n             STR_KEY.replace(Some(\"string data\".to_string()));\n             BOX_KEY.replace(Some(box 2));\n             INT_KEY.replace(Some(42));\n-            fail!();\n+            panic!();\n         });\n         // Not quite nondeterministic.\n         INT_KEY.replace(Some(31337));\n-        fail!();\n+        panic!();\n     }\n \n     #[test]"}, {"sha": "6a6e2e40ec8888e3f07dd04e1626e117665b844d", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -81,7 +81,7 @@ pub struct NativeMutex {\n /// destruction.\n ///\n /// Using this makes lock-based code resilient to unwinding/task\n-/// failure, because the lock will be automatically unlocked even\n+/// panic, because the lock will be automatically unlocked even\n /// then.\n #[must_use]\n pub struct LockGuard<'a> {"}, {"sha": "d01b4a3a4b34c87f44c0ef5c3104f8f8de6edf8f", "filename": "src/librustrt/stack_overflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack_overflow.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -116,7 +116,7 @@ mod imp {\n         PAGE_SIZE = info.dwPageSize as uint;\n \n         if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n-            fail!(\"failed to install exception handler\");\n+            panic!(\"failed to install exception handler\");\n         }\n \n         mem::forget(make_handler());\n@@ -127,7 +127,7 @@ mod imp {\n \n     pub unsafe fn make_handler() -> Handler {\n         if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-            fail!(\"failed to reserve stack space for exception handling\");\n+            panic!(\"failed to reserve stack space for exception handling\");\n         }\n \n         super::Handler { _data: 0i as *mut libc::c_void }\n@@ -232,7 +232,7 @@ mod imp {\n     pub unsafe fn init() {\n         let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n         if psize == -1 {\n-            fail!(\"failed to get page size\");\n+            panic!(\"failed to get page size\");\n         }\n \n         PAGE_SIZE = psize as uint;\n@@ -260,7 +260,7 @@ mod imp {\n                              -1,\n                              0);\n         if alt_stack == MAP_FAILED {\n-            fail!(\"failed to allocate an alternative stack\");\n+            panic!(\"failed to allocate an alternative stack\");\n         }\n \n         let mut stack: sigaltstack = mem::zeroed();"}, {"sha": "ad3b1dc7e1695e8e0b2f513ae4cb96312907da5d", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -53,7 +53,7 @@ use collections::str::SendStr;\n ///\n /// * `run` - This function will execute a closure inside the context of a task.\n ///           Failure is caught and handled via the task's on_exit callback. If\n-///           this fails, the task is still returned, but it can no longer be\n+///           this panics, the task is still returned, but it can no longer be\n ///           used, it is poisoned.\n ///\n /// * `destroy` - This is a required function to call to destroy a task. If a\n@@ -74,18 +74,18 @@ use collections::str::SendStr;\n /// // Create a task using a native runtime\n /// let task = native::task::new((0, uint::MAX), 0);\n ///\n-/// // Run some code, catching any possible failures\n+/// // Run some code, catching any possible panic\n /// let task = task.run(|| {\n ///     // Run some code inside this task\n ///     println!(\"Hello with a native runtime!\");\n /// });\n ///\n-/// // Run some code again, catching the failure\n+/// // Run some code again, catching the panic\n /// let task = task.run(|| {\n-///     fail!(\"oh no, what to do!\");\n+///     panic!(\"oh no, what to do!\");\n /// });\n ///\n-/// // Now that the task is failed, it can never be used again\n+/// // Now that the task has panicked, it can never be used again\n /// assert!(task.is_destroyed());\n ///\n /// // Deallocate the resources associated with this task\n@@ -114,15 +114,15 @@ enum TaskState {\n pub struct TaskOpts {\n     /// Invoke this procedure with the result of the task when it finishes.\n     pub on_exit: Option<proc(Result): Send>,\n-    /// A name for the task-to-be, for identification in failure messages\n+    /// A name for the task-to-be, for identification in panic messages\n     pub name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n     pub stack_size: Option<uint>,\n }\n \n /// Indicates the manner in which a task exited.\n ///\n-/// A task that completes without failing is considered to exit successfully.\n+/// A task that completes without panicking is considered to exit successfully.\n ///\n /// If you wish for this result's delivery to block until all\n /// children tasks complete, recommend using a result future.\n@@ -138,7 +138,7 @@ pub enum BlockedTask {\n     Shared(Arc<AtomicUint>),\n }\n \n-/// Per-task state related to task death, killing, failure, etc.\n+/// Per-task state related to task death, killing, panic, etc.\n pub struct Death {\n     pub on_exit: Option<proc(Result):Send>,\n     marker: marker::NoCopy,\n@@ -175,15 +175,15 @@ impl Task {\n     /// try/catch). Invoking this function is quite cheap.\n     ///\n     /// If the closure `f` succeeds, then the returned task can be used again\n-    /// for another invocation of `run`. If the closure `f` fails then `self`\n+    /// for another invocation of `run`. If the closure `f` panics then `self`\n     /// will be internally destroyed along with all of the other associated\n     /// resources of this task. The `on_exit` callback is invoked with the\n-    /// cause of failure (not returned here). This can be discovered by querying\n+    /// cause of panic (not returned here). This can be discovered by querying\n     /// `is_destroyed()`.\n     ///\n     /// Note that it is possible to view partial execution of the closure `f`\n     /// because it is not guaranteed to run to completion, but this function is\n-    /// guaranteed to return if it fails. Care should be taken to ensure that\n+    /// guaranteed to return if it panicks. Care should be taken to ensure that\n     /// stack references made by `f` are handled appropriately.\n     ///\n     /// It is invalid to call this function with a task that has been previously\n@@ -212,7 +212,7 @@ impl Task {\n         // recursive invocations of run(). If there's no one else, then\n         // relinquish ownership of ourselves back into TLS.\n         if Local::exists(None::<Task>) {\n-            fail!(\"cannot run a task recursively inside another\");\n+            panic!(\"cannot run a task recursively inside another\");\n         }\n         self.state = Armed;\n         Local::put(self);\n@@ -226,7 +226,7 @@ impl Task {\n         let result = unsafe { unwind::try(f) };\n \n         // After running the closure given return the task back out if it ran\n-        // successfully, or clean up the task if it failed.\n+        // successfully, or clean up the task if it panicked.\n         let task: Box<Task> = Local::take();\n         match result {\n             Ok(()) => task,\n@@ -275,7 +275,7 @@ impl Task {\n         //    There is a test for this at fail-during-tld-destroy.rs.\n         //\n         // 2. One failure in destruction is tolerable, so long as the task\n-        //    didn't originally fail while it was running.\n+        //    didn't originally panic while it was running.\n         //\n         // And with all that in mind, we attempt to clean things up!\n         let mut task = self.run(|| {\n@@ -290,7 +290,7 @@ impl Task {\n             drop(tld);\n         });\n \n-        // If the above `run` block failed, then it must be the case that the\n+        // If the above `run` block panicked, then it must be the case that the\n         // task had previously succeeded. This also means that the code below\n         // was recursively run via the `run` method invoking this method. In\n         // this case, we just make sure the world is as we thought, and return.\n@@ -306,7 +306,7 @@ impl Task {\n \n         // FIXME: this is running in a seriously constrained context. If this\n         //        allocates TLD then it will likely abort the runtime. Similarly,\n-        //        if this fails, this will also likely abort the runtime.\n+        //        if this panics, this will also likely abort the runtime.\n         //\n         //        This closure is currently limited to a channel send via the\n         //        standard library's task interface, but this needs\n@@ -490,7 +490,7 @@ impl BlockedTask {\n     }\n \n     // This assertion has two flavours because the wake involves an atomic op.\n-    // In the faster version, destructors will fail dramatically instead.\n+    // In the faster version, destructors will panic dramatically instead.\n     #[cfg(not(test))] pub fn trash(self) { }\n     #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n \n@@ -570,7 +570,7 @@ mod test {\n         let result = task::try(proc()());\n         rtdebug!(\"trying first assert\");\n         assert!(result.is_ok());\n-        let result = task::try::<()>(proc() fail!());\n+        let result = task::try::<()>(proc() panic!());\n         rtdebug!(\"trying second assert\");\n         assert!(result.is_err());\n     }"}, {"sha": "9f3f45ba0981c47b1c0f40507cbd7137547d8af5", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -235,7 +235,7 @@ mod imp {\n         if ret as uint == 0 {\n             // be sure to not leak the closure\n             let _p: Box<proc():Send> = mem::transmute(arg);\n-            fail!(\"failed to spawn native thread: {}\", ret);\n+            panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         return ret;\n     }\n@@ -327,23 +327,23 @@ mod imp {\n         unsafe fn get_stack_start() -> *mut libc::c_void {\n             let mut attr: libc::pthread_attr_t = mem::zeroed();\n             if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                fail!(\"failed to get thread attributes\");\n+                panic!(\"failed to get thread attributes\");\n             }\n             let mut stackaddr = ptr::null_mut();\n             let mut stacksize = 0;\n             if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                fail!(\"failed to get stack information\");\n+                panic!(\"failed to get stack information\");\n             }\n             if pthread_attr_destroy(&mut attr) != 0 {\n-                fail!(\"failed to destroy thread attributes\");\n+                panic!(\"failed to destroy thread attributes\");\n             }\n             stackaddr\n         }\n \n         pub unsafe fn init() {\n             let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n             if psize == -1 {\n-                fail!(\"failed to get page size\");\n+                panic!(\"failed to get page size\");\n             }\n \n             PAGE_SIZE = psize as uint;\n@@ -361,7 +361,7 @@ mod imp {\n                               0);\n \n             if result != stackaddr || result == MAP_FAILED {\n-                fail!(\"failed to allocate a guard page\");\n+                panic!(\"failed to allocate a guard page\");\n             }\n \n             let offset = if cfg!(target_os = \"linux\") {\n@@ -387,22 +387,22 @@ mod imp {\n         pub unsafe fn current() -> uint {\n             let mut attr: libc::pthread_attr_t = mem::zeroed();\n             if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                fail!(\"failed to get thread attributes\");\n+                panic!(\"failed to get thread attributes\");\n             }\n             let mut guardsize = 0;\n             if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n-                fail!(\"failed to get stack guard page\");\n+                panic!(\"failed to get stack guard page\");\n             }\n             if guardsize == 0 {\n-                fail!(\"there is no guard page\");\n+                panic!(\"there is no guard page\");\n             }\n             let mut stackaddr = ptr::null_mut();\n             let mut stacksize = 0;\n             if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                fail!(\"failed to get stack information\");\n+                panic!(\"failed to get stack information\");\n             }\n             if pthread_attr_destroy(&mut attr) != 0 {\n-                fail!(\"failed to destroy thread attributes\");\n+                panic!(\"failed to destroy thread attributes\");\n             }\n \n             stackaddr as uint + guardsize as uint\n@@ -433,7 +433,7 @@ mod imp {\n             },\n             errno => {\n                 // This cannot really happen.\n-                fail!(\"pthread_attr_setstacksize() error: {}\", errno);\n+                panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n             },\n         };\n \n@@ -444,7 +444,7 @@ mod imp {\n         if ret != 0 {\n             // be sure to not leak the closure\n             let _p: Box<proc():Send> = mem::transmute(arg);\n-            fail!(\"failed to spawn native thread: {}\", ret);\n+            panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         native\n     }"}, {"sha": "96a584492aeda684a648951114e9cc2f855e13a1", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -115,11 +115,11 @@ impl Unwinder {\n     }\n }\n \n-/// Invoke a closure, capturing the cause of failure if one occurs.\n+/// Invoke a closure, capturing the cause of panic if one occurs.\n ///\n-/// This function will return `None` if the closure did not fail, and will\n-/// return `Some(cause)` if the closure fails. The `cause` returned is the\n-/// object with which failure was originally invoked.\n+/// This function will return `None` if the closure did not panic, and will\n+/// return `Some(cause)` if the closure panics. The `cause` returned is the\n+/// object with which panic was originally invoked.\n ///\n /// This function also is unsafe for a variety of reasons:\n ///\n@@ -489,9 +489,9 @@ pub mod eabi {\n     }\n }\n \n-// Entry point of failure from the libcore crate\n+// Entry point of panic from the libcore crate\n #[cfg(not(test))]\n-#[lang = \"fail_fmt\"]\n+#[lang = \"panic_fmt\"]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, &(file, line))\n@@ -500,7 +500,7 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `fail!()` has as low an impact\n+/// site as much as possible (so that `panic!()` has as low an impact\n /// on (e.g.) the inlining of other functions as possible), by moving\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n@@ -509,7 +509,7 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint))\n \n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n-    // failure + OOM properly anyway (see comment in begin_unwind\n+    // panic + OOM properly anyway (see comment in begin_unwind\n     // below).\n \n     struct VecWriter<'a> { v: &'a mut Vec<u8> }\n@@ -528,15 +528,15 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint))\n     begin_unwind_inner(msg, file_line)\n }\n \n-/// This is the entry point of unwinding for fail!() and assert!().\n+/// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that fail!() on OOM will invoke this code path,\n-    // but then again we're not really ready for failing on OOM anyway. If\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n     // we do start doing this, then we should propagate this allocation to\n     // be performed in the parent of this task instead of the task that's\n-    // failing.\n+    // panicking.\n \n     // see below for why we do the `Any` coercion here.\n     begin_unwind_inner(box msg, file_line)\n@@ -549,11 +549,11 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// we need the `Any` object anyway, we're not just creating it to\n /// avoid being generic.)\n ///\n-/// Do this split took the LLVM IR line counts of `fn main() { fail!()\n+/// Do this split took the LLVM IR line counts of `fn main() { panic!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n-    // First, invoke call the user-defined callbacks triggered on task failure.\n+    // First, invoke call the user-defined callbacks triggered on task panic.\n     //\n     // By the time that we see a callback has been registered (by reading\n     // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n@@ -584,7 +584,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     };\n \n     if task.unwinder.unwinding {\n-        // If a task fails while it's already unwinding then we\n+        // If a task panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the task cleanly.\n@@ -603,7 +603,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// Register a callback to be invoked when a task unwinds.\n ///\n /// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a task fails. This callback is invoked on both\n+/// callback to be invoked when a task panics. This callback is invoked on both\n /// the initial unwinding and a double unwinding if one occurs. Additionally,\n /// the local `Task` will be in place for the duration of the callback, and\n /// the callback must ensure that it remains in place once the callback returns."}, {"sha": "c999157b89a8ffb5d334d343994a230274c059de", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -144,7 +144,7 @@ impl<'a> ToBase64 for &'a [u8] {\n                     v.push(b'=');\n                 }\n             }\n-            _ => fail!(\"Algebra is broken, please alert the math police\")\n+            _ => panic!(\"Algebra is broken, please alert the math police\")\n         }\n \n         unsafe {"}, {"sha": "99c60dde0ac59c44e70c982364e9b3beae37dca1", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1229,7 +1229,7 @@ impl Stack {\n         let len = self.stack.len();\n         let idx = match *self.stack.last().unwrap() {\n             InternalIndex(i) => { i + 1 }\n-            _ => { fail!(); }\n+            _ => { panic!(); }\n         };\n         *self.stack.get_mut(len - 1) = InternalIndex(idx);\n     }\n@@ -1814,7 +1814,7 @@ impl<T: Iterator<char>> Builder<T> {\n         match self.token {\n             None => {}\n             Some(Error(e)) => { return Err(e); }\n-            ref tok => { fail!(\"unexpected token {}\", tok.clone()); }\n+            ref tok => { panic!(\"unexpected token {}\", tok.clone()); }\n         }\n         result\n     }\n@@ -1874,7 +1874,7 @@ impl<T: Iterator<char>> Builder<T> {\n             }\n             let key = match self.parser.stack().top() {\n                 Some(Key(k)) => { k.to_string() }\n-                _ => { fail!(\"invalid state\"); }\n+                _ => { panic!(\"invalid state\"); }\n             };\n             match self.build_value() {\n                 Ok(value) => { values.insert(key, value); }\n@@ -3015,9 +3015,9 @@ mod tests {\n             Ok(json) => Decodable::decode(&mut Decoder::new(json))\n         };\n         match res {\n-            Ok(_) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n+            Ok(_) => panic!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n                               to_parse, expected),\n-            Err(ParseError(e)) => fail!(\"`{}` is not valid json: {}\",\n+            Err(ParseError(e)) => panic!(\"`{}` is not valid json: {}\",\n                                            to_parse, e),\n             Err(e) => {\n                 assert_eq!(e, expected);\n@@ -3226,7 +3226,7 @@ mod tests {\n         let bytes = mem_buf.unwrap();\n         let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n         }\n     }\n@@ -3247,7 +3247,7 @@ mod tests {\n         let bytes = mem_buf.unwrap();\n         let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n         }\n     }\n@@ -3315,7 +3315,7 @@ mod tests {\n         use Decodable;\n         let json_str = \"{\\\"1\\\":true}\";\n         let json_obj = match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n@@ -3328,7 +3328,7 @@ mod tests {\n         use Decodable;\n         let json_str = \"{\\\"a\\\":true}\";\n         let json_obj = match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n@@ -3347,7 +3347,7 @@ mod tests {\n             };\n             let (ref expected_evt, ref expected_stack) = expected[i];\n             if !parser.stack().is_equal_to(expected_stack.as_slice()) {\n-                fail!(\"Parser stack is not equal to {}\", expected_stack);\n+                panic!(\"Parser stack is not equal to {}\", expected_stack);\n             }\n             assert_eq!(&evt, expected_evt);\n             i+=1;"}, {"sha": "33c8e94e32b60915e7390fccbe26992799b79113", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -138,7 +138,7 @@ impl<'a> fmt::Show for Ascii {\n \n /// Trait for converting into an ascii type.\n pub trait AsciiCast<T> {\n-    /// Convert to an ascii type, fail on non-ASCII input.\n+    /// Convert to an ascii type, panic on non-ASCII input.\n     #[inline]\n     fn to_ascii(&self) -> T {\n         assert!(self.is_ascii());\n@@ -649,16 +649,16 @@ mod tests {\n     }\n \n     #[test] #[should_fail]\n-    fn test_ascii_vec_fail_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }\n+    fn test_ascii_vec_panic_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }\n \n     #[test] #[should_fail]\n-    fn test_ascii_vec_fail_str_slice() { \"zo\u00e4\u534e\".to_ascii(); }\n+    fn test_ascii_vec_panic_str_slice() { \"zo\u00e4\u534e\".to_ascii(); }\n \n     #[test] #[should_fail]\n-    fn test_ascii_fail_u8_slice() { 255u8.to_ascii(); }\n+    fn test_ascii_panic_u8_slice() { 255u8.to_ascii(); }\n \n     #[test] #[should_fail]\n-    fn test_ascii_fail_char_slice() { '\u03bb'.to_ascii(); }\n+    fn test_ascii_panic_char_slice() { '\u03bb'.to_ascii(); }\n \n     #[test]\n     fn test_opt() {"}, {"sha": "bb7de168898f0b820a5f42064521bf950c2e1778", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -169,7 +169,7 @@ mod tests {\n     fn malloc(n: uint) -> CVec<u8> {\n         unsafe {\n             let mem = libc::malloc(n as libc::size_t);\n-            if mem.is_null() { fail!(\"out of memory\") }\n+            if mem.is_null() { panic!(\"out of memory\") }\n \n             CVec::new_with_dtor(mem as *mut u8, n,\n                 proc() { libc::free(mem as *mut libc::c_void); })\n@@ -189,7 +189,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_fail_at_null() {\n+    fn test_panic_at_null() {\n         unsafe {\n             CVec::new(ptr::null_mut::<u8>(), 9);\n         }\n@@ -213,7 +213,7 @@ mod tests {\n     fn test_unwrap() {\n         unsafe {\n             let cv = CVec::new_with_dtor(1 as *mut int, 0,\n-                proc() { fail!(\"Don't run this destructor!\") });\n+                proc() { panic!(\"Don't run this destructor!\") });\n             let p = cv.unwrap();\n             assert_eq!(p, 1 as *mut int);\n         }"}, {"sha": "6562a644988e6f32d4be9c72e532629eba97b431", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -120,17 +120,15 @@ impl DefaultResizePolicy {\n // is also memory and cache pressure that this would entail that would be very\n // difficult to properly see in a microbenchmark.\n //\n-// Future Improvements (FIXME!)\n-// ============================\n+// ## Future Improvements (FIXME!)\n //\n // Allow the load factor to be changed dynamically and/or at initialization.\n //\n // Also, would it be possible for us to reuse storage when growing the\n // underlying table? This is exactly the use case for 'realloc', and may\n // be worth exploring.\n //\n-// Future Optimizations (FIXME!)\n-// =============================\n+// ## Future Optimizations (FIXME!)\n //\n // Another possible design choice that I made without any real reason is\n // parameterizing the raw table over keys and values. Technically, all we need\n@@ -473,7 +471,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             };\n             buckets.next();\n         }\n-        fail!(\"Internal HashMap error: Out of space.\");\n+        panic!(\"Internal HashMap error: Out of space.\");\n     }\n }\n \n@@ -829,7 +827,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// Retrieves a mutable value for the given key.\n-    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.\n+    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-panicking\n+    /// alternative.\n     ///\n     /// # Failure\n     ///\n@@ -856,7 +855,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail!(\"no entry found for key\")\n+            None => panic!(\"no entry found for key\")\n         }\n     }\n \n@@ -1625,7 +1624,7 @@ mod test_map {\n         assert!(m.insert(5i, 14i));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => panic!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }\n@@ -1746,7 +1745,7 @@ mod test_map {\n         assert!(m.find(&1i).is_none());\n         m.insert(1i, 2i);\n         match m.find(&1) {\n-            None => fail!(),\n+            None => panic!(),\n             Some(v) => assert_eq!(*v, 2)\n         }\n     }\n@@ -1759,12 +1758,12 @@ mod test_map {\n         for i in range(1i, 10000) {\n             m.insert(i, i + 7);\n             match m.find_copy(&i) {\n-                None => fail!(),\n+                None => panic!(),\n                 Some(v) => assert_eq!(v, i + 7)\n             }\n             for j in range(1i, i/100) {\n                 match m.find_copy(&j) {\n-                    None => fail!(),\n+                    None => panic!(),\n                     Some(v) => assert_eq!(v, j + 7)\n                 }\n             }"}, {"sha": "ca20c3ddb74f02f1b36cad22c2f3ec2b8add85c7", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -470,7 +470,7 @@ impl<K, V, M> BucketState<K, V, M> {\n     pub fn expect_full(self) -> FullBucket<K, V, M> {\n         match self {\n             Full(full) => full,\n-            Empty(..) => fail!(\"Expected full bucket\")\n+            Empty(..) => panic!(\"Expected full bucket\")\n         }\n     }\n }"}, {"sha": "c2f27caad1d9c6758690b4a3b7b3abe75d5862b4", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -44,7 +44,7 @@ impl Drop for DynamicLibrary {\n             }\n         }) {\n             Ok(()) => {},\n-            Err(str) => fail!(\"{}\", str)\n+            Err(str) => panic!(\"{}\", str)\n         }\n     }\n }\n@@ -168,13 +168,13 @@ mod test {\n         // statically linked in\n         let none: Option<Path> = None; // appease the typechecker\n         let libm = match DynamicLibrary::open(none) {\n-            Err(error) => fail!(\"Could not load self as module: {}\", error),\n+            Err(error) => panic!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n         };\n \n         let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n             match libm.symbol(\"cos\") {\n-                Err(error) => fail!(\"Could not load function cos: {}\", error),\n+                Err(error) => panic!(\"Could not load function cos: {}\", error),\n                 Ok(cosine) => mem::transmute::<*mut u8, _>(cosine)\n             }\n         };\n@@ -183,7 +183,7 @@ mod test {\n         let expected_result = 1.0;\n         let result = cosine(argument);\n         if result != expected_result {\n-            fail!(\"cos({}) != {} but equaled {} instead\", argument,\n+            panic!(\"cos({}) != {} but equaled {} instead\", argument,\n                    expected_result, result)\n         }\n     }\n@@ -199,7 +199,7 @@ mod test {\n         let path = Path::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n-            Ok(_) => fail!(\"Successfully opened the empty library.\")\n+            Ok(_) => panic!(\"Successfully opened the empty library.\")\n         }\n     }\n }"}, {"sha": "077599743564151b5b72ec5cd43184d26d71044c", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -51,11 +51,11 @@ pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n     // all times. This means that this `exists` will return true almost all of\n     // the time. There are border cases, however, when the runtime has\n     // *almost* set up the local task, but hasn't quite gotten there yet. In\n-    // order to get some better diagnostics, we print on failure and\n+    // order to get some better diagnostics, we print on panic and\n     // immediately abort the whole process if there is no local task\n     // available.\n     if !Local::exists(None::<Task>) {\n-        let _ = writeln!(&mut err, \"failed at '{}', {}:{}\", msg, file, line);\n+        let _ = writeln!(&mut err, \"panicked at '{}', {}:{}\", msg, file, line);\n         if backtrace::log_enabled() {\n             let _ = backtrace::write(&mut err);\n         } else {\n@@ -76,26 +76,26 @@ pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n \n         match local_stderr.replace(None) {\n             Some(mut stderr) => {\n-                // FIXME: what to do when the task printing fails?\n+                // FIXME: what to do when the task printing panics?\n                 let _ = writeln!(stderr,\n-                                 \"task '{}' failed at '{}', {}:{}\\n\",\n+                                 \"task '{}' panicked at '{}', {}:{}\\n\",\n                                  n, msg, file, line);\n                 if backtrace::log_enabled() {\n                     let _ = backtrace::write(&mut *stderr);\n                 }\n                 local_stderr.replace(Some(stderr));\n             }\n             None => {\n-                let _ = writeln!(&mut err, \"task '{}' failed at '{}', {}:{}\",\n+                let _ = writeln!(&mut err, \"task '{}' panicked at '{}', {}:{}\",\n                                  n, msg, file, line);\n                 if backtrace::log_enabled() {\n                     let _ = backtrace::write(&mut err);\n                 }\n             }\n         }\n \n-        // If this is a double failure, make sure that we printed a backtrace\n-        // for this failure.\n+        // If this is a double panic, make sure that we printed a backtrace\n+        // for this panic.\n         if unwinding && !backtrace::log_enabled() {\n             let _ = backtrace::write(&mut err);\n         }"}, {"sha": "9cd8dbcc509498fe2b6974d64e92d5b2483040c5", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -183,7 +183,7 @@ impl<W: Writer> BufferedWriter<W> {\n     ///\n     /// The buffer is flushed before returning the writer.\n     pub fn unwrap(mut self) -> W {\n-        // FIXME(#12628): is failing the right thing to do if flushing fails?\n+        // FIXME(#12628): is panicking the right thing to do if flushing panicks?\n         self.flush_buf().unwrap();\n         self.inner.take().unwrap()\n     }\n@@ -214,7 +214,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n impl<W: Writer> Drop for BufferedWriter<W> {\n     fn drop(&mut self) {\n         if self.inner.is_some() {\n-            // dtors should not fail, so we ignore a failed flush\n+            // dtors should not panic, so we ignore a panicked flush\n             let _ = self.flush_buf();\n         }\n     }\n@@ -612,7 +612,7 @@ mod test {\n \n     #[test]\n     #[should_fail]\n-    fn dont_fail_in_drop_on_failed_flush() {\n+    fn dont_panic_in_drop_on_panicked_flush() {\n         struct FailFlushWriter;\n \n         impl Writer for FailFlushWriter {\n@@ -623,9 +623,8 @@ mod test {\n         let writer = FailFlushWriter;\n         let _writer = BufferedWriter::new(writer);\n \n-        // Trigger failure. If writer fails *again* due to the flush\n-        // error then the process will abort.\n-        fail!();\n+        // If writer panics *again* due to the flush error then the process will abort.\n+        panic!();\n     }\n \n     #[bench]"}, {"sha": "07f4ebda2d41aa4f4d60ba53bcd696dcb62e0f96", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -188,14 +188,14 @@ mod test {\n         assert_eq!(a, buf.as_slice());\n \n         match reader.read(buf.as_mut_slice()) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n         assert_eq!(a, buf.as_slice());\n \n-        // Ensure it continues to fail in the same way.\n+        // Ensure it continues to panic in the same way.\n         match reader.read(buf.as_mut_slice()) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n         assert_eq!(a, buf.as_slice());\n@@ -218,7 +218,7 @@ mod test {\n         assert_eq!(Ok(\"hello world\\n\".to_string()), reader.read_line());\n         assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n         match reader.read_line() {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n     }\n@@ -232,12 +232,12 @@ mod test {\n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n         let got = match task::try(proc() { rx.recv() }) {\n             Ok(got) => got,\n-            Err(_) => fail!(),\n+            Err(_) => panic!(),\n         };\n         assert_eq!(wanted, got);\n \n         match writer.write_u8(1) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::BrokenPipe),\n         }\n     }"}, {"sha": "a595921fcf72d549a347d9918a2ede003010f6e0", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -70,7 +70,7 @@ impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n ///\n /// * `n`: The value to convert.\n /// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           failure occurs. If this is less than 8, then a value of that\n+///           panic occurs. If this is less than 8, then a value of that\n ///           many bytes is produced. For example, if `size` is 4, then a\n ///           32-bit byte representation is produced.\n /// * `f`: A callback that receives the value.\n@@ -109,7 +109,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///\n /// * `n`: The value to convert.\n /// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           failure occurs. If this is less than 8, then a value of that\n+///           panic occurs. If this is less than 8, then a value of that\n ///           many bytes is produced. For example, if `size` is 4, then a\n ///           32-bit byte representation is produced.\n /// * `f`: A callback that receives the value.\n@@ -146,7 +146,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n /// * `data`: The buffer in which to extract the value.\n /// * `start`: The offset at which to extract the value.\n /// * `size`: The size of the value in bytes to extract. This must be 8 or\n-///           less, or task failure occurs. If this is less than 8, then only\n+///           less, or task panic occurs. If this is less than 8, then only\n ///           that many bytes are parsed. For example, if `size` is 4, then a\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n@@ -156,7 +156,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     assert!(size <= 8u);\n \n     if data.len() - start < size {\n-        fail!(\"index out of bounds\");\n+        panic!(\"index out of bounds\");\n     }\n \n     let mut buf = [0u8, ..8];"}, {"sha": "f749d6c823ea3b399055b0b1fda3105b879cead7", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -105,7 +105,7 @@ impl File {\n     ///\n     /// let file = match File::open_mode(&p, Open, ReadWrite) {\n     ///     Ok(f) => f,\n-    ///     Err(e) => fail!(\"file error: {}\", e),\n+    ///     Err(e) => panic!(\"file error: {}\", e),\n     /// };\n     /// // do some stuff with that file\n     ///\n@@ -957,13 +957,13 @@ mod test {\n     macro_rules! check( ($e:expr) => (\n         match $e {\n             Ok(t) => t,\n-            Err(e) => fail!(\"{} failed with: {}\", stringify!($e), e),\n+            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n         }\n     ) )\n \n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n-            Ok(val) => fail!(\"Unexpected success. Should've been: {}\", $s),\n+            Ok(val) => panic!(\"Unexpected success. Should've been: {}\", $s),\n             Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n@@ -1013,7 +1013,7 @@ mod test {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n-                -1|0 => fail!(\"shouldn't happen\"),\n+                -1|0 => panic!(\"shouldn't happen\"),\n                 n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n@@ -1241,7 +1241,7 @@ mod test {\n                 check!(File::open(f).read(mem));\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n-                    None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n+                    None|Some(\"\") => panic!(\"really shouldn't happen..\"),\n                     Some(n) => format!(\"{}{}\", prefix, n),\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n@@ -1371,7 +1371,7 @@ mod test {\n                     from.display(), to.display()));\n \n         match copy(&from, &to) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(..) => {\n                 assert!(!from.exists());\n                 assert!(!to.exists());\n@@ -1400,7 +1400,7 @@ mod test {\n \n         check!(File::create(&out));\n         match copy(&out, tmpdir.path()) {\n-            Ok(..) => fail!(), Err(..) => {}\n+            Ok(..) => panic!(), Err(..) => {}\n         }\n     }\n \n@@ -1424,7 +1424,7 @@ mod test {\n         let out = tmpdir.join(\"out\");\n \n         match copy(tmpdir.path(), &out) {\n-            Ok(..) => fail!(), Err(..) => {}\n+            Ok(..) => panic!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n     }\n@@ -1475,7 +1475,7 @@ mod test {\n     fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match readlink(tmpdir.path()) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n+            Ok(..) => panic!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n     }\n@@ -1501,12 +1501,12 @@ mod test {\n \n         // can't link to yourself\n         match link(&input, &input) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n+            Ok(..) => panic!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n         // can't link to something that doesn't exist\n         match link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n+            Ok(..) => panic!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n     }\n@@ -1522,7 +1522,7 @@ mod test {\n         assert!(!check!(stat(&file)).perm.contains(io::USER_WRITE));\n \n         match chmod(&tmpdir.join(\"foo\"), io::USER_RWX) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n+            Ok(..) => panic!(\"wanted a panic\"),\n             Err(..) => {}\n         }\n \n@@ -1580,7 +1580,7 @@ mod test {\n         let tmpdir = tmpdir();\n \n         match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n-            Ok(..) => fail!(), Err(..) => {}\n+            Ok(..) => panic!(), Err(..) => {}\n         }\n \n         // Perform each one twice to make sure that it succeeds the second time\n@@ -1615,7 +1615,7 @@ mod test {\n             let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Open,\n                                                io::Read));\n             match f.write(\"wut\".as_bytes()) {\n-                Ok(..) => fail!(), Err(..) => {}\n+                Ok(..) => panic!(), Err(..) => {}\n             }\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n@@ -1653,7 +1653,7 @@ mod test {\n         let tmpdir = tmpdir();\n \n         match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(..) => {}\n         }\n     }"}, {"sha": "2f6dd7e47955fd703b5e0dc76f7861c125c573e4", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -409,7 +409,7 @@ mod test {\n         writer.write([0]).unwrap();\n \n         match writer.write([0, 0]) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::OtherIoError),\n         }\n     }\n@@ -510,7 +510,7 @@ mod test {\n         let buf = [0xff];\n         let mut r = BufReader::new(buf);\n         match r.read_to_string() {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(..) => {}\n         }\n     }"}, {"sha": "7826a6dd9c68e88927ff0d4107150ce096a24fc7", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1730,7 +1730,7 @@ pub enum FileType {\n /// # fn foo() {\n /// let info = match Path::new(\"foo.txt\").stat() {\n ///     Ok(stat) => stat,\n-///     Err(e) => fail!(\"couldn't read foo.txt: {}\", e),\n+///     Err(e) => panic!(\"couldn't read foo.txt: {}\", e),\n /// };\n ///\n /// println!(\"byte size: {}\", info.size);"}, {"sha": "112094d1d39b366477ee2754f9ec99327872a8fb", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -269,21 +269,21 @@ mod tests {\n         spawn(proc() {\n             match UnixStream::connect(&path2) {\n                 Ok(c) => client(c),\n-                Err(e) => fail!(\"failed connect: {}\", e),\n+                Err(e) => panic!(\"failed connect: {}\", e),\n             }\n         });\n \n         match acceptor.accept() {\n             Ok(c) => server(c),\n-            Err(e) => fail!(\"failed accept: {}\", e),\n+            Err(e) => panic!(\"failed accept: {}\", e),\n         }\n     }\n \n     #[test]\n     fn bind_error() {\n         let path = \"path/to/nowhere\";\n         match UnixListener::bind(&path) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => {\n                 assert!(e.kind == PermissionDenied || e.kind == FileNotFound ||\n                         e.kind == InvalidInput);\n@@ -299,7 +299,7 @@ mod tests {\n             \"path/to/nowhere\"\n         };\n         match UnixStream::connect(&path) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => {\n                 assert!(e.kind == FileNotFound || e.kind == OtherIoError);\n             }\n@@ -358,15 +358,15 @@ mod tests {\n \n         let mut acceptor = match UnixListener::bind(&path1).listen() {\n             Ok(a) => a,\n-            Err(e) => fail!(\"failed listen: {}\", e),\n+            Err(e) => panic!(\"failed listen: {}\", e),\n         };\n \n         spawn(proc() {\n             for _ in range(0u, times) {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write([100]) {\n                     Ok(..) => {}\n-                    Err(e) => fail!(\"failed write: {}\", e)\n+                    Err(e) => panic!(\"failed write: {}\", e)\n                 }\n             }\n         });\n@@ -376,7 +376,7 @@ mod tests {\n             let mut buf = [0];\n             match client.read(buf) {\n                 Ok(..) => {}\n-                Err(e) => fail!(\"failed read/accept: {}\", e),\n+                Err(e) => panic!(\"failed read/accept: {}\", e),\n             }\n             assert_eq!(buf[0], 100);\n         }\n@@ -531,10 +531,10 @@ mod tests {\n             match a.accept() {\n                 Ok(..) => break,\n                 Err(ref e) if e.kind == TimedOut => {}\n-                Err(e) => fail!(\"error: {}\", e),\n+                Err(e) => panic!(\"error: {}\", e),\n             }\n             ::task::deschedule();\n-            if i == 1000 { fail!(\"should have a pending connection\") }\n+            if i == 1000 { panic!(\"should have a pending connection\") }\n         }\n         drop(l);\n \n@@ -659,9 +659,9 @@ mod tests {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => fail!(\"{}\", e),\n+                Err(e) => panic!(\"{}\", e),\n            }\n-           if i == 1000 { fail!(\"should have filled up?!\"); }\n+           if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n \n         // I'm not sure as to why, but apparently the write on windows always\n@@ -687,7 +687,7 @@ mod tests {\n             while amt < 100 * 128 * 1024 {\n                 match s.read([0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n-                    Err(e) => fail!(\"{}\", e),\n+                    Err(e) => panic!(\"{}\", e),\n                 }\n             }\n             let _ = rx.recv_opt();\n@@ -722,9 +722,9 @@ mod tests {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => fail!(\"{}\", e),\n+                Err(e) => panic!(\"{}\", e),\n            }\n-           if i == 1000 { fail!(\"should have filled up?!\"); }\n+           if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n \n         tx.send(());"}, {"sha": "09804ef57031384425c3669532410afd2e3612ee", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -471,7 +471,7 @@ impl TcpAcceptor {\n     ///         match socket {\n     ///             Ok(s) => { /* handle s */ }\n     ///             Err(ref e) if e.kind == EndOfFile => break, // closed\n-    ///             Err(e) => fail!(\"unexpected error: {}\", e),\n+    ///             Err(e) => panic!(\"unexpected error: {}\", e),\n     ///         }\n     ///     }\n     /// });\n@@ -532,15 +532,15 @@ mod test {\n     #[test]\n     fn bind_error() {\n         match TcpListener::bind(\"0.0.0.0\", 1) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     }\n \n     #[test]\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0\", 1) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n     }\n@@ -708,7 +708,7 @@ mod test {\n         assert!(nread.is_err());\n \n         match stream.read(buf) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(ref e) => {\n                 assert!(e.kind == NotConnected || e.kind == EndOfFile,\n                         \"unknown kind: {}\", e.kind);\n@@ -734,7 +734,7 @@ mod test {\n         assert!(nread.is_err());\n \n         match stream.read(buf) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(ref e) => {\n                 assert!(e.kind == NotConnected || e.kind == EndOfFile,\n                         \"unknown kind: {}\", e.kind);\n@@ -1082,7 +1082,7 @@ mod test {\n         let listener = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n         assert!(listener.is_ok());\n         match TcpListener::bind(ip_str.as_slice(), port).listen() {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n                         \"unknown error: {} {}\", e, e.kind);\n@@ -1266,10 +1266,10 @@ mod test {\n                 match a.accept() {\n                     Ok(..) => break,\n                     Err(ref e) if e.kind == TimedOut => {}\n-                    Err(e) => fail!(\"error: {}\", e),\n+                    Err(e) => panic!(\"error: {}\", e),\n                 }\n                 ::task::deschedule();\n-                if i == 1000 { fail!(\"should have a pending connection\") }\n+                if i == 1000 { panic!(\"should have a pending connection\") }\n             }\n         }\n \n@@ -1373,9 +1373,9 @@ mod test {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => fail!(\"{}\", e),\n+                Err(e) => panic!(\"{}\", e),\n            }\n-           if i == 1000 { fail!(\"should have filled up?!\"); }\n+           if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n         assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n \n@@ -1398,7 +1398,7 @@ mod test {\n             while amt < 100 * 128 * 1024 {\n                 match s.read([0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n-                    Err(e) => fail!(\"{}\", e),\n+                    Err(e) => panic!(\"{}\", e),\n                 }\n             }\n             let _ = rx.recv_opt();\n@@ -1435,9 +1435,9 @@ mod test {\n             match s.write([0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => fail!(\"{}\", e),\n+                Err(e) => panic!(\"{}\", e),\n            }\n-           if i == 1000 { fail!(\"should have filled up?!\"); }\n+           if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n         assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n "}, {"sha": "ad9ed090a5ba667cbed3d866b36c452e53532c84", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -43,7 +43,7 @@ use rt::rtio;\n ///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n ///     let mut socket = match UdpSocket::bind(addr) {\n ///         Ok(s) => s,\n-///         Err(e) => fail!(\"couldn't bind socket: {}\", e),\n+///         Err(e) => panic!(\"couldn't bind socket: {}\", e),\n ///     };\n ///\n ///     let mut buf = [0, ..10];\n@@ -271,7 +271,7 @@ mod test {\n     fn bind_error() {\n         let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n         match UdpSocket::bind(addr) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     }\n@@ -289,7 +289,7 @@ mod test {\n                     rx1.recv();\n                     client.send_to([99], server_ip).unwrap()\n                 }\n-                Err(..) => fail!()\n+                Err(..) => panic!()\n             }\n             tx2.send(());\n         });\n@@ -304,10 +304,10 @@ mod test {\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    Err(..) => fail!()\n+                    Err(..) => panic!()\n                 }\n             }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n         rx2.recv();\n     }\n@@ -324,7 +324,7 @@ mod test {\n                     rx.recv();\n                     client.send_to([99], server_ip).unwrap()\n                 }\n-                Err(..) => fail!()\n+                Err(..) => panic!()\n             }\n         });\n \n@@ -338,10 +338,10 @@ mod test {\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    Err(..) => fail!()\n+                    Err(..) => panic!()\n                 }\n             }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n     }\n \n@@ -362,7 +362,7 @@ mod test {\n                         let mut stream = client.connect(server_ip);\n                         stream.write(val).unwrap();\n                     }\n-                    Err(..) => fail!()\n+                    Err(..) => panic!()\n                 }\n             };\n             rx1.recv();\n@@ -382,10 +382,10 @@ mod test {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    Err(..) => fail!(),\n+                    Err(..) => panic!(),\n                 }\n             }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n         rx2.recv();\n     }\n@@ -406,7 +406,7 @@ mod test {\n                     rx1.recv();\n                     stream.write([99]).unwrap();\n                 }\n-                Err(..) => fail!()\n+                Err(..) => panic!()\n             }\n             tx2.send(());\n         });\n@@ -422,10 +422,10 @@ mod test {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    Err(..) => fail!()\n+                    Err(..) => panic!()\n                 }\n             }\n-            Err(..) => fail!()\n+            Err(..) => panic!()\n         }\n         rx2.recv();\n     }\n@@ -535,7 +535,7 @@ mod test {\n             rx.recv();\n             match sock2.recv_from(buf) {\n                 Ok(..) => {}\n-                Err(e) => fail!(\"failed receive: {}\", e),\n+                Err(e) => panic!(\"failed receive: {}\", e),\n             }\n             serv_tx.send(());\n         });\n@@ -612,7 +612,7 @@ mod test {\n             match a.send_to([0, ..4*1024], addr2) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => fail!(\"other error: {}\", e),\n+                Err(e) => panic!(\"other error: {}\", e),\n             }\n         }\n     }"}, {"sha": "36d235907046d3537072b5866de4f11e6819c93c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -56,7 +56,7 @@ use std::hash::sip::SipState;\n ///\n /// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n ///     Ok(child) => child,\n-///     Err(e) => fail!(\"failed to execute child: {}\", e),\n+///     Err(e) => panic!(\"failed to execute child: {}\", e),\n /// };\n ///\n /// let contents = child.stdout.as_mut().unwrap().read_to_end();\n@@ -145,7 +145,7 @@ pub type EnvMap = HashMap<EnvKey, CString>;\n ///\n /// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n ///   Ok(p) => p,\n-///   Err(e) => fail!(\"failed to execute process: {}\", e),\n+///   Err(e) => panic!(\"failed to execute process: {}\", e),\n /// };\n ///\n /// let output = process.stdout.as_mut().unwrap().read_to_end();\n@@ -372,7 +372,7 @@ impl Command {\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n     ///     Ok(output) => output,\n-    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n@@ -393,7 +393,7 @@ impl Command {\n     ///\n     /// let status = match Command::new(\"ls\").status() {\n     ///     Ok(status) => status,\n-    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n     /// };\n     ///\n     /// println!(\"process exited with: {}\", status);\n@@ -691,7 +691,7 @@ mod tests {\n     #[test]\n     fn smoke_failure() {\n         match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(..) => {}\n         }\n     }\n@@ -714,7 +714,7 @@ mod tests {\n         let mut p = p.unwrap();\n         match p.wait().unwrap() {\n             process::ExitSignal(1) => {},\n-            result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n+            result => panic!(\"not terminated by signal 1 (instead, {})\", result),\n         }\n     }\n \n@@ -815,7 +815,7 @@ mod tests {\n     fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind, FileNotFound),\n-            Ok(..) => fail!()\n+            Ok(..) => panic!()\n         }\n     }\n \n@@ -1063,7 +1063,7 @@ mod tests {\n             }\n             timer::sleep(Duration::milliseconds(100));\n         }\n-        fail!(\"never saw the child go away\");\n+        panic!(\"never saw the child go away\");\n     }\n \n     #[test]\n@@ -1121,7 +1121,7 @@ mod tests {\n \n         let mut fdes = match file::open(&path.to_c_str(), Truncate, Write) {\n             Ok(f) => f,\n-            Err(_) => fail!(\"failed to open file descriptor\"),\n+            Err(_) => panic!(\"failed to open file descriptor\"),\n         };\n \n         let mut cmd = pwd_cmd();"}, {"sha": "40793d98ee3b893eac11d6eb10cbf81f96b4b255", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -96,11 +96,11 @@ mod test {\n             Err(io::standard_error(io::EndOfFile));\n \n         match writer.write([0, 0, 0]) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n         match writer.flush() {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n     }\n@@ -122,7 +122,7 @@ mod test {\n         let mut buf = [];\n \n         match reader.read(buf) {\n-            Ok(..) => fail!(),\n+            Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n     }"}, {"sha": "5fd4faff6d2500f75486043e230ca5703bc0560d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -176,8 +176,8 @@ pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n /// Resets the task-local stderr handle to the specified writer\n ///\n /// This will replace the current task's stderr handle, returning the old\n-/// handle. Currently, the stderr handle is used for printing failure messages\n-/// during task failure.\n+/// handle. Currently, the stderr handle is used for printing panic messages\n+/// during task panic.\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n@@ -212,7 +212,7 @@ fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n     };\n     match result {\n         Ok(()) => {}\n-        Err(e) => fail!(\"failed printing to stdout: {}\", e),\n+        Err(e) => panic!(\"failed printing to stdout: {}\", e),\n     }\n }\n \n@@ -415,7 +415,7 @@ mod tests {\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n             ::realstd::io::stdio::set_stderr(box w);\n-            fail!(\"my special message\");\n+            panic!(\"my special message\");\n         });\n         let s = r.read_to_string().unwrap();\n         assert!(s.as_slice().contains(\"my special message\"));"}, {"sha": "6571dc41585bb76ff55825399841dfbe090b9665", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -139,14 +139,14 @@ mod darwin_fd_limit {\n         if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n                   null_mut(), 0) != 0 {\n             let err = last_os_error();\n-            fail!(\"raise_fd_limit: error calling sysctl: {}\", err);\n+            panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n         }\n \n         // Fetch the current resource limits\n         let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n         if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n             let err = last_os_error();\n-            fail!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n+            panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n         }\n \n         // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n@@ -155,7 +155,7 @@ mod darwin_fd_limit {\n         // Set our newly-increased resource limit\n         if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n             let err = last_os_error();\n-            fail!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+            panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n         }\n     }\n }"}, {"sha": "d16199da77fcdf3de982dfbe84a3aba07c9b2065", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -340,22 +340,22 @@ mod test {\n     fn oneshot_fail() {\n         let mut timer = Timer::new().unwrap();\n         let _rx = timer.oneshot(Duration::milliseconds(1));\n-        fail!();\n+        panic!();\n     }\n \n     #[test]\n     #[should_fail]\n     fn period_fail() {\n         let mut timer = Timer::new().unwrap();\n         let _rx = timer.periodic(Duration::milliseconds(1));\n-        fail!();\n+        panic!();\n     }\n \n     #[test]\n     #[should_fail]\n     fn normal_fail() {\n         let _timer = Timer::new().unwrap();\n-        fail!();\n+        panic!();\n     }\n \n     #[test]"}, {"sha": "5451d07ab468536355f9af84f5e17e9f5e7b78de", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -91,7 +91,7 @@\n //! Finally, the [`prelude`](prelude/index.html) defines a\n //! common set of traits, types, and functions that are made available\n //! to all code by default. [`macros`](macros/index.html) contains\n-//! all the standard macros, such as `assert!`, `fail!`, `println!`,\n+//! all the standard macros, such as `assert!`, `panic!`, `println!`,\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n@@ -261,7 +261,7 @@ mod std {\n     pub use io; // used for println!()\n     pub use local_data; // used for local_data_key!()\n     pub use option; // used for bitflags!{}\n-    pub use rt; // used for fail!()\n+    pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n \n     // The test runner calls ::std::os::args() but really wants realstd"}, {"sha": "9e0530a76f2577e197f0d72cae54264ff51dfdd6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,29 +17,29 @@\n #![experimental]\n #![macro_escape]\n \n-/// The entry point for failure of rust tasks.\n+/// The entry point for panic of Rust tasks.\n ///\n-/// This macro is used to inject failure into a rust task, causing the task to\n-/// unwind and fail entirely. Each task's failure can be reaped as the\n-/// `Box<Any>` type, and the single-argument form of the `fail!` macro will be\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n /// the value which is transmitted.\n ///\n-/// The multi-argument form of this macro fails with a string and has the\n+/// The multi-argument form of this macro panics with a string and has the\n /// `format!` syntax for building a string.\n ///\n /// # Example\n ///\n /// ```should_fail\n /// # #![allow(unreachable_code)]\n-/// fail!();\n-/// fail!(\"this is a terrible mistake!\");\n-/// fail!(4i); // fail with the value of 4 to be collected elsewhere\n-/// fail!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-macro_rules! fail(\n+macro_rules! panic(\n     () => ({\n-        fail!(\"explicit failure\")\n+        panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n         // static requires less code at runtime, more constant data\n@@ -57,7 +57,7 @@ macro_rules! fail(\n         // as returning !. We really do want this to be inlined, however,\n         // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n         // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to fail!()\n+        // up with the number of calls to panic!()\n         //\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n@@ -74,13 +74,13 @@ macro_rules! fail(\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n-/// This will invoke the `fail!` macro if the provided expression cannot be\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n /// # Example\n ///\n /// ```\n-/// // the failure message for these assertions is the stringified value of the\n+/// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// assert!(true);\n /// # fn some_computation() -> bool { true }\n@@ -96,20 +96,20 @@ macro_rules! fail(\n macro_rules! assert(\n     ($cond:expr) => (\n         if !$cond {\n-            fail!(concat!(\"assertion failed: \", stringify!($cond)))\n+            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n     ($cond:expr, $($arg:expr),+) => (\n         if !$cond {\n-            fail!($($arg),+)\n+            panic!($($arg),+)\n         }\n     );\n )\n \n /// Asserts that two expressions are equal to each other, testing equality in\n /// both directions.\n ///\n-/// On failure, this macro will print the values of the expressions.\n+/// On panic, this macro will print the values of the expressions.\n ///\n /// # Example\n ///\n@@ -126,7 +126,7 @@ macro_rules! assert_eq(\n                 // check both directions of equality....\n                 if !((*given_val == *expected_val) &&\n                      (*expected_val == *given_val)) {\n-                    fail!(\"assertion failed: `(left == right) && (right == left)` \\\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n                            (left: `{}`, right: `{}`)\", *given_val, *expected_val)\n                 }\n             }\n@@ -136,7 +136,7 @@ macro_rules! assert_eq(\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n-/// This will invoke the `fail!` macro if the provided expression cannot be\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n /// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n@@ -147,7 +147,7 @@ macro_rules! assert_eq(\n /// # Example\n ///\n /// ```\n-/// // the failure message for these assertions is the stringified value of the\n+/// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// debug_assert!(true);\n /// # fn some_expensive_computation() -> bool { true }\n@@ -167,7 +167,7 @@ macro_rules! debug_assert(\n /// Asserts that two expressions are equal to each other, testing equality in\n /// both directions.\n ///\n-/// On failure, this macro will print the values of the expressions.\n+/// On panic, this macro will print the values of the expressions.\n ///\n /// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n /// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n@@ -186,7 +186,7 @@ macro_rules! debug_assert_eq(\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n )\n \n-/// A utility macro for indicating unreachable code. It will fail if\n+/// A utility macro for indicating unreachable code. It will panic if\n /// executed. This is occasionally useful to put after loops that never\n /// terminate normally, but instead directly return from a function.\n ///\n@@ -211,14 +211,14 @@ macro_rules! debug_assert_eq(\n /// ```\n #[macro_export]\n macro_rules! unreachable(\n-    () => (fail!(\"internal error: entered unreachable code\"))\n+    () => (panic!(\"internal error: entered unreachable code\"))\n )\n \n-/// A standardised placeholder for marking unfinished code. It fails with the\n+/// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n macro_rules! unimplemented(\n-    () => (fail!(\"not yet implemented\"))\n+    () => (panic!(\"not yet implemented\"))\n )\n \n /// Use the syntax described in `std::fmt` to create a value of type `String`."}, {"sha": "6e0d81a63c951da37baf427828407f05a05a5567", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -264,10 +264,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ => ()\n     }\n@@ -553,19 +553,19 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n+          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n                     special values 'inf' and 'NaN'\", radix),\n         _ if (radix as int) < 2\n-          => fail!(\"from_str_bytes_common: radix {} to low, \\\n+          => panic!(\"from_str_bytes_common: radix {} to low, \\\n                     must lie in the range [2, 36]\", radix),\n         _ if (radix as int) > 36\n-          => fail!(\"from_str_bytes_common: radix {} to high, \\\n+          => panic!(\"from_str_bytes_common: radix {} to high, \\\n                     must lie in the range [2, 36]\", radix),\n         _ => ()\n     }"}, {"sha": "c7994ae84e8482f2cbf3597f1d5f54992ddbe0d0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -96,7 +96,7 @@ pub fn getcwd() -> Path {\n     let mut buf = [0 as c_char, ..BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            fail!()\n+            panic!()\n         }\n         Path::new(CString::new(buf.as_ptr(), false))\n     }\n@@ -130,7 +130,7 @@ pub fn getcwd() -> Path {\n     let mut buf = [0 as u16, ..BUF_BYTES];\n     unsafe {\n         if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            fail!();\n+            panic!();\n         }\n     }\n     Path::new(String::from_utf16(::str::truncate_utf16_at_nul(buf))\n@@ -238,7 +238,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             };\n             let ch = GetEnvironmentStringsW();\n             if ch as uint == 0 {\n-                fail!(\"os::env() failure getting env string from OS: {}\",\n+                panic!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             // Here, we lossily decode the string as UTF16.\n@@ -280,7 +280,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             }\n             let mut environ = rust_env_pairs();\n             if environ as uint == 0 {\n-                fail!(\"os::env() failure getting env string from OS: {}\",\n+                panic!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             let mut result = Vec::new();\n@@ -1009,7 +1009,7 @@ pub fn error_string(errnum: uint) -> String {\n         let p = buf.as_mut_ptr();\n         unsafe {\n             if strerror_r(errnum as c_int, p, buf.len() as libc::size_t) < 0 {\n-                fail!(\"strerror_r failure\");\n+                panic!(\"strerror_r failure\");\n             }\n \n             ::string::raw::from_buf(p as *const u8)\n@@ -1079,9 +1079,9 @@ static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n  * Sets the process exit code\n  *\n  * Sets the exit code returned by the process if all supervised tasks\n- * terminate successfully (without failing). If the current root task fails\n+ * terminate successfully (without panicking). If the current root task panics\n  * and is supervised by the scheduler then any user-specified exit status is\n- * ignored and the process exits with the default failure status.\n+ * ignored and the process exits with the default panic status.\n  *\n  * Note that this is not synchronized against modifications of other threads.\n  */\n@@ -1185,7 +1185,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n \n     match rt::args::clone() {\n         Some(args) => args,\n-        None => fail!(\"process arguments not initialized\")\n+        None => panic!(\"process arguments not initialized\")\n     }\n }\n \n@@ -1511,12 +1511,12 @@ impl MemoryMap {\n \n #[cfg(unix)]\n impl Drop for MemoryMap {\n-    /// Unmap the mapping. Fails the task if `munmap` fails.\n+    /// Unmap the mapping. Panics the task if `munmap` panics.\n     fn drop(&mut self) {\n         if self.len == 0 { /* workaround for dummy_stack */ return; }\n \n         unsafe {\n-            // `munmap` only fails due to logic errors\n+            // `munmap` only panics due to logic errors\n             libc::munmap(self.data as *mut c_void, self.len as libc::size_t);\n         }\n     }\n@@ -2098,7 +2098,7 @@ mod tests {\n             os::MapWritable\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(\"{}\", msg)\n+            Err(msg) => panic!(\"{}\", msg)\n         };\n         assert!(chunk.len >= 16);\n \n@@ -2147,7 +2147,7 @@ mod tests {\n             MapOffset(size / 2)\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(\"{}\", msg)\n+            Err(msg) => panic!(\"{}\", msg)\n         };\n         assert!(chunk.len > 0);\n "}, {"sha": "1897c8638cc69e3c4a68e4b174ebefbf0e450df8", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1343,7 +1343,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_not_utf8_fail() {\n+    fn test_not_utf8_panics() {\n         Path::new(b\"hello\\x80.txt\");\n     }\n "}, {"sha": "d1c655cb4d0bb1186cea212a2856b182fee5a7e9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -297,7 +297,7 @@ impl<'a> SeedableRng<&'a [uint]> for StdRng {\n pub fn weak_rng() -> XorShiftRng {\n     match OsRng::new() {\n         Ok(mut r) => r.gen(),\n-        Err(e) => fail!(\"weak_rng: failed to create seeded RNG: {}\", e)\n+        Err(e) => panic!(\"weak_rng: failed to create seeded RNG: {}\", e)\n     }\n }\n \n@@ -308,7 +308,7 @@ impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n     fn reseed(&mut self, rng: &mut StdRng) {\n         *rng = match StdRng::new() {\n             Ok(r) => r,\n-            Err(e) => fail!(\"could not reseed task_rng: {}\", e)\n+            Err(e) => panic!(\"could not reseed task_rng: {}\", e)\n         }\n     }\n }\n@@ -339,7 +339,7 @@ pub fn task_rng() -> TaskRng {\n         None => {\n             let r = match StdRng::new() {\n                 Ok(r) => r,\n-                Err(e) => fail!(\"could not initialize task_rng: {}\", e)\n+                Err(e) => panic!(\"could not initialize task_rng: {}\", e)\n             };\n             let rng = reseeding::ReseedingRng::new(r,\n                                                    TASK_RNG_RESEED_THRESHOLD,\n@@ -445,7 +445,7 @@ mod test {\n             // use this to get nicer error messages.\n             for (i, &byte) in v.iter().enumerate() {\n                 if byte == 0 {\n-                    fail!(\"byte {} of {} is zero\", i, n)\n+                    panic!(\"byte {} of {} is zero\", i, n)\n                 }\n             }\n         }\n@@ -472,14 +472,14 @@ mod test {\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_range_fail_int() {\n+    fn test_gen_range_panic_int() {\n         let mut r = task_rng();\n         r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_range_fail_uint() {\n+    fn test_gen_range_panic_uint() {\n         let mut r = task_rng();\n         r.gen_range(5u, 2u);\n     }"}, {"sha": "424fd039fd4c45f8f0dbc8b0d39f23d34c972fba", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -120,7 +120,7 @@ mod imp {\n                 SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t, v.as_mut_ptr())\n             };\n             if ret == -1 {\n-                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\", os::last_os_error());\n             }\n         }\n     }\n@@ -208,7 +208,7 @@ mod imp {\n                                v.as_mut_ptr())\n             };\n             if ret == 0 {\n-                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\", os::last_os_error());\n             }\n         }\n     }\n@@ -219,7 +219,7 @@ mod imp {\n                 CryptReleaseContext(self.hcryptprov, 0)\n             };\n             if ret == 0 {\n-                fail!(\"couldn't release context: {}\", os::last_os_error());\n+                panic!(\"couldn't release context: {}\", os::last_os_error());\n             }\n         }\n     }"}, {"sha": "4f2205312373c20b0d9141520b9f52af743dda44", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -18,7 +18,9 @@ use result::{Ok, Err};\n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required.\n ///\n-/// It will fail if it there is insufficient data to fulfill a request.\n+/// # Panics\n+///\n+/// It will panic if it there is insufficient data to fulfill a request.\n ///\n /// # Example\n ///\n@@ -65,7 +67,7 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         if v.len() == 0 { return }\n         match self.reader.read_at_least(v.len(), v) {\n             Ok(_) => {}\n-            Err(e) => fail!(\"ReaderRng.fill_bytes error: {}\", e)\n+            Err(e) => panic!(\"ReaderRng.fill_bytes error: {}\", e)\n         }\n     }\n }"}, {"sha": "5bd3927727574ff3b56eb39fa70bf6a436559824", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Simple backtrace functionality (to print on failure)\n+//! Simple backtrace functionality (to print on panic)\n \n #![allow(non_camel_case_types)]\n \n@@ -265,7 +265,7 @@ mod imp {\n \n         // while it doesn't requires lock for work as everything is\n         // local, it still displays much nicer backtraces when a\n-        // couple of tasks fail simultaneously\n+        // couple of tasks panic simultaneously\n         static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };\n \n@@ -327,7 +327,7 @@ mod imp {\n             // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n             // slightly more accurate stack trace in the process.\n             //\n-            // This is often because failure involves the last instruction of a\n+            // This is often because panic involves the last instruction of a\n             // function being \"call std::rt::begin_unwind\", with no ret\n             // instructions after it. This means that the return instruction\n             // pointer points *outside* of the calling function, and by"}, {"sha": "e36d4ce8d4b7414b140c85bdf53bfa9922e985dd", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -67,7 +67,7 @@ pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio, thread};\n pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};\n pub use rustrt::{bookkeeping, at_exit, unwind, DEFAULT_ERROR_CODE, Runtime};\n \n-// Simple backtrace functionality (to print on failure)\n+// Simple backtrace functionality (to print on panic)\n pub mod backtrace;\n \n // Just stuff"}, {"sha": "56f2dbf667a7c30680aab7af33acd92be95240a6", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -62,7 +62,7 @@ pub fn default_sched_threads() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(nstr.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => fail!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n+                _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n         None => {"}, {"sha": "3607050943270db02c37deacaa19ef294d30d815", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -58,7 +58,7 @@ impl<A> Future<A> {\n         let state = replace(&mut self.state, Evaluating);\n         match state {\n             Forced(v) => v,\n-            _ => fail!( \"Logic error.\" ),\n+            _ => panic!( \"Logic error.\" ),\n         }\n     }\n \n@@ -70,10 +70,10 @@ impl<A> Future<A> {\n         */\n         match self.state {\n             Forced(ref v) => return v,\n-            Evaluating => fail!(\"Recursive forcing of future!\"),\n+            Evaluating => panic!(\"Recursive forcing of future!\"),\n             Pending(_) => {\n                 match replace(&mut self.state, Evaluating) {\n-                    Forced(_) | Evaluating => fail!(\"Logic error.\"),\n+                    Forced(_) | Evaluating => panic!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n                         self.get_ref()\n@@ -132,7 +132,7 @@ impl<A:Send> Future<A> {\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n-            // Don't fail if the other end has hung up\n+            // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n         });\n \n@@ -193,8 +193,8 @@ mod test {\n \n     #[test]\n     #[should_fail]\n-    fn test_futurefail() {\n-        let mut f = Future::spawn(proc() fail!());\n+    fn test_future_panic() {\n+        let mut f = Future::spawn(proc() panic!());\n         let _x: String = f.get();\n     }\n \n@@ -211,7 +211,7 @@ mod test {\n     }\n \n     #[test]\n-    fn test_dropped_future_doesnt_fail() {\n+    fn test_dropped_future_doesnt_panic() {\n         struct Bomb(Sender<bool>);\n \n         local_data_key!(LOCAL: Bomb)\n@@ -224,13 +224,13 @@ mod test {\n         }\n \n         // Spawn a future, but drop it immediately. When we receive the result\n-        // later on, we should never view the task as having failed.\n+        // later on, we should never view the task as having panicked.\n         let (tx, rx) = channel();\n         drop(Future::spawn(proc() {\n             LOCAL.replace(Some(Bomb(tx)));\n         }));\n \n-        // Make sure the future didn't fail the task.\n+        // Make sure the future didn't panic the task.\n         assert!(!rx.recv());\n     }\n }"}, {"sha": "d4a60fb584457e90088b73fa9739837af669d3ef", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -42,9 +42,9 @@ impl<T> TaskPool<T> {\n     /// `init_fn_factory` returns a function which, given the index of the\n     /// task, should return local data to be kept around in that task.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function will fail if `n_tasks` is less than 1.\n+    /// This function will panic if `n_tasks` is less than 1.\n     pub fn new(n_tasks: uint,\n                init_fn_factory: || -> proc(uint):Send -> T)\n                -> TaskPool<T> {\n@@ -96,7 +96,7 @@ fn test_task_pool() {\n \n #[test]\n #[should_fail]\n-fn test_zero_tasks_failure() {\n+fn test_zero_tasks_panic() {\n     let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n     TaskPool::new(0, f);\n }"}, {"sha": "c79b8715c06c2757ade5974950b6c4a773499fb7", "filename": "src/libstd/task.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -28,12 +28,12 @@\n //! using the atomically-reference-counted container,\n //! [`Arc`](../../std/sync/struct.Arc.html).\n //!\n-//! Fatal logic errors in Rust cause *task failure*, during which\n+//! Fatal logic errors in Rust cause *task panic*, during which\n //! a task will unwind the stack, running destructors and freeing\n-//! owned resources. Task failure is unrecoverable from within\n-//! the failing task (i.e. there is no 'try/catch' in Rust), but\n-//! failure may optionally be detected from a different task. If\n-//! the main task fails the application will exit with a non-zero\n+//! owned resources. Task panic is unrecoverable from within\n+//! the panicking task (i.e. there is no 'try/catch' in Rust), but\n+//! panic may optionally be detected from a different task. If\n+//! the main task panics the application will exit with a non-zero\n //! exit code.\n //!\n //! # Basic task scheduling\n@@ -123,7 +123,7 @@ impl Spawner for SiblingSpawner {\n         let tb: Option<Box<Task>> = Local::try_take();\n         match tb {\n             Some(t) => t.spawn_sibling(opts, f),\n-            None => fail!(\"need a local task to spawn a sibling task\"),\n+            None => panic!(\"need a local task to spawn a sibling task\"),\n         };\n     }\n }\n@@ -140,7 +140,7 @@ impl Spawner for SiblingSpawner {\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n pub struct TaskBuilder<S = SiblingSpawner> {\n-    // A name for the task-to-be, for identification in failure messages\n+    // A name for the task-to-be, for identification in panic messages\n     name: Option<SendStr>,\n     // The size of the stack for the spawned task\n     stack_size: Option<uint>,\n@@ -173,7 +173,7 @@ impl TaskBuilder<SiblingSpawner> {\n \n impl<S: Spawner> TaskBuilder<S> {\n     /// Name the task-to-be. Currently the name is used for identification\n-    /// only in failure messages.\n+    /// only in panic messages.\n     #[unstable = \"IntoMaybeOwned will probably change.\"]\n     pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n         self.name = Some(name.into_maybe_owned());\n@@ -269,10 +269,10 @@ impl<S: Spawner> TaskBuilder<S> {\n     ///\n     /// # Return value\n     ///\n-    /// If the child task executes successfully (without failing) then the\n+    /// If the child task executes successfully (without panicking) then the\n     /// future returns `result::Ok` containing the value returned by the\n-    /// function. If the child task fails then the future returns `result::Err`\n-    /// containing the argument to `fail!(...)` as an `Any` trait object.\n+    /// function. If the child task panics then the future returns `result::Err`\n+    /// containing the argument to `panic!(...)` as an `Any` trait object.\n     #[experimental = \"Futures are experimental.\"]\n     pub fn try_future<T:Send>(self, f: proc():Send -> T)\n                               -> Future<Result<T, Box<Any + Send>>> {\n@@ -293,7 +293,7 @@ impl<S: Spawner> TaskBuilder<S> {\n     }\n \n     /// Execute a function in a newly-spawnedtask and block until the task\n-    /// completes or fails. Equivalent to `.try_future(f).unwrap()`.\n+    /// completes or panics. Equivalent to `.try_future(f).unwrap()`.\n     #[unstable = \"Error type may change.\"]\n     pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n         self.try_future(f).unwrap()\n@@ -313,7 +313,7 @@ pub fn spawn(f: proc(): Send) {\n }\n \n /// Execute a function in a newly-spawned task and return either the return\n-/// value of the function or an error if the task failed.\n+/// value of the function or an error if the task panicked.\n ///\n /// This is equivalent to `TaskBuilder::new().try`.\n #[unstable = \"Error type may change.\"]\n@@ -355,8 +355,8 @@ pub fn deschedule() {\n     task.yield_now();\n }\n \n-/// True if the running task is currently failing (e.g. will return `true` inside a\n-/// destructor that is run while unwinding the stack after a call to `fail!()`).\n+/// True if the running task is currently panicking (e.g. will return `true` inside a\n+/// destructor that is run while unwinding the stack after a call to `panic!()`).\n #[unstable = \"May move to a different module.\"]\n pub fn failing() -> bool {\n     use rt::task::Task;\n@@ -420,7 +420,7 @@ mod test {\n         assert!(result.unwrap().is_ok());\n \n         let result = TaskBuilder::new().try_future(proc() -> () {\n-            fail!();\n+            panic!();\n         });\n         assert!(result.unwrap().is_err());\n     }\n@@ -431,17 +431,17 @@ mod test {\n             \"Success!\".to_string()\n         }).as_ref().map(|s| s.as_slice()) {\n             result::Ok(\"Success!\") => (),\n-            _ => fail!()\n+            _ => panic!()\n         }\n     }\n \n     #[test]\n-    fn test_try_fail() {\n+    fn test_try_panic() {\n         match try(proc() {\n-            fail!()\n+            panic!()\n         }) {\n             result::Err(_) => (),\n-            result::Ok(()) => fail!()\n+            result::Ok(()) => panic!()\n         }\n     }\n \n@@ -541,37 +541,37 @@ mod test {\n     }\n \n     #[test]\n-    fn test_try_fail_message_static_str() {\n+    fn test_try_panic_message_static_str() {\n         match try(proc() {\n-            fail!(\"static string\");\n+            panic!(\"static string\");\n         }) {\n             Err(e) => {\n                 type T = &'static str;\n                 assert!(e.is::<T>());\n                 assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n             }\n-            Ok(()) => fail!()\n+            Ok(()) => panic!()\n         }\n     }\n \n     #[test]\n-    fn test_try_fail_message_owned_str() {\n+    fn test_try_panic_message_owned_str() {\n         match try(proc() {\n-            fail!(\"owned string\".to_string());\n+            panic!(\"owned string\".to_string());\n         }) {\n             Err(e) => {\n                 type T = String;\n                 assert!(e.is::<T>());\n                 assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n             }\n-            Ok(()) => fail!()\n+            Ok(()) => panic!()\n         }\n     }\n \n     #[test]\n-    fn test_try_fail_message_any() {\n+    fn test_try_panic_message_any() {\n         match try(proc() {\n-            fail!(box 413u16 as Box<Any + Send>);\n+            panic!(box 413u16 as Box<Any + Send>);\n         }) {\n             Err(e) => {\n                 type T = Box<Any + Send>;\n@@ -580,19 +580,19 @@ mod test {\n                 assert!(any.is::<u16>());\n                 assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n             }\n-            Ok(()) => fail!()\n+            Ok(()) => panic!()\n         }\n     }\n \n     #[test]\n-    fn test_try_fail_message_unit_struct() {\n+    fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n         match try(proc() {\n-            fail!(Juju)\n+            panic!(Juju)\n         }) {\n             Err(ref e) if e.is::<Juju>() => {}\n-            Err(_) | Ok(()) => fail!()\n+            Err(_) | Ok(()) => panic!()\n         }\n     }\n "}, {"sha": "c8b01ce1055bdbddbb3ee23a46c342d21a275a32", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -107,7 +107,7 @@ impl Duration {\n     pub fn seconds(seconds: i64) -> Duration {\n         let d = Duration { secs: seconds, nanos: 0 };\n         if d < MIN || d > MAX {\n-            fail!(\"Duration::seconds out of bounds\");\n+            panic!(\"Duration::seconds out of bounds\");\n         }\n         d\n     }"}, {"sha": "247f50d666e1402000ba4a3bcec7f49262f96576", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -46,13 +46,13 @@\n //! ## Failure Propagation\n //!\n //! In addition to being a core primitive for communicating in rust, channels\n-//! are the points at which failure is propagated among tasks.  Whenever the one\n+//! are the points at which panics are propagated among tasks.  Whenever the one\n //! half of channel is closed, the other half will have its next operation\n-//! `fail!`. The purpose of this is to allow propagation of failure among tasks\n+//! `panic!`. The purpose of this is to allow propagation of panics among tasks\n //! that are linked to one another via channels.\n //!\n //! There are methods on both of senders and receivers to perform their\n-//! respective operations without failing, however.\n+//! respective operations without panicking, however.\n //!\n //! ## Runtime Requirements\n //!\n@@ -102,10 +102,10 @@\n //! }\n //! ```\n //!\n-//! Propagating failure:\n+//! Propagating panics:\n //!\n //! ```should_fail\n-//! // The call to recv() will fail!() because the channel has already hung\n+//! // The call to recv() will panic!() because the channel has already hung\n //! // up (or been deallocated)\n //! let (tx, rx) = channel::<int>();\n //! drop(tx);\n@@ -506,7 +506,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// becomes  \"rendezvous channel\" where each send will not return until a recv\n /// is paired with it.\n ///\n-/// As with asynchronous channels, all senders will fail in `send` if the\n+/// As with asynchronous channels, all senders will panic in `send` if the\n /// `Receiver` has been destroyed.\n ///\n /// # Example\n@@ -550,25 +550,25 @@ impl<T: Send> Sender<T> {\n     ///\n     /// Rust channels are infinitely buffered so this method will never block.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function will fail if the other end of the channel has hung up.\n+    /// This function will panic if the other end of the channel has hung up.\n     /// This means that if the corresponding receiver has fallen out of scope,\n-    /// this function will trigger a fail message saying that a message is\n+    /// this function will trigger a panic message saying that a message is\n     /// being sent on a closed channel.\n     ///\n-    /// Note that if this function does *not* fail, it does not mean that the\n+    /// Note that if this function does *not* panic, it does not mean that the\n     /// data will be successfully received. All sends are placed into a queue,\n     /// so it is possible for a send to succeed (the other end is alive), but\n     /// then the other end could immediately disconnect.\n     ///\n-    /// The purpose of this functionality is to propagate failure among tasks.\n-    /// If failure is not desired, then consider using the `send_opt` method\n+    /// The purpose of this functionality is to propagate panicks among tasks.\n+    /// If a panic is not desired, then consider using the `send_opt` method\n     #[experimental = \"this function is being considered candidate for removal \\\n                       to adhere to the general guidelines of rust\"]\n     pub fn send(&self, t: T) {\n         if self.send_opt(t).is_err() {\n-            fail!(\"sending on a closed channel\");\n+            panic!(\"sending on a closed channel\");\n         }\n     }\n \n@@ -585,9 +585,9 @@ impl<T: Send> Sender<T> {\n     ///\n     /// Like `send`, this method will never block.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This method will never fail, it will return the message back to the\n+    /// This method will never panic, it will return the message back to the\n     /// caller if the other end is disconnected\n     ///\n     /// # Example\n@@ -634,7 +634,7 @@ impl<T: Send> Sender<T> {\n                             }\n                             oneshot::UpDisconnected => (a, Err(t)),\n                             oneshot::UpWoke(task) => {\n-                                // This send cannot fail because the task is\n+                                // This send cannot panic because the task is\n                                 // asleep (we're looking at it), so the receiver\n                                 // can't go away.\n                                 (*a.get()).send(t).ok().unwrap();\n@@ -731,20 +731,20 @@ impl<T: Send> SyncSender<T> {\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Similarly to `Sender::send`, this function will fail if the\n+    /// Similarly to `Sender::send`, this function will panic if the\n     /// corresponding `Receiver` for this channel has disconnected. This\n-    /// behavior is used to propagate failure among tasks.\n+    /// behavior is used to propagate panics among tasks.\n     ///\n-    /// If failure is not desired, you can achieve the same semantics with the\n-    /// `SyncSender::send_opt` method which will not fail if the receiver\n+    /// If a panic is not desired, you can achieve the same semantics with the\n+    /// `SyncSender::send_opt` method which will not panic if the receiver\n     /// disconnects.\n     #[experimental = \"this function is being considered candidate for removal \\\n                       to adhere to the general guidelines of rust\"]\n     pub fn send(&self, t: T) {\n         if self.send_opt(t).is_err() {\n-            fail!(\"sending on a closed channel\");\n+            panic!(\"sending on a closed channel\");\n         }\n     }\n \n@@ -756,9 +756,9 @@ impl<T: Send> SyncSender<T> {\n     /// is returned back to the callee. This function is similar to `try_send`,\n     /// except that it will block if the channel is currently full.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function cannot fail.\n+    /// This function cannot panic.\n     #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         unsafe { (*self.inner.get()).send(t) }\n@@ -774,9 +774,9 @@ impl<T: Send> SyncSender<T> {\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function cannot fail\n+    /// This function cannot panic\n     #[unstable = \"the return type of this function is candidate for \\\n                   modification\"]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n@@ -814,13 +814,13 @@ impl<T: Send> Receiver<T> {\n     /// on the channel from its paired `Sender` structure. This receiver will\n     /// be woken up when data is ready, and the data will be returned.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Similar to channels, this method will trigger a task failure if the\n+    /// Similar to channels, this method will trigger a task panic if the\n     /// other end of the channel has hung up (been deallocated). The purpose of\n-    /// this is to propagate failure among tasks.\n+    /// this is to propagate panicks among tasks.\n     ///\n-    /// If failure is not desired, then there are two options:\n+    /// If a panic is not desired, then there are two options:\n     ///\n     /// * If blocking is still desired, the `recv_opt` method will return `None`\n     ///   when the other end hangs up\n@@ -832,7 +832,7 @@ impl<T: Send> Receiver<T> {\n     pub fn recv(&self) -> T {\n         match self.recv_opt() {\n             Ok(t) => t,\n-            Err(()) => fail!(\"receiving on a closed channel\"),\n+            Err(()) => panic!(\"receiving on a closed channel\"),\n         }\n     }\n \n@@ -845,7 +845,9 @@ impl<T: Send> Receiver<T> {\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n     ///\n-    /// This function cannot fail.\n+    /// # Panics\n+    ///\n+    /// This function cannot panic.\n     #[unstable = \"the return type of this function may be altered\"]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         // If a thread is spinning in try_recv, we should take the opportunity\n@@ -899,15 +901,15 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Attempt to wait for a value on this receiver, but does not fail if the\n+    /// Attempt to wait for a value on this receiver, but does not panic if the\n     /// corresponding channel has hung up.\n     ///\n     /// This implementation of iterators for ports will always block if there is\n-    /// not data available on the receiver, but it will not fail in the case\n+    /// not data available on the receiver, but it will not panic in the case\n     /// that the channel has been deallocated.\n     ///\n     /// In other words, this function has the same semantics as the `recv`\n-    /// method except for the failure aspect.\n+    /// method except for the panic aspect.\n     ///\n     /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n     /// the value found on the receiver is returned.\n@@ -947,7 +949,7 @@ impl<T: Send> Receiver<T> {\n     }\n \n     /// Returns an iterator which will block waiting for messages, but never\n-    /// `fail!`. It will return `None` when the channel has hung up.\n+    /// `panic!`. It will return `None` when the channel has hung up.\n     #[unstable]\n     pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n         Messages { rx: self }\n@@ -1191,7 +1193,7 @@ mod test {\n                 assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n-                Ok(..) => fail!(),\n+                Ok(..) => panic!(),\n                 _ => {}\n             }\n             dtx.send(());\n@@ -1287,7 +1289,7 @@ mod test {\n     } #[should_fail])\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n-        // Receiving on a closed chan will fail\n+        // Receiving on a closed chan will panic\n         let res = task::try(proc() {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n@@ -1711,7 +1713,7 @@ mod sync_tests {\n                 assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n-                Ok(..) => fail!(),\n+                Ok(..) => panic!(),\n                 _ => {}\n             }\n             dtx.send(());\n@@ -1747,7 +1749,7 @@ mod sync_tests {\n     } #[should_fail])\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n-        // Receiving on a closed chan will fail\n+        // Receiving on a closed chan will panic\n         let res = task::try(proc() {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);"}, {"sha": "447585fb2e08760cf905a8fb5505cdcb20abbe8e", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -94,7 +94,7 @@ impl<T: Send> Packet<T> {\n         // Sanity check\n         match self.upgrade {\n             NothingSent => {}\n-            _ => fail!(\"sending on a oneshot that's already sent on \"),\n+            _ => panic!(\"sending on a oneshot that's already sent on \"),\n         }\n         assert!(self.data.is_none());\n         self.data = Some(t);\n@@ -203,7 +203,7 @@ impl<T: Send> Packet<T> {\n         let prev = match self.upgrade {\n             NothingSent => NothingSent,\n             SendUsed => SendUsed,\n-            _ => fail!(\"upgrading again\"),\n+            _ => panic!(\"upgrading again\"),\n         };\n         self.upgrade = GoUp(up);\n "}, {"sha": "f826664308429128fca793331e6e656bd90c5931", "filename": "src/libsync/comm/select.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -102,7 +102,7 @@ pub trait Packet {\n \n impl Select {\n     /// Creates a new selection structure. This set is initially empty and\n-    /// `wait` will fail!() if called.\n+    /// `wait` will panic!() if called.\n     ///\n     /// Usage of this struct directly can sometimes be burdensome, and usage is\n     /// rather much easier through the `select!` macro.\n@@ -353,17 +353,17 @@ mod test {\n         tx1.send(1);\n         select! (\n             foo = rx1.recv() => { assert_eq!(foo, 1); },\n-            _bar = rx2.recv() => { fail!() }\n+            _bar = rx2.recv() => { panic!() }\n         )\n         tx2.send(2);\n         select! (\n-            _foo = rx1.recv() => { fail!() },\n+            _foo = rx1.recv() => { panic!() },\n             bar = rx2.recv() => { assert_eq!(bar, 2) }\n         )\n         drop(tx1);\n         select! (\n             foo = rx1.recv_opt() => { assert_eq!(foo, Err(())); },\n-            _bar = rx2.recv() => { fail!() }\n+            _bar = rx2.recv() => { panic!() }\n         )\n         drop(tx2);\n         select! (\n@@ -379,10 +379,10 @@ mod test {\n         let (tx5, rx5) = channel::<int>();\n         tx5.send(4);\n         select! (\n-            _foo = rx1.recv() => { fail!(\"1\") },\n-            _foo = rx2.recv() => { fail!(\"2\") },\n-            _foo = rx3.recv() => { fail!(\"3\") },\n-            _foo = rx4.recv() => { fail!(\"4\") },\n+            _foo = rx1.recv() => { panic!(\"1\") },\n+            _foo = rx2.recv() => { panic!(\"2\") },\n+            _foo = rx3.recv() => { panic!(\"3\") },\n+            _foo = rx4.recv() => { panic!(\"4\") },\n             foo = rx5.recv() => { assert_eq!(foo, 4); }\n         )\n     })\n@@ -393,7 +393,7 @@ mod test {\n         drop(tx2);\n \n         select! (\n-            _a1 = rx1.recv_opt() => { fail!() },\n+            _a1 = rx1.recv_opt() => { panic!() },\n             a2 = rx2.recv_opt() => { assert_eq!(a2, Err(())); }\n         )\n     })\n@@ -412,12 +412,12 @@ mod test {\n \n         select! (\n             a = rx1.recv() => { assert_eq!(a, 1); },\n-            _b = rx2.recv() => { fail!() }\n+            _b = rx2.recv() => { panic!() }\n         )\n         tx3.send(1);\n         select! (\n             a = rx1.recv_opt() => { assert_eq!(a, Err(())); },\n-            _b = rx2.recv() => { fail!() }\n+            _b = rx2.recv() => { panic!() }\n         )\n     })\n \n@@ -488,7 +488,7 @@ mod test {\n         tx3.send(());\n         select!(\n             _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => fail!()\n+            _i2 = rx2.recv() => panic!()\n         )\n         tx3.send(());\n     })\n@@ -509,7 +509,7 @@ mod test {\n         tx3.send(());\n         select!(\n             _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => fail!()\n+            _i2 = rx2.recv() => panic!()\n         )\n         tx3.send(());\n     })"}, {"sha": "a82efe76289bfb7d6b7aceec23ffa67a094d622e", "filename": "src/libsync/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -299,7 +299,7 @@ impl<T: Send> Packet<T> {\n                     Thread::yield_now();\n                     match self.queue.pop() {\n                         mpsc::Data(t) => { data = t; break }\n-                        mpsc::Empty => fail!(\"inconsistent => empty\"),\n+                        mpsc::Empty => panic!(\"inconsistent => empty\"),\n                         mpsc::Inconsistent => {}\n                     }\n                 }\n@@ -358,7 +358,7 @@ impl<T: Send> Packet<T> {\n         match self.channels.fetch_sub(1, atomic::SeqCst) {\n             1 => {}\n             n if n > 1 => return,\n-            n => fail!(\"bad number of channels left {}\", n),\n+            n => panic!(\"bad number of channels left {}\", n),\n         }\n \n         match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {"}, {"sha": "bbb4813f5f90f965c2268d772de1cbbeb64fb9c6", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -19,7 +19,7 @@\n /// which means that every successful send is paired with a successful recv.\n ///\n /// This flavor of channels defines a new `send_opt` method for channels which\n-/// is the method by which a message is sent but the task does not fail if it\n+/// is the method by which a message is sent but the task does not panic if it\n /// cannot be delivered.\n ///\n /// Another major difference is that send() will *always* return back the data\n@@ -193,7 +193,7 @@ impl<T: Send> Packet<T> {\n             // success, someone's about to receive our buffered data.\n             BlockedReceiver(task) => { wakeup(task, guard); Ok(()) }\n \n-            BlockedSender(..) => fail!(\"lolwut\"),\n+            BlockedSender(..) => panic!(\"lolwut\"),\n         }\n     }\n "}, {"sha": "31889a36dd7abdb87e5d649ed63246dac70e278b", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -467,7 +467,7 @@ mod tests {\n             while left > 0 {\n                 match s.steal() {\n                     Data((1, 10)) => { left -= 1; }\n-                    Data(..) => fail!(),\n+                    Data(..) => panic!(),\n                     Abort | Empty => {}\n                 }\n             }\n@@ -497,7 +497,7 @@ mod tests {\n                             Data(box 20) => {\n                                 (*unsafe_remaining).fetch_sub(1, SeqCst);\n                             }\n-                            Data(..) => fail!(),\n+                            Data(..) => panic!(),\n                             Abort | Empty => {}\n                         }\n                     }\n@@ -508,7 +508,7 @@ mod tests {\n         while remaining.load(SeqCst) > 0 {\n             match w.pop() {\n                 Some(box 20) => { remaining.fetch_sub(1, SeqCst); }\n-                Some(..) => fail!(),\n+                Some(..) => panic!(),\n                 None => {}\n             }\n         }\n@@ -556,7 +556,7 @@ mod tests {\n                 loop {\n                     match s.steal() {\n                         Data(2) => { HITS.fetch_add(1, SeqCst); }\n-                        Data(..) => fail!(),\n+                        Data(..) => panic!(),\n                         _ if DONE.load(SeqCst) => break,\n                         _ => {}\n                     }\n@@ -571,7 +571,7 @@ mod tests {\n                 match w.pop() {\n                     None => {}\n                     Some(2) => { HITS.fetch_add(1, SeqCst); },\n-                    Some(_) => fail!(),\n+                    Some(_) => panic!(),\n                 }\n             } else {\n                 expected += 1;\n@@ -583,7 +583,7 @@ mod tests {\n             match w.pop() {\n                 None => {}\n                 Some(2) => { HITS.fetch_add(1, SeqCst); },\n-                Some(_) => fail!(),\n+                Some(_) => panic!(),\n             }\n         }\n         DONE.store(true, SeqCst);\n@@ -618,7 +618,7 @@ mod tests {\n                             Data((1, 2)) => {\n                                 (*thread_box).fetch_add(1, SeqCst);\n                             }\n-                            Data(..) => fail!(),\n+                            Data(..) => panic!(),\n                             _ if DONE.load(SeqCst) => break,\n                             _ => {}\n                         }\n@@ -635,7 +635,7 @@ mod tests {\n                     match w.pop() {\n                         None => {}\n                         Some((1, 2)) => myhit = true,\n-                        Some(_) => fail!(),\n+                        Some(_) => panic!(),\n                     }\n                 } else {\n                     w.push((1, 2));"}, {"sha": "a9b0b7c48034f31cee3ddf084a358b2c11dcb928", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -12,11 +12,11 @@\n //!\n //! The wrappers in this module build on the primitives from `sync::raw` to\n //! provide safe interfaces around using the primitive locks. These primitives\n-//! implement a technique called \"poisoning\" where when a task failed with a\n-//! held lock, all future attempts to use the lock will fail.\n+//! implement a technique called \"poisoning\" where when a task panicked with a\n+//! held lock, all future attempts to use the lock will panic.\n //!\n-//! For example, if two tasks are contending on a mutex and one of them fails\n-//! after grabbing the lock, the second task will immediately fail because the\n+//! For example, if two tasks are contending on a mutex and one of them panics\n+//! after grabbing the lock, the second task will immediately panic because the\n //! lock is now poisoned.\n \n use core::prelude::*;\n@@ -43,7 +43,7 @@ fn failing() -> bool {\n impl<'a> PoisonOnFail<'a> {\n     fn check(flag: bool, name: &str) {\n         if flag {\n-            fail!(\"Poisoned {} - another task failed inside!\", name);\n+            panic!(\"Poisoned {} - another task failed inside!\", name);\n         }\n     }\n \n@@ -99,10 +99,10 @@ impl<'a> Condvar<'a> {\n     ///\n     /// wait() is equivalent to wait_on(0).\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// A task which is killed while waiting on a condition variable will wake\n-    /// up, fail, and unlock the associated lock as it unwinds.\n+    /// up, panic, and unlock the associated lock as it unwinds.\n     #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n \n@@ -213,12 +213,12 @@ impl<T: Send> Mutex<T> {\n     /// when dropped. All concurrent tasks attempting to lock the mutex will\n     /// block while the returned value is still alive.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Failing while inside the Mutex will unlock the Mutex while unwinding, so\n+    /// Panicking while inside the Mutex will unlock the Mutex while unwinding, so\n     /// that other tasks won't block forever. It will also poison the Mutex:\n     /// any tasks that subsequently try to access it (including those already\n-    /// blocked on the mutex) will also fail immediately.\n+    /// blocked on the mutex) will also panic immediately.\n     #[inline]\n     pub fn lock<'a>(&'a self) -> MutexGuard<'a, T> {\n         let guard = self.lock.lock();\n@@ -317,11 +317,11 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Access the underlying data mutably. Locks the rwlock in write mode;\n     /// other readers and writers will block.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Failing while inside the lock will unlock the lock while unwinding, so\n+    /// Panicking while inside the lock will unlock the lock while unwinding, so\n     /// that other tasks won't block forever. As Mutex.lock, it will also poison\n-    /// the lock, so subsequent readers and writers will both also fail.\n+    /// the lock, so subsequent readers and writers will both also panic.\n     #[inline]\n     pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a, T> {\n         let guard = self.lock.write();\n@@ -496,7 +496,7 @@ mod tests {\n             let lock = arc2.lock();\n             lock.cond.signal();\n             // Parent should fail when it wakes up.\n-            fail!();\n+            panic!();\n         });\n \n         let lock = arc.lock();\n@@ -546,7 +546,7 @@ mod tests {\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n-            fail!();\n+            panic!();\n         });\n         let lock = arc.lock();\n         assert_eq!(*lock, 2);\n@@ -661,7 +661,7 @@ mod tests {\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n-            fail!();\n+            panic!();\n         });\n         let lock = arc.read();\n         assert_eq!(*lock, 2);"}, {"sha": "69dc2fe8e607e359113aded9253306e76709dc01", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -177,7 +177,7 @@ mod tests {\n         let q = Queue::new();\n         match q.pop() {\n             Empty => {}\n-            Inconsistent | Data(..) => fail!()\n+            Inconsistent | Data(..) => panic!()\n         }\n         let (tx, rx) = channel();\n         let q = Arc::new(q);"}, {"sha": "4fd62ac3a1da04d6cfc9a391248011ac36305174", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -216,10 +216,10 @@ pub struct Condvar<'a> {\n impl<'a> Condvar<'a> {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// A task which is killed while waiting on a condition variable will wake\n-    /// up, fail, and unlock the associated lock as it unwinds.\n+    /// up, panic, and unlock the associated lock as it unwinds.\n     pub fn wait(&self) { self.wait_on(0) }\n \n     /// As wait(), but can specify which of multiple condition variables to\n@@ -228,7 +228,7 @@ impl<'a> Condvar<'a> {\n     ///\n     /// The associated lock must have been initialised with an appropriate\n     /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n-    /// or else this call will fail.\n+    /// or else this call will panic.\n     ///\n     /// wait() is equivalent to wait_on(0).\n     pub fn wait_on(&self, condvar_id: uint) {\n@@ -324,7 +324,7 @@ impl<'a> Condvar<'a> {\n     }\n }\n \n-// Checks whether a condvar ID was out of bounds, and fails if so, or does\n+// Checks whether a condvar ID was out of bounds, and panics if so, or does\n // something else next on success.\n #[inline]\n fn check_cvar_bounds<U>(\n@@ -335,9 +335,9 @@ fn check_cvar_bounds<U>(\n                      -> U {\n     match out_of_bounds {\n         Some(0) =>\n-            fail!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n+            panic!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n         Some(length) =>\n-            fail!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n+            panic!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n         None => blk()\n     }\n }\n@@ -367,9 +367,9 @@ pub struct SemaphoreGuard<'a> {\n impl Semaphore {\n     /// Create a new semaphore with the specified count.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// This function will fail if `count` is negative.\n+    /// This function will panic if `count` is negative.\n     pub fn new(count: int) -> Semaphore {\n         Semaphore { sem: Sem::new(count, ()) }\n     }\n@@ -396,8 +396,9 @@ impl Semaphore {\n /// A blocking, bounded-waiting, mutual exclusion lock with an associated\n /// FIFO condition variable.\n ///\n-/// # Failure\n-/// A task which fails while holding a mutex will unlock the mutex as it\n+/// # Panics\n+///\n+/// A task which panicks while holding a mutex will unlock the mutex as it\n /// unwinds.\n pub struct Mutex {\n     sem: Sem<Vec<WaitQueue>>,\n@@ -421,7 +422,7 @@ impl Mutex {\n     /// Create a new mutex, with a specified number of associated condvars. This\n     /// will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n     /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n-    /// allowed but any operations on the condvar will fail.)\n+    /// allowed but any operations on the condvar will panic.)\n     pub fn new_with_condvars(num_condvars: uint) -> Mutex {\n         Mutex { sem: Sem::new_and_signal(1, num_condvars) }\n     }\n@@ -443,9 +444,9 @@ impl Mutex {\n \n /// A blocking, no-starvation, reader-writer lock with an associated condvar.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// A task which fails while holding an rwlock will unlock the rwlock as it\n+/// A task which panics while holding an rwlock will unlock the rwlock as it\n /// unwinds.\n pub struct RWLock {\n     order_lock:  Semaphore,\n@@ -835,13 +836,13 @@ mod tests {\n     fn test_mutex_killed_simple() {\n         use std::any::Any;\n \n-        // Mutex must get automatically unlocked if failed/killed within.\n+        // Mutex must get automatically unlocked if panicked/killed within.\n         let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n \n         let result: result::Result<(), Box<Any + Send>> = task::try(proc() {\n             let _lock = m2.lock();\n-            fail!();\n+            panic!();\n         });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n@@ -1075,13 +1076,13 @@ mod tests {\n     fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         use std::any::Any;\n \n-        // Mutex must get automatically unlocked if failed/killed within.\n+        // Mutex must get automatically unlocked if panicked/killed within.\n         let x = Arc::new(RWLock::new());\n         let x2 = x.clone();\n \n         let result: result::Result<(), Box<Any + Send>> = task::try(proc() {\n             lock_rwlock_in_mode(&x2, mode1, || {\n-                fail!();\n+                panic!();\n             })\n         });\n         assert!(result.is_err());"}, {"sha": "ef0ceb141458b23b5203adea2a4ab626e698f625", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -369,7 +369,7 @@ mod test {\n                     loop {\n                         match consumer.pop() {\n                             Some(1i) => break,\n-                            Some(_) => fail!(),\n+                            Some(_) => panic!(),\n                             None => {}\n                         }\n                     }"}, {"sha": "3bd25d245e175d814fe27db28e19ed0540239e3e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -84,7 +84,7 @@ impl PartialEq for Ident {\n             // one example and its non-hygienic counterpart would be:\n             //      syntax::parse::token::Token::mtwt_eq\n             //      syntax::ext::tt::macro_parser::token_name_eq\n-            fail!(\"not allowed to compare these idents: {}, {}. \\\n+            panic!(\"not allowed to compare these idents: {}, {}. \\\n                    Probably related to issue \\\\#6993\", self, other);\n         }\n     }"}, {"sha": "187d94d1fa7809b58cc5226f31178265df624cec", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -198,17 +198,17 @@ impl<'a> FnLikeNode<'a> {\n                         ident: i.ident, decl: &**decl, style: style, body: &**block,\n                         generics: generics, abi: abi, id: i.id, span: i.span\n                     }),\n-                _ => fail!(\"item FnLikeNode that is not fn-like\"),\n+                _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeTraitItem(t) => match *t {\n                 ast::ProvidedMethod(ref m) => method(&**m),\n-                _ => fail!(\"trait method FnLikeNode that is not fn-like\"),\n+                _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => method(&**m),\n                     ast::TypeImplItem(_) => {\n-                        fail!(\"impl method FnLikeNode that is not fn-like\")\n+                        panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }\n             }\n@@ -217,9 +217,9 @@ impl<'a> FnLikeNode<'a> {\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 ast::ExprProc(ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n-                _ => fail!(\"expr FnLikeNode that is not fn-like\"),\n+                _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },\n-            _ => fail!(\"other FnLikeNode that is not fn-like\"),\n+            _ => panic!(\"other FnLikeNode that is not fn-like\"),\n         }\n     }\n }"}, {"sha": "915c2d1b3188cbcba6cf6e8b140331b73ec7fc2b", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -263,12 +263,12 @@ impl<'ast> Map<'ast> {\n         &self.forest.krate\n     }\n \n-    /// Retrieve the Node corresponding to `id`, failing if it cannot\n+    /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'ast> {\n         match self.find(id) {\n             Some(node) => node,\n-            None => fail!(\"couldn't find node id {} in the AST map\", id)\n+            None => panic!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n@@ -308,7 +308,7 @@ impl<'ast> Map<'ast> {\n         };\n         match abi {\n             Some(abi) => abi,\n-            None => fail!(\"expected foreign mod or inlined parent, found {}\",\n+            None => panic!(\"expected foreign mod or inlined parent, found {}\",\n                           self.node_to_string(parent))\n         }\n     }\n@@ -324,7 +324,7 @@ impl<'ast> Map<'ast> {\n     pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n-            _ => fail!(\"expected item, found {}\", self.node_to_string(id))\n+            _ => panic!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -333,37 +333,37 @@ impl<'ast> Map<'ast> {\n             Some(NodeItem(i)) => {\n                 match i.node {\n                     ItemStruct(ref struct_def, _) => &**struct_def,\n-                    _ => fail!(\"struct ID bound to non-struct\")\n+                    _ => panic!(\"struct ID bound to non-struct\")\n                 }\n             }\n             Some(NodeVariant(variant)) => {\n                 match variant.node.kind {\n                     StructVariantKind(ref struct_def) => &**struct_def,\n-                    _ => fail!(\"struct ID bound to enum variant that isn't struct-like\"),\n+                    _ => panic!(\"struct ID bound to enum variant that isn't struct-like\"),\n                 }\n             }\n-            _ => fail!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n+            _ => panic!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n         }\n     }\n \n     pub fn expect_variant(&self, id: NodeId) -> &'ast Variant {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n-            _ => fail!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n+            _ => panic!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> &'ast ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n-            _ => fail!(\"expected foreign item, found {}\", self.node_to_string(id))\n+            _ => panic!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n         match self.find(id) {\n             Some(NodeExpr(expr)) => expr,\n-            _ => fail!(\"expected expr, found {}\", self.node_to_string(id))\n+            _ => panic!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -388,7 +388,7 @@ impl<'ast> Map<'ast> {\n                                 PathName(ident.name)\n                             }\n                             MethMac(_) => {\n-                                fail!(\"no path elem for {}\", node)\n+                                panic!(\"no path elem for {}\", node)\n                             }\n                         }\n                     }\n@@ -402,13 +402,13 @@ impl<'ast> Map<'ast> {\n                         MethDecl(ident, _, _, _, _, _, _, _) => {\n                             PathName(ident.name)\n                         }\n-                        MethMac(_) => fail!(\"no path elem for {}\", node),\n+                        MethMac(_) => panic!(\"no path elem for {}\", node),\n                     }\n                 }\n                 TypeTraitItem(ref m) => PathName(m.ident.name),\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n-            _ => fail!(\"no path elem for {}\", node)\n+            _ => panic!(\"no path elem for {}\", node)\n         }\n     }\n \n@@ -533,7 +533,7 @@ impl<'ast> Map<'ast> {\n \n     pub fn span(&self, id: NodeId) -> Span {\n         self.opt_span(id)\n-            .unwrap_or_else(|| fail!(\"AstMap.span: could not find span for id {}\", id))\n+            .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {}\", id))\n     }\n \n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n@@ -666,7 +666,7 @@ impl Named for Method {\n     fn name(&self) -> Name {\n         match self.node {\n             MethDecl(i, _, _, _, _, _, _, _) => i.name,\n-            MethMac(_) => fail!(\"encountered unexpanded method macro.\"),\n+            MethMac(_) => panic!(\"encountered unexpanded method macro.\"),\n         }\n     }\n }\n@@ -1018,9 +1018,9 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeLocal(_)       => fail!(\"cannot print isolated Local\"),\n-            NodeArg(_)         => fail!(\"cannot print isolated Arg\"),\n-            NodeStructCtor(_)  => fail!(\"cannot print isolated StructCtor\"),\n+            NodeLocal(_)       => panic!(\"cannot print isolated Local\"),\n+            NodeArg(_)         => panic!(\"cannot print isolated Arg\"),\n+            NodeStructCtor(_)  => panic!(\"cannot print isolated StructCtor\"),\n         }\n     }\n }"}, {"sha": "7e1716e6b18171a3de9df2fb3ebf9713f504d10c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -43,7 +43,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n       StmtDecl(_, id) => id,\n       StmtExpr(_, id) => id,\n       StmtSemi(_, id) => id,\n-      StmtMac(..) => fail!(\"attempted to analyze unexpanded stmt\")\n+      StmtMac(..) => panic!(\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n@@ -233,7 +233,7 @@ pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n                 abi: abi,\n             }\n         },\n-        MethMac(_) => fail!(\"expected non-macro method declaration\")\n+        MethMac(_) => panic!(\"expected non-macro method declaration\")\n     }\n }\n \n@@ -246,7 +246,7 @@ pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n         RequiredMethod(ref m) => (*m).clone(),\n         ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n         TypeTraitItem(_) => {\n-            fail!(\"trait_method_to_ty_method(): expected method but found \\\n+            panic!(\"trait_method_to_ty_method(): expected method but found \\\n                    typedef\")\n         }\n     }\n@@ -615,7 +615,7 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n             slice.iter().all(|p| walk_pat(&**p, |p| it(p))) &&\n             after.iter().all(|p| walk_pat(&**p, |p| it(p)))\n         }\n-        PatMac(_) => fail!(\"attempted to analyze unexpanded pattern\"),\n+        PatMac(_) => panic!(\"attempted to analyze unexpanded pattern\"),\n         PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n         PatEnum(_, _) => {\n             true\n@@ -725,7 +725,7 @@ macro_rules! mf_method{\n             match self.node {\n                 $field_pat => $result,\n                 MethMac(_) => {\n-                    fail!(\"expected an AST without macro invocations\");\n+                    panic!(\"expected an AST without macro invocations\");\n                 }\n             }\n         }"}, {"sha": "7d303644020a47fdbb34da6bf192804b843f7d5c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -425,7 +425,7 @@ impl CodeMap {\n \n         // FIXME #8256: this used to be an assert but whatever precondition\n         // it's testing isn't true for all spans in the AST, so to allow the\n-        // caller to not have to fail (and it can't catch it since the CodeMap\n+        // caller to not have to panic (and it can't catch it since the CodeMap\n         // isn't sendable), return None\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n@@ -441,7 +441,7 @@ impl CodeMap {\n                 return fm.clone();\n             }\n         }\n-        fail!(\"asking for {} which we don't know about\", filename);\n+        panic!(\"asking for {} which we don't know about\", filename);\n     }\n \n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n@@ -503,13 +503,13 @@ impl CodeMap {\n                 break;\n             }\n             if a == 0 {\n-                fail!(\"position {} does not resolve to a source location\",\n+                panic!(\"position {} does not resolve to a source location\",\n                       pos.to_uint());\n             }\n             a -= 1;\n         }\n         if a >= len {\n-            fail!(\"position {} does not resolve to a source location\",\n+            panic!(\"position {} does not resolve to a source location\",\n                   pos.to_uint())\n         }\n "}, {"sha": "e24aa0f0b95870cda55c2218312247cd08a962c3", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -63,7 +63,7 @@ pub trait Emitter {\n                    sp: RenderSpan, msg: &str, lvl: Level);\n }\n \n-/// This structure is used to signify that a task has failed with a fatal error\n+/// This structure is used to signify that a task has panicked with a fatal error\n /// from the diagnostics. You can use this with the `Any` trait to figure out\n /// how a rustc task died (if so desired).\n pub struct FatalError;\n@@ -83,7 +83,7 @@ pub struct SpanHandler {\n impl SpanHandler {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n-        fail!(FatalError);\n+        panic!(FatalError);\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Error);\n@@ -113,7 +113,7 @@ impl SpanHandler {\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        fail!(ExplicitBug);\n+        panic!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, format!(\"unimplemented {}\", msg).as_slice());\n@@ -134,7 +134,7 @@ pub struct Handler {\n impl Handler {\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.emit.borrow_mut().emit(None, msg, None, Fatal);\n-        fail!(FatalError);\n+        panic!(FatalError);\n     }\n     pub fn err(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Error);\n@@ -172,7 +172,7 @@ impl Handler {\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.emit.borrow_mut().emit(None, msg, None, Bug);\n-        fail!(ExplicitBug);\n+        panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n         self.bug(format!(\"unimplemented {}\", msg).as_slice());\n@@ -367,15 +367,15 @@ impl Emitter for EmitterWriter {\n \n         match error {\n             Ok(()) => {}\n-            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n+            Err(e) => panic!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n         match emit(self, cm, sp, msg, None, lvl, true) {\n             Ok(()) => {}\n-            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n+            Err(e) => panic!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n }"}, {"sha": "87406081aae97123dce8c23eaecb69404cac1007", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -741,7 +741,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n     let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n     if expanded_pats.len() == 0 {\n-        fail!(\"encountered match arm with 0 patterns\");\n+        panic!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n@@ -1621,7 +1621,7 @@ mod test {\n                     // good lord, you can't make a path with 0 segments, can you?\n                     let final_varref_ident = match varref.segments.last() {\n                         Some(pathsegment) => pathsegment.identifier,\n-                        None => fail!(\"varref with 0 path segments?\")\n+                        None => panic!(\"varref with 0 path segments?\")\n                     };\n                     let varref_name = mtwt::resolve(final_varref_ident);\n                     let varref_idents : Vec<ast::Ident>\n@@ -1688,7 +1688,7 @@ foo_module!()\n         let cxbinds: &[&ast::Ident] = cxbinds.as_slice();\n         let cxbind = match cxbinds {\n             [b] => b,\n-            _ => fail!(\"expected just one binding for ext_cx\")\n+            _ => panic!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt::resolve(*cxbind);\n         let varrefs = crate_varrefs(&cr);"}, {"sha": "840468176ab0310c0c75e5591084e847edcac0a6", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -211,7 +211,7 @@ fn resolve_internal(id: Ident,\n                     resolvedthis\n                 }\n             }\n-            IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n         }\n     };\n     resolve_table.insert(key, resolved);\n@@ -250,7 +250,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n                     loopvar = tl;\n                 }\n             }\n-            IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n         }\n     }\n }\n@@ -261,7 +261,7 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n         match (*sctable.table.borrow())[ctxt as uint] {\n             Mark(mrk, _) => mrk,\n-            _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n+            _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n     })\n }\n@@ -342,7 +342,7 @@ mod tests {\n                     sc = tail;\n                     continue;\n                 }\n-                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+                IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n             }\n         }\n     }"}, {"sha": "a95a737720a96bb3097414b741fc02899c9bd267", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -366,7 +366,7 @@ pub mod rt {\n                 Some(ast) => ast,\n                 None => {\n                     error!(\"parse error\");\n-                    fail!()\n+                    panic!()\n                 }\n             }\n         }\n@@ -598,7 +598,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec!(mk_name(cx, sp, ident.ident())));\n         }\n \n-        token::Interpolated(_) => fail!(\"quote! with interpolated token\"),\n+        token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n \n         _ => ()\n     }\n@@ -635,7 +635,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Dollar       => \"Dollar\",\n         token::Underscore   => \"Underscore\",\n         token::Eof          => \"Eof\",\n-        _                   => fail!(),\n+        _                   => panic!(),\n     };\n     mk_token_path(cx, sp, name)\n }\n@@ -662,7 +662,7 @@ fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n                 .chain(mk_tt(cx, sp, &close.to_tt()).into_iter())\n                 .collect()\n         },\n-        ast::TtSequence(..) => fail!(\"TtSequence in quote!\"),\n+        ast::TtSequence(..) => panic!(\"TtSequence in quote!\"),\n         ast::TtNonterminal(sp, ident) => {\n             // tt.extend($ident.to_tokens(ext_cx).into_iter())\n "}, {"sha": "9260a45adb954075e849229176d808c4eb222830", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -395,7 +395,7 @@ pub fn parse(sess: &ParseSess,\n                                 token::get_ident(name),\n                                 token::get_ident(bind))).to_string()\n                       }\n-                      _ => fail!()\n+                      _ => panic!()\n                     } }).collect::<Vec<String>>().connect(\" or \");\n                 return Error(sp, format!(\n                     \"local ambiguity: multiple parsing options: \\\n@@ -421,7 +421,7 @@ pub fn parse(sess: &ParseSess,\n                         parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n                   }\n-                  _ => fail!()\n+                  _ => panic!()\n                 }\n                 cur_eis.push(ei);\n "}, {"sha": "85bd5cde3044f1e61c22811ef3e16a89beb5b14c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -39,7 +39,7 @@ impl<'a> ParserAnyMacro<'a> {\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semicolons at the end of normal expressions aren't complained\n     /// about e.g. the semicolon in `macro_rules! kapow( () => {\n-    /// fail!(); } )` doesn't get picked up by .parse_expr(), but it's\n+    /// panic!(); } )` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();"}, {"sha": "47ca66b0b4923cd868aa40966878dae5075b85b0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -171,7 +171,7 @@ pub trait Folder {\n     }\n \n     fn fold_mac(&mut self, _macro: Mac) -> Mac {\n-        fail!(\"fold_mac disabled by default\");\n+        panic!(\"fold_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a folder that\n         // works on macros, use this\n@@ -1404,7 +1404,7 @@ mod test {\n                 let a_val = $a;\n                 let b_val = $b;\n                 if !(pred_val(a_val.as_slice(),b_val.as_slice())) {\n-                    fail!(\"expected args satisfying {}, got {} and {}\",\n+                    panic!(\"expected args satisfying {}, got {} and {}\",\n                           $predname, a_val, b_val);\n                 }\n             }"}, {"sha": "5a7679570bf8d7b7011650566291ab357e7d649e", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -142,7 +142,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         return lines.connect(\"\\n\");\n     }\n \n-    fail!(\"not a doc-comment: {}\", comment);\n+    panic!(\"not a doc-comment: {}\", comment);\n }\n \n fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n@@ -322,7 +322,7 @@ fn consume_comment(rdr: &mut StringReader,\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr_is('#') && rdr.nextch_is('!') {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n-    } else { fail!(); }\n+    } else { panic!(); }\n     debug!(\"<<< consume comment\");\n }\n "}, {"sha": "3a6cf610b4f8b058b0d026b21c7dd9e9bb3609f5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -555,8 +555,8 @@ impl<'a> StringReader<'a> {\n                                                whence: &str) {\n             match r.curr {\n                 Some(r_c) if r_c == c => r.bump(),\n-                Some(r_c) => fail!(\"expected {}, hit {}, {}\", described_c, r_c, whence),\n-                None      => fail!(\"expected {}, hit EOF, {}\", described_c, whence),\n+                Some(r_c) => panic!(\"expected {}, hit {}, {}\", described_c, r_c, whence),\n+                None      => panic!(\"expected {}, hit EOF, {}\", described_c, whence),\n             }\n         }\n \n@@ -577,7 +577,7 @@ impl<'a> StringReader<'a> {\n         self.scan_digits(base);\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n-                fail!(\"expected digits representing a name, got `{}`, {}, range [{},{}]\",\n+                panic!(\"expected digits representing a name, got `{}`, {}, range [{},{}]\",\n                       s, whence, start_bpos, self.last_pos);\n             })\n         });\n@@ -595,7 +595,7 @@ impl<'a> StringReader<'a> {\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n-                fail!(\"expected digits representing a ctxt, got `{}`, {}\", s, whence);\n+                panic!(\"expected digits representing a ctxt, got `{}`, {}\", s, whence);\n             })\n         });\n \n@@ -1542,7 +1542,7 @@ mod test {\n         let mut lexer = setup(&sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n             token::Comment => { },\n-            _ => fail!(\"expected a comment!\")\n+            _ => panic!(\"expected a comment!\")\n         }\n         assert_eq!(lexer.next_token().tok, token::LitChar(token::intern(\"a\")));\n     }"}, {"sha": "c731f3965a0c907eb7d6d1b8dc9fede35de9802d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -65,7 +65,7 @@ impl ParseSess {\n \n         match v.checked_add(&count) {\n             Some(next) => { self.node_id.set(next); }\n-            None => fail!(\"Input too large, ran out of node ids!\")\n+            None => panic!(\"Input too large, ran out of node ids!\")\n         }\n \n         v\n@@ -381,7 +381,7 @@ pub fn char_lit(lit: &str) -> (char, int) {\n             '0' => Some('\\0'),\n             _ => { None }\n         },\n-        _ => fail!(\"lexer accepted invalid char escape `{}`\", lit)\n+        _ => panic!(\"lexer accepted invalid char escape `{}`\", lit)\n     };\n \n     match c {\n@@ -434,19 +434,19 @@ pub fn str_lit(lit: &str) -> String {\n                 match c {\n                     '\\\\' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n-                            fail!(\"{}\", error(i).as_slice())\n+                            panic!(\"{}\", error(i).as_slice())\n                         }).val1();\n \n                         if ch == '\\n' {\n                             eat(&mut chars);\n                         } else if ch == '\\r' {\n                             chars.next();\n                             let ch = chars.peek().unwrap_or_else(|| {\n-                                fail!(\"{}\", error(i).as_slice())\n+                                panic!(\"{}\", error(i).as_slice())\n                             }).val1();\n \n                             if ch != '\\n' {\n-                                fail!(\"lexer accepted bare CR\");\n+                                panic!(\"lexer accepted bare CR\");\n                             }\n                             eat(&mut chars);\n                         } else {\n@@ -460,11 +460,11 @@ pub fn str_lit(lit: &str) -> String {\n                     },\n                     '\\r' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n-                            fail!(\"{}\", error(i).as_slice())\n+                            panic!(\"{}\", error(i).as_slice())\n                         }).val1();\n \n                         if ch != '\\n' {\n-                            fail!(\"lexer accepted bare CR\");\n+                            panic!(\"lexer accepted bare CR\");\n                         }\n                         chars.next();\n                         res.push('\\n');\n@@ -494,7 +494,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n             Some(c) => {\n                 if c == '\\r' {\n                     if *chars.peek().unwrap() != '\\n' {\n-                        fail!(\"lexer accepted bare CR\");\n+                        panic!(\"lexer accepted bare CR\");\n                     }\n                     chars.next();\n                     res.push('\\n');\n@@ -553,11 +553,11 @@ pub fn byte_lit(lit: &str) -> (u8, uint) {\n                 match ::std::num::from_str_radix::<u64>(lit.slice(2, 4), 16) {\n                     Some(c) =>\n                         if c > 0xFF {\n-                            fail!(err(2))\n+                            panic!(err(2))\n                         } else {\n                             return (c as u8, 4)\n                         },\n-                    None => fail!(err(3))\n+                    None => panic!(err(3))\n                 }\n             }\n         };\n@@ -594,7 +594,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n                     b'\\r' => {\n                         chars.next();\n                         if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n-                            fail!(\"lexer accepted bare CR\");\n+                            panic!(\"lexer accepted bare CR\");\n                         }\n                         eat(&mut chars);\n                     }\n@@ -612,7 +612,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n             Some((i, b'\\r')) => {\n                 let em = error(i);\n                 if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n-                    fail!(\"lexer accepted bare CR\");\n+                    panic!(\"lexer accepted bare CR\");\n                 }\n                 chars.next();\n                 res.push(b'\\n');\n@@ -813,7 +813,7 @@ mod test {\n                               ast::TtToken(_, token::Ident(name, token::Plain))],\n                              &ast::Delimiter { token: token::RParen, .. })\n                             if name.as_str() == \"a\" => {},\n-                            _ => fail!(\"value 3: {}\", **first_delimed),\n+                            _ => panic!(\"value 3: {}\", **first_delimed),\n                         }\n                         let (ref second_open, ref second_tts, ref second_close) = **second_delimed;\n                         match (second_open, second_tts.as_slice(), second_close) {\n@@ -822,13 +822,13 @@ mod test {\n                               ast::TtToken(_, token::Ident(name, token::Plain))],\n                              &ast::Delimiter { token: token::RParen, .. })\n                             if name.as_str() == \"a\" => {},\n-                            _ => fail!(\"value 4: {}\", **second_delimed),\n+                            _ => panic!(\"value 4: {}\", **second_delimed),\n                         }\n                     },\n-                    _ => fail!(\"value 2: {}\", **macro_delimed),\n+                    _ => panic!(\"value 2: {}\", **macro_delimed),\n                 }\n             },\n-            _ => fail!(\"value: {}\",tts),\n+            _ => panic!(\"value: {}\",tts),\n         }\n     }\n "}, {"sha": "8ef3a559bf41abda8fbac7a372d4ed1e8eb6f6bc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -5746,7 +5746,7 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n                 IoviForeignItem(_) => {\n-                    fail!();\n+                    panic!();\n                 }\n             }\n             attrs = self.parse_outer_attributes();\n@@ -5769,7 +5769,7 @@ impl<'a> Parser<'a> {\n                     items.push(item)\n                 }\n                 IoviForeignItem(_) => {\n-                    fail!();\n+                    panic!();\n                 }\n             }\n         }"}, {"sha": "57c72ca77c616072695867235d9981986c7fa63f", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -600,7 +600,7 @@ impl Printer {\n           }\n           Eof => {\n             // Eof should never get here.\n-            fail!();\n+            panic!();\n           }\n         }\n     }"}, {"sha": "d347d0199a724797a79615cf7b520b8d8edb0889", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1072,7 +1072,7 @@ impl<'a> State<'a> {\n                     Inconsistent, struct_def.fields.as_slice(),\n                     |s, field| {\n                         match field.node.kind {\n-                            ast::NamedField(..) => fail!(\"unexpected named field\"),\n+                            ast::NamedField(..) => panic!(\"unexpected named field\"),\n                             ast::UnnamedField(vis) => {\n                                 try!(s.print_visibility(vis));\n                                 try!(s.maybe_print_comment(field.span.lo));\n@@ -1093,7 +1093,7 @@ impl<'a> State<'a> {\n \n             for field in struct_def.fields.iter() {\n                 match field.node.kind {\n-                    ast::UnnamedField(..) => fail!(\"unexpected unnamed field\"),\n+                    ast::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     ast::NamedField(ident, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n@@ -1440,7 +1440,7 @@ impl<'a> State<'a> {\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n-                        fail!(\"print_if saw if with weird alternative\");\n+                        panic!(\"print_if saw if with weird alternative\");\n                     }\n                 }\n             }"}, {"sha": "422c2d5c75bd7cefe836cd69ffd3d72cb20a2539", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -99,7 +99,7 @@ impl<T> SmallVector<T> {\n         match self.repr {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => &vs[idx],\n-            _ => fail!(\"out of bounds access\")\n+            _ => panic!(\"out of bounds access\")\n         }\n     }\n \n@@ -110,10 +110,10 @@ impl<T> SmallVector<T> {\n                 if v.len() == 1 {\n                     v.into_iter().next().unwrap()\n                 } else {\n-                    fail!(err)\n+                    panic!(err)\n                 }\n             }\n-            _ => fail!(err)\n+            _ => panic!(err)\n         }\n     }\n "}, {"sha": "bec72e88f99b98560010a38a53a8c5421d562c62", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -103,7 +103,7 @@ pub trait Visitor<'v> {\n         walk_explicit_self(self, es)\n     }\n     fn visit_mac(&mut self, _macro: &'v Mac) {\n-        fail!(\"visit_mac disabled by default\");\n+        panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this"}, {"sha": "a3482dc85c63bcdb5a3351d9589393851a859d44", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -474,7 +474,7 @@ impl FormatOp {\n             'x' => FormatHex,\n             'X' => FormatHEX,\n             's' => FormatString,\n-            _ => fail!(\"bad FormatOp char\")\n+            _ => panic!(\"bad FormatOp char\")\n         }\n     }\n     fn to_char(self) -> char {"}, {"sha": "81d0bb76d1497babe4c89f8ea0e58bd28425529d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -130,7 +130,7 @@ pub trait TDynBenchFn {\n }\n \n // A function that runs a test. If the function returns successfully,\n-// the test succeeds; if the function fails then the test fails. We\n+// the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n pub enum TestFn {\n@@ -235,18 +235,18 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => fail!(\"{}\", msg),\n+            Some(Err(msg)) => panic!(\"{}\", msg),\n             None => return\n         };\n     match run_tests_console(&opts, tests) {\n         Ok(true) => {}\n-        Ok(false) => fail!(\"Some tests failed\"),\n-        Err(e) => fail!(\"io error when running tests: {}\", e),\n+        Ok(false) => panic!(\"Some tests failed\"),\n+        Err(e) => panic!(\"io error when running tests: {}\", e),\n     }\n }\n \n // A variant optimized for invocation with a static test vector.\n-// This will fail (intentionally) when fed any dynamic tests, because\n+// This will panic (intentionally) when fed any dynamic tests, because\n // it is copying the static values out into a dynamic vector and cannot\n // copy dynamic values. It is doing this because from this point on\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n@@ -257,7 +257,7 @@ pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n         match t.testfn {\n             StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n             StaticBenchFn(f) => TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n-            _ => fail!(\"non-static tests passed to test::test_main_static\")\n+            _ => panic!(\"non-static tests passed to test::test_main_static\")\n         }\n     }).collect();\n     test_main(args, owned_tests)\n@@ -352,7 +352,7 @@ Test Attributes:\n     #[bench]       - Indicates a function is a benchmark to be run. This\n                      function takes one argument (test::Bencher).\n     #[should_fail] - This function (also labeled with #[test]) will only pass if\n-                     the code causes a failure (an assertion failure or fail!)\n+                     the code causes a failure (an assertion failure or panic!)\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n@@ -445,7 +445,7 @@ pub fn opt_shard(maybestr: Option<String>) -> Option<(uint,uint)> {\n                    it.next()) {\n                 (Some(a), Some(b), None) => {\n                     if a <= 0 || a > b {\n-                        fail!(\"tried to run shard {a}.{b}, but {a} is out of bounds \\\n+                        panic!(\"tried to run shard {a}.{b}, but {a} is out of bounds \\\n                               (should be between 1 and {b}\", a=a, b=b)\n                     }\n                     Some((a, b))\n@@ -964,7 +964,7 @@ fn get_concurrency() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(s.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => fail!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n+                _ => panic!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n             }\n         }\n         None => {\n@@ -1120,7 +1120,7 @@ impl MetricMap {\n     ///\n     /// # Failure\n     ///\n-    /// This function will fail if the path does not exist or the path does not\n+    /// This function will panic if the path does not exist or the path does not\n     /// contain a valid metric map.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n@@ -1129,7 +1129,7 @@ impl MetricMap {\n         let mut decoder = json::Decoder::new(value);\n         MetricMap(match Decodable::decode(&mut decoder) {\n             Ok(t) => t,\n-            Err(e) => fail!(\"failure decoding JSON: {}\", e)\n+            Err(e) => panic!(\"failure decoding JSON: {}\", e)\n         })\n     }\n \n@@ -1401,7 +1401,7 @@ mod tests {\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { fail!(); }\n+        fn f() { panic!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1435,7 +1435,7 @@ mod tests {\n \n     #[test]\n     fn test_should_fail() {\n-        fn f() { fail!(); }\n+        fn f() { panic!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1472,7 +1472,7 @@ mod tests {\n         let args = vec!(\"progname\".to_string(), \"some_regex_filter\".to_string());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n+            _ => panic!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(opts.filter.expect(\"should've found filter\").is_match(\"some_regex_filter\"))\n     }\n@@ -1484,7 +1484,7 @@ mod tests {\n                         \"--ignored\".to_string());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in parse_ignored_flag\")\n+            _ => panic!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));\n     }"}, {"sha": "590d0bfdcabc42cd610254846f262046074cead8", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -1305,7 +1305,7 @@ mod tests {\n             == Err(InvalidTime));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n-          Err(e) => fail!(e),\n+          Err(e) => panic!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1324,7 +1324,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format).unwrap() == s.to_string(),\n-              Err(e) => fail!(e)\n+              Err(e) => panic!(e)\n             }\n         }\n "}, {"sha": "44d001d45fda24656063404ee45a7692a693251c", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -38,7 +38,7 @@ pub fn alist_get<A:Clone + 'static,\n             return entry.value.clone();\n         }\n     }\n-    fail!();\n+    panic!();\n }\n \n #[inline]"}, {"sha": "bd8857ceef7ea4f55f14b0fa3bb6b9f06edad684", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,5 +10,5 @@\n \n \n pub unsafe fn f(xs: Vec<int> ) {\n-    xs.iter().map(|_x| { unsafe fn q() { fail!(); } }).collect::<Vec<()>>();\n+    xs.iter().map(|_x| { unsafe fn q() { panic!(); } }).collect::<Vec<()>>();\n }"}, {"sha": "fad70a917980d66735b0e8ecbc2319208561745b", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -12,6 +12,6 @@\n #[phase(plugin, link)] extern crate log;\n \n pub fn foo<T>() {\n-    fn death() -> int { fail!() }\n+    fn death() -> int { panic!() }\n     debug!(\"{}\", (||{ death() })());\n }"}, {"sha": "9c0716e2cc2a5e7e92786906e996817858d2d54b", "filename": "src/test/auxiliary/regions-bounded-method-type-parameters-cross-crate-lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -36,7 +36,7 @@ pub trait IntoMaybeOwned<'a> {\n }\n \n impl<'a> IntoMaybeOwned<'a> for Inv<'a> {\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> { fail!() }\n-    fn into_inv(self) -> Inv<'a> { fail!() }\n-    fn bigger_region<'b:'a>(self, b: Inv<'b>) { fail!() }\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { panic!() }\n+    fn into_inv(self) -> Inv<'a> { panic!() }\n+    fn bigger_region<'b:'a>(self, b: Inv<'b>) { panic!() }\n }"}, {"sha": "811d8f116923980eb5cabe6f0fc7a536b609bfa4", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -36,6 +36,6 @@ impl read for bool {\n pub fn read<T:read>(s: String) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n-      _ => fail!(\"read failed!\")\n+      _ => panic!(\"read panicked!\")\n     }\n }"}, {"sha": "6a1f8588b60d74002f10cf696f5d4820c97c0a82", "filename": "src/test/auxiliary/weak-lang-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -28,7 +28,7 @@ impl core::ops::Drop for A {\n \n pub fn foo() {\n     let _a = A;\n-    fail!(\"wut\");\n+    panic!(\"wut\");\n }\n \n mod std {"}, {"sha": "39057215b5e6909b1146caed37946b2c559140b9", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -145,7 +145,7 @@ fn is_utf8_ascii() {\n     for _ in range(0u, 20000) {\n         v.push('b' as u8);\n         if !str::is_utf8(v.as_slice()) {\n-            fail!(\"is_utf8 failed\");\n+            panic!(\"is_utf8 panicked\");\n         }\n     }\n }\n@@ -156,7 +156,7 @@ fn is_utf8_multibyte() {\n     for _ in range(0u, 5000) {\n         v.push_all(s.as_bytes());\n         if !str::is_utf8(v.as_slice()) {\n-            fail!(\"is_utf8 failed\");\n+            panic!(\"is_utf8 panicked\");\n         }\n     }\n }"}, {"sha": "abcd9f90333438473b78e555b1eceae061d5250e", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -90,7 +90,7 @@ fn show_digit(nn: uint) -> &'static str {\n         7 => {\" seven\"}\n         8 => {\" eight\"}\n         9 => {\" nine\"}\n-        _ => {fail!(\"expected digits from 0 to 9...\")}\n+        _ => {panic!(\"expected digits from 0 to 9...\")}\n     }\n }\n "}, {"sha": "d0e6aacdbb2ad0c30a026322913d760808b26087", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -225,7 +225,7 @@ fn pack_symbol(c: u8) -> u8 {\n         'C' => 1,\n         'G' => 2,\n         'T' => 3,\n-        _ => fail!(\"{}\", c as char),\n+        _ => panic!(\"{}\", c as char),\n     }\n }\n "}, {"sha": "6e80c07a1a2aa583c08f76873ad07410308bc27c", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -207,7 +207,7 @@ fn get_id(m: u64) -> u8 {\n     for id in range(0u8, 10) {\n         if m & (1 << (id + 50) as uint) != 0 {return id;}\n     }\n-    fail!(\"{:016x} does not have a valid identifier\", m);\n+    panic!(\"{:016x} does not have a valid identifier\", m);\n }\n \n // Converts a list of mask to a Vec<u8>."}, {"sha": "425b2e3e7140bbb9171a7e6484c94cb4a4867331", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -61,7 +61,7 @@ fn parse_opts(argv: Vec<String> ) -> Config {\n       Ok(ref m) => {\n           return Config {stress: m.opt_present(\"stress\")}\n       }\n-      Err(_) => { fail!(); }\n+      Err(_) => { panic!(); }\n     }\n }\n "}, {"sha": "ae7594ea8a20e74b29cd49e0c71f19ebdfadbcd3", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -83,7 +83,7 @@ impl Sudoku {\n                     from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n-                fail!(\"Invalid sudoku file\");\n+                panic!(\"Invalid sudoku file\");\n             }\n         }\n         return Sudoku::new(g)\n@@ -123,7 +123,7 @@ impl Sudoku {\n                 ptr = ptr + 1u;\n             } else {\n                 // no: redo this field aft recoloring pred; unless there is none\n-                if ptr == 0u { fail!(\"No solution found for this sudoku\"); }\n+                if ptr == 0u { panic!(\"No solution found for this sudoku\"); }\n                 ptr = ptr - 1u;\n             }\n         }"}, {"sha": "5d96c90197cce0390f442855c6f65033e9d3cf00", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -39,7 +39,7 @@ fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n         println!(\"starting {:.4f}\", precise_time_s());\n         task::try(proc() {\n-            recurse_or_fail(depth, None)\n+            recurse_or_panic(depth, None)\n         });\n         println!(\"stopping {:.4f}\", precise_time_s());\n     }\n@@ -70,10 +70,10 @@ fn r(l: Box<nillist>) -> r {\n     }\n }\n \n-fn recurse_or_fail(depth: int, st: Option<State>) {\n+fn recurse_or_panic(depth: int, st: Option<State>) {\n     if depth == 0 {\n         println!(\"unwinding {:.4f}\", precise_time_s());\n-        fail!();\n+        panic!();\n     } else {\n         let depth = depth - 1;\n \n@@ -96,6 +96,6 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n             }\n         };\n \n-        recurse_or_fail(depth, Some(st));\n+        recurse_or_panic(depth, Some(st));\n     }\n }"}, {"sha": "3d2822e14597ff4d8400eb88144d19ac367c1d61", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -51,6 +51,6 @@ fn main() {\n     let (tx, rx) = channel();\n     child_generation(from_str::<uint>(args[1].as_slice()).unwrap(), tx);\n     if rx.recv_opt().is_err() {\n-        fail!(\"it happened when we slumbered\");\n+        panic!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "7e8142dbb2908de386b67d3b067ceaaf3fc8c9f1", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,7 +11,7 @@\n // Tests that a function with a ! annotation always actually fails\n \n fn bad_bang(i: uint) -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    if i < 0u { } else { fail!(); }\n+    if i < 0u { } else { panic!(); }\n }\n \n fn main() { bad_bang(5u); }"}, {"sha": "2a5c7136dc377ba5475ca833b219db6d89768125", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match x {\n         Some((ref _y, _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail!()\n+        None => panic!()\n     }\n }"}, {"sha": "ae568a5277ce8d0e0215fdc3dfc22c1ec2813223", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -22,6 +22,6 @@ fn main() {\n     let x = some2(X { x: () }, X { x: () });\n     match x {\n         some2(ref _y, _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        none2 => fail!()\n+        none2 => panic!()\n     }\n }"}, {"sha": "8c7542fbe6b3d02c1c84aefdb3957891eff73a7c", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match x {\n         Some((_y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail!()\n+        None => panic!()\n     }\n }"}, {"sha": "18534db0dd5a074450bc65b564b45f591d2d5980", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,8 +13,8 @@ fn main() {\n     let x = Some(rx);\n     tx.send(false);\n     match x {\n-        Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n+        Some(z) if z.recv() => { panic!() }, //~ ERROR cannot bind by-move into a pattern guard\n         Some(z) => { assert!(!z.recv()); },\n-        None => fail!()\n+        None => panic!()\n     }\n }"}, {"sha": "3e0cd05cba346b89d98a94e28f058327c932272a", "filename": "src/test/compile-fail/borrowck-anon-fields-variant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,12 +20,12 @@ fn distinct_variant() {\n \n     let a = match y {\n       Y(ref mut a, _) => a,\n-      X => fail!()\n+      X => panic!()\n     };\n \n     let b = match y {\n       Y(_, ref mut b) => b,\n-      X => fail!()\n+      X => panic!()\n     };\n \n     *a += 1;\n@@ -37,12 +37,12 @@ fn same_variant() {\n \n     let a = match y {\n       Y(ref mut a, _) => a,\n-      X => fail!()\n+      X => panic!()\n     };\n \n     let b = match y {\n       Y(ref mut b, _) => b, //~ ERROR cannot borrow\n-      X => fail!()\n+      X => panic!()\n     };\n \n     *a += 1;"}, {"sha": "4c6088969f3595a8c31fcb56f2ce2e55a3f4ae3b", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -28,7 +28,7 @@ fn main() {\n                     x = X(Left((0,0)));\n                     (*f)()\n                 },\n-                _ => fail!()\n+                _ => panic!()\n             }\n         })\n }"}, {"sha": "c071691c94707c0a27c8b2578096fb89495c829d", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -19,7 +19,7 @@ struct Bar {\n   int2: int,\n }\n \n-fn make_foo() -> Box<Foo> { fail!() }\n+fn make_foo() -> Box<Foo> { panic!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();"}, {"sha": "3a85b45ad126dffe44dcaede60251ddfb7ed67fc", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -18,7 +18,7 @@ struct Bar {\n   int2: int,\n }\n \n-fn make_foo() -> Foo { fail!() }\n+fn make_foo() -> Foo { panic!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();"}, {"sha": "febc84ccd44613c8fb7401c8c852cad9c880ca8b", "filename": "src/test/compile-fail/borrowck-closures-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -43,7 +43,7 @@ fn d(x: &mut int) {\n }\n \n fn e(x: &mut int) {\n-    let c1: || = || x = fail!(); //~ ERROR closure cannot assign to immutable local variable\n+    let c1: || = || x = panic!(); //~ ERROR closure cannot assign to immutable local variable\n }\n \n fn main() {"}, {"sha": "8a7ecde700ae6f7cbab94f64f68d198002007978", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,9 +17,9 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail!() }\n-fn for_func(_f: || -> bool) { fail!() }\n-fn produce<T>() -> T { fail!(); }\n+fn cond() -> bool { panic!() }\n+fn for_func(_f: || -> bool) { panic!() }\n+fn produce<T>() -> T { panic!(); }\n \n fn inc(v: &mut Box<int>) {\n     *v = box() (**v + 1);"}, {"sha": "6adcfad33f46c58c582f7ffe1d14538f2cefa762", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,8 +17,8 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail!() }\n-fn produce<T>() -> T { fail!(); }\n+fn cond() -> bool { panic!() }\n+fn produce<T>() -> T { panic!(); }\n \n fn inc(v: &mut Box<int>) {\n     *v = box() (**v + 1);"}, {"sha": "de8c7d9def4e1b709f2441091e18a809c0a42384", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,9 +17,9 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail!() }\n-fn for_func(_f: || -> bool) { fail!() }\n-fn produce<T>() -> T { fail!(); }\n+fn cond() -> bool { panic!() }\n+fn for_func(_f: || -> bool) { panic!() }\n+fn produce<T>() -> T { panic!(); }\n \n fn inc(v: &mut Box<int>) {\n     *v = box() (**v + 1);"}, {"sha": "376832ada4ef5b433cdc38dab5ed796b41353137", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -16,7 +16,7 @@ enum Either<T, U> { Left(T), Right(U) }\n                 *x = Right(1.0);\n                 *z\n             }\n-            _ => fail!()\n+            _ => panic!()\n         }\n     }\n "}, {"sha": "726d4bcdf1d083a222c2680b15e8a1dc49f6fc00", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n         },\n-        None => { fail!() }\n+        None => { panic!() }\n     }\n     println!(\"{}\", *msg);\n }"}, {"sha": "4a5418a4f20c21b3dca027a7bb4415a47514a64d", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -15,7 +15,7 @@ fn a<'a>() -> &'a [int] {\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let tail = match vec {\n         [_, tail..] => tail,\n-        _ => fail!(\"a\")\n+        _ => panic!(\"a\")\n     };\n     tail\n }\n@@ -25,7 +25,7 @@ fn b<'a>() -> &'a [int] {\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let init = match vec {\n         [init.., _] => init,\n-        _ => fail!(\"b\")\n+        _ => panic!(\"b\")\n     };\n     init\n }\n@@ -35,7 +35,7 @@ fn c<'a>() -> &'a [int] {\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let slice = match vec {\n         [_, slice.., _] => slice,\n-        _ => fail!(\"c\")\n+        _ => panic!(\"c\")\n     };\n     slice\n }"}, {"sha": "852eb172c59d10335e37783a4c0f94092c84ea57", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,7 +13,7 @@ fn a<'a>() -> &'a int {\n     let vec: &[int] = vec.as_slice(); //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n         [_a, tail..] => &tail[0],\n-        _ => fail!(\"foo\")\n+        _ => panic!(\"foo\")\n     };\n     tail\n }"}, {"sha": "7a1ebed0a82acb433a9d128ae54485fce6fe090b", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -12,8 +12,8 @@ fn foo(f: || -> !) {}\n \n fn main() {\n     // Type inference didn't use to be able to handle this:\n-    foo(|| fail!());\n-    foo(|| -> ! fail!());\n+    foo(|| panic!());\n+    foo(|| -> ! panic!());\n     foo(|| 22i); //~ ERROR computation may converge in a function marked as diverging\n     foo(|| -> ! 22i); //~ ERROR computation may converge in a function marked as diverging\n     let x = || -> ! 1i; //~ ERROR computation may converge in a function marked as diverging"}, {"sha": "da2e6200eb65f222a90d753236204aeb3f6d4eb2", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-multidispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,7 +20,7 @@ trait MyTrait<T> {\n \n impl<T> MyTrait<T> for T { //~ ERROR E0119\n     fn get(&self) -> T {\n-        fail!()\n+        panic!()\n     }\n }\n "}, {"sha": "3179b1815609f9bbc87a94874dd485e69262d786", "filename": "src/test/compile-fail/dead-code-closure-bang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,7 +11,7 @@\n #![deny(unreachable_code)]\n \n fn main() {\n-    let x: || -> ! = || fail!();\n+    let x: || -> ! = || panic!();\n     x();\n     println!(\"Foo bar\"); //~ ERROR: unreachable statement\n }"}, {"sha": "1c711c0145d90f936d11a375c3294ad47f9956d8", "filename": "src/test/compile-fail/deref-non-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n   match *1 { //~ ERROR: cannot be dereferenced\n-      _ => { fail!(); }\n+      _ => { panic!(); }\n   }\n }"}, {"sha": "49a927b9879e491eb62c98b8f71aebd2f5c217c7", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -18,11 +18,11 @@\n fn foo() { //~ ERROR function is never used\n \n     // none of these should have any dead_code exposed to the user\n-    fail!();\n+    panic!();\n \n-    fail!(\"foo\");\n+    panic!(\"foo\");\n \n-    fail!(\"bar {}\", \"baz\")\n+    panic!(\"bar {}\", \"baz\")\n }\n \n "}, {"sha": "6e5d3a313556e3809e85324e6e03f2b68bb61b8d", "filename": "src/test/compile-fail/fail-no-dead-code.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -14,11 +14,11 @@\n fn foo() { //~ ERROR function is never used\n \n     // none of these should have any dead_code exposed to the user\n-    fail!();\n+    panic!();\n \n-    fail!(\"foo\");\n+    panic!(\"foo\");\n \n-    fail!(\"bar {}\", \"baz\")\n+    panic!(\"bar {}\", \"baz\")\n }\n \n "}, {"sha": "97b709592a9c9434487e739fb6804aeaeac595c4", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,5 +11,5 @@\n \n // error-pattern:unexpected token\n fn main() {\n-  fail!(@);\n+  panic!(@);\n }"}, {"sha": "651072d2118e5f3648070ef49d6018883d2ead93", "filename": "src/test/compile-fail/generic-lifetime-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -23,7 +23,7 @@ trait Foo<'a> {\n }\n \n impl<'a> Foo<'a> for &'a str {\n-    fn bar<T: Bar<'a>>(self) -> &'a str { fail!() } //~ ERROR lifetime\n+    fn bar<T: Bar<'a>>(self) -> &'a str { panic!() } //~ ERROR lifetime\n }\n \n fn main() {"}, {"sha": "2cbb59cc15a204a2e7ae84e2d0ef580c57939144", "filename": "src/test/compile-fail/issue-10392-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-10392-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-10392-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10392-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,7 +10,7 @@\n \n struct A { foo: int }\n \n-fn a() -> A { fail!() }\n+fn a() -> A { panic!() }\n \n fn main() {\n     let A { .., } = a(); //~ ERROR: expected `}`"}, {"sha": "4d0e02c6310c202670c4cbdb62fe624422d47c8d", "filename": "src/test/compile-fail/issue-10392.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-10392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-10392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10392.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,7 +10,7 @@\n \n struct A { foo: int }\n \n-fn a() -> A { fail!() }\n+fn a() -> A { panic!() }\n \n fn main() {\n     let A { , } = a(); //~ ERROR: expected ident"}, {"sha": "55c12b051b94d85bc49e0b3380e1228e7c03a299", "filename": "src/test/compile-fail/issue-11844.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     match a {\n         Ok(a) => //~ ERROR: mismatched types\n             println!(\"{}\",a),\n-        None => fail!()\n+        None => panic!()\n     }\n }\n "}, {"sha": "cc0841a6856caa3bcc4d9d1fc36f7bfaa14a88d4", "filename": "src/test/compile-fail/issue-12116.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -18,7 +18,7 @@ fn tail(source_list: &IntList) -> IntList {\n         &Cons(val, box ref next_list) => tail(next_list),\n         &Cons(val, box Nil)           => Cons(val, box Nil),\n         //~^ ERROR: unreachable pattern\n-        _                          => fail!()\n+        _                          => panic!()\n     }\n }\n "}, {"sha": "74423b041dda327b231e43c827ad48575bcdc59d", "filename": "src/test/compile-fail/issue-12187-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn new<T>() -> &'static T {\n-    fail!()\n+    panic!()\n }\n \n fn main() {"}, {"sha": "af5c8b45a483e4ad118bd3f97ed1415dcf320705", "filename": "src/test/compile-fail/issue-12187-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn new<'r, T>() -> &'r T {\n-    fail!()\n+    panic!()\n }\n \n fn main() {"}, {"sha": "e150c1a0f2fc83f8484419a5fc311f5ca9f416e0", "filename": "src/test/compile-fail/issue-13466.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -16,6 +16,6 @@ pub fn main() {\n     // tricked into looking up a non-existing second type parameter.\n     let _x: uint = match Some(1u) {\n         Ok(u) => u, //~ ERROR  mismatched types: expected `core::option::Option<uint>`\n-        Err(e) => fail!(e)  //~ ERROR mismatched types: expected `core::option::Option<uint>`\n+        Err(e) => panic!(e)  //~ ERROR mismatched types: expected `core::option::Option<uint>`\n     };\n }"}, {"sha": "e64d674b7c862f1c379c33f447c614a461950d13", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -15,7 +15,7 @@ trait vec_monad<A> {\n \n impl<A> vec_monad<A> for Vec<A> {\n     fn bind<B>(&self, f: |A| -> Vec<B> ) {\n-        let mut r = fail!();\n+        let mut r = panic!();\n         for elt in self.iter() { r = r + f(*elt); }\n         //~^ ERROR the type of this value must be known\n         //~^^ ERROR not implemented"}, {"sha": "468fed1eff5ad8d73825f10ea2a2d7dd58777203", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -14,7 +14,7 @@\n \n fn fail_len(v: Vec<int> ) -> uint {\n     let mut i = 3;\n-    fail!();\n+    panic!();\n     for x in v.iter() { i += 1u; }\n     //~^ ERROR: unreachable statement\n     return i;"}, {"sha": "fbd8f9163b5df9a9a5238ac36adc09e9e57414b4", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let x = fail!();\n+    let x = panic!();\n     x.clone(); //~ ERROR the type of this value must be known in this context\n }"}, {"sha": "6291b0240533f2170a02dee2ef9fe7949215a830", "filename": "src/test/compile-fail/issue-2330.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -16,7 +16,7 @@ trait channel<T> {\n \n // `chan` is not a trait, it's an enum\n impl chan for int { //~ ERROR `chan` is not a trait\n-    fn send(&self, v: int) { fail!() }\n+    fn send(&self, v: int) { panic!() }\n }\n \n fn main() {"}, {"sha": "93f38a50b05821f32972530a46f94aae91eb7ee3", "filename": "src/test/compile-fail/issue-2354.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,8 +10,8 @@\n \n fn foo() { //~ NOTE Did you mean to close this delimiter?\n   match Some(x) {\n-      Some(y) { fail!(); }\n-      None    { fail!(); }\n+      Some(y) { panic!(); }\n+      None    { panic!(); }\n }\n \n fn bar() {"}, {"sha": "70ffa86359d5a5a2d9ffe38a43301183f1f12681", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,7 +20,7 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F: Sync, G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Sync`\n+  fn b<F: Sync, G>(_x: F) -> F { panic!() } //~ ERROR type parameter 0 requires `Sync`\n }\n \n fn main() {}"}, {"sha": "2eda5d67edd8e5409353dd8a6b9dc84bc07a34cb", "filename": "src/test/compile-fail/issue-2611-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -21,7 +21,7 @@ struct E {\n \n impl A for E {\n   // n.b. The error message is awful -- see #3404\n-  fn b<F:Clone,G>(&self, _x: G) -> G { fail!() } //~ ERROR method `b` has an incompatible type\n+  fn b<F:Clone,G>(&self, _x: G) -> G { panic!() } //~ ERROR method `b` has an incompatible type\n }\n \n fn main() {}"}, {"sha": "578f100eba40b967e84c5ae098acdbb0606cfe6c", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -23,7 +23,7 @@ fn siphash(k0 : u64) -> SipHash {\n            //~^ ERROR unresolved name `k0`.\n         }\n     }\n-    fail!();\n+    panic!();\n }\n \n fn main() {}"}, {"sha": "2716d49fe69a8d3171883f8d94e6e493dcde7b54", "filename": "src/test/compile-fail/issue-3601.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -38,6 +38,6 @@ fn main() {\n         box Element(ed) => match ed.kind { //~ ERROR non-exhaustive patterns\n             box HTMLImageElement(ref d) if d.image.is_some() => { true }\n         },\n-        _ => fail!(\"WAT\") //~ ERROR unreachable pattern\n+        _ => panic!(\"WAT\") //~ ERROR unreachable pattern\n     };\n }"}, {"sha": "9c31dc1e38ef8ff312193b105a73e9346e9d0153", "filename": "src/test/compile-fail/issue-3668.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,7 +17,7 @@ impl PTrait for P {\n    fn getChildOption(&self) -> Option<Box<P>> {\n        static childVal: Box<P> = self.child.get();\n        //~^ ERROR attempt to use a non-constant value in a constant\n-       fail!();\n+       panic!();\n    }\n }\n "}, {"sha": "0edcfa8a5477d19178891e0275c672f5b904bfe3", "filename": "src/test/compile-fail/issue-5500-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     let a = 5;\n     let _iter = TrieMapIterator{node: &a};\n     _iter.node = & //~ ERROR cannot assign to immutable field\n-    fail!()\n+    panic!()\n }"}, {"sha": "52a57fa2f4411322505b2d23f188990230f8b305", "filename": "src/test/compile-fail/issue-6458-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn foo<T>(t: T) {}\n-fn main() { foo(fail!()) }\n+fn main() { foo(panic!()) }\n     //~^ ERROR type annotations required"}, {"sha": "659b1426bd3f99a86d830adc8ee3c21b2b1f7179", "filename": "src/test/compile-fail/issue-897-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -10,7 +10,7 @@\n \n #![deny(unreachable_code)]\n \n-fn g() -> ! { fail!(); }\n+fn g() -> ! { panic!(); }\n fn f() -> ! {\n     return g(); //~ ERROR `return` in a function declared as diverging\n     g();"}, {"sha": "b9cfbd695b0473049a1963b7c321c43051f41e84", "filename": "src/test/compile-fail/issue-897.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,8 +11,8 @@\n #![deny(unreachable_code)]\n \n fn f() -> ! {\n-    return fail!(); //~ ERROR `return` in a function declared as diverging\n-    fail!(); // the unreachable statement error is in <std macro>, at this line, there\n+    return panic!(); //~ ERROR `return` in a function declared as diverging\n+    panic!(); // the unreachable statement error is in <std macro>, at this line, there\n              // only is a note\n }\n "}, {"sha": "849f337743b77d86e42512594afab680ba8a0fb1", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,13 +11,13 @@\n // Lifetime annotation needed because we have no arguments.\n fn f() -> &int {    //~ ERROR missing lifetime specifier\n //~^ NOTE there is no value for it to be borrowed from\n-    fail!()\n+    panic!()\n }\n \n // Lifetime annotation needed because we have two by-reference parameters.\n fn g(_x: &int, _y: &int) -> &int {    //~ ERROR missing lifetime specifier\n //~^ NOTE the signature does not say whether it is borrowed from `_x` or `_y`\n-    fail!()\n+    panic!()\n }\n \n struct Foo<'a> {\n@@ -28,7 +28,7 @@ struct Foo<'a> {\n // and one on the reference.\n fn h(_x: &Foo) -> &int { //~ ERROR missing lifetime specifier\n //~^ NOTE the signature does not say which one of `_x`'s 2 elided lifetimes it is borrowed from\n-    fail!()\n+    panic!()\n }\n \n fn main() {}"}, {"sha": "df3feefa881f3f28231da76f42a16c03d62c80c4", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -20,7 +20,7 @@ mod foo {\n     }\n }\n \n-fn callback<T>(_f: || -> T) -> T { fail!() }\n+fn callback<T>(_f: || -> T) -> T { panic!() }\n unsafe fn unsf() {}\n \n fn bad1() { unsafe {} }                  //~ ERROR: unnecessary `unsafe` block\n@@ -50,7 +50,7 @@ fn good2() {\n        sure that when purity is inherited that the source of the unsafe-ness\n        is tracked correctly */\n     unsafe {\n-        unsafe fn what() -> Vec<String> { fail!() }\n+        unsafe fn what() -> Vec<String> { panic!() }\n \n         callback(|| {\n             what();"}, {"sha": "55ffdcd7f9fb314a51b242411976726a07c5fd67", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,27 +17,27 @@ struct Private<T>;\n pub struct Public<T>;\n \n impl Private<Public<int>> {\n-    pub fn a(&self) -> Private<int> { fail!() }\n-    fn b(&self) -> Private<int> { fail!() }\n+    pub fn a(&self) -> Private<int> { panic!() }\n+    fn b(&self) -> Private<int> { panic!() }\n \n-    pub fn c() -> Private<int> { fail!() }\n-    fn d() -> Private<int> { fail!() }\n+    pub fn c() -> Private<int> { panic!() }\n+    fn d() -> Private<int> { panic!() }\n }\n impl Private<int> {\n-    pub fn e(&self) -> Private<int> { fail!() }\n-    fn f(&self) -> Private<int> { fail!() }\n+    pub fn e(&self) -> Private<int> { panic!() }\n+    fn f(&self) -> Private<int> { panic!() }\n }\n \n impl Public<Private<int>> {\n-    pub fn a(&self) -> Private<int> { fail!() }\n-    fn b(&self) -> Private<int> { fail!() }\n+    pub fn a(&self) -> Private<int> { panic!() }\n+    fn b(&self) -> Private<int> { panic!() }\n \n-    pub fn c() -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n-    fn d() -> Private<int> { fail!() }\n+    pub fn c() -> Private<int> { panic!() } //~ ERROR private type in exported type signature\n+    fn d() -> Private<int> { panic!() }\n }\n impl Public<int> {\n-    pub fn e(&self) -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n-    fn f(&self) -> Private<int> { fail!() }\n+    pub fn e(&self) -> Private<int> { panic!() } //~ ERROR private type in exported type signature\n+    fn f(&self) -> Private<int> { panic!() }\n }\n \n pub fn x(_: Private<int>) {} //~ ERROR private type in exported type signature\n@@ -70,39 +70,39 @@ enum Qux {\n }\n \n pub trait PubTrait {\n-    fn foo(&self) -> Private<int> { fail!( )} //~ ERROR private type in exported type signature\n+    fn foo(&self) -> Private<int> { panic!( )} //~ ERROR private type in exported type signature\n     fn bar(&self) -> Private<int>; //~ ERROR private type in exported type signature\n     fn baz() -> Private<int>; //~ ERROR private type in exported type signature\n }\n \n impl PubTrait for Public<int> {\n-    fn bar(&self) -> Private<int> { fail!() }\n-    fn baz() -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n+    fn baz() -> Private<int> { panic!() }\n }\n impl PubTrait for Public<Private<int>> {\n-    fn bar(&self) -> Private<int> { fail!() }\n-    fn baz() -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n+    fn baz() -> Private<int> { panic!() }\n }\n \n impl PubTrait for Private<int> {\n-    fn bar(&self) -> Private<int> { fail!() }\n-    fn baz() -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n+    fn baz() -> Private<int> { panic!() }\n }\n impl PubTrait for (Private<int>,) {\n-    fn bar(&self) -> Private<int> { fail!() }\n-    fn baz() -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n+    fn baz() -> Private<int> { panic!() }\n }\n \n \n trait PrivTrait {\n-    fn foo(&self) -> Private<int> { fail!( )}\n+    fn foo(&self) -> Private<int> { panic!( )}\n     fn bar(&self) -> Private<int>;\n }\n impl PrivTrait for Private<int> {\n-    fn bar(&self) -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n }\n impl PrivTrait for (Private<int>,) {\n-    fn bar(&self) -> Private<int> { fail!() }\n+    fn bar(&self) -> Private<int> { panic!() }\n }\n \n pub trait ParamTrait<T> {\n@@ -111,14 +111,14 @@ pub trait ParamTrait<T> {\n \n impl ParamTrait<Private<int>> //~ ERROR private type in exported type signature\n    for Public<int> {\n-    fn foo() -> Private<int> { fail!() }\n+    fn foo() -> Private<int> { panic!() }\n }\n \n impl ParamTrait<Private<int>> for Private<int> {\n-    fn foo() -> Private<int> { fail!( )}\n+    fn foo() -> Private<int> { panic!( )}\n }\n \n impl<T: ParamTrait<Private<int>>>  //~ ERROR private type in exported type signature\n      ParamTrait<T> for Public<i8> {\n-    fn foo() -> T { fail!() }\n+    fn foo() -> T { panic!() }\n }"}, {"sha": "1ad696503e7f9994b5467479ace60a69a27422fc", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,7 +11,7 @@\n fn send<T:Send + std::fmt::Show>(ch: _chan<T>, data: T) {\n     println!(\"{}\", ch);\n     println!(\"{}\", data);\n-    fail!();\n+    panic!();\n }\n \n #[deriving(Show)]\n@@ -24,4 +24,4 @@ fn test00_start(ch: _chan<Box<int>>, message: Box<int>, _count: Box<int>) {\n     println!(\"{}\", message); //~ ERROR use of moved value: `message`\n }\n \n-fn main() { fail!(); }\n+fn main() { panic!(); }"}, {"sha": "8064ef0e427a37e6b300db3e92af6e2612146037", "filename": "src/test/compile-fail/match-join.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,10 +11,10 @@\n // a good test that we merge paths correctly in the presence of a\n // variable that's used before it's declared\n \n-fn my_fail() -> ! { fail!(); }\n+fn my_panic() -> ! { panic!(); }\n \n fn main() {\n-    match true { false => { my_fail(); } true => { } }\n+    match true { false => { my_panic(); } true => { } }\n \n     println!(\"{}\", x); //~ ERROR unresolved name `x`.\n     let x: int;"}, {"sha": "678808f166cde90c7f094e97b7e14241aea31357", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,7 +13,7 @@\n \n \n struct Foo<A> { f: A }\n-fn guard(_s: String) -> bool {fail!()}\n+fn guard(_s: String) -> bool {panic!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "7d209467caf2a6f75cadb25948a6625c02c163d4", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,7 +13,7 @@\n // terms of the binding, not the discriminant.\n \n struct Foo<A> { f: A }\n-fn guard(_s: String) -> bool {fail!()}\n+fn guard(_s: String) -> bool {panic!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "2a73b769895eeeb75be648157400f0bc3d73d75d", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -31,7 +31,7 @@ fn innocent_looking_victim() {\n                     //~^ ERROR: cannot borrow `*f` as mutable because\n                     println!(\"{}\", msg);\n                 },\n-                None => fail!(\"oops\"),\n+                None => panic!(\"oops\"),\n             }\n         }\n     })"}, {"sha": "eb946a90c376c5d3ef4f700ffc27f2988caa903a", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -23,7 +23,7 @@ fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'s\n fn main() {\n     let x = a(c);\n     match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n-        a(d) => { fail!(\"hello\"); }\n-        b => { fail!(\"goodbye\"); }\n+        a(d) => { panic!(\"hello\"); }\n+        b => { panic!(\"goodbye\"); }\n     }\n }"}, {"sha": "2deb9591a834d08082dae64cce1d76e222eebb6f", "filename": "src/test/compile-fail/not-enough-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -13,7 +13,7 @@\n // unrelated errors.\n \n fn foo(a: int, b: int, c: int, d:int) {\n-  fail!();\n+  panic!();\n }\n \n fn main() {"}, {"sha": "7da62ef4db7daf976f6cafed7c850ee3c22f22ea", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -11,7 +11,7 @@\n enum bar { t1((), Option<Vec<int>>), t2, }\n \n // n.b. my change changes this error message, but I think it's right -- tjc\n-fn foo(t: bar) -> int { match t { t1(_, Some(x)) => { return x * 3; } _ => { fail!(); } } }\n+fn foo(t: bar) -> int { match t { t1(_, Some(x)) => { return x * 3; } _ => { panic!(); } } }\n //~^ ERROR binary operation `*` cannot be applied to\n \n fn main() { }"}, {"sha": "7752ea521f7e35a1b1ce1da989bbae1c009498d8", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -17,7 +17,7 @@ fn foo(t: bar) {\n       t1(_, Some::<int>(x)) => {\n         println!(\"{}\", x);\n       }\n-      _ => { fail!(); }\n+      _ => { panic!(); }\n     }\n }\n "}, {"sha": "deae9a83866038256d0fa9785dd93b3b48622b74", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -64,5 +64,5 @@ fn main() {\n }\n \n fn check_pp<T>(expr: T, f: |pprust::ps, T|, expect: str) {\n-    fail!();\n+    panic!();\n }"}, {"sha": "94485dddd136b01c45a2617a341c2182cab84f61", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -57,5 +57,5 @@ fn main() {\n }\n \n fn check_pp<T>(expr: T, f: |pprust::ps, T|, expect: str) {\n-    fail!();\n+    panic!();\n }"}, {"sha": "c2b52b79f6c87cc894c533570e5a15f5f8cba867", "filename": "src/test/compile-fail/regions-fn-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -21,8 +21,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn of<T>() -> |T| { fail!(); }\n-fn subtype<T>(x: |T|) { fail!(); }\n+fn of<T>() -> |T| { panic!(); }\n+fn subtype<T>(x: |T|) { panic!(); }\n \n fn test_fn<'x, 'y, 'z, T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // Here, x, y, and z are free.  Other letters"}, {"sha": "72004f8714c6e361d87eb92def4fed742f0069ed", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -31,17 +31,17 @@ fn want_G(f: G) { }\n \n // Should meet both.\n fn foo(x: &S) -> &'static S {\n-    fail!()\n+    panic!()\n }\n \n // Should meet both.\n fn bar<'a,'b>(x: &'a S) -> &'b S {\n-    fail!()\n+    panic!()\n }\n \n // Meets F, but not G.\n fn baz(x: &S) -> &S {\n-    fail!()\n+    panic!()\n }\n \n fn supply_F() {"}, {"sha": "8e8d892a39f22dd0f4a5d5189c804e3690d8d755", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn of<'a,T>() -> |T|:'a { fail!(); }\n-fn subtype<T>(x: |T|) { fail!(); }\n+fn of<'a,T>() -> |T|:'a { panic!(); }\n+fn subtype<T>(x: |T|) { panic!(); }\n \n fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // Here, x, y, and z are free.  Other letters"}, {"sha": "435d10a0a29a1c07db7a43a40d2ca3bfee547143", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -27,7 +27,7 @@ fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n     // Do not infer an ordering from the return value.\n     let z: &'b uint = &*x;\n     //~^ ERROR cannot infer\n-    fail!();\n+    panic!();\n }\n \n fn ordering4<'a, 'b>(a: &'a uint, b: &'b uint, x: |&'a &'b uint|) {"}, {"sha": "a9df449032e6fef4d9a22e03b57131458ed0ee03", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7828c3dd2858d8f3a0448484d8093e22719dbda0/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=7828c3dd2858d8f3a0448484d8093e22719dbda0", "patch": "@@ -15,7 +15,7 @@\n use std::vec::Vec;\n \n fn last<T>(v: Vec<&T> ) -> std::option::Option<T> {\n-    fail!();\n+    panic!();\n }\n \n fn main() {"}]}