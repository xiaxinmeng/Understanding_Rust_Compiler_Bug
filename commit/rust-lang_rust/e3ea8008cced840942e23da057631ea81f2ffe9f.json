{"sha": "e3ea8008cced840942e23da057631ea81f2ffe9f", "node_id": "C_kwDOAAsO6NoAKGUzZWE4MDA4Y2NlZDg0MDk0MmUyM2RhMDU3NjMxZWE4MWYyZmZlOWY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-08T06:25:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-08T06:25:06Z"}, "message": "Rollup merge of #101153 - IntQuant:issue-100717-infer-2, r=davidtwco\n\nMigrate another part of rustc_infer to session diagnostic\n\nProbably will migrate another file before marking this one as ready-to-merge.\n\n`@rustbot` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717", "tree": {"sha": "7c062bbf1a401e16d002bd3dcfbab2c44dd3b9f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c062bbf1a401e16d002bd3dcfbab2c44dd3b9f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3ea8008cced840942e23da057631ea81f2ffe9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjGYrCCRBK7hj4Ov3rIwAAI4UIAEGSHMdnwQNmy2uXqSnOa/Mh\nglNyDt97okzDXj1/vW3yVsArtKpQRUn41R3zXmCcSIeprWriqdEYi5OZ9vPg2B/n\nQoK/A+WTHGhWkhe4NVotL5u/MctndFHJsRRPkeu6ypi6xakRKxnczCO/fPtAR9fP\nCsVc/0+roCS3+j2UOEWDmaUQRLDPrAGghys9BJA/QoMUfaus4UQcsw3Ql/4jQXVO\noBQNqCtY/OoBAzWrj0I/rLfKwVtLheKwLGakPAazruXFSp7UdwG3ywNnSbOULb6K\n46MkqMxGS37m9HXg7YkCJl0+h4i+ngIl7IziUzQsPZh8wT9QAd+22d7RtsOyzRQ=\n=2tLb\n-----END PGP SIGNATURE-----\n", "payload": "tree 7c062bbf1a401e16d002bd3dcfbab2c44dd3b9f9\nparent 4af35b8e3017cb080630942d1c2b7045c74e450a\nparent 3d70be7240b826c54411c76d18d3b203f657425a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1662618306 +0530\ncommitter GitHub <noreply@github.com> 1662618306 +0530\n\nRollup merge of #101153 - IntQuant:issue-100717-infer-2, r=davidtwco\n\nMigrate another part of rustc_infer to session diagnostic\n\nProbably will migrate another file before marking this one as ready-to-merge.\n\n`@rustbot` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ea8008cced840942e23da057631ea81f2ffe9f", "html_url": "https://github.com/rust-lang/rust/commit/e3ea8008cced840942e23da057631ea81f2ffe9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3ea8008cced840942e23da057631ea81f2ffe9f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af35b8e3017cb080630942d1c2b7045c74e450a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af35b8e3017cb080630942d1c2b7045c74e450a", "html_url": "https://github.com/rust-lang/rust/commit/4af35b8e3017cb080630942d1c2b7045c74e450a"}, {"sha": "3d70be7240b826c54411c76d18d3b203f657425a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d70be7240b826c54411c76d18d3b203f657425a", "html_url": "https://github.com/rust-lang/rust/commit/3d70be7240b826c54411c76d18d3b203f657425a"}], "stats": {"total": 1202, "additions": 805, "deletions": 397}, "files": [{"sha": "2899b8304bc14884338564a480a2ffc54cdaec05", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -104,9 +104,67 @@ infer_relate_object_bound = ...so that it can be closed over into an object\n infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-[true] ...\n-*[false] {\"\"}\n+    [true] ...\n+    *[false] {\"\"}\n }\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+\n+infer_nothing = {\"\"}\n+\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] -> {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] -> {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [reempty] the empty lifetime\n+    [reemptyuni] the empty lifetime in universe {$desc_arg}\n+    [revar] lifetime {$desc_arg}\n+\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+}\n+\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n+infer_msl_impl_note = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/4af35b8e3017cb080630942d1c2b7045c74e450a/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af35b8e3017cb080630942d1c2b7045c74e450a/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=4af35b8e3017cb080630942d1c2b7045c74e450a", "patch": "@@ -1,254 +0,0 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n-use rustc_hir::FnRetTy;\n-use rustc_macros::SessionDiagnostic;\n-use rustc_span::{BytePos, Span};\n-\n-use crate::infer::error_reporting::{\n-    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n-    ObligationCauseAsDiagArg,\n-};\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::opaque_hidden_type)]\n-pub struct OpaqueHiddenTypeDiag {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[note(infer::opaque_type)]\n-    pub opaque_type: Span,\n-    #[note(infer::hidden_type)]\n-    pub hidden_type: Span,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0282\")]\n-pub struct AnnotationRequired<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0283\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0283\")]\n-pub struct AmbigousImpl<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0284\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0284\")]\n-pub struct AmbigousReturn<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n-pub struct NeedTypeInfoInGenerator<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub generator_kind: GeneratorKindAsDiagArg,\n-    #[subdiagnostic]\n-    pub bad_label: InferenceBadError<'a>,\n-}\n-\n-// Used when a better one isn't available\n-#[derive(SessionSubdiagnostic)]\n-#[label(infer::label_bad)]\n-pub struct InferenceBadError<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub bad_kind: &'static str,\n-    pub prefix_kind: UnderspecifiedArgKind,\n-    pub has_parent: bool,\n-    pub prefix: &'a str,\n-    pub parent_prefix: &'a str,\n-    pub parent_name: String,\n-    pub name: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-pub enum SourceKindSubdiag<'a> {\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_let,\n-        code = \": {type_name}\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    LetLike {\n-        #[primary_span]\n-        span: Span,\n-        name: String,\n-        type_name: String,\n-        kind: &'static str,\n-        x_kind: &'static str,\n-        prefix_kind: UnderspecifiedArgKind,\n-        prefix: &'a str,\n-        arg_name: String,\n-    },\n-    #[label(infer::source_kind_subdiag_generic_label)]\n-    GenericLabel {\n-        #[primary_span]\n-        span: Span,\n-        is_type: bool,\n-        param_name: String,\n-        parent_exists: bool,\n-        parent_prefix: String,\n-        parent_name: String,\n-    },\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_generic_suggestion,\n-        code = \"::<{args}>\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    GenericSuggestion {\n-        #[primary_span]\n-        span: Span,\n-        arg_count: usize,\n-        args: String,\n-    },\n-}\n-\n-// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n-// Would be a part of `SourceKindSubdiag` otherwise.\n-pub enum SourceKindMultiSuggestion<'a> {\n-    FullyQualified {\n-        span: Span,\n-        def_path: String,\n-        adjustment: &'a str,\n-        successor: (&'a str, BytePos),\n-    },\n-    ClosureReturn {\n-        ty_info: String,\n-        data: &'a FnRetTy<'a>,\n-        should_wrap_expr: Option<Span>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        match self {\n-            Self::FullyQualified { span, def_path, adjustment, successor } => {\n-                let suggestion = vec![\n-                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_fully_qualified,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n-                };\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_closure_return,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-pub enum RegionOriginNote<'a> {\n-    Plain {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    },\n-    WithName {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-        name: &'a str,\n-        continues: bool,\n-    },\n-    WithRequirement {\n-        span: Span,\n-        requirement: ObligationCauseAsDiagArg<'a>,\n-        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for RegionOriginNote<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        let mut label_or_note = |span, msg: DiagnosticMessage| {\n-            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n-            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n-            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n-            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n-                diag.span_label(span, msg);\n-            } else if span_is_primary && expanded_sub_count == 0 {\n-                diag.note(msg);\n-            } else {\n-                diag.span_note(span, msg);\n-            }\n-        };\n-        match self {\n-            RegionOriginNote::Plain { span, msg } => {\n-                label_or_note(span, msg);\n-            }\n-            RegionOriginNote::WithName { span, msg, name, continues } => {\n-                label_or_note(span, msg);\n-                diag.set_arg(\"name\", name);\n-                diag.set_arg(\"continues\", continues);\n-            }\n-            RegionOriginNote::WithRequirement {\n-                span,\n-                requirement,\n-                expected_found: Some((expected, found)),\n-            } => {\n-                label_or_note(span, fluent::infer::subtype);\n-                diag.set_arg(\"requirement\", requirement);\n-\n-                diag.note_expected_found(&\"\", expected, &\"\", found);\n-            }\n-            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n-                // FIXME: this really should be handled at some earlier stage. Our\n-                // handling of region checking when type errors are present is\n-                // *terrible*.\n-                label_or_note(span, fluent::infer::subtype_2);\n-                diag.set_arg(\"requirement\", requirement);\n-            }\n-        };\n-    }\n-}"}, {"sha": "d232a186462444ada7ab0accb711002623226c5c", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -0,0 +1,499 @@\n+use hir::GenericParamKind;\n+use rustc_errors::{\n+    fluent, AddSubdiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::{FnRetTy, Ty};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_span::symbol::kw;\n+use rustc_span::{symbol::Ident, BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+pub mod note_and_explain;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindMultiSuggestion<'a> {\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_fully_qualified,\n+        applicability = \"has-placeholders\"\n+    )]\n+    FullyQualified {\n+        #[suggestion_part(code = \"{def_path}({adjustment}\")]\n+        span_lo: Span,\n+        #[suggestion_part(code = \"{successor_pos}\")]\n+        span_hi: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor_pos: &'a str,\n+    },\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_closure_return,\n+        applicability = \"has-placeholders\"\n+    )]\n+    ClosureReturn {\n+        #[suggestion_part(code = \"{start_span_code}\")]\n+        start_span: Span,\n+        start_span_code: String,\n+        #[suggestion_part(code = \" }}\")]\n+        end_span: Option<Span>,\n+    },\n+}\n+\n+impl<'a> SourceKindMultiSuggestion<'a> {\n+    pub fn new_fully_qualified(\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    ) -> Self {\n+        Self::FullyQualified {\n+            span_lo: span.shrink_to_lo(),\n+            span_hi: span.shrink_to_hi().with_hi(successor.1),\n+            def_path,\n+            adjustment,\n+            successor_pos: successor.0,\n+        }\n+    }\n+\n+    pub fn new_closure_return(\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    ) -> Self {\n+        let (arrow, post) = match data {\n+            FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+            _ => (\"\", \"\"),\n+        };\n+        let (start_span, start_span_code, end_span) = match should_wrap_expr {\n+            Some(end_span) => {\n+                (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post), Some(end_span))\n+            }\n+            None => (data.span(), format!(\"{}{}{}\", arrow, ty_info, post), None),\n+        };\n+        Self::ClosureReturn { start_span, start_span_code, end_span }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}\n+\n+pub enum LifetimeMismatchLabels {\n+    InRet {\n+        param_span: Span,\n+        ret_span: Span,\n+        span: Span,\n+        label_var1: Option<Ident>,\n+    },\n+    Normal {\n+        hir_equal: bool,\n+        ty_sup: Span,\n+        ty_sub: Span,\n+        span: Span,\n+        sup: Option<Ident>,\n+        sub: Option<Ident>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for LifetimeMismatchLabels {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n+                diag.span_label(param_span, fluent::infer::declared_different);\n+                diag.span_label(ret_span, fluent::infer::nothing);\n+                diag.span_label(span, fluent::infer::data_returned);\n+                diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n+            }\n+            LifetimeMismatchLabels::Normal {\n+                hir_equal,\n+                ty_sup,\n+                ty_sub,\n+                span,\n+                sup: label_var1,\n+                sub: label_var2,\n+            } => {\n+                if hir_equal {\n+                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                } else {\n+                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                    diag.set_arg(\n+                        \"label_var1\",\n+                        label_var1.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                    diag.set_arg(\"label_var2_exists\", label_var2.is_some());\n+                    diag.set_arg(\n+                        \"label_var2\",\n+                        label_var2.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AddLifetimeParamsSuggestion<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub sub: Region<'a>,\n+    pub ty_sup: &'a Ty<'a>,\n+    pub ty_sub: &'a Ty<'a>,\n+    pub add_note: bool,\n+}\n+\n+impl AddSubdiagnostic for AddLifetimeParamsSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut mk_suggestion = || {\n+            let (\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n+            ) = (self.ty_sub, self.ty_sup) else {\n+                return false;\n+            };\n+\n+            if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n+                return false;\n+            };\n+\n+            let Some(anon_reg) = self.tcx.is_suitable_region(self.sub) else {\n+                return false;\n+            };\n+\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+\n+            let node = self.tcx.hir().get(hir_id);\n+            let is_impl = matches!(&node, hir::Node::ImplItem(_));\n+            let generics = match node {\n+                hir::Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Fn(_, ref generics, ..),\n+                    ..\n+                })\n+                | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n+                | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n+                _ => return false,\n+            };\n+\n+            let suggestion_param_name = generics\n+                .params\n+                .iter()\n+                .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+                .map(|p| p.name.ident().name)\n+                .find(|i| *i != kw::UnderscoreLifetime);\n+            let introduce_new = suggestion_param_name.is_none();\n+            let suggestion_param_name =\n+                suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+            debug!(?lifetime_sup.span);\n+            debug!(?lifetime_sub.span);\n+            let make_suggestion = |span: rustc_span::Span| {\n+                if span.is_empty() {\n+                    (span, format!(\"{}, \", suggestion_param_name))\n+                } else if let Ok(\"&\") = self.tcx.sess.source_map().span_to_snippet(span).as_deref()\n+                {\n+                    (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n+                } else {\n+                    (span, suggestion_param_name.clone())\n+                }\n+            };\n+            let mut suggestions =\n+                vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n+\n+            if introduce_new {\n+                let new_param_suggestion = if let Some(first) =\n+                    generics.params.iter().find(|p| !p.name.ident().span.is_empty())\n+                {\n+                    (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+                } else {\n+                    (generics.span, format!(\"<{}>\", suggestion_param_name))\n+                };\n+\n+                suggestions.push(new_param_suggestion);\n+            }\n+\n+            diag.multipart_suggestion(\n+                fluent::infer::lifetime_param_suggestion,\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.set_arg(\"is_impl\", is_impl);\n+            true\n+        };\n+        if mk_suggestion() && self.add_note {\n+            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+pub struct LifetimeMismatch<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub labels: LifetimeMismatchLabels,\n+    #[subdiagnostic]\n+    pub suggestion: AddLifetimeParamsSuggestion<'a>,\n+}\n+\n+pub struct IntroducesStaticBecauseUnmetLifetimeReq {\n+    pub unmet_requirements: MultiSpan,\n+    pub binding_span: Span,\n+}\n+\n+impl AddSubdiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n+    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+        self.unmet_requirements\n+            .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n+        diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n+    }\n+}\n+\n+pub struct ImplNote {\n+    pub impl_span: Option<Span>,\n+}\n+\n+impl AddSubdiagnostic for ImplNote {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self.impl_span {\n+            Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n+            None => diag.note(fluent::infer::msl_impl_note),\n+        };\n+    }\n+}\n+\n+pub enum TraitSubdiag {\n+    Note { span: Span },\n+    Sugg { span: Span },\n+}\n+\n+// FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n+impl AddSubdiagnostic for TraitSubdiag {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            TraitSubdiag::Note { span } => {\n+                diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");\n+            }\n+            TraitSubdiag::Sugg { span } => {\n+                diag.span_suggestion_verbose(\n+                    span,\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_owned(),\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::mismatched_static_lifetime)]\n+pub struct MismatchedStaticLifetime<'a> {\n+    #[primary_span]\n+    pub cause_span: Span,\n+    #[subdiagnostic]\n+    pub unmet_lifetime_reqs: IntroducesStaticBecauseUnmetLifetimeReq,\n+    #[subdiagnostic]\n+    pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n+    #[subdiagnostic]\n+    pub impl_note: ImplNote,\n+    #[subdiagnostic]\n+    pub trait_subdiags: Vec<TraitSubdiag>,\n+}"}, {"sha": "6f1f9522c869da5a472f7f895f735fe099b26f04", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -0,0 +1,179 @@\n+use crate::infer::error_reporting::nice_region_error::find_anon_type;\n+use rustc_errors::{self, fluent, AddSubdiagnostic, IntoDiagnosticArg};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{symbol::kw, Span};\n+\n+#[derive(Default)]\n+struct DescriptionCtx<'a> {\n+    span: Option<Span>,\n+    kind: &'a str,\n+    arg: String,\n+    num_arg: u32,\n+}\n+\n+impl<'a> DescriptionCtx<'a> {\n+    fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        me.span = alt_span;\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                return Self::from_early_bound_and_free_regions(tcx, region);\n+            }\n+            ty::ReStatic => {\n+                me.kind = \"restatic\";\n+            }\n+\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => me.kind = \"reempty\",\n+\n+            ty::ReEmpty(ui) => {\n+                me.kind = \"reemptyuni\";\n+                me.arg = format!(\"{:?}\", ui);\n+            }\n+\n+            ty::RePlaceholder(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                me.kind = \"revar\";\n+                me.arg = format!(\"{:?}\", region);\n+            }\n+        };\n+        Some(me)\n+    }\n+\n+    fn from_early_bound_and_free_regions<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        let scope = region.free_region_binding_scope(tcx).expect_local();\n+        match *region {\n+            ty::ReEarlyBound(ref br) => {\n+                let mut sp = tcx.def_span(scope);\n+                if let Some(param) =\n+                    tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+                {\n+                    sp = param.span;\n+                }\n+                if br.has_name() {\n+                    me.kind = \"as_defined\";\n+                    me.arg = br.name.to_string();\n+                } else {\n+                    me.kind = \"as_defined_anon\";\n+                };\n+                me.span = Some(sp)\n+            }\n+            ty::ReFree(ref fr) => {\n+                if !fr.bound_region.is_named()\n+                    && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n+                {\n+                    me.kind = \"defined_here\";\n+                    me.span = Some(ty.span);\n+                } else {\n+                    match fr.bound_region {\n+                        ty::BoundRegionKind::BrNamed(_, name) => {\n+                            let mut sp = tcx.def_span(scope);\n+                            if let Some(param) =\n+                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            {\n+                                sp = param.span;\n+                            }\n+                            if name == kw::UnderscoreLifetime {\n+                                me.kind = \"as_defined_anon\";\n+                            } else {\n+                                me.kind = \"as_defined\";\n+                                me.arg = name.to_string();\n+                            };\n+                            me.span = Some(sp);\n+                        }\n+                        ty::BrAnon(idx) => {\n+                            me.kind = \"anon_num_here\";\n+                            me.num_arg = idx+1;\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                        _ => {\n+                            me.kind = \"defined_here_reg\";\n+                            me.arg = region.to_string();\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                    }\n+                }\n+            }\n+            _ => bug!(),\n+        }\n+        Some(me)\n+    }\n+\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.set_arg(\"desc_kind\", self.kind);\n+        diag.set_arg(\"desc_arg\", self.arg);\n+        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+    }\n+}\n+\n+pub enum PrefixKind {\n+    Empty,\n+}\n+\n+pub enum SuffixKind {\n+    Continues,\n+}\n+\n+impl IntoDiagnosticArg for PrefixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Empty => \"empty\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for SuffixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Continues => \"continues\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+pub struct RegionExplanation<'a> {\n+    desc: DescriptionCtx<'a>,\n+    prefix: PrefixKind,\n+    suffix: SuffixKind,\n+}\n+\n+impl RegionExplanation<'_> {\n+    pub fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+        prefix: PrefixKind,\n+        suffix: SuffixKind,\n+    ) -> Option<Self> {\n+        Some(Self { desc: DescriptionCtx::new(tcx, region, alt_span)?, prefix, suffix })\n+    }\n+}\n+\n+impl AddSubdiagnostic for RegionExplanation<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        if let Some(span) = self.desc.span {\n+            diag.span_note(span, fluent::infer::region_explanation);\n+        } else {\n+            diag.note(fluent::infer::region_explanation);\n+        }\n+        self.desc.add_to(diag);\n+        diag.set_arg(\"pref_kind\", self.prefix);\n+        diag.set_arg(\"suff_kind\", self.suffix);\n+    }\n+}"}, {"sha": "cb2be93589d051b13da021d5a363b9416dd577c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -511,20 +511,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n-                    span: receiver.span,\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_fully_qualified(\n+                    receiver.span,\n                     def_path,\n                     adjustment,\n                     successor,\n-                });\n+                ));\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n                 let ty_info = ty_to_string(self, ty);\n-                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_closure_return(\n                     ty_info,\n                     data,\n                     should_wrap_expr,\n-                });\n+                ));\n             }\n         }\n         match error_code {"}, {"sha": "3a4320a9a8f1d23f3d8874cf5fc8ba5d36e34303", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 31, "deletions": 116, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -1,18 +1,20 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::errors::AddLifetimeParamsSuggestion;\n+use crate::errors::LifetimeMismatch;\n+use crate::errors::LifetimeMismatchLabels;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n use crate::infer::TyCtxt;\n \n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n-use rustc_hir as hir;\n-use rustc_hir::{GenericParamKind, Ty};\n+use rustc_errors::AddSubdiagnostic;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_hir::Ty;\n use rustc_middle::ty::Region;\n-use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -98,137 +100,50 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n-        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n         debug!(\n             \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n             sub_is_ret_type, sup_is_ret_type\n         );\n \n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        match (sup_is_ret_type, sub_is_ret_type) {\n+        let labels = match (sup_is_ret_type, sub_is_ret_type) {\n             (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n                 let param_span =\n                     if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n-\n-                err.span_label(\n+                LifetimeMismatchLabels::InRet {\n                     param_span,\n-                    \"this parameter and the return type are declared with different lifetimes...\",\n-                );\n-                err.span_label(ret_span, \"\");\n-                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n-            }\n-\n-            (None, None) => {\n-                if ty_sup.hir_id == ty_sub.hir_id {\n-                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n-                } else {\n-                    err.span_label(\n-                        ty_sup.span,\n-                        \"these two types are declared with different lifetimes...\",\n-                    );\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(\n-                        span,\n-                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                    );\n+                    ret_span,\n+                    span,\n+                    label_var1: anon_param_sup.pat.simple_ident(),\n                 }\n             }\n-        }\n \n-        if suggest_adding_lifetime_params(self.tcx(), sub, ty_sup, ty_sub, &mut err) {\n-            err.note(\"each elided lifetime in input position becomes a distinct lifetime\");\n-        }\n+            (None, None) => LifetimeMismatchLabels::Normal {\n+                hir_equal: ty_sup.hir_id == ty_sub.hir_id,\n+                ty_sup: ty_sup.span,\n+                ty_sub: ty_sub.span,\n+                span,\n+                sup: anon_param_sup.pat.simple_ident(),\n+                sub: anon_param_sub.pat.simple_ident(),\n+            },\n+        };\n \n-        let reported = err.emit();\n+        let suggestion =\n+            AddLifetimeParamsSuggestion { tcx: self.tcx(), sub, ty_sup, ty_sub, add_note: true };\n+        let err = LifetimeMismatch { span, labels, suggestion };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }\n \n+/// Currently only used in rustc_borrowck, probably should be\n+/// removed in favour of public_errors::AddLifetimeParamsSuggestion\n pub fn suggest_adding_lifetime_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sub: Region<'tcx>,\n-    ty_sup: &Ty<'_>,\n-    ty_sub: &Ty<'_>,\n+    ty_sup: &'tcx Ty<'_>,\n+    ty_sub: &'tcx Ty<'_>,\n     err: &mut Diagnostic,\n-) -> bool {\n-    let (\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n-    ) = (ty_sub, ty_sup) else {\n-        return false;\n-    };\n-\n-    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n-        return false;\n-    };\n-\n-    let Some(anon_reg) = tcx.is_suitable_region(sub) else {\n-        return false;\n-    };\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-\n-    let node = tcx.hir().get(hir_id);\n-    let is_impl = matches!(&node, hir::Node::ImplItem(_));\n-    let generics = match node {\n-        hir::Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, ref generics, ..), .. })\n-        | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n-        | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n-        _ => return false,\n-    };\n-\n-    let suggestion_param_name = generics\n-        .params\n-        .iter()\n-        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .map(|p| p.name.ident().name)\n-        .find(|i| *i != kw::UnderscoreLifetime);\n-    let introduce_new = suggestion_param_name.is_none();\n-    let suggestion_param_name =\n-        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n-\n-    debug!(?lifetime_sup.span);\n-    debug!(?lifetime_sub.span);\n-    let make_suggestion = |span: rustc_span::Span| {\n-        if span.is_empty() {\n-            (span, format!(\"{}, \", suggestion_param_name))\n-        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n-            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n-        } else {\n-            (span, suggestion_param_name.clone())\n-        }\n-    };\n-    let mut suggestions =\n-        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n-\n-    if introduce_new {\n-        let new_param_suggestion =\n-            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n-                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n-            } else {\n-                (generics.span, format!(\"<{}>\", suggestion_param_name))\n-            };\n-\n-        suggestions.push(new_param_suggestion);\n-    }\n-\n-    let mut sugg = String::from(\"consider introducing a named lifetime parameter\");\n-    if is_impl {\n-        sugg.push_str(\" and update trait if needed\");\n-    }\n-    err.multipart_suggestion(sugg, suggestions, Applicability::MaybeIncorrect);\n-\n-    true\n+) {\n+    let suggestion = AddLifetimeParamsSuggestion { tcx, sub, ty_sup, ty_sub, add_note: false };\n+    suggestion.add_to_diagnostic(err);\n }"}, {"sha": "1410e2b63b0b87fbfa433ba727a410780b1354de", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ea8008cced840942e23da057631ea81f2ffe9f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=e3ea8008cced840942e23da057631ea81f2ffe9f", "patch": "@@ -1,13 +1,14 @@\n //! Error Reporting for when the lifetime for a type doesn't match the `impl` selected for a predicate\n //! to hold.\n \n+use crate::errors::{note_and_explain, IntroducesStaticBecauseUnmetLifetimeReq};\n+use crate::errors::{ImplNote, MismatchedStaticLifetime, TraitSubdiag};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::TypeVisitor;\n@@ -39,12 +40,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             = *parent.code() else {\n             return None;\n         };\n-        let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n+\n         // FIXME: we should point at the lifetime\n-        let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n-        err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n-        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n+        let multi_span: MultiSpan = vec![binding_span].into();\n+        let multispan_subdiag = IntroducesStaticBecauseUnmetLifetimeReq {\n+            unmet_requirements: multi_span,\n+            binding_span,\n+        };\n+\n+        let expl = note_and_explain::RegionExplanation::new(\n+            self.tcx(),\n+            sup,\n+            Some(binding_span),\n+            note_and_explain::PrefixKind::Empty,\n+            note_and_explain::SuffixKind::Continues,\n+        );\n+        let mut impl_span = None;\n+        let mut trait_subdiags = Vec::new();\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n             // If an impl is local, then maybe this isn't what they want. Try to\n             // be as helpful as possible with implicit lifetimes.\n@@ -73,31 +85,30 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // there aren't trait objects or because none are implicit, then just\n                 // write a single note on the impl itself.\n \n-                let impl_span = self.tcx().def_span(*impl_def_id);\n-                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                impl_span = Some(self.tcx().def_span(*impl_def_id));\n             } else {\n                 // Otherwise, point at all implicit static lifetimes\n \n-                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n                 for span in &traits {\n-                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    trait_subdiags.push(TraitSubdiag::Note { span: *span });\n                     // It would be nice to put this immediately under the above note, but they get\n                     // pushed to the end.\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n-                        \"consider relaxing the implicit `'static` requirement\",\n-                        \" + '_\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    trait_subdiags.push(TraitSubdiag::Sugg { span: span.shrink_to_hi() });\n                 }\n             }\n         } else {\n             // Otherwise just point out the impl.\n \n-            let impl_span = self.tcx().def_span(*impl_def_id);\n-            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            impl_span = Some(self.tcx().def_span(*impl_def_id));\n         }\n-        let reported = err.emit();\n+        let err = MismatchedStaticLifetime {\n+            cause_span: cause.span,\n+            unmet_lifetime_reqs: multispan_subdiag,\n+            expl,\n+            impl_note: ImplNote { impl_span },\n+            trait_subdiags,\n+        };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }"}]}