{"sha": "aa029d4bbe78fafbffdebb398a767941459d9d4e", "node_id": "C_kwDOAAsO6NoAKGFhMDI5ZDRiYmU3OGZhZmJmZmRlYmIzOThhNzY3OTQxNDU5ZDlkNGU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-10-28T00:46:08Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:24Z"}, "message": "Support conditional drops\n\nThis adds support for branching and merging control flow and uses this\nto correctly handle the case where a value is dropped in one branch of\nan if expression but not another.\n\nThere are other cases we need to handle, which will come in follow up\npatches.\n\nIssue #57478", "tree": {"sha": "bc79cebb3f92c617094b7eb7bb257c7dec13e3c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc79cebb3f92c617094b7eb7bb257c7dec13e3c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa029d4bbe78fafbffdebb398a767941459d9d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa029d4bbe78fafbffdebb398a767941459d9d4e", "html_url": "https://github.com/rust-lang/rust/commit/aa029d4bbe78fafbffdebb398a767941459d9d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa029d4bbe78fafbffdebb398a767941459d9d4e/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "html_url": "https://github.com/rust-lang/rust/commit/f246c0b116cdbbad570c23c5745aa01f6f3f64a0"}], "stats": {"total": 248, "additions": 220, "deletions": 28}, "files": [{"sha": "dfe3db5907a33b38212cfb1d041ecb56fe7dbed6", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa029d4bbe78fafbffdebb398a767941459d9d4e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aa029d4bbe78fafbffdebb398a767941459d9d4e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=aa029d4bbe78fafbffdebb398a767941459d9d4e", "patch": "@@ -4383,6 +4383,7 @@ dependencies = [\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n dependencies = [\n+ \"itertools 0.9.0\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "1da106d7002ef70e729d5b2a9cb77f4c4f703ce2", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa029d4bbe78fafbffdebb398a767941459d9d4e/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa029d4bbe78fafbffdebb398a767941459d9d4e/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=aa029d4bbe78fafbffdebb398a767941459d9d4e", "patch": "@@ -8,6 +8,7 @@ test = false\n doctest = false\n \n [dependencies]\n+itertools = \"0.9\"\n rustc_arena = { path = \"../rustc_arena\" }\n tracing = \"0.1\"\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "6144cbbd8dd4bf5279e7b26a9647f780fd6228e2", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 196, "deletions": 28, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/aa029d4bbe78fafbffdebb398a767941459d9d4e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa029d4bbe78fafbffdebb398a767941459d9d4e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=aa029d4bbe78fafbffdebb398a767941459d9d4e", "patch": "@@ -3,10 +3,13 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n+use std::mem;\n+\n use crate::expr_use_visitor::{self, ExprUseVisitor};\n \n use super::FnCtxt;\n use hir::{HirIdMap, Node};\n+use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -24,6 +27,9 @@ use rustc_span::Span;\n use smallvec::SmallVec;\n use tracing::debug;\n \n+#[cfg(test)]\n+mod tests;\n+\n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n@@ -80,7 +86,9 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                             );\n \n                             match self.drop_ranges.get(&hir_id) {\n-                                Some(range) if range.contains(yield_data.expr_and_pat_count) => {\n+                                Some(range)\n+                                    if range.is_dropped_at(yield_data.expr_and_pat_count) =>\n+                                {\n                                     debug!(\"value is dropped at yield point; not recording\");\n                                     return false;\n                                 }\n@@ -229,7 +237,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             hir: fcx.tcx.hir(),\n             consumed_places: <_>::default(),\n             borrowed_places: <_>::default(),\n-            drop_ranges: vec![<_>::default()],\n+            drop_ranges: <_>::default(),\n             expr_count: 0,\n         };\n \n@@ -254,7 +262,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             guard_bindings: <_>::default(),\n             guard_bindings_set: <_>::default(),\n             linted_values: <_>::default(),\n-            drop_ranges: drop_range_visitor.drop_ranges.pop().unwrap(),\n+            drop_ranges: drop_range_visitor.drop_ranges,\n         }\n     };\n     intravisit::walk_body(&mut visitor, body);\n@@ -671,7 +679,7 @@ struct DropRangeVisitor<'tcx> {\n     /// Maps a HirId to a set of HirIds that are dropped by that node.\n     consumed_places: HirIdMap<HirIdSet>,\n     borrowed_places: HirIdSet,\n-    drop_ranges: Vec<HirIdMap<DropRange>>,\n+    drop_ranges: HirIdMap<DropRange>,\n     expr_count: usize,\n }\n \n@@ -684,28 +692,42 @@ impl DropRangeVisitor<'tcx> {\n     }\n \n     fn record_drop(&mut self, hir_id: HirId) {\n-        let drop_ranges = self.drop_ranges.last_mut().unwrap();\n+        let drop_ranges = &mut self.drop_ranges;\n         if self.borrowed_places.contains(&hir_id) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n         } else {\n             debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-            drop_ranges.insert(hir_id, DropRange { dropped_at: self.expr_count });\n+            drop_ranges.insert(hir_id, DropRange::new(self.expr_count));\n         }\n     }\n \n-    fn push_drop_scope(&mut self) {\n-        self.drop_ranges.push(<_>::default());\n+    fn swap_drop_ranges(&mut self, mut other: HirIdMap<DropRange>) -> HirIdMap<DropRange> {\n+        mem::swap(&mut self.drop_ranges, &mut other);\n+        other\n     }\n \n-    fn pop_and_merge_drop_scope(&mut self) {\n-        let mut old_last = self.drop_ranges.pop().unwrap();\n-        let drop_ranges = self.drop_ranges.last_mut().unwrap();\n-        for (k, v) in old_last.drain() {\n-            match drop_ranges.get(&k).cloned() {\n-                Some(v2) => drop_ranges.insert(k, v.intersect(&v2)),\n-                None => drop_ranges.insert(k, v),\n-            };\n-        }\n+    #[allow(dead_code)]\n+    fn fork_drop_ranges(&self) -> HirIdMap<DropRange> {\n+        self.drop_ranges.iter().map(|(k, v)| (*k, v.fork_at(self.expr_count))).collect()\n+    }\n+\n+    fn intersect_drop_ranges(&mut self, drops: HirIdMap<DropRange>) {\n+        drops.into_iter().for_each(|(k, v)| match self.drop_ranges.get_mut(&k) {\n+            Some(ranges) => *ranges = ranges.intersect(&v),\n+            None => {\n+                self.drop_ranges.insert(k, v);\n+            }\n+        })\n+    }\n+\n+    #[allow(dead_code)]\n+    fn merge_drop_ranges(&mut self, drops: HirIdMap<DropRange>) {\n+        drops.into_iter().for_each(|(k, v)| {\n+            if !self.drop_ranges.contains_key(&k) {\n+                self.drop_ranges.insert(k, DropRange { events: vec![] });\n+            }\n+            self.drop_ranges.get_mut(&k).unwrap().merge_with(&v, self.expr_count);\n+        });\n     }\n \n     /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n@@ -751,7 +773,10 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor<'tcx> {\n             Some(parent) => parent,\n             None => place_with_id.hir_id,\n         };\n-        debug!(\"consume {:?}; diag_expr_id={:?}, using parent {:?}\", place_with_id, diag_expr_id, parent);\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n         self.mark_consumed(parent, place_with_id.hir_id);\n         place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n     }\n@@ -800,15 +825,47 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                 self.visit_expr(lhs);\n                 self.visit_expr(rhs);\n \n-                self.push_drop_scope();\n+                let old_drops = self.swap_drop_ranges(<_>::default());\n                 std::mem::swap(&mut old_count, &mut self.expr_count);\n                 self.visit_expr(rhs);\n                 self.visit_expr(lhs);\n \n                 // We should have visited the same number of expressions in either order.\n                 assert_eq!(old_count, self.expr_count);\n \n-                self.pop_and_merge_drop_scope();\n+                self.intersect_drop_ranges(old_drops);\n+            }\n+            ExprKind::If(test, if_true, if_false) => {\n+                self.visit_expr(test);\n+\n+                match if_false {\n+                    Some(if_false) => {\n+                        let mut true_ranges = self.fork_drop_ranges();\n+                        let mut false_ranges = self.fork_drop_ranges();\n+\n+                        true_ranges = self.swap_drop_ranges(true_ranges);\n+                        self.visit_expr(if_true);\n+                        true_ranges = self.swap_drop_ranges(true_ranges);\n+\n+                        false_ranges = self.swap_drop_ranges(false_ranges);\n+                        self.visit_expr(if_false);\n+                        false_ranges = self.swap_drop_ranges(false_ranges);\n+\n+                        self.merge_drop_ranges(true_ranges);\n+                        self.merge_drop_ranges(false_ranges);\n+                    }\n+                    None => {\n+                        let mut true_ranges = self.fork_drop_ranges();\n+                        debug!(\"true branch drop range fork: {:?}\", true_ranges);\n+                        true_ranges = self.swap_drop_ranges(true_ranges);\n+                        self.visit_expr(if_true);\n+                        true_ranges = self.swap_drop_ranges(true_ranges);\n+                        debug!(\"true branch computed drop_ranges: {:?}\", true_ranges);\n+                        debug!(\"drop ranges before merging: {:?}\", self.drop_ranges);\n+                        self.merge_drop_ranges(true_ranges);\n+                        debug!(\"drop ranges after merging: {:?}\", self.drop_ranges);\n+                    }\n+                }\n             }\n             _ => intravisit::walk_expr(self, expr),\n         }\n@@ -825,20 +882,131 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+enum Event {\n+    Drop(usize),\n+    Reinit(usize),\n+}\n+\n+impl Event {\n+    fn location(&self) -> usize {\n+        match *self {\n+            Event::Drop(i) | Event::Reinit(i) => i,\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Event {\n+    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n+        self.location().partial_cmp(&other.location())\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n struct DropRange {\n-    /// The post-order id of the point where this expression is dropped.\n-    ///\n-    /// We can consider the value dropped at any post-order id greater than dropped_at.\n-    dropped_at: usize,\n+    events: Vec<Event>,\n }\n \n impl DropRange {\n+    fn new(begin: usize) -> Self {\n+        Self { events: vec![Event::Drop(begin)] }\n+    }\n+\n     fn intersect(&self, other: &Self) -> Self {\n-        Self { dropped_at: self.dropped_at.max(other.dropped_at) }\n+        let mut events = vec![];\n+        self.events\n+            .iter()\n+            .merge_join_by(other.events.iter(), |a, b| a.partial_cmp(b).unwrap())\n+            .fold((false, false), |(left, right), event| match event {\n+                itertools::EitherOrBoth::Both(_, _) => todo!(),\n+                itertools::EitherOrBoth::Left(e) => match e {\n+                    Event::Drop(i) => {\n+                        if !left && right {\n+                            events.push(Event::Drop(*i));\n+                        }\n+                        (true, right)\n+                    }\n+                    Event::Reinit(i) => {\n+                        if left && !right {\n+                            events.push(Event::Reinit(*i));\n+                        }\n+                        (false, right)\n+                    }\n+                },\n+                itertools::EitherOrBoth::Right(e) => match e {\n+                    Event::Drop(i) => {\n+                        if left && !right {\n+                            events.push(Event::Drop(*i));\n+                        }\n+                        (left, true)\n+                    }\n+                    Event::Reinit(i) => {\n+                        if !left && right {\n+                            events.push(Event::Reinit(*i));\n+                        }\n+                        (left, false)\n+                    }\n+                },\n+            });\n+        Self { events }\n+    }\n+\n+    fn is_dropped_at(&self, id: usize) -> bool {\n+        match self.events.iter().try_fold(false, |is_dropped, event| {\n+            if event.location() < id {\n+                Ok(match event {\n+                    Event::Drop(_) => true,\n+                    Event::Reinit(_) => false,\n+                })\n+            } else {\n+                Err(is_dropped)\n+            }\n+        }) {\n+            Ok(is_dropped) | Err(is_dropped) => is_dropped,\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    fn drop(&mut self, location: usize) {\n+        self.events.push(Event::Drop(location))\n+    }\n+\n+    #[allow(dead_code)]\n+    fn reinit(&mut self, location: usize) {\n+        self.events.push(Event::Reinit(location));\n+    }\n+\n+    /// Merges another range with this one. Meant to be used at control flow join points.\n+    ///\n+    /// After merging, the value will be dead at the end of the range only if it was dead\n+    /// at the end of both self and other.\n+    ///\n+    /// Assumes that all locations in each range are less than joinpoint\n+    #[allow(dead_code)]\n+    fn merge_with(&mut self, other: &DropRange, join_point: usize) {\n+        let mut events: Vec<_> =\n+            self.events.iter().merge(other.events.iter()).dedup().cloned().collect();\n+\n+        events.push(if self.is_dropped_at(join_point) && other.is_dropped_at(join_point) {\n+            Event::Drop(join_point)\n+        } else {\n+            Event::Reinit(join_point)\n+        });\n+\n+        self.events = events;\n     }\n \n-    fn contains(&self, id: usize) -> bool {\n-        id > self.dropped_at\n+    /// Creates a new DropRange from this one at the split point.\n+    ///\n+    /// Used to model branching control flow.\n+    #[allow(dead_code)]\n+    fn fork_at(&self, split_point: usize) -> Self {\n+        Self {\n+            events: vec![if self.is_dropped_at(split_point) {\n+                Event::Drop(split_point)\n+            } else {\n+                Event::Reinit(split_point)\n+            }],\n+        }\n     }\n }"}, {"sha": "40f01f78662a3cd794212ad5b13d6facc5982a9b", "filename": "src/test/ui/generator/drop-if.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa029d4bbe78fafbffdebb398a767941459d9d4e/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa029d4bbe78fafbffdebb398a767941459d9d4e/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-if.rs?ref=aa029d4bbe78fafbffdebb398a767941459d9d4e", "patch": "@@ -0,0 +1,22 @@\n+// build-pass\n+\n+// This test case is reduced from src/test/ui/drop/dynamic-drop-async.rs\n+\n+#![feature(generators)]\n+\n+struct Ptr;\n+impl<'a> Drop for Ptr {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+fn main() {\n+    let arg = true;\n+    let _ = || {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        }\n+        yield\n+    };\n+}"}]}