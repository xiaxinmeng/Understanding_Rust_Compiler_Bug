{"sha": "d7517d83232082b1d6c0ce7cdea7ba5fe3c70745", "node_id": "C_kwDOAAsO6NoAKGQ3NTE3ZDgzMjMyMDgyYjFkNmMwY2U3Y2RlYTdiYTVmZTNjNzA3NDU", "commit": {"author": {"name": "Steven Joruk", "email": "steven@joruk.com", "date": "2022-03-12T15:10:16Z"}, "committer": {"name": "Steven Joruk", "email": "steven@joruk.com", "date": "2022-03-12T15:55:47Z"}, "message": "refactor: Veykril's code review suggestions", "tree": {"sha": "751070ba901ef94f5711484143d4d1acfa33c43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/751070ba901ef94f5711484143d4d1acfa33c43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745", "html_url": "https://github.com/rust-lang/rust/commit/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745/comments", "author": {"login": "steven-joruk", "id": 1277939, "node_id": "MDQ6VXNlcjEyNzc5Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1277939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steven-joruk", "html_url": "https://github.com/steven-joruk", "followers_url": "https://api.github.com/users/steven-joruk/followers", "following_url": "https://api.github.com/users/steven-joruk/following{/other_user}", "gists_url": "https://api.github.com/users/steven-joruk/gists{/gist_id}", "starred_url": "https://api.github.com/users/steven-joruk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steven-joruk/subscriptions", "organizations_url": "https://api.github.com/users/steven-joruk/orgs", "repos_url": "https://api.github.com/users/steven-joruk/repos", "events_url": "https://api.github.com/users/steven-joruk/events{/privacy}", "received_events_url": "https://api.github.com/users/steven-joruk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steven-joruk", "id": 1277939, "node_id": "MDQ6VXNlcjEyNzc5Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1277939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steven-joruk", "html_url": "https://github.com/steven-joruk", "followers_url": "https://api.github.com/users/steven-joruk/followers", "following_url": "https://api.github.com/users/steven-joruk/following{/other_user}", "gists_url": "https://api.github.com/users/steven-joruk/gists{/gist_id}", "starred_url": "https://api.github.com/users/steven-joruk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steven-joruk/subscriptions", "organizations_url": "https://api.github.com/users/steven-joruk/orgs", "repos_url": "https://api.github.com/users/steven-joruk/repos", "events_url": "https://api.github.com/users/steven-joruk/events{/privacy}", "received_events_url": "https://api.github.com/users/steven-joruk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b712bd8217f974e96019910aace4c66547fbacc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b712bd8217f974e96019910aace4c66547fbacc", "html_url": "https://github.com/rust-lang/rust/commit/5b712bd8217f974e96019910aace4c66547fbacc"}], "stats": {"total": 217, "additions": 126, "deletions": 91}, "files": [{"sha": "e80e09260d9f8f58319c1427518a146085780718", "filename": "crates/ide_assists/src/handlers/inline_type_alias.rs", "status": "modified", "additions": 126, "deletions": 91, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7517d83232082b1d6c0ce7cdea7ba5fe3c70745/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=d7517d83232082b1d6c0ce7cdea7ba5fe3c70745", "patch": "@@ -46,11 +46,19 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let concrete_type = alias.ty()?;\n \n     let replacement = if let Some(alias_generics) = alias.generic_param_list() {\n-        get_replacement_for_generic_alias(\n-            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast),\n-            alias_generics,\n+        if alias_generics.generic_params().next().is_none() {\n+            cov_mark::hit!(no_generics_params);\n+            return None;\n+        }\n+\n+        let instance_args =\n+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);\n+\n+        create_replacement(\n+            &LifetimeMap::new(&instance_args, &alias_generics)?,\n+            &ConstAndTypeMap::new(&instance_args, &alias_generics)?,\n             &concrete_type,\n-        )?\n+        )\n     } else {\n         concrete_type.to_string()\n     };\n@@ -67,6 +75,83 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     )\n }\n \n+struct LifetimeMap(HashMap<String, ast::Lifetime>);\n+\n+impl LifetimeMap {\n+    fn new(\n+        instance_args: &Option<ast::GenericArgList>,\n+        alias_generics: &ast::GenericParamList,\n+    ) -> Option<Self> {\n+        let mut inner = HashMap::new();\n+\n+        let wildcard_lifetime = make::lifetime(\"'_\");\n+        let lifetimes = alias_generics\n+            .lifetime_params()\n+            .filter_map(|lp| lp.lifetime())\n+            .map(|l| l.to_string())\n+            .collect_vec();\n+\n+        for lifetime in &lifetimes {\n+            inner.insert(lifetime.to_string(), wildcard_lifetime.clone());\n+        }\n+\n+        if let Some(instance_generic_args_list) = &instance_args {\n+            for (index, lifetime) in instance_generic_args_list\n+                .lifetime_args()\n+                .filter_map(|arg| arg.lifetime())\n+                .enumerate()\n+            {\n+                let key = match lifetimes.get(index) {\n+                    Some(key) => key,\n+                    None => {\n+                        cov_mark::hit!(too_many_lifetimes);\n+                        return None;\n+                    }\n+                };\n+\n+                inner.insert(key.clone(), lifetime);\n+            }\n+        }\n+\n+        Some(Self(inner))\n+    }\n+}\n+\n+struct ConstAndTypeMap(HashMap<String, SyntaxNode>);\n+\n+impl ConstAndTypeMap {\n+    fn new(\n+        instance_args: &Option<ast::GenericArgList>,\n+        alias_generics: &ast::GenericParamList,\n+    ) -> Option<Self> {\n+        let mut inner = HashMap::new();\n+        let instance_generics = generic_args_to_const_and_type_generics(instance_args);\n+        let alias_generics = generic_param_list_to_const_and_type_generics(&alias_generics);\n+\n+        if instance_generics.len() > alias_generics.len() {\n+            cov_mark::hit!(too_many_generic_args);\n+            return None;\n+        }\n+\n+        // Any declaration generics that don't have a default value must have one\n+        // provided by the instance.\n+        for (i, declaration_generic) in alias_generics.iter().enumerate() {\n+            let key = declaration_generic.replacement_key()?;\n+\n+            if let Some(instance_generic) = instance_generics.get(i) {\n+                inner.insert(key, instance_generic.replacement_value()?);\n+            } else if let Some(value) = declaration_generic.replacement_value() {\n+                inner.insert(key, value);\n+            } else {\n+                cov_mark::hit!(missing_replacement_param);\n+                return None;\n+            }\n+        }\n+\n+        Some(Self(inner))\n+    }\n+}\n+\n /// This doesn't attempt to ensure specified generics are compatible with those\n /// required by the type alias, other than lifetimes which must either all be\n /// specified or all omitted. It will replace TypeArgs with ConstArgs and vice\n@@ -94,65 +179,11 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Optio\n /// 3. Remove wildcard lifetimes entirely:\n ///\n ///    &[u64; 100]\n-fn get_replacement_for_generic_alias(\n-    instance_generic_args_list: Option<ast::GenericArgList>,\n-    alias_generics: ast::GenericParamList,\n+fn create_replacement(\n+    lifetime_map: &LifetimeMap,\n+    const_and_type_map: &ConstAndTypeMap,\n     concrete_type: &ast::Type,\n-) -> Option<String> {\n-    if alias_generics.generic_params().count() == 0 {\n-        cov_mark::hit!(no_generics_params);\n-        return None;\n-    }\n-\n-    let mut lifetime_mappings = HashMap::<&str, ast::Lifetime>::new();\n-    let mut other_mappings = HashMap::<String, SyntaxNode>::new();\n-\n-    let wildcard_lifetime = make::lifetime(\"'_\");\n-    let alias_lifetimes = alias_generics.lifetime_params().map(|l| l.to_string()).collect_vec();\n-    for lifetime in &alias_lifetimes {\n-        lifetime_mappings.insert(lifetime, wildcard_lifetime.clone());\n-    }\n-\n-    if let Some(ref instance_generic_args_list) = instance_generic_args_list {\n-        for (index, lifetime) in instance_generic_args_list\n-            .lifetime_args()\n-            .map(|arg| arg.lifetime().expect(\"LifetimeArg has a Lifetime\"))\n-            .enumerate()\n-        {\n-            if index >= alias_lifetimes.len() {\n-                cov_mark::hit!(too_many_lifetimes);\n-                return None;\n-            }\n-\n-            let key = &alias_lifetimes[index];\n-\n-            lifetime_mappings.insert(key, lifetime);\n-        }\n-    }\n-\n-    let instance_generics = generic_args_to_other_generics(instance_generic_args_list);\n-    let alias_generics = generic_param_list_to_other_generics(&alias_generics);\n-\n-    if instance_generics.len() > alias_generics.len() {\n-        cov_mark::hit!(too_many_generic_args);\n-        return None;\n-    }\n-\n-    // Any declaration generics that don't have a default value must have one\n-    // provided by the instance.\n-    for (i, declaration_generic) in alias_generics.iter().enumerate() {\n-        let key = declaration_generic.replacement_key();\n-\n-        if let Some(instance_generic) = instance_generics.get(i) {\n-            other_mappings.insert(key, instance_generic.replacement_value()?);\n-        } else if let Some(value) = declaration_generic.replacement_value() {\n-            other_mappings.insert(key, value);\n-        } else {\n-            cov_mark::hit!(missing_replacement_param);\n-            return None;\n-        }\n-    }\n-\n+) -> String {\n     let updated_concrete_type = concrete_type.clone_for_update();\n     let mut replacements = Vec::new();\n     let mut removals = Vec::new();\n@@ -161,20 +192,21 @@ fn get_replacement_for_generic_alias(\n         let syntax_string = syntax.to_string();\n         let syntax_str = syntax_string.as_str();\n \n-        if syntax.kind() == SyntaxKind::LIFETIME {\n-            let new = lifetime_mappings.get(syntax_str).expect(\"lifetime is mapped\");\n-            if new.text() == \"'_\" {\n-                removals.push(NodeOrToken::Node(syntax.clone()));\n+        if let Some(old_lifetime) = ast::Lifetime::cast(syntax.clone()) {\n+            if let Some(new_lifetime) = lifetime_map.0.get(&old_lifetime.to_string()) {\n+                if new_lifetime.text() == \"'_\" {\n+                    removals.push(NodeOrToken::Node(syntax.clone()));\n+\n+                    if let Some(ws) = syntax.next_sibling_or_token() {\n+                        removals.push(ws.clone());\n+                    }\n \n-                if let Some(ws) = syntax.next_sibling_or_token() {\n-                    removals.push(ws.clone());\n+                    continue;\n                 }\n \n-                continue;\n+                replacements.push((syntax.clone(), new_lifetime.syntax().clone_for_update()));\n             }\n-\n-            replacements.push((syntax.clone(), new.syntax().clone_for_update()));\n-        } else if let Some(replacement_syntax) = other_mappings.get(syntax_str) {\n+        } else if let Some(replacement_syntax) = const_and_type_map.0.get(syntax_str) {\n             let new_string = replacement_syntax.to_string();\n             let new = if new_string == \"_\" {\n                 make::wildcard_pat().syntax().clone_for_update()\n@@ -194,7 +226,7 @@ fn get_replacement_for_generic_alias(\n         ted::remove(syntax);\n     }\n \n-    Some(updated_concrete_type.to_string())\n+    updated_concrete_type.to_string()\n }\n \n fn get_type_alias(ctx: &AssistContext, path: &ast::PathType) -> Option<ast::TypeAlias> {\n@@ -205,57 +237,60 @@ fn get_type_alias(ctx: &AssistContext, path: &ast::PathType) -> Option<ast::Type\n     // keep the order, so we must get the `ast::TypeAlias` from the hir\n     // definition.\n     if let PathResolution::Def(hir::ModuleDef::TypeAlias(ta)) = resolved_path {\n-        ast::TypeAlias::cast(ctx.sema.source(ta)?.syntax().value.clone())\n+        Some(ctx.sema.source(ta)?.value)\n     } else {\n         None\n     }\n }\n \n-enum OtherGeneric {\n+enum ConstOrTypeGeneric {\n     ConstArg(ast::ConstArg),\n     TypeArg(ast::TypeArg),\n     ConstParam(ast::ConstParam),\n     TypeParam(ast::TypeParam),\n }\n \n-impl OtherGeneric {\n-    fn replacement_key(&self) -> String {\n+impl ConstOrTypeGeneric {\n+    fn replacement_key(&self) -> Option<String> {\n         // Only params are used as replacement keys.\n         match self {\n-            OtherGeneric::ConstArg(_) => unreachable!(),\n-            OtherGeneric::TypeArg(_) => unreachable!(),\n-            OtherGeneric::ConstParam(cp) => cp.name().expect(\"ConstParam has a name\").to_string(),\n-            OtherGeneric::TypeParam(tp) => tp.name().expect(\"TypeParam has a name\").to_string(),\n+            ConstOrTypeGeneric::ConstParam(cp) => Some(cp.name()?.to_string()),\n+            ConstOrTypeGeneric::TypeParam(tp) => Some(tp.name()?.to_string()),\n+            _ => None,\n         }\n     }\n \n     fn replacement_value(&self) -> Option<SyntaxNode> {\n         Some(match self {\n-            OtherGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),\n-            OtherGeneric::TypeArg(ta) => ta.syntax().clone(),\n-            OtherGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),\n-            OtherGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),\n+            ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),\n+            ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),\n+            ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),\n+            ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),\n         })\n     }\n }\n \n-fn generic_param_list_to_other_generics(generics: &ast::GenericParamList) -> Vec<OtherGeneric> {\n+fn generic_param_list_to_const_and_type_generics(\n+    generics: &ast::GenericParamList,\n+) -> Vec<ConstOrTypeGeneric> {\n     let mut others = Vec::new();\n \n     for param in generics.generic_params() {\n         match param {\n             ast::GenericParam::LifetimeParam(_) => {}\n             ast::GenericParam::ConstParam(cp) => {\n-                others.push(OtherGeneric::ConstParam(cp));\n+                others.push(ConstOrTypeGeneric::ConstParam(cp));\n             }\n-            ast::GenericParam::TypeParam(tp) => others.push(OtherGeneric::TypeParam(tp)),\n+            ast::GenericParam::TypeParam(tp) => others.push(ConstOrTypeGeneric::TypeParam(tp)),\n         }\n     }\n \n     others\n }\n \n-fn generic_args_to_other_generics(generics: Option<ast::GenericArgList>) -> Vec<OtherGeneric> {\n+fn generic_args_to_const_and_type_generics(\n+    generics: &Option<ast::GenericArgList>,\n+) -> Vec<ConstOrTypeGeneric> {\n     let mut others = Vec::new();\n \n     // It's fine for there to be no instance generics because the declaration\n@@ -264,10 +299,10 @@ fn generic_args_to_other_generics(generics: Option<ast::GenericArgList>) -> Vec<\n         for arg in generics.generic_args() {\n             match arg {\n                 ast::GenericArg::TypeArg(ta) => {\n-                    others.push(OtherGeneric::TypeArg(ta));\n+                    others.push(ConstOrTypeGeneric::TypeArg(ta));\n                 }\n                 ast::GenericArg::ConstArg(ca) => {\n-                    others.push(OtherGeneric::ConstArg(ca));\n+                    others.push(ConstOrTypeGeneric::ConstArg(ca));\n                 }\n                 _ => {}\n             }"}]}