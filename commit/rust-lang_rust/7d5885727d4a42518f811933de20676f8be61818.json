{"sha": "7d5885727d4a42518f811933de20676f8be61818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNTg4NTcyN2Q0YTQyNTE4ZjgxMTkzM2RlMjA2NzZmOGJlNjE4MTg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-11T19:49:08Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-14T22:37:16Z"}, "message": "Remove old \"generic\" framework", "tree": {"sha": "f8f9a59f2dccf402fe05e79d7b7c017205ba62a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8f9a59f2dccf402fe05e79d7b7c017205ba62a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d5885727d4a42518f811933de20676f8be61818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d5885727d4a42518f811933de20676f8be61818", "html_url": "https://github.com/rust-lang/rust/commit/7d5885727d4a42518f811933de20676f8be61818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d5885727d4a42518f811933de20676f8be61818/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c51f605a021f1416a23e0cd76afa2156d5526c", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c51f605a021f1416a23e0cd76afa2156d5526c", "html_url": "https://github.com/rust-lang/rust/commit/07c51f605a021f1416a23e0cd76afa2156d5526c"}], "stats": {"total": 595, "additions": 0, "deletions": 595}, "files": [{"sha": "d2ca4f1572c1f6a3d53fc34a3f664bf2252e5537", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "removed", "additions": 0, "deletions": 595, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c51f605a021f1416a23e0cd76afa2156d5526c/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=07c51f605a021f1416a23e0cd76afa2156d5526c", "patch": "@@ -1,595 +0,0 @@\n-//! Dataflow analysis with arbitrary transfer functions.\n-//!\n-//! This module is a work in progress. You should instead use `BitDenotation` in\n-//! `librustc_mir/dataflow/mod.rs` and encode your transfer function as a [gen/kill set][gk]. In\n-//! doing so, your analysis will run faster and you will be able to generate graphviz diagrams for\n-//! debugging with no extra effort. The interface in this module is intended only for dataflow\n-//! problems that cannot be expressed using gen/kill sets.\n-//!\n-//! FIXME(ecstaticmorse): In the long term, the plan is to preserve the existing `BitDenotation`\n-//! interface, but make `Engine` and `ResultsCursor` the canonical way to perform and inspect a\n-//! dataflow analysis. This requires porting the graphviz debugging logic to this module, deciding\n-//! on a way to handle the `before` methods in `BitDenotation` and creating an adapter so that\n-//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566] for more\n-//! information.\n-//!\n-//! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n-//! [#64566]: https://github.com/rust-lang/rust/pull/64566\n-\n-use std::borrow::Borrow;\n-use std::cmp::Ordering;\n-use std::ffi::OsString;\n-use std::path::{Path, PathBuf};\n-use std::{fs, io, ops};\n-\n-use rustc::mir::{self, traversal, BasicBlock, Location};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_span::symbol::sym;\n-\n-use crate::dataflow::BottomValue;\n-\n-mod graphviz;\n-\n-/// A specific kind of dataflow analysis.\n-///\n-/// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n-/// `initialize_start_block` and define a transfer function for each statement or terminator via\n-/// the various `effect` methods. The entry set for all other basic blocks is initialized to\n-/// `Self::BOTTOM_VALUE`. The dataflow `Engine` then iteratively updates the various entry sets for\n-/// each block with the cumulative effects of the transfer functions of all preceding blocks.\n-///\n-/// You should use an `Engine` to actually run an analysis, and a `ResultsCursor` to inspect the\n-/// results of that analysis like so:\n-///\n-/// ```ignore(cross-crate-imports)\n-/// fn do_my_analysis(body: &mir::Body<'tcx>, dead_unwinds: &BitSet<BasicBlock>) {\n-///     // `MyAnalysis` implements `Analysis`.\n-///     let analysis = MyAnalysis::new();\n-///\n-///     let results = Engine::new(body, dead_unwinds, analysis).iterate_to_fixpoint();\n-///     let mut cursor = ResultsCursor::new(body, results);\n-///\n-///     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n-///         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n-///         let state = cursor.get();\n-///         println!(\"{:?}\", state);\n-///     }\n-/// }\n-/// ```\n-pub trait Analysis<'tcx>: BottomValue {\n-    /// The index type used to access the dataflow state.\n-    type Idx: Idx;\n-\n-    /// A name, used for debugging, that describes this dataflow analysis.\n-    ///\n-    /// The name should be suitable as part of a filename, so avoid whitespace, slashes or periods\n-    /// and try to keep it short.\n-    const NAME: &'static str;\n-\n-    /// How each element of your dataflow state will be displayed during debugging.\n-    ///\n-    /// By default, this is the `fmt::Debug` representation of `Self::Idx`.\n-    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n-        write!(w, \"{:?}\", idx)\n-    }\n-\n-    /// The size of each bitvector allocated for each block.\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n-\n-    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n-    /// analysis.\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n-\n-    /// Updates the current dataflow state with the effect of evaluating a statement.\n-    fn apply_statement_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        statement: &mir::Statement<'tcx>,\n-        location: Location,\n-    );\n-\n-    /// Updates the current dataflow state with the effect of evaluating a terminator.\n-    ///\n-    /// Note that the effect of a successful return from a `Call` terminator should **not** be\n-    /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n-    /// in the `InitializedPlaces` analyses, the return place is not marked as initialized here.\n-    fn apply_terminator_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        location: Location,\n-    );\n-\n-    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n-    /// terminator.\n-    ///\n-    /// This is separated from `apply_terminator_effect` to properly track state across\n-    /// unwind edges for `Call`s.\n-    fn apply_call_return_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        func: &mir::Operand<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n-    );\n-\n-    /// Applies the cumulative effect of an entire basic block to the dataflow state (except for\n-    /// `call_return_effect`, which is handled in the `Engine`).\n-    ///\n-    /// The default implementation calls `statement_effect` for every statement in the block before\n-    /// finally calling `terminator_effect`. However, some dataflow analyses are able to coalesce\n-    /// transfer functions for an entire block and apply them at once. Such analyses should\n-    /// override `block_effect`.\n-    fn apply_whole_block_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-    ) {\n-        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n-            let location = Location { block, statement_index };\n-            self.apply_statement_effect(state, stmt, location);\n-        }\n-\n-        let location = Location { block, statement_index: block_data.statements.len() };\n-        self.apply_terminator_effect(state, block_data.terminator(), location);\n-    }\n-\n-    /// Applies the cumulative effect of a sequence of statements (and possibly a terminator)\n-    /// within a single basic block.\n-    ///\n-    /// When called with `0..block_data.statements.len() + 1` as the statement range, this function\n-    /// is equivalent to `apply_whole_block_effect`.\n-    fn apply_partial_block_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-        mut range: ops::Range<usize>,\n-    ) {\n-        if range.is_empty() {\n-            return;\n-        }\n-\n-        // The final location might be a terminator, so iterate through all statements until the\n-        // final one, then check to see whether the final one is a statement or terminator.\n-        //\n-        // This can't cause the range to wrap-around since we check that the range contains at\n-        // least one element above.\n-        range.end -= 1;\n-        let final_location = Location { block, statement_index: range.end };\n-\n-        for statement_index in range {\n-            let location = Location { block, statement_index };\n-            let stmt = &block_data.statements[statement_index];\n-            self.apply_statement_effect(state, stmt, location);\n-        }\n-\n-        if final_location.statement_index == block_data.statements.len() {\n-            let terminator = block_data.terminator();\n-            self.apply_terminator_effect(state, terminator, final_location);\n-        } else {\n-            let stmt = &block_data.statements[final_location.statement_index];\n-            self.apply_statement_effect(state, stmt, final_location);\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-enum CursorPosition {\n-    AtBlockStart(BasicBlock),\n-    After(Location),\n-}\n-\n-impl CursorPosition {\n-    fn block(&self) -> BasicBlock {\n-        match *self {\n-            Self::AtBlockStart(block) => block,\n-            Self::After(Location { block, .. }) => block,\n-        }\n-    }\n-}\n-\n-type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n-\n-/// Inspect the results of dataflow analysis.\n-///\n-/// This cursor has linear performance when visiting statements in a block in order. Visiting\n-/// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n-/// in that block.\n-pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    body: &'mir mir::Body<'tcx>,\n-    results: R,\n-    state: BitSet<A::Idx>,\n-\n-    pos: CursorPosition,\n-\n-    /// Whether the effects of `apply_call_return_effect` are currently stored in `state`.\n-    ///\n-    /// This flag ensures that multiple calls to `seek_after_assume_call_returns` with the same\n-    /// target only result in one invocation of `apply_call_return_effect`.\n-    is_call_return_effect_applied: bool,\n-}\n-\n-impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n-where\n-    A: Analysis<'tcx>,\n-    R: Borrow<Results<'tcx, A>>,\n-{\n-    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n-    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n-        ResultsCursor {\n-            body,\n-            pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n-            is_call_return_effect_applied: false,\n-            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            results,\n-        }\n-    }\n-\n-    pub fn analysis(&self) -> &A {\n-        &self.results.borrow().analysis\n-    }\n-\n-    /// Resets the cursor to the start of the given `block`.\n-    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n-        self.pos = CursorPosition::AtBlockStart(block);\n-        self.is_call_return_effect_applied = false;\n-    }\n-\n-    /// Updates the cursor to hold the dataflow state immediately before `target`.\n-    pub fn seek_before(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        if target.statement_index == 0 {\n-            self.seek_to_block_start(target.block);\n-        } else {\n-            self._seek_after(Location {\n-                block: target.block,\n-                statement_index: target.statement_index - 1,\n-            });\n-        }\n-    }\n-\n-    /// Updates the cursor to hold the dataflow state at `target`.\n-    ///\n-    /// If `target` is a `Call` terminator, `apply_call_return_effect` will not be called. See\n-    /// `seek_after_assume_call_returns` if you wish to observe the dataflow state upon a\n-    /// successful return.\n-    pub fn seek_after(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        // This check ensures the correctness of a call to `seek_after_assume_call_returns`\n-        // followed by one to `seek_after` with the same target.\n-        if self.is_call_return_effect_applied {\n-            self.seek_to_block_start(target.block);\n-        }\n-\n-        self._seek_after(target);\n-    }\n-\n-    /// Equivalent to `seek_after`, but also calls `apply_call_return_effect` if `target` is a\n-    /// `Call` terminator whose callee is convergent.\n-    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        self._seek_after(target);\n-\n-        if target != self.body.terminator_loc(target.block) {\n-            return;\n-        }\n-\n-        let term = self.body.basic_blocks()[target.block].terminator();\n-        if let mir::TerminatorKind::Call {\n-            destination: Some((return_place, _)), func, args, ..\n-        } = &term.kind\n-        {\n-            if !self.is_call_return_effect_applied {\n-                self.is_call_return_effect_applied = true;\n-                self.results.borrow().analysis.apply_call_return_effect(\n-                    &mut self.state,\n-                    target.block,\n-                    func,\n-                    args,\n-                    return_place,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn _seek_after(&mut self, target: Location) {\n-        let Location { block: target_block, statement_index: target_index } = target;\n-\n-        if self.pos.block() != target_block {\n-            self.seek_to_block_start(target_block);\n-        }\n-\n-        // If we're in the same block but after the target statement, we need to reset to the start\n-        // of the block.\n-        if let CursorPosition::After(Location { statement_index: curr_index, .. }) = self.pos {\n-            match curr_index.cmp(&target_index) {\n-                Ordering::Equal => return,\n-                Ordering::Less => {}\n-                Ordering::Greater => self.seek_to_block_start(target_block),\n-            }\n-        }\n-\n-        // The cursor is now in the same block as the target location pointing at an earlier\n-        // statement.\n-        debug_assert_eq!(self.pos.block(), target_block);\n-        if let CursorPosition::After(Location { statement_index, .. }) = self.pos {\n-            debug_assert!(statement_index < target_index);\n-        }\n-\n-        let first_unapplied_statement = match self.pos {\n-            CursorPosition::AtBlockStart(_) => 0,\n-            CursorPosition::After(Location { statement_index, .. }) => statement_index + 1,\n-        };\n-\n-        let block_data = &self.body.basic_blocks()[target_block];\n-        self.results.borrow().analysis.apply_partial_block_effect(\n-            &mut self.state,\n-            target_block,\n-            block_data,\n-            first_unapplied_statement..target_index + 1,\n-        );\n-\n-        self.pos = CursorPosition::After(target);\n-        self.is_call_return_effect_applied = false;\n-    }\n-\n-    /// Gets the dataflow state at the current location.\n-    pub fn get(&self) -> &BitSet<A::Idx> {\n-        &self.state\n-    }\n-}\n-\n-/// A completed dataflow analysis.\n-pub struct Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    analysis: A,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-/// All information required to iterate a dataflow analysis to fixpoint.\n-pub struct Engine<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    analysis: A,\n-    bits_per_block: usize,\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n-    def_id: DefId,\n-    dead_unwinds: &'a BitSet<BasicBlock>,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-impl<A> Engine<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        def_id: DefId,\n-        dead_unwinds: &'a BitSet<BasicBlock>,\n-        analysis: A,\n-    ) -> Self {\n-        let bits_per_block = analysis.bits_per_block(body);\n-\n-        let bottom_value_set = if A::BOTTOM_VALUE == true {\n-            BitSet::new_filled(bits_per_block)\n-        } else {\n-            BitSet::new_empty(bits_per_block)\n-        };\n-\n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n-        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n-\n-        Engine { analysis, bits_per_block, tcx, body, def_id, dead_unwinds, entry_sets }\n-    }\n-\n-    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n-        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n-\n-        let mut dirty_queue: WorkQueue<BasicBlock> =\n-            WorkQueue::with_none(self.body.basic_blocks().len());\n-\n-        for (bb, _) in traversal::reverse_postorder(self.body) {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        for bb in self.body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        while let Some(bb) = dirty_queue.pop() {\n-            let bb_data = &self.body[bb];\n-            let on_entry = &self.entry_sets[bb];\n-\n-            temp_state.overwrite(on_entry);\n-            self.analysis.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n-\n-            self.propagate_bits_into_graph_successors_of(\n-                &mut temp_state,\n-                (bb, bb_data),\n-                &mut dirty_queue,\n-            );\n-        }\n-\n-        let Engine { tcx, body, def_id, analysis, entry_sets, .. } = self;\n-\n-        let results = Results { analysis, entry_sets };\n-\n-        let attrs = tcx.get_attrs(def_id);\n-        if let Some(path) = get_dataflow_graphviz_output_path(tcx, attrs, A::NAME) {\n-            let result = write_dataflow_graphviz_results(body, def_id, &path, &results);\n-            if let Err(e) = result {\n-                warn!(\"Failed to write dataflow results to {}: {}\", path.display(), e);\n-            }\n-        }\n-\n-        results\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        match bb_data.terminator().kind {\n-            mir::TerminatorKind::Return\n-            | mir::TerminatorKind::Resume\n-            | mir::TerminatorKind::Abort\n-            | mir::TerminatorKind::GeneratorDrop\n-            | mir::TerminatorKind::Unreachable => {}\n-\n-            mir::TerminatorKind::Goto { target }\n-            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n-            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n-            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n-            {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n-            | mir::TerminatorKind::DropAndReplace {\n-                target,\n-                value: _,\n-                location: _,\n-                unwind: Some(unwind),\n-            } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::Call { cleanup, ref destination, ref func, ref args, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-\n-                if let Some((ref dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        dirty_queue: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        let entry_set = &mut self.entry_sets[bb];\n-        let set_changed = self.analysis.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-}\n-\n-/// Looks for attributes like `#[rustc_mir(borrowck_graphviz_postflow=\"./path/to/suffix.dot\")]` and\n-/// extracts the path with the given analysis name prepended to the suffix.\n-///\n-/// Returns `None` if no such attribute exists.\n-fn get_dataflow_graphviz_output_path(\n-    tcx: TyCtxt<'tcx>,\n-    attrs: ty::Attributes<'tcx>,\n-    analysis: &str,\n-) -> Option<PathBuf> {\n-    let mut rustc_mir_attrs = attrs\n-        .into_iter()\n-        .filter(|attr| attr.check_name(sym::rustc_mir))\n-        .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n-\n-    let borrowck_graphviz_postflow =\n-        rustc_mir_attrs.find(|attr| attr.check_name(sym::borrowck_graphviz_postflow))?;\n-\n-    let path_and_suffix = match borrowck_graphviz_postflow.value_str() {\n-        Some(p) => p,\n-        None => {\n-            tcx.sess.span_err(\n-                borrowck_graphviz_postflow.span(),\n-                \"borrowck_graphviz_postflow requires a path\",\n-            );\n-\n-            return None;\n-        }\n-    };\n-\n-    // Change \"path/suffix.dot\" to \"path/analysis_name_suffix.dot\"\n-    let mut ret = PathBuf::from(path_and_suffix.to_string());\n-    let suffix = ret.file_name().unwrap();\n-\n-    let mut file_name: OsString = analysis.into();\n-    file_name.push(\"_\");\n-    file_name.push(suffix);\n-    ret.set_file_name(file_name);\n-\n-    Some(ret)\n-}\n-\n-fn write_dataflow_graphviz_results<A: Analysis<'tcx>>(\n-    body: &mir::Body<'tcx>,\n-    def_id: DefId,\n-    path: &Path,\n-    results: &Results<'tcx, A>,\n-) -> io::Result<()> {\n-    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n-\n-    let mut buf = Vec::new();\n-    let graphviz = graphviz::Formatter::new(body, def_id, results);\n-\n-    dot::render(&graphviz, &mut buf)?;\n-    fs::write(path, buf)\n-}"}]}