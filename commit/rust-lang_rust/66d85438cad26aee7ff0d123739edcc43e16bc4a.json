{"sha": "66d85438cad26aee7ff0d123739edcc43e16bc4a", "node_id": "C_kwDOAAsO6NoAKDY2ZDg1NDM4Y2FkMjZhZWU3ZmYwZDEyMzczOWVkY2M0M2UxNmJjNGE", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-25T08:46:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-04-26T05:46:13Z"}, "message": "Remove QueryEngine trait", "tree": {"sha": "ede9fb4276cd3f05176419c20adeebb84255558e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ede9fb4276cd3f05176419c20adeebb84255558e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d85438cad26aee7ff0d123739edcc43e16bc4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d85438cad26aee7ff0d123739edcc43e16bc4a", "html_url": "https://github.com/rust-lang/rust/commit/66d85438cad26aee7ff0d123739edcc43e16bc4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d85438cad26aee7ff0d123739edcc43e16bc4a/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "897a146006d1ceba4aeeffca5640fe1d9024b200", "url": "https://api.github.com/repos/rust-lang/rust/commits/897a146006d1ceba4aeeffca5640fe1d9024b200", "html_url": "https://github.com/rust-lang/rust/commit/897a146006d1ceba4aeeffca5640fe1d9024b200"}], "stats": {"total": 597, "additions": 271, "deletions": 326}, "files": [{"sha": "7d6ad4c638edc67cdbe9b984f9913c6af54fa9e2", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -3641,6 +3641,7 @@ dependencies = [\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n  \"rustc_query_impl\",\n+ \"rustc_query_system\",\n  \"rustc_resolve\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3770,6 +3771,7 @@ dependencies = [\n  \"derive_more\",\n  \"either\",\n  \"gsgdt\",\n+ \"measureme\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\","}, {"sha": "ec7fcbdf8848ca31400586e78da94bb209a5633d", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -4,7 +4,7 @@ use crate::errors;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n-use rustc_middle::ty::OnDiskCache;\n+use rustc_middle::query::on_disk_cache::OnDiskCache;\n use rustc_serialize::opaque::MemDecoder;\n use rustc_serialize::Decodable;\n use rustc_session::config::IncrementalStateAssertion;\n@@ -211,7 +211,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// If we are not in incremental compilation mode, returns `None`.\n /// Otherwise, tries to load the query result cache from disk,\n /// creating an empty cache if it could not be loaded.\n-pub fn load_query_result_cache<'a, C: OnDiskCache<'a>>(sess: &'a Session) -> Option<C> {\n+pub fn load_query_result_cache(sess: &Session) -> Option<OnDiskCache<'_>> {\n     if sess.opts.incremental.is_none() {\n         return None;\n     }\n@@ -223,7 +223,9 @@ pub fn load_query_result_cache<'a, C: OnDiskCache<'a>>(sess: &'a Session) -> Opt\n         &query_cache_path(sess),\n         sess.is_nightly_build(),\n     ) {\n-        LoadResult::Ok { data: (bytes, start_pos) } => Some(C::new(sess, bytes, start_pos)),\n-        _ => Some(C::new_empty(sess.source_map())),\n+        LoadResult::Ok { data: (bytes, start_pos) } => {\n+            Some(OnDiskCache::new(sess, bytes, start_pos))\n+        }\n+        _ => Some(OnDiskCache::new_empty(sess.source_map())),\n     }\n }"}, {"sha": "1441e64e41f326db2b8000f529913f98a5679f0c", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -48,7 +48,7 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n                     // Drop the memory map so that we can remove the file and write to it.\n-                    if let Some(odc) = &tcx.on_disk_cache {\n+                    if let Some(odc) = &tcx.query_system.on_disk_cache {\n                         odc.drop_serialized_data(tcx);\n                     }\n "}, {"sha": "2c7438ed9db43a366d8676a27d4f0c112a2a48cf", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -44,6 +44,7 @@ rustc_lint = { path = \"../rustc_lint\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n+rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "8e9150ba8ad3dc85d49e1135d21404bda89b3304", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -12,6 +12,7 @@ use rustc_lint::LintStore;\n use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n+use rustc_query_system::query::print_query_stack;\n use rustc_session::config::{self, CheckCfg, ErrorOutputType, Input, OutputFilenames};\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n@@ -317,7 +318,7 @@ pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n     // state if it was responsible for triggering the panic.\n     let i = ty::tls::with_context_opt(|icx| {\n         if let Some(icx) = icx {\n-            QueryCtxt::from_tcx(icx.tcx).try_print_query_stack(icx.query, handler, num_frames)\n+            print_query_stack(QueryCtxt { tcx: icx.tcx }, icx.query, handler, num_frames)\n         } else {\n             0\n         }"}, {"sha": "48401eabd1ed1e46981ea3770d4c2579eca27cbd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -23,7 +23,6 @@ use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str, validate_attr};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n-use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::Resolver;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{MetadataLoader, Untracked};\n@@ -669,7 +668,6 @@ pub fn create_global_ctxt<'tcx>(\n     lint_store: Lrc<LintStore>,\n     dep_graph: DepGraph,\n     untracked: Untracked,\n-    queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     gcx_cell: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n     hir_arena: &'tcx WorkerLocal<rustc_hir::Arena<'tcx>>,\n@@ -693,10 +691,6 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n-    let queries = queries.get_or_init(|| {\n-        TcxQueries::new(local_providers, extern_providers, query_result_on_disk_cache)\n-    });\n-\n     sess.time(\"setup_global_ctxt\", || {\n         gcx_cell.get_or_init(move || {\n             TyCtxt::create_global_ctxt(\n@@ -706,9 +700,9 @@ pub fn create_global_ctxt<'tcx>(\n                 hir_arena,\n                 untracked,\n                 dep_graph,\n-                queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n-                queries.as_dyn(),\n+                query_result_on_disk_cache,\n                 rustc_query_impl::query_callbacks(arena),\n+                rustc_query_impl::query_system_fns(local_providers, extern_providers),\n             )\n         })\n     })"}, {"sha": "77fbbf64a0ad25003c39aac89a9ca528b5cc4e18", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -16,7 +16,6 @@ use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::{GlobalCtxt, TyCtxt};\n-use rustc_query_impl::Queries as TcxQueries;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::cstore::Untracked;\n use rustc_session::{output::find_crate_name, Session};\n@@ -81,7 +80,6 @@ impl<T> Default for Query<T> {\n pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n     gcx_cell: OnceCell<GlobalCtxt<'tcx>>,\n-    queries: OnceCell<TcxQueries<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n     hir_arena: WorkerLocal<rustc_hir::Arena<'tcx>>,\n@@ -102,7 +100,6 @@ impl<'tcx> Queries<'tcx> {\n         Queries {\n             compiler,\n             gcx_cell: OnceCell::new(),\n-            queries: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             hir_arena: WorkerLocal::new(|_| rustc_hir::Arena::default()),\n             dep_graph_future: Default::default(),\n@@ -225,7 +222,6 @@ impl<'tcx> Queries<'tcx> {\n                 lint_store,\n                 self.dep_graph()?.steal(),\n                 untracked,\n-                &self.queries,\n                 &self.gcx_cell,\n                 &self.arena,\n                 &self.hir_arena,"}, {"sha": "a93b9e6f4e95f0f014260d2299105de1c10137e8", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -168,7 +168,8 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n ) -> R {\n     use rustc_data_structures::jobserver;\n     use rustc_middle::ty::tls;\n-    use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n+    use rustc_query_impl::QueryCtxt;\n+    use rustc_query_system::query::{deadlock, QueryContext};\n \n     let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n@@ -179,7 +180,7 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n             // On deadlock, creates a new thread and forwards information in thread\n             // locals to it. The new thread runs the deadlock handler.\n             let query_map = tls::with(|tcx| {\n-                QueryCtxt::from_tcx(tcx)\n+                QueryCtxt::new(tcx)\n                     .try_collect_active_jobs()\n                     .expect(\"active jobs shouldn't be locked in deadlock handler\")\n             });"}, {"sha": "a7d97bd3cf5ee6b0a9ba6fae9cf9cd58fd988ba2", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -11,6 +11,7 @@ chalk-ir = \"0.87.0\"\n derive_more = \"0.99.17\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n+measureme = \"10.0.0\"\n polonius-engine = \"0.13.0\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_arena = { path = \"../rustc_arena\" }"}, {"sha": "e5a9766c84dc83aa9bdc09b3b48b52d8e0065ff9", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -227,7 +227,9 @@ pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n             // References to statics doesn't need to know about their allocations,\n             // just about its `DefId`.\n             AllocDiscriminant::Static.encode(encoder);\n-            did.encode(encoder);\n+            // Cannot use `did.encode(encoder)` because of a bug around\n+            // specializations and method calls.\n+            Encodable::<E>::encode(&did, encoder);\n         }\n     }\n }"}, {"sha": "6443c30e82291f91b8d3b32c81a871990fcbab19", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -9,6 +9,7 @@ use rustc_span::def_id::LOCAL_CRATE;\n \n pub mod erase;\n mod keys;\n+pub mod on_disk_cache;\n pub use keys::{AsLocalKey, Key, LocalCrate};\n \n // Each of these queries corresponds to a function pointer field in the"}, {"sha": "13cc3346252e3773cc04dd41690799e57d5ff0a9", "filename": "compiler/rustc_middle/src/query/on_disk_cache.rs", "status": "modified", "additions": 9, "deletions": 47, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -1,4 +1,3 @@\n-use crate::QueryCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::stable_hasher::Hash64;\n@@ -13,8 +12,7 @@ use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_query_system::dep_graph::DepContext;\n-use rustc_query_system::query::{QueryCache, QuerySideEffects};\n+use rustc_query_system::query::QuerySideEffects;\n use rustc_serialize::{\n     opaque::{FileEncodeResult, FileEncoder, IntEncodedWithFixedSize, MemDecoder},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -123,7 +121,7 @@ struct SourceFileIndex(u32);\n pub struct AbsoluteBytePos(u64);\n \n impl AbsoluteBytePos {\n-    fn new(pos: usize) -> AbsoluteBytePos {\n+    pub fn new(pos: usize) -> AbsoluteBytePos {\n         AbsoluteBytePos(pos.try_into().expect(\"Incremental cache file size overflowed u64.\"))\n     }\n \n@@ -158,9 +156,9 @@ impl EncodedSourceFileId {\n     }\n }\n \n-impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n+impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    fn new(sess: &'sess Session, data: Mmap, start_pos: usize) -> Self {\n+    pub fn new(sess: &'sess Session, data: Mmap, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n         // Wrap in a scope so we can borrow `data`.\n@@ -193,7 +191,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         }\n     }\n \n-    fn new_empty(source_map: &'sess SourceMap) -> Self {\n+    pub fn new_empty(source_map: &'sess SourceMap) -> Self {\n         Self {\n             serialized_data: RwLock::new(None),\n             file_index_to_stable_id: Default::default(),\n@@ -215,7 +213,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n     /// Cache promotions require invoking queries, which needs to read the serialized data.\n     /// In order to serialize the new on-disk cache, the former on-disk cache file needs to be\n     /// deleted, hence we won't be able to refer to its memmapped data.\n-    fn drop_serialized_data(&self, tcx: TyCtxt<'_>) {\n+    pub fn drop_serialized_data(&self, tcx: TyCtxt<'_>) {\n         // Load everything into memory so we can write it out to the on-disk\n         // cache. The vast majority of cacheable query results should already\n         // be in memory, so this should be a cheap operation.\n@@ -227,7 +225,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         *self.serialized_data.write() = None;\n     }\n \n-    fn serialize(&self, tcx: TyCtxt<'_>, encoder: FileEncoder) -> FileEncodeResult {\n+    pub fn serialize(&self, tcx: TyCtxt<'_>, encoder: FileEncoder) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -269,7 +267,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             tcx.sess.time(\"encode_query_results\", || {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n-                QueryCtxt::from_tcx(tcx).encode_query_results(enc, qri);\n+                (tcx.query_system.fns.encode_query_results)(tcx, enc, qri);\n             });\n \n             // Encode side effects.\n@@ -358,12 +356,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             encoder.finish()\n         })\n     }\n-}\n-\n-impl<'sess> OnDiskCache<'sess> {\n-    pub fn as_dyn(&self) -> &dyn rustc_middle::ty::OnDiskCache<'sess> {\n-        self as _\n-    }\n \n     /// Loads a `QuerySideEffects` created during the previous compilation session.\n     pub fn load_side_effects(\n@@ -855,7 +847,7 @@ impl<'a, 'tcx> CacheEncoder<'a, 'tcx> {\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(&mut self, tag: T, value: &V) {\n+    pub fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(&mut self, tag: T, value: &V) {\n         let start_pos = self.position();\n \n         tag.encode(self);\n@@ -1032,33 +1024,3 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n         self.encode(&mut e.encoder);\n     }\n }\n-\n-pub(crate) fn encode_query_results<'a, 'tcx, Q>(\n-    query: Q,\n-    qcx: QueryCtxt<'tcx>,\n-    encoder: &mut CacheEncoder<'a, 'tcx>,\n-    query_result_index: &mut EncodedDepNodeIndex,\n-) where\n-    Q: super::QueryConfigRestored<'tcx>,\n-    Q::RestoredValue: Encodable<CacheEncoder<'a, 'tcx>>,\n-{\n-    let _timer = qcx\n-        .tcx\n-        .profiler()\n-        .verbose_generic_activity_with_arg(\"encode_query_results_for\", query.name());\n-\n-    assert!(query.query_state(qcx).all_inactive());\n-    let cache = query.query_cache(qcx);\n-    cache.iter(&mut |key, value, dep_node| {\n-        if query.cache_on_disk(qcx.tcx, &key) {\n-            let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n-\n-            // Record position of the cache entry.\n-            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.encoder.position())));\n-\n-            // Encode the type check tables with the `SerializedDepNodeIndex`\n-            // as tag.\n-            encoder.encode_tagged(dep_node, &Q::restore(*value));\n-        }\n-    });\n-}"}, {"sha": "7536903ef96fcf41dcab9535f8ec8e4a012c1f09", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -500,7 +500,6 @@ impl_arena_copy_decoder! {<'tcx>\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n-            use std::borrow::Cow;\n             use rustc_serialize::Decoder;\n \n             use super::$DecoderName;"}, {"sha": "d4beb49b1cf4998eb6ac7983a3e29578176468ff", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -14,11 +14,14 @@ use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{Body, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::query::on_disk_cache::OnDiskCache;\n use crate::query::LocalCrate;\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use crate::ty::query::QuerySystem;\n+use crate::ty::query::QuerySystemFns;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n@@ -31,7 +34,6 @@ use rustc_ast::{self as ast, attr};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -61,7 +63,6 @@ use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{FieldIdx, Layout, LayoutS, TargetDataLayout, VariantIdx};\n@@ -84,21 +85,6 @@ use super::query::IntoQueryParam;\n \n const TINY_CONST_EVAL_LIMIT: Limit = Limit(20);\n \n-pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n-    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n-    where\n-        Self: Sized;\n-\n-    fn new_empty(source_map: &'tcx SourceMap) -> Self\n-    where\n-        Self: Sized;\n-\n-    fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>);\n-\n-    fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: FileEncoder) -> FileEncodeResult;\n-}\n-\n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Interner for TyCtxt<'tcx> {\n     type AdtDef = ty::AdtDef<'tcx>;\n@@ -527,13 +513,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     untracked: Untracked,\n \n-    /// This provides access to the incremental compilation on-disk cache for query results.\n-    /// Do not access this directly. It is only meant to be used by\n-    /// `DepGraph::try_mark_green()` and the query infrastructure.\n-    /// This is `None` if we are not incremental compilation mode\n-    pub on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n-\n-    pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_system: query::QuerySystem<'tcx>,\n     pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n@@ -674,9 +653,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n         untracked: Untracked,\n         dep_graph: DepGraph,\n-        on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n-        queries: &'tcx dyn query::QueryEngine<'tcx>,\n+        on_disk_cache: Option<OnDiskCache<'tcx>>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n+        query_system_fns: QuerySystemFns<'tcx>,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n             s.emit_fatal(err);\n@@ -698,9 +677,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n             untracked,\n-            on_disk_cache,\n-            queries,\n-            query_system: Default::default(),\n+            query_system: QuerySystem::new(query_system_fns, on_disk_cache),\n             query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n@@ -1039,7 +1016,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n-        self.on_disk_cache.as_ref().map_or(Ok(0), |c| c.serialize(self, encoder))\n+        self.query_system.on_disk_cache.as_ref().map_or(Ok(0), |c| c.serialize(self, encoder))\n     }\n \n     /// If `true`, we should use lazy normalization for constants, otherwise"}, {"sha": "db6b35026a8e7852971678552c4b99f17c7aec55", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -84,8 +84,7 @@ pub use self::consts::{\n     Const, ConstData, ConstInt, ConstKind, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n-    tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n-    TyCtxtFeed,\n+    tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, TyCtxt, TyCtxtFeed,\n };\n pub use self::instance::{Instance, InstanceDef, ShortInstance, UnusedGenericParams};\n pub use self::list::List;"}, {"sha": "86e80a7a01de0cf44b919c60b58c5fddf4349268", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -1,6 +1,7 @@\n #![allow(unused_parens)]\n \n use crate::dep_graph;\n+use crate::dep_graph::DepKind;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintExpectation;\n use crate::metadata::ModChild;\n@@ -17,7 +18,11 @@ use crate::mir::interpret::{\n };\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n+\n use crate::query::erase::{erase, restore, Erase};\n+use crate::query::on_disk_cache::CacheEncoder;\n+use crate::query::on_disk_cache::EncodedDepNodeIndex;\n+use crate::query::on_disk_cache::OnDiskCache;\n use crate::query::{AsLocalKey, Key};\n use crate::thir;\n use crate::traits::query::{\n@@ -38,13 +43,16 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n+use measureme::StringId;\n use rustc_arena::TypedArena;\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::AtomicU64;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_data_structures::unord::UnordSet;\n@@ -58,6 +66,7 @@ use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::IndexVec;\n+use rustc_query_system::ich::StableHashingContext;\n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n@@ -76,17 +85,70 @@ use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_query_system::ich::StableHashingContext;\n+pub struct QueryKeyStringCache {\n+    pub def_id_cache: FxHashMap<DefId, StringId>,\n+}\n+\n+impl QueryKeyStringCache {\n+    pub fn new() -> QueryKeyStringCache {\n+        QueryKeyStringCache { def_id_cache: Default::default() }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct QueryStruct<'tcx> {\n+    pub try_collect_active_jobs: fn(TyCtxt<'tcx>, &mut QueryMap<DepKind>) -> Option<()>,\n+    pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n+    pub encode_query_results:\n+        Option<fn(TyCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n+}\n+\n+pub struct QuerySystemFns<'tcx> {\n+    pub engine: QueryEngine,\n+    pub local_providers: Providers,\n+    pub extern_providers: ExternProviders,\n+    pub query_structs: Vec<QueryStruct<'tcx>>,\n+    pub encode_query_results: fn(\n+        tcx: TyCtxt<'tcx>,\n+        encoder: &mut CacheEncoder<'_, 'tcx>,\n+        query_result_index: &mut EncodedDepNodeIndex,\n+    ),\n+    pub try_mark_green: fn(tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool,\n+}\n \n-#[derive(Default)]\n pub struct QuerySystem<'tcx> {\n+    pub states: QueryStates<'tcx>,\n     pub arenas: QueryArenas<'tcx>,\n     pub caches: QueryCaches<'tcx>,\n+\n+    /// This provides access to the incremental compilation on-disk cache for query results.\n+    /// Do not access this directly. It is only meant to be used by\n+    /// `DepGraph::try_mark_green()` and the query infrastructure.\n+    /// This is `None` if we are not incremental compilation mode\n+    pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n+\n+    pub fns: QuerySystemFns<'tcx>,\n+\n+    pub jobs: AtomicU64,\n+\n     // Since we erase query value types we tell the typesystem about them with `PhantomData`.\n     _phantom_values: QueryPhantomValues<'tcx>,\n }\n \n+impl<'tcx> QuerySystem<'tcx> {\n+    pub fn new(fns: QuerySystemFns<'tcx>, on_disk_cache: Option<OnDiskCache<'tcx>>) -> Self {\n+        QuerySystem {\n+            states: Default::default(),\n+            arenas: Default::default(),\n+            caches: Default::default(),\n+            on_disk_cache,\n+            fns,\n+            jobs: AtomicU64::new(1),\n+            _phantom_values: Default::default(),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TyCtxtAt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -136,7 +198,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn try_mark_green(self, dep_node: &dep_graph::DepNode) -> bool {\n-        self.queries.try_mark_green(self, dep_node)\n+        (self.query_system.fns.try_mark_green)(self, dep_node)\n     }\n }\n \n@@ -349,7 +411,7 @@ macro_rules! define_callbacks {\n \n                 match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n-                    None => self.tcx.queries.$name(\n+                    None => (self.tcx.query_system.fns.engine.$name)(\n                         self.tcx,\n                         DUMMY_SP,\n                         key,\n@@ -367,7 +429,7 @@ macro_rules! define_callbacks {\n \n                 match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n-                    None => self.tcx.queries.$name(\n+                    None => (self.tcx.query_system.fns.engine.$name)(\n                         self.tcx,\n                         DUMMY_SP,\n                         key,\n@@ -396,11 +458,22 @@ macro_rules! define_callbacks {\n \n                 restore::<$V>(match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n-                    None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n+                    None => (self.tcx.query_system.fns.engine.$name)(\n+                        self.tcx,\n+                        self.span,\n+                        key, QueryMode::Get\n+                    ).unwrap(),\n                 })\n             })*\n         }\n \n+        #[derive(Default)]\n+        pub struct QueryStates<'tcx> {\n+            $(\n+                pub $name: QueryState<$($K)*, DepKind>,\n+            )*\n+        }\n+\n         pub struct Providers {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n@@ -446,19 +519,13 @@ macro_rules! define_callbacks {\n             fn clone(&self) -> Self { *self }\n         }\n \n-        pub trait QueryEngine<'tcx>: rustc_data_structures::sync::Sync {\n-            fn as_any(&'tcx self) -> &'tcx dyn std::any::Any;\n-\n-            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool;\n-\n-            $($(#[$attr])*\n-            fn $name(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                span: Span,\n-                key: query_keys::$name<'tcx>,\n-                mode: QueryMode,\n-            ) -> Option<Erase<$V>>;)*\n+        pub struct QueryEngine {\n+            $(pub $name: for<'tcx> fn(\n+                TyCtxt<'tcx>,\n+                Span,\n+                query_keys::$name<'tcx>,\n+                QueryMode,\n+            ) -> Option<Erase<$V>>,)*\n         }\n     };\n }"}, {"sha": "82b335f4b4b5714d28c1f02c31add888bb525fee", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -11,36 +11,29 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n-#[macro_use]\n-extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n \n-use rustc_data_structures::sync::AtomicU64;\n+use crate::plumbing::{encode_all_query_results, try_mark_green};\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKind, DepKindStruct};\n use rustc_middle::query::erase::{erase, restore, Erase};\n use rustc_middle::query::AsLocalKey;\n use rustc_middle::ty::query::{\n     query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n };\n-use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n+use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine, QuerySystemFns};\n use rustc_middle::ty::TyCtxt;\n use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::Value;\n use rustc_span::Span;\n \n #[macro_use]\n mod plumbing;\n-pub use plumbing::QueryCtxt;\n-use rustc_query_system::query::*;\n-#[cfg(parallel_compiler)]\n-pub use rustc_query_system::query::{deadlock, QueryContext};\n+pub use crate::plumbing::QueryCtxt;\n \n pub use rustc_query_system::query::QueryConfig;\n-\n-mod on_disk_cache;\n-pub use on_disk_cache::OnDiskCache;\n+use rustc_query_system::query::*;\n \n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;\n@@ -54,9 +47,16 @@ trait QueryConfigRestored<'tcx>: QueryConfig<QueryCtxt<'tcx>> + Default {\n \n rustc_query_append! { define_queries! }\n \n-impl<'tcx> Queries<'tcx> {\n-    // Force codegen in the dyn-trait transformation in this crate.\n-    pub fn as_dyn(&'tcx self) -> &'tcx dyn QueryEngine<'tcx> {\n-        self\n+pub fn query_system_fns<'tcx>(\n+    local_providers: Providers,\n+    extern_providers: ExternProviders,\n+) -> QuerySystemFns<'tcx> {\n+    QuerySystemFns {\n+        engine: engine(),\n+        local_providers,\n+        extern_providers,\n+        query_structs: make_dep_kind_array!(query_structs).to_vec(),\n+        encode_query_results: encode_all_query_results,\n+        try_mark_green: try_mark_green,\n     }\n }"}, {"sha": "9f8ac7ccd0b8e9032d3d464c32727047766e4787", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 127, "deletions": 176, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -2,35 +2,44 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::on_disk_cache::{CacheDecoder, CacheEncoder, EncodedDepNodeIndex};\n-use crate::profiling_support::QueryKeyStringCache;\n-use crate::{on_disk_cache, Queries};\n+use crate::rustc_middle::dep_graph::DepContext;\n+use crate::rustc_middle::ty::TyEncoder;\n use rustc_data_structures::stable_hasher::{Hash64, HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU64, Lock};\n-use rustc_errors::{Diagnostic, Handler};\n+use rustc_data_structures::sync::Lock;\n+use rustc_errors::Diagnostic;\n+use rustc_index::Idx;\n use rustc_middle::dep_graph::{\n     self, DepKind, DepKindStruct, DepNode, DepNodeIndex, SerializedDepNodeIndex,\n };\n+use rustc_middle::query::on_disk_cache::AbsoluteBytePos;\n+use rustc_middle::query::on_disk_cache::{CacheDecoder, CacheEncoder, EncodedDepNodeIndex};\n use rustc_middle::query::Key;\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::{DepNodeParams, HasDepContext};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_query_system::query::{\n-    force_query, QueryConfig, QueryContext, QueryJobId, QueryMap, QuerySideEffects, QueryStackFrame,\n+    force_query, QueryCache, QueryConfig, QueryContext, QueryJobId, QueryMap, QuerySideEffects,\n+    QueryStackFrame,\n };\n use rustc_query_system::{LayoutOfDepth, QueryOverflow};\n use rustc_serialize::Decodable;\n+use rustc_serialize::Encodable;\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n-use std::any::Any;\n use std::num::NonZeroU64;\n use thin_vec::ThinVec;\n \n #[derive(Copy, Clone)]\n pub struct QueryCtxt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n-    pub queries: &'tcx Queries<'tcx>,\n+}\n+\n+impl<'tcx> QueryCtxt<'tcx> {\n+    #[inline]\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        QueryCtxt { tcx }\n+    }\n }\n \n impl<'tcx> std::ops::Deref for QueryCtxt<'tcx> {\n@@ -53,44 +62,56 @@ impl<'tcx> HasDepContext for QueryCtxt<'tcx> {\n }\n \n impl QueryContext for QueryCtxt<'_> {\n+    #[inline]\n     fn next_job_id(self) -> QueryJobId {\n         QueryJobId(\n             NonZeroU64::new(\n-                self.queries.jobs.fetch_add(1, rustc_data_structures::sync::Ordering::Relaxed),\n+                self.query_system.jobs.fetch_add(1, rustc_data_structures::sync::Ordering::Relaxed),\n             )\n             .unwrap(),\n         )\n     }\n \n+    #[inline]\n     fn current_query_job(self) -> Option<QueryJobId> {\n-        tls::with_related_context(*self, |icx| icx.query)\n+        tls::with_related_context(self.tcx, |icx| icx.query)\n     }\n \n     fn try_collect_active_jobs(self) -> Option<QueryMap<DepKind>> {\n-        self.queries.try_collect_active_jobs(*self)\n+        let mut jobs = QueryMap::default();\n+\n+        for query in &self.query_system.fns.query_structs {\n+            (query.try_collect_active_jobs)(self.tcx, &mut jobs);\n+        }\n+\n+        Some(jobs)\n     }\n \n     // Interactions with on_disk_cache\n     fn load_side_effects(self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n-        self.queries\n+        self.query_system\n             .on_disk_cache\n             .as_ref()\n-            .map(|c| c.load_side_effects(*self, prev_dep_node_index))\n+            .map(|c| c.load_side_effects(self.tcx, prev_dep_node_index))\n             .unwrap_or_default()\n     }\n \n+    #[inline(never)]\n+    #[cold]\n     fn store_side_effects(self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n-        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n+        if let Some(c) = self.query_system.on_disk_cache.as_ref() {\n             c.store_side_effects(dep_node_index, side_effects)\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n     fn store_side_effects_for_anon_node(\n         self,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n     ) {\n-        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n+        if let Some(c) = self.query_system.on_disk_cache.as_ref() {\n             c.store_side_effects_for_anon_node(dep_node_index, side_effects)\n         }\n     }\n@@ -109,14 +130,14 @@ impl QueryContext for QueryCtxt<'_> {\n         // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n         // when accessing the `ImplicitCtxt`.\n-        tls::with_related_context(*self, move |current_icx| {\n+        tls::with_related_context(self.tcx, move |current_icx| {\n             if depth_limit && !self.recursion_limit().value_within_limit(current_icx.query_depth) {\n                 self.depth_limit_error(token);\n             }\n \n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = ImplicitCtxt {\n-                tcx: *self,\n+                tcx: self.tcx,\n                 query: Some(token),\n                 diagnostics,\n                 query_depth: current_icx.query_depth + depth_limit as usize,\n@@ -152,51 +173,20 @@ impl QueryContext for QueryCtxt<'_> {\n     }\n }\n \n-impl<'tcx> QueryCtxt<'tcx> {\n-    #[inline]\n-    pub fn from_tcx(tcx: TyCtxt<'tcx>) -> Self {\n-        let queries = tcx.queries.as_any();\n-        let queries = unsafe {\n-            let queries = std::mem::transmute::<&dyn Any, &dyn Any>(queries);\n-            let queries = queries.downcast_ref().unwrap();\n-            let queries = std::mem::transmute::<&Queries<'_>, &Queries<'_>>(queries);\n-            queries\n-        };\n-        QueryCtxt { tcx, queries }\n-    }\n-\n-    pub(crate) fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n-        self.queries.on_disk_cache.as_ref()\n-    }\n+pub(super) fn try_mark_green<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool {\n+    tcx.dep_graph.try_mark_green(QueryCtxt::new(tcx), dep_node).is_some()\n+}\n \n-    pub(super) fn encode_query_results(\n-        self,\n-        encoder: &mut CacheEncoder<'_, 'tcx>,\n-        query_result_index: &mut EncodedDepNodeIndex,\n-    ) {\n-        for query in &self.queries.query_structs {\n-            if let Some(encode) = query.encode_query_results {\n-                encode(self, encoder, query_result_index);\n-            }\n+pub(super) fn encode_all_query_results<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    encoder: &mut CacheEncoder<'_, 'tcx>,\n+    query_result_index: &mut EncodedDepNodeIndex,\n+) {\n+    for query in &tcx.query_system.fns.query_structs {\n+        if let Some(encode) = query.encode_query_results {\n+            encode(tcx, encoder, query_result_index);\n         }\n     }\n-\n-    pub fn try_print_query_stack(\n-        self,\n-        query: Option<QueryJobId>,\n-        handler: &Handler,\n-        num_frames: Option<usize>,\n-    ) -> usize {\n-        rustc_query_system::query::print_query_stack(self, query, handler, num_frames)\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-pub(crate) struct QueryStruct<'tcx> {\n-    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap<DepKind>) -> Option<()>,\n-    pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n-    pub encode_query_results:\n-        Option<fn(QueryCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n }\n \n macro_rules! handle_cycle_error {\n@@ -276,13 +266,13 @@ macro_rules! hash_result {\n \n macro_rules! call_provider {\n     ([][$qcx:expr, $name:ident, $key:expr]) => {{\n-        ($qcx.queries.local_providers.$name)($qcx.tcx, $key)\n+        ($qcx.query_system.fns.local_providers.$name)($qcx, $key)\n     }};\n     ([(separate_provide_extern) $($rest:tt)*][$qcx:expr, $name:ident, $key:expr]) => {{\n         if let Some(key) = $key.as_local_key() {\n-            ($qcx.queries.local_providers.$name)($qcx.tcx, key)\n+            ($qcx.query_system.fns.local_providers.$name)($qcx, key)\n         } else {\n-            ($qcx.queries.extern_providers.$name)($qcx.tcx, $key)\n+            ($qcx.query_system.fns.extern_providers.$name)($qcx, $key)\n         }\n     }};\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n@@ -306,7 +296,7 @@ pub(crate) fn create_query_frame<\n     'tcx,\n     K: Copy + Key + for<'a> HashStable<StableHashingContext<'a>>,\n >(\n-    tcx: QueryCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     do_describe: fn(TyCtxt<'tcx>, K) -> String,\n     key: K,\n     kind: DepKind,\n@@ -318,7 +308,7 @@ pub(crate) fn create_query_frame<\n         // Showing visible path instead of any path is not that important in production.\n         ty::print::with_no_visible_paths!(\n             // Force filename-line mode to avoid invoking `type_of` query.\n-            ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n+            ty::print::with_forced_impl_filename_line!(do_describe(tcx, key))\n         )\n     );\n     let description =\n@@ -328,7 +318,7 @@ pub(crate) fn create_query_frame<\n         // so exit to avoid infinite recursion.\n         None\n     } else {\n-        Some(key.default_span(*tcx))\n+        Some(key.default_span(tcx))\n     };\n     let def_id = key.key_as_def_id();\n     let def_kind = if kind == dep_graph::DepKind::opt_def_kind {\n@@ -350,6 +340,34 @@ pub(crate) fn create_query_frame<\n     QueryStackFrame::new(description, span, def_id, def_kind, kind, ty_adt_id, hash)\n }\n \n+pub(crate) fn encode_query_results<'a, 'tcx, Q>(\n+    query: Q,\n+    qcx: QueryCtxt<'tcx>,\n+    encoder: &mut CacheEncoder<'a, 'tcx>,\n+    query_result_index: &mut EncodedDepNodeIndex,\n+) where\n+    Q: super::QueryConfigRestored<'tcx>,\n+    Q::RestoredValue: Encodable<CacheEncoder<'a, 'tcx>>,\n+{\n+    let _timer =\n+        qcx.profiler().verbose_generic_activity_with_arg(\"encode_query_results_for\", query.name());\n+\n+    assert!(query.query_state(qcx).all_inactive());\n+    let cache = query.query_cache(qcx);\n+    cache.iter(&mut |key, value, dep_node| {\n+        if query.cache_on_disk(qcx.tcx, &key) {\n+            let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n+\n+            // Record position of the cache entry.\n+            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n+\n+            // Encode the type check tables with the `SerializedDepNodeIndex`\n+            // as tag.\n+            encoder.encode_tagged(dep_node, &Q::restore(*value));\n+        }\n+    });\n+}\n+\n fn try_load_from_on_disk_cache<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode)\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n@@ -364,22 +382,22 @@ where\n     }\n }\n \n-pub(crate) fn loadable_from_disk<'tcx>(tcx: QueryCtxt<'tcx>, id: SerializedDepNodeIndex) -> bool {\n-    if let Some(cache) = tcx.on_disk_cache().as_ref() {\n+pub(crate) fn loadable_from_disk<'tcx>(tcx: TyCtxt<'tcx>, id: SerializedDepNodeIndex) -> bool {\n+    if let Some(cache) = tcx.query_system.on_disk_cache.as_ref() {\n         cache.loadable_from_disk(id)\n     } else {\n         false\n     }\n }\n \n pub(crate) fn try_load_from_disk<'tcx, V>(\n-    tcx: QueryCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     id: SerializedDepNodeIndex,\n ) -> Option<V>\n where\n     V: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n {\n-    tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id)\n+    tcx.query_system.on_disk_cache.as_ref()?.try_load_query_result(tcx, id)\n }\n \n fn force_from_dep_node<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n@@ -407,8 +425,7 @@ where\n     if let Some(key) = Q::Key::recover(tcx, &dep_node) {\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();\n-        let tcx = QueryCtxt::from_tcx(tcx);\n-        force_query(query, tcx, key, dep_node);\n+        force_query(query, QueryCtxt::new(tcx), key, dep_node);\n         true\n     } else {\n         false\n@@ -461,8 +478,33 @@ macro_rules! define_queries {\n     (\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-        define_queries_struct! {\n-            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n+        mod get_query {\n+            use super::*;\n+\n+            $(\n+                #[inline(always)]\n+                #[tracing::instrument(level = \"trace\", skip(tcx))]\n+                pub(super) fn $name<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    span: Span,\n+                    key: query_keys::$name<'tcx>,\n+                    mode: QueryMode,\n+                ) -> Option<Erase<query_values::$name<'tcx>>> {\n+                    get_query(\n+                        queries::$name::default(),\n+                        QueryCtxt::new(tcx),\n+                        span,\n+                        key,\n+                        mode\n+                    )\n+                }\n+            )*\n+        }\n+\n+        pub(crate) fn engine() -> QueryEngine {\n+            QueryEngine {\n+                $($name: get_query::$name,)*\n+            }\n         }\n \n         #[allow(nonstandard_style)]\n@@ -502,7 +544,7 @@ macro_rules! define_queries {\n             fn query_state<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n                 where QueryCtxt<'tcx>: 'a\n             {\n-                &tcx.queries.$name\n+                &tcx.query_system.states.$name\n             }\n \n             #[inline(always)]\n@@ -521,7 +563,7 @@ macro_rules! define_queries {\n             fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 query_provided_to_value::$name(\n                     qcx.tcx,\n-                    call_provider!([$($modifiers)*][qcx, $name, key])\n+                    call_provider!([$($modifiers)*][qcx.tcx, $name, key])\n                 )\n             }\n \n@@ -535,7 +577,7 @@ macro_rules! define_queries {\n                     if ::rustc_middle::query::cached::$name(_qcx.tcx, _key) {\n                         Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n                             let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n-                                qcx,\n+                                qcx.tcx,\n                                 dep_node\n                             );\n                             value.map(|value| query_provided_to_value::$name(qcx.tcx, value))\n@@ -557,7 +599,7 @@ macro_rules! define_queries {\n             ) -> bool {\n                 should_ever_cache_on_disk!([$($modifiers)*] {\n                     self.cache_on_disk(_qcx.tcx, _key) &&\n-                        $crate::plumbing::loadable_from_disk(_qcx, _index)\n+                        $crate::plumbing::loadable_from_disk(_qcx.tcx, _index)\n                 } {\n                     false\n                 })\n@@ -684,14 +726,13 @@ macro_rules! define_queries {\n         }\n \n         mod query_structs {\n-            use rustc_middle::ty::TyCtxt;\n-            use $crate::plumbing::{QueryStruct, QueryCtxt};\n-            use $crate::profiling_support::QueryKeyStringCache;\n-            use rustc_query_system::query::QueryMap;\n+            use super::*;\n+            use rustc_middle::ty::query::QueryStruct;\n+            use rustc_middle::ty::query::QueryKeyStringCache;\n             use rustc_middle::dep_graph::DepKind;\n \n             pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n-                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n+                fn noop_try_collect_active_jobs(_: TyCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n                     None\n                 }\n                 fn noop_alloc_self_profile_query_strings(_: TyCtxt<'_>, _: &mut QueryKeyStringCache) {}\n@@ -717,7 +758,7 @@ macro_rules! define_queries {\n                         let name = stringify!($name);\n                         $crate::plumbing::create_query_frame(tcx, rustc_middle::query::descs::$name, key, kind, name)\n                     };\n-                    tcx.queries.$name.try_collect_active_jobs(\n+                    tcx.query_system.states.$name.try_collect_active_jobs(\n                         tcx,\n                         make_query,\n                         qmap,\n@@ -731,10 +772,10 @@ macro_rules! define_queries {\n                         string_cache,\n                     )\n                 },\n-                encode_query_results: expand_if_cached!([$($modifiers)*], |qcx, encoder, query_result_index|\n-                    $crate::on_disk_cache::encode_query_results::<super::queries::$name<'tcx>>(\n+                encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n+                    $crate::plumbing::encode_query_results::<super::queries::$name<'tcx>>(\n                         super::queries::$name::default(),\n-                        qcx,\n+                        QueryCtxt::new(tcx),\n                         encoder,\n                         query_result_index,\n                     )\n@@ -747,93 +788,3 @@ macro_rules! define_queries {\n         }\n     }\n }\n-\n-use crate::{ExternProviders, OnDiskCache, Providers};\n-\n-impl<'tcx> Queries<'tcx> {\n-    pub fn new(\n-        local_providers: Providers,\n-        extern_providers: ExternProviders,\n-        on_disk_cache: Option<OnDiskCache<'tcx>>,\n-    ) -> Self {\n-        use crate::query_structs;\n-        Queries {\n-            local_providers: Box::new(local_providers),\n-            extern_providers: Box::new(extern_providers),\n-            query_structs: make_dep_kind_array!(query_structs).to_vec(),\n-            on_disk_cache,\n-            jobs: AtomicU64::new(1),\n-            ..Queries::default()\n-        }\n-    }\n-}\n-\n-macro_rules! define_queries_struct {\n-    (\n-     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n-        #[derive(Default)]\n-        pub struct Queries<'tcx> {\n-            local_providers: Box<Providers>,\n-            extern_providers: Box<ExternProviders>,\n-            query_structs: Vec<$crate::plumbing::QueryStruct<'tcx>>,\n-            pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n-            jobs: AtomicU64,\n-\n-            $(\n-                $(#[$attr])*\n-                $name: QueryState<\n-                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n-                    rustc_middle::dep_graph::DepKind,\n-                >,\n-            )*\n-        }\n-\n-        impl<'tcx> Queries<'tcx> {\n-            pub(crate) fn try_collect_active_jobs(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-            ) -> Option<QueryMap<rustc_middle::dep_graph::DepKind>> {\n-                let tcx = QueryCtxt { tcx, queries: self };\n-                let mut jobs = QueryMap::default();\n-\n-                for query in &self.query_structs {\n-                    (query.try_collect_active_jobs)(tcx, &mut jobs);\n-                }\n-\n-                Some(jobs)\n-            }\n-        }\n-\n-        impl<'tcx> QueryEngine<'tcx> for Queries<'tcx> {\n-            fn as_any(&'tcx self) -> &'tcx dyn std::any::Any {\n-                let this = unsafe { std::mem::transmute::<&Queries<'_>, &Queries<'_>>(self) };\n-                this as _\n-            }\n-\n-            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool {\n-                let qcx = QueryCtxt { tcx, queries: self };\n-                tcx.dep_graph.try_mark_green(qcx, dep_node).is_some()\n-            }\n-\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            #[tracing::instrument(level = \"trace\", skip(self, tcx))]\n-            fn $name(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                span: Span,\n-                key: query_keys::$name<'tcx>,\n-                mode: QueryMode,\n-            ) -> Option<Erase<query_values::$name<'tcx>>> {\n-                let qcx = QueryCtxt { tcx, queries: self };\n-                get_query(\n-                    queries::$name::default(),\n-                    qcx,\n-                    span,\n-                    key,\n-                    mode\n-                )\n-            })*\n-        }\n-    };\n-}"}, {"sha": "7d9306f8087eddc62f553c69d65d4a341ae2b5d5", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -1,24 +1,13 @@\n-use crate::QueryCtxt;\n use measureme::{StringComponent, StringId};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n+use rustc_middle::ty::query::QueryKeyStringCache;\n use rustc_middle::ty::TyCtxt;\n use rustc_query_system::query::QueryCache;\n use std::fmt::Debug;\n use std::io::Write;\n \n-pub(crate) struct QueryKeyStringCache {\n-    def_id_cache: FxHashMap<DefId, StringId>,\n-}\n-\n-impl QueryKeyStringCache {\n-    fn new() -> QueryKeyStringCache {\n-        QueryKeyStringCache { def_id_cache: Default::default() }\n-    }\n-}\n-\n struct QueryKeyStringBuilder<'p, 'tcx> {\n     profiler: &'p SelfProfiler,\n     tcx: TyCtxt<'tcx>,\n@@ -253,9 +242,8 @@ pub fn alloc_self_profile_query_strings(tcx: TyCtxt<'_>) {\n     }\n \n     let mut string_cache = QueryKeyStringCache::new();\n-    let queries = QueryCtxt::from_tcx(tcx);\n \n-    for query in &queries.queries.query_structs {\n+    for query in &tcx.query_system.fns.query_structs {\n         (query.alloc_self_profile_query_strings)(tcx, &mut string_cache);\n     }\n }"}, {"sha": "aa22140c99d525a3196e3bbe34b8924e9b26e575", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d85438cad26aee7ff0d123739edcc43e16bc4a/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=66d85438cad26aee7ff0d123739edcc43e16bc4a", "patch": "@@ -1190,6 +1190,7 @@ impl Session {\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n+    #[inline]\n     pub fn threads(&self) -> usize {\n         self.opts.unstable_opts.threads\n     }"}]}