{"sha": "8484b9935c4d0a8e2209511a0094cc92ba09f561", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODRiOTkzNWM0ZDBhOGUyMjA5NTExYTAwOTRjYzkyYmEwOWY1NjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-08T07:55:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-08T07:55:18Z"}, "message": "Rollup merge of #72026 - botika:master, r=estebank\n\nUpdate annotate-snippets-rs to 0.8.0\n\n#59346\nI made major changes to this library. In the previous version we worked with owned while in the current one with borrowed.\n\nI have adapted it without changing the behavior.\nI have modified the coverage since the previous one did not return correctly the index of the character in the line.", "tree": {"sha": "8c3a9c3859c879ff809db8a8671e8330a9c707d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c3a9c3859c879ff809db8a8671e8330a9c707d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8484b9935c4d0a8e2209511a0094cc92ba09f561", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe3e7mCRBK7hj4Ov3rIwAAdHIIAGYxHmXLfeFQr7BdFkTCqXfa\njnAkAEywtZZKsnsp5VWFcsV6yUobwhPrw9QxWyp4KWXNzJVl1YFIryjKMScR7K5B\nppk615mkah7knb8xWiIuWKBN52hdAmpDPH4hDLwew24tvcBRBwLSqC/K5TTLE1/K\n5FAW9JnDeUTGhuA1O99eUfm4ncwhNsktsHwMBGhd3a/Q0DNAsWMRSrRFam8WgjDB\naUhvCI54Ey7xq8VzQBKu/8i3x8Xrpip7FkohQkCqfxo5mud8oruJoWh/dNr2b6U4\noHokdIykEA2FXzkc3FHttYV2DclGI/IrMz+NSkaOlBXDrgHcsqlpE6FPZQWqn1k=\n=nwTD\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c3a9c3859c879ff809db8a8671e8330a9c707d8\nparent 73558160933b2764ed9a84b1b2b647e128eac3f8\nparent 8fc62029114a917969a55a50f05c1688599a5c33\nauthor Ralf Jung <post@ralfj.de> 1591602918 +0200\ncommitter GitHub <noreply@github.com> 1591602918 +0200\n\nRollup merge of #72026 - botika:master, r=estebank\n\nUpdate annotate-snippets-rs to 0.8.0\n\n#59346\nI made major changes to this library. In the previous version we worked with owned while in the current one with borrowed.\n\nI have adapted it without changing the behavior.\nI have modified the coverage since the previous one did not return correctly the index of the character in the line.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8484b9935c4d0a8e2209511a0094cc92ba09f561", "html_url": "https://github.com/rust-lang/rust/commit/8484b9935c4d0a8e2209511a0094cc92ba09f561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8484b9935c4d0a8e2209511a0094cc92ba09f561/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73558160933b2764ed9a84b1b2b647e128eac3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/73558160933b2764ed9a84b1b2b647e128eac3f8", "html_url": "https://github.com/rust-lang/rust/commit/73558160933b2764ed9a84b1b2b647e128eac3f8"}, {"sha": "8fc62029114a917969a55a50f05c1688599a5c33", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc62029114a917969a55a50f05c1688599a5c33", "html_url": "https://github.com/rust-lang/rust/commit/8fc62029114a917969a55a50f05c1688599a5c33"}], "stats": {"total": 338, "additions": 210, "deletions": 128}, "files": [{"sha": "76665d5a6f7f35fe25498321e480b3321790c83b", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -48,6 +48,12 @@ dependencies = [\n  \"ansi_term\",\n ]\n \n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -3316,7 +3322,7 @@ version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0c374e89b3c9714869ef86076942155383804ba6778c26be2169d324563c31f9\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3810,7 +3816,7 @@ version = \"0.0.0\"\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"log\",\n  \"rustc_data_structures\",\n@@ -4477,7 +4483,7 @@ dependencies = [\n name = \"rustfmt-nightly\"\n version = \"1.4.15\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"bytecount\",\n  \"cargo_metadata 0.8.0\",\n  \"derive-new\","}, {"sha": "7f72161aff826a09091bc7012cdabd0582c67b52", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -17,7 +17,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.6.1\"\n+annotate-snippets = \"0.8.0\"\n termize = \"0.1.1\"\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "5b47364e714e910dbf6792c98af13e119944a74b", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 92, "deletions": 123, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -8,12 +8,11 @@\n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, SubDiagnostic};\n-use annotate_snippets::display_list::DisplayList;\n-use annotate_snippets::formatter::DisplayListFormatter;\n+use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Loc, MultiSpan, SourceFile};\n+use rustc_span::{MultiSpan, SourceFile};\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n@@ -59,112 +58,20 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n     }\n }\n \n-/// Collects all the data needed to generate the data structures needed for the\n-/// `annotate-snippets` library.\n-struct DiagnosticConverter<'a> {\n-    source_map: Option<Lrc<SourceMap>>,\n-    level: Level,\n-    message: String,\n-    code: Option<DiagnosticId>,\n-    msp: MultiSpan,\n-    #[allow(dead_code)]\n-    children: &'a [SubDiagnostic],\n-    #[allow(dead_code)]\n-    suggestions: &'a [CodeSuggestion],\n+/// Provides the source string for the given `line` of `file`\n+fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n+    file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or_default()\n }\n \n-impl<'a> DiagnosticConverter<'a> {\n-    /// Turns rustc Diagnostic information into a `annotate_snippets::snippet::Snippet`.\n-    fn to_annotation_snippet(&self) -> Option<Snippet> {\n-        if let Some(source_map) = &self.source_map {\n-            // Make sure our primary file comes first\n-            let primary_lo = if let Some(ref primary_span) = self.msp.primary_span().as_ref() {\n-                source_map.lookup_char_pos(primary_span.lo())\n-            } else {\n-                // FIXME(#59346): Not sure when this is the case and what\n-                // should be done if it happens\n-                return None;\n-            };\n-            let annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(&self.msp, &self.source_map);\n-            let slices = self.slices_for_files(annotated_files, primary_lo);\n-\n-            Some(Snippet {\n-                title: Some(Annotation {\n-                    label: Some(self.message.to_string()),\n-                    id: self.code.clone().map(|c| match c {\n-                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val,\n-                    }),\n-                    annotation_type: Self::annotation_type_for_level(self.level),\n-                }),\n-                footer: vec![],\n-                slices,\n-            })\n-        } else {\n-            // FIXME(#59346): Is it ok to return None if there's no source_map?\n-            None\n-        }\n-    }\n-\n-    fn slices_for_files(\n-        &self,\n-        annotated_files: Vec<FileWithAnnotatedLines>,\n-        primary_lo: Loc,\n-    ) -> Vec<Slice> {\n-        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n-        annotated_files\n-            .iter()\n-            .flat_map(|annotated_file| {\n-                annotated_file\n-                    .lines\n-                    .iter()\n-                    .map(|line| {\n-                        let line_source = Self::source_string(annotated_file.file.clone(), &line);\n-                        Slice {\n-                            source: line_source,\n-                            line_start: line.line_index,\n-                            origin: Some(primary_lo.file.name.to_string()),\n-                            // FIXME(#59346): Not really sure when `fold` should be true or false\n-                            fold: false,\n-                            annotations: line\n-                                .annotations\n-                                .iter()\n-                                .map(|a| self.annotation_to_source_annotation(a.clone()))\n-                                .collect(),\n-                        }\n-                    })\n-                    .collect::<Vec<Slice>>()\n-            })\n-            .collect::<Vec<Slice>>()\n-    }\n-\n-    /// Turns a `crate::snippet::Annotation` into a `SourceAnnotation`\n-    fn annotation_to_source_annotation(\n-        &self,\n-        annotation: crate::snippet::Annotation,\n-    ) -> SourceAnnotation {\n-        SourceAnnotation {\n-            range: (annotation.start_col, annotation.end_col),\n-            label: annotation.label.unwrap_or(\"\".to_string()),\n-            annotation_type: Self::annotation_type_for_level(self.level),\n-        }\n-    }\n-\n-    /// Provides the source string for the given `line` of `file`\n-    fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n-        file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or(String::new())\n-    }\n-\n-    /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n-    fn annotation_type_for_level(level: Level) -> AnnotationType {\n-        match level {\n-            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n-            Level::Warning => AnnotationType::Warning,\n-            Level::Note => AnnotationType::Note,\n-            Level::Help => AnnotationType::Help,\n-            // FIXME(#59346): Not sure how to map these two levels\n-            Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n-        }\n+/// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n+fn annotation_type_for_level(level: Level) -> AnnotationType {\n+    match level {\n+        Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n+        Level::Warning => AnnotationType::Warning,\n+        Level::Note => AnnotationType::Note,\n+        Level::Help => AnnotationType::Help,\n+        // FIXME(#59346): Not sure how to map these two levels\n+        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n     }\n }\n \n@@ -191,25 +98,87 @@ impl AnnotateSnippetEmitterWriter {\n         message: String,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n-        children: &[SubDiagnostic],\n-        suggestions: &[CodeSuggestion],\n+        _children: &[SubDiagnostic],\n+        _suggestions: &[CodeSuggestion],\n     ) {\n-        let converter = DiagnosticConverter {\n-            source_map: self.source_map.clone(),\n-            level: *level,\n-            message,\n-            code: code.clone(),\n-            msp: msp.clone(),\n-            children,\n-            suggestions,\n-        };\n-        if let Some(snippet) = converter.to_annotation_snippet() {\n-            let dl = DisplayList::from(snippet);\n-            let dlf = DisplayListFormatter::new(true, self.ui_testing);\n+        if let Some(source_map) = &self.source_map {\n+            // Make sure our primary file comes first\n+            let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+                if primary_span.is_dummy() {\n+                    // FIXME(#59346): Not sure when this is the case and what\n+                    // should be done if it happens\n+                    return;\n+                } else {\n+                    source_map.lookup_char_pos(primary_span.lo())\n+                }\n+            } else {\n+                // FIXME(#59346): Not sure when this is the case and what\n+                // should be done if it happens\n+                return;\n+            };\n+            let mut annotated_files =\n+                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n+            {\n+                annotated_files.swap(0, pos);\n+            }\n+            // owned: line source, line index, annotations\n+            type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n+            let origin = primary_lo.file.name.to_string();\n+            let annotated_files: Vec<Owned> = annotated_files\n+                .into_iter()\n+                .flat_map(|annotated_file| {\n+                    let file = annotated_file.file;\n+                    annotated_file\n+                        .lines\n+                        .into_iter()\n+                        .map(|line| {\n+                            (source_string(file.clone(), &line), line.line_index, line.annotations)\n+                        })\n+                        .collect::<Vec<Owned>>()\n+                })\n+                .collect();\n+            let snippet = Snippet {\n+                title: Some(Annotation {\n+                    label: Some(&message),\n+                    id: code.as_ref().map(|c| match c {\n+                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val.as_str(),\n+                    }),\n+                    annotation_type: annotation_type_for_level(*level),\n+                }),\n+                footer: vec![],\n+                opt: FormatOptions { color: true, anonymized_line_numbers: self.ui_testing },\n+                slices: annotated_files\n+                    .iter()\n+                    .map(|(source, line_index, annotations)| {\n+                        Slice {\n+                            source,\n+                            line_start: *line_index,\n+                            origin: Some(&origin),\n+                            // FIXME(#59346): Not really sure when `fold` should be true or false\n+                            fold: false,\n+                            annotations: annotations\n+                                .into_iter()\n+                                .map(|annotation| SourceAnnotation {\n+                                    range: (annotation.start_col, annotation.end_col),\n+                                    label: annotation\n+                                        .label\n+                                        .as_ref()\n+                                        .map(|s| s.as_str())\n+                                        .unwrap_or_default(),\n+                                    annotation_type: annotation_type_for_level(*level),\n+                                })\n+                                .collect(),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n             // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n             // `emitter.rs` has the `Destination` enum that lists various possible output\n             // destinations.\n-            eprintln!(\"{}\", dlf.format(&dl));\n-        };\n+            eprintln!(\"{}\", DisplayList::from(snippet))\n+        }\n+        // FIXME(#59346): Is it ok to return None if there's no source_map?\n     }\n }"}, {"sha": "c05d15643dbb12518c3cd69d646758985408a701", "filename": "src/test/ui/annotate-snippet/auxiliary/multispan.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -0,0 +1,37 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_diagnostic, proc_macro_span, proc_macro_def_site)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, Span, Diagnostic};\n+\n+fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n+    let mut hi_spans = vec![];\n+    for tree in input {\n+        if let TokenTree::Ident(ref ident) = tree {\n+            if ident.to_string() == \"hi\" {\n+                hi_spans.push(ident.span());\n+            }\n+        }\n+    }\n+\n+    if !hi_spans.is_empty() {\n+        return Err(Span::def_site()\n+                       .error(\"hello to you, too!\")\n+                       .span_note(hi_spans, \"found these 'hi's\"));\n+    }\n+\n+    Ok(())\n+}\n+\n+#[proc_macro]\n+pub fn hello(input: TokenStream) -> TokenStream {\n+    if let Err(diag) = parse(input) {\n+        diag.emit();\n+    }\n+\n+    TokenStream::new()\n+}"}, {"sha": "c16f022a77fa338c5edc16d91d6d81d50be029ff", "filename": "src/test/ui/annotate-snippet/missing-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -1,5 +1,5 @@\n error[E0412]: cannot find type `Iter` in this scope\n-  --> $DIR/missing-type.rs:4:11\n+  --> $DIR/missing-type.rs:4:12\n    |\n LL |     let x: Iter;\n    |            ^^^^ not found in this scope"}, {"sha": "325252d7716f60b1ab6d5c720e627e9c29ce52cf", "filename": "src/test/ui/annotate-snippet/multispan.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -0,0 +1,28 @@\n+// aux-build:multispan.rs\n+// compile-flags: --error-format human-annotate-rs\n+\n+#![feature(proc_macro_hygiene)]\n+\n+extern crate multispan;\n+\n+use multispan::hello;\n+\n+fn main() {\n+    // This one emits no error.\n+    hello!();\n+\n+    // Exactly one 'hi'.\n+    hello!(hi); //~ ERROR hello to you, too!\n+\n+    // Now two, back to back.\n+    hello!(hi hi); //~ ERROR hello to you, too!\n+\n+    // Now three, back to back.\n+    hello!(hi hi hi); //~ ERROR hello to you, too!\n+\n+    // Now several, with spacing.\n+    hello!(hi hey hi yo hi beep beep hi hi); //~ ERROR hello to you, too!\n+    hello!(hi there, hi how are you? hi... hi.); //~ ERROR hello to you, too!\n+    hello!(whoah. hi di hi di ho); //~ ERROR hello to you, too!\n+    hello!(hi good hi and good bye); //~ ERROR hello to you, too!\n+}"}, {"sha": "4ac31e32ba7cfa80f6e025598f8ad3f7f4ab3e3c", "filename": "src/test/ui/annotate-snippet/multispan.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8484b9935c4d0a8e2209511a0094cc92ba09f561/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr?ref=8484b9935c4d0a8e2209511a0094cc92ba09f561", "patch": "@@ -0,0 +1,42 @@\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:15:5\n+   |\n+LL |     hello!(hi);\n+   |     ^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:18:5\n+   |\n+LL |     hello!(hi hi);\n+   |     ^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:21:5\n+   |\n+LL |     hello!(hi hi hi);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:24:5\n+   |\n+LL |     hello!(hi hey hi yo hi beep beep hi hi);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:25:5\n+   |\n+LL |     hello!(hi there, hi how are you? hi... hi.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:26:5\n+   |\n+LL |     hello!(whoah. hi di hi di ho);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:27:5\n+   |\n+LL |     hello!(hi good hi and good bye);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |"}]}