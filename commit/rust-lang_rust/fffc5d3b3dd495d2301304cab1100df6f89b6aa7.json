{"sha": "fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZmM1ZDNiM2RkNDk1ZDIzMDEzMDRjYWIxMTAwZGY2Zjg5YjZhYTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T00:38:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T01:28:59Z"}, "message": "rustc: Write out a path index as well", "tree": {"sha": "c66986008c9644f339a212e36552d58399d7241f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c66986008c9644f339a212e36552d58399d7241f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "html_url": "https://github.com/rust-lang/rust/commit/fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fffc5d3b3dd495d2301304cab1100df6f89b6aa7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b65a61cad6fffebcc97e25688d0133d28181f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b65a61cad6fffebcc97e25688d0133d28181f44", "html_url": "https://github.com/rust-lang/rust/commit/1b65a61cad6fffebcc97e25688d0133d28181f44"}], "stats": {"total": 191, "additions": 124, "deletions": 67}, "files": [{"sha": "f9ef70ca740df69231fa9cdf7b234ac4dd3c7e6d", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fffc5d3b3dd495d2301304cab1100df6f89b6aa7/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffc5d3b3dd495d2301304cab1100df6f89b6aa7/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "patch": "@@ -268,14 +268,14 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n             auto found = false;\n             while (ebml.bytes_left(ebml_r) > 0u && !found) {\n                 auto ebml_tag = ebml.peek(ebml_r);\n-                if ((ebml_tag.id == metadata.tag_paths_item) ||\n-                        (ebml_tag.id == metadata.tag_paths_mod)) {\n+                if ((ebml_tag.id == metadata.tag_paths_data_item) ||\n+                        (ebml_tag.id == metadata.tag_paths_data_mod)) {\n                     ebml.move_to_first_child(ebml_r);\n                     auto did_opt = none[ast.def_id];\n                     auto name_opt = none[ast.ident];\n                     while (ebml.bytes_left(ebml_r) > 0u) {\n                         auto inner_tag = ebml.peek(ebml_r);\n-                        if (inner_tag.id == metadata.tag_paths_name) {\n+                        if (inner_tag.id == metadata.tag_paths_data_name) {\n                             ebml.move_to_first_child(ebml_r);\n                             auto name_data = ebml.read_data(ebml_r);\n                             ebml.move_to_parent(ebml_r);\n@@ -335,8 +335,8 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n \n impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n     ebml.move_to_sibling_with_id(ebml_r, metadata.tag_items);\n-    ebml.move_to_child_with_id(ebml_r, metadata.tag_items_index);\n-    ebml.move_to_child_with_id(ebml_r, metadata.tag_items_index_table);\n+    ebml.move_to_child_with_id(ebml_r, metadata.tag_index);\n+    ebml.move_to_child_with_id(ebml_r, metadata.tag_index_table);\n     ebml.move_to_first_child(ebml_r);\n \n     // Move to the bucket.\n@@ -347,11 +347,10 @@ impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n     ebml.reset_reader(ebml_r, bucket_pos);\n \n     // Search to find the item ID in the bucket.\n-    check (ebml.peek(ebml_r).id == metadata.tag_items_index_buckets_bucket);\n+    check (ebml.peek(ebml_r).id == metadata.tag_index_buckets_bucket);\n     ebml.move_to_first_child(ebml_r);\n     while (ebml.bytes_left(ebml_r) > 0u) {\n-        if (ebml.peek(ebml_r).id ==\n-                metadata.tag_items_index_buckets_bucket_elt) {\n+        if (ebml.peek(ebml_r).id == metadata.tag_index_buckets_bucket_elt) {\n             ebml.move_to_first_child(ebml_r);\n             auto pos = ebml_r.reader.read_be_uint(4u);\n             auto this_item_id = ebml_r.reader.read_be_uint(4u) as int;"}, {"sha": "6a470e39e9cad0df8f7c35e025c87810c0a6c21a", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 117, "deletions": 59, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/fffc5d3b3dd495d2301304cab1100df6f89b6aa7/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffc5d3b3dd495d2301304cab1100df6f89b6aa7/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "patch": "@@ -19,27 +19,28 @@ import lib.llvm.False;\n const uint tag_paths = 0x01u;\n const uint tag_items = 0x02u;\n \n-const uint tag_paths_name = 0x03u;\n-const uint tag_paths_item = 0x04u;\n-const uint tag_paths_mod = 0x05u;\n-\n-const uint tag_def_id = 0x06u;\n-\n-const uint tag_items_data = 0x07u;\n-const uint tag_items_data_item = 0x08u;\n-const uint tag_items_data_item_kind = 0x09u;\n-const uint tag_items_data_item_ty_param = 0x0au;\n-const uint tag_items_data_item_type = 0x0bu;\n-const uint tag_items_data_item_symbol = 0x0cu;\n-const uint tag_items_data_item_variant = 0x0du;\n-const uint tag_items_data_item_tag_id = 0x0eu;\n-const uint tag_items_data_item_obj_type_id = 0x0fu;\n-\n-const uint tag_items_index = 0x10u;\n-const uint tag_items_index_buckets = 0x11u;\n-const uint tag_items_index_buckets_bucket = 0x12u;\n-const uint tag_items_index_buckets_bucket_elt = 0x13u;\n-const uint tag_items_index_table = 0x14u;\n+const uint tag_paths_data = 0x03u;\n+const uint tag_paths_data_name = 0x04u;\n+const uint tag_paths_data_item = 0x05u;\n+const uint tag_paths_data_mod = 0x06u;\n+\n+const uint tag_def_id = 0x07u;\n+\n+const uint tag_items_data = 0x08u;\n+const uint tag_items_data_item = 0x09u;\n+const uint tag_items_data_item_kind = 0x0au;\n+const uint tag_items_data_item_ty_param = 0x0bu;\n+const uint tag_items_data_item_type = 0x0cu;\n+const uint tag_items_data_item_symbol = 0x0du;\n+const uint tag_items_data_item_variant = 0x0eu;\n+const uint tag_items_data_item_tag_id = 0x0fu;\n+const uint tag_items_data_item_obj_type_id = 0x10u;\n+\n+const uint tag_index = 0x11u;\n+const uint tag_index_buckets = 0x12u;\n+const uint tag_index_buckets_bucket = 0x13u;\n+const uint tag_index_buckets_bucket_elt = 0x14u;\n+const uint tag_index_table = 0x15u;\n \n // Type encoding\n \n@@ -164,7 +165,7 @@ fn C_postr(str s) -> ValueRef {\n // Path table encoding\n \n fn encode_name(&ebml.writer ebml_w, str name) {\n-    ebml.start_tag(ebml_w, tag_paths_name);\n+    ebml.start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(_str.bytes(name));\n     ebml.end_tag(ebml_w);\n }\n@@ -177,25 +178,37 @@ fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n \n fn encode_tag_variant_paths(&ebml.writer ebml_w, vec[ast.variant] variants) {\n     for (ast.variant variant in variants) {\n-        ebml.start_tag(ebml_w, tag_paths_item);\n+        ebml.start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, variant.node.id);\n         ebml.end_tag(ebml_w);\n     }\n }\n \n+fn add_to_index(&ebml.writer ebml_w,\n+                vec[str] path,\n+                &mutable vec[tup(str, uint)] index,\n+                str name) {\n+    auto full_path = path + vec(name);\n+    index += vec(tup(_str.connect(full_path, \".\"), ebml_w.writer.tell()));\n+}\n+\n fn encode_native_module_item_paths(&ebml.writer ebml_w,\n-                                   &ast.native_mod nmod) {\n+                                   &ast.native_mod nmod,\n+                                   vec[str] path,\n+                                   &mutable vec[tup(str, uint)] index) {\n     for (@ast.native_item nitem in nmod.items) {\n         alt (nitem.node) {\n             case (ast.native_item_ty(?id, ?did)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.native_item_fn(?id, _, _, _, ?did, _)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n@@ -204,51 +217,62 @@ fn encode_native_module_item_paths(&ebml.writer ebml_w,\n     }\n }\n \n-fn encode_module_item_paths(&ebml.writer ebml_w, &ast._mod module) {\n+fn encode_module_item_paths(&ebml.writer ebml_w,\n+                            &ast._mod module,\n+                            vec[str] path,\n+                            &mutable vec[tup(str, uint)] index) {\n     // TODO: only encode exported items\n     for (@ast.item it in module.items) {\n         alt (it.node) {\n             case (ast.item_const(?id, _, ?tps, ?did, ?ann)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_fn(?id, _, ?tps, ?did, ?ann)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_mod(?id, ?_mod, ?did)) {\n-                ebml.start_tag(ebml_w, tag_paths_mod);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                encode_module_item_paths(ebml_w, _mod);\n+                encode_module_item_paths(ebml_w, _mod, path + vec(id), index);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_native_mod(?id, ?nmod, ?did)) {\n-                ebml.start_tag(ebml_w, tag_paths_mod);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                encode_native_module_item_paths(ebml_w, nmod);\n+                encode_native_module_item_paths(ebml_w, nmod, path + vec(id),\n+                                                index);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_tag(?id, ?variants, ?tps, ?did)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_tag_variant_paths(ebml_w, variants);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n             }\n             case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n-                ebml.start_tag(ebml_w, tag_paths_item);\n+                add_to_index(ebml_w, path, index, id);\n+                ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, odid.ctor);\n                 encode_obj_type_id(ebml_w, odid.ty);\n@@ -258,10 +282,14 @@ fn encode_module_item_paths(&ebml.writer ebml_w, &ast._mod module) {\n     }\n }\n \n-fn encode_item_paths(&ebml.writer ebml_w, @ast.crate crate) {\n+fn encode_item_paths(&ebml.writer ebml_w, @ast.crate crate)\n+        -> vec[tup(str, uint)] {\n+    let vec[tup(str, uint)] index = vec();\n+    let vec[str] path = vec();\n     ebml.start_tag(ebml_w, tag_paths);\n-    encode_module_item_paths(ebml_w, crate.node.module);\n+    encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebml.end_tag(ebml_w);\n+    ret index;\n }\n \n \n@@ -442,51 +470,61 @@ fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n }\n \n \n-// Definition ID indexing\n+// Path and definition ID indexing\n+\n+// djb's cdb hashes.\n \n-fn hash_def_num(int def_num) -> uint {\n+fn hash_def_num(&int def_num) -> uint {\n     ret 177573u ^ (def_num as uint);\n }\n \n-fn create_index(vec[tup(int, uint)] index) -> vec[vec[tup(int, uint)]] {\n-    let vec[vec[tup(int, uint)]] buckets = vec();\n+fn hash_path(&str s) -> uint {\n+    auto h = 5381u;\n+    for (u8 ch in _str.bytes(s)) {\n+        h = ((h << 5u) + h) ^ (ch as uint);\n+    }\n+    ret h;\n+}\n+\n+fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n+        -> vec[vec[tup(T, uint)]] {\n+    let vec[vec[tup(T, uint)]] buckets = vec();\n     for each (uint i in _uint.range(0u, 256u)) {\n-        let vec[tup(int, uint)] bucket = vec();\n+        let vec[tup(T, uint)] bucket = vec();\n         buckets += vec(bucket);\n     }\n \n-    for (tup(int, uint) elt in index) {\n-        auto h = hash_def_num(elt._0);\n+    for (tup(T, uint) elt in index) {\n+        auto h = hash_fn(elt._0);\n         buckets.(h % 256u) += vec(elt);\n     }\n \n     ret buckets;\n }\n \n-impure fn encode_index(&ebml.writer ebml_w, vec[tup(int, uint)] index) {\n+impure fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n+                          impure fn(io.writer, &T) write_fn) {\n     auto writer = io.new_writer_(ebml_w.writer);\n \n-    auto buckets = create_index(index);\n-\n-    ebml.start_tag(ebml_w, tag_items_index);\n+    ebml.start_tag(ebml_w, tag_index);\n \n     let vec[uint] bucket_locs = vec();\n-    ebml.start_tag(ebml_w, tag_items_index_buckets);\n-    for (vec[tup(int, uint)] bucket in buckets) {\n+    ebml.start_tag(ebml_w, tag_index_buckets);\n+    for (vec[tup(T, uint)] bucket in buckets) {\n         bucket_locs += vec(ebml_w.writer.tell());\n \n-        ebml.start_tag(ebml_w, tag_items_index_buckets_bucket);\n-        for (tup(int, uint) elt in bucket) {\n-            ebml.start_tag(ebml_w, tag_items_index_buckets_bucket_elt);\n+        ebml.start_tag(ebml_w, tag_index_buckets_bucket);\n+        for (tup(T, uint) elt in bucket) {\n+            ebml.start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n-            writer.write_be_uint(elt._0 as uint, 4u);\n+            write_fn(writer, elt._0);\n             ebml.end_tag(ebml_w);\n         }\n         ebml.end_tag(ebml_w);\n     }\n     ebml.end_tag(ebml_w);\n \n-    ebml.start_tag(ebml_w, tag_items_index_table);\n+    ebml.start_tag(ebml_w, tag_index_table);\n     for (uint pos in bucket_locs) {\n         writer.write_be_uint(pos, 4u);\n     }\n@@ -496,17 +534,37 @@ impure fn encode_index(&ebml.writer ebml_w, vec[tup(int, uint)] index) {\n }\n \n \n+impure fn write_str(io.writer writer, &str s) {\n+    writer.write_str(s);\n+}\n+\n+impure fn write_int(io.writer writer, &int n) {\n+    writer.write_be_uint(n as uint, 4u);\n+}\n+\n+\n impure fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n         -> ValueRef {\n     auto string_w = io.string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n     auto ebml_w = ebml.create_writer(buf_w);\n \n-    encode_item_paths(ebml_w, crate);\n+    // Encode and index the paths.\n+    ebml.start_tag(ebml_w, tag_paths);\n+    auto paths_index = encode_item_paths(ebml_w, crate);\n+    auto str_writer = write_str;\n+    auto path_hasher = hash_path;\n+    auto paths_buckets = create_index[str](paths_index, path_hasher);\n+    encode_index[str](ebml_w, paths_buckets, str_writer);\n+    ebml.end_tag(ebml_w);\n \n+    // Encode and index the items.\n     ebml.start_tag(ebml_w, tag_items);\n-    auto index = encode_info_for_items(cx, ebml_w);\n-    encode_index(ebml_w, index);\n+    auto items_index = encode_info_for_items(cx, ebml_w);\n+    auto int_writer = write_int;\n+    auto item_hasher = hash_def_num;\n+    auto items_buckets = create_index[int](items_index, item_hasher);\n+    encode_index[int](ebml_w, items_buckets, int_writer);\n     ebml.end_tag(ebml_w);\n \n     ret C_postr(string_w.get_str());"}]}