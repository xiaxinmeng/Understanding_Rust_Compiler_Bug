{"sha": "10853f71f2360ee21665c9b481e3be01f35ee902", "node_id": "C_kwDOAAsO6NoAKDEwODUzZjcxZjIzNjBlZTIxNjY1YzliNDgxZTNiZTAxZjM1ZWU5MDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T09:27:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T09:27:33Z"}, "message": "Auto merge of #8694 - Jarcho:check_proc_macro, r=xFrednet\n\nMore proc-macro detection\n\nfixes #6514\nfixes #8683\nfixes #6858\nfixes #6594\n\nThis is a more general way of checking if an expression comes from a macro and could be trivially applied to other lints. Ideally this would be fixed in rustc's proc-macro api, but I don't see that happening any time soon.\n\nchangelog: FPs: [`unit_arg`] [`default_trait_access`] [`missing_docs_in_private_items`]: No longer trigger in code generated from proc-macros.", "tree": {"sha": "c630408d0ec6af27a06a62b65606b87c7230d9cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c630408d0ec6af27a06a62b65606b87c7230d9cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10853f71f2360ee21665c9b481e3be01f35ee902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10853f71f2360ee21665c9b481e3be01f35ee902", "html_url": "https://github.com/rust-lang/rust/commit/10853f71f2360ee21665c9b481e3be01f35ee902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10853f71f2360ee21665c9b481e3be01f35ee902/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97a0cf2de2367187c1f9eb9d9f6d333cb8bc8b8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/97a0cf2de2367187c1f9eb9d9f6d333cb8bc8b8f", "html_url": "https://github.com/rust-lang/rust/commit/97a0cf2de2367187c1f9eb9d9f6d333cb8bc8b8f"}, {"sha": "745b1942925c53156389f3ea731c360e507f71eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/745b1942925c53156389f3ea731c360e507f71eb", "html_url": "https://github.com/rust-lang/rust/commit/745b1942925c53156389f3ea731c360e507f71eb"}], "stats": {"total": 532, "additions": 439, "deletions": 93}, "files": [{"sha": "74f7df611778ec32d61d9a056f23dccd727756ec", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{has_drop, is_copy};\n-use clippy_utils::{any_parent_is_automatically_derived, contains_name, get_parent_expr, match_def_path, paths};\n+use clippy_utils::{\n+    any_parent_is_automatically_derived, contains_name, get_parent_expr, is_from_proc_macro, match_def_path, paths,\n+};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -94,6 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n             if let QPath::Resolved(None, _path) = qpath;\n             let expr_ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, ..) = expr_ty.kind();\n+            if !is_from_proc_macro(cx, expr);\n             then {\n                 // TODO: Work out a way to put \"whatever the imported way of referencing\n                 // this type in this file\" rather than a fully-qualified type."}, {"sha": "01cefe4af8532638a5179eba0c26fde9599fcdbe", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n+use clippy_utils::is_span_if;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -297,12 +298,11 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n     if_chain! {\n         if !first.span.from_expansion() && !second.span.from_expansion();\n-        if let ExprKind::If(cond_expr, ..) = &first.kind;\n+        if matches!(first.kind, ExprKind::If(..));\n         if is_block(second) || is_if(second);\n \n         // Proc-macros can give weird spans. Make sure this is actually an `if`.\n-        if let Some(if_snip) = snippet_opt(cx, first.span.until(cond_expr.span));\n-        if if_snip.starts_with(\"if\");\n+        if is_span_if(cx, first.span);\n \n         // If there is a line break between the two expressions, don't lint.\n         // If there is a non-whitespace character, this span came from a proc-macro."}, {"sha": "91bd0c7decee22f1c66c1dbf8f3a0d1e94d1370c", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -21,8 +21,8 @@ mod single_match;\n mod try_err;\n mod wild_in_or_pats;\n \n-use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n-use clippy_utils::{higher, in_constant, meets_msrv, msrvs};\n+use clippy_utils::source::{snippet_opt, walk_span_to_context};\n+use clippy_utils::{higher, in_constant, is_span_match, meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -949,7 +949,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         let from_expansion = expr.span.from_expansion();\n \n         if let ExprKind::Match(ex, arms, source) = expr.kind {\n-            if source == MatchSource::Normal && !span_starts_with(cx, expr.span, \"match\") {\n+            if source == MatchSource::Normal && !is_span_match(cx, expr.span) {\n                 return;\n             }\n             if matches!(source, MatchSource::Normal | MatchSource::ForLoopDesugar) {"}, {"sha": "7ef80b1a5960e8288f07c5e8b229c55e5c855b45", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -7,6 +7,7 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_from_proc_macro;\n use if_chain::if_chain;\n use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n@@ -158,14 +159,18 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n-        self.check_missing_docs_attrs(cx, attrs, it.span, article, desc);\n+        if !is_from_proc_macro(cx, it) {\n+            self.check_missing_docs_attrs(cx, attrs, it.span, article, desc);\n+        }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(trait_item.hir_id());\n-        self.check_missing_docs_attrs(cx, attrs, trait_item.span, article, desc);\n+        if !is_from_proc_macro(cx, trait_item) {\n+            self.check_missing_docs_attrs(cx, attrs, trait_item.span, article, desc);\n+        }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n@@ -181,18 +186,24 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n         let attrs = cx.tcx.hir().attrs(impl_item.hir_id());\n-        self.check_missing_docs_attrs(cx, attrs, impl_item.span, article, desc);\n+        if !is_from_proc_macro(cx, impl_item) {\n+            self.check_missing_docs_attrs(cx, attrs, impl_item.span, article, desc);\n+        }\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'tcx>, sf: &'tcx hir::FieldDef<'_>) {\n         if !sf.is_positional() {\n             let attrs = cx.tcx.hir().attrs(sf.hir_id);\n-            self.check_missing_docs_attrs(cx, attrs, sf.span, \"a\", \"struct field\");\n+            if !is_from_proc_macro(cx, sf) {\n+                self.check_missing_docs_attrs(cx, attrs, sf.span, \"a\", \"struct field\");\n+            }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n         let attrs = cx.tcx.hir().attrs(v.id);\n-        self.check_missing_docs_attrs(cx, attrs, v.span, \"a\", \"variant\");\n+        if !is_from_proc_macro(cx, v) {\n+            self.check_missing_docs_attrs(cx, attrs, v.span, \"a\", \"variant\");\n+        }\n     }\n }"}, {"sha": "546242ebd9a474d1c27d8b39ad986472814f71d7", "filename": "clippy_lints/src/unit_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitTypes {\n         let_unit_value::check(cx, local);\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         unit_cmp::check(cx, expr);\n         unit_arg::check(cx, expr);\n     }"}, {"sha": "16da2f11b81a6a6650b07d9dde5062461720c5b5", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_from_proc_macro;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -7,7 +8,7 @@ use rustc_lint::LateContext;\n \n use super::{utils, UNIT_ARG};\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n     if expr.span.from_expansion() {\n         return;\n     }\n@@ -44,7 +45,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     }\n                 })\n                 .collect::<Vec<_>>();\n-            if !args_to_recover.is_empty() {\n+            if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n                 lint_unit_args(cx, expr, &args_to_recover);\n             }\n         },"}, {"sha": "0f00a1cdf0fa29a1b99c6cdeccb4c963c327e8b3", "filename": "clippy_utils/src/check_proc_macro.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -0,0 +1,297 @@\n+//! This module handles checking if the span given is from a proc-macro or not.\n+//!\n+//! Proc-macros are capable of setting the span of every token they output to a few possible spans.\n+//! This includes spans we can detect easily as coming from a proc-macro (e.g. the call site\n+//! or the def site), and spans we can't easily detect as such (e.g. the span of any token\n+//! passed into the proc macro). This capability means proc-macros are capable of generating code\n+//! with a span that looks like it was written by the user, but which should not be linted by clippy\n+//! as it was generated by an external macro.\n+//!\n+//! That brings us to this module. The current approach is to determine a small bit of text which\n+//! must exist at both the start and the end of an item (e.g. an expression or a path) assuming the\n+//! code was written, and check if the span contains that text. Note this will only work correctly\n+//! if the span is not from a `macro_rules` based macro.\n+\n+use rustc_ast::ast::{IntTy, LitIntType, LitKind, StrStyle, UintTy};\n+use rustc_hir::{\n+    Block, BlockCheckMode, Closure, Destination, Expr, ExprKind, FieldDef, FnHeader, Impl, ImplItem, ImplItemKind,\n+    IsAuto, Item, ItemKind, LoopSource, MatchSource, QPath, TraitItem, TraitItemKind, UnOp, UnsafeSource, Unsafety,\n+    Variant, VariantData, YieldSource,\n+};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+use rustc_span::{Span, Symbol};\n+use rustc_target::spec::abi::Abi;\n+\n+/// The search pattern to look for. Used by `span_matches_pat`\n+#[derive(Clone, Copy)]\n+pub enum Pat {\n+    /// A single string.\n+    Str(&'static str),\n+    /// Any of the given strings.\n+    MultiStr(&'static [&'static str]),\n+    /// The string representation of the symbol.\n+    Sym(Symbol),\n+    /// Any decimal or hexadecimal digit depending on the location.\n+    Num,\n+}\n+\n+/// Checks if the start and the end of the span's text matches the patterns. This will return false\n+/// if the span crosses multiple files or if source is not available.\n+fn span_matches_pat(sess: &Session, span: Span, start_pat: Pat, end_pat: Pat) -> bool {\n+    let pos = sess.source_map().lookup_byte_offset(span.lo());\n+    let Some(ref src) = pos.sf.src else {\n+        return false;\n+    };\n+    let end = span.hi() - pos.sf.start_pos;\n+    src.get(pos.pos.0 as usize..end.0 as usize).map_or(false, |s| {\n+        // Spans can be wrapped in a mixture or parenthesis, whitespace, and trailing commas.\n+        let start_str = s.trim_start_matches(|c: char| c.is_whitespace() || c == '(');\n+        let end_str = s.trim_end_matches(|c: char| c.is_whitespace() || c == ')' || c == ',');\n+        (match start_pat {\n+            Pat::Str(text) => start_str.starts_with(text),\n+            Pat::MultiStr(texts) => texts.iter().any(|s| start_str.starts_with(s)),\n+            Pat::Sym(sym) => start_str.starts_with(sym.as_str()),\n+            Pat::Num => start_str.as_bytes().first().map_or(false, u8::is_ascii_digit),\n+        } && match end_pat {\n+            Pat::Str(text) => end_str.ends_with(text),\n+            Pat::MultiStr(texts) => texts.iter().any(|s| start_str.ends_with(s)),\n+            Pat::Sym(sym) => end_str.ends_with(sym.as_str()),\n+            Pat::Num => end_str.as_bytes().last().map_or(false, u8::is_ascii_hexdigit),\n+        })\n+    })\n+}\n+\n+/// Get the search patterns to use for the given literal\n+fn lit_search_pat(lit: &LitKind) -> (Pat, Pat) {\n+    match lit {\n+        LitKind::Str(_, StrStyle::Cooked) => (Pat::Str(\"\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::Str(_, StrStyle::Raw(0)) => (Pat::Str(\"r\"), Pat::Str(\"\\\"\")),\n+        LitKind::Str(_, StrStyle::Raw(_)) => (Pat::Str(\"r#\"), Pat::Str(\"#\")),\n+        LitKind::ByteStr(_) => (Pat::Str(\"b\\\"\"), Pat::Str(\"\\\"\")),\n+        LitKind::Byte(_) => (Pat::Str(\"b'\"), Pat::Str(\"'\")),\n+        LitKind::Char(_) => (Pat::Str(\"'\"), Pat::Str(\"'\")),\n+        LitKind::Int(_, LitIntType::Signed(IntTy::Isize)) => (Pat::Num, Pat::Str(\"isize\")),\n+        LitKind::Int(_, LitIntType::Unsigned(UintTy::Usize)) => (Pat::Num, Pat::Str(\"usize\")),\n+        LitKind::Int(..) => (Pat::Num, Pat::Num),\n+        LitKind::Float(..) => (Pat::Num, Pat::Str(\"\")),\n+        LitKind::Bool(true) => (Pat::Str(\"true\"), Pat::Str(\"true\")),\n+        LitKind::Bool(false) => (Pat::Str(\"false\"), Pat::Str(\"false\")),\n+        _ => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+/// Get the search patterns to use for the given path\n+fn qpath_search_pat(path: &QPath<'_>) -> (Pat, Pat) {\n+    match path {\n+        QPath::Resolved(ty, path) => {\n+            let start = if ty.is_some() {\n+                Pat::Str(\"<\")\n+            } else {\n+                path.segments\n+                    .first()\n+                    .map_or(Pat::Str(\"\"), |seg| Pat::Sym(seg.ident.name))\n+            };\n+            let end = path.segments.last().map_or(Pat::Str(\"\"), |seg| {\n+                if seg.args.is_some() {\n+                    Pat::Str(\">\")\n+                } else {\n+                    Pat::Sym(seg.ident.name)\n+                }\n+            });\n+            (start, end)\n+        },\n+        QPath::TypeRelative(_, name) => (Pat::Str(\"\"), Pat::Sym(name.ident.name)),\n+        QPath::LangItem(..) => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+/// Get the search patterns to use for the given expression\n+fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n+    match e.kind {\n+        ExprKind::Box(e) => (Pat::Str(\"box\"), expr_search_pat(tcx, e).1),\n+        ExprKind::ConstBlock(_) => (Pat::Str(\"const\"), Pat::Str(\"}\")),\n+        ExprKind::Tup([]) => (Pat::Str(\")\"), Pat::Str(\"(\")),\n+        ExprKind::Unary(UnOp::Deref, e) => (Pat::Str(\"*\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Unary(UnOp::Not, e) => (Pat::Str(\"!\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Unary(UnOp::Neg, e) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n+        ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n+        ExprKind::Call(e, []) | ExprKind::MethodCall(_, [e], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n+        ExprKind::Call(first, [.., last])\n+        | ExprKind::MethodCall(_, [first, .., last], _)\n+        | ExprKind::Binary(_, first, last)\n+        | ExprKind::Tup([first, .., last])\n+        | ExprKind::Assign(first, last, _)\n+        | ExprKind::AssignOp(_, first, last) => (expr_search_pat(tcx, first).0, expr_search_pat(tcx, last).1),\n+        ExprKind::Tup([e]) | ExprKind::DropTemps(e) => expr_search_pat(tcx, e),\n+        ExprKind::Cast(e, _) | ExprKind::Type(e, _) => (expr_search_pat(tcx, e).0, Pat::Str(\"\")),\n+        ExprKind::Let(let_expr) => (Pat::Str(\"let\"), expr_search_pat(tcx, let_expr.init).1),\n+        ExprKind::If(..) => (Pat::Str(\"if\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, Some(_), _, _) | ExprKind::Block(_, Some(_)) => (Pat::Str(\"'\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::Loop, _) => (Pat::Str(\"loop\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::While, _) => (Pat::Str(\"while\"), Pat::Str(\"}\")),\n+        ExprKind::Loop(_, None, LoopSource::ForLoop, _) | ExprKind::Match(_, _, MatchSource::ForLoopDesugar) => {\n+            (Pat::Str(\"for\"), Pat::Str(\"}\"))\n+        },\n+        ExprKind::Match(_, _, MatchSource::Normal) => (Pat::Str(\"match\"), Pat::Str(\"}\")),\n+        ExprKind::Match(e, _, MatchSource::TryDesugar) => (expr_search_pat(tcx, e).0, Pat::Str(\"?\")),\n+        ExprKind::Match(e, _, MatchSource::AwaitDesugar) | ExprKind::Yield(e, YieldSource::Await { .. }) => {\n+            (expr_search_pat(tcx, e).0, Pat::Str(\"await\"))\n+        },\n+        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, &tcx.hir().body(body).value).1),\n+        ExprKind::Block(\n+            Block {\n+                rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ..\n+            },\n+            None,\n+        ) => (Pat::Str(\"unsafe\"), Pat::Str(\"}\")),\n+        ExprKind::Block(_, None) => (Pat::Str(\"{\"), Pat::Str(\"}\")),\n+        ExprKind::Field(e, name) => (expr_search_pat(tcx, e).0, Pat::Sym(name.name)),\n+        ExprKind::Index(e, _) => (expr_search_pat(tcx, e).0, Pat::Str(\"]\")),\n+        ExprKind::Path(ref path) => qpath_search_pat(path),\n+        ExprKind::AddrOf(_, _, e) => (Pat::Str(\"&\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Break(Destination { label: None, .. }, None) => (Pat::Str(\"break\"), Pat::Str(\"break\")),\n+        ExprKind::Break(Destination { label: Some(name), .. }, None) => (Pat::Str(\"break\"), Pat::Sym(name.ident.name)),\n+        ExprKind::Break(_, Some(e)) => (Pat::Str(\"break\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Continue(Destination { label: None, .. }) => (Pat::Str(\"continue\"), Pat::Str(\"continue\")),\n+        ExprKind::Continue(Destination { label: Some(name), .. }) => (Pat::Str(\"continue\"), Pat::Sym(name.ident.name)),\n+        ExprKind::Ret(None) => (Pat::Str(\"return\"), Pat::Str(\"return\")),\n+        ExprKind::Ret(Some(e)) => (Pat::Str(\"return\"), expr_search_pat(tcx, e).1),\n+        ExprKind::Struct(path, _, _) => (qpath_search_pat(path).0, Pat::Str(\"}\")),\n+        ExprKind::Yield(e, YieldSource::Yield) => (Pat::Str(\"yield\"), expr_search_pat(tcx, e).1),\n+        _ => (Pat::Str(\"\"), Pat::Str(\"\")),\n+    }\n+}\n+\n+fn fn_header_search_pat(header: FnHeader) -> Pat {\n+    if header.is_async() {\n+        Pat::Str(\"async\")\n+    } else if header.is_const() {\n+        Pat::Str(\"const\")\n+    } else if header.is_unsafe() {\n+        Pat::Str(\"unsafe\")\n+    } else if header.abi != Abi::Rust {\n+        Pat::Str(\"extern\")\n+    } else {\n+        Pat::MultiStr(&[\"fn\", \"extern\"])\n+    }\n+}\n+\n+fn item_search_pat(item: &Item<'_>) -> (Pat, Pat) {\n+    let (start_pat, end_pat) = match &item.kind {\n+        ItemKind::ExternCrate(_) => (Pat::Str(\"extern\"), Pat::Str(\";\")),\n+        ItemKind::Static(..) => (Pat::Str(\"static\"), Pat::Str(\";\")),\n+        ItemKind::Const(..) => (Pat::Str(\"const\"), Pat::Str(\";\")),\n+        ItemKind::Fn(sig, ..) => (fn_header_search_pat(sig.header), Pat::Str(\"\")),\n+        ItemKind::ForeignMod { .. } => (Pat::Str(\"extern\"), Pat::Str(\"}\")),\n+        ItemKind::TyAlias(..) | ItemKind::OpaqueTy(_) => (Pat::Str(\"type\"), Pat::Str(\";\")),\n+        ItemKind::Enum(..) => (Pat::Str(\"enum\"), Pat::Str(\"}\")),\n+        ItemKind::Struct(VariantData::Struct(..), _) => (Pat::Str(\"struct\"), Pat::Str(\"}\")),\n+        ItemKind::Struct(..) => (Pat::Str(\"struct\"), Pat::Str(\";\")),\n+        ItemKind::Union(..) => (Pat::Str(\"union\"), Pat::Str(\"}\")),\n+        ItemKind::Trait(_, Unsafety::Unsafe, ..)\n+        | ItemKind::Impl(Impl {\n+            unsafety: Unsafety::Unsafe,\n+            ..\n+        }) => (Pat::Str(\"unsafe\"), Pat::Str(\"}\")),\n+        ItemKind::Trait(IsAuto::Yes, ..) => (Pat::Str(\"auto\"), Pat::Str(\"}\")),\n+        ItemKind::Trait(..) => (Pat::Str(\"trait\"), Pat::Str(\"}\")),\n+        ItemKind::Impl(_) => (Pat::Str(\"impl\"), Pat::Str(\"}\")),\n+        _ => return (Pat::Str(\"\"), Pat::Str(\"\")),\n+    };\n+    if item.vis_span.is_empty() {\n+        (start_pat, end_pat)\n+    } else {\n+        (Pat::Str(\"pub\"), end_pat)\n+    }\n+}\n+\n+fn trait_item_search_pat(item: &TraitItem<'_>) -> (Pat, Pat) {\n+    match &item.kind {\n+        TraitItemKind::Const(..) => (Pat::Str(\"const\"), Pat::Str(\";\")),\n+        TraitItemKind::Type(..) => (Pat::Str(\"type\"), Pat::Str(\";\")),\n+        TraitItemKind::Fn(sig, ..) => (fn_header_search_pat(sig.header), Pat::Str(\"\")),\n+    }\n+}\n+\n+fn impl_item_search_pat(item: &ImplItem<'_>) -> (Pat, Pat) {\n+    let (start_pat, end_pat) = match &item.kind {\n+        ImplItemKind::Const(..) => (Pat::Str(\"const\"), Pat::Str(\";\")),\n+        ImplItemKind::TyAlias(..) => (Pat::Str(\"type\"), Pat::Str(\";\")),\n+        ImplItemKind::Fn(sig, ..) => (fn_header_search_pat(sig.header), Pat::Str(\"\")),\n+    };\n+    if item.vis_span.is_empty() {\n+        (start_pat, end_pat)\n+    } else {\n+        (Pat::Str(\"pub\"), end_pat)\n+    }\n+}\n+\n+fn field_def_search_pat(def: &FieldDef<'_>) -> (Pat, Pat) {\n+    if def.vis_span.is_empty() {\n+        if def.is_positional() {\n+            (Pat::Str(\"\"), Pat::Str(\"\"))\n+        } else {\n+            (Pat::Sym(def.ident.name), Pat::Str(\"\"))\n+        }\n+    } else {\n+        (Pat::Str(\"pub\"), Pat::Str(\"\"))\n+    }\n+}\n+\n+fn variant_search_pat(v: &Variant<'_>) -> (Pat, Pat) {\n+    match v.data {\n+        VariantData::Struct(..) => (Pat::Sym(v.ident.name), Pat::Str(\"}\")),\n+        VariantData::Tuple(..) => (Pat::Sym(v.ident.name), Pat::Str(\"\")),\n+        VariantData::Unit(..) => (Pat::Sym(v.ident.name), Pat::Sym(v.ident.name)),\n+    }\n+}\n+\n+pub trait WithSearchPat {\n+    type Context: LintContext;\n+    fn search_pat(&self, cx: &Self::Context) -> (Pat, Pat);\n+    fn span(&self) -> Span;\n+}\n+macro_rules! impl_with_search_pat {\n+    ($cx:ident: $ty:ident with $fn:ident $(($tcx:ident))?) => {\n+        impl<'cx> WithSearchPat for $ty<'cx> {\n+            type Context = $cx<'cx>;\n+            #[allow(unused_variables)]\n+            fn search_pat(&self, cx: &Self::Context) -> (Pat, Pat) {\n+                $(let $tcx = cx.tcx;)?\n+                $fn($($tcx,)? self)\n+            }\n+            fn span(&self) -> Span {\n+                self.span\n+            }\n+        }\n+    };\n+}\n+impl_with_search_pat!(LateContext: Expr with expr_search_pat(tcx));\n+impl_with_search_pat!(LateContext: Item with item_search_pat);\n+impl_with_search_pat!(LateContext: TraitItem with trait_item_search_pat);\n+impl_with_search_pat!(LateContext: ImplItem with impl_item_search_pat);\n+impl_with_search_pat!(LateContext: FieldDef with field_def_search_pat);\n+impl_with_search_pat!(LateContext: Variant with variant_search_pat);\n+\n+/// Checks if the item likely came from a proc-macro.\n+///\n+/// This should be called after `in_external_macro` and the initial pattern matching of the ast as\n+/// it is significantly slower than both of those.\n+pub fn is_from_proc_macro<T: WithSearchPat>(cx: &T::Context, item: &T) -> bool {\n+    let (start_pat, end_pat) = item.search_pat(cx);\n+    !span_matches_pat(cx.sess(), item.span(), start_pat, end_pat)\n+}\n+\n+/// Checks if the span actually refers to a match expression\n+pub fn is_span_match(cx: &impl LintContext, span: Span) -> bool {\n+    span_matches_pat(cx.sess(), span, Pat::Str(\"match\"), Pat::Str(\"}\"))\n+}\n+\n+/// Checks if the span actually refers to an if expression\n+pub fn is_span_if(cx: &impl LintContext, span: Span) -> bool {\n+    span_matches_pat(cx.sess(), span, Pat::Str(\"if\"), Pat::Str(\"}\"))\n+}"}, {"sha": "dcfc03475b423d134252b1eedd5c1db22e972a1d", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -38,6 +38,7 @@ pub mod sym_helper;\n \n pub mod ast_utils;\n pub mod attrs;\n+mod check_proc_macro;\n pub mod comparisons;\n pub mod consts;\n pub mod diagnostics;\n@@ -58,6 +59,7 @@ pub mod usage;\n pub mod visitors;\n \n pub use self::attrs::*;\n+pub use self::check_proc_macro::{is_from_proc_macro, is_span_if, is_span_match};\n pub use self::hir_utils::{\n     both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };"}, {"sha": "d85f591fb9a42f0c087f61dfe95da170d65db5aa", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -11,24 +11,6 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext};\n use std::borrow::Cow;\n \n-/// Checks if the span starts with the given text. This will return false if the span crosses\n-/// multiple files or if source is not available.\n-///\n-/// This is used to check for proc macros giving unhelpful spans to things.\n-pub fn span_starts_with<T: LintContext>(cx: &T, span: Span, text: &str) -> bool {\n-    fn helper(sm: &SourceMap, span: Span, text: &str) -> bool {\n-        let pos = sm.lookup_byte_offset(span.lo());\n-        let Some(ref src) = pos.sf.src else {\n-            return false;\n-        };\n-        let end = span.hi() - pos.sf.start_pos;\n-        src.get(pos.pos.0 as usize..end.0 as usize)\n-            // Expression spans can include wrapping parenthesis. Remove them first.\n-            .map_or(false, |s| s.trim_start_matches('(').starts_with(text))\n-    }\n-    helper(cx.sess().source_map(), span, text)\n-}\n-\n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, T: LintContext>("}, {"sha": "fce66eb175963ee4b78247e85e5d12545567dbcb", "filename": "tests/ui/default_trait_access.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.fixed?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,8 +1,12 @@\n // run-rustfix\n+// aux-build: proc_macro_with_span.rs\n \n #![allow(unused_imports, dead_code)]\n #![deny(clippy::default_trait_access)]\n \n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n use std::default;\n use std::default::Default as D2;\n use std::string;\n@@ -51,6 +55,8 @@ fn main() {\n         ..Default::default()\n     };\n \n+    let _s21: String = with_span!(s Default::default());\n+\n     println!(\n         \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}]\",\n         s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20,"}, {"sha": "3e8e898b7bc61aa8311ae64e29059105747af577", "filename": "tests/ui/default_trait_access.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,8 +1,12 @@\n // run-rustfix\n+// aux-build: proc_macro_with_span.rs\n \n #![allow(unused_imports, dead_code)]\n #![deny(clippy::default_trait_access)]\n \n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n use std::default;\n use std::default::Default as D2;\n use std::string;\n@@ -51,6 +55,8 @@ fn main() {\n         ..Default::default()\n     };\n \n+    let _s21: String = with_span!(s Default::default());\n+\n     println!(\n         \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}]\",\n         s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20,"}, {"sha": "3493de37a55be55beb0d9d736bd2ea6a882581c2", "filename": "tests/ui/default_trait_access.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fdefault_trait_access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.stderr?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,53 +1,53 @@\n error: calling `std::string::String::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:11:22\n+  --> $DIR/default_trait_access.rs:15:22\n    |\n LL |     let s1: String = Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n    |\n note: the lint level is defined here\n-  --> $DIR/default_trait_access.rs:4:9\n+  --> $DIR/default_trait_access.rs:5:9\n    |\n LL | #![deny(clippy::default_trait_access)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: calling `std::string::String::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:15:22\n+  --> $DIR/default_trait_access.rs:19:22\n    |\n LL |     let s3: String = D2::default();\n    |                      ^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n error: calling `std::string::String::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:17:22\n+  --> $DIR/default_trait_access.rs:21:22\n    |\n LL |     let s4: String = std::default::Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n error: calling `std::string::String::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:21:22\n+  --> $DIR/default_trait_access.rs:25:22\n    |\n LL |     let s6: String = default::Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n error: calling `GenericDerivedDefault::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:31:46\n+  --> $DIR/default_trait_access.rs:35:46\n    |\n LL |     let s11: GenericDerivedDefault<String> = Default::default();\n    |                                              ^^^^^^^^^^^^^^^^^^ help: try: `GenericDerivedDefault::default()`\n \n error: calling `TupleDerivedDefault::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:37:36\n+  --> $DIR/default_trait_access.rs:41:36\n    |\n LL |     let s14: TupleDerivedDefault = Default::default();\n    |                                    ^^^^^^^^^^^^^^^^^^ help: try: `TupleDerivedDefault::default()`\n \n error: calling `ArrayDerivedDefault::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:39:36\n+  --> $DIR/default_trait_access.rs:43:36\n    |\n LL |     let s15: ArrayDerivedDefault = Default::default();\n    |                                    ^^^^^^^^^^^^^^^^^^ help: try: `ArrayDerivedDefault::default()`\n \n error: calling `TupleStructDerivedDefault::default()` is more clear than this expression\n-  --> $DIR/default_trait_access.rs:43:42\n+  --> $DIR/default_trait_access.rs:47:42\n    |\n LL |     let s17: TupleStructDerivedDefault = Default::default();\n    |                                          ^^^^^^^^^^^^^^^^^^ help: try: `TupleStructDerivedDefault::default()`"}, {"sha": "29cc026a8fd394e21b033bb1f45c9b8614252087", "filename": "tests/ui/missing_doc.rs", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,10 +1,15 @@\n+// aux-build: proc_macro_with_span.rs\n+\n #![warn(clippy::missing_docs_in_private_items)]\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n #![allow(dead_code)]\n //! Some garbage docs for the crate here\n #![doc = \"More garbage\"]\n \n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n use std::arch::global_asm;\n \n type Typedef = String;\n@@ -100,3 +105,11 @@ fn main() {}\n \n // Ensure global asm doesn't require documentation.\n global_asm! { \"\" }\n+\n+// Don't lint proc macro output with an unexpected span.\n+with_span!(span pub struct FooPm { pub field: u32});\n+with_span!(span pub struct FooPm2;);\n+with_span!(span pub enum FooPm3 { A, B(u32), C { field: u32 }});\n+with_span!(span pub fn foo_pm() {});\n+with_span!(span pub static FOO_PM: u32 = 0;);\n+with_span!(span pub const FOO2_PM: u32 = 0;);", "previous_filename": "tests/ui/missing-doc.rs"}, {"sha": "6c8e66f464377c9f1fd0f36415b1a35926f558f7", "filename": "tests/ui/missing_doc.stderr", "status": "renamed", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc.stderr?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,43 +1,43 @@\n error: missing documentation for a type alias\n-  --> $DIR/missing-doc.rs:10:1\n+  --> $DIR/missing_doc.rs:15:1\n    |\n LL | type Typedef = String;\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::missing-docs-in-private-items` implied by `-D warnings`\n \n error: missing documentation for a type alias\n-  --> $DIR/missing-doc.rs:11:1\n+  --> $DIR/missing_doc.rs:16:1\n    |\n LL | pub type PubTypedef = String;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing-doc.rs:13:1\n+  --> $DIR/missing_doc.rs:18:1\n    |\n LL | mod module_no_dox {}\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing-doc.rs:14:1\n+  --> $DIR/missing_doc.rs:19:1\n    |\n LL | pub mod pub_module_no_dox {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:18:1\n+  --> $DIR/missing_doc.rs:23:1\n    |\n LL | pub fn foo2() {}\n    | ^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:19:1\n+  --> $DIR/missing_doc.rs:24:1\n    |\n LL | fn foo3() {}\n    | ^^^^^^^^^^^^\n \n error: missing documentation for an enum\n-  --> $DIR/missing-doc.rs:33:1\n+  --> $DIR/missing_doc.rs:38:1\n    |\n LL | / enum Baz {\n LL | |     BazA { a: isize, b: isize },\n@@ -46,75 +46,75 @@ LL | | }\n    | |_^\n \n error: missing documentation for a variant\n-  --> $DIR/missing-doc.rs:34:5\n+  --> $DIR/missing_doc.rs:39:5\n    |\n LL |     BazA { a: isize, b: isize },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc.rs:34:12\n+  --> $DIR/missing_doc.rs:39:12\n    |\n LL |     BazA { a: isize, b: isize },\n    |            ^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc.rs:34:22\n+  --> $DIR/missing_doc.rs:39:22\n    |\n LL |     BazA { a: isize, b: isize },\n    |                      ^^^^^^^^\n \n error: missing documentation for a variant\n-  --> $DIR/missing-doc.rs:35:5\n+  --> $DIR/missing_doc.rs:40:5\n    |\n LL |     BarB,\n    |     ^^^^\n \n error: missing documentation for an enum\n-  --> $DIR/missing-doc.rs:38:1\n+  --> $DIR/missing_doc.rs:43:1\n    |\n LL | / pub enum PubBaz {\n LL | |     PubBazA { a: isize },\n LL | | }\n    | |_^\n \n error: missing documentation for a variant\n-  --> $DIR/missing-doc.rs:39:5\n+  --> $DIR/missing_doc.rs:44:5\n    |\n LL |     PubBazA { a: isize },\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc.rs:39:15\n+  --> $DIR/missing_doc.rs:44:15\n    |\n LL |     PubBazA { a: isize },\n    |               ^^^^^^^^\n \n error: missing documentation for a constant\n-  --> $DIR/missing-doc.rs:59:1\n+  --> $DIR/missing_doc.rs:64:1\n    |\n LL | const FOO: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a constant\n-  --> $DIR/missing-doc.rs:66:1\n+  --> $DIR/missing_doc.rs:71:1\n    |\n LL | pub const FOO4: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n-  --> $DIR/missing-doc.rs:68:1\n+  --> $DIR/missing_doc.rs:73:1\n    |\n LL | static BAR: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n-  --> $DIR/missing-doc.rs:75:1\n+  --> $DIR/missing_doc.rs:80:1\n    |\n LL | pub static BAR4: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing-doc.rs:77:1\n+  --> $DIR/missing_doc.rs:82:1\n    |\n LL | / mod internal_impl {\n LL | |     /// dox\n@@ -126,31 +126,31 @@ LL | | }\n    | |_^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:80:5\n+  --> $DIR/missing_doc.rs:85:5\n    |\n LL |     pub fn undocumented1() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:81:5\n+  --> $DIR/missing_doc.rs:86:5\n    |\n LL |     pub fn undocumented2() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:82:5\n+  --> $DIR/missing_doc.rs:87:5\n    |\n LL |     fn undocumented3() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:87:9\n+  --> $DIR/missing_doc.rs:92:9\n    |\n LL |         pub fn also_undocumented1() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing-doc.rs:88:9\n+  --> $DIR/missing_doc.rs:93:9\n    |\n LL |         fn also_undocumented2() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/missing-doc.stderr"}, {"sha": "e00c7fbfed15745932a1929049ef96f943ae5fd2", "filename": "tests/ui/missing_doc_crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc_crate.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "previous_filename": "tests/ui/missing-doc-crate.rs"}, {"sha": "51fd57df8df1da962322d50dc6edcf85726e9661", "filename": "tests/ui/missing_doc_crate_missing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate_missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate_missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc_crate_missing.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "previous_filename": "tests/ui/missing-doc-crate-missing.rs"}, {"sha": "19516bf5fab0e176caf6c1dd4d42bd6519d9a7f9", "filename": "tests/ui/missing_doc_crate_missing.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate_missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_crate_missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc_crate_missing.stderr?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,5 +1,5 @@\n error: missing documentation for the crate\n-  --> $DIR/missing-doc-crate-missing.rs:1:1\n+  --> $DIR/missing_doc_crate_missing.rs:1:1\n    |\n LL | / #![warn(clippy::missing_docs_in_private_items)]\n LL | |", "previous_filename": "tests/ui/missing-doc-crate-missing.stderr"}, {"sha": "0396d1193ff5c2b1e3d330e9d8d5b2b1c5cedc7b", "filename": "tests/ui/missing_doc_impl.rs", "status": "renamed", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc_impl.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,10 +1,15 @@\n+// aux-build: proc_macro_with_span.rs\n+\n #![warn(clippy::missing_docs_in_private_items)]\n #![allow(dead_code)]\n #![feature(associated_type_defaults)]\n \n //! Some garbage docs for the crate here\n #![doc = \"More garbage\"]\n \n+extern crate proc_macro_with_span;\n+use proc_macro_with_span::with_span;\n+\n struct Foo {\n     a: isize,\n     b: isize,\n@@ -90,3 +95,13 @@ impl F for Foo {\n }\n \n fn main() {}\n+\n+// don't lint proc macro output\n+with_span!(span\n+    pub struct FooPm;\n+    impl FooPm {\n+        pub fn foo() {}\n+        pub const fn bar() {}\n+        pub const X: u32 = 0;\n+    }\n+);", "previous_filename": "tests/ui/missing-doc-impl.rs"}, {"sha": "f22fa19dbcabc912ed543f1c26228442e7229974", "filename": "tests/ui/missing_doc_impl.stderr", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Fmissing_doc_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc_impl.stderr?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,5 +1,5 @@\n error: missing documentation for a struct\n-  --> $DIR/missing-doc-impl.rs:8:1\n+  --> $DIR/missing_doc_impl.rs:13:1\n    |\n LL | / struct Foo {\n LL | |     a: isize,\n@@ -10,19 +10,19 @@ LL | | }\n    = note: `-D clippy::missing-docs-in-private-items` implied by `-D warnings`\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc-impl.rs:9:5\n+  --> $DIR/missing_doc_impl.rs:14:5\n    |\n LL |     a: isize,\n    |     ^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc-impl.rs:10:5\n+  --> $DIR/missing_doc_impl.rs:15:5\n    |\n LL |     b: isize,\n    |     ^^^^^^^^\n \n error: missing documentation for a struct\n-  --> $DIR/missing-doc-impl.rs:13:1\n+  --> $DIR/missing_doc_impl.rs:18:1\n    |\n LL | / pub struct PubFoo {\n LL | |     pub a: isize,\n@@ -31,19 +31,19 @@ LL | | }\n    | |_^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc-impl.rs:14:5\n+  --> $DIR/missing_doc_impl.rs:19:5\n    |\n LL |     pub a: isize,\n    |     ^^^^^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing-doc-impl.rs:15:5\n+  --> $DIR/missing_doc_impl.rs:20:5\n    |\n LL |     b: isize,\n    |     ^^^^^^^^\n \n error: missing documentation for a trait\n-  --> $DIR/missing-doc-impl.rs:38:1\n+  --> $DIR/missing_doc_impl.rs:43:1\n    |\n LL | / pub trait C {\n LL | |     fn foo(&self);\n@@ -52,51 +52,51 @@ LL | | }\n    | |_^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:39:5\n+  --> $DIR/missing_doc_impl.rs:44:5\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:40:5\n+  --> $DIR/missing_doc_impl.rs:45:5\n    |\n LL |     fn foo_with_impl(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated type\n-  --> $DIR/missing-doc-impl.rs:50:5\n+  --> $DIR/missing_doc_impl.rs:55:5\n    |\n LL |     type AssociatedType;\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated type\n-  --> $DIR/missing-doc-impl.rs:51:5\n+  --> $DIR/missing_doc_impl.rs:56:5\n    |\n LL |     type AssociatedTypeDef = Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:62:5\n+  --> $DIR/missing_doc_impl.rs:67:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Foo { a: 0, b: 0 }\n LL | |     }\n    | |_____^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:65:5\n+  --> $DIR/missing_doc_impl.rs:70:5\n    |\n LL |     fn bar() {}\n    |     ^^^^^^^^^^^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:69:5\n+  --> $DIR/missing_doc_impl.rs:74:5\n    |\n LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:73:5\n+  --> $DIR/missing_doc_impl.rs:78:5\n    |\n LL | /     fn foo2() -> u32 {\n LL | |         1", "previous_filename": "tests/ui/missing-doc-impl.stderr"}, {"sha": "7bf3adc07ac5645dcecf0abbc88a5743cf416103", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,3 +1,5 @@\n+// aux-build: proc_macro_with_span.rs\n+\n #![warn(clippy::unit_arg)]\n #![allow(\n     clippy::no_effect,\n@@ -8,9 +10,13 @@\n     clippy::or_fun_call,\n     clippy::needless_question_mark,\n     clippy::self_named_constructors,\n-    clippy::let_unit_value\n+    clippy::let_unit_value,\n+    clippy::never_loop\n )]\n \n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n use std::fmt::Debug;\n \n fn foo<T: Debug>(t: T) {\n@@ -127,6 +133,10 @@ fn returning_expr() -> Option<()> {\n \n fn taking_multiple_units(a: (), b: ()) {}\n \n+fn proc_macro() {\n+    with_span!(span taking_multiple_units(unsafe { (); }, 'x: loop { break 'x (); }));\n+}\n+\n fn main() {\n     bad();\n     ok();"}, {"sha": "1de9d44bb0d6ea80251502616e5843d835d8264a", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10853f71f2360ee21665c9b481e3be01f35ee902/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=10853f71f2360ee21665c9b481e3be01f35ee902", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:57:5\n+  --> $DIR/unit_arg.rs:63:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:60:5\n+  --> $DIR/unit_arg.rs:66:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:61:5\n+  --> $DIR/unit_arg.rs:67:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:66:5\n+  --> $DIR/unit_arg.rs:72:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL ~     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:69:5\n+  --> $DIR/unit_arg.rs:75:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:70:5\n+  --> $DIR/unit_arg.rs:76:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:74:5\n+  --> $DIR/unit_arg.rs:80:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -146,7 +146,7 @@ LL ~     );\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:85:13\n+  --> $DIR/unit_arg.rs:91:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -160,7 +160,7 @@ LL ~     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:88:5\n+  --> $DIR/unit_arg.rs:94:5\n    |\n LL |     foo(foo(()));\n    |     ^^^^^^^^^^^^\n@@ -172,7 +172,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:125:5\n+  --> $DIR/unit_arg.rs:131:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}]}