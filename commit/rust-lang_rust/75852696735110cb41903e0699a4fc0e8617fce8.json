{"sha": "75852696735110cb41903e0699a4fc0e8617fce8", "node_id": "C_kwDOAAsO6NoAKDc1ODUyNjk2NzM1MTEwY2I0MTkwM2UwNjk5YTRmYzBlODYxN2ZjZTg", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-04-01T18:54:12Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-04-07T13:47:20Z"}, "message": "add `generic_activity_with_arg_recorder` to the self-profiler\n\nThis allows profiling costly arguments to be recorded only when `-Zself-profile-events=args` is on: using a closure that takes an `EventArgRecorder` and call its `record_arg` or `record_args` methods.", "tree": {"sha": "045952f78227ea94d7fd39ffd01ff54fea6136dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/045952f78227ea94d7fd39ffd01ff54fea6136dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75852696735110cb41903e0699a4fc0e8617fce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75852696735110cb41903e0699a4fc0e8617fce8", "html_url": "https://github.com/rust-lang/rust/commit/75852696735110cb41903e0699a4fc0e8617fce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75852696735110cb41903e0699a4fc0e8617fce8/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4ae7aa4a3c9f4ffa23a81b83cebbb34f51e7d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4ae7aa4a3c9f4ffa23a81b83cebbb34f51e7d1", "html_url": "https://github.com/rust-lang/rust/commit/1c4ae7aa4a3c9f4ffa23a81b83cebbb34f51e7d1"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "3f7a90a8467b85b3ac91983e9e51a729d2f6b358", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/75852696735110cb41903e0699a4fc0e8617fce8/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75852696735110cb41903e0699a4fc0e8617fce8/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=75852696735110cb41903e0699a4fc0e8617fce8", "patch": "@@ -97,6 +97,7 @@ use std::time::{Duration, Instant};\n pub use measureme::EventId;\n use measureme::{EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n+use smallvec::SmallVec;\n \n bitflags::bitflags! {\n     struct EventFilter: u32 {\n@@ -288,6 +289,66 @@ impl SelfProfilerRef {\n         })\n     }\n \n+    /// Start profiling a generic activity, allowing costly arguments to be recorded. Profiling\n+    /// continues until the `TimingGuard` returned from this call is dropped.\n+    ///\n+    /// If the arguments to a generic activity are cheap to create, use `generic_activity_with_arg`\n+    /// or `generic_activity_with_args` for their simpler API. However, if they are costly or\n+    /// require allocation in sufficiently hot contexts, then this allows for a closure to be called\n+    /// only when arguments were asked to be recorded via `-Z self-profile-events=args`.\n+    ///\n+    /// In this case, the closure will be passed a `&mut EventArgRecorder`, to help with recording\n+    /// one or many arguments within the generic activity being profiled, by calling its\n+    /// `record_arg` method for example.\n+    ///\n+    /// This `EventArgRecorder` may implement more specific traits from other rustc crates, e.g. for\n+    /// richer handling of rustc-specific argument types, while keeping this single entry-point API\n+    /// for recording arguments.\n+    ///\n+    /// Note: recording at least one argument is *required* for the self-profiler to create the\n+    /// `TimingGuard`. A panic will be triggered if that doesn't happen. This function exists\n+    /// explicitly to record arguments, so it fails loudly when there are none to record.\n+    ///\n+    #[inline(always)]\n+    pub fn generic_activity_with_arg_recorder<F>(\n+        &self,\n+        event_label: &'static str,\n+        mut f: F,\n+    ) -> TimingGuard<'_>\n+    where\n+        F: FnMut(&mut EventArgRecorder<'_>),\n+    {\n+        // Ensure this event will only be recorded when self-profiling is turned on.\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let builder = EventIdBuilder::new(&profiler.profiler);\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+\n+            // Ensure the closure to create event arguments will only be called when argument\n+            // recording is turned on.\n+            let event_id = if profiler.event_filter_mask.contains(EventFilter::FUNCTION_ARGS) {\n+                // Set up the builder and call the user-provided closure to record potentially\n+                // costly event arguments.\n+                let mut recorder = EventArgRecorder { profiler, args: SmallVec::new() };\n+                f(&mut recorder);\n+\n+                // It is expected that the closure will record at least one argument. If that\n+                // doesn't happen, it's a bug: we've been explicitly called in order to record\n+                // arguments, so we fail loudly when there are none to record.\n+                if recorder.args.is_empty() {\n+                    panic!(\n+                        \"The closure passed to `generic_activity_with_arg_recorder` needs to \\\n+                         record at least one argument\"\n+                    );\n+                }\n+\n+                builder.from_label_and_args(event_label, &recorder.args)\n+            } else {\n+                builder.from_label(event_label)\n+            };\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n+    }\n+\n     /// Record the size of an artifact that the compiler produces\n     ///\n     /// `artifact_kind` is the class of artifact (e.g., query_cache, object_file, etc.)\n@@ -443,6 +504,33 @@ impl SelfProfilerRef {\n     }\n }\n \n+/// A helper for recording costly arguments to self-profiling events. Used with\n+/// `SelfProfilerRef::generic_activity_with_arg_recorder`.\n+pub struct EventArgRecorder<'p> {\n+    /// The `SelfProfiler` used to intern the event arguments that users will ask to record.\n+    profiler: &'p SelfProfiler,\n+\n+    /// The interned event arguments to be recorded in the generic activity event.\n+    ///\n+    /// The most common case, when actually recording event arguments, is to have one argument. Then\n+    /// followed by recording two, in a couple places.\n+    args: SmallVec<[StringId; 2]>,\n+}\n+\n+impl EventArgRecorder<'_> {\n+    /// Records a single argument within the current generic activity being profiled.\n+    ///\n+    /// Note: when self-profiling with costly event arguments, at least one argument\n+    /// needs to be recorded. A panic will be triggered if that doesn't happen.\n+    pub fn record_arg<A>(&mut self, event_arg: A)\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n+        let event_arg = self.profiler.get_or_alloc_cached_string(event_arg);\n+        self.args.push(event_arg);\n+    }\n+}\n+\n pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,"}]}