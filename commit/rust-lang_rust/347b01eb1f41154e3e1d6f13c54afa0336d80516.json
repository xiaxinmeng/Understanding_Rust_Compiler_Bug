{"sha": "347b01eb1f41154e3e1d6f13c54afa0336d80516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0N2IwMWViMWY0MTE1NGUzZTFkNmYxM2M1NGFmYTAzMzZkODA1MTY=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-04-26T00:48:02Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-02-10T10:57:27Z"}, "message": "rework use_self impl based on ty::Ty comparison", "tree": {"sha": "ea0de2c866dfd7b4c5e5995329b099550e16e6a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0de2c866dfd7b4c5e5995329b099550e16e6a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/347b01eb1f41154e3e1d6f13c54afa0336d80516", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmAjvBcACgkQHKDfKvWd\naKWL3A/8DVrjT3D6BJ35WiP1yOTjTzQu2hw03SBO0jIblJlNgHH/UvteSo+1pKqK\nmDOVWFpJyHNqJ/dZiJGikulGgBxmgvDwrqe+NNvN+KuPRZWUoVXLJ5mi+thVINWd\nECUk60L+T9+WlpQtTp9uBFpC0dRt8/Sjg2c+fQCj1pJdQ0PbhicvL3aAfVIe/Lxg\np7YgRASpp2hPaZOyg3O5rhNWqlc/wb3Q5Nr8fGj5r0yoEfDOnbDo+mcgVdeS4XHg\nQu0ln+GFxfwv00t95+M0rWC00gGeuXjXAjKRJhZJAfHEOduqtsDiux2nnBuxBMBG\nTL0ZXk7tM/ALVBj7Qu24XsP/lxOYuBoZ7FgZPtsTzhfQBfdxWGW3b9OhQykVdkQO\nUxsLCieKxRglUeEAjEmehE0XoKvplHkX2SwedY/ucAczzEyh0kiCXlCR04dZL2NW\nY4Yp5iPS8/JGYNOT6II94dAESHlX9280+GtTUzM8bHkd5j3zCQ5kepqmqmxkpl3X\nh07+MYvv8ixevmZcH6TxEHqGAsQ07rBe0BzKwicc5oiMZ1Q+Na68Ch0Ll3PiiZCE\ntHANuq5dNug8SZhVmeqCnfp0xsKNqYfMLsadbP5EJjlwNBLdLgbgPzYITb0E89gn\nSJK20J+2n6DsGtTjuZZjsUzRV4SCpMvD3B8oZ/6g9PoeB7rT8L4=\n=aITL\n-----END PGP SIGNATURE-----", "payload": "tree ea0de2c866dfd7b4c5e5995329b099550e16e6a1\nparent 0e371b8923f1760680c1edbb96e1bc9170803ffc\nauthor Tim Nielens <tim.nielens@gmail.com> 1587862082 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1612954647 +0100\n\nrework use_self impl based on ty::Ty comparison\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/347b01eb1f41154e3e1d6f13c54afa0336d80516", "html_url": "https://github.com/rust-lang/rust/commit/347b01eb1f41154e3e1d6f13c54afa0336d80516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/347b01eb1f41154e3e1d6f13c54afa0336d80516/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e371b8923f1760680c1edbb96e1bc9170803ffc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e371b8923f1760680c1edbb96e1bc9170803ffc", "html_url": "https://github.com/rust-lang/rust/commit/0e371b8923f1760680c1edbb96e1bc9170803ffc"}], "stats": {"total": 884, "additions": 668, "deletions": 216}, "files": [{"sha": "1b5070d1cffbfd0040c786baa2f8ac3cafe66026", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 194, "deletions": 126, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -1,24 +1,24 @@\n+use crate::utils;\n+use crate::utils::snippet_opt;\n+use crate::utils::span_lint_and_sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::intravisit::{walk_expr, walk_impl_item, walk_ty, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    def, FnDecl, FnRetTy, FnSig, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Path, PathSegment, QPath,\n-    TyKind,\n+    def, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, ImplItem, ImplItemKind, ItemKind, Node, Path, PathSegment,\n+    QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n-use rustc_middle::ty::{DefIdTree, Ty};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::kw;\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{differing_macro_contexts, meets_msrv, span_lint_and_sugg};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n     /// replacement with `Self` is applicable.\n@@ -28,8 +28,7 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// - False positive when using associated types ([#2843](https://github.com/rust-lang/rust-clippy/issues/2843))\n-    /// - False positives in some situations when using generics ([#3410](https://github.com/rust-lang/rust-clippy/issues/3410))\n+    /// Unaddressed false negatives related to unresolved internal compiler errors.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -54,23 +53,11 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-impl_lint_pass!(UseSelf => [USE_SELF]);\n+declare_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-fn span_use_self_lint(cx: &LateContext<'_>, path: &Path<'_>, last_segment: Option<&PathSegment<'_>>) {\n-    let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n-\n-    // Path segments only include actual path, no methods or fields.\n-    let last_path_span = last_segment.ident.span;\n-\n-    if differing_macro_contexts(path.span, last_path_span) {\n-        return;\n-    }\n-\n-    // Only take path up to the end of last_path_span.\n-    let span = path.span.with_hi(last_path_span.hi());\n-\n+fn span_lint<'tcx>(cx: &LateContext<'tcx>, span: Span) {\n     span_lint_and_sugg(\n         cx,\n         USE_SELF,\n@@ -82,107 +69,196 @@ fn span_use_self_lint(cx: &LateContext<'_>, path: &Path<'_>, last_segment: Optio\n     );\n }\n \n-// FIXME: always use this (more correct) visitor, not just in method signatures.\n-struct SemanticUseSelfVisitor<'a, 'tcx> {\n+#[allow(clippy::cast_possible_truncation)]\n+fn span_lint_until_last_segment<'tcx>(cx: &LateContext<'tcx>, span: Span, segment: &'tcx PathSegment<'tcx>) {\n+    let sp = span.with_hi(segment.ident.span.lo());\n+    // remove the trailing ::\n+    let span_without_last_segment = match snippet_opt(cx, sp) {\n+        Some(snippet) => match snippet.rfind(\"::\") {\n+            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n+            None => sp,\n+        },\n+        None => sp,\n+    };\n+    span_lint(cx, span_without_last_segment);\n+}\n+\n+fn span_lint_on_path_until_last_segment<'tcx>(cx: &LateContext<'tcx>, path: &'tcx Path<'tcx>) {\n+    if path.segments.len() > 1 {\n+        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n+    }\n+}\n+\n+fn span_lint_on_qpath_resolved<'tcx>(cx: &LateContext<'tcx>, qpath: &'tcx QPath<'tcx>, until_last_segment: bool) {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if until_last_segment {\n+            span_lint_on_path_until_last_segment(cx, path);\n+        } else {\n+            span_lint(cx, path.span);\n+        }\n+    }\n+}\n+\n+struct ImplVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     self_ty: Ty<'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for SemanticUseSelfVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ImplVisitor<'a, 'tcx> {\n+    fn check_trait_method_impl_decl(\n+        &mut self,\n+        impl_item: &ImplItem<'tcx>,\n+        impl_decl: &'tcx FnDecl<'tcx>,\n+        impl_trait_ref: ty::TraitRef<'tcx>,\n+    ) {\n+        let tcx = self.cx.tcx;\n+        let trait_method = tcx\n+            .associated_items(impl_trait_ref.def_id)\n+            .find_by_name_and_kind(tcx, impl_item.ident, ty::AssocKind::Fn, impl_trait_ref.def_id)\n+            .expect(\"impl method matches a trait method\");\n+\n+        let trait_method_sig = tcx.fn_sig(trait_method.def_id);\n+        let trait_method_sig = tcx.erase_late_bound_regions(&trait_method_sig);\n+\n+        let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n+            Some(&**ty)\n+        } else {\n+            None\n+        };\n+\n+        // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n+        // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n+        // We use `impl_hir_ty` to see if the type was written as `Self`,\n+        // `hir_ty_to_ty(...)` to check semantic types of paths, and\n+        // `trait_ty` to determine which parts of the signature in the trait, mention\n+        // the type being implemented verbatim (as opposed to `Self`).\n+        for (impl_hir_ty, trait_ty) in impl_decl\n+            .inputs\n+            .iter()\n+            .chain(output_hir_ty)\n+            .zip(trait_method_sig.inputs_and_output)\n+        {\n+            // Check if the input/output type in the trait method specifies the implemented\n+            // type verbatim, and only suggest `Self` if that isn't the case.\n+            // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n+            // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n+            // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n+            let self_ty = impl_trait_ref.self_ty();\n+            if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n+                self.visit_ty(&impl_hir_ty);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ImplVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = &hir_ty.kind {\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind {\n             match path.res {\n                 def::Res::SelfTy(..) => {},\n                 _ => {\n-                    if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n-                        span_use_self_lint(self.cx, path, None);\n+                    match self.cx.tcx.hir().find(self.cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n+                        Some(Node::Expr(Expr {\n+                            kind: ExprKind::Path(QPath::TypeRelative(_, _segment)),\n+                            ..\n+                        })) => {\n+                            // The following block correctly identifies applicable lint locations\n+                            // but `hir_ty_to_ty` calls cause odd ICEs.\n+                            //\n+                            // if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n+                            //     // FIXME: this span manipulation should not be necessary\n+                            //     // @flip1995 found an ast lowering issue in\n+                            //     // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#L142-L162\n+                            //     span_lint_until_last_segment(self.cx, hir_ty.span, segment);\n+                            // }\n+                        },\n+                        _ => {\n+                            if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n+                                span_lint(self.cx, hir_ty.span)\n+                            }\n+                        },\n                     }\n                 },\n             }\n         }\n \n-        walk_ty(self, hir_ty)\n+        walk_ty(self, hir_ty);\n     }\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-fn check_trait_method_impl_decl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    impl_item: &ImplItem<'_>,\n-    impl_decl: &'tcx FnDecl<'_>,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-) {\n-    let trait_method = cx\n-        .tcx\n-        .associated_items(impl_trait_ref.def_id)\n-        .find_by_name_and_kind(cx.tcx, impl_item.ident, ty::AssocKind::Fn, impl_trait_ref.def_id)\n-        .expect(\"impl method matches a trait method\");\n-\n-    let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n-    let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n-\n-    let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n-        Some(&**ty)\n-    } else {\n-        None\n-    };\n-\n-    // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n-    // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n-    // We use `impl_hir_ty` to see if the type was written as `Self`,\n-    // `hir_ty_to_ty(...)` to check semantic types of paths, and\n-    // `trait_ty` to determine which parts of the signature in the trait, mention\n-    // the type being implemented verbatim (as opposed to `Self`).\n-    for (impl_hir_ty, trait_ty) in impl_decl\n-        .inputs\n-        .iter()\n-        .chain(output_hir_ty)\n-        .zip(trait_method_sig.inputs_and_output)\n-    {\n-        // Check if the input/output type in the trait method specifies the implemented\n-        // type verbatim, and only suggest `Self` if that isn't the case.\n-        // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n-        // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n-        // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n-        let self_ty = impl_trait_ref.self_ty();\n-        if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n-            let mut visitor = SemanticUseSelfVisitor { cx, self_ty };\n-\n-            visitor.visit_ty(&impl_hir_ty);\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        fn expr_ty_matches<'tcx>(expr: &'tcx Expr<'tcx>, self_ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+            let def_id = expr.hir_id.owner;\n+            if cx.tcx.has_typeck_results(def_id) {\n+                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n+            } else {\n+                false\n+            }\n         }\n-    }\n-}\n-\n-const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n-\n-pub struct UseSelf {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl UseSelf {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n+                if expr_ty_matches(expr, self.self_ty, self.cx) {\n+                    match path.res {\n+                        def::Res::SelfTy(..) => (),\n+                        def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(self.cx, path),\n+                        _ => {\n+                            span_lint(self.cx, path.span);\n+                        },\n+                    }\n+                }\n+            },\n+            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Call(fun, _) => {\n+                if let Expr {\n+                    kind: ExprKind::Path(ref qpath),\n+                    ..\n+                } = fun\n+                {\n+                    if expr_ty_matches(expr, self.self_ty, self.cx) {\n+                        let res = utils::qpath_res(self.cx, qpath, fun.hir_id);\n+\n+                        if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n+                            match ctor_of {\n+                                def::CtorOf::Variant => {\n+                                    span_lint_on_qpath_resolved(self.cx, qpath, true);\n+                                },\n+                                def::CtorOf::Struct => {\n+                                    span_lint_on_qpath_resolved(self.cx, qpath, false);\n+                                },\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            // unit enum variants (`Enum::A`)\n+            ExprKind::Path(ref qpath) => {\n+                if expr_ty_matches(expr, self.self_ty, self.cx) {\n+                    span_lint_on_qpath_resolved(self.cx, qpath, true);\n+                }\n+            },\n+            _ => (),\n+        }\n+        walk_expr(self, expr);\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for UseSelf {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+        if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n         }\n \n-        if in_external_macro(cx.sess(), item.span) {\n-            return;\n-        }\n+        let parent_id = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n+        let imp = cx.tcx.hir().expect_item(parent_id);\n+\n         if_chain! {\n-            if let ItemKind::Impl(impl_) = &item.kind;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = impl_.self_ty.kind;\n+            if let ItemKind::Impl { self_ty: hir_self_ty, .. } = imp.kind;\n+            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = parameters.as_ref().map_or(\n@@ -191,31 +267,23 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                         &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n                 );\n \n+                // TODO: don't short-circuit upon lifetime parameters\n                 if should_check {\n-                    let visitor = &mut UseSelfVisitor {\n-                        item_path,\n-                        cx,\n-                    };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n-\n-                    if let Some(impl_trait_ref) = impl_trait_ref {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            if let ImplItemKind::Fn(FnSig{ decl: impl_decl, .. }, impl_body_id)\n-                                    = &impl_item.kind {\n-                                check_trait_method_impl_decl(cx, impl_item, impl_decl, impl_trait_ref);\n-\n-                                let body = cx.tcx.hir().body(*impl_body_id);\n-                                visitor.visit_body(body);\n-                            } else {\n-                                visitor.visit_impl_item(impl_item);\n-                            }\n-                        }\n-                    } else {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            visitor.visit_impl_item(impl_item);\n+                    let self_ty = hir_ty_to_ty(cx.tcx, hir_self_ty);\n+                    let visitor = &mut ImplVisitor { cx, self_ty };\n+\n+                    let tcx = cx.tcx;\n+                    let impl_def_id = tcx.hir().local_def_id(imp.hir_id);\n+                    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                    if_chain! {\n+                        if let Some(impl_trait_ref) = impl_trait_ref;\n+                        if let ImplItemKind::Fn(FnSig { decl: impl_decl, .. }, impl_body_id) = &impl_item.kind;\n+                        then {\n+                            visitor.check_trait_method_impl_decl(impl_item, impl_decl, impl_trait_ref);\n+                            let body = tcx.hir().body(*impl_body_id);\n+                            visitor.visit_body(body);\n+                        } else {\n+                            walk_impl_item(visitor, impl_item)\n                         }\n                     }\n                 }"}, {"sha": "916484eef931f7e12aab8206f1ef113f844ac65a", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 220, "deletions": 10, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -15,13 +15,14 @@ mod use_self {\n             Self {}\n         }\n         fn test() -> Self {\n-            Self::new()\n+            Foo::new()\n         }\n     }\n \n     impl Default for Foo {\n         fn default() -> Self {\n-            Self::new()\n+            // FIXME: applicable here\n+            Foo::new()\n         }\n     }\n }\n@@ -87,7 +88,11 @@ mod existential {\n     struct Foo;\n \n     impl Foo {\n-        fn bad(foos: &[Self]) -> impl Iterator<Item = &Self> {\n+        // FIXME:\n+        // TyKind::Def (used for `impl Trait` types) does not include type parameters yet.\n+        // See documentation in rustc_hir::hir::TyKind.\n+        // The hir tree walk stops at `impl Iterator` level and does not inspect &Foo.\n+        fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n             foos.iter()\n         }\n \n@@ -177,11 +182,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -197,8 +213,8 @@ mod rustfix {\n         fn fun_1() {}\n \n         fn fun_2() {\n-            Self::fun_1();\n-            Self::A;\n+            nested::A::fun_1();\n+            nested::A::A;\n \n             Self {};\n         }\n@@ -219,7 +235,8 @@ mod issue3567 {\n \n     impl Test for TestStruct {\n         fn test() -> TestStruct {\n-            Self::from_something()\n+            // FIXME: applicable here\n+            TestStruct::from_something()\n         }\n     }\n }\n@@ -233,12 +250,14 @@ mod paths_created_by_lowering {\n         const A: usize = 0;\n         const B: usize = 1;\n \n-        async fn g() -> Self {\n+        // FIXME: applicable here\n+        async fn g() -> S {\n             Self {}\n         }\n \n         fn f<'a>(&self, p: &'a [u8]) -> &'a [u8] {\n-            &p[Self::A..Self::B]\n+            // FIXME: applicable here twice\n+            &p[S::A..S::B]\n         }\n     }\n \n@@ -252,3 +271,194 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Self {\n+            Self { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = Self;\n+        type To = Self;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            // FIXME: applicable here\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            // FIXME: applicable here\n+            A::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "347f5e96555629c33bc16dd3c8dd661f66d495ec", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 213, "deletions": 3, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -21,6 +21,7 @@ mod use_self {\n \n     impl Default for Foo {\n         fn default() -> Foo {\n+            // FIXME: applicable here\n             Foo::new()\n         }\n     }\n@@ -87,7 +88,11 @@ mod existential {\n     struct Foo;\n \n     impl Foo {\n-        fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n+        // FIXME:\n+        // TyKind::Def (used for `impl Trait` types) does not include type parameters yet.\n+        // See documentation in rustc_hir::hir::TyKind.\n+        // The hir tree walk stops at `impl Iterator` level and does not inspect &Foo.\n+        fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n             foos.iter()\n         }\n \n@@ -177,11 +182,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -219,6 +235,7 @@ mod issue3567 {\n \n     impl Test for TestStruct {\n         fn test() -> TestStruct {\n+            // FIXME: applicable here\n             TestStruct::from_something()\n         }\n     }\n@@ -233,11 +250,13 @@ mod paths_created_by_lowering {\n         const A: usize = 0;\n         const B: usize = 1;\n \n+        // FIXME: applicable here\n         async fn g() -> S {\n             S {}\n         }\n \n         fn f<'a>(&self, p: &'a [u8]) -> &'a [u8] {\n+            // FIXME: applicable here twice\n             &p[S::A..S::B]\n         }\n     }\n@@ -252,3 +271,194 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Foo<T> {\n+            Foo { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = T::From;\n+        type To = T::To;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            // FIXME: applicable here\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            // FIXME: applicable here\n+            A::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "a88dd04f13d3ffbbf3e5a7569a36e118e7cb4337", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 38, "deletions": 62, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -18,38 +18,26 @@ error: unnecessary structure name repetition\n LL |         fn test() -> Foo {\n    |                      ^^^ help: use the applicable keyword: `Self`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:18:13\n-   |\n-LL |             Foo::new()\n-   |             ^^^ help: use the applicable keyword: `Self`\n-\n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:23:25\n    |\n LL |         fn default() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:24:13\n-   |\n-LL |             Foo::new()\n-   |             ^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:90:56\n+  --> $DIR/use_self.rs:94:24\n    |\n-LL |         fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n-   |                                                        ^^^ help: use the applicable keyword: `Self`\n+LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n+   |                        ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:105:13\n+  --> $DIR/use_self.rs:109:13\n    |\n LL |             TS(0)\n    |             ^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:113:25\n+  --> $DIR/use_self.rs:117:25\n    |\n LL |             fn new() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n@@ -60,7 +48,7 @@ LL |         use_self_expand!(); // Should lint in local macros\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:114:17\n+  --> $DIR/use_self.rs:118:17\n    |\n LL |                 Foo {}\n    |                 ^^^ help: use the applicable keyword: `Self`\n@@ -71,94 +59,82 @@ LL |         use_self_expand!(); // Should lint in local macros\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:149:21\n+  --> $DIR/use_self.rs:141:29\n    |\n-LL |         fn baz() -> Foo {\n-   |                     ^^^ help: use the applicable keyword: `Self`\n+LL |                 fn bar() -> Bar {\n+   |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:150:13\n+  --> $DIR/use_self.rs:142:21\n    |\n-LL |             Foo {}\n-   |             ^^^ help: use the applicable keyword: `Self`\n+LL |                     Bar { foo: Foo {} }\n+   |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:137:29\n+  --> $DIR/use_self.rs:153:21\n    |\n-LL |                 fn bar() -> Bar {\n-   |                             ^^^ help: use the applicable keyword: `Self`\n+LL |         fn baz() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:138:21\n+  --> $DIR/use_self.rs:154:13\n    |\n-LL |                     Bar { foo: Foo {} }\n-   |                     ^^^ help: use the applicable keyword: `Self`\n+LL |             Foo {}\n+   |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:167:21\n+  --> $DIR/use_self.rs:171:21\n    |\n LL |             let _ = Enum::B(42);\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:168:21\n+  --> $DIR/use_self.rs:172:21\n    |\n LL |             let _ = Enum::C { field: true };\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:169:21\n+  --> $DIR/use_self.rs:173:21\n    |\n LL |             let _ = Enum::A;\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:200:13\n-   |\n-LL |             nested::A::fun_1();\n-   |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:201:13\n-   |\n-LL |             nested::A::A;\n-   |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:203:13\n+  --> $DIR/use_self.rs:218:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:222:13\n+  --> $DIR/use_self.rs:254:13\n    |\n-LL |             TestStruct::from_something()\n-   |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n+LL |             S {}\n+   |             ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:236:25\n+  --> $DIR/use_self.rs:282:29\n    |\n-LL |         async fn g() -> S {\n-   |                         ^ help: use the applicable keyword: `Self`\n+LL |         fn foo(value: T) -> Foo<T> {\n+   |                             ^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:237:13\n+  --> $DIR/use_self.rs:283:13\n    |\n-LL |             S {}\n-   |             ^ help: use the applicable keyword: `Self`\n+LL |             Foo { value }\n+   |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:16\n+  --> $DIR/use_self.rs:320:21\n    |\n-LL |             &p[S::A..S::B]\n-   |                ^ help: use the applicable keyword: `Self`\n+LL |         type From = T::From;\n+   |                     ^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:22\n+  --> $DIR/use_self.rs:321:19\n    |\n-LL |             &p[S::A..S::B]\n-   |                      ^ help: use the applicable keyword: `Self`\n+LL |         type To = T::To;\n+   |                   ^^^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "d425f953a9c3c6c26761c01f31e51d433b63a4fd", "filename": "tests/ui/use_self_trait.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self_trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self_trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self_trait.fixed?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -33,7 +33,7 @@ impl SelfTrait for Bad {\n     fn nested(_p1: Box<Self>, _p2: (&u8, &Self)) {}\n \n     fn vals(_: Self) -> Self {\n-        Self::default()\n+        Bad::default()\n     }\n }\n \n@@ -47,7 +47,7 @@ impl Mul for Bad {\n \n impl Clone for Bad {\n     fn clone(&self) -> Self {\n-        Self\n+        Bad\n     }\n }\n "}, {"sha": "fa528cc5b7dd091c10880dcc89dc7b440cb07cdb", "filename": "tests/ui/use_self_trait.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/347b01eb1f41154e3e1d6f13c54afa0336d80516/tests%2Fui%2Fuse_self_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self_trait.stderr?ref=347b01eb1f41154e3e1d6f13c54afa0336d80516", "patch": "@@ -60,12 +60,6 @@ error: unnecessary structure name repetition\n LL |     fn vals(_: Bad) -> Bad {\n    |                        ^^^ help: use the applicable keyword: `Self`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/use_self_trait.rs:36:9\n-   |\n-LL |         Bad::default()\n-   |         ^^^ help: use the applicable keyword: `Self`\n-\n error: unnecessary structure name repetition\n   --> $DIR/use_self_trait.rs:41:19\n    |\n@@ -84,11 +78,5 @@ error: unnecessary structure name repetition\n LL |     fn mul(self, rhs: Bad) -> Bad {\n    |                               ^^^ help: use the applicable keyword: `Self`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/use_self_trait.rs:50:9\n-   |\n-LL |         Bad\n-   |         ^^^ help: use the applicable keyword: `Self`\n-\n-error: aborting due to 15 previous errors\n+error: aborting due to 13 previous errors\n "}]}