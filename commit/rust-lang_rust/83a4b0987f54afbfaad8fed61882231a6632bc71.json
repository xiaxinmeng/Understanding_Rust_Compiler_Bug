{"sha": "83a4b0987f54afbfaad8fed61882231a6632bc71", "node_id": "C_kwDOAAsO6NoAKDgzYTRiMDk4N2Y1NGFmYmZhYWQ4ZmVkNjE4ODIyMzFhNjYzMmJjNzE", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-05-18T05:56:04Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-05-18T05:56:04Z"}, "message": "Fix formatting of if let chain", "tree": {"sha": "8faf0ce59e89277d0b87f546e40809f019610f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8faf0ce59e89277d0b87f546e40809f019610f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83a4b0987f54afbfaad8fed61882231a6632bc71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83a4b0987f54afbfaad8fed61882231a6632bc71", "html_url": "https://github.com/rust-lang/rust/commit/83a4b0987f54afbfaad8fed61882231a6632bc71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83a4b0987f54afbfaad8fed61882231a6632bc71/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf182b9f4327194e9636a2ec8ddb1d246815a162", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf182b9f4327194e9636a2ec8ddb1d246815a162", "html_url": "https://github.com/rust-lang/rust/commit/cf182b9f4327194e9636a2ec8ddb1d246815a162"}], "stats": {"total": 93, "additions": 47, "deletions": 46}, "files": [{"sha": "855bbf4c668b89f8afcf86eb45920e295367daf8", "filename": "clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/83a4b0987f54afbfaad8fed61882231a6632bc71/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a4b0987f54afbfaad8fed61882231a6632bc71/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=83a4b0987f54afbfaad8fed61882231a6632bc71", "patch": "@@ -77,53 +77,54 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n             local.els.is_none() &&\n             local.ty.is_none() &&\n             init.span.ctxt() == stmt.span.ctxt() &&\n-            let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init) {\n-        match if_let_or_match {\n-            IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n-                if expr_is_simple_identity(let_pat, if_then);\n-                if let Some(if_else) = if_else;\n-                if expr_diverges(cx, if_else);\n-                then {\n-                    emit_manual_let_else(cx, stmt.span, if_let_expr, local.pat, let_pat, if_else);\n-                }\n-            },\n-            IfLetOrMatch::Match(match_expr, arms, source) => {\n-                if self.matches_behaviour == MatchLintBehaviour::Never {\n-                    return;\n-                }\n-                if source != MatchSource::Normal {\n-                    return;\n-                }\n-                // Any other number than two arms doesn't (necessarily)\n-                // have a trivial mapping to let else.\n-                if arms.len() != 2 {\n-                    return;\n-                }\n-                // Guards don't give us an easy mapping either\n-                if arms.iter().any(|arm| arm.guard.is_some()) {\n-                    return;\n-                }\n-                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n-                let diverging_arm_opt = arms\n-                    .iter()\n-                    .enumerate()\n-                    .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n-                let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n-                // If the non-diverging arm is the first one, its pattern can be reused in a let/else statement.\n-                // However, if it arrives in second position, its pattern may cover some cases already covered\n-                // by the diverging one.\n-                // TODO: accept the non-diverging arm as a second position if patterns are disjointed.\n-                if idx == 0 {\n-                    return;\n-                }\n-                let pat_arm = &arms[1 - idx];\n-                if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n-                    return;\n-                }\n+            let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init)\n+        {\n+            match if_let_or_match {\n+                IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n+                    if expr_is_simple_identity(let_pat, if_then);\n+                    if let Some(if_else) = if_else;\n+                    if expr_diverges(cx, if_else);\n+                    then {\n+                        emit_manual_let_else(cx, stmt.span, if_let_expr, local.pat, let_pat, if_else);\n+                    }\n+                },\n+                IfLetOrMatch::Match(match_expr, arms, source) => {\n+                    if self.matches_behaviour == MatchLintBehaviour::Never {\n+                        return;\n+                    }\n+                    if source != MatchSource::Normal {\n+                        return;\n+                    }\n+                    // Any other number than two arms doesn't (necessarily)\n+                    // have a trivial mapping to let else.\n+                    if arms.len() != 2 {\n+                        return;\n+                    }\n+                    // Guards don't give us an easy mapping either\n+                    if arms.iter().any(|arm| arm.guard.is_some()) {\n+                        return;\n+                    }\n+                    let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n+                    let diverging_arm_opt = arms\n+                        .iter()\n+                        .enumerate()\n+                        .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n+                    let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n+                    // If the non-diverging arm is the first one, its pattern can be reused in a let/else statement.\n+                    // However, if it arrives in second position, its pattern may cover some cases already covered\n+                    // by the diverging one.\n+                    // TODO: accept the non-diverging arm as a second position if patterns are disjointed.\n+                    if idx == 0 {\n+                        return;\n+                    }\n+                    let pat_arm = &arms[1 - idx];\n+                    if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n+                        return;\n+                    }\n \n-                emit_manual_let_else(cx, stmt.span, match_expr, local.pat, pat_arm.pat, diverging_arm.body);\n-            },\n-        }\n+                    emit_manual_let_else(cx, stmt.span, match_expr, local.pat, pat_arm.pat, diverging_arm.body);\n+                },\n+            }\n         };\n     }\n "}]}