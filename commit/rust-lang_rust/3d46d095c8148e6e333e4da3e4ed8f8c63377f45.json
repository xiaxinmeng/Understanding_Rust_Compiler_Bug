{"sha": "3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNDZkMDk1YzgxNDhlNmUzMzNlNGRhM2U0ZWQ4ZjhjNjMzNzdmNDU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-15T17:08:53Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-15T17:08:53Z"}, "message": "use stalled_on in all obligation types\n\nthis improves typeck performance by 5% (LLVM times are still huge).\n\nBasically fixes #25916 (still O(n^2), but the example takes <1s to\ncompile).", "tree": {"sha": "a1b45b14ae6f524dc7834d5e212c95f6a76ed373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b45b14ae6f524dc7834d5e212c95f6a76ed373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "html_url": "https://github.com/rust-lang/rust/commit/3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/comments", "author": null, "committer": null, "parents": [{"sha": "3a254fe4bd10f630da76e89cbdc1275413a189d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a254fe4bd10f630da76e89cbdc1275413a189d8", "html_url": "https://github.com/rust-lang/rust/commit/3a254fe4bd10f630da76e89cbdc1275413a189d8"}], "stats": {"total": 82, "additions": 68, "deletions": 14}, "files": [{"sha": "de70cdbd29a354849607c3deb4f5e712a50aed07", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "patch": "@@ -10,7 +10,7 @@\n \n use dep_graph::DepGraph;\n use middle::infer::InferCtxt;\n-use middle::ty::{self, Ty, TypeFoldable};\n+use middle::ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n use std::iter;\n use syntax::ast;\n@@ -417,6 +417,21 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n+\n+/// Return the set of type variables contained in a trait ref\n+fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n+                                 t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    t.skip_binder() // ok b/c this check doesn't care about regions\n+     .input_types()\n+     .iter()\n+     .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n+     .filter(|t| t.has_infer_types())\n+     .flat_map(|t| t.walk())\n+     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+     .collect()\n+}\n+\n /// Processes a predicate obligation and returns either:\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n@@ -433,7 +448,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     // doing more work yet\n     if !pending_obligation.stalled_on.is_empty() {\n         if pending_obligation.stalled_on.iter().all(|&ty| {\n-            let resolved_ty = selcx.infcx().resolve_type_vars_if_possible(&ty);\n+            let resolved_ty = selcx.infcx().shallow_resolve(&ty);\n             resolved_ty == ty // nothing changed here\n         }) {\n             debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n@@ -493,14 +508,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     // of its type, and those types are resolved at\n                     // the same time.\n                     pending_obligation.stalled_on =\n-                        data.skip_binder() // ok b/c this check doesn't care about regions\n-                        .input_types()\n-                        .iter()\n-                        .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n-                        .filter(|t| t.has_infer_types())\n-                        .flat_map(|t| t.walk())\n-                        .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n-                        .collect();\n+                        trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n \n                     debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n                            selcx.infcx().resolve_type_vars_if_possible(obligation),\n@@ -568,6 +576,11 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n             match project::poly_project_and_unify_type(selcx, &project_obligation) {\n+                Ok(None) => {\n+                    pending_obligation.stalled_on =\n+                        trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n+                    Ok(None)\n+                }\n                 Ok(v) => Ok(v),\n                 Err(e) => Err(CodeProjectionError(e))\n             }\n@@ -582,8 +595,14 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            Ok(ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n-                                   ty, obligation.cause.span))\n+            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+                                      ty, obligation.cause.span) {\n+                None => {\n+                    pending_obligation.stalled_on = vec![ty];\n+                    Ok(None)\n+                }\n+                s => Ok(s)\n+            }\n         }\n     }\n }"}, {"sha": "0fd443239f8b578c2503a9d11a44004ac721a854", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "patch": "@@ -917,7 +917,7 @@ impl<'tcx> ToPolyTraitRef<'tcx> for TraitRef<'tcx> {\n \n impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        self.map_bound_ref(|trait_pred| trait_pred.trait_ref.clone())\n+        self.map_bound_ref(|trait_pred| trait_pred.trait_ref)\n     }\n }\n \n@@ -928,7 +928,7 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyProjectionPredicate<'tcx> {\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n-        ty::Binder(self.0.projection_ty.trait_ref.clone())\n+        ty::Binder(self.0.projection_ty.trait_ref)\n     }\n }\n "}, {"sha": "eb52e2e21c481387f5f872442c63f59dfa7205de", "filename": "src/test/run-pass/issue-25916.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Ftest%2Frun-pass%2Fissue-25916.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d46d095c8148e6e333e4da3e4ed8f8c63377f45/src%2Ftest%2Frun-pass%2Fissue-25916.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25916.rs?ref=3d46d095c8148e6e333e4da3e4ed8f8c63377f45", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    macro_rules! f {\n+        () => { 0 + 0 }\n+    }\n+    // 16 per line\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+    f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();f!();\n+}"}]}