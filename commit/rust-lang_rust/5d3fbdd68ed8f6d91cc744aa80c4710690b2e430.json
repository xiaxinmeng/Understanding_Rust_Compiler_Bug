{"sha": "5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkM2ZiZGQ2OGVkOGY2ZDkxY2M3NDRhYTgwYzQ3MTA2OTBiMmU0MzA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-20T15:35:58Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-20T15:35:58Z"}, "message": "Use more rustc_codegen_ssa::back::link for linking", "tree": {"sha": "6215a9f51078146b6336d6997b8d301177907bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6215a9f51078146b6336d6997b8d301177907bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "html_url": "https://github.com/rust-lang/rust/commit/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b3b6f08314a8255e81e22691513c8da1703bfde", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3b6f08314a8255e81e22691513c8da1703bfde", "html_url": "https://github.com/rust-lang/rust/commit/8b3b6f08314a8255e81e22691513c8da1703bfde"}], "stats": {"total": 288, "additions": 4, "deletions": 284}, "files": [{"sha": "7694892a8e80a7c835e42539ae8d6efa6c658f28", "filename": "src/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink.rs?ref=5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "patch": "@@ -11,6 +11,7 @@ use tempfile::Builder as TempFileBuilder;\n use rustc::session::config::{self, CrateType, DebugInfo, RUST_CGU_EXT};\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n+use rustc_codegen_ssa::METADATA_FILENAME;\n use rustc_codegen_ssa::back::command::Command;\n use rustc_codegen_ssa::back::link::*;\n use rustc_codegen_ssa::back::linker::*;\n@@ -48,7 +49,7 @@ pub(crate) fn link_rlib(sess: &Session, res: &CodegenResults, output_name: PathB\n     builder\n         .append(\n             &ar::Header::new(\n-                crate::metadata::METADATA_FILENAME.as_bytes().to_vec(),\n+                METADATA_FILENAME.as_bytes().to_vec(),\n                 res.metadata.raw_data.len() as u64,\n             ),\n             ::std::io::Cursor::new(res.metadata.raw_data.clone()),"}, {"sha": "d58ffda3336c22d7e437c7f9ed81fd2984cb5aea", "filename": "src/link_copied.rs", "status": "modified", "additions": 1, "deletions": 281, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Flink_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Flink_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink_copied.rs?ref=5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "patch": "@@ -1,21 +1,14 @@\n //! All functions here are copied from https://github.com/rust-lang/rust/blob/942864a000efd74b73e36bda5606b2cdb55ecf39/src/librustc_codegen_llvm/back/link.rs\n \n-use std::fmt;\n-use std::fs;\n-use std::io;\n-use std::iter;\n use std::path::{Path, PathBuf};\n-use std::process::{Output, Stdio};\n-\n-use log::info;\n \n use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use rustc::session::config::{self, OutputType, RUST_CGU_EXT};\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n use rustc::util::common::time;\n-use rustc_codegen_ssa::back::command::Command;\n+use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n use rustc_codegen_ssa::back::linker::*;\n use rustc_codegen_ssa::back::link::*;\n use rustc_data_structures::fx::FxHashSet;\n@@ -25,11 +18,6 @@ use syntax::attr;\n use crate::prelude::*;\n \n use crate::archive::{ArchiveBuilder, ArchiveConfig};\n-use crate::metadata::METADATA_FILENAME;\n-\n-\n-// cg_clif doesn't have bytecode, so this is just a dummy\n-const RLIB_BYTECODE_EXTENSION: &str = \".cg_clif_bytecode_dummy\";\n \n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     sess.target_filesearch(PathKind::Native).search_path_dirs()\n@@ -46,147 +34,6 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n-pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n-    -> io::Result<Output>\n-{\n-    // When attempting to spawn the linker we run a risk of blowing out the\n-    // size limits for spawning a new process with respect to the arguments\n-    // we pass on the command line.\n-    //\n-    // Here we attempt to handle errors from the OS saying \"your list of\n-    // arguments is too big\" by reinvoking the linker again with an `@`-file\n-    // that contains all the arguments. The theory is that this is then\n-    // accepted on all linkers and the linker will read all its options out of\n-    // there instead of looking at the command line.\n-    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n-        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n-            Ok(child) => {\n-                let output = child.wait_with_output();\n-                flush_linked_file(&output, out_filename)?;\n-                return output;\n-            }\n-            Err(ref e) if command_line_too_big(e) => {\n-                info!(\"command line to linker was too big: {}\", e);\n-            }\n-            Err(e) => return Err(e)\n-        }\n-    }\n-\n-    info!(\"falling back to passing arguments to linker via an @-file\");\n-    let mut cmd2 = cmd.clone();\n-    let mut args = String::new();\n-    for arg in cmd2.take_args() {\n-        args.push_str(&Escape {\n-            arg: arg.to_str().unwrap(),\n-            is_like_msvc: sess.target.target.options.is_like_msvc,\n-        }.to_string());\n-        args.push_str(\"\\n\");\n-    }\n-    let file = tmpdir.join(\"linker-arguments\");\n-    let bytes = if sess.target.target.options.is_like_msvc {\n-        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n-        // start the stream with a UTF-16 BOM\n-        for c in iter::once(0xFEFF).chain(args.encode_utf16()) {\n-            // encode in little endian\n-            out.push(c as u8);\n-            out.push((c >> 8) as u8);\n-        }\n-        out\n-    } else {\n-        args.into_bytes()\n-    };\n-    fs::write(&file, &bytes)?;\n-    cmd2.arg(format!(\"@{}\", file.display()));\n-    info!(\"invoking linker {:?}\", cmd2);\n-    let output = cmd2.output();\n-    flush_linked_file(&output, out_filename)?;\n-    return output;\n-\n-    #[cfg(unix)]\n-    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(windows)]\n-    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n-        -> io::Result<()>\n-    {\n-        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n-        // even long after process exit, causing nasty, non-reproducible output bugs.\n-        //\n-        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n-        //\n-        // \u0410 full writeup of the original Chrome bug can be found at\n-        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n-\n-        if let &Ok(ref out) = command_output {\n-            if out.status.success() {\n-                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n-                    of.sync_all()?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[cfg(unix)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        err.raw_os_error() == Some(::libc::E2BIG)\n-    }\n-\n-    #[cfg(windows)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n-        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n-    }\n-\n-    struct Escape<'a> {\n-        arg: &'a str,\n-        is_like_msvc: bool,\n-    }\n-\n-    impl<'a> fmt::Display for Escape<'a> {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            if self.is_like_msvc {\n-                // This is \"documented\" at\n-                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n-                //\n-                // Unfortunately there's not a great specification of the\n-                // syntax I could find online (at least) but some local\n-                // testing showed that this seemed sufficient-ish to catch\n-                // at least a few edge cases.\n-                write!(f, \"\\\"\")?;\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\"' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-                write!(f, \"\\\"\")?;\n-            } else {\n-                // This is documented at https://linux.die.net/man/1/ld, namely:\n-                //\n-                // > Options in file are separated by whitespace. A whitespace\n-                // > character may be included in an option by surrounding the\n-                // > entire option in either single or double quotes. Any\n-                // > character (including a backslash) may be included by\n-                // > prefixing the character to be included with a backslash.\n-                //\n-                // We put an argument on each line, so all we need to do is\n-                // ensure the line is interpreted as one whole argument.\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-            }\n-            Ok(())\n-        }\n-    }\n-}\n-\n // # Rust Crate linking\n //\n // Rust crates are not considered at all when creating an rlib output. All\n@@ -505,130 +352,3 @@ pub fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n                             parent.unwrap_or(Path::new(\"\")));\n     }\n }\n-\n-// # Native library linking\n-//\n-// User-supplied library search paths (-L on the command line). These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n-//\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n-pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n-                              sess: &Session,\n-                              codegen_results: &CodegenResults) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n-            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n-        }\n-    }\n-\n-    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n-        relevant_lib(sess, l)\n-    });\n-\n-    let search_path = archive_search_paths(sess);\n-    for lib in relevant_libs {\n-        let name = match lib.name {\n-            Some(ref l) => l,\n-            None => continue,\n-        };\n-        match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n-                                                                        &search_path)\n-        }\n-    }\n-}\n-\n-// Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native dependencies are all non-static\n-// dependencies. We've got two cases then:\n-//\n-// 1. The upstream crate is an rlib. In this case we *must* link in the\n-// native dependency because the rlib is just an archive.\n-//\n-// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-// have the dependency present on the system somewhere. Thus, we don't\n-// gain a whole lot from not linking in the dynamic dependency to this\n-// crate as well.\n-//\n-// The use case for this is a little subtle. In theory the native\n-// dependencies of a crate are purely an implementation detail of the crate\n-// itself, but the problem arises with generic and inlined functions. If a\n-// generic function calls a native function, then the generic function must\n-// be instantiated in the target crate, meaning that the native symbol must\n-// also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n-    // Be sure to use a topological sorting of crates because there may be\n-    // interdependencies between native libraries. When passing -nodefaultlibs,\n-    // for example, almost all native libraries depend on libc, so we have to\n-    // make sure that's all the way at the right (liblibc is near the base of\n-    // the dependency chain).\n-    //\n-    // This passes RequireStatic, but the actual requirement doesn't matter,\n-    // we're just getting an ordering of crate numbers, we're not worried about\n-    // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    let crates = &codegen_results.crate_info.used_crates_static;\n-    for &(cnum, _) in crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let name = match lib.name {\n-                Some(ref l) => l,\n-                None => continue,\n-            };\n-            if !relevant_lib(sess, &lib) {\n-                continue\n-            }\n-            match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-                NativeLibraryKind::NativeStaticNobundle => {\n-                    // Link \"static-nobundle\" native libs only if the crate they originate from\n-                    // is being linked statically to the current crate.  If it's linked dynamically\n-                    // or is an rlib already included via some other dylib crate, the symbols from\n-                    // native libs will have already been included in that dylib.\n-                    if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(&name.as_str())\n-                    }\n-                },\n-                // ignore statically included native libraries here as we've\n-                // already included them when we included the rust library\n-                // previously\n-                NativeLibraryKind::NativeStatic => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n-fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n-    match sess.lto() {\n-        Lto::Fat => true,\n-        Lto::Thin => {\n-            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n-            // any upstream object files have not been copied yet.\n-            !sess.opts.cg.linker_plugin_lto.enabled()\n-        }\n-        Lto::No |\n-        Lto::ThinLocal => false,\n-    }\n-}"}, {"sha": "d7fd026dfaf0f34d2298ae5aff6758009af4897d", "filename": "src/metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3fbdd68ed8f6d91cc744aa80c4710690b2e430/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=5d3fbdd68ed8f6d91cc744aa80c4710690b2e430", "patch": "@@ -1,11 +1,10 @@\n use rustc::middle::cstore::MetadataLoader;\n+use rustc_codegen_ssa::METADATA_FILENAME;\n use rustc_data_structures::owning_ref::{self, OwningRef};\n use rustc_data_structures::rustc_erase_owner;\n use std::fs::File;\n use std::path::Path;\n \n-pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n-\n pub struct CraneliftMetadataLoader;\n \n impl MetadataLoader for CraneliftMetadataLoader {"}]}