{"sha": "07c7f35effe1a4602ba02baf9ff67a4eb214818f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YzdmMzVlZmZlMWE0NjAyYmEwMmJhZjlmZjY3YTRlYjIxNDgxOGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-03T07:54:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-03T07:54:45Z"}, "message": "Merge #6430\n\n6430: Move completions rendering into a separate module r=popzxc a=popzxc\n\nThis PR extracts rendering-related things from `Completions` structure to the new `render` module.\r\n\r\n`render` module declares a `Render` structure (which is a generic renderer interface), `RenderContext` (interface for data/methods not required for completions generating, but required for rendering), and a bunch of smaller `*Render` structures which encapsulate logic behind rendering a certain item.\r\n\r\nThis is just a step in full separation direction, since the following this are still to be done:\r\n\r\n- Move some data from `CompletionContext` to the `RenderContext`;\r\n- Forbid any kind of rendering outside of `render` module;\r\n- Extract score computing into a separate module.\r\n\r\nThis PR is already pretty big, so not to make it even harder to review I decided to split this process into several subsequent PRs.\r\n\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>", "tree": {"sha": "1cf4253dc23366dfd20f36285036d73b168a526e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cf4253dc23366dfd20f36285036d73b168a526e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07c7f35effe1a4602ba02baf9ff67a4eb214818f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfoQzFCRBK7hj4Ov3rIwAAdHIIAFvBwWj5HMzjmnzubLgQ+Rci\nEvvDmxZDw2SM3IouWuAksxoXytGQQHNu8CdjFdpO/JT/MQaODtQEQJIsQr72t596\ndAO+pu5731OqFazL3D9+djFzY6udBpTA61O1631/BaJmAnmKG0Ge9IYvgWKJaB/2\niY1nIZqroy08bX1J/d5s7XMmJ+eYn2bNEMhZO/1ItHj+ZbG1S69stEuqYmL0MZrI\npuLJWyvDNKM1ahyAk6IZypUSewXDjPPJVDMP0mdO1DS9TsuMwnZmB+gD9Qt9xwlv\nzM7WkcNHAoko7qjl281dqTb8uhgmSiYbHg8ZHGqzR9VIH+2JlLXLgMF++jJpUPU=\n=naqA\n-----END PGP SIGNATURE-----\n", "payload": "tree 1cf4253dc23366dfd20f36285036d73b168a526e\nparent 658e97a39e77bcb978697a66ddccd7e4b58990cf\nparent 8efe43245bc64ed27f88c333541b2cb7af2ce44c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604390085 +0000\ncommitter GitHub <noreply@github.com> 1604390085 +0000\n\nMerge #6430\n\n6430: Move completions rendering into a separate module r=popzxc a=popzxc\n\nThis PR extracts rendering-related things from `Completions` structure to the new `render` module.\r\n\r\n`render` module declares a `Render` structure (which is a generic renderer interface), `RenderContext` (interface for data/methods not required for completions generating, but required for rendering), and a bunch of smaller `*Render` structures which encapsulate logic behind rendering a certain item.\r\n\r\nThis is just a step in full separation direction, since the following this are still to be done:\r\n\r\n- Move some data from `CompletionContext` to the `RenderContext`;\r\n- Forbid any kind of rendering outside of `render` module;\r\n- Extract score computing into a separate module.\r\n\r\nThis PR is already pretty big, so not to make it even harder to review I decided to split this process into several subsequent PRs.\r\n\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07c7f35effe1a4602ba02baf9ff67a4eb214818f", "html_url": "https://github.com/rust-lang/rust/commit/07c7f35effe1a4602ba02baf9ff67a4eb214818f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07c7f35effe1a4602ba02baf9ff67a4eb214818f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658e97a39e77bcb978697a66ddccd7e4b58990cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/658e97a39e77bcb978697a66ddccd7e4b58990cf", "html_url": "https://github.com/rust-lang/rust/commit/658e97a39e77bcb978697a66ddccd7e4b58990cf"}, {"sha": "8efe43245bc64ed27f88c333541b2cb7af2ce44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8efe43245bc64ed27f88c333541b2cb7af2ce44c", "html_url": "https://github.com/rust-lang/rust/commit/8efe43245bc64ed27f88c333541b2cb7af2ce44c"}], "stats": {"total": 3136, "additions": 1781, "deletions": 1355}, "files": [{"sha": "75dbb1a23bb5c8c616d7c2b752994aa573e627e9", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 29, "deletions": 1342, "changes": 1371, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -14,14 +14,16 @@ pub(crate) mod macro_in_item_position;\n pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n \n-use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, StructKind, Type};\n-use itertools::Itertools;\n-use syntax::{ast::NameOwner, display::*};\n-use test_utils::mark;\n+use hir::{ModPath, ScopeDef, Type};\n \n use crate::{\n-    item::Builder, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n-    CompletionScore, RootDatabase,\n+    item::Builder,\n+    render::{\n+        const_::render_const, enum_variant::render_enum_variant, function::render_fn,\n+        macro_::render_macro, render_field, render_resolution, render_tuple_field,\n+        type_alias::render_type_alias, RenderContext,\n+    },\n+    CompletionContext, CompletionItem,\n };\n \n /// Represents an in-progress set of completions being built.\n@@ -58,27 +60,13 @@ impl Completions {\n     }\n \n     pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n-        let is_deprecated = is_deprecated(field, ctx.db);\n-        let name = field.name(ctx.db);\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n-                .kind(CompletionItemKind::Field)\n-                .detail(ty.display(ctx.db).to_string())\n-                .set_documentation(field.docs(ctx.db))\n-                .set_deprecated(is_deprecated);\n-\n-        if let Some(score) = compute_score(ctx, &ty, &name.to_string()) {\n-            item = item.set_score(score);\n-        }\n-\n-        item.add_to(self);\n+        let item = render_field(RenderContext::new(ctx), field, ty);\n+        self.add(item);\n     }\n \n     pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n-            .kind(CompletionItemKind::Field)\n-            .detail(ty.display(ctx.db).to_string())\n-            .add_to(self);\n+        let item = render_tuple_field(RenderContext::new(ctx), field, ty);\n+        self.add(item);\n     }\n \n     pub(crate) fn add_resolution(\n@@ -87,100 +75,9 @@ impl Completions {\n         local_name: String,\n         resolution: &ScopeDef,\n     ) {\n-        use hir::ModuleDef::*;\n-\n-        let completion_kind = match resolution {\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-            _ => CompletionKind::Reference,\n-        };\n-\n-        let kind = match resolution {\n-            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n-            ScopeDef::ModuleDef(Function(func)) => {\n-                self.add_function(ctx, *func, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n-            // FIXME: add CompletionItemKind::Union\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n-\n-            ScopeDef::ModuleDef(EnumVariant(var)) => {\n-                self.add_enum_variant(ctx, *var, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n-            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n-            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n-            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::Local(..) => CompletionItemKind::Binding,\n-            // (does this need its own kind?)\n-            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::MacroDef(mac) => {\n-                self.add_macro(ctx, Some(local_name), *mac);\n-                return;\n-            }\n-            ScopeDef::Unknown => {\n-                CompletionItem::new(CompletionKind::Reference, ctx.source_range(), local_name)\n-                    .kind(CompletionItemKind::UnresolvedReference)\n-                    .add_to(self);\n-                return;\n-            }\n-        };\n-\n-        let docs = match resolution {\n-            ScopeDef::ModuleDef(Module(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Adt(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Const(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Static(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Trait(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(ctx.db),\n-            _ => None,\n-        };\n-\n-        let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n-        if let ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(ctx.db);\n-            if !ty.is_unknown() {\n-                item = item.detail(ty.display(ctx.db).to_string());\n-            }\n-        };\n-\n-        let mut ref_match = None;\n-        if let ScopeDef::Local(local) = resolution {\n-            if let Some((active_name, active_type)) = ctx.active_name_and_type() {\n-                let ty = local.ty(ctx.db);\n-                if let Some(score) =\n-                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n-                {\n-                    item = item.set_score(score);\n-                }\n-                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n-            }\n+        if let Some(item) = render_resolution(RenderContext::new(ctx), local_name, resolution) {\n+            self.add(item);\n         }\n-\n-        // Add `<>` for generic types\n-        if ctx.is_path_type && !ctx.has_type_args && ctx.config.add_call_parenthesis {\n-            if let Some(cap) = ctx.config.snippet_cap {\n-                let has_non_default_type_params = match resolution {\n-                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n-                    ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n-                    _ => false,\n-                };\n-                if has_non_default_type_params {\n-                    mark::hit!(inserts_angle_brackets_for_generics);\n-                    item = item\n-                        .lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-                }\n-            }\n-        }\n-\n-        item.kind(kind).set_documentation(docs).set_ref_match(ref_match).add_to(self)\n     }\n \n     pub(crate) fn add_macro(\n@@ -189,50 +86,13 @@ impl Completions {\n         name: Option<String>,\n         macro_: hir::MacroDef,\n     ) {\n-        // FIXME: Currently proc-macro do not have ast-node,\n-        // such that it does not have source\n-        if macro_.is_proc_macro() {\n-            return;\n-        }\n-\n         let name = match name {\n             Some(it) => it,\n             None => return,\n         };\n-\n-        let ast_node = macro_.source(ctx.db).value;\n-        let detail = macro_label(&ast_node);\n-\n-        let docs = macro_.docs(ctx.db);\n-\n-        let mut builder = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            &format!(\"{}!\", name),\n-        )\n-        .kind(CompletionItemKind::Macro)\n-        .set_documentation(docs.clone())\n-        .set_deprecated(is_deprecated(macro_, ctx.db))\n-        .detail(detail);\n-\n-        let needs_bang = ctx.use_item_syntax.is_none() && !ctx.is_macro_call;\n-        builder = match ctx.config.snippet_cap {\n-            Some(cap) if needs_bang => {\n-                let docs = docs.as_ref().map_or(\"\", |s| s.as_str());\n-                let (bra, ket) = guess_macro_braces(&name, docs);\n-                builder\n-                    .insert_snippet(cap, format!(\"{}!{}$0{}\", name, bra, ket))\n-                    .label(format!(\"{}!{}\u2026{}\", name, bra, ket))\n-                    .lookup_by(format!(\"{}!\", name))\n-            }\n-            None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n-            _ => {\n-                mark::hit!(dont_insert_macro_call_parens_unncessary);\n-                builder.insert_text(name)\n-            }\n-        };\n-\n-        self.add(builder.build());\n+        if let Some(item) = render_macro(RenderContext::new(ctx), name, macro_) {\n+            self.add(item);\n+        }\n     }\n \n     pub(crate) fn add_function(\n@@ -241,82 +101,20 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n-        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n-            if let Some(derefed_ty) = ty.remove_ref() {\n-                for (name, local) in ctx.locals.iter() {\n-                    if name == arg && local.ty(ctx.db) == derefed_ty {\n-                        return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n-                            + &arg.to_string();\n-                    }\n-                }\n-            }\n-            arg.to_string()\n-        };\n-        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n-        let ast_node = func.source(ctx.db).value;\n-\n-        let mut builder =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if func.self_param(ctx.db).is_some() {\n-                    CompletionItemKind::Method\n-                } else {\n-                    CompletionItemKind::Function\n-                })\n-                .set_documentation(func.docs(ctx.db))\n-                .set_deprecated(is_deprecated(func, ctx.db))\n-                .detail(function_declaration(&ast_node));\n-\n-        let params_ty = func.params(ctx.db);\n-        let params = ast_node\n-            .param_list()\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .zip(params_ty)\n-            .flat_map(|(it, param_ty)| {\n-                if let Some(pat) = it.pat() {\n-                    let name = pat.to_string();\n-                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n-                    return Some(add_arg(arg, param_ty.ty(), ctx));\n-                }\n-                None\n-            })\n-            .collect();\n-\n-        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n-\n-        self.add(builder.build())\n+        let item = render_fn(RenderContext::new(ctx), local_name, func);\n+        self.add(item)\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n-        let ast_node = constant.source(ctx.db).value;\n-        let name = match ast_node.name() {\n-            Some(name) => name,\n-            _ => return,\n-        };\n-        let detail = const_label(&ast_node);\n-\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n-            .kind(CompletionItemKind::Const)\n-            .set_documentation(constant.docs(ctx.db))\n-            .set_deprecated(is_deprecated(constant, ctx.db))\n-            .detail(detail)\n-            .add_to(self);\n+        if let Some(item) = render_const(RenderContext::new(ctx), constant) {\n+            self.add(item);\n+        }\n     }\n \n     pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n-        let type_def = type_alias.source(ctx.db).value;\n-        let name = match type_def.name() {\n-            Some(name) => name,\n-            _ => return,\n-        };\n-        let detail = type_label(&type_def);\n-\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n-            .kind(CompletionItemKind::TypeAlias)\n-            .set_documentation(type_alias.docs(ctx.db))\n-            .set_deprecated(is_deprecated(type_alias, ctx.db))\n-            .detail(detail)\n-            .add_to(self);\n+        if let Some(item) = render_type_alias(RenderContext::new(ctx), type_alias) {\n+            self.add(item)\n+        }\n     }\n \n     pub(crate) fn add_qualified_enum_variant(\n@@ -325,7 +123,8 @@ impl Completions {\n         variant: hir::EnumVariant,\n         path: ModPath,\n     ) {\n-        self.add_enum_variant_impl(ctx, variant, None, Some(path))\n+        let item = render_enum_variant(RenderContext::new(ctx), None, variant, Some(path));\n+        self.add(item);\n     }\n \n     pub(crate) fn add_enum_variant(\n@@ -334,1119 +133,7 @@ impl Completions {\n         variant: hir::EnumVariant,\n         local_name: Option<String>,\n     ) {\n-        self.add_enum_variant_impl(ctx, variant, local_name, None)\n-    }\n-\n-    fn add_enum_variant_impl(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        variant: hir::EnumVariant,\n-        local_name: Option<String>,\n-        path: Option<ModPath>,\n-    ) {\n-        let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n-        let (qualified_name, short_qualified_name) = match &path {\n-            Some(path) => {\n-                let full = path.to_string();\n-                let short =\n-                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n-                (full, short)\n-            }\n-            None => (name.to_string(), name.to_string()),\n-        };\n-        let detail_types = variant\n-            .fields(ctx.db)\n-            .into_iter()\n-            .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n-        let variant_kind = variant.kind(ctx.db);\n-        let detail = match variant_kind {\n-            StructKind::Tuple | StructKind::Unit => format!(\n-                \"({})\",\n-                detail_types.map(|(_, t)| t.display(ctx.db).to_string()).format(\", \")\n-            ),\n-            StructKind::Record => format!(\n-                \"{{ {} }}\",\n-                detail_types\n-                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n-                    .format(\", \")\n-            ),\n-        };\n-        let mut res = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            qualified_name.clone(),\n-        )\n-        .kind(CompletionItemKind::EnumVariant)\n-        .set_documentation(variant.docs(ctx.db))\n-        .set_deprecated(is_deprecated)\n-        .detail(detail);\n-\n-        if variant_kind == StructKind::Tuple {\n-            mark::hit!(inserts_parens_for_tuple_enums);\n-            let params = Params::Anonymous(variant.fields(ctx.db).len());\n-            res = res.add_call_parens(ctx, short_qualified_name, params)\n-        } else if path.is_some() {\n-            res = res.lookup_by(short_qualified_name);\n-        }\n-\n-        res.add_to(self);\n-    }\n-}\n-\n-fn compute_score_from_active(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<CompletionScore> {\n-    // Compute score\n-    // For the same type\n-    if active_type != ty {\n-        return None;\n-    }\n-\n-    let mut res = CompletionScore::TypeMatch;\n-\n-    // If same type + same name then go top position\n-    if active_name == name {\n-        res = CompletionScore::TypeAndNameMatch\n-    }\n-\n-    Some(res)\n-}\n-fn refed_type_matches(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<(Mutability, CompletionScore)> {\n-    let derefed_active = active_type.remove_ref()?;\n-    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n-    Some((\n-        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n-        score,\n-    ))\n-}\n-\n-fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n-    let (active_name, active_type) = ctx.active_name_and_type()?;\n-    compute_score_from_active(&active_type, &active_name, ty, name)\n-}\n-\n-enum Params {\n-    Named(Vec<String>),\n-    Anonymous(usize),\n-}\n-\n-impl Params {\n-    fn len(&self) -> usize {\n-        match self {\n-            Params::Named(xs) => xs.len(),\n-            Params::Anonymous(len) => *len,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-impl Builder {\n-    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n-        if !ctx.config.add_call_parenthesis {\n-            return self;\n-        }\n-        if ctx.use_item_syntax.is_some() {\n-            mark::hit!(no_parens_in_use_item);\n-            return self;\n-        }\n-        if ctx.is_pattern_call {\n-            mark::hit!(dont_duplicate_pattern_parens);\n-            return self;\n-        }\n-        if ctx.is_call {\n-            return self;\n-        }\n-\n-        // Don't add parentheses if the expected type is some function reference.\n-        if let Some(ty) = &ctx.expected_type {\n-            if ty.is_fn() {\n-                mark::hit!(no_call_parens_if_fn_ptr_needed);\n-                return self;\n-            }\n-        }\n-\n-        let cap = match ctx.config.snippet_cap {\n-            Some(it) => it,\n-            None => return self,\n-        };\n-        // If not an import, add parenthesis automatically.\n-        mark::hit!(inserts_parens_for_function_calls);\n-\n-        let (snippet, label) = if params.is_empty() {\n-            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n-        } else {\n-            self = self.trigger_call_info();\n-            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n-                (true, Params::Named(params)) => {\n-                    let function_params_snippet =\n-                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n-                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n-                        });\n-                    format!(\"{}({})$0\", name, function_params_snippet)\n-                }\n-                _ => {\n-                    mark::hit!(suppress_arg_snippets);\n-                    format!(\"{}($0)\", name)\n-                }\n-            };\n-\n-            (snippet, format!(\"{}(\u2026)\", name))\n-        };\n-        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n-    }\n-}\n-\n-fn is_deprecated(node: impl HasAttrs, db: &RootDatabase) -> bool {\n-    node.attrs(db).by_key(\"deprecated\").exists()\n-}\n-\n-fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n-    let mut votes = [0, 0, 0];\n-    for (idx, s) in docs.match_indices(&macro_name) {\n-        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n-        // Ensure to match the full word\n-        if after.starts_with('!')\n-            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n-        {\n-            // It may have spaces before the braces like `foo! {}`\n-            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n-                Some('{') => votes[0] += 1,\n-                Some('[') => votes[1] += 1,\n-                Some('(') => votes[2] += 1,\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    // Insert a space before `{}`.\n-    // We prefer the last one when some votes equal.\n-    let (_vote, (bra, ket)) = votes\n-        .iter()\n-        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n-        .max_by_key(|&(&vote, _)| vote)\n-        .unwrap();\n-    (*bra, *ket)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::cmp::Reverse;\n-\n-    use expect_test::{expect, Expect};\n-    use test_utils::mark;\n-\n-    use crate::{\n-        test_utils::{check_edit, check_edit_with_config, do_completion, get_all_items},\n-        CompletionConfig, CompletionKind, CompletionScore,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n-        expect.assert_debug_eq(&actual);\n-    }\n-\n-    fn check_scores(ra_fixture: &str, expect: Expect) {\n-        fn display_score(score: Option<CompletionScore>) -> &'static str {\n-            match score {\n-                Some(CompletionScore::TypeMatch) => \"[type]\",\n-                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n-                None => \"[]\".into(),\n-            }\n-        }\n-\n-        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n-        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n-        let actual = completions\n-            .into_iter()\n-            .filter(|it| it.completion_kind == CompletionKind::Reference)\n-            .map(|it| {\n-                let tag = it.kind().unwrap().tag();\n-                let score = display_score(it.score());\n-                format!(\"{} {} {}\\n\", tag, it.label(), score)\n-            })\n-            .collect::<String>();\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn enum_detail_includes_record_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo { x: i32, y: i32 } }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 54..56,\n-                        delete: 54..56,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"{ x: i32, y: i32 }\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_doesnt_include_tuple_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo (i32, i32) }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo(\u2026)\",\n-                        source_range: 46..48,\n-                        delete: 46..48,\n-                        insert: \"Foo($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Foo\",\n-                        detail: \"(i32, i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_just_parentheses_for_unit() {\n-        check(\n-            r#\"\n-enum Foo { Foo }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 35..37,\n-                        delete: 35..37,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn lookup_enums_by_two_qualifiers() {\n-        check(\n-            r#\"\n-mod m {\n-    pub enum Spam { Foo, Bar(i32) }\n-}\n-fn main() { let _: m::Spam = S<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Spam::Bar(\u2026)\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"Spam::Bar($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Bar\",\n-                        detail: \"(i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"m\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m\",\n-                        kind: Module,\n-                    },\n-                    CompletionItem {\n-                        label: \"m::Spam::Foo\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m::Spam::Foo\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Foo\",\n-                        detail: \"()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn sets_deprecated_flag_in_items() {\n-        check(\n-            r#\"\n-#[deprecated]\n-fn something_deprecated() {}\n-#[deprecated(since = \"1.0.0\")]\n-fn something_else_deprecated() {}\n-\n-fn main() { som<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"something_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_deprecated\",\n-                        detail: \"fn something_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"something_else_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_else_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_else_deprecated\",\n-                        detail: \"fn something_else_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-struct A { #[deprecated] the_field: u32 }\n-fn foo() { A { the<|> } }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_field\",\n-                        source_range: 57..60,\n-                        delete: 57..60,\n-                        insert: \"the_field\",\n-                        kind: Field,\n-                        detail: \"u32\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn renders_docs() {\n-        check(\n-            r#\"\n-struct S {\n-    /// Field docs\n-    foo:\n-}\n-impl S {\n-    /// Method docs\n-    fn bar(self) { self.<|> }\n-}\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"bar()\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"bar()$0\",\n-                        kind: Method,\n-                        lookup: \"bar\",\n-                        detail: \"fn bar(self)\",\n-                        documentation: Documentation(\n-                            \"Method docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"foo\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"foo\",\n-                        kind: Field,\n-                        detail: \"{unknown}\",\n-                        documentation: Documentation(\n-                            \"Field docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-use self::my<|>;\n-\n-/// mod docs\n-mod my { }\n-\n-/// enum docs\n-enum E {\n-    /// variant docs\n-    V\n-}\n-use self::E::*;\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"E\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"E\",\n-                        kind: Enum,\n-                        documentation: Documentation(\n-                            \"enum docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"V\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"V\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                        documentation: Documentation(\n-                            \"variant docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"my\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"my\",\n-                        kind: Module,\n-                        documentation: Documentation(\n-                            \"mod docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn dont_render_attrs() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    #[inline]\n-    fn the_method(&self) { }\n-}\n-fn foo(s: S) { s.<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_method()\",\n-                        source_range: 81..81,\n-                        delete: 81..81,\n-                        insert: \"the_method()$0\",\n-                        kind: Method,\n-                        lookup: \"the_method\",\n-                        detail: \"fn the_method(&self)\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_function_calls() {\n-        mark::check!(inserts_parens_for_function_calls);\n-        check_edit(\n-            \"no_args\",\n-            r#\"\n-fn no_args() {}\n-fn main() { no_<|> }\n-\"#,\n-            r#\"\n-fn no_args() {}\n-fn main() { no_args()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args(${1:x}, ${2:y})$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.f<|> }\n-\"#,\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.foo()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.f<|>\n-}\n-\"#,\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.foo(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn suppress_arg_snippets() {\n-        mark::check!(suppress_arg_snippets);\n-        check_edit_with_config(\n-            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args($0) }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn strips_underscores_from_args() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { f<|> }\n-\"#,\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_mut_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&mut x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope_for_method() {\n-        check_edit(\n-            \"apply_foo\",\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.apply_foo(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trim_mut_keyword_in_func_completion() {\n-        check_edit(\n-            \"take_mutably\",\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_m<|>\n-}\n-\"#,\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_mutably(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_tuple_enums() {\n-        mark::check!(inserts_parens_for_tuple_enums);\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Som<|>\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Some($0)\n-}\n-\"#,\n-        );\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Som<|>\n-    }\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Some($0)\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_duplicate_pattern_parens() {\n-        mark::check!(dont_duplicate_pattern_parens);\n-        check_edit(\n-            \"Var\",\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::<|>(92) => (),\n-    }\n-}\n-\"#,\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::Var(92) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_call_parens_if_fn_ptr_needed() {\n-        mark::check!(no_call_parens_if_fn_ptr_needed);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: f<|> }\n-}\n-\"#,\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: foo }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_use_item() {\n-        mark::check!(no_parens_in_use_item);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::f<|>;\n-\"#,\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_call() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { f<|>(); }\n-\"#,\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { foo(); }\n-\"#,\n-        );\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.f<|>(); }\n-\"#,\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.foo(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_angle_brackets_for_generics() {\n-        mark::check!(inserts_angle_brackets_for_generics);\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Vec)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|><i128>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<i128>)\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_insert_macro_call_parens_unncessary() {\n-        mark::check!(dont_insert_macro_call_parens_unncessary);\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-//- /main.rs crate:main deps:foo\n-use foo::<|>;\n-//- /foo/lib.rs crate:foo\n-#[macro_export]\n-macro_rules frobnicate { () => () }\n-\"#,\n-            r#\"\n-use foo::frobnicate;\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frob<|>!(); }\n-\"#,\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frobnicate!(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn active_param_score() {\n-        mark::check!(active_param_type_match);\n-        check_scores(\n-            r#\"\n-struct S { foo: i64, bar: u32, baz: u32 }\n-fn test(bar: u32) { }\n-fn foo(s: S) { test(s.<|>) }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn record_field_scores() {\n-        mark::check!(record_field_type_match);\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn foo(a: A) { B { bar: a.<|> }; }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn record_field_and_call_scores() {\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { B { bar: f(a.<|>) }; }\n-\"#,\n-            expect![[r#\"\n-                fd foo [type+name]\n-                fd bar []\n-                fd baz []\n-            \"#]],\n-        );\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { f(B { bar: a.<|> }); }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn prioritize_exact_ref_match() {\n-        check_scores(\n-            r#\"\n-struct WorldSnapshot { _f: () };\n-fn go(world: &WorldSnapshot) { go(w<|>) }\n-\"#,\n-            expect![[r#\"\n-                bn world [type+name]\n-                st WorldSnapshot []\n-                fn go(\u2026) []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn too_many_arguments() {\n-        check_scores(\n-            r#\"\n-struct Foo;\n-fn f(foo: &Foo) { f(foo, w<|>) }\n-\"#,\n-            expect![[r#\"\n-                st Foo []\n-                fn f(\u2026) []\n-                bn foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn guesses_macro_braces() {\n-        check_edit(\n-            \"vec!\",\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { v<|> }\n-\"#,\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { vec![$0] }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo!\",\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { <|> }\n-\"#,\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { foo! {$0} }\n-\"#,\n-        )\n+        let item = render_enum_variant(RenderContext::new(ctx), local_name, variant, None);\n+        self.add(item);\n     }\n }"}, {"sha": "bf70ee478e31f4f1fe20474ba0405890e2fc4e66", "filename": "crates/completion/src/context.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcontext.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -245,19 +245,6 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    pub(crate) fn active_name_and_type(&self) -> Option<(String, Type)> {\n-        if let Some(record_field) = &self.record_field_syntax {\n-            mark::hit!(record_field_type_match);\n-            let (struct_field, _local) = self.sema.resolve_record_field(record_field)?;\n-            Some((struct_field.name(self.db).to_string(), struct_field.signature_ty(self.db)))\n-        } else if let Some(active_parameter) = &self.active_parameter {\n-            mark::hit!(active_param_type_match);\n-            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);"}, {"sha": "cb6e0554e9a7cededcf6cb4faf49451681b81c62", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -7,6 +7,7 @@ mod patterns;\n mod generated_lint_completions;\n #[cfg(test)]\n mod test_utils;\n+mod render;\n \n mod completions;\n "}, {"sha": "1fa02c37522f0333e5c82c832bcc189a39e53b7a", "filename": "crates/completion/src/render.rs", "status": "added", "additions": 848, "deletions": 0, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,848 @@\n+//! `render` module provides utilities for rendering completion suggestions\n+//! into code pieces that will be presented to user.\n+\n+pub(crate) mod macro_;\n+pub(crate) mod function;\n+pub(crate) mod enum_variant;\n+pub(crate) mod const_;\n+pub(crate) mod type_alias;\n+\n+mod builder_ext;\n+\n+use hir::{Documentation, HasAttrs, HirDisplay, Mutability, ScopeDef, Type};\n+use ide_db::RootDatabase;\n+use syntax::TextRange;\n+use test_utils::mark;\n+\n+use crate::{\n+    config::SnippetCap, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n+    CompletionScore,\n+};\n+\n+use crate::render::{enum_variant::render_enum_variant, function::render_fn, macro_::render_macro};\n+\n+pub(crate) fn render_field<'a>(\n+    ctx: RenderContext<'a>,\n+    field: hir::Field,\n+    ty: &Type,\n+) -> CompletionItem {\n+    Render::new(ctx).add_field(field, ty)\n+}\n+\n+pub(crate) fn render_tuple_field<'a>(\n+    ctx: RenderContext<'a>,\n+    field: usize,\n+    ty: &Type,\n+) -> CompletionItem {\n+    Render::new(ctx).add_tuple_field(field, ty)\n+}\n+\n+pub(crate) fn render_resolution<'a>(\n+    ctx: RenderContext<'a>,\n+    local_name: String,\n+    resolution: &ScopeDef,\n+) -> Option<CompletionItem> {\n+    Render::new(ctx).render_resolution(local_name, resolution)\n+}\n+\n+/// Interface for data and methods required for items rendering.\n+#[derive(Debug)]\n+pub(crate) struct RenderContext<'a> {\n+    completion: &'a CompletionContext<'a>,\n+}\n+\n+impl<'a> RenderContext<'a> {\n+    pub(crate) fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n+        RenderContext { completion }\n+    }\n+\n+    fn snippet_cap(&self) -> Option<SnippetCap> {\n+        self.completion.config.snippet_cap.clone()\n+    }\n+\n+    fn db(&self) -> &'a RootDatabase {\n+        &self.completion.db\n+    }\n+\n+    fn source_range(&self) -> TextRange {\n+        self.completion.source_range()\n+    }\n+\n+    fn is_deprecated(&self, node: impl HasAttrs) -> bool {\n+        node.attrs(self.db()).by_key(\"deprecated\").exists()\n+    }\n+\n+    fn docs(&self, node: impl HasAttrs) -> Option<Documentation> {\n+        node.docs(self.db())\n+    }\n+\n+    fn active_name_and_type(&self) -> Option<(String, Type)> {\n+        if let Some(record_field) = &self.completion.record_field_syntax {\n+            mark::hit!(record_field_type_match);\n+            let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n+            Some((struct_field.name(self.db()).to_string(), struct_field.signature_ty(self.db())))\n+        } else if let Some(active_parameter) = &self.completion.active_parameter {\n+            mark::hit!(active_param_type_match);\n+            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Generic renderer for completion items.\n+#[derive(Debug)]\n+struct Render<'a> {\n+    ctx: RenderContext<'a>,\n+}\n+\n+impl<'a> Render<'a> {\n+    fn new(ctx: RenderContext<'a>) -> Render<'a> {\n+        Render { ctx }\n+    }\n+\n+    fn add_field(&mut self, field: hir::Field, ty: &Type) -> CompletionItem {\n+        let is_deprecated = self.ctx.is_deprecated(field);\n+        let name = field.name(self.ctx.db());\n+        let mut item = CompletionItem::new(\n+            CompletionKind::Reference,\n+            self.ctx.source_range(),\n+            name.to_string(),\n+        )\n+        .kind(CompletionItemKind::Field)\n+        .detail(ty.display(self.ctx.db()).to_string())\n+        .set_documentation(field.docs(self.ctx.db()))\n+        .set_deprecated(is_deprecated);\n+\n+        if let Some(score) = compute_score(&self.ctx, &ty, &name.to_string()) {\n+            item = item.set_score(score);\n+        }\n+\n+        item.build()\n+    }\n+\n+    fn add_tuple_field(&mut self, field: usize, ty: &Type) -> CompletionItem {\n+        CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), field.to_string())\n+            .kind(CompletionItemKind::Field)\n+            .detail(ty.display(self.ctx.db()).to_string())\n+            .build()\n+    }\n+\n+    fn render_resolution(\n+        self,\n+        local_name: String,\n+        resolution: &ScopeDef,\n+    ) -> Option<CompletionItem> {\n+        use hir::ModuleDef::*;\n+\n+        let completion_kind = match resolution {\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+            _ => CompletionKind::Reference,\n+        };\n+\n+        let kind = match resolution {\n+            ScopeDef::ModuleDef(Function(func)) => {\n+                let item = render_fn(self.ctx, Some(local_name), *func);\n+                return Some(item);\n+            }\n+            ScopeDef::ModuleDef(EnumVariant(var)) => {\n+                let item = render_enum_variant(self.ctx, Some(local_name), *var, None);\n+                return Some(item);\n+            }\n+            ScopeDef::MacroDef(mac) => {\n+                let item = render_macro(self.ctx, local_name, *mac);\n+                return item;\n+            }\n+\n+            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n+            // FIXME: add CompletionItemKind::Union\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n+            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n+            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n+            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n+            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::Local(..) => CompletionItemKind::Binding,\n+            // (does this need its own kind?)\n+            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::Unknown => {\n+                let item = CompletionItem::new(\n+                    CompletionKind::Reference,\n+                    self.ctx.source_range(),\n+                    local_name,\n+                )\n+                .kind(CompletionItemKind::UnresolvedReference)\n+                .build();\n+                return Some(item);\n+            }\n+        };\n+\n+        let docs = self.docs(resolution);\n+\n+        let mut item =\n+            CompletionItem::new(completion_kind, self.ctx.source_range(), local_name.clone());\n+        if let ScopeDef::Local(local) = resolution {\n+            let ty = local.ty(self.ctx.db());\n+            if !ty.is_unknown() {\n+                item = item.detail(ty.display(self.ctx.db()).to_string());\n+            }\n+        };\n+\n+        let mut ref_match = None;\n+        if let ScopeDef::Local(local) = resolution {\n+            if let Some((active_name, active_type)) = self.ctx.active_name_and_type() {\n+                let ty = local.ty(self.ctx.db());\n+                if let Some(score) =\n+                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n+                {\n+                    item = item.set_score(score);\n+                }\n+                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n+            }\n+        }\n+\n+        // Add `<>` for generic types\n+        if self.ctx.completion.is_path_type\n+            && !self.ctx.completion.has_type_args\n+            && self.ctx.completion.config.add_call_parenthesis\n+        {\n+            if let Some(cap) = self.ctx.snippet_cap() {\n+                let has_non_default_type_params = match resolution {\n+                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(self.ctx.db()),\n+                    ScopeDef::ModuleDef(TypeAlias(it)) => {\n+                        it.has_non_default_type_params(self.ctx.db())\n+                    }\n+                    _ => false,\n+                };\n+                if has_non_default_type_params {\n+                    mark::hit!(inserts_angle_brackets_for_generics);\n+                    item = item\n+                        .lookup_by(local_name.clone())\n+                        .label(format!(\"{}<\u2026>\", local_name))\n+                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n+                }\n+            }\n+        }\n+\n+        let item = item.kind(kind).set_documentation(docs).set_ref_match(ref_match).build();\n+        Some(item)\n+    }\n+\n+    fn docs(&self, resolution: &ScopeDef) -> Option<Documentation> {\n+        use hir::ModuleDef::*;\n+        match resolution {\n+            ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n+            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+fn compute_score_from_active(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<CompletionScore> {\n+    // Compute score\n+    // For the same type\n+    if active_type != ty {\n+        return None;\n+    }\n+\n+    let mut res = CompletionScore::TypeMatch;\n+\n+    // If same type + same name then go top position\n+    if active_name == name {\n+        res = CompletionScore::TypeAndNameMatch\n+    }\n+\n+    Some(res)\n+}\n+fn refed_type_matches(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<(Mutability, CompletionScore)> {\n+    let derefed_active = active_type.remove_ref()?;\n+    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n+    Some((\n+        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n+        score,\n+    ))\n+}\n+\n+fn compute_score(ctx: &RenderContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n+    let (active_name, active_type) = ctx.active_name_and_type()?;\n+    compute_score_from_active(&active_type, &active_name, ty, name)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::cmp::Reverse;\n+\n+    use expect_test::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        test_utils::{check_edit, do_completion, get_all_items},\n+        CompletionConfig, CompletionKind, CompletionScore,\n+    };\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n+        expect.assert_debug_eq(&actual);\n+    }\n+\n+    fn check_scores(ra_fixture: &str, expect: Expect) {\n+        fn display_score(score: Option<CompletionScore>) -> &'static str {\n+            match score {\n+                Some(CompletionScore::TypeMatch) => \"[type]\",\n+                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n+                None => \"[]\".into(),\n+            }\n+        }\n+\n+        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n+        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n+        let actual = completions\n+            .into_iter()\n+            .filter(|it| it.completion_kind == CompletionKind::Reference)\n+            .map(|it| {\n+                let tag = it.kind().unwrap().tag();\n+                let score = display_score(it.score());\n+                format!(\"{} {} {}\\n\", tag, it.label(), score)\n+            })\n+            .collect::<String>();\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn enum_detail_includes_record_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo { x: i32, y: i32 } }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 54..56,\n+                        delete: 54..56,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"{ x: i32, y: i32 }\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_doesnt_include_tuple_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo (i32, i32) }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo(\u2026)\",\n+                        source_range: 46..48,\n+                        delete: 46..48,\n+                        insert: \"Foo($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Foo\",\n+                        detail: \"(i32, i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_just_parentheses_for_unit() {\n+        check(\n+            r#\"\n+enum Foo { Foo }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 35..37,\n+                        delete: 35..37,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn lookup_enums_by_two_qualifiers() {\n+        check(\n+            r#\"\n+mod m {\n+    pub enum Spam { Foo, Bar(i32) }\n+}\n+fn main() { let _: m::Spam = S<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Spam::Bar(\u2026)\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"Spam::Bar($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Bar\",\n+                        detail: \"(i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"m\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m\",\n+                        kind: Module,\n+                    },\n+                    CompletionItem {\n+                        label: \"m::Spam::Foo\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m::Spam::Foo\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Foo\",\n+                        detail: \"()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn sets_deprecated_flag_in_items() {\n+        check(\n+            r#\"\n+#[deprecated]\n+fn something_deprecated() {}\n+#[deprecated(since = \"1.0.0\")]\n+fn something_else_deprecated() {}\n+\n+fn main() { som<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"something_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_deprecated\",\n+                        detail: \"fn something_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"something_else_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_else_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_else_deprecated\",\n+                        detail: \"fn something_else_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+struct A { #[deprecated] the_field: u32 }\n+fn foo() { A { the<|> } }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_field\",\n+                        source_range: 57..60,\n+                        delete: 57..60,\n+                        insert: \"the_field\",\n+                        kind: Field,\n+                        detail: \"u32\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn renders_docs() {\n+        check(\n+            r#\"\n+struct S {\n+    /// Field docs\n+    foo:\n+}\n+impl S {\n+    /// Method docs\n+    fn bar(self) { self.<|> }\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"bar()\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"bar()$0\",\n+                        kind: Method,\n+                        lookup: \"bar\",\n+                        detail: \"fn bar(self)\",\n+                        documentation: Documentation(\n+                            \"Method docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"foo\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"foo\",\n+                        kind: Field,\n+                        detail: \"{unknown}\",\n+                        documentation: Documentation(\n+                            \"Field docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+use self::my<|>;\n+\n+/// mod docs\n+mod my { }\n+\n+/// enum docs\n+enum E {\n+    /// variant docs\n+    V\n+}\n+use self::E::*;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"E\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"E\",\n+                        kind: Enum,\n+                        documentation: Documentation(\n+                            \"enum docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"V\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"V\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                        documentation: Documentation(\n+                            \"variant docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"my\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"my\",\n+                        kind: Module,\n+                        documentation: Documentation(\n+                            \"mod docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_render_attrs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    #[inline]\n+    fn the_method(&self) { }\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_method()\",\n+                        source_range: 81..81,\n+                        delete: 81..81,\n+                        insert: \"the_method()$0\",\n+                        kind: Method,\n+                        lookup: \"the_method\",\n+                        detail: \"fn the_method(&self)\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn no_call_parens_if_fn_ptr_needed() {\n+        mark::check!(no_call_parens_if_fn_ptr_needed);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: f<|> }\n+}\n+\"#,\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: foo }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_use_item() {\n+        mark::check!(no_parens_in_use_item);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::f<|>;\n+\"#,\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_call() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { f<|>(); }\n+\"#,\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { foo(); }\n+\"#,\n+        );\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.f<|>(); }\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.foo(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inserts_angle_brackets_for_generics() {\n+        mark::check!(inserts_angle_brackets_for_generics);\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Vec)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|><i128>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<i128>)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn active_param_score() {\n+        mark::check!(active_param_type_match);\n+        check_scores(\n+            r#\"\n+struct S { foo: i64, bar: u32, baz: u32 }\n+fn test(bar: u32) { }\n+fn foo(s: S) { test(s.<|>) }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_field_scores() {\n+        mark::check!(record_field_type_match);\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn foo(a: A) { B { bar: a.<|> }; }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn record_field_and_call_scores() {\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { B { bar: f(a.<|>) }; }\n+\"#,\n+            expect![[r#\"\n+                fd foo [type+name]\n+                fd bar []\n+                fd baz []\n+            \"#]],\n+        );\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { f(B { bar: a.<|> }); }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn prioritize_exact_ref_match() {\n+        check_scores(\n+            r#\"\n+struct WorldSnapshot { _f: () };\n+fn go(world: &WorldSnapshot) { go(w<|>) }\n+\"#,\n+            expect![[r#\"\n+                bn world [type+name]\n+                st WorldSnapshot []\n+                fn go(\u2026) []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_arguments() {\n+        check_scores(\n+            r#\"\n+struct Foo;\n+fn f(foo: &Foo) { f(foo, w<|>) }\n+\"#,\n+            expect![[r#\"\n+                st Foo []\n+                fn f(\u2026) []\n+                bn foo []\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "37b0d0459a63f011c76e312db0311dac08f9ecda", "filename": "crates/completion/src/render/builder_ext.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,94 @@\n+//! Extensions for `Builder` structure required for item rendering.\n+\n+use itertools::Itertools;\n+use test_utils::mark;\n+\n+use crate::{item::Builder, CompletionContext};\n+\n+pub(super) enum Params {\n+    Named(Vec<String>),\n+    Anonymous(usize),\n+}\n+\n+impl Params {\n+    pub(super) fn len(&self) -> usize {\n+        match self {\n+            Params::Named(xs) => xs.len(),\n+            Params::Anonymous(len) => *len,\n+        }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n+impl Builder {\n+    pub(super) fn should_add_parems(&self, ctx: &CompletionContext) -> bool {\n+        if !ctx.config.add_call_parenthesis {\n+            return false;\n+        }\n+        if ctx.use_item_syntax.is_some() {\n+            mark::hit!(no_parens_in_use_item);\n+            return false;\n+        }\n+        if ctx.is_pattern_call {\n+            mark::hit!(dont_duplicate_pattern_parens);\n+            return false;\n+        }\n+        if ctx.is_call {\n+            return false;\n+        }\n+\n+        // Don't add parentheses if the expected type is some function reference.\n+        if let Some(ty) = &ctx.expected_type {\n+            if ty.is_fn() {\n+                mark::hit!(no_call_parens_if_fn_ptr_needed);\n+                return false;\n+            }\n+        }\n+\n+        // Nothing prevents us from adding parentheses\n+        true\n+    }\n+\n+    pub(super) fn add_call_parens(\n+        mut self,\n+        ctx: &CompletionContext,\n+        name: String,\n+        params: Params,\n+    ) -> Builder {\n+        if !self.should_add_parems(ctx) {\n+            return self;\n+        }\n+\n+        let cap = match ctx.config.snippet_cap {\n+            Some(it) => it,\n+            None => return self,\n+        };\n+        // If not an import, add parenthesis automatically.\n+        mark::hit!(inserts_parens_for_function_calls);\n+\n+        let (snippet, label) = if params.is_empty() {\n+            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n+        } else {\n+            self = self.trigger_call_info();\n+            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n+                (true, Params::Named(params)) => {\n+                    let function_params_snippet =\n+                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n+                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n+                        });\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+                _ => {\n+                    mark::hit!(suppress_arg_snippets);\n+                    format!(\"{}($0)\", name)\n+                }\n+            };\n+\n+            (snippet, format!(\"{}(\u2026)\", name))\n+        };\n+        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n+    }\n+}"}, {"sha": "039bdabc051ac7adf7b7d1ec32b6915b1e64f10d", "filename": "crates/completion/src/render/const_.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fconst_.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,55 @@\n+//! Renderer for `const` fields.\n+\n+use hir::HasSource;\n+use syntax::{\n+    ast::{Const, NameOwner},\n+    display::const_label,\n+};\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::RenderContext,\n+};\n+\n+pub(crate) fn render_const<'a>(\n+    ctx: RenderContext<'a>,\n+    const_: hir::Const,\n+) -> Option<CompletionItem> {\n+    ConstRender::new(ctx, const_).render()\n+}\n+\n+#[derive(Debug)]\n+struct ConstRender<'a> {\n+    ctx: RenderContext<'a>,\n+    const_: hir::Const,\n+    ast_node: Const,\n+}\n+\n+impl<'a> ConstRender<'a> {\n+    fn new(ctx: RenderContext<'a>, const_: hir::Const) -> ConstRender<'a> {\n+        let ast_node = const_.source(ctx.db()).value;\n+        ConstRender { ctx, const_, ast_node }\n+    }\n+\n+    fn render(self) -> Option<CompletionItem> {\n+        let name = self.name()?;\n+        let detail = self.detail();\n+\n+        let item = CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name)\n+            .kind(CompletionItemKind::Const)\n+            .set_documentation(self.ctx.docs(self.const_))\n+            .set_deprecated(self.ctx.is_deprecated(self.const_))\n+            .detail(detail)\n+            .build();\n+\n+        Some(item)\n+    }\n+\n+    fn name(&self) -> Option<String> {\n+        self.ast_node.name().map(|name| name.text().to_string())\n+    }\n+\n+    fn detail(&self) -> String {\n+        const_label(&self.ast_node)\n+    }\n+}"}, {"sha": "fd412ed0eef881f348f4d3b36a0a5016767eb834", "filename": "crates/completion/src/render/enum_variant.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,180 @@\n+//! Renderer for `enum` variants.\n+\n+use hir::{HasAttrs, HirDisplay, ModPath, StructKind};\n+use itertools::Itertools;\n+use test_utils::mark;\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::{builder_ext::Params, RenderContext},\n+};\n+\n+pub(crate) fn render_enum_variant<'a>(\n+    ctx: RenderContext<'a>,\n+    local_name: Option<String>,\n+    variant: hir::EnumVariant,\n+    path: Option<ModPath>,\n+) -> CompletionItem {\n+    EnumVariantRender::new(ctx, local_name, variant, path).render()\n+}\n+\n+#[derive(Debug)]\n+struct EnumVariantRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    variant: hir::EnumVariant,\n+    path: Option<ModPath>,\n+    qualified_name: String,\n+    short_qualified_name: String,\n+    variant_kind: StructKind,\n+}\n+\n+impl<'a> EnumVariantRender<'a> {\n+    fn new(\n+        ctx: RenderContext<'a>,\n+        local_name: Option<String>,\n+        variant: hir::EnumVariant,\n+        path: Option<ModPath>,\n+    ) -> EnumVariantRender<'a> {\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()).to_string());\n+        let variant_kind = variant.kind(ctx.db());\n+\n+        let (qualified_name, short_qualified_name) = match &path {\n+            Some(path) => {\n+                let full = path.to_string();\n+                let short =\n+                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n+                (full, short)\n+            }\n+            None => (name.to_string(), name.to_string()),\n+        };\n+\n+        EnumVariantRender {\n+            ctx,\n+            name,\n+            variant,\n+            path,\n+            qualified_name,\n+            short_qualified_name,\n+            variant_kind,\n+        }\n+    }\n+\n+    fn render(self) -> CompletionItem {\n+        let mut builder = CompletionItem::new(\n+            CompletionKind::Reference,\n+            self.ctx.source_range(),\n+            self.qualified_name.clone(),\n+        )\n+        .kind(CompletionItemKind::EnumVariant)\n+        .set_documentation(self.variant.docs(self.ctx.db()))\n+        .set_deprecated(self.ctx.is_deprecated(self.variant))\n+        .detail(self.detail());\n+\n+        if self.variant_kind == StructKind::Tuple {\n+            mark::hit!(inserts_parens_for_tuple_enums);\n+            let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n+            builder =\n+                builder.add_call_parens(self.ctx.completion, self.short_qualified_name, params);\n+        } else if self.path.is_some() {\n+            builder = builder.lookup_by(self.short_qualified_name);\n+        }\n+\n+        builder.build()\n+    }\n+\n+    fn detail(&self) -> String {\n+        let detail_types = self\n+            .variant\n+            .fields(self.ctx.db())\n+            .into_iter()\n+            .map(|field| (field.name(self.ctx.db()), field.signature_ty(self.ctx.db())));\n+\n+        match self.variant_kind {\n+            StructKind::Tuple | StructKind::Unit => format!(\n+                \"({})\",\n+                detail_types.map(|(_, t)| t.display(self.ctx.db()).to_string()).format(\", \")\n+            ),\n+            StructKind::Record => format!(\n+                \"{{ {} }}\",\n+                detail_types\n+                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(self.ctx.db()).to_string()))\n+                    .format(\", \")\n+            ),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::test_utils::check_edit;\n+\n+    #[test]\n+    fn inserts_parens_for_tuple_enums() {\n+        mark::check!(inserts_parens_for_tuple_enums);\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Som<|>\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Some($0)\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Som<|>\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Some($0)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_duplicate_pattern_parens() {\n+        mark::check!(dont_duplicate_pattern_parens);\n+        check_edit(\n+            \"Var\",\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::<|>(92) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::Var(92) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "4fa6eafd72f6f8d83ac64e9bc580df1471385d4e", "filename": "crates/completion/src/render/function.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,303 @@\n+//! Renderer for function calls.\n+\n+use hir::{HasSource, Type};\n+use syntax::{ast::Fn, display::function_declaration};\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::{builder_ext::Params, RenderContext},\n+};\n+\n+pub(crate) fn render_fn<'a>(\n+    ctx: RenderContext<'a>,\n+    local_name: Option<String>,\n+    fn_: hir::Function,\n+) -> CompletionItem {\n+    FunctionRender::new(ctx, local_name, fn_).render()\n+}\n+\n+#[derive(Debug)]\n+struct FunctionRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    fn_: hir::Function,\n+    ast_node: Fn,\n+}\n+\n+impl<'a> FunctionRender<'a> {\n+    fn new(\n+        ctx: RenderContext<'a>,\n+        local_name: Option<String>,\n+        fn_: hir::Function,\n+    ) -> FunctionRender<'a> {\n+        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()).to_string());\n+        let ast_node = fn_.source(ctx.db()).value;\n+\n+        FunctionRender { ctx, name, fn_, ast_node }\n+    }\n+\n+    fn render(self) -> CompletionItem {\n+        let params = self.params();\n+        CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), self.name.clone())\n+            .kind(self.kind())\n+            .set_documentation(self.ctx.docs(self.fn_))\n+            .set_deprecated(self.ctx.is_deprecated(self.fn_))\n+            .detail(self.detail())\n+            .add_call_parens(self.ctx.completion, self.name, params)\n+            .build()\n+    }\n+\n+    fn detail(&self) -> String {\n+        function_declaration(&self.ast_node)\n+    }\n+\n+    fn add_arg(&self, arg: &str, ty: &Type) -> String {\n+        if let Some(derefed_ty) = ty.remove_ref() {\n+            for (name, local) in self.ctx.completion.locals.iter() {\n+                if name == arg && local.ty(self.ctx.db()) == derefed_ty {\n+                    let mutability = if ty.is_mutable_reference() { \"&mut \" } else { \"&\" };\n+                    return format!(\"{}{}\", mutability, arg);\n+                }\n+            }\n+        }\n+        arg.to_string()\n+    }\n+\n+    fn params(&self) -> Params {\n+        let params_ty = self.fn_.params(self.ctx.db());\n+        let params = self\n+            .ast_node\n+            .param_list()\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .zip(params_ty)\n+            .flat_map(|(it, param_ty)| {\n+                if let Some(pat) = it.pat() {\n+                    let name = pat.to_string();\n+                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n+                    return Some(self.add_arg(arg, param_ty.ty()));\n+                }\n+                None\n+            })\n+            .collect();\n+        Params::Named(params)\n+    }\n+\n+    fn kind(&self) -> CompletionItemKind {\n+        if self.fn_.self_param(self.ctx.db()).is_some() {\n+            CompletionItemKind::Method\n+        } else {\n+            CompletionItemKind::Function\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::{\n+        test_utils::{check_edit, check_edit_with_config},\n+        CompletionConfig,\n+    };\n+\n+    #[test]\n+    fn inserts_parens_for_function_calls() {\n+        mark::check!(inserts_parens_for_function_calls);\n+        check_edit(\n+            \"no_args\",\n+            r#\"\n+fn no_args() {}\n+fn main() { no_<|> }\n+\"#,\n+            r#\"\n+fn no_args() {}\n+fn main() { no_args()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args(${1:x}, ${2:y})$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.f<|> }\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.foo()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.f<|>\n+}\n+\"#,\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.foo(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn suppress_arg_snippets() {\n+        mark::check!(suppress_arg_snippets);\n+        check_edit_with_config(\n+            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args($0) }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strips_underscores_from_args() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { f<|> }\n+\"#,\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_mut_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&mut x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope_for_method() {\n+        check_edit(\n+            \"apply_foo\",\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.apply_foo(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trim_mut_keyword_in_func_completion() {\n+        check_edit(\n+            \"take_mutably\",\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_m<|>\n+}\n+\"#,\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_mutably(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "96be59cc336aeda40e1b3865b6ce8a0c60c691a9", "filename": "crates/completion/src/render/macro_.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,216 @@\n+//! Renderer for macro invocations.\n+\n+use hir::{Documentation, HasSource};\n+use syntax::display::macro_label;\n+use test_utils::mark;\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::RenderContext,\n+};\n+\n+pub(crate) fn render_macro<'a>(\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    macro_: hir::MacroDef,\n+) -> Option<CompletionItem> {\n+    MacroRender::new(ctx, name, macro_).render()\n+}\n+\n+#[derive(Debug)]\n+struct MacroRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    macro_: hir::MacroDef,\n+    docs: Option<Documentation>,\n+    bra: &'static str,\n+    ket: &'static str,\n+}\n+\n+impl<'a> MacroRender<'a> {\n+    fn new(ctx: RenderContext<'a>, name: String, macro_: hir::MacroDef) -> MacroRender<'a> {\n+        let docs = ctx.docs(macro_);\n+        let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n+        let (bra, ket) = guess_macro_braces(&name, docs_str);\n+\n+        MacroRender { ctx, name, macro_, docs, bra, ket }\n+    }\n+\n+    fn render(&self) -> Option<CompletionItem> {\n+        // FIXME: Currently proc-macro do not have ast-node,\n+        // such that it does not have source\n+        if self.macro_.is_proc_macro() {\n+            return None;\n+        }\n+\n+        let mut builder =\n+            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), &self.label())\n+                .kind(CompletionItemKind::Macro)\n+                .set_documentation(self.docs.clone())\n+                .set_deprecated(self.ctx.is_deprecated(self.macro_))\n+                .detail(self.detail());\n+\n+        let needs_bang = self.needs_bang();\n+        builder = match self.ctx.snippet_cap() {\n+            Some(cap) if needs_bang => {\n+                let snippet = self.snippet();\n+                let lookup = self.lookup();\n+                builder.insert_snippet(cap, snippet).lookup_by(lookup)\n+            }\n+            None if needs_bang => builder.insert_text(self.banged_name()),\n+            _ => {\n+                mark::hit!(dont_insert_macro_call_parens_unncessary);\n+                builder.insert_text(&self.name)\n+            }\n+        };\n+\n+        Some(builder.build())\n+    }\n+\n+    fn needs_bang(&self) -> bool {\n+        self.ctx.completion.use_item_syntax.is_none() && !self.ctx.completion.is_macro_call\n+    }\n+\n+    fn label(&self) -> String {\n+        if self.needs_bang() && self.ctx.snippet_cap().is_some() {\n+            format!(\"{}!{}\u2026{}\", self.name, self.bra, self.ket)\n+        } else {\n+            self.banged_name()\n+        }\n+    }\n+\n+    fn snippet(&self) -> String {\n+        format!(\"{}!{}$0{}\", self.name, self.bra, self.ket)\n+    }\n+\n+    fn lookup(&self) -> String {\n+        self.banged_name()\n+    }\n+\n+    fn banged_name(&self) -> String {\n+        format!(\"{}!\", self.name)\n+    }\n+\n+    fn detail(&self) -> String {\n+        let ast_node = self.macro_.source(self.ctx.db()).value;\n+        macro_label(&ast_node)\n+    }\n+}\n+\n+fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n+    let mut votes = [0, 0, 0];\n+    for (idx, s) in docs.match_indices(&macro_name) {\n+        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n+        // Ensure to match the full word\n+        if after.starts_with('!')\n+            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n+        {\n+            // It may have spaces before the braces like `foo! {}`\n+            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n+                Some('{') => votes[0] += 1,\n+                Some('[') => votes[1] += 1,\n+                Some('(') => votes[2] += 1,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    // Insert a space before `{}`.\n+    // We prefer the last one when some votes equal.\n+    let (_vote, (bra, ket)) = votes\n+        .iter()\n+        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n+        .max_by_key(|&(&vote, _)| vote)\n+        .unwrap();\n+    (*bra, *ket)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::test_utils::check_edit;\n+\n+    #[test]\n+    fn dont_insert_macro_call_parens_unncessary() {\n+        mark::check!(dont_insert_macro_call_parens_unncessary);\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::<|>;\n+//- /foo/lib.rs crate:foo\n+#[macro_export]\n+macro_rules frobnicate { () => () }\n+\"#,\n+            r#\"\n+use foo::frobnicate;\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frob<|>!(); }\n+\"#,\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frobnicate!(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_macro_braces() {\n+        check_edit(\n+            \"vec!\",\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { v<|> }\n+\"#,\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { vec![$0] }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo!\",\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { <|> }\n+\"#,\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { foo! {$0} }\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "9605c7fa9424b3fb0e9b7564c30c59caf10c0228", "filename": "crates/completion/src/render/type_alias.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c7f35effe1a4602ba02baf9ff67a4eb214818f/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ftype_alias.rs?ref=07c7f35effe1a4602ba02baf9ff67a4eb214818f", "patch": "@@ -0,0 +1,55 @@\n+//! Renderer for type aliases.\n+\n+use hir::HasSource;\n+use syntax::{\n+    ast::{NameOwner, TypeAlias},\n+    display::type_label,\n+};\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::RenderContext,\n+};\n+\n+pub(crate) fn render_type_alias<'a>(\n+    ctx: RenderContext<'a>,\n+    type_alias: hir::TypeAlias,\n+) -> Option<CompletionItem> {\n+    TypeAliasRender::new(ctx, type_alias).render()\n+}\n+\n+#[derive(Debug)]\n+struct TypeAliasRender<'a> {\n+    ctx: RenderContext<'a>,\n+    type_alias: hir::TypeAlias,\n+    ast_node: TypeAlias,\n+}\n+\n+impl<'a> TypeAliasRender<'a> {\n+    fn new(ctx: RenderContext<'a>, type_alias: hir::TypeAlias) -> TypeAliasRender<'a> {\n+        let ast_node = type_alias.source(ctx.db()).value;\n+        TypeAliasRender { ctx, type_alias, ast_node }\n+    }\n+\n+    fn render(self) -> Option<CompletionItem> {\n+        let name = self.name()?;\n+        let detail = self.detail();\n+\n+        let item = CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name)\n+            .kind(CompletionItemKind::TypeAlias)\n+            .set_documentation(self.ctx.docs(self.type_alias))\n+            .set_deprecated(self.ctx.is_deprecated(self.type_alias))\n+            .detail(detail)\n+            .build();\n+\n+        Some(item)\n+    }\n+\n+    fn name(&self) -> Option<String> {\n+        self.ast_node.name().map(|name| name.text().to_string())\n+    }\n+\n+    fn detail(&self) -> String {\n+        type_label(&self.ast_node)\n+    }\n+}"}]}