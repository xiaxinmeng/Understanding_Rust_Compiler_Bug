{"sha": "8cef65fde3f92a84218fc338de6ab967fafd1820", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZWY2NWZkZTNmOTJhODQyMThmYzMzOGRlNmFiOTY3ZmFmZDE4MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T23:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T23:43:20Z"}, "message": "Auto merge of #77801 - fusion-engineering-forks:pin-mutex, r=Mark-Simulacrum\n\nEnforce no-move rule of ReentrantMutex using Pin and fix UB in stdio\n\nA `sys_common::ReentrantMutex` may not be moved after initializing it with `.init()`. This was not enforced, but only stated as a requirement in the comments on the unsafe functions. This change enforces this no-moving rule using `Pin`, by changing `&self` to a `Pin` in the `init()` and `lock()` functions.\n\nThis uncovered a bug I introduced in #77154: stdio.rs (the only user of ReentrantMutex) called `init()` on its ReentrantMutexes while constructing them in the intializer of `SyncOnceCell::get_or_init`, which would move them afterwards. Interestingly, the ReentrantMutex unit tests already had the same bug, so this invalid usage has been tested on all (CI-tested) platforms for a long time. Apparently this doesn't break badly on any of the major platforms, but it does break the rules.\\*\n\nTo be able to keep using SyncOnceCell, this adds a `SyncOnceCell::get_or_init_pin` function, which makes it possible to work with pinned values inside a (pinned) SyncOnceCell. Whether this function should be public or not and what its exact behaviour and interface should be if it would be public is something I'd like to leave for a separate issue or PR. In this PR, this function is internal-only and marked with `pub(crate)`.\n\n\\* Note: That bug is now included in 1.48, while this patch can only make it to ~~1.49~~ 1.50. We should consider the implications of 1.48 shipping with a wrong usage of `pthread_mutex_t` / `CRITICAL_SECTION` / .. which technically invokes UB according to their specification. The risk is very low, considering the objects are not 'used' (locked) before the move, and the ReentrantMutex unit tests have verified this works fine in practice.\n\nEdit: This has been backported and included in 1.48. And soon 1.49 too.\n\n---\n\nIn future changes, I want to push this usage of Pin further inside `sys` instead of only `sys_common`, and apply it to all 'unmovable' objects there (`Mutex`, `Condvar`, `RwLock`). Also, while `sys_common`'s mutexes and condvars are already taken care of by #77147 and #77648, its `RwLock` should still be made movable or get pinned.", "tree": {"sha": "010ae7656cedae44211a7ae5187c3e45df3451d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/010ae7656cedae44211a7ae5187c3e45df3451d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cef65fde3f92a84218fc338de6ab967fafd1820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cef65fde3f92a84218fc338de6ab967fafd1820", "html_url": "https://github.com/rust-lang/rust/commit/8cef65fde3f92a84218fc338de6ab967fafd1820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cef65fde3f92a84218fc338de6ab967fafd1820/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32c320d7eee56706486fef6be778495303afe9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d32c320d7eee56706486fef6be778495303afe9e", "html_url": "https://github.com/rust-lang/rust/commit/d32c320d7eee56706486fef6be778495303afe9e"}, {"sha": "67c18fdec59cf313818b8606c3847a8af6bcf684", "url": "https://api.github.com/repos/rust-lang/rust/commits/67c18fdec59cf313818b8606c3847a8af6bcf684", "html_url": "https://github.com/rust-lang/rust/commit/67c18fdec59cf313818b8606c3847a8af6bcf684"}], "stats": {"total": 211, "additions": 129, "deletions": 82}, "files": [{"sha": "1160011f352875514d15687f05c3fd75d117292f", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=8cef65fde3f92a84218fc338de6ab967fafd1820", "patch": "@@ -9,6 +9,7 @@ use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n+use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n@@ -490,7 +491,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: &'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>,\n+    inner: Pin<&'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n }\n \n /// A locked reference to the `Stdout` handle.\n@@ -550,25 +551,29 @@ pub struct StdoutLock<'a> {\n pub fn stdout() -> Stdout {\n     static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> =\n         SyncOnceCell::new();\n+\n+    fn cleanup() {\n+        if let Some(instance) = INSTANCE.get() {\n+            // Flush the data and disable buffering during shutdown\n+            // by replacing the line writer by one with zero\n+            // buffering capacity.\n+            // We use try_lock() instead of lock(), because someone\n+            // might have leaked a StdoutLock, which would\n+            // otherwise cause a deadlock here.\n+            if let Some(lock) = Pin::static_ref(instance).try_lock() {\n+                *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+            }\n+        }\n+    }\n+\n     Stdout {\n-        inner: INSTANCE.get_or_init(|| unsafe {\n-            let _ = sys_common::at_exit(|| {\n-                if let Some(instance) = INSTANCE.get() {\n-                    // Flush the data and disable buffering during shutdown\n-                    // by replacing the line writer by one with zero\n-                    // buffering capacity.\n-                    // We use try_lock() instead of lock(), because someone\n-                    // might have leaked a StdoutLock, which would\n-                    // otherwise cause a deadlock here.\n-                    if let Some(lock) = instance.try_lock() {\n-                        *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n-                    }\n-                }\n-            });\n-            let r = ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())));\n-            r.init();\n-            r\n-        }),\n+        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n+            || unsafe {\n+                let _ = sys_common::at_exit(cleanup);\n+                ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())))\n+            },\n+            |mutex| unsafe { mutex.init() },\n+        ),\n     }\n }\n \n@@ -700,7 +705,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: &'static ReentrantMutex<RefCell<StderrRaw>>,\n+    inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n@@ -756,21 +761,16 @@ pub struct StderrLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    // Note that unlike `stdout()` we don't use `Lazy` here which registers a\n-    // destructor. Stderr is not buffered nor does the `stderr_raw` type consume\n-    // any owned resources, so there's no need to run any destructors at some\n-    // point in the future.\n-    //\n-    // This has the added benefit of allowing `stderr` to be usable during\n-    // process shutdown as well!\n+    // Note that unlike `stdout()` we don't use `at_exit` here to register a\n+    // destructor. Stderr is not buffered , so there's no need to run a\n+    // destructor for flushing the buffer\n     static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n \n     Stderr {\n-        inner: INSTANCE.get_or_init(|| unsafe {\n-            let r = ReentrantMutex::new(RefCell::new(stderr_raw()));\n-            r.init();\n-            r\n-        }),\n+        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n+            || unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) },\n+            |mutex| unsafe { mutex.init() },\n+        ),\n     }\n }\n "}, {"sha": "68f57958bb233c5c8f39eaca8de07ad67135674d", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=8cef65fde3f92a84218fc338de6ab967fafd1820", "patch": "@@ -10,6 +10,7 @@ use crate::{\n     mem::MaybeUninit,\n     ops::{Deref, Drop},\n     panic::{RefUnwindSafe, UnwindSafe},\n+    pin::Pin,\n     sync::Once,\n };\n \n@@ -297,6 +298,60 @@ impl<T> SyncOnceCell<T> {\n         Ok(unsafe { self.get_unchecked() })\n     }\n \n+    /// Internal-only API that gets the contents of the cell, initializing it\n+    /// in two steps with `f` and `g` if the cell was empty.\n+    ///\n+    /// `f` is called to construct the value, which is then moved into the cell\n+    /// and given as a (pinned) mutable reference to `g` to finish\n+    /// initialization.\n+    ///\n+    /// This allows `g` to inspect an manipulate the value after it has been\n+    /// moved into its final place in the cell, but before the cell is\n+    /// considered initialized.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` or `g` panics, the panic is propagated to the caller, and the\n+    /// cell remains uninitialized.\n+    ///\n+    /// With the current implementation, if `g` panics, the value from `f` will\n+    /// not be dropped. This should probably be fixed if this is ever used for\n+    /// a type where this matters.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The exact\n+    /// outcome is unspecified. Current implementation deadlocks, but this may\n+    /// be changed to a panic in the future.\n+    pub(crate) fn get_or_init_pin<F, G>(self: Pin<&Self>, f: F, g: G) -> Pin<&T>\n+    where\n+        F: FnOnce() -> T,\n+        G: FnOnce(Pin<&mut T>),\n+    {\n+        if let Some(value) = self.get_ref().get() {\n+            // SAFETY: The inner value was already initialized, and will not be\n+            // moved anymore.\n+            return unsafe { Pin::new_unchecked(value) };\n+        }\n+\n+        let slot = &self.value;\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|_| {\n+            let value = f();\n+            // SAFETY: We use the Once (self.once) to guarantee unique access\n+            // to the UnsafeCell (slot).\n+            let value: &mut T = unsafe { (&mut *slot.get()).write(value) };\n+            // SAFETY: The value has been written to its final place in\n+            // self.value. We do not to move it anymore, which we promise here\n+            // with a Pin<&mut T>.\n+            g(unsafe { Pin::new_unchecked(value) });\n+        });\n+\n+        // SAFETY: The inner value has been initialized, and will not be moved\n+        // anymore.\n+        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }\n+    }\n+\n     /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n     /// `None` if the cell was empty.\n     ///"}, {"sha": "def8db1f45c37fb3a6b7c88e15ab028216342cf3", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8cef65fde3f92a84218fc338de6ab967fafd1820", "patch": "@@ -266,6 +266,7 @@\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n #![feature(generator_trait)]\n+#![feature(get_mut_unchecked)]\n #![feature(global_asm)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n@@ -293,6 +294,7 @@\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n+#![feature(pin_static_ref)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]"}, {"sha": "475bfca9b6dcccc7ccb27ee31735e8306143d06c", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=8cef65fde3f92a84218fc338de6ab967fafd1820", "patch": "@@ -1,10 +1,10 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::fmt;\n-use crate::marker;\n+use crate::marker::PhantomPinned;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::pin::Pin;\n use crate::sys::mutex as sys;\n \n /// A re-entrant mutual exclusion\n@@ -15,6 +15,7 @@ use crate::sys::mutex as sys;\n pub struct ReentrantMutex<T> {\n     inner: sys::ReentrantMutex,\n     data: T,\n+    _pinned: PhantomPinned,\n }\n \n unsafe impl<T: Send> Send for ReentrantMutex<T> {}\n@@ -37,10 +38,10 @@ impl<T> RefUnwindSafe for ReentrantMutex<T> {}\n /// guarded data.\n #[must_use = \"if unused the ReentrantMutex will immediately unlock\"]\n pub struct ReentrantMutexGuard<'a, T: 'a> {\n-    lock: &'a ReentrantMutex<T>,\n+    lock: Pin<&'a ReentrantMutex<T>>,\n }\n \n-impl<T> !marker::Send for ReentrantMutexGuard<'_, T> {}\n+impl<T> !Send for ReentrantMutexGuard<'_, T> {}\n \n impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n@@ -51,7 +52,11 @@ impl<T> ReentrantMutex<T> {\n     /// once this mutex is in its final resting place, and only then are the\n     /// lock/unlock methods safe.\n     pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n-        ReentrantMutex { inner: sys::ReentrantMutex::uninitialized(), data: t }\n+        ReentrantMutex {\n+            inner: sys::ReentrantMutex::uninitialized(),\n+            data: t,\n+            _pinned: PhantomPinned,\n+        }\n     }\n \n     /// Initializes this mutex so it's ready for use.\n@@ -60,8 +65,8 @@ impl<T> ReentrantMutex<T> {\n     ///\n     /// Unsafe to call more than once, and must be called after this will no\n     /// longer move in memory.\n-    pub unsafe fn init(&self) {\n-        self.inner.init();\n+    pub unsafe fn init(self: Pin<&mut Self>) {\n+        self.get_unchecked_mut().inner.init()\n     }\n \n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n@@ -76,9 +81,9 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {\n+    pub fn lock(self: Pin<&Self>) -> ReentrantMutexGuard<'_, T> {\n         unsafe { self.inner.lock() }\n-        ReentrantMutexGuard::new(&self)\n+        ReentrantMutexGuard { lock: self }\n     }\n \n     /// Attempts to acquire this lock.\n@@ -93,8 +98,12 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {\n-        if unsafe { self.inner.try_lock() } { Some(ReentrantMutexGuard::new(&self)) } else { None }\n+    pub fn try_lock(self: Pin<&Self>) -> Option<ReentrantMutexGuard<'_, T>> {\n+        if unsafe { self.inner.try_lock() } {\n+            Some(ReentrantMutexGuard { lock: self })\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -107,30 +116,6 @@ impl<T> Drop for ReentrantMutex<T> {\n     }\n }\n \n-impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.try_lock() {\n-            Some(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n-            None => {\n-                struct LockedPlaceholder;\n-                impl fmt::Debug for LockedPlaceholder {\n-                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                        f.write_str(\"<locked>\")\n-                    }\n-                }\n-\n-                f.debug_struct(\"ReentrantMutex\").field(\"data\", &LockedPlaceholder).finish()\n-            }\n-        }\n-    }\n-}\n-\n-impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n-    fn new(lock: &'mutex ReentrantMutex<T>) -> ReentrantMutexGuard<'mutex, T> {\n-        ReentrantMutexGuard { lock }\n-    }\n-}\n-\n impl<T> Deref for ReentrantMutexGuard<'_, T> {\n     type Target = T;\n "}, {"sha": "88453ded2f9fb2d310e1ace420194fa4eaf37538", "filename": "library/std/src/sys_common/remutex/tests.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef65fde3f92a84218fc338de6ab967fafd1820/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs?ref=8cef65fde3f92a84218fc338de6ab967fafd1820", "patch": "@@ -1,15 +1,18 @@\n+use crate::boxed::Box;\n use crate::cell::RefCell;\n+use crate::pin::Pin;\n use crate::sync::Arc;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread;\n \n #[test]\n fn smoke() {\n     let m = unsafe {\n-        let m = ReentrantMutex::new(());\n-        m.init();\n+        let mut m = Box::pin(ReentrantMutex::new(()));\n+        m.as_mut().init();\n         m\n     };\n+    let m = m.as_ref();\n     {\n         let a = m.lock();\n         {\n@@ -27,18 +30,19 @@ fn smoke() {\n #[test]\n fn is_mutex() {\n     let m = unsafe {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n-        m.init();\n-        m\n+        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        let mut m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n+        Pin::new_unchecked(m)\n     };\n     let m2 = m.clone();\n-    let lock = m.lock();\n+    let lock = m.as_ref().lock();\n     let child = thread::spawn(move || {\n-        let lock = m2.lock();\n+        let lock = m2.as_ref().lock();\n         assert_eq!(*lock.borrow(), 4950);\n     });\n     for i in 0..100 {\n-        let lock = m.lock();\n+        let lock = m.as_ref().lock();\n         *lock.borrow_mut() += i;\n     }\n     drop(lock);\n@@ -48,20 +52,21 @@ fn is_mutex() {\n #[test]\n fn trylock_works() {\n     let m = unsafe {\n-        let m = Arc::new(ReentrantMutex::new(()));\n-        m.init();\n-        m\n+        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        let mut m = Arc::new(ReentrantMutex::new(()));\n+        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n+        Pin::new_unchecked(m)\n     };\n     let m2 = m.clone();\n-    let _lock = m.try_lock();\n-    let _lock2 = m.try_lock();\n+    let _lock = m.as_ref().try_lock();\n+    let _lock2 = m.as_ref().try_lock();\n     thread::spawn(move || {\n-        let lock = m2.try_lock();\n+        let lock = m2.as_ref().try_lock();\n         assert!(lock.is_none());\n     })\n     .join()\n     .unwrap();\n-    let _lock3 = m.try_lock();\n+    let _lock3 = m.as_ref().try_lock();\n }\n \n pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);"}]}