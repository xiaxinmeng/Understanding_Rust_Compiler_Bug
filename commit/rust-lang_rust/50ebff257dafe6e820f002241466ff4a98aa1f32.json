{"sha": "50ebff257dafe6e820f002241466ff4a98aa1f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZWJmZjI1N2RhZmU2ZTgyMGYwMDIyNDE0NjZmZjRhOThhYTFmMzI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-26T15:00:10Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-26T15:23:40Z"}, "message": "Rename ResolvedVisibility -> Visibility", "tree": {"sha": "5bfcf71964d649edb14b06394ff370c8ef556a5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bfcf71964d649edb14b06394ff370c8ef556a5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ebff257dafe6e820f002241466ff4a98aa1f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ebff257dafe6e820f002241466ff4a98aa1f32", "html_url": "https://github.com/rust-lang/rust/commit/50ebff257dafe6e820f002241466ff4a98aa1f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ebff257dafe6e820f002241466ff4a98aa1f32/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1a2961273bdf7ef24c81f22fe86041a20812365", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a2961273bdf7ef24c81f22fe86041a20812365", "html_url": "https://github.com/rust-lang/rust/commit/e1a2961273bdf7ef24c81f22fe86041a20812365"}], "stats": {"total": 121, "additions": 54, "deletions": 67}, "files": [{"sha": "fdf3167450a51a438900d55853c318c346f36b69", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -118,7 +118,7 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub use hir_def::{attr::Attrs, visibility::ResolvedVisibility};\n+pub use hir_def::{attr::Attrs, visibility::Visibility};\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n@@ -256,7 +256,7 @@ impl StructField {\n }\n \n impl HasVisibility for StructField {\n-    fn visibility(&self, db: &impl HirDatabase) -> ResolvedVisibility {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n         let struct_field_id: hir_def::StructFieldId = (*self).into();\n         let visibility = db.visibility(struct_field_id.into());\n         let parent_id: hir_def::VariantId = self.parent.into();\n@@ -1052,7 +1052,7 @@ impl<T: Into<AttrDef> + Copy> Docs for T {\n }\n \n pub trait HasVisibility {\n-    fn visibility(&self, db: &impl HirDatabase) -> ResolvedVisibility;\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility;\n     fn visible_from(&self, db: &impl HirDatabase, module: Module) -> bool {\n         let vis = self.visibility(db);\n         vis.visible_from(db, module.id)"}, {"sha": "fc3a028e0da25a1428c492c808689c009673c8ee", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -543,7 +543,7 @@ where\n             };\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n-                let vis = crate::visibility::ResolvedVisibility::Public; // FIXME determine correctly\n+                let vis = crate::visibility::Visibility::Public; // FIXME determine correctly\n                 self.body\n                     .item_scope\n                     .push_res(name.as_name(), crate::per_ns::PerNs::from_def(def, vis));"}, {"sha": "fe7bb9779c8a2b36ca62f87e2d53081021267d0f", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -6,8 +6,8 @@ use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    per_ns::PerNs, visibility::ResolvedVisibility, AdtId, BuiltinType, ImplId, MacroDefId,\n-    ModuleDefId, TraitId,\n+    per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n+    TraitId,\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -33,9 +33,7 @@ pub struct ItemScope {\n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), PerNs::types(ty.clone().into(), ResolvedVisibility::Public))\n-        })\n+        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into(), Visibility::Public)))\n         .collect()\n });\n \n@@ -159,7 +157,7 @@ impl ItemScope {\n }\n \n impl PerNs {\n-    pub(crate) fn from_def(def: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+    pub(crate) fn from_def(def: ModuleDefId, v: Visibility) -> PerNs {\n         match def {\n             ModuleDefId::ModuleId(_) => PerNs::types(def, v),\n             ModuleDefId::FunctionId(_) => PerNs::values(def, v),"}, {"sha": "63beaedc58860d33982954648d92366c6d35a757", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     },\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    visibility::ResolvedVisibility,\n+    visibility::Visibility,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n     LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n@@ -109,7 +109,7 @@ struct MacroDirective {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, ResolvedVisibility)>>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n@@ -217,8 +217,8 @@ where\n         if export {\n             self.update(\n                 self.def_map.root,\n-                &[(name, PerNs::macros(macro_, ResolvedVisibility::Public))],\n-                ResolvedVisibility::Public,\n+                &[(name, PerNs::macros(macro_, Visibility::Public))],\n+                Visibility::Public,\n             );\n         }\n     }\n@@ -358,7 +358,7 @@ where\n         let vis = self\n             .def_map\n             .resolve_visibility(self.db, module_id, &directive.import.visibility)\n-            .unwrap_or(ResolvedVisibility::Public);\n+            .unwrap_or(Visibility::Public);\n \n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n@@ -461,12 +461,7 @@ where\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        resolutions: &[(Name, PerNs)],\n-        vis: ResolvedVisibility,\n-    ) {\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)], vis: Visibility) {\n         self.update_recursive(module_id, resolutions, vis, 0)\n     }\n \n@@ -476,7 +471,7 @@ where\n         resolutions: &[(Name, PerNs)],\n         // All resolutions are imported with this visibility; the visibilies in\n         // the `PerNs` values are ignored and overwritten\n-        vis: ResolvedVisibility,\n+        vis: Visibility,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -749,7 +744,7 @@ where\n             .def_collector\n             .def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n-            .unwrap_or(ResolvedVisibility::Public);\n+            .unwrap_or(Visibility::Public);\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n@@ -825,7 +820,7 @@ where\n             .def_collector\n             .def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, vis)\n-            .unwrap_or(ResolvedVisibility::Public);\n+            .unwrap_or(Visibility::Public);\n         self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis)\n     }\n "}, {"sha": "fd6422d60e0fc224fb69a6c5ce4f5b3b9f399598", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    visibility::{RawVisibility, ResolvedVisibility},\n+    visibility::{RawVisibility, Visibility},\n     AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n@@ -64,15 +64,15 @@ impl CrateDefMap {\n     pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n         self.extern_prelude\n             .get(name)\n-            .map_or(PerNs::none(), |&it| PerNs::types(it, ResolvedVisibility::Public))\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public))\n     }\n \n     pub(crate) fn resolve_visibility(\n         &self,\n         db: &impl DefDatabase,\n         original_module: LocalModuleId,\n         visibility: &RawVisibility,\n-    ) -> Option<ResolvedVisibility> {\n+    ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(path) => {\n                 let (result, remaining) =\n@@ -82,14 +82,14 @@ impl CrateDefMap {\n                 }\n                 let types = result.take_types()?;\n                 match types {\n-                    ModuleDefId::ModuleId(m) => Some(ResolvedVisibility::Module(m)),\n+                    ModuleDefId::ModuleId(m) => Some(Visibility::Module(m)),\n                     _ => {\n                         // error: visibility needs to refer to module\n                         None\n                     }\n                 }\n             }\n-            RawVisibility::Public => Some(ResolvedVisibility::Public),\n+            RawVisibility::Public => Some(Visibility::Public),\n         }\n     }\n \n@@ -119,18 +119,18 @@ impl CrateDefMap {\n                     tested_by!(macro_dollar_crate_self);\n                     PerNs::types(\n                         ModuleId { krate: self.krate, local_id: self.root }.into(),\n-                        ResolvedVisibility::Public,\n+                        Visibility::Public,\n                     )\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = ModuleId { krate, local_id: def_map.root };\n                     tested_by!(macro_dollar_crate_other);\n-                    PerNs::types(module.into(), ResolvedVisibility::Public)\n+                    PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n             PathKind::Crate => PerNs::types(\n                 ModuleId { krate: self.krate, local_id: self.root }.into(),\n-                ResolvedVisibility::Public,\n+                Visibility::Public,\n             ),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n@@ -161,7 +161,7 @@ impl CrateDefMap {\n                 if let Some(local_id) = m {\n                     PerNs::types(\n                         ModuleId { krate: self.krate, local_id }.into(),\n-                        ResolvedVisibility::Public,\n+                        Visibility::Public,\n                     )\n                 } else {\n                     log::debug!(\"super path in root module\");\n@@ -176,7 +176,7 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def, ResolvedVisibility::Public)\n+                    PerNs::types(*def, Visibility::Public)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n@@ -225,7 +225,7 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into(), ResolvedVisibility::Public)\n+                            PerNs::both(variant.into(), variant.into(), Visibility::Public)\n                         }\n                         None => {\n                             return ResolvePathResult::with(\n@@ -274,12 +274,12 @@ impl CrateDefMap {\n         let from_legacy_macro = self[module]\n             .scope\n             .get_legacy_macro(name)\n-            .map_or_else(PerNs::none, |m| PerNs::macros(m, ResolvedVisibility::Public));\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n         let from_scope = self[module].scope.get(name, shadow);\n         let from_extern_prelude = self\n             .extern_prelude\n             .get(name)\n-            .map_or(PerNs::none(), |&it| PerNs::types(it, ResolvedVisibility::Public));\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public));\n         let from_prelude = self.resolve_in_prelude(db, name, shadow);\n \n         from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)"}, {"sha": "6e435c8c12a7c28e1352389dc8d9c4149c7e3ebc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -5,13 +5,13 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::{visibility::ResolvedVisibility, ModuleDefId};\n+use crate::{visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n-    pub types: Option<(ModuleDefId, ResolvedVisibility)>,\n-    pub values: Option<(ModuleDefId, ResolvedVisibility)>,\n-    pub macros: Option<(MacroDefId, ResolvedVisibility)>,\n+    pub types: Option<(ModuleDefId, Visibility)>,\n+    pub values: Option<(ModuleDefId, Visibility)>,\n+    pub macros: Option<(MacroDefId, Visibility)>,\n }\n \n impl Default for PerNs {\n@@ -25,19 +25,19 @@ impl PerNs {\n         PerNs { types: None, values: None, macros: None }\n     }\n \n-    pub fn values(t: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+    pub fn values(t: ModuleDefId, v: Visibility) -> PerNs {\n         PerNs { types: None, values: Some((t, v)), macros: None }\n     }\n \n-    pub fn types(t: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+    pub fn types(t: ModuleDefId, v: Visibility) -> PerNs {\n         PerNs { types: Some((t, v)), values: None, macros: None }\n     }\n \n-    pub fn both(types: ModuleDefId, values: ModuleDefId, v: ResolvedVisibility) -> PerNs {\n+    pub fn both(types: ModuleDefId, values: ModuleDefId, v: Visibility) -> PerNs {\n         PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDefId, v: ResolvedVisibility) -> PerNs {\n+    pub fn macros(macro_: MacroDefId, v: Visibility) -> PerNs {\n         PerNs { types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n@@ -49,7 +49,7 @@ impl PerNs {\n         self.types.map(|it| it.0)\n     }\n \n-    pub fn take_types_vis(self) -> Option<(ModuleDefId, ResolvedVisibility)> {\n+    pub fn take_types_vis(self) -> Option<(ModuleDefId, Visibility)> {\n         self.types\n     }\n \n@@ -61,15 +61,15 @@ impl PerNs {\n         self.macros.map(|it| it.0)\n     }\n \n-    pub fn filter_visibility(self, mut f: impl FnMut(ResolvedVisibility) -> bool) -> PerNs {\n+    pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n         PerNs {\n             types: self.types.filter(|(_, v)| f(*v)),\n             values: self.values.filter(|(_, v)| f(*v)),\n             macros: self.macros.filter(|(_, v)| f(*v)),\n         }\n     }\n \n-    pub fn with_visibility(self, vis: ResolvedVisibility) -> PerNs {\n+    pub fn with_visibility(self, vis: Visibility) -> PerNs {\n         PerNs {\n             types: self.types.map(|(it, _)| (it, vis)),\n             values: self.values.map(|(it, _)| (it, vis)),"}, {"sha": "43dc751d97d3ca20ee80127310775001be2632e5", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n-    visibility::{RawVisibility, ResolvedVisibility},\n+    visibility::{RawVisibility, Visibility},\n     AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,\n     FunctionId, GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n     StaticId, StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\n@@ -236,7 +236,7 @@ impl Resolver {\n         &self,\n         db: &impl DefDatabase,\n         visibility: &RawVisibility,\n-    ) -> Option<ResolvedVisibility> {\n+    ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(_) => {\n                 let (item_map, module) = match self.module() {\n@@ -245,7 +245,7 @@ impl Resolver {\n                 };\n                 item_map.resolve_visibility(db, module, visibility)\n             }\n-            RawVisibility::Public => Some(ResolvedVisibility::Public),\n+            RawVisibility::Public => Some(Visibility::Public),\n         }\n     }\n \n@@ -466,16 +466,10 @@ impl Scope {\n                     f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(\n-                        name.clone(),\n-                        ScopeDef::PerNs(PerNs::macros(macro_, ResolvedVisibility::Public)),\n-                    );\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_, Visibility::Public)));\n                 });\n                 m.crate_def_map.extern_prelude.iter().for_each(|(name, &def)| {\n-                    f(\n-                        name.clone(),\n-                        ScopeDef::PerNs(PerNs::types(def.into(), ResolvedVisibility::Public)),\n-                    );\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into(), Visibility::Public)));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);"}, {"sha": "e4c25ab7d15afad57387c7511947db14af2b259b", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ebff257dafe6e820f002241466ff4a98aa1f32/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=50ebff257dafe6e820f002241466ff4a98aa1f32", "patch": "@@ -109,26 +109,26 @@ impl RawVisibility {\n         &self,\n         db: &impl DefDatabase,\n         resolver: &crate::resolver::Resolver,\n-    ) -> ResolvedVisibility {\n+    ) -> Visibility {\n         // we fall back to public visibility (i.e. fail open) if the path can't be resolved\n-        resolver.resolve_visibility(db, self).unwrap_or(ResolvedVisibility::Public)\n+        resolver.resolve_visibility(db, self).unwrap_or(Visibility::Public)\n     }\n }\n \n /// Visibility of an item, with the path resolved.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum ResolvedVisibility {\n+pub enum Visibility {\n     /// Visibility is restricted to a certain module.\n     Module(ModuleId),\n     /// Visibility is unrestricted.\n     Public,\n }\n \n-impl ResolvedVisibility {\n+impl Visibility {\n     pub fn visible_from(self, db: &impl DefDatabase, from_module: ModuleId) -> bool {\n         let to_module = match self {\n-            ResolvedVisibility::Module(m) => m,\n-            ResolvedVisibility::Public => return true,\n+            Visibility::Module(m) => m,\n+            Visibility::Public => return true,\n         };\n         // if they're not in the same crate, it can't be visible\n         if from_module.krate != to_module.krate {\n@@ -144,8 +144,8 @@ impl ResolvedVisibility {\n         from_module: crate::LocalModuleId,\n     ) -> bool {\n         let to_module = match self {\n-            ResolvedVisibility::Module(m) => m,\n-            ResolvedVisibility::Public => return true,\n+            Visibility::Module(m) => m,\n+            Visibility::Public => return true,\n         };\n         // from_module needs to be a descendant of to_module\n         let mut ancestors = std::iter::successors(Some(from_module), |m| {"}]}