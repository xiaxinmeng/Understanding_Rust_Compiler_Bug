{"sha": "143206d54d7558c2326212df99efc98110904fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MzIwNmQ1NGQ3NTU4YzIzMjYyMTJkZjk5ZWZjOTgxMTA5MDRmZGI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2017-06-19T05:01:29Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2017-06-25T02:20:57Z"}, "message": "Stabilize RangeArgument\n\nMove it and Bound to core::ops while we're at it.\n\nCloses #30877", "tree": {"sha": "8c444d9522f0500f9c3a3217c7e227aa4aaf8916", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c444d9522f0500f9c3a3217c7e227aa4aaf8916"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/143206d54d7558c2326212df99efc98110904fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/143206d54d7558c2326212df99efc98110904fdb", "html_url": "https://github.com/rust-lang/rust/commit/143206d54d7558c2326212df99efc98110904fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/143206d54d7558c2326212df99efc98110904fdb/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc411e307ac76af0fd2128da5ea12562c84a48c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc411e307ac76af0fd2128da5ea12562c84a48c6", "html_url": "https://github.com/rust-lang/rust/commit/dc411e307ac76af0fd2128da5ea12562c84a48c6"}], "stats": {"total": 404, "additions": 187, "deletions": 217}, "files": [{"sha": "5243fb6ae0e061688eaf6f10a91d755b4fde6859", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -13,12 +13,11 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n-use core::ops::Index;\n+use core::ops::{Index, RangeArgument};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{Excluded, Included, Unbounded};\n-use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;"}, {"sha": "c755d2d8b8538909d37587e1f524b4d95917baef", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -16,12 +16,11 @@ use core::cmp::{min, max};\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeArgument};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n-use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n "}, {"sha": "6f4e300fd3cc9d814550fb4d38bd4b00f9f0ddc8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -203,56 +203,7 @@ mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n+pub use core::ops::Bound;\n \n /// An intermediate trait for specialization of `Extend`.\n #[doc(hidden)]"}, {"sha": "0a058c47a50b252ed6c16386041b04d9838a78fa", "filename": "src/liballoc/range.rs", "status": "modified", "additions": 2, "deletions": 136, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -11,142 +11,8 @@\n #![unstable(feature = \"collections_range\",\n             reason = \"waiting for dust to settle on inclusive ranges\",\n             issue = \"30877\")]\n+#![rustc_deprecated(reason = \"moved to core::ops\", since = \"1.19.0\")]\n \n //! Range syntax.\n \n-use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n-use Bound::{self, Excluded, Included, Unbounded};\n-\n-/// `RangeArgument` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound.\n-    ///\n-    /// Returns the start value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n-    /// # }\n-    /// ```\n-    fn start(&self) -> Bound<&T>;\n-\n-    /// End index bound.\n-    ///\n-    /// Returns the end value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n-    /// # }\n-    /// ```\n-    fn end(&self) -> Bound<&T>;\n-}\n-\n-// FIXME add inclusive ranges to RangeArgument\n-\n-impl<T: ?Sized> RangeArgument<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n-        match *self {\n-            (Included(ref start), _) => Included(start),\n-            (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n-        }\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        match *self {\n-            (_, Included(ref end)) => Included(end),\n-            (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n-        }\n-    }\n-}\n-\n-impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n-        self.0\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        self.1\n-    }\n-}\n+pub use core::ops::RangeArgument;"}, {"sha": "1f0894d39d4d23a525ff4acef0382865a7b5dc69", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -59,15 +59,14 @@\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeArgument};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ptr;\n use core::str::pattern::Pattern;\n use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n-use range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;"}, {"sha": "e118d406ecf095cbcd91392e6971c920f74546e3", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -74,7 +74,8 @@ use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n+use core::ops::{InPlace, Index, IndexMut, Place, Placer, RangeArgument};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops;\n use core::ptr;\n use core::ptr::Shared;\n@@ -84,8 +85,6 @@ use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///"}, {"sha": "d1d334267bccf8dc4fb86aaad33f94ef6ea7ad45", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -21,7 +21,8 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n+use core::ops::{Index, IndexMut, Place, Placer, InPlace, RangeArgument};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n@@ -31,8 +32,6 @@ use core::cmp;\n \n use raw_vec::RawVec;\n \n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1"}, {"sha": "0a939831622f5c1c926f34a1e8004cfc38701284", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -46,6 +46,7 @@ pub use alloc::binary_heap;\n pub use alloc::borrow;\n pub use alloc::fmt;\n pub use alloc::linked_list;\n+#[allow(deprecated)]\n pub use alloc::range;\n pub use alloc::slice;\n pub use alloc::str;"}, {"sha": "34f00850579e8c3ee62b798360d439b9b43fbf89", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -183,6 +183,9 @@ pub use self::index::{Index, IndexMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+pub use self::range::{RangeArgument, Bound};\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub use self::range::{RangeInclusive, RangeToInclusive};\n "}, {"sha": "65e09da4fff05c3362f96fefb240c08bb9f98f52", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 165, "deletions": 9, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use fmt;\n+use ops::Bound::{Included, Excluded, Unbounded};\n \n /// An unbounded range. Use `..` (two dots) for its shorthand.\n ///\n@@ -71,7 +72,8 @@ impl fmt::Debug for RangeFull {\n ///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+// not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -134,7 +136,8 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///     assert_eq!(arr[1..3], [  1,2  ]);\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+// not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -250,17 +253,16 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n ///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+// not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeInclusive<Idx> {\n     /// The lower bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub end: Idx,\n }\n@@ -333,8 +335,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n     /// The upper bound of the range (inclusive)\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub end: Idx,\n }\n@@ -365,3 +366,158 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n \n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n+\n+/// `RangeArgument` is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+pub trait RangeArgument<T: ?Sized> {\n+    /// Start index bound.\n+    ///\n+    /// Returns the start value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ops::RangeArgument;\n+    /// use std::ops::Bound::*;\n+    ///\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n+    /// ```\n+    #[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+    fn start(&self) -> Bound<&T>;\n+\n+    /// End index bound.\n+    ///\n+    /// Returns the end value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ops::RangeArgument;\n+    /// use std::ops::Bound::*;\n+    ///\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// ```\n+    #[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+    fn end(&self) -> Bound<&T>;\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<T: ?Sized> RangeArgument<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<T> RangeArgument<T> for RangeFrom<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<T> RangeArgument<T> for RangeTo<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<T> RangeArgument<T> for Range<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _) => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded) => Unbounded,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n+impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n+    }\n+}\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// use std::ops::RangeArgument;\n+/// use std::ops::Bound::*;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}"}, {"sha": "eacd394ad5ea14bb5bd316112b417e37cf23bb2e", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -15,11 +15,10 @@\n //!\n //! The N above is determined by Array's implementor, by way of an associatated constant.\n \n-use std::ops::{Deref, DerefMut};\n+use std::ops::{Deref, DerefMut, RangeArgument};\n use std::iter::{self, IntoIterator, FromIterator};\n use std::slice;\n use std::vec;\n-use std::collections::range::RangeArgument;\n \n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n "}, {"sha": "a9abdf1377e9dff62dc8e1b3bd9d91fa7f39daf8", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -13,13 +13,12 @@\n use std::marker::Unsize;\n use std::iter::Extend;\n use std::ptr::{self, drop_in_place, Shared};\n-use std::ops::{Deref, DerefMut, Range};\n+use std::ops::{Deref, DerefMut, Range, RangeArgument};\n+use std::ops::Bound::{Excluded, Included, Unbounded};\n use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n use std::mem;\n-use std::collections::range::RangeArgument;\n-use std::collections::Bound::{Excluded, Included, Unbounded};\n use std::mem::ManuallyDrop;\n \n pub unsafe trait Array {"}, {"sha": "3bf926fa8bf38a78c6a258096aaf3036e0ae3b0c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::range::RangeArgument;\n use std::fmt::Debug;\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut, Range};\n+use std::ops::{Index, IndexMut, Range, RangeArgument};\n use std::fmt;\n use std::vec;\n use std::u32;"}, {"sha": "0bbda547761cc5fd3cc1246b02a966c618f3422c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -25,7 +25,6 @@\n #![deny(warnings)]\n \n #![feature(shared)]\n-#![feature(collections_range)]\n #![feature(nonzero)]\n #![feature(unboxed_closures)]\n #![feature(fn_traits)]"}, {"sha": "2ed6724b07da4fb9bab5f40e176ecfb6010d706e", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143206d54d7558c2326212df99efc98110904fdb/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143206d54d7558c2326212df99efc98110904fdb/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=143206d54d7558c2326212df99efc98110904fdb", "patch": "@@ -436,6 +436,8 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"moved to std::ops\", since = \"1.19.0\")]\n+#[allow(deprecated)]\n pub use alloc::range;\n \n mod hash;"}]}