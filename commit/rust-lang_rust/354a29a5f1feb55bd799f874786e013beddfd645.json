{"sha": "354a29a5f1feb55bd799f874786e013beddfd645", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGEyOWE1ZjFmZWI1NWJkNzk5Zjg3NDc4NmUwMTNiZWRkZmQ2NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-17T18:13:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-17T18:13:26Z"}, "message": "Auto merge of #54277 - petrochenkov:afterder, r=alexcrichton\n\nTemporarily prohibit proc macro attributes placed after derives\n\n... and also proc macro attributes used together with `#[test]`/`#[bench]`.\n\nAddresses item 6 from https://github.com/rust-lang/rust/pull/50911#issuecomment-411605393.\n\nThe end goal is straightforward predictable left-to-right expansion order for attributes.\nRight now derives are expanded last regardless of their relative ordering with macro attributes and right now it's simpler to temporarily prohibit macro attributes placed after derives than changing the expansion order.\nI'm not sure whether the new beta is already released or not, but if it's released, then this patch needs to be backported, so the solution needs to be minimal.\n\nHow to fix broken code (derives):\n- Move macro attributes above derives. This won't change expansion order, they are expanded before derives anyway.\n\nUsing attribute macros on same items with `#[test]` and `#[bench]` is prohibited for similar expansion order reasons, but this one is going to be reverted much sooner than restrictions on derives.\n\nHow to fix broken code (test/bench):\n- Enable `#![feature(plugin)]` (don't ask why).\n\nr? @ghost", "tree": {"sha": "5d8b8dc7b289b1af380df5fdbe86751fe9f42693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d8b8dc7b289b1af380df5fdbe86751fe9f42693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354a29a5f1feb55bd799f874786e013beddfd645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354a29a5f1feb55bd799f874786e013beddfd645", "html_url": "https://github.com/rust-lang/rust/commit/354a29a5f1feb55bd799f874786e013beddfd645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354a29a5f1feb55bd799f874786e013beddfd645/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "186fe091434b4c20c160b8098a56bb6a841bf6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/186fe091434b4c20c160b8098a56bb6a841bf6b1", "html_url": "https://github.com/rust-lang/rust/commit/186fe091434b4c20c160b8098a56bb6a841bf6b1"}, {"sha": "229df02c0b85c33465d7191a6e085e964e56c1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/229df02c0b85c33465d7191a6e085e964e56c1c9", "html_url": "https://github.com/rust-lang/rust/commit/229df02c0b85c33465d7191a6e085e964e56c1c9"}], "stats": {"total": 211, "additions": 160, "deletions": 51}, "files": [{"sha": "cb561b2597b397920e0ac9464bf584e382e04ad5", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -24,7 +24,7 @@ use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n+use syntax::ext::expand::{AstFragment, Invocation, InvocationKind, TogetherWith};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, feature_err, emit_feature_err, is_builtin_attr_name, GateIssue};\n@@ -332,21 +332,30 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        let (path, kind, derives_in_scope) = match invoc.kind {\n+        let (path, kind, derives_in_scope, together_with) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n                 return Ok(None),\n-            InvocationKind::Attr { attr: Some(ref attr), ref traits, .. } =>\n-                (&attr.path, MacroKind::Attr, traits.clone()),\n+            InvocationKind::Attr { attr: Some(ref attr), ref traits, together_with, .. } =>\n+                (&attr.path, MacroKind::Attr, traits.clone(), together_with),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, Vec::new()),\n+                (&mac.node.path, MacroKind::Bang, Vec::new(), TogetherWith::None),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new()),\n+                (path, MacroKind::Derive, Vec::new(), TogetherWith::None),\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n+            match together_with {\n+                TogetherWith::Derive =>\n+                    self.session.span_err(invoc.span(),\n+                        \"macro attributes must be placed before `#[derive]`\"),\n+                TogetherWith::TestBench if !self.session.features_untracked().plugin =>\n+                    self.session.span_err(invoc.span(),\n+                        \"macro attributes cannot be used together with `#[test]` or `#[bench]`\"),\n+                _ => {}\n+            }\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n             let normal_module_def_id =\n                 self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;"}, {"sha": "33d0e76ca481cb2bbf42bcc6b0cdbf4cc63ca73e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -216,6 +216,14 @@ pub struct Invocation {\n     pub expansion_data: ExpansionData,\n }\n \n+// Needed for feature-gating attributes used after derives or together with test/bench\n+#[derive(Clone, Copy, PartialEq)]\n+pub enum TogetherWith {\n+    None,\n+    Derive,\n+    TestBench,\n+}\n+\n pub enum InvocationKind {\n     Bang {\n         mac: ast::Mac,\n@@ -226,6 +234,7 @@ pub enum InvocationKind {\n         attr: Option<ast::Attribute>,\n         traits: Vec<Path>,\n         item: Annotatable,\n+        together_with: TogetherWith,\n     },\n     Derive {\n         path: Path,\n@@ -353,7 +362,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let dummy = invoc.fragment_kind.dummy(invoc.span()).unwrap();\n                     let fragment = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n                     self.collect_invocations(fragment, &[])\n-                } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n+                } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n                     if !item.derive_allowed() {\n                         let attr = attr::find_by_name(item.attrs(), \"derive\")\n                             .expect(\"`derive` attribute should exist\");\n@@ -1069,14 +1078,23 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     attr: Option<ast::Attribute>,\n                     traits: Vec<Path>,\n                     item: Annotatable,\n-                    kind: AstFragmentKind)\n+                    kind: AstFragmentKind,\n+                    together_with: TogetherWith)\n                     -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, traits, item })\n+        self.collect(kind, InvocationKind::Attr { attr, traits, item, together_with })\n     }\n \n-    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, together_with: &mut TogetherWith)\n+                       -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n-                        .position(|a| !attr::is_known(a) && !is_builtin_attr(a))\n+                        .position(|a| {\n+                            if a.path == \"derive\" {\n+                                *together_with = TogetherWith::Derive\n+                            } else if a.path == \"rustc_test_marker2\" {\n+                                *together_with = TogetherWith::TestBench\n+                            }\n+                            !attr::is_known(a) && !is_builtin_attr(a)\n+                        })\n                         .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n             if !self.cx.ecfg.enable_custom_inner_attributes() &&\n@@ -1086,14 +1104,19 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                                  \"non-builtin inner attributes are unstable\");\n             }\n         }\n+        if together_with == &TogetherWith::None &&\n+           attrs.iter().any(|a| a.path == \"rustc_test_marker2\") {\n+            *together_with = TogetherWith::TestBench;\n+        }\n         attr\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n+    fn classify_item<T>(&mut self, mut item: T)\n+                        -> (Option<ast::Attribute>, Vec<Path>, T, TogetherWith)\n         where T: HasAttrs,\n     {\n-        let (mut attr, mut traits) = (None, Vec::new());\n+        let (mut attr, mut traits, mut together_with) = (None, Vec::new(), TogetherWith::None);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1102,19 +1125,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs);\n+            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n             attrs\n         });\n \n-        (attr, traits, item)\n+        (attr, traits, item, together_with)\n     }\n \n     /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T) -> (Option<ast::Attribute>, T) {\n-        let mut attr = None;\n+    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T)\n+                                     -> (Option<ast::Attribute>, T, TogetherWith) {\n+        let (mut attr, mut together_with) = (None, TogetherWith::None);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1123,11 +1147,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs);\n+            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n             attrs\n         });\n \n-        (attr, item)\n+        (attr, item, together_with)\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1166,7 +1190,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr) = self.classify_nonitem(expr);\n+        let (attr, expr, together_with) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n@@ -1175,7 +1199,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             // AstFragmentKind::Expr requires the macro to emit an expression\n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr).make_expr();\n+                                     AstFragmentKind::Expr, together_with).make_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1191,14 +1215,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr) = self.classify_nonitem(expr);\n+        let (attr, expr, together_with) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr)\n-                .make_opt_expr();\n+                                     AstFragmentKind::OptExpr, together_with).make_opt_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1230,19 +1253,18 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_) = if stmt.is_item() {\n+            let (attr, derives, stmt_, together_with) = if stmt.is_item() {\n                 self.classify_item(stmt)\n             } else {\n                 // ignore derives on non-item statements so it falls through\n                 // to the unused-attributes lint\n-                let (attr, stmt) = self.classify_nonitem(stmt);\n-                (attr, vec![], stmt)\n+                let (attr, stmt, together_with) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt, together_with)\n             };\n \n             if attr.is_some() || !derives.is_empty() {\n-                return self.collect_attr(attr, derives,\n-                                         Annotatable::Stmt(P(stmt_)), AstFragmentKind::Stmts)\n-                    .make_stmts();\n+                return self.collect_attr(attr, derives, Annotatable::Stmt(P(stmt_)),\n+                                         AstFragmentKind::Stmts, together_with).make_stmts();\n             }\n \n             stmt = stmt_;\n@@ -1284,10 +1306,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> OneVector<P<ast::Item>> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item) = self.classify_item(item);\n+        let (attr, traits, item, together_with) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::Item(item);\n-            return self.collect_attr(attr, traits, item, AstFragmentKind::Items).make_items();\n+            return self.collect_attr(attr, traits, Annotatable::Item(item),\n+                                     AstFragmentKind::Items, together_with).make_items();\n         }\n \n         match item.node {\n@@ -1359,11 +1381,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> OneVector<ast::TraitItem> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item) = self.classify_item(item);\n+        let (attr, traits, item, together_with) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::TraitItem(P(item));\n-            return self.collect_attr(attr, traits, item, AstFragmentKind::TraitItems)\n-                .make_trait_items()\n+            return self.collect_attr(attr, traits, Annotatable::TraitItem(P(item)),\n+                                     AstFragmentKind::TraitItems, together_with).make_trait_items()\n         }\n \n         match item.node {\n@@ -1379,11 +1400,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> OneVector<ast::ImplItem> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item) = self.classify_item(item);\n+        let (attr, traits, item, together_with) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::ImplItem(P(item));\n-            return self.collect_attr(attr, traits, item, AstFragmentKind::ImplItems)\n-                .make_impl_items();\n+            return self.collect_attr(attr, traits, Annotatable::ImplItem(P(item)),\n+                                     AstFragmentKind::ImplItems, together_with).make_impl_items();\n         }\n \n         match item.node {\n@@ -1414,12 +1434,12 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n     fn fold_foreign_item(&mut self,\n                          foreign_item: ast::ForeignItem) -> OneVector<ast::ForeignItem> {\n-        let (attr, traits, foreign_item) = self.classify_item(foreign_item);\n+        let (attr, traits, foreign_item, together_with) = self.classify_item(foreign_item);\n \n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::ForeignItem(P(foreign_item));\n-            return self.collect_attr(attr, traits, item, AstFragmentKind::ForeignItems)\n-                .make_foreign_items();\n+            return self.collect_attr(attr, traits, Annotatable::ForeignItem(P(foreign_item)),\n+                                     AstFragmentKind::ForeignItems, together_with)\n+                                     .make_foreign_items();\n         }\n \n         if let ast::ForeignItemKind::Macro(mac) = foreign_item.node {"}, {"sha": "060faa9856d7a882a4200cba70b959dc6f8b00a7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -970,6 +970,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                      \"the `#[rustc_test_marker]` attribute \\\n                                       is used internally to track tests\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_test_marker2\", Normal, Gated(Stability::Unstable,\n+                                         \"rustc_attrs\",\n+                                         \"temporarily used by rustc to report some errors\",\n+                                         cfg_fn!(rustc_attrs))),\n     (\"rustc_transparent_macro\", Whitelisted, Gated(Stability::Unstable,\n                                                    \"rustc_attrs\",\n                                                    \"used internally for testing macro hygiene\","}, {"sha": "bb47d9b535befbc8cac04a0a537fbada869601d9", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -38,7 +38,7 @@\n \n use std::fmt::{self, Display, Debug};\n use std::iter::FromIterator;\n-use std::ops::Deref;\n+use std::ops::{Deref, DerefMut};\n use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -103,6 +103,12 @@ impl<T: ?Sized> Deref for P<T> {\n     }\n }\n \n+impl<T: ?Sized> DerefMut for P<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.ptr\n+    }\n+}\n+\n impl<T: 'static + Clone> Clone for P<T> {\n     fn clone(&self) -> P<T> {\n         P((**self).clone())"}, {"sha": "8ddfb1d9cba224c7aa077042a6b14e1ac30e5d47", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -49,7 +49,7 @@ pub fn expand_test_or_bench(\n     // If we're not in test configuration, remove the annotated item\n     if !cx.ecfg.should_test { return vec![]; }\n \n-    let item =\n+    let mut item =\n         if let Annotatable::Item(i) = item { i }\n         else {\n             cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n@@ -192,6 +192,12 @@ pub fn expand_test_or_bench(\n \n     debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n+    // Temporarily add another marker to the original item for error reporting\n+    let marker2 = cx.attribute(\n+        attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"rustc_test_marker2\"))\n+    );\n+    item.attrs.push(marker2);\n+\n     vec![\n         // Access to libtest under a gensymed name\n         Annotatable::Item(test_extern),"}, {"sha": "83bbb7c13c43f8acb74000f15f55b174084f8f25", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -16,12 +16,12 @@\n #[macro_use]\n extern crate derive_b;\n \n-#[derive(B)]\n #[B] //~ ERROR `B` is a derive mode\n #[C]\n #[B(D)]\n #[B(E = \"foo\")]\n #[B(arbitrary tokens)]\n+#[derive(B)]\n struct B;\n \n fn main() {}"}, {"sha": "553cd86e6203858edb6e1a4f820041075418a1fe", "filename": "src/test/ui-fulldeps/attribute-order-restricted.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -0,0 +1,32 @@\n+// aux-build:attr_proc_macro.rs\n+// compile-flags:--test\n+\n+#![feature(test)]\n+\n+extern crate test;\n+extern crate attr_proc_macro;\n+use attr_proc_macro::*;\n+\n+#[attr_proc_macro] // OK\n+#[derive(Clone)]\n+struct Before;\n+\n+#[derive(Clone)]\n+#[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n+struct After;\n+\n+#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+#[test]\n+fn test_before() {}\n+\n+#[test]\n+#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+fn test_after() {}\n+\n+#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+#[bench]\n+fn bench_before(b: &mut test::Bencher) {}\n+\n+#[bench]\n+#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+fn bench_after(b: &mut test::Bencher) {}"}, {"sha": "841fc630b227089d20ef9f6613432e3686554d19", "filename": "src/test/ui-fulldeps/attribute-order-restricted.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -0,0 +1,32 @@\n+error: macro attributes must be placed before `#[derive]`\n+  --> $DIR/attribute-order-restricted.rs:15:1\n+   |\n+LL | #[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n+  --> $DIR/attribute-order-restricted.rs:18:1\n+   |\n+LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n+  --> $DIR/attribute-order-restricted.rs:23:1\n+   |\n+LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n+  --> $DIR/attribute-order-restricted.rs:26:1\n+   |\n+LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n+  --> $DIR/attribute-order-restricted.rs:31:1\n+   |\n+LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "aa9eae0ba317afc4159519d71ed7823cb3cf7367", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -3,8 +3,8 @@\n extern crate derive_helper_shadowing;\n use derive_helper_shadowing::*;\n \n-#[derive(MyTrait)]\n #[my_attr] //~ ERROR `my_attr` is ambiguous\n+#[derive(MyTrait)]\n struct S;\n \n fn main() {}"}, {"sha": "cdfecb3d1014667d6c0c60eb8fd774b233105993", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/354a29a5f1feb55bd799f874786e013beddfd645/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=354a29a5f1feb55bd799f874786e013beddfd645", "patch": "@@ -1,5 +1,5 @@\n error[E0659]: `my_attr` is ambiguous\n-  --> $DIR/derive-helper-shadowing.rs:7:3\n+  --> $DIR/derive-helper-shadowing.rs:6:3\n    |\n LL | #[my_attr] //~ ERROR `my_attr` is ambiguous\n    |   ^^^^^^^ ambiguous name\n@@ -10,7 +10,7 @@ note: `my_attr` could refer to the name imported here\n LL | use derive_helper_shadowing::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: `my_attr` could also refer to the name defined here\n-  --> $DIR/derive-helper-shadowing.rs:6:10\n+  --> $DIR/derive-helper-shadowing.rs:7:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^"}]}