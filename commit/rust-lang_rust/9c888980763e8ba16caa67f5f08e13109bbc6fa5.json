{"sha": "9c888980763e8ba16caa67f5f08e13109bbc6fa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODg4OTgwNzYzZThiYTE2Y2FhNjdmNWYwOGUxMzEwOWJiYzZmYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-18T18:29:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-18T18:29:25Z"}, "message": "Auto merge of #34899 - michaelwoerister:always_internalize_symbols, r=eddyb\n\nRun base::internalize_symbols() even for single-codegen-unit crates.\n\nThe initial linkage-assignment (especially for closures) is a conservative one that makes some symbols more visible than they need to be. While this is not a correctness problem, it does force the LLVM inliner to be more conservative too, which results in poor performance. Once translation is based solely on MIR, it will be easier to also make the initial linkage assignment a better fitting one. Until then `internalize_symbols()` does a good job of preventing most performance regressions.\n\nThis should solve the regressions reported in https://github.com/rust-lang/rust/issues/34891 and maybe also those in https://github.com/rust-lang/rust/issues/34831.\n\nAs a side-effect, this will also solve most of the problematic cases described in https://github.com/rust-lang/rust/issues/34793. Not reliably so, however. For that, we still need a solution like the one implement in https://github.com/rust-lang/rust/pull/34830.\n\ncc @rust-lang/compiler", "tree": {"sha": "4082fe088e06fca69227e0c6a526d6b5719318b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4082fe088e06fca69227e0c6a526d6b5719318b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c888980763e8ba16caa67f5f08e13109bbc6fa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c888980763e8ba16caa67f5f08e13109bbc6fa5", "html_url": "https://github.com/rust-lang/rust/commit/9c888980763e8ba16caa67f5f08e13109bbc6fa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c888980763e8ba16caa67f5f08e13109bbc6fa5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06ca016b6e779ba972efb9d1735afc527d301505", "url": "https://api.github.com/repos/rust-lang/rust/commits/06ca016b6e779ba972efb9d1735afc527d301505", "html_url": "https://github.com/rust-lang/rust/commit/06ca016b6e779ba972efb9d1735afc527d301505"}, {"sha": "22f77a917147f232d7fa96522ae539fe5b00d7f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f77a917147f232d7fa96522ae539fe5b00d7f6", "html_url": "https://github.com/rust-lang/rust/commit/22f77a917147f232d7fa96522ae539fe5b00d7f6"}], "stats": {"total": 36, "additions": 15, "deletions": 21}, "files": [{"sha": "c8b9fea15ba8b0e12cb4c3557411deddb8f3b056", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c888980763e8ba16caa67f5f08e13109bbc6fa5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c888980763e8ba16caa67f5f08e13109bbc6fa5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9c888980763e8ba16caa67f5f08e13109bbc6fa5", "patch": "@@ -2270,12 +2270,9 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n \n                 if is_decl || is_available_externally {\n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                        .to_bytes()\n-                        .to_vec();\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                     declared.insert(name);\n                 }\n-\n             }\n         }\n \n@@ -2286,21 +2283,21 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n-                let is_external = linkage == llvm::ExternalLinkage as c_uint;\n-                let is_weak_odr = linkage == llvm::WeakODRLinkage as c_uint;\n-                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n-\n-                // We only care about external definitions.\n-                if (is_external || is_weak_odr) && !is_decl {\n+                let is_externally_visible = (linkage == llvm::ExternalLinkage as c_uint) ||\n+                                            (linkage == llvm::LinkOnceODRLinkage as c_uint) ||\n+                                            (linkage == llvm::WeakODRLinkage as c_uint);\n+                let is_definition = llvm::LLVMIsDeclaration(val) != 0;\n \n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                                .to_bytes()\n-                                .to_vec();\n+                // If this is a definition (as opposed to just a declaration)\n+                // and externally visible, check if we can internalize it\n+                if is_definition && is_externally_visible {\n+                    let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                    let name_str = name_cstr.to_str().unwrap();\n \n-                    let is_declared = declared.contains(&name);\n-                    let reachable = reachable.contains(str::from_utf8(&name).unwrap());\n+                    let is_referenced_somewhere = declared.contains(&name_cstr);\n+                    let is_reachable = reachable.contains(name_str);\n \n-                    if !is_declared && !reachable {\n+                    if !is_referenced_somewhere && !is_reachable {\n                         llvm::SetLinkage(val, llvm::InternalLinkage);\n                         llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n                         llvm::UnsetComdat(val);\n@@ -2488,7 +2485,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n-    let codegen_unit_count = codegen_units.len();\n \n     let symbol_map = Rc::new(symbol_map);\n \n@@ -2620,10 +2616,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    if codegen_unit_count > 1 {\n-        internalize_symbols(&crate_context_list,\n-                            &reachable_symbols.iter().map(|x| &x[..]).collect());\n-    }\n+    internalize_symbols(&crate_context_list,\n+                        &reachable_symbols.iter().map(|x| &x[..]).collect());\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {"}]}