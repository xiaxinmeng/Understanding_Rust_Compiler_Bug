{"sha": "e860ab2dabc281b8d882387fd62e78a6c072e6dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NjBhYjJkYWJjMjgxYjhkODgyMzg3ZmQ2MmU3OGE2YzA3MmU2ZGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-15T18:18:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "Tweak logging\n\n- The logging in step.rs becomes debug! to make it stand out a bit more\n- Dump value of operands (in `eval_operands`)\n- Try to log a bit less verbose", "tree": {"sha": "8196f191362d019aaee0ee2ffe0722f4b1b5883a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8196f191362d019aaee0ee2ffe0722f4b1b5883a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e860ab2dabc281b8d882387fd62e78a6c072e6dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e860ab2dabc281b8d882387fd62e78a6c072e6dc", "html_url": "https://github.com/rust-lang/rust/commit/e860ab2dabc281b8d882387fd62e78a6c072e6dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e860ab2dabc281b8d882387fd62e78a6c072e6dc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0807ad19ef0b7e1d56b040f79a3192c4229c2224", "url": "https://api.github.com/repos/rust-lang/rust/commits/0807ad19ef0b7e1d56b040f79a3192c4229c2224", "html_url": "https://github.com/rust-lang/rust/commit/0807ad19ef0b7e1d56b040f79a3192c4229c2224"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "9a36abdb7cfa0b0c2e0b2bc0b039c18c4061d878", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e860ab2dabc281b8d882387fd62e78a6c072e6dc", "patch": "@@ -395,21 +395,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data.\n-    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    pub fn eval_operand(&mut self, mir_op: &mir::Operand<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n         use rustc::mir::Operand::*;\n-        match *op {\n+        let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n             Move(ref place) =>\n-                self.eval_place_to_op(place),\n+                self.eval_place_to_op(place)?,\n \n             Constant(ref constant) => {\n-                let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n+                let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx), self.substs());\n                 let layout = self.layout_of(ty)?;\n                 let op = self.const_value_to_op(constant.literal.val)?;\n-                Ok(OpTy { op, layout })\n+                OpTy { op, layout }\n             }\n-        }\n+        };\n+        trace!(\"{:?}: {:?}\", mir_op, *op);\n+        Ok(op)\n     }\n \n     /// Evaluate a bunch of operands at once"}, {"sha": "555bc797f6c50a8581c97d104643ba2f54c6e2d8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e860ab2dabc281b8d882387fd62e78a6c072e6dc", "patch": "@@ -516,6 +516,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         src_val: Value,\n         dest : PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n         // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n         // but not factored as a separate function.\n         match dest.place {\n@@ -543,7 +544,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         value: Value,\n         dest: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write_value_to_ptr: {:#?}, {:#?}\", value, dest.layout);\n         assert_eq!(dest.extra, PlaceExtra::None);\n         // Note that it is really important that the type here is the right one, and matches the type things are read at.\n         // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n@@ -584,8 +584,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         src: OpTy<'tcx>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"Copying {:?} to {:?}\", src, dest);\n-        assert_eq!(src.layout.size, dest.layout.size, \"Size mismatch when copying!\");\n+        assert_eq!(src.layout.size, dest.layout.size,\n+            \"Size mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let (src_ptr, src_align) = match self.try_read_value(src)? {\n@@ -595,6 +595,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Err(mplace) => mplace.to_scalar_ptr_align(),\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n+        trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n         let (dest_ptr, dest_align) = self.force_allocation(dest)?.to_scalar_ptr_align();\n         self.memory.copy(\n             src_ptr, src_align,"}, {"sha": "f313b486cfa6faffc2783ac90818c6ef5af00285", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=e860ab2dabc281b8d882387fd62e78a6c072e6dc", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx> {\n-        trace!(\"{:?}\", stmt);\n+        debug!(\"{:?}\", stmt);\n \n         use rustc::mir::StatementKind::*;\n \n@@ -281,12 +281,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n-        trace!(\"{:?}\", terminator.kind);\n+        debug!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n         self.memory.tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n-            trace!(\"// {:?}\", self.frame().block);\n+            debug!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())\n     }"}, {"sha": "98ffacf6b4a0881800b55af27f284796a3bd7af1", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=e860ab2dabc281b8d882387fd62e78a6c072e6dc", "patch": "@@ -13,7 +13,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         span: Span,\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"drop_place: {:#?}\", place);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n@@ -29,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         span: Span,\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n+        trace!(\"drop: {:?},\\n  {:?}, {:?}\", arg, ty.sty, instance.def);\n \n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {"}, {"sha": "c947a8434639dde1c5ff418079d366939449826f", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e860ab2dabc281b8d882387fd62e78a6c072e6dc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=e860ab2dabc281b8d882387fd62e78a6c072e6dc", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             } => {\n                 let discr_val = self.eval_operand(discr)?;\n                 let discr = self.read_value(discr_val)?;\n-                trace!(\"SwitchInt({:#?})\", *discr);\n+                trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n@@ -286,10 +286,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // and need to pack arguments\n                     Abi::Rust => {\n                         trace!(\n-                            \"arg_locals: {:#?}\",\n-                            self.frame().mir.args_iter().collect::<Vec<_>>()\n+                            \"args: {:#?}\",\n+                            self.frame().mir.args_iter().zip(args.iter())\n+                                .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n                         );\n-                        trace!(\"args: {:#?}\", args);\n                         let local = arg_locals.nth(1).unwrap();\n                         for (i, &op) in args.into_iter().enumerate() {\n                             let dest = self.eval_place(&mir::Place::Local(local).field(\n@@ -319,10 +319,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\n-                    \"arg_locals: {:#?}\",\n-                    self.frame().mir.args_iter().collect::<Vec<_>>()\n+                    \"args: {:#?}\",\n+                    self.frame().mir.args_iter().zip(args.iter())\n+                        .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n                 );\n-                trace!(\"args: {:#?}\", args);\n                 match sig.abi {\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);"}]}