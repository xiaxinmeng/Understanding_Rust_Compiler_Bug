{"sha": "2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlY2FlODBhZjIxMGQ2MTUzY2RmMGZlY2IxZWNkMTFmY2MzOTBjMDA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-06T05:18:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-07T16:29:42Z"}, "message": "Fix some windows rpass tests", "tree": {"sha": "67a8d5fa6a12da4a905e7c80e367c84d49d0c2bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67a8d5fa6a12da4a905e7c80e367c84d49d0c2bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "html_url": "https://github.com/rust-lang/rust/commit/2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d9fd8e2a1f8aa43b4cf66272eaa3cf695bbdcd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9fd8e2a1f8aa43b4cf66272eaa3cf695bbdcd9", "html_url": "https://github.com/rust-lang/rust/commit/0d9fd8e2a1f8aa43b4cf66272eaa3cf695bbdcd9"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "d1edea4df710567d5e552ea68cd8566d4ab3bfc6", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "patch": "@@ -40,6 +40,9 @@ pub struct Process {\n \n     /// None until finish() is called.\n     exit_code: Option<p::ProcessExit>,\n+\n+    /// Manually delivered signal\n+    exit_signal: Option<int>,\n }\n \n impl Process {\n@@ -107,7 +110,12 @@ impl Process {\n \n         match res {\n             Ok(res) => {\n-                Ok((Process { pid: res.pid, handle: res.handle, exit_code: None },\n+                Ok((Process {\n+                        pid: res.pid,\n+                        handle: res.handle,\n+                        exit_code: None,\n+                        exit_signal: None,\n+                    },\n                     ret_io))\n             }\n             Err(e) => Err(e)\n@@ -127,6 +135,14 @@ impl rtio::RtioProcess for Process {\n             Some(code) => code,\n             None => {\n                 let code = waitpid(self.pid);\n+                // On windows, waitpid will never return a signal. If a signal\n+                // was successfully delivered to the process, however, we can\n+                // consider it as having died via a signal.\n+                let code = match self.exit_signal {\n+                    None => code,\n+                    Some(signal) if cfg!(windows) => p::ExitSignal(signal),\n+                    Some(..) => code,\n+                };\n                 self.exit_code = Some(code);\n                 code\n             }\n@@ -157,7 +173,14 @@ impl rtio::RtioProcess for Process {\n             }),\n             None => {}\n         }\n-        return unsafe { killpid(self.pid, signum) };\n+\n+        // A successfully delivered signal that isn't 0 (just a poll for being\n+        // alive) is recorded for windows (see wait())\n+        match unsafe { killpid(self.pid, signum) } {\n+            Ok(()) if signum == 0 => Ok(()),\n+            Ok(()) => { self.exit_signal = Some(signum); Ok(()) }\n+            Err(e) => Err(e),\n+        }\n     }\n }\n \n@@ -256,31 +279,37 @@ fn spawn_process_os(config: p::ProcessConfig,\n \n         let cur_proc = GetCurrentProcess();\n \n-        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n-        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        if in_fd != -1 {\n+            let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n+            if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            }\n+            if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            }\n         }\n \n-        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n-        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        if out_fd != -1 {\n+            let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n+            if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            }\n+            if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            }\n         }\n \n-        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n-        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        if err_fd != -1 {\n+            let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n+            if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n+                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            }\n+            if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            }\n         }\n \n         let cmd = make_command_line(config.program, config.args);\n@@ -307,9 +336,9 @@ fn spawn_process_os(config: p::ProcessConfig,\n             })\n         });\n \n-        assert!(CloseHandle(si.hStdInput) != 0);\n-        assert!(CloseHandle(si.hStdOutput) != 0);\n-        assert!(CloseHandle(si.hStdError) != 0);\n+        if in_fd != -1 { assert!(CloseHandle(si.hStdInput) != 0); }\n+        if out_fd != -1 { assert!(CloseHandle(si.hStdOutput) != 0); }\n+        if err_fd != -1 { assert!(CloseHandle(si.hStdError) != 0); }\n \n         match create_err {\n             Some(err) => return Err(err),"}, {"sha": "1435a101115586c94a926f68ddd9d735b1b70c9e", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_std];\n+#![no_std]\n \n #[lang=\"fail_\"]\n fn fail(_: *i8, _: *i8, _: uint) -> ! { loop {} }"}, {"sha": "4fe2247212f6d07553f19f53b0ad7021e4f69736", "filename": "src/test/run-pass/issue-9047.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Fissue-9047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Fissue-9047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9047.rs?ref=2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "patch": "@@ -16,4 +16,6 @@ fn decode() -> ~str {\n     ~\"\"\n }\n \n-pub fn main() {}\n+pub fn main() {\n+    println!(\"{}\", decode());\n+}"}, {"sha": "23e48b97427c59e59fa77eb042b1ceb2bf491fb1", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "patch": "@@ -10,8 +10,9 @@\n \n // aux-build:lang-item-public.rs\n // ignore-android\n+// ignore-win32 #13361\n \n-#[no_std];\n+#![no_std]\n \n extern crate lang_lib = \"lang-item-public\";\n "}, {"sha": "063ffed3151276ff931db5e6ed78bae0040f140c", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecae80af210d6153cdf0fecb1ecd11fcc390c00/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=2ecae80af210d6153cdf0fecb1ecd11fcc390c00", "patch": "@@ -16,10 +16,18 @@\n #[phase(syntax, link)]\n extern crate log;\n extern crate libc;\n+extern crate green;\n+extern crate rustuv;\n \n use std::io::net::ip::{Ipv4Addr, SocketAddr};\n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n+use std::task;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n \n fn main() {\n     // This test has a chance to time out, try to not let it time out\n@@ -53,7 +61,9 @@ fn main() {\n     let (tx, rx) = channel();\n     for _ in range(0, 1000) {\n         let tx = tx.clone();\n-        spawn(proc() {\n+        let mut builder = task::task();\n+        builder.opts.stack_size = Some(32 * 1024);\n+        builder.spawn(proc() {\n             match TcpStream::connect(addr) {\n                 Ok(stream) => {\n                     let mut stream = stream;"}]}