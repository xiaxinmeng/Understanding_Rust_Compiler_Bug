{"sha": "7f442f8ba174fd4233a14ef4d7b577aa907db594", "node_id": "C_kwDOAAsO6NoAKDdmNDQyZjhiYTE3NGZkNDIzM2ExNGVmNGQ3YjU3N2FhOTA3ZGI1OTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T02:24:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T02:24:44Z"}, "message": "Auto merge of #101220 - JohnTitor:rollup-ov7upr7, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #100804 (Fix search results color on hover for ayu theme)\n - #100892 (Add `AsFd` implementations for stdio types on WASI.)\n - #100927 (Adding new Fuchsia rustup docs... reworking walkthrough)\n - #101088 (Set DebuginfoKind::Pdb in msvc_base)\n - #101159 (add tracking issue number to const_slice_split_at_not_mut)\n - #101192 (Remove path string)\n - #101193 (Avoid zeroing large stack buffers in stdio on Windows)\n - #101197 (:arrow_up: rust-analyzer)\n - #101200 (Add test for issue #85872)\n - #101219 (Update books)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e4825b3c7441ec0fab4d3aa6fee294d54e234b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4825b3c7441ec0fab4d3aa6fee294d54e234b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f442f8ba174fd4233a14ef4d7b577aa907db594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f442f8ba174fd4233a14ef4d7b577aa907db594", "html_url": "https://github.com/rust-lang/rust/commit/7f442f8ba174fd4233a14ef4d7b577aa907db594", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f442f8ba174fd4233a14ef4d7b577aa907db594/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "html_url": "https://github.com/rust-lang/rust/commit/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd"}, {"sha": "0cbc58978b99c090673caa0f2c0e8b4bf7197ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbc58978b99c090673caa0f2c0e8b4bf7197ee3", "html_url": "https://github.com/rust-lang/rust/commit/0cbc58978b99c090673caa0f2c0e8b4bf7197ee3"}], "stats": {"total": 3577, "additions": 2576, "deletions": 1001}, "files": [{"sha": "3a6119a627368fb18da0c9e7f4638546ce339428", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -2055,22 +2055,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             (exp_found.expected.kind(), exp_found.found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n-                let path_str = format!(\"{:?}\", exp_def);\n                 if exp_def == &found_def {\n-                    let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                                       `.as_ref()`\";\n-                    let result_msg = \"you can convert from `&Result<T, E>` to \\\n-                                          `Result<&T, &E>` using `.as_ref()`\";\n                     let have_as_ref = &[\n-                        (\"std::option::Option\", opt_msg),\n-                        (\"core::option::Option\", opt_msg),\n-                        (\"std::result::Result\", result_msg),\n-                        (\"core::result::Result\", result_msg),\n+                        (\n+                            sym::Option,\n+                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+                        `.as_ref()`\",\n+                        ),\n+                        (\n+                            sym::Result,\n+                            \"you can convert from `&Result<T, E>` to \\\n+                        `Result<&T, &E>` using `.as_ref()`\",\n+                        ),\n                     ];\n-                    if let Some(msg) = have_as_ref\n-                        .iter()\n-                        .find_map(|(path, msg)| (&path_str == path).then_some(msg))\n-                    {\n+                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n+                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n+                    }) {\n                         let mut show_suggestion = true;\n                         for (exp_ty, found_ty) in\n                             iter::zip(exp_substs.types(), found_substs.types())"}, {"sha": "b3cd38a6ec3de7ad1847d054222f202e594a7cd9", "filename": "compiler/rustc_target/src/spec/msvc_base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, SplitDebuginfo, TargetOptions};\n+use crate::spec::{DebuginfoKind, LinkerFlavor, LldFlavor, SplitDebuginfo, TargetOptions};\n use std::borrow::Cow;\n \n pub fn opts() -> TargetOptions {\n@@ -20,6 +20,7 @@ pub fn opts() -> TargetOptions {\n         // where `*.pdb` files show up next to the final artifact.\n         split_debuginfo: SplitDebuginfo::Packed,\n         supported_split_debuginfo: Cow::Borrowed(&[SplitDebuginfo::Packed]),\n+        debuginfo_kind: DebuginfoKind::Pdb,\n \n         ..Default::default()\n     }"}, {"sha": "21062c337d82522c7920162cfbbbd48ad8e57124", "filename": "compiler/rustc_target/src/spec/windows_msvc_base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_msvc_base.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{cvs, DebuginfoKind, TargetOptions};\n+use crate::spec::{cvs, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n     let base = super::msvc_base::opts();\n@@ -28,7 +28,6 @@ pub fn opts() -> TargetOptions {\n         // not ever be possible for us to pass this flag.\n         no_default_libraries: false,\n         has_thread_local: true,\n-        debuginfo_kind: DebuginfoKind::Pdb,\n \n         ..base\n     }"}, {"sha": "d5706c388f0045c4764f3797f8473498e9acccc9", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1541,7 +1541,7 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_split_at_not_mut\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_slice_split_at_not_mut\", issue = \"101158\")]\n     #[inline]\n     #[track_caller]\n     #[must_use]"}, {"sha": "d2081771b6ec79d267a9dba2377dc014cfb35a07", "filename": "library/std/src/sys/wasi/stdio.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -4,7 +4,7 @@ use super::fd::WasiFd;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n use crate::os::raw;\n-use crate::os::wasi::io::{AsRawFd, FromRawFd};\n+use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd};\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -23,6 +23,13 @@ impl AsRawFd for Stdin {\n     }\n }\n \n+impl AsFd for Stdin {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw(0) }\n+    }\n+}\n+\n impl io::Read for Stdin {\n     fn read(&mut self, data: &mut [u8]) -> io::Result<usize> {\n         self.read_vectored(&mut [IoSliceMut::new(data)])\n@@ -51,6 +58,13 @@ impl AsRawFd for Stdout {\n     }\n }\n \n+impl AsFd for Stdout {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw(1) }\n+    }\n+}\n+\n impl io::Write for Stdout {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         self.write_vectored(&[IoSlice::new(data)])\n@@ -82,6 +96,13 @@ impl AsRawFd for Stderr {\n     }\n }\n \n+impl AsFd for Stderr {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw(2) }\n+    }\n+}\n+\n impl io::Write for Stderr {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         self.write_vectored(&[IoSlice::new(data)])"}, {"sha": "70c9b14a08fa7f41deea5d3c48580e0269f734b5", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -3,6 +3,7 @@\n use crate::char::decode_utf16;\n use crate::cmp;\n use crate::io;\n+use crate::mem::MaybeUninit;\n use crate::os::windows::io::{FromRawHandle, IntoRawHandle};\n use crate::ptr;\n use crate::str;\n@@ -169,13 +170,14 @@ fn write(\n }\n \n fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n-    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut utf16 = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n     let mut len_utf16 = 0;\n     for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n-        *dest = chr;\n+        *dest = MaybeUninit::new(chr);\n         len_utf16 += 1;\n     }\n-    let utf16 = &utf16[..len_utf16];\n+    // Safety: We've initialized `len_utf16` values.\n+    let utf16: &[u16] = unsafe { MaybeUninit::slice_assume_init_ref(&utf16[..len_utf16]) };\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n@@ -250,27 +252,33 @@ impl io::Read for Stdin {\n             return Ok(bytes_copied);\n         } else if buf.len() - bytes_copied < 4 {\n             // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.\n-            let mut utf16_buf = [0u16; 1];\n+            let mut utf16_buf = [MaybeUninit::new(0); 1];\n             // Read one u16 character.\n             let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;\n             // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.\n-            let read_bytes = utf16_to_utf8(&utf16_buf[..read], &mut self.incomplete_utf8.bytes)?;\n+            let read_bytes = utf16_to_utf8(\n+                unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) },\n+                &mut self.incomplete_utf8.bytes,\n+            )?;\n \n             // Read in the bytes from incomplete_utf8 until the buffer is full.\n             self.incomplete_utf8.len = read_bytes as u8;\n             // No-op if no bytes.\n             bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);\n             Ok(bytes_copied)\n         } else {\n-            let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+            let mut utf16_buf = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n+\n             // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n             // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n             // lost.\n             let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n             let read =\n                 read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n-\n-            match utf16_to_utf8(&utf16_buf[..read], buf) {\n+            // Safety `read_u16s_fixup_surrogates` returns the number of items\n+            // initialized.\n+            let utf16s = unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) };\n+            match utf16_to_utf8(utf16s, buf) {\n                 Ok(value) => return Ok(bytes_copied + value),\n                 Err(e) => return Err(e),\n             }\n@@ -283,14 +291,14 @@ impl io::Read for Stdin {\n // This is a best effort, and might not work if we are not the only reader on Stdin.\n fn read_u16s_fixup_surrogates(\n     handle: c::HANDLE,\n-    buf: &mut [u16],\n+    buf: &mut [MaybeUninit<u16>],\n     mut amount: usize,\n     surrogate: &mut u16,\n ) -> io::Result<usize> {\n     // Insert possibly remaining unpaired surrogate from last read.\n     let mut start = 0;\n     if *surrogate != 0 {\n-        buf[0] = *surrogate;\n+        buf[0] = MaybeUninit::new(*surrogate);\n         *surrogate = 0;\n         start = 1;\n         if amount == 1 {\n@@ -303,7 +311,10 @@ fn read_u16s_fixup_surrogates(\n     let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n \n     if amount > 0 {\n-        let last_char = buf[amount - 1];\n+        // Safety: The returned `amount` is the number of values initialized,\n+        // and it is not 0, so we know that `buf[amount - 1]` have been\n+        // initialized.\n+        let last_char = unsafe { buf[amount - 1].assume_init() };\n         if last_char >= 0xD800 && last_char <= 0xDBFF {\n             // high surrogate\n             *surrogate = last_char;\n@@ -313,7 +324,8 @@ fn read_u16s_fixup_surrogates(\n     Ok(amount)\n }\n \n-fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+// Returns `Ok(n)` if it initialized `n` values in `buf`.\n+fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usize> {\n     // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n     // traditional DOS method to indicate end of character stream / user input (SUB).\n     // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n@@ -346,8 +358,9 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n         }\n         break;\n     }\n-\n-    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+    // Safety: if `amount > 0`, then that many bytes were written, so\n+    // `buf[amount as usize - 1]` has been initialized.\n+    if amount > 0 && unsafe { buf[amount as usize - 1].assume_init() } == CTRL_Z {\n         amount -= 1;\n     }\n     Ok(amount as usize)"}, {"sha": "0a5421ceb238357b3634fb75234eba4d1dad643c", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1 +1 @@\n-Subproject commit 42ca0ef484fcc8437a0682cee23abe4b7c407d52\n+Subproject commit 0a5421ceb238357b3634fb75234eba4d1dad643c"}, {"sha": "d880e6ac2acf133dce640da24b9fb692844f02d4", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1 +1 @@\n-Subproject commit 8e6aa3448515a0654e347b5e2510f1d4bc4d5a64\n+Subproject commit d880e6ac2acf133dce640da24b9fb692844f02d4"}, {"sha": "f62e93c28323ed9637d0a205a0c256498674a509", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1 +1 @@\n-Subproject commit e647eb102890e8927f488bea12672b079eff8d9d\n+Subproject commit f62e93c28323ed9637d0a205a0c256498674a509"}, {"sha": "04892c1a6fc145602ac7367945fda9d4ee83c9fb", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1 +1 @@\n-Subproject commit d3daa1f28e169087becbc5e2b49ac91ca0405a44\n+Subproject commit 04892c1a6fc145602ac7367945fda9d4ee83c9fb"}, {"sha": "c2a1613f288c5c8a7db18addef22bb474d17209b", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 426, "deletions": 97, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -5,14 +5,10 @@\n [Fuchsia] is a modern open source operating system that's simple, secure,\n updatable, and performant.\n \n-[Fuchsia]: https://fuchsia.dev/\n-\n ## Target maintainers\n \n The [Fuchsia team]:\n \n-[Fuchsia team]: https://team-api.infra.rust-lang.org/v1/teams/fuchsia.json\n-\n - Tyler Mandry ([@tmandry](https://github.com/tmandry))\n - Dan Johnson ([@computerdruid](https://github.com/computerdruid))\n - David Koloski ([@djkoloski](https://github.com/djkoloski))\n@@ -24,27 +20,162 @@ the members reported by the API. The API should be considered to be\n authoritative if this occurs. Instead of pinging individual members, use\n `@rustbot ping fuchsia` to contact the team on GitHub.\n \n+## Table of contents\n+\n+1. [Requirements](#requirements)\n+1. [Walkthrough structure](#walkthrough-structure)\n+1. [Compiling a Rust binary targeting Fuchsia](#compiling-a-rust-binary-targeting-fuchsia)\n+    1. [Targeting Fuchsia with rustup and cargo](#targeting-fuchsia-with-rustup-and-cargo)\n+    1. [Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\n+1. [Creating a Fuchsia package](#creating-a-fuchsia-package)\n+    1. [Creating a Fuchsia component](#creating-a-fuchsia-component)\n+    1. [Building a Fuchsia package](#building-a-fuchsia-package)\n+1. [Publishing a Fuchsia package](#publishing-a-fuchsia-package)\n+    1. [Creating a Fuchsia package repository](#creating-a-fuchsia-package-repository)\n+    1. [Publishing Fuchsia package to repository](#publishing-fuchsia-package-to-repository)\n+1. [Running a Fuchsia component on an emulator](#running-a-fuchsia-component-on-an-emulator)\n+    1. [Starting the Fuchsia emulator](#starting-the-fuchsia-emulator)\n+    1. [Watching emulator logs](#watching-emulator-logs)\n+    1. [Serving a Fuchsia package](#serving-a-fuchsia-package)\n+    1. [Running a Fuchsia component](#running-a-fuchsia-component)\n+1. [`.gitignore` extensions](#gitignore-extensions)\n+1. [Testing](#testing)\n+    1. [Running unit tests](#running-unit-tests)\n+    1. [Running the compiler test suite](#running-the-compiler-test-suite)\n+\n ## Requirements\n \n-This target is cross-compiled from a host environment. Development may be done\n-from the [source tree] or using the Fuchsia SDK.\n+This target is cross-compiled from a host environment. You will need a recent\n+copy of the [Fuchsia SDK], which provides the tools, libraries, and binaries\n+required to build and link programs for Fuchsia.\n \n-[source tree]: https://fuchsia.dev/fuchsia-src/get-started/learn/build\n+Development may also be done from the [source tree].\n \n-Fuchsia targets support std and follow the `sysv64` calling convention on\n+Fuchsia targets support `std` and follow the `sysv64` calling convention on\n x86_64. Fuchsia binaries use the ELF file format.\n \n-## Building the target\n+## Walkthrough structure\n+\n+This walkthrough will cover:\n+\n+1. Compiling a Rust binary targeting Fuchsia.\n+1. Building a Fuchsia package.\n+1. Publishing and running a Fuchsia package to a Fuchsia emulator.\n+\n+For the purposes of this walkthrough, we will only target `x86_64-fuchsia`.\n+\n+## Compiling a Rust binary targeting Fuchsia\n+\n+Today, there are two main ways to build a Rust binary targeting Fuchsia\n+using the Fuchsia SDK:\n+1. Allow [rustup] to handle the installation of Fuchsia targets for you.\n+1. Build a toolchain locally that can target Fuchsia.\n+\n+### Targeting Fuchsia with rustup and cargo\n+\n+The easiest way to build a Rust binary targeting Fuchsia is by allowing [rustup]\n+to handle the installation of Fuchsia targets for you. This can be done by issuing\n+the following commands:\n+\n+```sh\n+rustup target add x86_64-fuchsia\n+rustup target add aarch_64-fuchsia\n+```\n+\n+After installing our Fuchsia targets, we can now compile a Rust binary that targets\n+Fuchsia.\n+\n+To create our Rust project, we can issue a standard `cargo` command as follows:\n+\n+**From base working directory**\n+```sh\n+cargo new hello_fuchsia\n+```\n+\n+The rest of this walkthrough will take place from `hello_fuchsia`, so we can\n+change into that directory now:\n+\n+```sh\n+cd hello_fuchsia\n+```\n+\n+*Note: From this point onwards, all commands will be issued from the `hello_fuchsia/`\n+directory, and all `hello_fuchsia/` prefixes will be removed from references for sake of brevity.*\n+\n+We can edit our `src/main.rs` to include a test as follows:\n+\n+**`src/main.rs`**\n+```rust\n+fn main() {\n+    println!(\"Hello Fuchsia!\");\n+}\n+\n+#[test]\n+fn it_works() {\n+    assert_eq!(2 + 2, 4);\n+}\n+```\n+\n+In addition to the standard workspace created, we will want to create a\n+`.cargo/config.toml` file to link necessary libraries\n+during compilation:\n+\n+**`.cargo/config.toml`**\n+```txt\n+[target.x86_64-fuchsia]\n+\n+rustflags = [\n+    \"-Lnative\", \"<SDK_PATH>/arch/x64/sysroot/lib\",\n+    \"-Lnative\", \"<SDK_PATH>/arch/x64/lib\"\n+]\n+```\n+\n+*Note: Make sure to fill out `<SDK_PATH>` with the path to the downloaded [Fuchsia SDK].*\n+\n+In total, our new project will look like:\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503  \u2517\u2501 main.rs\n+\u2523\u2501 Cargo.toml\n+\u2517\u2501 .cargo/\n+   \u2517\u2501 config.toml\n+```\n+\n+Finally, we can build our rust binary as:\n+\n+```sh\n+cargo build --target x86_64-fuchsia\n+```\n+\n+Now we have a Rust binary at `target/x86_64-fuchsia/debug/hello_fuchsia`,\n+targeting our desired Fuchsia target.\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503  \u2517\u2501 main.rs\n+\u2523\u2501 target/\n+\u2503  \u2517\u2501 x86_64-fuchsia/\n+\u2503     \u2517\u2501 debug/\n+\u2503        \u2517\u2501 hello_fuchsia\n+\u2523\u2501 Cargo.toml\n+\u2517\u2501 .cargo/\n+   \u2517\u2501 config.toml\n+```\n+\n+### Targeting Fuchsia with a compiler built from source\n+\n+An alternative to the first workflow is to target Fuchsia by using\n+`rustc` built from source.\n \n Before building Rust for Fuchsia, you'll need a clang toolchain that supports\n Fuchsia as well. A recent version (14+) of clang should be sufficient to compile\n Rust for Fuchsia.\n \n-You'll also need a recent copy of the [Fuchsia SDK], which provides the tools\n-and binaries required to build and link programs for Fuchsia.\n-\n-[Fuchsia SDK]: https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core\n-\n x86-64 and AArch64 Fuchsia targets can be enabled using the following\n configuration.\n \n@@ -75,15 +206,21 @@ export CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/\n These can be run together in a shell environment by executing\n `(source config-env.sh && ./x.py install)`.\n \n-## Building Rust programs\n+Once `rustc` is installed, we can create a new working directory to work from,\n+`hello_fuchsia` along with `hello_fuchsia/src`:\n \n-After compiling Rust binaries, you'll need to build a component, package it, and\n-serve it to a Fuchsia device or emulator. All of this can be done using the\n-Fuchsia SDK.\n+```sh\n+mkdir hello_fuchsia\n+cd hello_fuchsia\n+mkdir src\n+```\n \n-As an example, we'll compile and run this simple program on a Fuchsia emulator:\n+*Note: From this point onwards, all commands will be issued from the `hello_fuchsia/`\n+directory, and all `hello_fuchsia/` prefixes will be removed from references for sake of brevity.*\n \n-**`hello_fuchsia.rs`**\n+There, we can create a new file named `src/hello_fuchsia.rs`:\n+\n+**`src/hello_fuchsia.rs`**\n ```rust\n fn main() {\n     println!(\"Hello Fuchsia!\");\n@@ -95,31 +232,87 @@ fn it_works() {\n }\n ```\n \n-Create a new file named `hello_fuchsia.rs` and fill out its contents with that\n-code.\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 src/\n+    \u2517\u2501 hello_fuchsia.rs\n+```\n+\n+Using your freshly installed `rustc`, you can compile a binary for Fuchsia using\n+the following options:\n+\n+* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n+  platform of your choice\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n+  the SDK\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib`: Link against Fuchsia kernel\n+  libraries from the SDK\n+\n+Putting it all together:\n+\n+```sh\n+# Configure these for the Fuchsia target of your choice\n+TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n+ARCH=\"<x64|aarch64>\"\n+\n+rustc \\\n+    --target ${TARGET_ARCH} \\\n+    -Lnative=${SDK_PATH}/arch/${ARCH}/lib \\\n+    -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib \\\n+    --out-dir bin src/hello_fuchsia.rs\n+```\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503   \u2517\u2501 hello_fuchsia.rs\n+\u2517\u2501 bin/\n+   \u2517\u2501 hello_fuchsia\n+```\n+\n+## Creating a Fuchsia package\n \n-### Create a package\n+Before moving on, double check your directory structure:\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/                     (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n+\u2523\u2501 bin/                     ...\n+\u2503  \u2517\u2501 hello_fuchsia         ...\n+\u2523\u2501 src/                     (if using cargo)\n+\u2503  \u2517\u2501 main.rs               ...\n+\u2517\u2501 target/                  ...\n+   \u2517\u2501 x86_64-fuchsia/       ...\n+      \u2517\u2501 debug/             ...\n+         \u2517\u2501 hello_fuchsia   ...\n+```\n \n+With our Rust binary built, we can move to creating a Fuchsia package.\n On Fuchsia, a package is the unit of distribution for software. We'll need to\n create a new package directory where we will place files like our finished\n-binary and any data it may need. The working directory will have this layout:\n+binary and any data it may need.\n+\n+To start, make the `pkg`, and `pkg/meta` directories:\n+\n+```sh\n+mkdir pkg\n+mkdir pkg/meta\n+```\n \n+**Current directory structure**\n ```txt\n-hello_fuchsia.rs\n-hello_fuchsia.cml\n-package\n-\u2523\u2501 bin\n-\u2503  \u2517\u2501 hello_fuchsia\n-\u2523\u2501 meta\n-\u2503  \u2523\u2501 package\n-\u2503  \u2517\u2501 hello_fuchsia.cm\n-\u2517\u2501 hello_fuchsia.manifest\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2517\u2501 meta/\n ```\n \n-Make the `package`, `package/bin`, and `package/meta` directories and create the\n-following files inside:\n+Now, create the following files inside:\n \n-**`package/meta/package`**\n+**`pkg/meta/package`**\n ```json\n {\n   \"name\": \"hello_fuchsia\",\n@@ -130,56 +323,41 @@ following files inside:\n The `package` file describes our package's name and version number. Every\n package must contain one.\n \n-**`package/hello_fuchsia.manifest`**\n+**`pkg/hello_fuchsia.manifest`**\n ```txt\n-bin/hello_fuchsia=package/bin/hello_fuchsia\n+bin/hello_fuchsia=target/x86_64-fuchsia/debug/hello_fuchsia     # If using cargo...\n+bin/hello_fuchsia=bin/hello_fuchsia                             # If using rustc...\n lib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\n lib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\n-meta/package=package/meta/package\n-meta/hello_fuchsia.cm=package/meta/hello_fuchsia.cm\n+meta/package=pkg/meta/package\n+meta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm\n ```\n \n *Note: Relative manifest paths are resolved starting from the working directory\n of `pm`. Make sure to fill out `<SDK_PATH>` with the path to the downloaded\n SDK.*\n \n The `.manifest` file will be used to describe the contents of the package by\n-relating their location when installed to their location on the file system. You\n-can use this to make a package pull files from other places, but for this\n-example we'll just be placing everything in the `package` directory.\n-\n-### Compiling a binary\n-\n-Using your freshly compiled `rustc`, you can compile a binary for Fuchsia using\n-the following options:\n-\n-* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n-  platform of your choice\n-* `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n-  the SDK\n-* `-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib`: Link against Fuchsia kernel\n-  libraries from the SDK\n-\n-Putting it all together:\n-\n-```sh\n-# Configure these for the Fuchsia target of your choice\n-TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n-ARCH=\"<x64|aarch64>\"\n+relating their location when installed to their location on the file system. The\n+`bin/hello_fuchsia=` entry will be different depending on how your Rust binary\n+was built, so choose accordingly.\n \n-rustc --target ${TARGET_ARCH} -Lnative=${SDK_PATH}/arch/${ARCH}/lib -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib -o package/bin/hello_fuchsia hello_fuchsia.rs\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2517\u2501 package\n+   \u2517\u2501 hello_fuchsia.manifest\n ```\n \n-### Bulding a component\n+### Creating a Fuchsia component\n \n-On Fuchsia, components require a component manifest written in Fuchia's markup\n+On Fuchsia, components require a component manifest written in Fuchsia's markup\n language called CML. The Fuchsia devsite contains an [overview of CML] and a\n [reference for the file format]. Here's a basic one that can run our single binary:\n \n-[overview of CML]: https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests\n-[reference for the file format]: https://fuchsia.dev/reference/cml\n-\n-**`hello_fuchsia.cml`**\n+**`pkg/hello_fuchsia.cml`**\n ```txt\n {\n     include: [ \"syslog/client.shard.cml\" ],\n@@ -190,43 +368,152 @@ language called CML. The Fuchsia devsite contains an [overview of CML] and a\n }\n ```\n \n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2517\u2501 package\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2517\u2501 hello_fuchsia.cml\n+```\n+\n Now we can compile that CML into a component manifest:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/cmc compile hello_fuchsia.cml --includepath ${SDK_PATH}/pkg -o package/meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/cmc compile \\\n+    pkg/hello_fuchsia.cml \\\n+    --includepath ${SDK_PATH}/pkg \\\n+    -o pkg/meta/hello_fuchsia.cm\n+```\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2517\u2501 hello_fuchsia.cml\n ```\n \n-`--includepath` tells the compiler where to look for `include`s from our CML.\n-In our case, we're only using `syslog/client.shard.cml`.\n+*Note: `--includepath` tells the compiler where to look for `include`s from our CML.\n+In our case, we're only using `syslog/client.shard.cml`.*\n \n-### Building and publishing a package\n+### Building a Fuchsia package\n \n-Next, we'll build our package as defined by our manifest:\n+Next, we'll build a package manifest as defined by our manifest:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm -o hello_fuchsia -m package/hello_fuchsia.manifest build -output-package-manifest hello_fuchsia_manifest\n+${SDK_PATH}/tools/${ARCH}/pm \\\n+    -o hello_fuchsia_manifest \\\n+    -m pkg/hello_fuchsia.manifest \\\n+    build \\\n+    -output-package-manifest hello_fuchsia_package_manifest\n+```\n+\n+This will produce `pkg/hello_fuchsia_manifest/` which is a package manifest we can\n+publish directly to a repository.\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n ```\n \n-This will produce `hello_fuchsia_manifest` which is a package manifest we can\n-publish directly to a repository. We can set up that repository with:\n+We are now ready to publish the package.\n+\n+## Publishing a Fuchsia package\n+\n+With our package and component manifests setup,\n+we can now publish our package. The first step will\n+be to create a Fuchsia package repository to publish\n+to.\n+\n+### Creating a Fuchsia package repository\n+\n+We can set up our repository with:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm newrepo -repo repo\n+${SDK_PATH}/tools/${ARCH}/pm newrepo \\\n+    -repo pkg/repo\n ```\n \n-And then publish our new package to that repository with:\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 repo/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n+```\n+\n+## Publishing Fuchsia package to repository\n+\n+We can publish our new package to that repository with:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm publish -repo repo -lp -f <(echo \"hello_fuchsia_manifest\")\n+${SDK_PATH}/tools/${ARCH}/pm publish \\\n+    -repo repo \\\n+    -lp -f <(echo \"hello_fuchsia_package_manifest\")\n ```\n \n-Then we can add it to `ffx`'s package server as `hello-fuchsia` using:\n+Then we can add the repository to `ffx`'s package server as `hello-fuchsia` using:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx repository add-from-pm repo -r hello-fuchsia\n+${SDK_PATH}/tools/${ARCH}/ffx repository add-from-pm \\\n+    repo \\\n+    -r hello-fuchsia\n+```\n+\n+## Running a Fuchsia component on an emulator\n+\n+At this point, we are ready to run our Fuchsia\n+component. For reference, our final directory\n+structure will look like:\n+\n+**Final directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/                     (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n+\u2523\u2501 bin/                     ...\n+\u2503  \u2517\u2501 hello_fuchsia         ...\n+\u2523\u2501 src/                     (if using cargo)\n+\u2503  \u2517\u2501 main.rs               ...\n+\u2523\u2501 target/                  ...\n+\u2503  \u2517\u2501 x86_64-fuchsia/       ...\n+\u2503     \u2517\u2501 debug/             ...\n+\u2503        \u2517\u2501 hello_fuchsia   ...\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 repo/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n ```\n \n-### Starting the emulator\n+### Starting the Fuchsia emulator\n \n Start a Fuchsia emulator in a new terminal using:\n \n@@ -235,50 +522,83 @@ ${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}\n ${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless\n ```\n \n-Once the emulator is running, start a package repository server to serve our\n-package to the emulator:\n+### Watching emulator logs\n \n+Once the emulator is running, open a separate terminal to watch the emulator logs:\n+\n+**In separate terminal**\n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx repository server start\n+${SDK_PATH}/tools/${ARCH}/ffx log \\\n+    --since now\n ```\n \n-Once the repository server is up and running, register our repository:\n+### Serving a Fuchsia package\n+\n+Now, start a package repository server to serve our\n+package to the emulator:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx target repository register --repository hello-fuchsia\n+${SDK_PATH}/tools/${ARCH}/ffx repository server start\n ```\n \n-And watch the logs from the emulator in a separate terminal:\n+Once the repository server is up and running, register it with the target Fuchsia system running in the emulator:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx log --since now\n+${SDK_PATH}/tools/${ARCH}/ffx target repository register \\\n+    --repository hello-fuchsia\n ```\n \n+### Running a Fuchsia component\n+\n Finally, run the component:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx component run fuchsia-pkg://hello-fuchsia/hello_fuchsia#meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/ffx component run \\\n+    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm\n ```\n \n On reruns of the component, the `--recreate` argument may also need to be\n passed.\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx component run --recreate fuchsia-pkg://hello-fuchsia/hello_fuchsia#meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/ffx component run \\\n+    --recreate \\\n+    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm\n+```\n+\n+## `.gitignore` extensions\n+\n+Optionally, we can create/extend our `.gitignore` file to ignore files and\n+directories that are not helpful to track:\n+\n+```txt\n+pkg/repo\n+pkg/meta/hello_fuchsia.cm\n+pkg/hello_fuchsia_manifest\n+pkg/hello_fuchsia_package_manifest\n ```\n \n ## Testing\n \n ### Running unit tests\n \n-Tests can be run in the same way as a regular binary, simply by passing `--test`\n-to the `rustc` invocation and then repackaging and rerunning. The test harness\n-will run the applicable unit tests.\n+Tests can be run in the same way as a regular binary.\n+\n+* If using `cargo`, you can simply pass `test --no-run`\n+to the `cargo` invocation and then repackage and rerun the Fuchsia package. From our previous example,\n+this would look like `cargo test --target x86_64-fuchsia --no-run`, and moving the executable\n+binary path found from the line `Executable unittests src/main.rs (target/x86_64-fuchsia/debug/deps/hello_fuchsia-<HASH>)`\n+into `pkg/hello_fuchsia.manifest`.\n+\n+* If using the compiled `rustc`, you can simply pass `--test`\n+to the `rustc` invocation and then repackage and rerun the Fuchsia package.\n+\n+The test harness will run the applicable unit tests.\n \n Often when testing, you may want to pass additional command line arguments to\n your binary. Additional arguments can be set in the component manifest:\n \n-**`hello_fuchsia.cml`**\n+**`pkg/hello_fuchsia.cml`**\n ```txt\n {\n     include: [ \"syslog/client.shard.cml\" ],\n@@ -293,11 +613,20 @@ your binary. Additional arguments can be set in the component manifest:\n This will pass the argument `it_works` to the binary, filtering the tests to\n only those tests that match the pattern. There are many more configuration\n options available in CML including environment variables. More documentation is\n-available on the [Fuchsia devsite](https://fuchsia.dev/reference/cml).\n+available on the [Fuchsia devsite].\n \n ### Running the compiler test suite\n \n Running the Rust test suite on Fuchsia is [not currently supported], but work is\n underway to enable it.\n \n+[Fuchsia team]: https://team-api.infra.rust-lang.org/v1/teams/fuchsia.json\n+[Fuchsia]: https://fuchsia.dev/\n+[source tree]: https://fuchsia.dev/fuchsia-src/get-started/learn/build\n+[rustup]: https://rustup.rs/\n+[cargo]: https://doc.rust-lang.org/cargo/\n+[Fuchsia SDK]: https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core\n+[overview of CML]: https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests\n+[reference for the file format]: https://fuchsia.dev/reference/cml\n+[Fuchsia devsite]: https://fuchsia.dev/reference/cml\n [not currently supported]: https://fxbug.dev/105393"}, {"sha": "e301a793282eb56b9ff73a8c227be000bb976db8", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -83,12 +83,13 @@ pre, .rustdoc.source .example-wrap {\n }\n \n .search-results a:hover {\n-\tbackground-color: #777;\n+\tcolor: #fff !important;\n+\tbackground-color: #3c3c3c;\n }\n \n .search-results a:focus {\n-\tcolor: #000 !important;\n-\tbackground-color: #c6afb3;\n+\tcolor: #fff !important;\n+\tbackground-color: #3c3c3c;\n }\n .search-results a {\n \tcolor: #0096cf;"}, {"sha": "591a1aca74747e77e0ec5d8e30049714576a3bed", "filename": "src/test/codegen/issue-85872-multiple-reverse.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftest%2Fcodegen%2Fissue-85872-multiple-reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftest%2Fcodegen%2Fissue-85872-multiple-reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-85872-multiple-reverse.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -0,0 +1,20 @@\n+// min-llvm-version: 15.0.0\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn u16_be_to_arch(mut data: [u8; 2]) -> [u8; 2] {\n+    // CHECK-LABEL: @u16_be_to_arch\n+    // CHECK: @llvm.bswap.i16\n+    data.reverse();\n+    data\n+}\n+\n+#[no_mangle]\n+pub fn u32_be_to_arch(mut data: [u8; 4]) -> [u8; 4] {\n+    // CHECK-LABEL: @u32_be_to_arch\n+    // CHECK: @llvm.bswap.i32\n+    data.reverse();\n+    data\n+}"}, {"sha": "5e328133e62a19db5ba5cc327a4bff0b5e9f46f6", "filename": "src/test/rustdoc-gui/search-result-color.goml", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -29,6 +29,23 @@ assert-css: (\n     {\"color\": \"rgb(120, 135, 151)\"},\n )\n \n+// Checking the `<a>` container.\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(0, 150, 207)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+\n+// Checking color and background on hover.\n+move-cursor-to: \"//*[@class='desc']//*[text()='Just a normal struct.']\"\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']\",\n+    {\"color\": \"rgb(255, 255, 255)\"},\n+)\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(255, 255, 255)\", \"background-color\": \"rgb(60, 60, 60)\"},\n+)\n+\n // Dark theme\n local-storage: {\n     \"rustdoc-theme\": \"dark\",\n@@ -54,6 +71,23 @@ assert-css: (\n     {\"color\": \"rgb(221, 221, 221)\"},\n )\n \n+// Checking the `<a>` container.\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+\n+// Checking color and background on hover.\n+move-cursor-to: \"//*[@class='desc']//*[text()='Just a normal struct.']\"\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']\",\n+    {\"color\": \"rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(119, 119, 119)\"},\n+)\n+\n // Light theme\n local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n reload:\n@@ -75,6 +109,23 @@ assert-css: (\n     {\"color\": \"rgb(0, 0, 0)\"},\n )\n \n+// Checking the `<a>` container.\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+\n+// Checking color and background on hover.\n+move-cursor-to: \"//*[@class='desc']//*[text()='Just a normal struct.']\"\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']\",\n+    {\"color\": \"rgb(0, 0, 0)\"},\n+)\n+assert-css: (\n+    \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(221, 221, 221)\"},\n+)\n+\n // Check the alias more specifically in the dark theme.\n goto: file://|DOC_PATH|/test_docs/index.html\n // We set the theme so we're sure that the correct values will be used, whatever the computer"}, {"sha": "9f10d92c4e3ab0dc90c60ff09287ade92fbdff6d", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -247,20 +247,6 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n-[[package]]\n-name = \"crossbeam\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2801af0d36612ae591caa9568261fddce32ce6e08a7275ea334a06a4ad021a2c\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-channel\"\n version = \"0.5.6\"\n@@ -296,16 +282,6 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd42583b04998a5363558e5f9291ee5a5ff6b49944332103f251e7479a82aa7\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.8.11\"\n@@ -728,6 +704,7 @@ dependencies = [\n  \"ide-db\",\n  \"itertools\",\n  \"parser\",\n+ \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n  \"text-edit\",\n@@ -895,9 +872,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70c74e2173b2b31f8655d33724b4b45ac13f439386f66290f539c22b144c2212\"\n+checksum = \"a3bcfee315dde785ba887edb540b08765fd7df75a7d948844be6bf5712246734\"\n dependencies = [\n  \"bitflags\",\n  \"serde\",\n@@ -1178,7 +1155,6 @@ dependencies = [\n name = \"proc-macro-srv\"\n version = \"0.0.0\"\n dependencies = [\n- \"crossbeam\",\n  \"expect-test\",\n  \"libloading\",\n  \"mbe\",\n@@ -1254,6 +1230,26 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"protobuf\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ee4a7d8b91800c8f167a6268d1a1026607368e1adc84e98fe044aeb905302f7\"\n+dependencies = [\n+ \"once_cell\",\n+ \"protobuf-support\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"protobuf-support\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ca157fe12fc7ee2e315f2f735e27df41b3d97cdd70ea112824dac1ffb08ee1c\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -1385,6 +1381,7 @@ dependencies = [\n  \"project-model\",\n  \"rayon\",\n  \"rustc-hash\",\n+ \"scip\",\n  \"serde\",\n  \"serde_json\",\n  \"sourcegen\",\n@@ -1471,6 +1468,15 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"scip\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2bfbb10286f69fad7c78db71004b7839bf957788359fe0c479f029f9849136b\"\n+dependencies = [\n+ \"protobuf\",\n+]\n+\n [[package]]\n name = \"scoped-tls\"\n version = \"1.0.0\"\n@@ -1656,6 +1662,26 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.1.4\"\n@@ -1896,6 +1922,7 @@ dependencies = [\n  \"indexmap\",\n  \"paths\",\n  \"rustc-hash\",\n+ \"stdx\",\n ]\n \n [[package]]"}, {"sha": "b388e47dee6e4ecd4411158467ca7e39a4da34f5", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -9,10 +9,11 @@\n use std::{fmt, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n \n use cfg::CfgOptions;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::SmolStr;\n use tt::Subtree;\n-use vfs::{file_set::FileSet, FileId, VfsPath};\n+use vfs::{file_set::FileSet, AnchoredPath, FileId, VfsPath};\n \n /// Files are grouped into source roots. A source root is a directory on the\n /// file systems which is watched for changes. Typically it corresponds to a\n@@ -31,22 +32,30 @@ pub struct SourceRoot {\n     /// Libraries are considered mostly immutable, this assumption is used to\n     /// optimize salsa's query structure\n     pub is_library: bool,\n-    pub(crate) file_set: FileSet,\n+    file_set: FileSet,\n }\n \n impl SourceRoot {\n     pub fn new_local(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: false, file_set }\n     }\n+\n     pub fn new_library(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: true, file_set }\n     }\n+\n     pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n         self.file_set.path_for_file(file)\n     }\n+\n     pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n         self.file_set.file_for_path(path)\n     }\n+\n+    pub fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n+        self.file_set.resolve_path(path)\n+    }\n+\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.file_set.iter()\n     }\n@@ -72,12 +81,19 @@ impl SourceRoot {\n /// <https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/architecture.md#serialization>\n #[derive(Debug, Clone, Default /* Serialize, Deserialize */)]\n pub struct CrateGraph {\n-    arena: FxHashMap<CrateId, CrateData>,\n+    arena: NoHashHashMap<CrateId, CrateData>,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CrateId(pub u32);\n \n+impl stdx::hash::NoHashHashable for CrateId {}\n+impl std::hash::Hash for CrateId {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CrateName(SmolStr);\n \n@@ -342,7 +358,7 @@ impl CrateGraph {\n         // Check if adding a dep from `from` to `to` creates a cycle. To figure\n         // that out, look for a  path in the *opposite* direction, from `to` to\n         // `from`.\n-        if let Some(path) = self.find_path(&mut FxHashSet::default(), dep.crate_id, from) {\n+        if let Some(path) = self.find_path(&mut NoHashHashSet::default(), dep.crate_id, from) {\n             let path = path.into_iter().map(|it| (it, self[it].display_name.clone())).collect();\n             let err = CyclicDependenciesError { path };\n             assert!(err.from().0 == from && err.to().0 == dep.crate_id);\n@@ -365,7 +381,7 @@ impl CrateGraph {\n     /// including the crate itself.\n     pub fn transitive_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut deps = FxHashSet::default();\n+        let mut deps = NoHashHashSet::default();\n \n         while let Some(krate) = worklist.pop() {\n             if !deps.insert(krate) {\n@@ -382,10 +398,10 @@ impl CrateGraph {\n     /// including the crate itself.\n     pub fn transitive_rev_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut rev_deps = FxHashSet::default();\n+        let mut rev_deps = NoHashHashSet::default();\n         rev_deps.insert(of);\n \n-        let mut inverted_graph = FxHashMap::<_, Vec<_>>::default();\n+        let mut inverted_graph = NoHashHashMap::<_, Vec<_>>::default();\n         self.arena.iter().for_each(|(&krate, data)| {\n             data.dependencies\n                 .iter()\n@@ -409,7 +425,7 @@ impl CrateGraph {\n     /// come before the crate itself).\n     pub fn crates_in_topological_order(&self) -> Vec<CrateId> {\n         let mut res = Vec::new();\n-        let mut visited = FxHashSet::default();\n+        let mut visited = NoHashHashSet::default();\n \n         for krate in self.arena.keys().copied() {\n             go(self, &mut visited, &mut res, krate);\n@@ -419,7 +435,7 @@ impl CrateGraph {\n \n         fn go(\n             graph: &CrateGraph,\n-            visited: &mut FxHashSet<CrateId>,\n+            visited: &mut NoHashHashSet<CrateId>,\n             res: &mut Vec<CrateId>,\n             source: CrateId,\n         ) {\n@@ -459,7 +475,7 @@ impl CrateGraph {\n \n     fn find_path(\n         &self,\n-        visited: &mut FxHashSet<CrateId>,\n+        visited: &mut NoHashHashSet<CrateId>,\n         from: CrateId,\n         to: CrateId,\n     ) -> Option<Vec<CrateId>> {"}, {"sha": "da11e4ae7bb96f36b2532b79423407e93786cfcf", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -8,7 +8,7 @@ pub mod fixture;\n \n use std::{panic, sync::Arc};\n \n-use rustc_hash::FxHashSet;\n+use stdx::hash::NoHashHashSet;\n use syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n \n pub use crate::{\n@@ -58,7 +58,7 @@ pub trait FileLoader {\n     /// Text of the file.\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId>;\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>>;\n }\n \n /// Database which stores all significant input facts: source code and project\n@@ -94,10 +94,10 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n \n-    fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>>;\n }\n \n-fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHashSet<CrateId>> {\n+fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>> {\n     let graph = db.crate_graph();\n     let res = graph\n         .iter()\n@@ -120,10 +120,10 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n         // FIXME: this *somehow* should be platform agnostic...\n         let source_root = self.0.file_source_root(path.anchor);\n         let source_root = self.0.source_root(source_root);\n-        source_root.file_set.resolve_path(path)\n+        source_root.resolve_path(path)\n     }\n \n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         let _p = profile::span(\"relevant_crates\");\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)"}, {"sha": "d9f4ef5b7ff578deceae41a0a1866b15d7dd9753", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -125,6 +125,7 @@ pub enum Progress {\n     DidCheckCrate(String),\n     DidFinish(io::Result<()>),\n     DidCancel,\n+    DidFailToRestart(String),\n }\n \n enum Restart {\n@@ -193,10 +194,11 @@ impl FlycheckActor {\n                             self.progress(Progress::DidStart);\n                         }\n                         Err(error) => {\n-                            tracing::error!(\n-                                command = ?self.check_command(),\n-                                %error, \"failed to restart flycheck\"\n-                            );\n+                            self.progress(Progress::DidFailToRestart(format!(\n+                                \"Failed to run the following command: {:?} error={}\",\n+                                self.check_command(),\n+                                error\n+                            )));\n                         }\n                     }\n                 }"}, {"sha": "631ae3cf11fa7e0fc9ddc2d57843ac383d1d6e65", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, MacroCallId, MacroDefKind};\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n use smallvec::SmallVec;\n use syntax::ast;\n \n@@ -12,7 +12,10 @@ use crate::{\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n-    nameres::{attr_resolution::ResolvedAttr, proc_macro::ProcMacroKind, DefMap},\n+    nameres::{\n+        attr_resolution::ResolvedAttr, diagnostics::DefDiagnostic, proc_macro::ProcMacroKind,\n+        DefMap,\n+    },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -210,6 +213,13 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n+        db.trait_data_with_diagnostics(tr).0\n+    }\n+\n+    pub(crate) fn trait_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        tr: TraitId,\n+    ) -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>) {\n         let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n@@ -229,17 +239,20 @@ impl TraitData {\n         let mut collector =\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n         collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n-        let (items, attribute_calls) = collector.finish();\n-\n-        Arc::new(TraitData {\n-            name,\n-            attribute_calls,\n-            items,\n-            is_auto,\n-            is_unsafe,\n-            visibility,\n-            skip_array_during_method_dispatch,\n-        })\n+        let (items, attribute_calls, diagnostics) = collector.finish();\n+\n+        (\n+            Arc::new(TraitData {\n+                name,\n+                attribute_calls,\n+                items,\n+                is_auto,\n+                is_unsafe,\n+                visibility,\n+                skip_array_during_method_dispatch,\n+            }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n@@ -280,7 +293,14 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n-        let _p = profile::span(\"impl_data_query\");\n+        db.impl_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn impl_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: ImplId,\n+    ) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>) {\n+        let _p = profile::span(\"impl_data_with_diagnostics_query\");\n         let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n         let item_tree = tree_id.item_tree(db);\n@@ -293,10 +313,13 @@ impl ImplData {\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::ImplId(id));\n         collector.collect(&item_tree, tree_id.tree_id(), &impl_def.items);\n \n-        let (items, attribute_calls) = collector.finish();\n+        let (items, attribute_calls, diagnostics) = collector.finish();\n         let items = items.into_iter().map(|(_, item)| item).collect();\n \n-        Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n+        (\n+            Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n@@ -437,6 +460,7 @@ struct AssocItemCollector<'a> {\n     db: &'a dyn DefDatabase,\n     module_id: ModuleId,\n     def_map: Arc<DefMap>,\n+    inactive_diagnostics: Vec<DefDiagnostic>,\n     container: ItemContainerId,\n     expander: Expander,\n \n@@ -459,15 +483,21 @@ impl<'a> AssocItemCollector<'a> {\n             expander: Expander::new(db, file_id, module_id),\n             items: Vec::new(),\n             attr_calls: Vec::new(),\n+            inactive_diagnostics: Vec::new(),\n         }\n     }\n \n     fn finish(\n         self,\n-    ) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+    ) -> (\n+        Vec<(Name, AssocItemId)>,\n+        Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n+        Vec<DefDiagnostic>,\n+    ) {\n         (\n             self.items,\n             if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n+            self.inactive_diagnostics,\n         )\n     }\n \n@@ -479,6 +509,12 @@ impl<'a> AssocItemCollector<'a> {\n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n             if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n+                self.inactive_diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    self.module_id.local_id,\n+                    InFile::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n+                    attrs.cfg().unwrap(),\n+                    self.expander.cfg_options().clone(),\n+                ));\n                 continue;\n             }\n "}, {"sha": "40b2f734b7117192afa1fb51b52de20be9a250c8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     intern::Interned,\n     item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::DefMap,\n+    nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n     ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n@@ -106,9 +106,16 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n+    #[salsa::invoke(ImplData::impl_data_with_diagnostics_query)]\n+    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n+    #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n+    fn trait_data_with_diagnostics(&self, tr: TraitId)\n+        -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n "}, {"sha": "ed7e920fd2b83a00ac28b69fca443dc6723a83d1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -73,7 +73,7 @@ impl DefDiagnostic {\n         Self { in_module: container, kind: DefDiagnosticKind::UnresolvedImport { id, index } }\n     }\n \n-    pub(super) fn unconfigured_code(\n+    pub fn unconfigured_code(\n         container: LocalModuleId,\n         ast: AstId<ast::Item>,\n         cfg: CfgExpr,"}, {"sha": "b7908bddaa1cf785d392cf1e7f4449eee0f64e82", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -10,7 +10,7 @@ use base_db::{\n     SourceDatabase, Upcast,\n };\n use hir_expand::{db::AstDatabase, InFile};\n-use rustc_hash::FxHashSet;\n+use stdx::hash::NoHashHashSet;\n use syntax::{algo, ast, AstNode};\n \n use crate::{\n@@ -76,7 +76,7 @@ impl FileLoader for TestDB {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }"}, {"sha": "3f6d0844e9c1f27afc10ece6dde6b3414c169937", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -6,7 +6,7 @@\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n use std::{\n-    cell::{Cell, RefCell},\n+    cell::{Cell, RefCell, RefMut},\n     iter,\n     sync::Arc,\n };\n@@ -330,26 +330,26 @@ impl<'a> TyLoweringContext<'a> {\n                 }\n             }\n             TypeRef::Macro(macro_call) => {\n-                let (expander, recursion_start) = {\n-                    let mut expander = self.expander.borrow_mut();\n-                    if expander.is_some() {\n-                        (Some(expander), false)\n-                    } else {\n-                        *expander = Some(Expander::new(\n-                            self.db.upcast(),\n-                            macro_call.file_id,\n-                            self.resolver.module(),\n-                        ));\n-                        (Some(expander), true)\n+                let (mut expander, recursion_start) = {\n+                    match RefMut::filter_map(self.expander.borrow_mut(), Option::as_mut) {\n+                        Ok(expander) => (expander, false),\n+                        Err(expander) => (\n+                            RefMut::map(expander, |it| {\n+                                it.insert(Expander::new(\n+                                    self.db.upcast(),\n+                                    macro_call.file_id,\n+                                    self.resolver.module(),\n+                                ))\n+                            }),\n+                            true,\n+                        ),\n                     }\n                 };\n-                let ty = if let Some(mut expander) = expander {\n-                    let expander_mut = expander.as_mut().unwrap();\n+                let ty = {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n-                    match expander_mut.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n+                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                            let ctx =\n-                                LowerCtx::new(self.db.upcast(), expander_mut.current_file_id());\n+                            let ctx = LowerCtx::new(self.db.upcast(), expander.current_file_id());\n                             let type_ref = TypeRef::from_ast(&ctx, expanded);\n \n                             drop(expander);\n@@ -364,8 +364,6 @@ impl<'a> TyLoweringContext<'a> {\n                         }\n                         _ => None,\n                     }\n-                } else {\n-                    None\n                 };\n                 if recursion_start {\n                     *self.expander.borrow_mut() = None;\n@@ -479,7 +477,14 @@ impl<'a> TyLoweringContext<'a> {\n                         TyKind::Placeholder(to_placeholder_idx(self.db, param_id.into()))\n                     }\n                     ParamLoweringMode::Variable => {\n-                        let idx = generics.param_idx(param_id.into()).expect(\"matching generics\");\n+                        let idx = match generics.param_idx(param_id.into()) {\n+                            None => {\n+                                never!(\"no matching generics\");\n+                                return (TyKind::Error.intern(Interner), None);\n+                            }\n+                            Some(idx) => idx,\n+                        };\n+\n                         TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n                 }"}, {"sha": "118e5311e9a6414ebf6ab084762257883bb2d4dd", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -10,7 +10,7 @@ use base_db::{\n };\n use hir_def::{db::DefDatabase, ModuleId};\n use hir_expand::db::AstDatabase;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::TextRange;\n use test_utils::extract_annotations;\n \n@@ -80,7 +80,7 @@ impl FileLoader for TestDB {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }\n@@ -102,7 +102,7 @@ impl TestDB {\n         self.module_for_file_opt(file_id).unwrap()\n     }\n \n-    pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+    pub(crate) fn extract_annotations(&self) -> NoHashHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {"}, {"sha": "c7895db1afbf5e523a3e6c9a03f09df74cd0aa73", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1526,6 +1526,34 @@ unsafe impl Storage for InlineStorage {\n     );\n }\n \n+#[test]\n+fn gat_crash_3() {\n+    // FIXME: This test currently crashes rust analyzer in a debug build but not in a\n+    // release build (i.e. for the user). With the assumption that tests will always be run\n+    // in debug mode, we catch the unwind and expect that it panicked. See the\n+    // [`crate::utils::generics`] function for more information.\n+    cov_mark::check!(ignore_gats);\n+    std::panic::catch_unwind(|| {\n+        check_no_mismatches(\n+            r#\"\n+trait Collection {\n+    type Item;\n+    type Member<T>: Collection<Item = T>;\n+    fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n+}\n+struct ConstGen<T, const N: usize> {\n+    data: [T; N],\n+}\n+impl<T, const N: usize> Collection for ConstGen<T, N> {\n+    type Item = T;\n+    type Member<U> = ConstGen<U, N>;\n+}\n+        \"#,\n+        );\n+    })\n+    .expect_err(\"must panic\");\n+}\n+\n #[test]\n fn cfgd_out_self_param() {\n     cov_mark::check!(cfgd_out_self_param);"}, {"sha": "d6638db02851183c5f080dc8cfc3fed5503ae76c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -176,10 +176,19 @@ pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n     if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n         let params = db.generic_params(def);\n+        let parent_params = &parent_generics.as_ref().unwrap().params;\n         let has_consts =\n             params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        return if has_consts {\n-            // XXX: treat const generic associated types as not existing to avoid crashes (#11769)\n+        let parent_has_consts =\n+            parent_params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n+        return if has_consts || parent_has_consts {\n+            // XXX: treat const generic associated types as not existing to avoid crashes\n+            // (#11769)\n+            //\n+            // Note: Also crashes when the parent has const generics (also even if the GAT\n+            // doesn't use them), see `tests::regression::gat_crash_3` for an example.\n+            // Avoids that by disabling GATs when the parent (i.e. `impl` block) has\n+            // const generics (#12193).\n             //\n             // Chalk expects the inner associated type's parameters to come\n             // *before*, not after the trait's generics as we've always done it.\n@@ -264,12 +273,8 @@ impl Generics {\n \n     fn find_param(&self, param: TypeOrConstParamId) -> Option<(usize, &TypeOrConstParamData)> {\n         if param.parent == self.def {\n-            let (idx, (_local_id, data)) = self\n-                .params\n-                .iter()\n-                .enumerate()\n-                .find(|(_, (idx, _))| *idx == param.local_id)\n-                .unwrap();\n+            let (idx, (_local_id, data)) =\n+                self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n             let parent_len = self.parent_generics().map_or(0, Generics::len);\n             Some((parent_len + idx, data))\n         } else {"}, {"sha": "6dccf2ed20b8e8e6dc00534678e42e7a558de526", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -511,6 +511,7 @@ impl Module {\n             .collect()\n     }\n \n+    /// Fills `acc` with the module's diagnostics.\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n@@ -531,11 +532,21 @@ impl Module {\n                         m.diagnostics(db, acc)\n                     }\n                 }\n+                ModuleDef::Trait(t) => {\n+                    for diag in db.trait_data_with_diagnostics(t.id).1.iter() {\n+                        emit_def_diagnostic(db, acc, diag);\n+                    }\n+                    acc.extend(decl.diagnostics(db))\n+                }\n                 _ => acc.extend(decl.diagnostics(db)),\n             }\n         }\n \n         for impl_def in self.impl_defs(db) {\n+            for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n+                emit_def_diagnostic(db, acc, diag);\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),"}, {"sha": "03aa8601d14e1ef3e34207da916dd4574d175bbf", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -171,6 +171,25 @@ fn collect_used_generics<'gp>(\n         ast::Type::RefType(ref_) => generics.extend(\n             ref_.lifetime().and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n         ),\n+        ast::Type::ArrayType(ar) => {\n+            if let Some(expr) = ar.expr() {\n+                if let ast::Expr::PathExpr(p) = expr {\n+                    if let Some(path) = p.path() {\n+                        if let Some(name_ref) = path.as_single_name_ref() {\n+                            if let Some(param) = known_generics.iter().find(|gp| {\n+                                if let ast::GenericParam::ConstParam(cp) = gp {\n+                                    cp.name().map_or(false, |n| n.text() == name_ref.text())\n+                                } else {\n+                                    false\n+                                }\n+                            }) {\n+                                generics.push(param);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         _ => (),\n     });\n     // stable resort to lifetime, type, const\n@@ -357,4 +376,29 @@ impl<'outer, Outer, const OUTER: usize> () {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn issue_11197() {\n+        check_assist(\n+            extract_type_alias,\n+            r#\"\n+struct Foo<T, const N: usize>\n+where\n+    [T; N]: Sized,\n+{\n+    arr: $0[T; N]$0,\n+}\n+            \"#,\n+            r#\"\n+type $0Type<T, const N: usize> = [T; N];\n+\n+struct Foo<T, const N: usize>\n+where\n+    [T; N]: Sized,\n+{\n+    arr: Type<T, N>,\n+}\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "96890ad51a6f941e3399fea772058ab19d653af9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -311,12 +311,16 @@ fn inline(\n     } else {\n         fn_body.clone_for_update()\n     };\n-    if let Some(t) = body.syntax().ancestors().find_map(ast::Impl::cast).and_then(|i| i.self_ty()) {\n-        body.syntax()\n-            .descendants_with_tokens()\n-            .filter_map(NodeOrToken::into_token)\n-            .filter(|tok| tok.kind() == SyntaxKind::SELF_TYPE_KW)\n-            .for_each(|tok| ted::replace(tok, t.syntax()));\n+    if let Some(imp) = body.syntax().ancestors().find_map(ast::Impl::cast) {\n+        if !node.syntax().ancestors().any(|anc| &anc == imp.syntax()) {\n+            if let Some(t) = imp.self_ty() {\n+                body.syntax()\n+                    .descendants_with_tokens()\n+                    .filter_map(NodeOrToken::into_token)\n+                    .filter(|tok| tok.kind() == SyntaxKind::SELF_TYPE_KW)\n+                    .for_each(|tok| ted::replace(tok, t.syntax()));\n+            }\n+        }\n     }\n     let usages_for_locals = |local| {\n         Definition::Local(local)\n@@ -1221,6 +1225,31 @@ impl A {\n fn main() {\n     A(114514);\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn inline_call_with_self_type_but_within_same_impl() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(1919810) }\n+    fn main() {\n+        Self::f$0();\n+    }\n+}\n+\"#,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(1919810) }\n+    fn main() {\n+        Self(1919810);\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "a5e854b74df9d268504f2b4e39684c6002e4c335", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -64,8 +64,11 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) qualified: Qualified,\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n+    #[allow(dead_code)]\n     /// The path of which we are completing the segment\n     pub(super) path: ast::Path,\n+    /// The path of which we are completing the segment in the original file\n+    pub(crate) original_path: Option<ast::Path>,\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,"}, {"sha": "01dd9a234f553c354a47eb3487fc610a37b8df26", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -588,12 +588,15 @@ impl<'a> CompletionContext<'a> {\n         };\n \n         let path = segment.parent_path();\n+        let original_path = find_node_in_file_compensated(sema, original_file, &path);\n+\n         let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n             has_macro_bang: false,\n             qualified: Qualified::No,\n             parent: None,\n             path: path.clone(),\n+            original_path,\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n             use_tree_parent: false,"}, {"sha": "86302cb0678f198687dfe2b4eed26997c642efa6", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -323,9 +323,7 @@ fn render_resolution_path(\n             ..CompletionRelevance::default()\n         });\n \n-        if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-            item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-        }\n+        path_ref_match(completion, path_ctx, &ty, &mut item);\n     };\n     item\n }\n@@ -453,6 +451,29 @@ fn compute_ref_match(\n     None\n }\n \n+fn path_ref_match(\n+    completion: &CompletionContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n+    ty: &hir::Type,\n+    item: &mut Builder,\n+) {\n+    if let Some(original_path) = &path_ctx.original_path {\n+        // At least one char was typed by the user already, in that case look for the original path\n+        if let Some(original_path) = completion.sema.original_ast_node(original_path.clone()) {\n+            if let Some(ref_match) = compute_ref_match(completion, ty) {\n+                item.ref_match(ref_match, original_path.syntax().text_range().start());\n+            }\n+        }\n+    } else {\n+        // completion requested on an empty identifier, there is no path here yet.\n+        // FIXME: This might create inconsistent completions where we show a ref match in macro inputs\n+        // as long as nothing was typed yet\n+        if let Some(ref_match) = compute_ref_match(completion, ty) {\n+            item.ref_match(ref_match, completion.position.offset);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::cmp;"}, {"sha": "37612084604764eee2c66ec568d9dc7fda0c236f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -79,18 +79,18 @@ fn render(\n         ..ctx.completion_relevance()\n     });\n \n-    if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n-        match func_kind {\n-            FuncKind::Function(path_ctx) => {\n-                item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-            }\n-            FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n-                if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+    match func_kind {\n+        FuncKind::Function(path_ctx) => {\n+            super::path_ref_match(completion, path_ctx, &ret_type, &mut item);\n+        }\n+        FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n+            if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+                if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n                     item.ref_match(ref_match, original_expr.syntax().text_range().start());\n                 }\n             }\n-            _ => (),\n         }\n+        _ => (),\n     }\n \n     item.set_documentation(ctx.docs(func))"}, {"sha": "0c791ac570c566f95f511c1a94805ffe03b96af1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -2,13 +2,12 @@\n \n use hir::{db::HirDatabase, Documentation, HasAttrs, StructKind};\n use ide_db::SymbolKind;\n-use syntax::AstNode;\n \n use crate::{\n     context::{CompletionContext, PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem},\n     render::{\n-        compute_ref_match, compute_type_match,\n+        compute_type_match,\n         variant::{\n             format_literal_label, format_literal_lookup, render_record_lit, render_tuple_lit,\n             visible_fields, RenderedLiteral,\n@@ -125,9 +124,8 @@ fn render(\n         type_match: compute_type_match(ctx.completion, &ty),\n         ..ctx.completion_relevance()\n     });\n-    if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-        item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-    }\n+\n+    super::path_ref_match(completion, path_ctx, &ty, &mut item);\n \n     if let Some(import_to_add) = ctx.import_to_add {\n         item.add_import(import_to_add);"}, {"sha": "1ec62a8425a39b3fcb5f1fb6287047e7cf1b4002", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -52,6 +52,7 @@ use hir::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     symbols::FileSymbolKind,\n };\n+use stdx::hash::NoHashHashSet;\n \n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n@@ -118,7 +119,7 @@ impl FileLoader for RootDatabase {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }"}, {"sha": "75d49ff2fd77fc040779ee51238811c3b4348777", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -2,15 +2,15 @@\n //! representation.\n use std::{iter, mem};\n \n-use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n     /// Offset the the beginning of each line, zero-based\n     pub(crate) newlines: Vec<TextSize>,\n     /// List of non-ASCII characters on each line\n-    pub(crate) utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n+    pub(crate) utf16_lines: NoHashHashMap<u32, Vec<Utf16Char>>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -55,7 +55,7 @@ impl Utf16Char {\n \n impl LineIndex {\n     pub fn new(text: &str) -> LineIndex {\n-        let mut utf16_lines = FxHashMap::default();\n+        let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n         let mut newlines = vec![0.into()];"}, {"sha": "7deffe8e0f637917c2ab05cac45ee069037caf69", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -9,7 +9,7 @@ use std::{mem, sync::Arc};\n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n use once_cell::unsync::Lazy;\n-use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::{\n@@ -20,7 +20,7 @@ use crate::{\n \n #[derive(Debug, Default, Clone)]\n pub struct UsageSearchResult {\n-    pub references: FxHashMap<FileId, Vec<FileReference>>,\n+    pub references: NoHashHashMap<FileId, Vec<FileReference>>,\n }\n \n impl UsageSearchResult {\n@@ -45,7 +45,7 @@ impl UsageSearchResult {\n \n impl IntoIterator for UsageSearchResult {\n     type Item = (FileId, Vec<FileReference>);\n-    type IntoIter = <FxHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n+    type IntoIter = <NoHashHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n \n     fn into_iter(self) -> Self::IntoIter {\n         self.references.into_iter()\n@@ -78,17 +78,17 @@ pub enum ReferenceCategory {\n /// e.g. for things like local variables.\n #[derive(Clone, Debug)]\n pub struct SearchScope {\n-    entries: FxHashMap<FileId, Option<TextRange>>,\n+    entries: NoHashHashMap<FileId, Option<TextRange>>,\n }\n \n impl SearchScope {\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+    fn new(entries: NoHashHashMap<FileId, Option<TextRange>>) -> SearchScope {\n         SearchScope { entries }\n     }\n \n     /// Build a search scope spanning the entire crate graph of files.\n     fn crate_graph(db: &RootDatabase) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n \n         let graph = db.crate_graph();\n         for krate in graph.iter() {\n@@ -102,7 +102,7 @@ impl SearchScope {\n \n     /// Build a search scope spanning all the reverse dependencies of the given crate.\n     fn reverse_dependencies(db: &RootDatabase, of: hir::Crate) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n         for rev_dep in of.transitive_reverse_dependencies(db) {\n             let root_file = rev_dep.root_file(db);\n             let source_root_id = db.file_source_root(root_file);\n@@ -117,14 +117,12 @@ impl SearchScope {\n         let root_file = of.root_file(db);\n         let source_root_id = db.file_source_root(root_file);\n         let source_root = db.source_root(source_root_id);\n-        SearchScope {\n-            entries: source_root.iter().map(|id| (id, None)).collect::<FxHashMap<_, _>>(),\n-        }\n+        SearchScope { entries: source_root.iter().map(|id| (id, None)).collect() }\n     }\n \n     /// Build a search scope spanning the given module and all its submodules.\n     fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n \n         let (file_id, range) = {\n             let InFile { file_id, value } = module.definition_source(db);\n@@ -157,7 +155,7 @@ impl SearchScope {\n \n     /// Build an empty search scope.\n     pub fn empty() -> SearchScope {\n-        SearchScope::new(FxHashMap::default())\n+        SearchScope::new(NoHashHashMap::default())\n     }\n \n     /// Build a empty search scope spanning the given file."}, {"sha": "8e338061df43345c6d18b2cd6eb1d7fefb41a707", "filename": "src/tools/rust-analyzer/crates/ide-db/src/source_change.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -6,16 +6,15 @@\n use std::{collections::hash_map::Entry, iter, mem};\n \n use base_db::{AnchoredPathBuf, FileId};\n-use rustc_hash::FxHashMap;\n-use stdx::never;\n+use stdx::{hash::NoHashHashMap, never};\n use syntax::{algo, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::SnippetCap;\n \n #[derive(Default, Debug, Clone)]\n pub struct SourceChange {\n-    pub source_file_edits: FxHashMap<FileId, TextEdit>,\n+    pub source_file_edits: NoHashHashMap<FileId, TextEdit>,\n     pub file_system_edits: Vec<FileSystemEdit>,\n     pub is_snippet: bool,\n }\n@@ -24,7 +23,7 @@ impl SourceChange {\n     /// Creates a new SourceChange with the given label\n     /// from the edits.\n     pub fn from_edits(\n-        source_file_edits: FxHashMap<FileId, TextEdit>,\n+        source_file_edits: NoHashHashMap<FileId, TextEdit>,\n         file_system_edits: Vec<FileSystemEdit>,\n     ) -> Self {\n         SourceChange { source_file_edits, file_system_edits, is_snippet: false }\n@@ -78,8 +77,8 @@ impl Extend<FileSystemEdit> for SourceChange {\n     }\n }\n \n-impl From<FxHashMap<FileId, TextEdit>> for SourceChange {\n-    fn from(source_file_edits: FxHashMap<FileId, TextEdit>) -> SourceChange {\n+impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n+    fn from(source_file_edits: NoHashHashMap<FileId, TextEdit>) -> SourceChange {\n         SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }\n     }\n }"}, {"sha": "04918891b254ca4a45f7cd12ef8187fc60d9c2c2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -106,18 +106,17 @@ fn f() {\n \n     #[test]\n     fn inactive_assoc_item() {\n-        // FIXME these currently don't work, hence the *\n         check(\n             r#\"\n struct Foo;\n impl Foo {\n     #[cfg(any())] pub fn f() {}\n-  //*************************** weak: code is inactive due to #[cfg] directives\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives\n }\n \n trait Bar {\n     #[cfg(any())] pub fn f() {}\n-  //*************************** weak: code is inactive due to #[cfg] directives\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives\n }\n \"#,\n         );"}, {"sha": "73314e0f330bc67a30b291e55bdb588ff30bdde7", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -20,6 +20,7 @@ parser = { path = \"../parser\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n hir = { path = \"../hir\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n \n [dev-dependencies]\n test-utils = { path = \"../test-utils\" }"}, {"sha": "d9834ee63adccf1368681f8397672e93ef0c3e66", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -86,11 +86,9 @@ pub use crate::{errors::SsrError, from_comment::ssr_from_comment, matching::Matc\n \n use crate::{errors::bail, matching::MatchFailureReason};\n use hir::Semantics;\n-use ide_db::{\n-    base_db::{FileId, FilePosition, FileRange},\n-    FxHashMap,\n-};\n+use ide_db::base_db::{FileId, FilePosition, FileRange};\n use resolving::ResolvedRule;\n+use stdx::hash::NoHashHashMap;\n use syntax::{ast, AstNode, SyntaxNode, TextRange};\n use text_edit::TextEdit;\n \n@@ -170,9 +168,9 @@ impl<'db> MatchFinder<'db> {\n     }\n \n     /// Finds matches for all added rules and returns edits for all found matches.\n-    pub fn edits(&self) -> FxHashMap<FileId, TextEdit> {\n+    pub fn edits(&self) -> NoHashHashMap<FileId, TextEdit> {\n         use ide_db::base_db::SourceDatabaseExt;\n-        let mut matches_by_file = FxHashMap::default();\n+        let mut matches_by_file = NoHashHashMap::default();\n         for m in self.matches().matches {\n             matches_by_file\n                 .entry(m.range.file_id)"}, {"sha": "92ce26b422e1dab0f13af86930c8c62e674fd7fd", "filename": "src/tools/rust-analyzer/crates/ide/src/doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -184,10 +184,10 @@ pub(crate) fn resolve_doc_path_for_def(\n         Definition::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::SelfType(it) => it.resolve_doc_path(db, link, ns),\n         Definition::BuiltinAttr(_)\n         | Definition::ToolModule(_)\n         | Definition::BuiltinType(_)\n-        | Definition::SelfType(_)\n         | Definition::Local(_)\n         | Definition::GenericParam(_)\n         | Definition::Label(_)"}, {"sha": "d61d69a090b33850049acfa36b8327ba7b887965", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n-    moniker::{MonikerKind, MonikerResult, PackageInformation},\n+    moniker::{MonikerDescriptorKind, MonikerKind, MonikerResult, PackageInformation},\n     move_item::Direction,\n     navigation_target::NavigationTarget,\n     prime_caches::ParallelPrimeCachesProgress,\n@@ -98,7 +98,7 @@ pub use crate::{\n     static_index::{StaticIndex, StaticIndexedFile, TokenId, TokenStaticData},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},\n-        HlRange,\n+        HighlightConfig, HlRange,\n     },\n };\n pub use hir::{Documentation, Semantics};\n@@ -517,8 +517,12 @@ impl Analysis {\n     }\n \n     /// Computes syntax highlighting for the given file\n-    pub fn highlight(&self, file_id: FileId) -> Cancellable<Vec<HlRange>> {\n-        self.with_db(|db| syntax_highlighting::highlight(db, file_id, None, false))\n+    pub fn highlight(\n+        &self,\n+        highlight_config: HighlightConfig,\n+        file_id: FileId,\n+    ) -> Cancellable<Vec<HlRange>> {\n+        self.with_db(|db| syntax_highlighting::highlight(db, highlight_config, file_id, None))\n     }\n \n     /// Computes all ranges to highlight for a given item in a file.\n@@ -533,9 +537,13 @@ impl Analysis {\n     }\n \n     /// Computes syntax highlighting for the given file range.\n-    pub fn highlight_range(&self, frange: FileRange) -> Cancellable<Vec<HlRange>> {\n+    pub fn highlight_range(\n+        &self,\n+        highlight_config: HighlightConfig,\n+        frange: FileRange,\n+    ) -> Cancellable<Vec<HlRange>> {\n         self.with_db(|db| {\n-            syntax_highlighting::highlight(db, frange.file_id, Some(frange.range), false)\n+            syntax_highlighting::highlight(db, highlight_config, frange.file_id, Some(frange.range))\n         })\n     }\n "}, {"sha": "600a526300c76a10594fe7f4b8b5c28ec4a072b8", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 118, "deletions": 13, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -13,17 +13,39 @@ use syntax::{AstNode, SyntaxKind::*, T};\n \n use crate::{doc_links::token_as_doc_comment, RangeInfo};\n \n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum MonikerDescriptorKind {\n+    Namespace,\n+    Type,\n+    Term,\n+    Method,\n+    TypeParameter,\n+    Parameter,\n+    Macro,\n+    Meta,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct MonikerDescriptor {\n+    pub name: Name,\n+    pub desc: MonikerDescriptorKind,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct MonikerIdentifier {\n-    crate_name: String,\n-    path: Vec<Name>,\n+    pub crate_name: String,\n+    pub description: Vec<MonikerDescriptor>,\n }\n \n impl ToString for MonikerIdentifier {\n     fn to_string(&self) -> String {\n         match self {\n-            MonikerIdentifier { path, crate_name } => {\n-                format!(\"{}::{}\", crate_name, path.iter().map(|x| x.to_string()).join(\"::\"))\n+            MonikerIdentifier { description, crate_name } => {\n+                format!(\n+                    \"{}::{}\",\n+                    crate_name,\n+                    description.iter().map(|x| x.name.to_string()).join(\"::\")\n+                )\n             }\n         }\n     }\n@@ -42,6 +64,12 @@ pub struct MonikerResult {\n     pub package_information: PackageInformation,\n }\n \n+impl MonikerResult {\n+    pub fn from_def(db: &RootDatabase, def: Definition, from_crate: Crate) -> Option<Self> {\n+        def_to_moniker(db, def, from_crate)\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PackageInformation {\n     pub name: String,\n@@ -105,13 +133,23 @@ pub(crate) fn def_to_moniker(\n     def: Definition,\n     from_crate: Crate,\n ) -> Option<MonikerResult> {\n-    if matches!(def, Definition::GenericParam(_) | Definition::SelfType(_) | Definition::Local(_)) {\n+    if matches!(\n+        def,\n+        Definition::GenericParam(_)\n+            | Definition::Label(_)\n+            | Definition::DeriveHelper(_)\n+            | Definition::BuiltinAttr(_)\n+            | Definition::ToolModule(_)\n+    ) {\n         return None;\n     }\n+\n     let module = def.module(db)?;\n     let krate = module.krate();\n-    let mut path = vec![];\n-    path.extend(module.path_to_root(db).into_iter().filter_map(|x| x.name(db)));\n+    let mut description = vec![];\n+    description.extend(module.path_to_root(db).into_iter().filter_map(|x| {\n+        Some(MonikerDescriptor { name: x.name(db)?, desc: MonikerDescriptorKind::Namespace })\n+    }));\n \n     // Handle associated items within a trait\n     if let Some(assoc) = def.as_assoc_item(db) {\n@@ -120,31 +158,98 @@ pub(crate) fn def_to_moniker(\n             AssocItemContainer::Trait(trait_) => {\n                 // Because different traits can have functions with the same name,\n                 // we have to include the trait name as part of the moniker for uniqueness.\n-                path.push(trait_.name(db));\n+                description.push(MonikerDescriptor {\n+                    name: trait_.name(db),\n+                    desc: MonikerDescriptorKind::Type,\n+                });\n             }\n             AssocItemContainer::Impl(impl_) => {\n                 // Because a struct can implement multiple traits, for implementations\n                 // we add both the struct name and the trait name to the path\n                 if let Some(adt) = impl_.self_ty(db).as_adt() {\n-                    path.push(adt.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: adt.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n \n                 if let Some(trait_) = impl_.trait_(db) {\n-                    path.push(trait_.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: trait_.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n             }\n         }\n     }\n \n     if let Definition::Field(it) = def {\n-        path.push(it.parent_def(db).name(db));\n+        description.push(MonikerDescriptor {\n+            name: it.parent_def(db).name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        });\n     }\n \n-    path.push(def.name(db)?);\n+    let name_desc = match def {\n+        // These are handled by top-level guard (for performance).\n+        Definition::GenericParam(_)\n+        | Definition::Label(_)\n+        | Definition::DeriveHelper(_)\n+        | Definition::BuiltinAttr(_)\n+        | Definition::ToolModule(_) => return None,\n+\n+        Definition::Local(local) => {\n+            if !local.is_param(db) {\n+                return None;\n+            }\n+\n+            MonikerDescriptor { name: local.name(db), desc: MonikerDescriptorKind::Parameter }\n+        }\n+        Definition::Macro(m) => {\n+            MonikerDescriptor { name: m.name(db), desc: MonikerDescriptorKind::Macro }\n+        }\n+        Definition::Function(f) => {\n+            MonikerDescriptor { name: f.name(db), desc: MonikerDescriptorKind::Method }\n+        }\n+        Definition::Variant(v) => {\n+            MonikerDescriptor { name: v.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Const(c) => {\n+            MonikerDescriptor { name: c.name(db)?, desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Trait(trait_) => {\n+            MonikerDescriptor { name: trait_.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::TypeAlias(ta) => {\n+            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::TypeParameter }\n+        }\n+        Definition::Module(m) => {\n+            MonikerDescriptor { name: m.name(db)?, desc: MonikerDescriptorKind::Namespace }\n+        }\n+        Definition::BuiltinType(b) => {\n+            MonikerDescriptor { name: b.name(), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::SelfType(imp) => MonikerDescriptor {\n+            name: imp.self_ty(db).as_adt()?.name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::Field(it) => {\n+            MonikerDescriptor { name: it.name(db), desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Adt(adt) => {\n+            MonikerDescriptor { name: adt.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Static(s) => {\n+            MonikerDescriptor { name: s.name(db), desc: MonikerDescriptorKind::Meta }\n+        }\n+    };\n+\n+    description.push(name_desc);\n+\n     Some(MonikerResult {\n         identifier: MonikerIdentifier {\n             crate_name: krate.display_name(db)?.crate_name().to_string(),\n-            path,\n+            description,\n         },\n         kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },\n         package_information: {"}, {"sha": "87b3ef380c5943e0986ea4521be48591c74c9317", "filename": "src/tools/rust-analyzer/crates/ide/src/prime_caches.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -12,8 +12,9 @@ use ide_db::{\n         salsa::{Database, ParallelDatabase, Snapshot},\n         Cancelled, CrateGraph, CrateId, SourceDatabase, SourceDatabaseExt,\n     },\n-    FxHashSet, FxIndexMap,\n+    FxIndexMap,\n };\n+use stdx::hash::NoHashHashSet;\n \n use crate::RootDatabase;\n \n@@ -141,7 +142,7 @@ pub(crate) fn parallel_prime_caches(\n     }\n }\n \n-fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> FxHashSet<CrateId> {\n+fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> NoHashHashSet<CrateId> {\n     // We're only interested in the workspace crates and the `ImportMap`s of their direct\n     // dependencies, though in practice the latter also compute the `DefMap`s.\n     // We don't prime transitive dependencies because they're generally not visible in"}, {"sha": "99614b645e48ff02160b38fcf377f12bf01b4705", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -14,8 +14,9 @@ use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n     search::{ReferenceCategory, SearchScope, UsageSearchResult},\n-    FxHashMap, RootDatabase,\n+    RootDatabase,\n };\n+use stdx::hash::NoHashHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, HasName},\n@@ -29,7 +30,7 @@ use crate::{FilePosition, NavigationTarget, TryToNav};\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     pub declaration: Option<Declaration>,\n-    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n+    pub references: NoHashHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "50371d620eb2a41954412a3f1dd79bc33c18756e", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -14,7 +14,7 @@ mod html;\n mod tests;\n \n use hir::{Name, Semantics};\n-use ide_db::{FxHashMap, RootDatabase};\n+use ide_db::{FxHashMap, RootDatabase, SymbolKind};\n use syntax::{\n     ast, AstNode, AstToken, NodeOrToken, SyntaxKind::*, SyntaxNode, TextRange, WalkEvent, T,\n };\n@@ -24,7 +24,7 @@ use crate::{\n         escape::highlight_escape_string, format::highlight_format_string, highlights::Highlights,\n         macro_::MacroHighlighter, tags::Highlight,\n     },\n-    FileId, HlMod, HlTag,\n+    FileId, HlMod, HlOperator, HlPunct, HlTag,\n };\n \n pub(crate) use html::highlight_as_html;\n@@ -36,6 +36,26 @@ pub struct HlRange {\n     pub binding_hash: Option<u64>,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct HighlightConfig {\n+    /// Whether to highlight strings\n+    pub strings: bool,\n+    /// Whether to highlight punctuation\n+    pub punctuation: bool,\n+    /// Whether to specialize punctuation highlights\n+    pub specialize_punctuation: bool,\n+    /// Whether to highlight operator\n+    pub operator: bool,\n+    /// Whether to specialize operator highlights\n+    pub specialize_operator: bool,\n+    /// Whether to inject highlights into doc comments\n+    pub inject_doc_comment: bool,\n+    /// Whether to highlight the macro call bang\n+    pub macro_bang: bool,\n+    /// Whether to highlight unresolved things be their syntax\n+    pub syntactic_name_ref_highlighting: bool,\n+}\n+\n // Feature: Semantic Syntax Highlighting\n //\n // rust-analyzer highlights the code semantically.\n@@ -155,9 +175,9 @@ pub struct HlRange {\n // image::https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png[]\n pub(crate) fn highlight(\n     db: &RootDatabase,\n+    config: HighlightConfig,\n     file_id: FileId,\n     range_to_highlight: Option<TextRange>,\n-    syntactic_name_ref_highlighting: bool,\n ) -> Vec<HlRange> {\n     let _p = profile::span(\"highlight\");\n     let sema = Semantics::new(db);\n@@ -183,26 +203,18 @@ pub(crate) fn highlight(\n         Some(it) => it.krate(),\n         None => return hl.to_vec(),\n     };\n-    traverse(\n-        &mut hl,\n-        &sema,\n-        file_id,\n-        &root,\n-        krate,\n-        range_to_highlight,\n-        syntactic_name_ref_highlighting,\n-    );\n+    traverse(&mut hl, &sema, config, file_id, &root, krate, range_to_highlight);\n     hl.to_vec()\n }\n \n fn traverse(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     file_id: FileId,\n     root: &SyntaxNode,\n     krate: hir::Crate,\n     range_to_highlight: TextRange,\n-    syntactic_name_ref_highlighting: bool,\n ) {\n     let is_unlinked = sema.to_module_def(file_id).is_none();\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n@@ -323,9 +335,11 @@ fn traverse(\n             Enter(it) => it,\n             Leave(NodeOrToken::Token(_)) => continue,\n             Leave(NodeOrToken::Node(node)) => {\n-                // Doc comment highlighting injection, we do this when leaving the node\n-                // so that we overwrite the highlighting of the doc comment itself.\n-                inject::doc_comment(hl, sema, file_id, &node);\n+                if config.inject_doc_comment {\n+                    // Doc comment highlighting injection, we do this when leaving the node\n+                    // so that we overwrite the highlighting of the doc comment itself.\n+                    inject::doc_comment(hl, sema, config, file_id, &node);\n+                }\n                 continue;\n             }\n         };\n@@ -400,7 +414,8 @@ fn traverse(\n                 let string_to_highlight = ast::String::cast(descended_token.clone());\n                 if let Some((string, expanded_string)) = string.zip(string_to_highlight) {\n                     if string.is_raw() {\n-                        if inject::ra_fixture(hl, sema, &string, &expanded_string).is_some() {\n+                        if inject::ra_fixture(hl, sema, config, &string, &expanded_string).is_some()\n+                        {\n                             continue;\n                         }\n                     }\n@@ -421,7 +436,7 @@ fn traverse(\n                 sema,\n                 krate,\n                 &mut bindings_shadow_count,\n-                syntactic_name_ref_highlighting,\n+                config.syntactic_name_ref_highlighting,\n                 name_like,\n             ),\n             NodeOrToken::Token(token) => highlight::token(sema, token).zip(Some(None)),\n@@ -439,6 +454,29 @@ fn traverse(\n                 // something unresolvable. FIXME: There should be a way to prevent that\n                 continue;\n             }\n+\n+            // apply config filtering\n+            match &mut highlight.tag {\n+                HlTag::StringLiteral if !config.strings => continue,\n+                // If punctuation is disabled, make the macro bang part of the macro call again.\n+                tag @ HlTag::Punctuation(HlPunct::MacroBang) => {\n+                    if !config.macro_bang {\n+                        *tag = HlTag::Symbol(SymbolKind::Macro);\n+                    } else if !config.specialize_punctuation {\n+                        *tag = HlTag::Punctuation(HlPunct::Other);\n+                    }\n+                }\n+                HlTag::Punctuation(_) if !config.punctuation => continue,\n+                tag @ HlTag::Punctuation(_) if !config.specialize_punctuation => {\n+                    *tag = HlTag::Punctuation(HlPunct::Other);\n+                }\n+                HlTag::Operator(_) if !config.operator && highlight.mods.is_empty() => continue,\n+                tag @ HlTag::Operator(_) if !config.specialize_operator => {\n+                    *tag = HlTag::Operator(HlOperator::Other);\n+                }\n+                _ => (),\n+            }\n+\n             if inside_attribute {\n                 highlight |= HlMod::Attribute\n             }"}, {"sha": "e91fd7f12571649cee96e51e652165cad39bc993", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -5,7 +5,10 @@ use oorandom::Rand32;\n use stdx::format_to;\n use syntax::AstNode;\n \n-use crate::{syntax_highlighting::highlight, FileId, RootDatabase};\n+use crate::{\n+    syntax_highlighting::{highlight, HighlightConfig},\n+    FileId, RootDatabase,\n+};\n \n pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n     let parse = db.parse(file_id);\n@@ -20,7 +23,21 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         )\n     }\n \n-    let hl_ranges = highlight(db, file_id, None, false);\n+    let hl_ranges = highlight(\n+        db,\n+        HighlightConfig {\n+            strings: true,\n+            punctuation: true,\n+            specialize_punctuation: true,\n+            specialize_operator: true,\n+            operator: true,\n+            inject_doc_comment: true,\n+            macro_bang: true,\n+            syntactic_name_ref_highlighting: false,\n+        },\n+        file_id,\n+        None,\n+    );\n     let text = parse.tree().syntax().to_string();\n     let mut buf = String::new();\n     buf.push_str(STYLE);"}, {"sha": "9139528c7ed96d08685e6bb646e50aa7482bf5e4", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -15,13 +15,14 @@ use syntax::{\n \n use crate::{\n     doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n-    syntax_highlighting::{highlights::Highlights, injector::Injector},\n+    syntax_highlighting::{highlights::Highlights, injector::Injector, HighlightConfig},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n pub(super) fn ra_fixture(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     literal: &ast::String,\n     expanded: &ast::String,\n ) -> Option<()> {\n@@ -63,7 +64,13 @@ pub(super) fn ra_fixture(\n \n     let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n-    for mut hl_range in analysis.highlight(tmp_file_id).unwrap() {\n+    for mut hl_range in analysis\n+        .highlight(\n+            HighlightConfig { syntactic_name_ref_highlighting: false, ..config },\n+            tmp_file_id,\n+        )\n+        .unwrap()\n+    {\n         for range in inj.map_range_up(hl_range.range) {\n             if let Some(range) = literal.map_range_up(range) {\n                 hl_range.range = range;\n@@ -86,6 +93,7 @@ const RUSTDOC_FENCES: [&str; 2] = [\"```\", \"~~~\"];\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     src_file_id: FileId,\n     node: &SyntaxNode,\n ) {\n@@ -206,7 +214,14 @@ pub(super) fn doc_comment(\n \n     let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n-    if let Ok(ranges) = analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)) {\n+    if let Ok(ranges) = analysis.with_db(|db| {\n+        super::highlight(\n+            db,\n+            HighlightConfig { syntactic_name_ref_highlighting: true, ..config },\n+            tmp_file_id,\n+            None,\n+        )\n+    }) {\n         for HlRange { range, highlight, binding_hash } in ranges {\n             for range in inj.map_range_up(range) {\n                 hl.add(HlRange { range, highlight: highlight | HlMod::Injected, binding_hash });"}, {"sha": "3949f1189bd5ed47d946d46dec67cc2102c7bd40", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -199,7 +199,7 @@ impl fmt::Display for HlTag {\n }\n \n impl HlMod {\n-    const ALL: &'static [HlMod; HlMod::Unsafe as u8 as usize + 1] = &[\n+    const ALL: &'static [HlMod; 19] = &[\n         HlMod::Associated,\n         HlMod::Async,\n         HlMod::Attribute,\n@@ -296,7 +296,7 @@ impl Highlight {\n         Highlight { tag, mods: HlMods::default() }\n     }\n     pub fn is_empty(&self) -> bool {\n-        self.tag == HlTag::None && self.mods == HlMods::default()\n+        self.tag == HlTag::None && self.mods.is_empty()\n     }\n }\n \n@@ -330,6 +330,10 @@ impl ops::BitOr<HlMod> for Highlight {\n }\n \n impl HlMods {\n+    pub fn is_empty(&self) -> bool {\n+        self.0 == 0\n+    }\n+\n     pub fn contains(self, m: HlMod) -> bool {\n         self.0 & m.mask() == m.mask()\n     }"}, {"sha": "eef5baea9839239e3d1b0e8220f102d24cec7db0", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -56,7 +56,7 @@\n     <span class=\"field declaration\">bar</span><span class=\"colon\">:</span> <span class=\"builtin_type\">bool</span><span class=\"comma\">,</span>\n <span class=\"brace\">}</span>\n \n-<span class=\"comment documentation\">/// This is an impl with a code block.</span>\n+<span class=\"comment documentation\">/// This is an impl of </span><span class=\"struct documentation injected intra_doc_link\">[`Foo`]</span><span class=\"comment documentation\"> with a code block.</span>\n <span class=\"comment documentation\">///</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>"}, {"sha": "46cc667fc454f4f08f842017232a1b28e506e2fd", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -4,7 +4,18 @@ use expect_test::{expect_file, ExpectFile};\n use ide_db::SymbolKind;\n use test_utils::{bench, bench_fixture, skip_slow_tests, AssertLinear};\n \n-use crate::{fixture, FileRange, HlTag, TextRange};\n+use crate::{fixture, FileRange, HighlightConfig, HlTag, TextRange};\n+\n+const HL_CONFIG: HighlightConfig = HighlightConfig {\n+    strings: true,\n+    punctuation: true,\n+    specialize_punctuation: true,\n+    specialize_operator: true,\n+    operator: true,\n+    inject_doc_comment: true,\n+    macro_bang: true,\n+    syntactic_name_ref_highlighting: false,\n+};\n \n #[test]\n fn attributes() {\n@@ -613,7 +624,7 @@ struct Foo {\n     bar: bool,\n }\n \n-/// This is an impl with a code block.\n+/// This is an impl of [`Foo`] with a code block.\n ///\n /// ```\n /// fn foo() {\n@@ -996,7 +1007,10 @@ struct Foo {\n \n     // The \"x\"\n     let highlights = &analysis\n-        .highlight_range(FileRange { file_id, range: TextRange::at(45.into(), 1.into()) })\n+        .highlight_range(\n+            HL_CONFIG,\n+            FileRange { file_id, range: TextRange::at(45.into(), 1.into()) },\n+        )\n         .unwrap();\n \n     assert_eq!(&highlights[0].highlight.to_string(), \"field.declaration.public\");\n@@ -1011,7 +1025,7 @@ macro_rules! test {}\n }\"#\n         .trim(),\n     );\n-    let _ = analysis.highlight(file_id).unwrap();\n+    let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n }\n \n /// Highlights the code given by the `ra_fixture` argument, renders the\n@@ -1035,7 +1049,7 @@ fn benchmark_syntax_highlighting_long_struct() {\n     let hash = {\n         let _pt = bench(\"syntax highlighting long struct\");\n         analysis\n-            .highlight(file_id)\n+            .highlight(HL_CONFIG, file_id)\n             .unwrap()\n             .iter()\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n@@ -1061,7 +1075,7 @@ fn syntax_highlighting_not_quadratic() {\n             let time = Instant::now();\n \n             let hash = analysis\n-                .highlight(file_id)\n+                .highlight(HL_CONFIG, file_id)\n                 .unwrap()\n                 .iter()\n                 .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n@@ -1086,7 +1100,7 @@ fn benchmark_syntax_highlighting_parser() {\n     let hash = {\n         let _pt = bench(\"syntax highlighting parser\");\n         analysis\n-            .highlight(file_id)\n+            .highlight(HL_CONFIG, file_id)\n             .unwrap()\n             .iter()\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))"}, {"sha": "17a1e385b77248b4ed974d271745a3ffeddf5919", "filename": "src/tools/rust-analyzer/crates/ide/src/view_crate_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -3,8 +3,9 @@ use std::sync::Arc;\n use dot::{Id, LabelText};\n use ide_db::{\n     base_db::{CrateGraph, CrateId, Dependency, SourceDatabase, SourceDatabaseExt},\n-    FxHashSet, RootDatabase,\n+    RootDatabase,\n };\n+use stdx::hash::NoHashHashSet;\n \n // Feature: View Crate Graph\n //\n@@ -41,7 +42,7 @@ pub(crate) fn view_crate_graph(db: &RootDatabase, full: bool) -> Result<String,\n \n struct DotCrateGraph {\n     graph: Arc<CrateGraph>,\n-    crates_to_render: FxHashSet<CrateId>,\n+    crates_to_render: NoHashHashSet<CrateId>,\n }\n \n type Edge<'a> = (CrateId, &'a Dependency);"}, {"sha": "bc1224af9b212c639bcf80026661554887f19d07", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -13,6 +13,8 @@ pub(super) const PATTERN_FIRST: TokenSet =\n         T![.],\n     ]));\n \n+const PAT_TOP_FIRST: TokenSet = PATTERN_FIRST.union(TokenSet::new(&[T![|]]));\n+\n pub(crate) fn pattern(p: &mut Parser<'_>) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n@@ -228,6 +230,7 @@ fn path_or_macro_pat(p: &mut Parser<'_>) -> CompletedMarker {\n //     let S(_) = ();\n //     let S(_,) = ();\n //     let S(_, .. , x) = ();\n+//     let S(| a) = ();\n // }\n fn tuple_pat_fields(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n@@ -363,6 +366,7 @@ fn ref_pat(p: &mut Parser<'_>) -> CompletedMarker {\n //     let (a,) = ();\n //     let (..) = ();\n //     let () = ();\n+//     let (| a | a, | b) = ((),());\n // }\n fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n@@ -373,13 +377,13 @@ fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     let mut has_rest = false;\n     while !p.at(EOF) && !p.at(T![')']) {\n         has_pat = true;\n-        if !p.at_ts(PATTERN_FIRST) {\n+        if !p.at_ts(PAT_TOP_FIRST) {\n             p.error(\"expected a pattern\");\n             break;\n         }\n         has_rest |= p.at(T![..]);\n \n-        pattern(p);\n+        pattern_top(p);\n         if !p.at(T![')']) {\n             has_comma = true;\n             p.expect(T![,]);\n@@ -393,6 +397,7 @@ fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n // test slice_pat\n // fn main() {\n //     let [a, b, ..] = [];\n+//     let [| a, ..] = [];\n // }\n fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n@@ -405,12 +410,12 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PATTERN_FIRST) {\n+        if !p.at_ts(PAT_TOP_FIRST) {\n             p.error(\"expected a pattern\");\n             break;\n         }\n \n-        pattern(p);\n+        pattern_top(p);\n         if !p.at(ket) {\n             p.expect(T![,]);\n         }"}, {"sha": "dff72ba886fe82db58644325c4f72f57e8f543a5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0024_slice_pat.rast", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -37,6 +37,29 @@ SOURCE_FILE\n             L_BRACK \"[\"\n             R_BRACK \"]\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          SLICE_PAT\n+            L_BRACK \"[\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"a\"\n+            COMMA \",\"\n+            WHITESPACE \" \"\n+            REST_PAT\n+              DOT2 \"..\"\n+            R_BRACK \"]\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          ARRAY_EXPR\n+            L_BRACK \"[\"\n+            R_BRACK \"]\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "855ba89b1e9d9ec911ba50b82cce76ac9f2a21c6", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0024_slice_pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1,3 +1,4 @@\n fn main() {\n     let [a, b, ..] = [];\n+    let [| a, ..] = [];\n }"}, {"sha": "55baf2fdcb4f6a525a166c6c1f40fc049ee7d519", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0026_tuple_pat_fields.rast", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -100,6 +100,29 @@ SOURCE_FILE\n             L_PAREN \"(\"\n             R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          TUPLE_STRUCT_PAT\n+            PATH\n+              PATH_SEGMENT\n+                NAME_REF\n+                  IDENT \"S\"\n+            L_PAREN \"(\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"a\"\n+            R_PAREN \")\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          TUPLE_EXPR\n+            L_PAREN \"(\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "8ec6f4ca93e031ed6f3365e859f0b42ab959e328", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0026_tuple_pat_fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -3,4 +3,5 @@ fn foo() {\n     let S(_) = ();\n     let S(_,) = ();\n     let S(_, .. , x) = ();\n+    let S(| a) = ();\n }"}, {"sha": "1a01e0f69381feff531618d16b6f6cce6b85901a", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0111_tuple_pat.rast", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -85,6 +85,46 @@ SOURCE_FILE\n             L_PAREN \"(\"\n             R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          TUPLE_PAT\n+            L_PAREN \"(\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            OR_PAT\n+              IDENT_PAT\n+                NAME\n+                  IDENT \"a\"\n+              WHITESPACE \" \"\n+              PIPE \"|\"\n+              WHITESPACE \" \"\n+              IDENT_PAT\n+                NAME\n+                  IDENT \"a\"\n+            COMMA \",\"\n+            WHITESPACE \" \"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"b\"\n+            R_PAREN \")\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          TUPLE_EXPR\n+            L_PAREN \"(\"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            COMMA \",\"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "fbd7f48f66bd93da02e9d44cd51d47feae0e2015", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0111_tuple_pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     let (a,) = ();\n     let (..) = ();\n     let () = ();\n+    let (| a | a, | b) = ((),());\n }"}, {"sha": "e39026ac70bfd52e4d78b7b6a08a85d6938306ac", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -24,7 +24,6 @@ tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }\n proc-macro-api = { path = \"../proc-macro-api\", version = \"0.0.0\" }\n-crossbeam = \"0.8.1\"\n \n [dev-dependencies]\n expect-test = \"1.4.0\""}, {"sha": "3679bfc43c980a85a40909698dbe9fc7f27f9715", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -26,6 +26,7 @@ use std::{\n     ffi::OsString,\n     fs,\n     path::{Path, PathBuf},\n+    thread,\n     time::SystemTime,\n };\n \n@@ -65,18 +66,16 @@ impl ProcMacroSrv {\n \n         let macro_body = task.macro_body.to_subtree();\n         let attributes = task.attributes.map(|it| it.to_subtree());\n-        // FIXME: replace this with std's scoped threads once they stabilize\n-        // (then remove dependency on crossbeam)\n-        let result = crossbeam::scope(|s| {\n-            let res = match s\n-                .builder()\n+        let result = thread::scope(|s| {\n+            let thread = thread::Builder::new()\n                 .stack_size(EXPANDER_STACK_SIZE)\n                 .name(task.macro_name.clone())\n-                .spawn(|_| {\n+                .spawn_scoped(s, || {\n                     expander\n                         .expand(&task.macro_name, &macro_body, attributes.as_ref())\n                         .map(|it| FlatTree::new(&it))\n-                }) {\n+                });\n+            let res = match thread {\n                 Ok(handle) => handle.join(),\n                 Err(e) => std::panic::resume_unwind(Box::new(e)),\n             };\n@@ -86,10 +85,6 @@ impl ProcMacroSrv {\n                 Err(e) => std::panic::resume_unwind(e),\n             }\n         });\n-        let result = match result {\n-            Ok(result) => result,\n-            Err(e) => std::panic::resume_unwind(e),\n-        };\n \n         prev_env.rollback();\n "}, {"sha": "9ccb6e9101ef440c4604350b1901060375df66ae", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 357, "deletions": 357, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -185,10 +185,10 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -197,9 +197,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -260,77 +260,85 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            5,\n+                            3,\n                         ),\n-                        edition: Edition2015,\n+                        edition: Edition2018,\n                         version: Some(\n-                            \"0.2.98\",\n+                            \"0.1.0\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"libc\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"libc\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n+                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_CRATE_NAME\": \"hello_world\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO_PKG_NAME\": \"hello-world\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [],\n+                        dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"hello_world\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    4,\n+                                ),\n+                                name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                        ],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n+                            repo: None,\n                         },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        3,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            4,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -339,9 +347,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"it\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"it\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -402,77 +410,69 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        3,\n+                        4,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            4,\n+                            5,\n                         ),\n-                        edition: Edition2018,\n+                        edition: Edition2015,\n                         version: Some(\n-                            \"0.1.0\",\n+                            \"0.2.98\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"it\",\n+                                    \"libc\",\n                                 ),\n-                                canonical_name: \"it\",\n+                                canonical_name: \"libc\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n-                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"hello_world\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"hello-world\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"hello_world\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    4,\n-                                ),\n-                                name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                        ],\n+                        dependencies: [],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: None,\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -567,10 +567,10 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -579,9 +579,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -644,77 +644,10 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            5,\n-                        ),\n-                        edition: Edition2015,\n-                        version: Some(\n-                            \"0.2.98\",\n-                        ),\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                canonical_name: \"libc\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [\n-                                \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n-                            ],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [\n-                                \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n-                            ],\n-                        ),\n-                        env: Env {\n-                            entries: {\n-                                \"CARGO_PKG_LICENSE\": \"\",\n-                                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n-                                \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n-                                \"CARGO_PKG_LICENSE_FILE\": \"\",\n-                                \"CARGO_PKG_HOMEPAGE\": \"\",\n-                                \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n-                                \"CARGO\": \"cargo\",\n-                                \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n-                                \"CARGO_PKG_VERSION_PRE\": \"\",\n-                            },\n-                        },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"crate has not (yet) been built\",\n-                        ),\n-                        origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n-                        },\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        1,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            3,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -723,9 +656,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -864,92 +797,91 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         },\n                         is_proc_macro: false,\n                     },\n-                },\n-            }\"#]],\n-    )\n-}\n-\n-#[test]\n-fn cargo_hello_world_project_model() {\n-    let crate_graph = load_cargo(\"hello-world-metadata.json\");\n-    check_crate_graph(\n-        crate_graph,\n-        expect![[r#\"\n-            CrateGraph {\n-                arena: {\n                     CrateId(\n-                        0,\n+                        4,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            1,\n+                            5,\n                         ),\n-                        edition: Edition2018,\n+                        edition: Edition2015,\n                         version: Some(\n-                            \"0.1.0\",\n+                            \"0.2.98\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"libc\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"libc\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"test\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"test\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n-                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"hello_world\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"hello-world\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    4,\n-                                ),\n-                                name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                        ],\n+                        dependencies: [],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: None,\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n+                },\n+            }\"#]],\n+    )\n+}\n+\n+#[test]\n+fn cargo_hello_world_project_model() {\n+    let crate_graph = load_cargo(\"hello-world-metadata.json\");\n+    check_crate_graph(\n+        crate_graph,\n+        expect![[r#\"\n+            CrateGraph {\n+                arena: {\n                     CrateId(\n-                        2,\n+                        0,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            1,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -958,9 +890,9 @@ fn cargo_hello_world_project_model() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -995,15 +927,6 @@ fn cargo_hello_world_project_model() {\n                             },\n                         },\n                         dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"hello_world\",\n-                                ),\n-                                prelude: true,\n-                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     4,\n@@ -1023,77 +946,87 @@ fn cargo_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            5,\n+                            2,\n                         ),\n-                        edition: Edition2015,\n+                        edition: Edition2018,\n                         version: Some(\n-                            \"0.2.98\",\n+                            \"0.1.0\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"libc\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"libc\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n+                                \"test\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n+                                \"test\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n+                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_CRATE_NAME\": \"hello_world\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO_PKG_NAME\": \"hello-world\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [],\n+                        dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"hello_world\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    4,\n+                                ),\n+                                name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                        ],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n+                            repo: None,\n                         },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            3,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -1102,9 +1035,9 @@ fn cargo_hello_world_project_model() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1243,6 +1176,73 @@ fn cargo_hello_world_project_model() {\n                         },\n                         is_proc_macro: false,\n                     },\n+                    CrateId(\n+                        4,\n+                    ): CrateData {\n+                        root_file_id: FileId(\n+                            5,\n+                        ),\n+                        edition: Edition2015,\n+                        version: Some(\n+                            \"0.2.98\",\n+                        ),\n+                        display_name: Some(\n+                            CrateDisplayName {\n+                                crate_name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                canonical_name: \"libc\",\n+                            },\n+                        ),\n+                        cfg_options: CfgOptions(\n+                            [\n+                                \"debug_assertions\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n+                            ],\n+                        ),\n+                        potential_cfg_options: CfgOptions(\n+                            [\n+                                \"debug_assertions\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n+                            ],\n+                        ),\n+                        env: Env {\n+                            entries: {\n+                                \"CARGO_PKG_LICENSE\": \"\",\n+                                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_PKG_AUTHORS\": \"\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_PKG_LICENSE_FILE\": \"\",\n+                                \"CARGO_PKG_HOMEPAGE\": \"\",\n+                                \"CARGO_PKG_DESCRIPTION\": \"\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO\": \"cargo\",\n+                                \"CARGO_PKG_REPOSITORY\": \"\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_PRE\": \"\",\n+                            },\n+                        },\n+                        dependencies: [],\n+                        proc_macro: Err(\n+                            \"crate has not (yet) been built\",\n+                        ),\n+                        origin: CratesIo {\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n+                        },\n+                        is_proc_macro: false,\n+                    },\n                 },\n             }\"#]],\n     )\n@@ -1301,19 +1301,53 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        10,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            11,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"unwind\",\n+                                    \"core\",\n                                 ),\n-                                canonical_name: \"unwind\",\n+                                canonical_name: \"core\",\n+                            },\n+                        ),\n+                        cfg_options: CfgOptions(\n+                            [],\n+                        ),\n+                        potential_cfg_options: CfgOptions(\n+                            [],\n+                        ),\n+                        env: Env {\n+                            entries: {},\n+                        },\n+                        dependencies: [],\n+                        proc_macro: Err(\n+                            \"no proc macro loaded for sysroot crate\",\n+                        ),\n+                        origin: Lang(\n+                            Core,\n+                        ),\n+                        is_proc_macro: false,\n+                    },\n+                    CrateId(\n+                        2,\n+                    ): CrateData {\n+                        root_file_id: FileId(\n+                            3,\n+                        ),\n+                        edition: Edition2018,\n+                        version: None,\n+                        display_name: Some(\n+                            CrateDisplayName {\n+                                crate_name: CrateName(\n+                                    \"panic_abort\",\n+                                ),\n+                                canonical_name: \"panic_abort\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1335,19 +1369,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        7,\n+                        3,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            8,\n+                            4,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"std_detect\",\n+                                    \"panic_unwind\",\n                                 ),\n-                                canonical_name: \"std_detect\",\n+                                canonical_name: \"panic_unwind\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1413,19 +1447,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        5,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            6,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"core\",\n+                                    \"profiler_builtins\",\n                                 ),\n-                                canonical_name: \"core\",\n+                                canonical_name: \"profiler_builtins\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1442,24 +1476,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Core,\n+                            Other,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        11,\n+                        6,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            12,\n+                            7,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"std\",\n                                 ),\n-                                canonical_name: \"hello_world\",\n+                                canonical_name: \"std\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1472,6 +1506,15 @@ fn rust_project_hello_world_project_model() {\n                             entries: {},\n                         },\n                         dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"alloc\",\n+                                ),\n+                                prelude: true,\n+                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     1,\n@@ -1483,19 +1526,46 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    0,\n+                                    2,\n                                 ),\n                                 name: CrateName(\n-                                    \"alloc\",\n+                                    \"panic_abort\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    6,\n+                                    3,\n                                 ),\n                                 name: CrateName(\n-                                    \"std\",\n+                                    \"panic_unwind\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    5,\n+                                ),\n+                                name: CrateName(\n+                                    \"profiler_builtins\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    7,\n+                                ),\n+                                name: CrateName(\n+                                    \"std_detect\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    8,\n+                                ),\n+                                name: CrateName(\n+                                    \"term\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1506,31 +1576,40 @@ fn rust_project_hello_world_project_model() {\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n-                                prelude: false,\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    10,\n+                                ),\n+                                name: CrateName(\n+                                    \"unwind\",\n+                                ),\n+                                prelude: true,\n                             },\n                         ],\n                         proc_macro: Err(\n-                            \"no proc macro dylib present\",\n+                            \"no proc macro loaded for sysroot crate\",\n+                        ),\n+                        origin: Lang(\n+                            Std,\n                         ),\n-                        origin: CratesIo {\n-                            repo: None,\n-                        },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        8,\n+                        7,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            9,\n+                            8,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"term\",\n+                                    \"std_detect\",\n                                 ),\n-                                canonical_name: \"term\",\n+                                canonical_name: \"std_detect\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1552,19 +1631,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        5,\n+                        8,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            6,\n+                            9,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"profiler_builtins\",\n+                                    \"term\",\n                                 ),\n-                                canonical_name: \"profiler_builtins\",\n+                                canonical_name: \"term\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1586,19 +1665,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        9,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            10,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"panic_abort\",\n+                                    \"test\",\n                                 ),\n-                                canonical_name: \"panic_abort\",\n+                                canonical_name: \"test\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1615,24 +1694,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Other,\n+                            Test,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        9,\n+                        10,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            10,\n+                            11,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"test\",\n+                                    \"unwind\",\n                                 ),\n-                                canonical_name: \"test\",\n+                                canonical_name: \"unwind\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1649,24 +1728,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Test,\n+                            Other,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        6,\n+                        11,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            7,\n+                            12,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"std\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"std\",\n+                                canonical_name: \"hello_world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1679,15 +1758,6 @@ fn rust_project_hello_world_project_model() {\n                             entries: {},\n                         },\n                         dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"alloc\",\n-                                ),\n-                                prelude: true,\n-                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     1,\n@@ -1699,46 +1769,19 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    2,\n-                                ),\n-                                name: CrateName(\n-                                    \"panic_abort\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    3,\n-                                ),\n-                                name: CrateName(\n-                                    \"panic_unwind\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    5,\n-                                ),\n-                                name: CrateName(\n-                                    \"profiler_builtins\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    7,\n+                                    0,\n                                 ),\n                                 name: CrateName(\n-                                    \"std_detect\",\n+                                    \"alloc\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    8,\n+                                    6,\n                                 ),\n                                 name: CrateName(\n-                                    \"term\",\n+                                    \"std\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1749,58 +1792,15 @@ fn rust_project_hello_world_project_model() {\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    10,\n-                                ),\n-                                name: CrateName(\n-                                    \"unwind\",\n-                                ),\n-                                prelude: true,\n+                                prelude: false,\n                             },\n                         ],\n                         proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Std,\n-                        ),\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        3,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            4,\n-                        ),\n-                        edition: Edition2018,\n-                        version: None,\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"panic_unwind\",\n-                                ),\n-                                canonical_name: \"panic_unwind\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [],\n+                            \"no proc macro dylib present\",\n                         ),\n-                        env: Env {\n-                            entries: {},\n+                        origin: CratesIo {\n+                            repo: None,\n                         },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Other,\n-                        ),\n                         is_proc_macro: false,\n                     },\n                 },"}, {"sha": "818bbed6af2ec73600d2bde661d2f420d48969f7", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -13,7 +13,7 @@ use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n use semver::Version;\n-use stdx::always;\n+use stdx::{always, hash::NoHashHashMap};\n \n use crate::{\n     build_scripts::BuildScriptOutput,\n@@ -471,7 +471,7 @@ fn project_json_to_crate_graph(\n         .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, rustc_cfg.clone(), load));\n \n     let mut cfg_cache: FxHashMap<&str, Vec<CfgFlag>> = FxHashMap::default();\n-    let crates: FxHashMap<CrateId, CrateId> = project\n+    let crates: NoHashHashMap<CrateId, CrateId> = project\n         .crates()\n         .filter_map(|(crate_id, krate)| {\n             let file_path = &krate.root_module;"}, {"sha": "5392589186d1db8bcb563f90808b16f29ebd79d9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -22,7 +22,8 @@ anyhow = \"1.0.57\"\n crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.3\"\n-lsp-types = { version = \"0.93.0\", features = [\"proposed\"] }\n+scip = \"0.1.1\"\n+lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.2.4\"\n oorandom = \"11.1.3\"\n@@ -88,5 +89,5 @@ in-rust-tree = [\n     \"proc-macro-srv/sysroot-abi\",\n     \"sourcegen/in-rust-tree\",\n     \"ide/in-rust-tree\",\n-    \"syntax/in-rust-tree\"\n+    \"syntax/in-rust-tree\",\n ]"}, {"sha": "f6a6802972525c09002f18bdc81bacb60a39d3dd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -93,6 +93,7 @@ fn try_main() -> Result<()> {\n         flags::RustAnalyzerCmd::Ssr(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Search(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Lsif(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Scip(cmd) => cmd.run()?,\n     }\n     Ok(())\n }"}, {"sha": "60ba67e25f93bc08679072f4a25de7bf10bdaf7c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -9,6 +9,7 @@ mod analysis_stats;\n mod diagnostics;\n mod ssr;\n mod lsif;\n+mod scip;\n \n mod progress_report;\n "}, {"sha": "aa32654fbdca1efc3afc748e8ac59fb5b28e4c85", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -112,6 +112,10 @@ xflags::xflags! {\n         cmd lsif\n             required path: PathBuf\n         {}\n+\n+        cmd scip\n+            required path: PathBuf\n+        {}\n     }\n }\n \n@@ -140,6 +144,7 @@ pub enum RustAnalyzerCmd {\n     Search(Search),\n     ProcMacro(ProcMacro),\n     Lsif(Lsif),\n+    Scip(Scip),\n }\n \n #[derive(Debug)]\n@@ -207,6 +212,11 @@ pub struct Lsif {\n     pub path: PathBuf,\n }\n \n+#[derive(Debug)]\n+pub struct Scip {\n+    pub path: PathBuf,\n+}\n+\n impl RustAnalyzer {\n     pub const HELP: &'static str = Self::HELP_;\n "}, {"sha": "65cc993c45e7145f8936532d002ba8133b7d6105", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -0,0 +1,448 @@\n+//! SCIP generator\n+\n+use std::{\n+    collections::{HashMap, HashSet},\n+    time::Instant,\n+};\n+\n+use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use hir::Name;\n+use ide::{\n+    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n+    TokenId,\n+};\n+use ide_db::LineIndexDatabase;\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use scip::types as scip_types;\n+use std::env;\n+\n+use crate::cli::{\n+    flags,\n+    load_cargo::{load_workspace, LoadCargoConfig},\n+    Result,\n+};\n+\n+impl flags::Scip {\n+    pub fn run(self) -> Result<()> {\n+        eprintln!(\"Generating SCIP start...\");\n+        let now = Instant::now();\n+        let cargo_config = CargoConfig::default();\n+\n+        let no_progress = &|s| (eprintln!(\"rust-analyzer: Loading {}\", s));\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: true,\n+        };\n+        let path = vfs::AbsPathBuf::assert(env::current_dir()?.join(&self.path));\n+        let rootpath = path.normalize();\n+        let manifest = ProjectManifest::discover_single(&path)?;\n+\n+        let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n+\n+        let (host, vfs, _) = load_workspace(workspace, &load_cargo_config)?;\n+        let db = host.raw_database();\n+        let analysis = host.analysis();\n+\n+        let si = StaticIndex::compute(&analysis);\n+\n+        let mut index = scip_types::Index {\n+            metadata: Some(scip_types::Metadata {\n+                version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n+                tool_info: Some(scip_types::ToolInfo {\n+                    name: \"rust-analyzer\".to_owned(),\n+                    version: \"0.1\".to_owned(),\n+                    arguments: vec![],\n+                    ..Default::default()\n+                })\n+                .into(),\n+                project_root: format!(\n+                    \"file://{}\",\n+                    path.normalize()\n+                        .as_os_str()\n+                        .to_str()\n+                        .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n+                        .to_string()\n+                ),\n+                text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n+                ..Default::default()\n+            })\n+            .into(),\n+            ..Default::default()\n+        };\n+\n+        let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n+        let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n+\n+        for file in si.files {\n+            let mut local_count = 0;\n+            let mut new_local_symbol = || {\n+                let new_symbol = scip::types::Symbol::new_local(local_count);\n+                local_count += 1;\n+\n+                new_symbol\n+            };\n+\n+            let StaticIndexedFile { file_id, tokens, .. } = file;\n+            let relative_path = match get_relative_filepath(&vfs, &rootpath, file_id) {\n+                Some(relative_path) => relative_path,\n+                None => continue,\n+            };\n+\n+            let line_index = LineIndex {\n+                index: db.line_index(file_id),\n+                encoding: OffsetEncoding::Utf8,\n+                endings: LineEndings::Unix,\n+            };\n+\n+            let mut doc = scip_types::Document {\n+                relative_path,\n+                language: \"rust\".to_string(),\n+                ..Default::default()\n+            };\n+\n+            tokens.into_iter().for_each(|(range, id)| {\n+                let token = si.tokens.get(id).unwrap();\n+\n+                let mut occurrence = scip_types::Occurrence::default();\n+                occurrence.range = text_range_to_scip_range(&line_index, range);\n+                occurrence.symbol = match tokens_to_symbol.get(&id) {\n+                    Some(symbol) => symbol.clone(),\n+                    None => {\n+                        let symbol = match &token.moniker {\n+                            Some(moniker) => moniker_to_symbol(&moniker),\n+                            None => new_local_symbol(),\n+                        };\n+\n+                        let symbol = scip::symbol::format_symbol(symbol);\n+                        tokens_to_symbol.insert(id, symbol.clone());\n+                        symbol\n+                    }\n+                };\n+\n+                if let Some(def) = token.definition {\n+                    if def.range == range {\n+                        occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n+                    }\n+\n+                    if !symbols_emitted.contains(&id) {\n+                        symbols_emitted.insert(id);\n+\n+                        let mut symbol_info = scip_types::SymbolInformation::default();\n+                        symbol_info.symbol = occurrence.symbol.clone();\n+                        if let Some(hover) = &token.hover {\n+                            if !hover.markup.as_str().is_empty() {\n+                                symbol_info.documentation = vec![hover.markup.as_str().to_string()];\n+                            }\n+                        }\n+\n+                        doc.symbols.push(symbol_info)\n+                    }\n+                }\n+\n+                doc.occurrences.push(occurrence);\n+            });\n+\n+            if doc.occurrences.is_empty() {\n+                continue;\n+            }\n+\n+            index.documents.push(doc);\n+        }\n+\n+        scip::write_message_to_file(\"index.scip\", index)\n+            .map_err(|err| anyhow::anyhow!(\"Failed to write scip to file: {}\", err))?;\n+\n+        eprintln!(\"Generating SCIP finished {:?}\", now.elapsed());\n+        Ok(())\n+    }\n+}\n+\n+fn get_relative_filepath(\n+    vfs: &vfs::Vfs,\n+    rootpath: &vfs::AbsPathBuf,\n+    file_id: ide::FileId,\n+) -> Option<String> {\n+    Some(vfs.file_path(file_id).as_path()?.strip_prefix(&rootpath)?.as_ref().to_str()?.to_string())\n+}\n+\n+// SCIP Ranges have a (very large) optimization that ranges if they are on the same line\n+// only encode as a vector of [start_line, start_col, end_col].\n+//\n+// This transforms a line index into the optimized SCIP Range.\n+fn text_range_to_scip_range(line_index: &LineIndex, range: TextRange) -> Vec<i32> {\n+    let LineCol { line: start_line, col: start_col } = line_index.index.line_col(range.start());\n+    let LineCol { line: end_line, col: end_col } = line_index.index.line_col(range.end());\n+\n+    if start_line == end_line {\n+        vec![start_line as i32, start_col as i32, end_col as i32]\n+    } else {\n+        vec![start_line as i32, start_col as i32, end_line as i32, end_col as i32]\n+    }\n+}\n+\n+fn new_descriptor_str(\n+    name: &str,\n+    suffix: scip_types::descriptor::Suffix,\n+) -> scip_types::Descriptor {\n+    scip_types::Descriptor {\n+        name: name.to_string(),\n+        disambiguator: \"\".to_string(),\n+        suffix: suffix.into(),\n+        ..Default::default()\n+    }\n+}\n+\n+fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n+    let mut name = name.to_string();\n+    if name.contains(\"'\") {\n+        name = format!(\"`{}`\", name);\n+    }\n+\n+    new_descriptor_str(name.as_str(), suffix)\n+}\n+\n+/// Loosely based on `def_to_moniker`\n+///\n+/// Only returns a Symbol when it's a non-local symbol.\n+///     So if the visibility isn't outside of a document, then it will return None\n+fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+    use scip_types::descriptor::Suffix::*;\n+\n+    let package_name = moniker.package_information.name.clone();\n+    let version = moniker.package_information.version.clone();\n+    let descriptors = moniker\n+        .identifier\n+        .description\n+        .iter()\n+        .map(|desc| {\n+            new_descriptor(\n+                desc.name.clone(),\n+                match desc.desc {\n+                    MonikerDescriptorKind::Namespace => Namespace,\n+                    MonikerDescriptorKind::Type => Type,\n+                    MonikerDescriptorKind::Term => Term,\n+                    MonikerDescriptorKind::Method => Method,\n+                    MonikerDescriptorKind::TypeParameter => TypeParameter,\n+                    MonikerDescriptorKind::Parameter => Parameter,\n+                    MonikerDescriptorKind::Macro => Macro,\n+                    MonikerDescriptorKind::Meta => Meta,\n+                },\n+            )\n+        })\n+        .collect();\n+\n+    scip_types::Symbol {\n+        scheme: \"rust-analyzer\".into(),\n+        package: Some(scip_types::Package {\n+            manager: \"cargo\".to_string(),\n+            name: package_name,\n+            version,\n+            ..Default::default()\n+        })\n+        .into(),\n+        descriptors,\n+        ..Default::default()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use hir::Semantics;\n+    use ide::{AnalysisHost, FilePosition};\n+    use ide_db::defs::IdentClass;\n+    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use scip::symbol::format_symbol;\n+    use syntax::SyntaxKind::*;\n+    use syntax::{AstNode, T};\n+\n+    fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n+        let mut host = AnalysisHost::default();\n+        let change_fixture = ChangeFixture::parse(ra_fixture);\n+        host.raw_database_mut().apply_change(change_fixture.change);\n+        let (file_id, range_or_offset) =\n+            change_fixture.file_position.expect(\"expected a marker ($0)\");\n+        let offset = range_or_offset.expect_offset();\n+        (host, FilePosition { file_id, offset })\n+    }\n+\n+    /// If expected == \"\", then assert that there are no symbols (this is basically local symbol)\n+    #[track_caller]\n+    fn check_symbol(ra_fixture: &str, expected: &str) {\n+        let (host, position) = position(ra_fixture);\n+\n+        let FilePosition { file_id, offset } = position;\n+\n+        let db = host.raw_database();\n+        let sema = &Semantics::new(db);\n+        let file = sema.parse(file_id).syntax().clone();\n+        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n+            IDENT\n+            | INT_NUMBER\n+            | LIFETIME_IDENT\n+            | T![self]\n+            | T![super]\n+            | T![crate]\n+            | T![Self]\n+            | COMMENT => 2,\n+            kind if kind.is_trivia() => 0,\n+            _ => 1,\n+        })\n+        .expect(\"OK OK\");\n+\n+        let navs = sema\n+            .descend_into_macros(original_token.clone())\n+            .into_iter()\n+            .filter_map(|token| {\n+                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+                    it.into_iter().flat_map(|def| {\n+                        let module = def.module(db).unwrap();\n+                        let current_crate = module.krate();\n+\n+                        match MonikerResult::from_def(sema.db, def, current_crate) {\n+                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n+                            None => None,\n+                        }\n+                    })\n+                })\n+            })\n+            .flatten()\n+            .collect::<Vec<_>>();\n+\n+        if expected == \"\" {\n+            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            return;\n+        }\n+\n+        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n+\n+        let res = navs.get(0).unwrap();\n+        let formatted = format_symbol(res.clone());\n+        assert_eq!(formatted, expected);\n+    }\n+\n+    #[test]\n+    fn basic() {\n+        check_symbol(\n+            r#\"\n+//- /lib.rs crate:main deps:foo\n+use foo::example_mod::func;\n+fn main() {\n+    func$0();\n+}\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod example_mod {\n+    pub fn func() {}\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 example_mod/func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait() {\n+        check_symbol(\n+            r#\"\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod module {\n+    pub trait MyTrait {\n+        pub fn func$0() {}\n+    }\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_constant() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            const MY_CONST$0: u8;\n+        }\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#MY_CONST.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_type() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            type MyType$0;\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyTrait::MyType\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#[MyType]\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_impl_function() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            pub fn func() {}\n+        }\n+\n+        struct MyStruct {}\n+\n+        impl MyTrait for MyStruct {\n+            pub fn func$0() {}\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyStruct::MyTrait::func\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyStruct#MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_field() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::St;\n+    fn main() {\n+        let x = St { a$0: 2 };\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub struct St {\n+        pub a: i32,\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 St#a.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn local_symbol_for_local() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::module::func;\n+    fn main() {\n+        func();\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub fn func() {\n+            let x$0 = 2;\n+        }\n+    }\n+    \"#,\n+            \"\",\n+        );\n+    }\n+}"}, {"sha": "54dcb42d99c789ea142e8873dee91d246114692e", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -12,8 +12,8 @@ use std::{ffi::OsString, fmt, iter, path::PathBuf};\n use flycheck::FlycheckConfig;\n use ide::{\n     AssistConfig, CallableSnippets, CompletionConfig, DiagnosticsConfig, ExprFillDefaultMode,\n-    HighlightRelatedConfig, HoverConfig, HoverDocFormat, InlayHintsConfig, JoinLinesConfig,\n-    Snippet, SnippetScope,\n+    HighlightConfig, HighlightRelatedConfig, HoverConfig, HoverDocFormat, InlayHintsConfig,\n+    JoinLinesConfig, Snippet, SnippetScope,\n };\n use ide_db::{\n     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},\n@@ -385,6 +385,34 @@ config_data! {\n         /// available on a nightly build.\n         rustfmt_rangeFormatting_enable: bool = \"false\",\n \n+        /// Inject additional highlighting into doc comments.\n+        ///\n+        /// When enabled, rust-analyzer will highlight rust source in doc comments as well as intra\n+        /// doc links.\n+        semanticHighlighting_doc_comment_inject_enable: bool = \"true\",\n+        /// Use semantic tokens for operators.\n+        ///\n+        /// When disabled, rust-analyzer will emit semantic tokens only for operator tokens when\n+        /// they are tagged with modifiers.\n+        semanticHighlighting_operator_enable: bool = \"true\",\n+        /// Use specialized semantic tokens for operators.\n+        ///\n+        /// When enabled, rust-analyzer will emit special token types for operator tokens instead\n+        /// of the generic `operator` token type.\n+        semanticHighlighting_operator_specialization_enable: bool = \"false\",\n+        /// Use semantic tokens for punctuations.\n+        ///\n+        /// When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\n+        /// they are tagged with modifiers or have a special role.\n+        semanticHighlighting_punctuation_enable: bool = \"false\",\n+        /// When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\n+        /// calls.\n+        semanticHighlighting_punctuation_separate_macro_bang: bool = \"false\",\n+        /// Use specialized semantic tokens for punctuations.\n+        ///\n+        /// When enabled, rust-analyzer will emit special token types for punctuation tokens instead\n+        /// of the generic `punctuation` token type.\n+        semanticHighlighting_punctuation_specialization_enable: bool = \"false\",\n         /// Use semantic tokens for strings.\n         ///\n         /// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.\n@@ -1171,8 +1199,19 @@ impl Config {\n         }\n     }\n \n-    pub fn highlighting_strings(&self) -> bool {\n-        self.data.semanticHighlighting_strings_enable\n+    pub fn highlighting_config(&self) -> HighlightConfig {\n+        HighlightConfig {\n+            strings: self.data.semanticHighlighting_strings_enable,\n+            punctuation: self.data.semanticHighlighting_punctuation_enable,\n+            specialize_punctuation: self\n+                .data\n+                .semanticHighlighting_punctuation_specialization_enable,\n+            macro_bang: self.data.semanticHighlighting_punctuation_separate_macro_bang,\n+            operator: self.data.semanticHighlighting_operator_enable,\n+            specialize_operator: self.data.semanticHighlighting_operator_specialization_enable,\n+            inject_doc_comment: self.data.semanticHighlighting_doc_comment_inject_enable,\n+            syntactic_name_ref_highlighting: false,\n+        }\n     }\n \n     pub fn hover(&self) -> HoverConfig {"}, {"sha": "f516c194da467f7afee60a4f123aeff25c06b26d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -4,11 +4,12 @@ pub(crate) mod to_proto;\n use std::{mem, sync::Arc};\n \n use ide::FileId;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use ide_db::FxHashMap;\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<FxHashMap<usize, FxHashMap<FileId, Vec<Fix>>>>;\n+pub(crate) type CheckFixes = Arc<NoHashHashMap<usize, NoHashHashMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -19,12 +20,12 @@ pub struct DiagnosticsMapConfig {\n \n #[derive(Debug, Default, Clone)]\n pub(crate) struct DiagnosticCollection {\n-    // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>\n-    pub(crate) native: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    // FIXME: should be NoHashHashMap<FileId, Vec<ra_id::Diagnostic>>\n+    pub(crate) native: NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: FxHashMap<usize, FxHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n+    pub(crate) check: NoHashHashMap<usize, NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n-    changes: FxHashSet<FileId>,\n+    changes: NoHashHashSet<FileId>,\n }\n \n #[derive(Debug, Clone)]\n@@ -105,7 +106,7 @@ impl DiagnosticCollection {\n         native.chain(check)\n     }\n \n-    pub(crate) fn take_changes(&mut self) -> Option<FxHashSet<FileId>> {\n+    pub(crate) fn take_changes(&mut self) -> Option<NoHashHashSet<FileId>> {\n         if self.changes.is_empty() {\n             return None;\n         }"}, {"sha": "706e1742dffde38a695d9119413849ad8fb497ac", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -14,6 +14,7 @@ use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n use project_model::{CargoWorkspace, ProjectWorkspace, Target, WorkspaceBuildScripts};\n use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use vfs::AnchoredPathBuf;\n \n use crate::{\n@@ -67,7 +68,7 @@ pub(crate) struct GlobalState {\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n-    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) vfs_config_version: u32,\n     pub(crate) vfs_progress_config_version: u32,\n     pub(crate) vfs_progress_n_total: usize,\n@@ -113,7 +114,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) check_fixes: CheckFixes,\n     mem_docs: MemDocs,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n-    vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n@@ -157,7 +158,7 @@ impl GlobalState {\n             flycheck_sender,\n             flycheck_receiver,\n \n-            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), NoHashHashMap::default()))),\n             vfs_config_version: 0,\n             vfs_progress_config_version: 0,\n             vfs_progress_n_total: 0,"}, {"sha": "d89f0f5a3cf456d24c7889deec9355b3098e7a34", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1504,10 +1504,8 @@ pub(crate) fn handle_semantic_tokens_full(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(file_id)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     // Unconditionally cache the tokens\n     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());\n@@ -1525,10 +1523,8 @@ pub(crate) fn handle_semantic_tokens_full_delta(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(file_id)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     let mut cache = snap.semantic_tokens_cache.lock();\n     let cached_tokens = cache.entry(params.text_document.uri).or_default();\n@@ -1556,10 +1552,8 @@ pub(crate) fn handle_semantic_tokens_range(\n     let text = snap.analysis.file_text(frange.file_id)?;\n     let line_index = snap.file_line_index(frange.file_id)?;\n \n-    let highlights = snap.analysis.highlight_range(frange)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight_range(snap.config.highlighting_config(), frange)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n "}, {"sha": "3cfbc2e4e45037cbaefb2a5116987ba995bfaa3a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -328,8 +328,33 @@ impl GlobalState {\n                 }\n \n                 let uri = file_id_to_url(&self.vfs.read().0, file_id);\n-                let diagnostics =\n+                let mut diagnostics =\n                     self.diagnostics.diagnostics_for(file_id).cloned().collect::<Vec<_>>();\n+\n+                // VSCode assumes diagnostic messages to be non-empty strings, so we need to patch\n+                // empty diagnostics. Neither the docs of VSCode nor the LSP spec say whether\n+                // diagnostic messages are actually allowed to be empty or not and patching this\n+                // in the VSCode client does not work as the assertion happens in the protocol\n+                // conversion. So this hack is here to stay, and will be considered a hack\n+                // until the LSP decides to state that empty messages are allowed.\n+\n+                // See https://github.com/rust-lang/rust-analyzer/issues/11404\n+                // See https://github.com/rust-lang/rust-analyzer/issues/13130\n+                let patch_empty = |message: &mut String| {\n+                    if message.is_empty() {\n+                        *message = \" \".to_string();\n+                    }\n+                };\n+\n+                for d in &mut diagnostics {\n+                    patch_empty(&mut d.message);\n+                    if let Some(dri) = &mut d.related_information {\n+                        for dri in dri {\n+                            patch_empty(&mut dri.message);\n+                        }\n+                    }\n+                }\n+\n                 let version = from_proto::vfs_path(&uri)\n                     .map(|path| self.mem_docs.get(&path).map(|it| it.version))\n                     .unwrap_or_default();\n@@ -529,6 +554,13 @@ impl GlobalState {\n                     }\n                     flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n                     flycheck::Progress::DidCancel => (Progress::End, None),\n+                    flycheck::Progress::DidFailToRestart(err) => {\n+                        self.show_and_log_error(\n+                            \"cargo check failed\".to_string(),\n+                            Some(err.to_string()),\n+                        );\n+                        return;\n+                    }\n                     flycheck::Progress::DidFinish(result) => {\n                         if let Err(err) = result {\n                             self.show_and_log_error("}, {"sha": "c48410ed55e98472d4f0bc774703225e80048cad", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 107, "deletions": 84, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -8,107 +8,130 @@ use lsp_types::{\n };\n \n macro_rules! define_semantic_token_types {\n-    ($(($ident:ident, $string:literal)),*$(,)?) => {\n-        $(pub(crate) const $ident: SemanticTokenType = SemanticTokenType::new($string);)*\n+    (\n+        standard {\n+            $($standard:ident),*$(,)?\n+        }\n+        custom {\n+            $(($custom:ident, $string:literal)),*$(,)?\n+        }\n+\n+    ) => {\n+        $(pub(crate) const $standard: SemanticTokenType = SemanticTokenType::$standard;)*\n+        $(pub(crate) const $custom: SemanticTokenType = SemanticTokenType::new($string);)*\n \n         pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n-            SemanticTokenType::COMMENT,\n-            SemanticTokenType::KEYWORD,\n-            SemanticTokenType::STRING,\n-            SemanticTokenType::NUMBER,\n-            SemanticTokenType::REGEXP,\n-            SemanticTokenType::OPERATOR,\n-            SemanticTokenType::NAMESPACE,\n-            SemanticTokenType::TYPE,\n-            SemanticTokenType::STRUCT,\n-            SemanticTokenType::CLASS,\n-            SemanticTokenType::INTERFACE,\n-            SemanticTokenType::ENUM,\n-            SemanticTokenType::ENUM_MEMBER,\n-            SemanticTokenType::TYPE_PARAMETER,\n-            SemanticTokenType::FUNCTION,\n-            SemanticTokenType::METHOD,\n-            SemanticTokenType::PROPERTY,\n-            SemanticTokenType::MACRO,\n-            SemanticTokenType::VARIABLE,\n-            SemanticTokenType::PARAMETER,\n-            $($ident),*\n+            $(SemanticTokenType::$standard,)*\n+            $($custom),*\n         ];\n     };\n }\n \n define_semantic_token_types![\n-    (ANGLE, \"angle\"),\n-    (ARITHMETIC, \"arithmetic\"),\n-    (ATTRIBUTE, \"attribute\"),\n-    (ATTRIBUTE_BRACKET, \"attributeBracket\"),\n-    (BITWISE, \"bitwise\"),\n-    (BOOLEAN, \"boolean\"),\n-    (BRACE, \"brace\"),\n-    (BRACKET, \"bracket\"),\n-    (BUILTIN_ATTRIBUTE, \"builtinAttribute\"),\n-    (BUILTIN_TYPE, \"builtinType\"),\n-    (CHAR, \"character\"),\n-    (COLON, \"colon\"),\n-    (COMMA, \"comma\"),\n-    (COMPARISON, \"comparison\"),\n-    (CONST_PARAMETER, \"constParameter\"),\n-    (DERIVE, \"derive\"),\n-    (DERIVE_HELPER, \"deriveHelper\"),\n-    (DOT, \"dot\"),\n-    (ESCAPE_SEQUENCE, \"escapeSequence\"),\n-    (FORMAT_SPECIFIER, \"formatSpecifier\"),\n-    (GENERIC, \"generic\"),\n-    (LABEL, \"label\"),\n-    (LIFETIME, \"lifetime\"),\n-    (LOGICAL, \"logical\"),\n-    (MACRO_BANG, \"macroBang\"),\n-    (OPERATOR, \"operator\"),\n-    (PARENTHESIS, \"parenthesis\"),\n-    (PUNCTUATION, \"punctuation\"),\n-    (SELF_KEYWORD, \"selfKeyword\"),\n-    (SELF_TYPE_KEYWORD, \"selfTypeKeyword\"),\n-    (SEMICOLON, \"semicolon\"),\n-    (TYPE_ALIAS, \"typeAlias\"),\n-    (TOOL_MODULE, \"toolModule\"),\n-    (UNION, \"union\"),\n-    (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n+    standard {\n+        COMMENT,\n+        DECORATOR,\n+        ENUM_MEMBER,\n+        ENUM,\n+        FUNCTION,\n+        INTERFACE,\n+        KEYWORD,\n+        MACRO,\n+        METHOD,\n+        NAMESPACE,\n+        NUMBER,\n+        OPERATOR,\n+        PARAMETER,\n+        PROPERTY,\n+        STRING,\n+        STRUCT,\n+        TYPE_PARAMETER,\n+        VARIABLE,\n+    }\n+\n+    custom {\n+        (ANGLE, \"angle\"),\n+        (ARITHMETIC, \"arithmetic\"),\n+        (ATTRIBUTE, \"attribute\"),\n+        (ATTRIBUTE_BRACKET, \"attributeBracket\"),\n+        (BITWISE, \"bitwise\"),\n+        (BOOLEAN, \"boolean\"),\n+        (BRACE, \"brace\"),\n+        (BRACKET, \"bracket\"),\n+        (BUILTIN_ATTRIBUTE, \"builtinAttribute\"),\n+        (BUILTIN_TYPE, \"builtinType\"),\n+        (CHAR, \"character\"),\n+        (COLON, \"colon\"),\n+        (COMMA, \"comma\"),\n+        (COMPARISON, \"comparison\"),\n+        (CONST_PARAMETER, \"constParameter\"),\n+        (DERIVE, \"derive\"),\n+        (DERIVE_HELPER, \"deriveHelper\"),\n+        (DOT, \"dot\"),\n+        (ESCAPE_SEQUENCE, \"escapeSequence\"),\n+        (FORMAT_SPECIFIER, \"formatSpecifier\"),\n+        (GENERIC, \"generic\"),\n+        (LABEL, \"label\"),\n+        (LIFETIME, \"lifetime\"),\n+        (LOGICAL, \"logical\"),\n+        (MACRO_BANG, \"macroBang\"),\n+        (PARENTHESIS, \"parenthesis\"),\n+        (PUNCTUATION, \"punctuation\"),\n+        (SELF_KEYWORD, \"selfKeyword\"),\n+        (SELF_TYPE_KEYWORD, \"selfTypeKeyword\"),\n+        (SEMICOLON, \"semicolon\"),\n+        (TYPE_ALIAS, \"typeAlias\"),\n+        (TOOL_MODULE, \"toolModule\"),\n+        (UNION, \"union\"),\n+        (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n+    }\n ];\n \n macro_rules! define_semantic_token_modifiers {\n-    ($(($ident:ident, $string:literal)),*$(,)?) => {\n-        $(pub(crate) const $ident: SemanticTokenModifier = SemanticTokenModifier::new($string);)*\n+    (\n+        standard {\n+            $($standard:ident),*$(,)?\n+        }\n+        custom {\n+            $(($custom:ident, $string:literal)),*$(,)?\n+        }\n+\n+    ) => {\n+\n+        $(pub(crate) const $standard: SemanticTokenModifier = SemanticTokenModifier::$standard;)*\n+        $(pub(crate) const $custom: SemanticTokenModifier = SemanticTokenModifier::new($string);)*\n \n         pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n-            SemanticTokenModifier::DOCUMENTATION,\n-            SemanticTokenModifier::DECLARATION,\n-            SemanticTokenModifier::DEFINITION,\n-            SemanticTokenModifier::STATIC,\n-            SemanticTokenModifier::ABSTRACT,\n-            SemanticTokenModifier::DEPRECATED,\n-            SemanticTokenModifier::READONLY,\n-            SemanticTokenModifier::DEFAULT_LIBRARY,\n-            $($ident),*\n+            $(SemanticTokenModifier::$standard,)*\n+            $($custom),*\n         ];\n     };\n }\n \n define_semantic_token_modifiers![\n-    (ASYNC, \"async\"),\n-    (ATTRIBUTE_MODIFIER, \"attribute\"),\n-    (CALLABLE, \"callable\"),\n-    (CONSTANT, \"constant\"),\n-    (CONSUMING, \"consuming\"),\n-    (CONTROL_FLOW, \"controlFlow\"),\n-    (CRATE_ROOT, \"crateRoot\"),\n-    (INJECTED, \"injected\"),\n-    (INTRA_DOC_LINK, \"intraDocLink\"),\n-    (LIBRARY, \"library\"),\n-    (MUTABLE, \"mutable\"),\n-    (PUBLIC, \"public\"),\n-    (REFERENCE, \"reference\"),\n-    (TRAIT_MODIFIER, \"trait\"),\n-    (UNSAFE, \"unsafe\"),\n+    standard {\n+        DOCUMENTATION,\n+        DECLARATION,\n+        STATIC,\n+        DEFAULT_LIBRARY,\n+    }\n+    custom {\n+        (ASYNC, \"async\"),\n+        (ATTRIBUTE_MODIFIER, \"attribute\"),\n+        (CALLABLE, \"callable\"),\n+        (CONSTANT, \"constant\"),\n+        (CONSUMING, \"consuming\"),\n+        (CONTROL_FLOW, \"controlFlow\"),\n+        (CRATE_ROOT, \"crateRoot\"),\n+        (INJECTED, \"injected\"),\n+        (INTRA_DOC_LINK, \"intraDocLink\"),\n+        (LIBRARY, \"library\"),\n+        (MUTABLE, \"mutable\"),\n+        (PUBLIC, \"public\"),\n+        (REFERENCE, \"reference\"),\n+        (TRAIT_MODIFIER, \"trait\"),\n+        (UNSAFE, \"unsafe\"),\n+    }\n ];\n \n #[derive(Default)]"}, {"sha": "102cd602950439a4188b5006116353dd164299f8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -517,7 +517,6 @@ pub(crate) fn semantic_tokens(\n     text: &str,\n     line_index: &LineIndex,\n     highlights: Vec<HlRange>,\n-    highlight_strings: bool,\n ) -> lsp_types::SemanticTokens {\n     let id = TOKEN_RESULT_COUNTER.fetch_add(1, Ordering::SeqCst).to_string();\n     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);\n@@ -526,10 +525,8 @@ pub(crate) fn semantic_tokens(\n         if highlight_range.highlight.is_empty() {\n             continue;\n         }\n+\n         let (ty, mods) = semantic_token_type_and_modifiers(highlight_range.highlight);\n-        if !highlight_strings && ty == lsp_types::SemanticTokenType::STRING {\n-            continue;\n-        }\n         let token_index = semantic_tokens::type_index(ty);\n         let modifier_bitset = mods.0;\n \n@@ -561,55 +558,55 @@ fn semantic_token_type_and_modifiers(\n     let mut mods = semantic_tokens::ModifierSet::default();\n     let type_ = match highlight.tag {\n         HlTag::Symbol(symbol) => match symbol {\n-            SymbolKind::Attribute => semantic_tokens::ATTRIBUTE,\n+            SymbolKind::Attribute => semantic_tokens::DECORATOR,\n             SymbolKind::Derive => semantic_tokens::DERIVE,\n             SymbolKind::DeriveHelper => semantic_tokens::DERIVE_HELPER,\n-            SymbolKind::Module => lsp_types::SemanticTokenType::NAMESPACE,\n+            SymbolKind::Module => semantic_tokens::NAMESPACE,\n             SymbolKind::Impl => semantic_tokens::TYPE_ALIAS,\n-            SymbolKind::Field => lsp_types::SemanticTokenType::PROPERTY,\n-            SymbolKind::TypeParam => lsp_types::SemanticTokenType::TYPE_PARAMETER,\n+            SymbolKind::Field => semantic_tokens::PROPERTY,\n+            SymbolKind::TypeParam => semantic_tokens::TYPE_PARAMETER,\n             SymbolKind::ConstParam => semantic_tokens::CONST_PARAMETER,\n             SymbolKind::LifetimeParam => semantic_tokens::LIFETIME,\n             SymbolKind::Label => semantic_tokens::LABEL,\n-            SymbolKind::ValueParam => lsp_types::SemanticTokenType::PARAMETER,\n+            SymbolKind::ValueParam => semantic_tokens::PARAMETER,\n             SymbolKind::SelfParam => semantic_tokens::SELF_KEYWORD,\n             SymbolKind::SelfType => semantic_tokens::SELF_TYPE_KEYWORD,\n-            SymbolKind::Local => lsp_types::SemanticTokenType::VARIABLE,\n+            SymbolKind::Local => semantic_tokens::VARIABLE,\n             SymbolKind::Function => {\n                 if highlight.mods.contains(HlMod::Associated) {\n-                    lsp_types::SemanticTokenType::METHOD\n+                    semantic_tokens::METHOD\n                 } else {\n-                    lsp_types::SemanticTokenType::FUNCTION\n+                    semantic_tokens::FUNCTION\n                 }\n             }\n             SymbolKind::Const => {\n                 mods |= semantic_tokens::CONSTANT;\n-                mods |= lsp_types::SemanticTokenModifier::STATIC;\n-                lsp_types::SemanticTokenType::VARIABLE\n+                mods |= semantic_tokens::STATIC;\n+                semantic_tokens::VARIABLE\n             }\n             SymbolKind::Static => {\n-                mods |= lsp_types::SemanticTokenModifier::STATIC;\n-                lsp_types::SemanticTokenType::VARIABLE\n+                mods |= semantic_tokens::STATIC;\n+                semantic_tokens::VARIABLE\n             }\n-            SymbolKind::Struct => lsp_types::SemanticTokenType::STRUCT,\n-            SymbolKind::Enum => lsp_types::SemanticTokenType::ENUM,\n-            SymbolKind::Variant => lsp_types::SemanticTokenType::ENUM_MEMBER,\n+            SymbolKind::Struct => semantic_tokens::STRUCT,\n+            SymbolKind::Enum => semantic_tokens::ENUM,\n+            SymbolKind::Variant => semantic_tokens::ENUM_MEMBER,\n             SymbolKind::Union => semantic_tokens::UNION,\n             SymbolKind::TypeAlias => semantic_tokens::TYPE_ALIAS,\n-            SymbolKind::Trait => lsp_types::SemanticTokenType::INTERFACE,\n-            SymbolKind::Macro => lsp_types::SemanticTokenType::MACRO,\n+            SymbolKind::Trait => semantic_tokens::INTERFACE,\n+            SymbolKind::Macro => semantic_tokens::MACRO,\n             SymbolKind::BuiltinAttr => semantic_tokens::BUILTIN_ATTRIBUTE,\n             SymbolKind::ToolModule => semantic_tokens::TOOL_MODULE,\n         },\n         HlTag::AttributeBracket => semantic_tokens::ATTRIBUTE_BRACKET,\n         HlTag::BoolLiteral => semantic_tokens::BOOLEAN,\n         HlTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n-        HlTag::ByteLiteral | HlTag::NumericLiteral => lsp_types::SemanticTokenType::NUMBER,\n+        HlTag::ByteLiteral | HlTag::NumericLiteral => semantic_tokens::NUMBER,\n         HlTag::CharLiteral => semantic_tokens::CHAR,\n-        HlTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HlTag::Comment => semantic_tokens::COMMENT,\n         HlTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n         HlTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n-        HlTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HlTag::Keyword => semantic_tokens::KEYWORD,\n         HlTag::None => semantic_tokens::GENERIC,\n         HlTag::Operator(op) => match op {\n             HlOperator::Bitwise => semantic_tokens::BITWISE,\n@@ -618,7 +615,7 @@ fn semantic_token_type_and_modifiers(\n             HlOperator::Comparison => semantic_tokens::COMPARISON,\n             HlOperator::Other => semantic_tokens::OPERATOR,\n         },\n-        HlTag::StringLiteral => lsp_types::SemanticTokenType::STRING,\n+        HlTag::StringLiteral => semantic_tokens::STRING,\n         HlTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n         HlTag::Punctuation(punct) => match punct {\n             HlPunct::Bracket => semantic_tokens::BRACKET,\n@@ -643,16 +640,16 @@ fn semantic_token_type_and_modifiers(\n             HlMod::Consuming => semantic_tokens::CONSUMING,\n             HlMod::ControlFlow => semantic_tokens::CONTROL_FLOW,\n             HlMod::CrateRoot => semantic_tokens::CRATE_ROOT,\n-            HlMod::DefaultLibrary => lsp_types::SemanticTokenModifier::DEFAULT_LIBRARY,\n-            HlMod::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n-            HlMod::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n+            HlMod::DefaultLibrary => semantic_tokens::DEFAULT_LIBRARY,\n+            HlMod::Definition => semantic_tokens::DECLARATION,\n+            HlMod::Documentation => semantic_tokens::DOCUMENTATION,\n             HlMod::Injected => semantic_tokens::INJECTED,\n             HlMod::IntraDocLink => semantic_tokens::INTRA_DOC_LINK,\n             HlMod::Library => semantic_tokens::LIBRARY,\n             HlMod::Mutable => semantic_tokens::MUTABLE,\n             HlMod::Public => semantic_tokens::PUBLIC,\n             HlMod::Reference => semantic_tokens::REFERENCE,\n-            HlMod::Static => lsp_types::SemanticTokenModifier::STATIC,\n+            HlMod::Static => semantic_tokens::STATIC,\n             HlMod::Trait => semantic_tokens::TRAIT_MODIFIER,\n             HlMod::Unsafe => semantic_tokens::UNSAFE,\n         };"}, {"sha": "9909d71bdf066bd4117531998f054aeeaab45444", "filename": "src/tools/rust-analyzer/crates/stdx/src/hash.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -0,0 +1,80 @@\n+//! A none hashing [`Hasher`] implementation.\n+use std::{\n+    hash::{BuildHasher, Hasher},\n+    marker::PhantomData,\n+};\n+\n+pub type NoHashHashMap<K, V> = std::collections::HashMap<K, V, NoHashHasherBuilder<K>>;\n+pub type NoHashHashSet<K> = std::collections::HashSet<K, NoHashHasherBuilder<K>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct NoHashHasherBuilder<T>(PhantomData<T>);\n+\n+impl<T> Default for NoHashHasherBuilder<T> {\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n+pub trait NoHashHashable {}\n+impl NoHashHashable for usize {}\n+impl NoHashHashable for u32 {}\n+\n+pub struct NoHashHasher(u64);\n+\n+impl<T: NoHashHashable> BuildHasher for NoHashHasherBuilder<T> {\n+    type Hasher = NoHashHasher;\n+    fn build_hasher(&self) -> Self::Hasher {\n+        NoHashHasher(0)\n+    }\n+}\n+\n+impl Hasher for NoHashHasher {\n+    fn finish(&self) -> u64 {\n+        self.0\n+    }\n+\n+    fn write(&mut self, _: &[u8]) {\n+        unimplemented!(\"NoHashHasher should only be used for hashing primitive integers\")\n+    }\n+\n+    fn write_u8(&mut self, i: u8) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u16(&mut self, i: u16) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u32(&mut self, i: u32) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u64(&mut self, i: u64) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_usize(&mut self, i: usize) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i8(&mut self, i: i8) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i16(&mut self, i: i16) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i32(&mut self, i: i32) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i64(&mut self, i: i64) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_isize(&mut self, i: isize) {\n+        self.0 = i as u64;\n+    }\n+}"}, {"sha": "51e109798d1df3c22f119920424fd11969986936", "filename": "src/tools/rust-analyzer/crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -7,6 +7,7 @@ use std::{cmp::Ordering, ops, time::Instant};\n use std::{io as sio, iter};\n \n mod macros;\n+pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;"}, {"sha": "d7549a2841539bb1e9df66e5592d99b5d7c8a809", "filename": "src/tools/rust-analyzer/crates/vfs/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -12,6 +12,7 @@ doctest = false\n [dependencies]\n rustc-hash = \"1.1.0\"\n fst = \"0.4.7\"\n+indexmap = \"1.9.1\"\n \n paths = { path = \"../paths\", version = \"0.0.0\" }\n-indexmap = \"1.9.1\"\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "e0ef737b3fc09efe338e12ac996d8faf3690134a", "filename": "src/tools/rust-analyzer/crates/vfs/src/file_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -6,14 +6,15 @@ use std::fmt;\n \n use fst::{IntoStreamer, Streamer};\n use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n \n use crate::{AnchoredPath, FileId, Vfs, VfsPath};\n \n /// A set of [`VfsPath`]s identified by [`FileId`]s.\n #[derive(Default, Clone, Eq, PartialEq)]\n pub struct FileSet {\n     files: FxHashMap<VfsPath, FileId>,\n-    paths: FxHashMap<FileId, VfsPath>,\n+    paths: NoHashHashMap<FileId, VfsPath>,\n }\n \n impl FileSet {"}, {"sha": "afc9a0fa6fb206b1a0c41024137639f016518697", "filename": "src/tools/rust-analyzer/crates/vfs/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -59,9 +59,16 @@ pub use paths::{AbsPath, AbsPathBuf};\n /// Handle to a file in [`Vfs`]\n ///\n /// Most functions in rust-analyzer use this when they need to refer to a file.\n-#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq)]\n pub struct FileId(pub u32);\n \n+impl stdx::hash::NoHashHashable for FileId {}\n+impl std::hash::Hash for FileId {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n /// Storage for all files read by rust-analyzer.\n ///\n /// For more information see the [crate-level](crate) documentation."}, {"sha": "72b925726479e014c18142acb6b4546bffc2b2b8", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -587,6 +587,52 @@ Enables the use of rustfmt's unstable range formatting command for the\n `textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n available on a nightly build.\n --\n+[[rust-analyzer.semanticHighlighting.doc.comment.inject.enable]]rust-analyzer.semanticHighlighting.doc.comment.inject.enable (default: `true`)::\n++\n+--\n+Inject additional highlighting into doc comments.\n+\n+When enabled, rust-analyzer will highlight rust source in doc comments as well as intra\n+doc links.\n+--\n+[[rust-analyzer.semanticHighlighting.operator.enable]]rust-analyzer.semanticHighlighting.operator.enable (default: `true`)::\n++\n+--\n+Use semantic tokens for operators.\n+\n+When disabled, rust-analyzer will emit semantic tokens only for operator tokens when\n+they are tagged with modifiers.\n+--\n+[[rust-analyzer.semanticHighlighting.operator.specialization.enable]]rust-analyzer.semanticHighlighting.operator.specialization.enable (default: `false`)::\n++\n+--\n+Use specialized semantic tokens for operators.\n+\n+When enabled, rust-analyzer will emit special token types for operator tokens instead\n+of the generic `operator` token type.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.enable]]rust-analyzer.semanticHighlighting.punctuation.enable (default: `false`)::\n++\n+--\n+Use semantic tokens for punctuations.\n+\n+When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\n+they are tagged with modifiers or have a special role.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang]]rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang (default: `false`)::\n++\n+--\n+When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\n+calls.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.specialization.enable]]rust-analyzer.semanticHighlighting.punctuation.specialization.enable (default: `false`)::\n++\n+--\n+Use specialized semantic tokens for punctuations.\n+\n+When enabled, rust-analyzer will emit special token types for punctuation tokens instead\n+of the generic `punctuation` token type.\n+--\n [[rust-analyzer.semanticHighlighting.strings.enable]]rust-analyzer.semanticHighlighting.strings.enable (default: `true`)::\n +\n --"}, {"sha": "9bd3b6a692b1a7514263ca06c4b39e97281f42df", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -861,3 +861,14 @@ For example, if you want to run https://crates.io/crates/cargo-watch[`cargo watc\n     \"isBackground\": true\n }\n ```\n+\n+==== Live Share\n+\n+VS Code Live Share has partial support for rust-analyzer.\n+\n+Live Share _requires_ the official Microsoft build of VS Code, OSS builds will not work correctly.\n+\n+The host's rust-analyzer instance will be shared with all guests joining the session.\n+The guests do not have to have the rust-analyzer extension installed for this to work.\n+\n+If you are joining a Live Share session and _do_ have rust-analyzer installed locally, commands from the command palette will not work correctly since they will attempt to communicate with the local server."}, {"sha": "767c5875bf7e7e844c1178675ee082288ff1ac29", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -1084,6 +1084,36 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.semanticHighlighting.doc.comment.inject.enable\": {\n+                    \"markdownDescription\": \"Inject additional highlighting into doc comments.\\n\\nWhen enabled, rust-analyzer will highlight rust source in doc comments as well as intra\\ndoc links.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.operator.enable\": {\n+                    \"markdownDescription\": \"Use semantic tokens for operators.\\n\\nWhen disabled, rust-analyzer will emit semantic tokens only for operator tokens when\\nthey are tagged with modifiers.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.operator.specialization.enable\": {\n+                    \"markdownDescription\": \"Use specialized semantic tokens for operators.\\n\\nWhen enabled, rust-analyzer will emit special token types for operator tokens instead\\nof the generic `operator` token type.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.enable\": {\n+                    \"markdownDescription\": \"Use semantic tokens for punctuations.\\n\\nWhen disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\\nthey are tagged with modifiers or have a special role.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang\": {\n+                    \"markdownDescription\": \"When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\\ncalls.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.specialization.enable\": {\n+                    \"markdownDescription\": \"Use specialized semantic tokens for punctuations.\\n\\nWhen enabled, rust-analyzer will emit special token types for punctuation tokens instead\\nof the generic `punctuation` token type.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.semanticHighlighting.strings.enable\": {\n                     \"markdownDescription\": \"Use semantic tokens for strings.\\n\\nIn some editors (e.g. vscode) semantic tokens override other highlighting grammars.\\nBy disabling semantic tokens for strings, other grammars can be used to highlight\\ntheir contents.\",\n                     \"default\": true,"}, {"sha": "05d4d08f70b62d17436dcb32715011bb53449dd6", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -5,7 +5,6 @@ import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import { WorkspaceEdit } from \"vscode\";\n import { Workspace } from \"./ctx\";\n-import { updateConfig } from \"./config\";\n import { substituteVariablesInEnv } from \"./config\";\n import { outputChannel, traceOutputChannel } from \"./main\";\n import { randomUUID } from \"crypto\";\n@@ -86,11 +85,6 @@ export async function createClient(\n \n     let initializationOptions = vscode.workspace.getConfiguration(\"rust-analyzer\");\n \n-    // Update outdated user configs\n-    await updateConfig(initializationOptions).catch((err) => {\n-        void vscode.window.showErrorMessage(`Failed updating old config keys: ${err.message}`);\n-    });\n-\n     if (workspace.kind === \"Detached Files\") {\n         initializationOptions = {\n             detachedFiles: workspace.files.map((file) => file.uri.fsPath),\n@@ -105,22 +99,6 @@ export async function createClient(\n         traceOutputChannel: traceOutputChannel(),\n         outputChannel: outputChannel(),\n         middleware: {\n-            async handleDiagnostics(uri, diagnostics, next) {\n-                // Workaround for https://github.com/microsoft/vscode/issues/155531\n-                for (const diagnostic of diagnostics) {\n-                    if (!diagnostic.message) {\n-                        diagnostic.message = \" \";\n-                    }\n-                    if (diagnostic.relatedInformation) {\n-                        for (const relatedInformation of diagnostic.relatedInformation) {\n-                            if (!relatedInformation.message) {\n-                                relatedInformation.message = \" \";\n-                            }\n-                        }\n-                    }\n-                }\n-                next(uri, diagnostics);\n-            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,"}, {"sha": "a9c0f079b3da9350eeb3624fbed5247b465da7d9", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -3,8 +3,6 @@ import * as vscode from \"vscode\";\n import { Env } from \"./client\";\n import { log } from \"./util\";\n \n-export type UpdatesChannel = \"stable\" | \"nightly\";\n-\n export type RunnableEnvCfg =\n     | undefined\n     | Record<string, string>\n@@ -175,100 +173,6 @@ export class Config {\n     }\n }\n \n-export async function updateConfig(config: vscode.WorkspaceConfiguration) {\n-    const renames = [\n-        [\"assist.allowMergingIntoGlobImports\", \"imports.merge.glob\"],\n-        [\"assist.exprFillDefault\", \"assist.expressionFillDefault\"],\n-        [\"assist.importEnforceGranularity\", \"imports.granularity.enforce\"],\n-        [\"assist.importGranularity\", \"imports.granularity.group\"],\n-        [\"assist.importMergeBehavior\", \"imports.granularity.group\"],\n-        [\"assist.importMergeBehaviour\", \"imports.granularity.group\"],\n-        [\"assist.importGroup\", \"imports.group.enable\"],\n-        [\"assist.importPrefix\", \"imports.prefix\"],\n-        [\"primeCaches.enable\", \"cachePriming.enable\"],\n-        [\"cache.warmup\", \"cachePriming.enable\"],\n-        [\"cargo.loadOutDirsFromCheck\", \"cargo.buildScripts.enable\"],\n-        [\"cargo.runBuildScripts\", \"cargo.buildScripts.enable\"],\n-        [\"cargo.runBuildScriptsCommand\", \"cargo.buildScripts.overrideCommand\"],\n-        [\"cargo.useRustcWrapperForBuildScripts\", \"cargo.buildScripts.useRustcWrapper\"],\n-        [\"completion.snippets\", \"completion.snippets.custom\"],\n-        [\"diagnostics.enableExperimental\", \"diagnostics.experimental.enable\"],\n-        [\"experimental.procAttrMacros\", \"procMacro.attributes.enable\"],\n-        [\"highlighting.strings\", \"semanticHighlighting.strings.enable\"],\n-        [\"highlightRelated.breakPoints\", \"highlightRelated.breakPoints.enable\"],\n-        [\"highlightRelated.exitPoints\", \"highlightRelated.exitPoints.enable\"],\n-        [\"highlightRelated.yieldPoints\", \"highlightRelated.yieldPoints.enable\"],\n-        [\"highlightRelated.references\", \"highlightRelated.references.enable\"],\n-        [\"hover.documentation\", \"hover.documentation.enable\"],\n-        [\"hover.linksInHover\", \"hover.links.enable\"],\n-        [\"hoverActions.linksInHover\", \"hover.links.enable\"],\n-        [\"hoverActions.debug\", \"hover.actions.debug.enable\"],\n-        [\"hoverActions.enable\", \"hover.actions.enable.enable\"],\n-        [\"hoverActions.gotoTypeDef\", \"hover.actions.gotoTypeDef.enable\"],\n-        [\"hoverActions.implementations\", \"hover.actions.implementations.enable\"],\n-        [\"hoverActions.references\", \"hover.actions.references.enable\"],\n-        [\"hoverActions.run\", \"hover.actions.run.enable\"],\n-        [\"inlayHints.chainingHints\", \"inlayHints.chainingHints.enable\"],\n-        [\"inlayHints.closureReturnTypeHints\", \"inlayHints.closureReturnTypeHints.enable\"],\n-        [\"inlayHints.hideNamedConstructorHints\", \"inlayHints.typeHints.hideNamedConstructor\"],\n-        [\"inlayHints.parameterHints\", \"inlayHints.parameterHints.enable\"],\n-        [\"inlayHints.reborrowHints\", \"inlayHints.reborrowHints.enable\"],\n-        [\"inlayHints.typeHints\", \"inlayHints.typeHints.enable\"],\n-        [\"lruCapacity\", \"lru.capacity\"],\n-        [\"runnables.cargoExtraArgs\", \"runnables.extraArgs\"],\n-        [\"runnables.overrideCargo\", \"runnables.command\"],\n-        [\"rustcSource\", \"rustc.source\"],\n-        [\"rustfmt.enableRangeFormatting\", \"rustfmt.rangeFormatting.enable\"],\n-    ];\n-\n-    for (const [oldKey, newKey] of renames) {\n-        const inspect = config.inspect(oldKey);\n-        if (inspect !== undefined) {\n-            const valMatrix = [\n-                {\n-                    val: inspect.globalValue,\n-                    langVal: inspect.globalLanguageValue,\n-                    target: vscode.ConfigurationTarget.Global,\n-                },\n-                {\n-                    val: inspect.workspaceFolderValue,\n-                    langVal: inspect.workspaceFolderLanguageValue,\n-                    target: vscode.ConfigurationTarget.WorkspaceFolder,\n-                },\n-                {\n-                    val: inspect.workspaceValue,\n-                    langVal: inspect.workspaceLanguageValue,\n-                    target: vscode.ConfigurationTarget.Workspace,\n-                },\n-            ];\n-            for (const { val, langVal, target } of valMatrix) {\n-                const patch = (val: unknown) => {\n-                    // some of the updates we do only append \"enable\" or \"custom\"\n-                    // that means on the next run we would find these again, but as objects with\n-                    // these properties causing us to destroy the config\n-                    // so filter those already updated ones out\n-                    return (\n-                        val !== undefined &&\n-                        !(\n-                            typeof val === \"object\" &&\n-                            val !== null &&\n-                            (oldKey === \"completion.snippets\" || !val.hasOwnProperty(\"custom\"))\n-                        )\n-                    );\n-                };\n-                if (patch(val)) {\n-                    await config.update(newKey, val, target, false);\n-                    await config.update(oldKey, undefined, target, false);\n-                }\n-                if (patch(langVal)) {\n-                    await config.update(newKey, langVal, target, true);\n-                    await config.update(oldKey, undefined, target, true);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n export function substituteVariablesInEnv(env: Env): Env {\n     const missingDeps = new Set<string>();\n     // vscode uses `env:ENV_NAME` for env vars resolution, and it's easier"}, {"sha": "e9b62e0cc2578b876747093577439bfec057192e", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -33,7 +33,7 @@ export function outputChannel() {\n }\n \n export interface RustAnalyzerExtensionApi {\n-    client: lc.LanguageClient;\n+    client?: lc.LanguageClient;\n }\n \n export async function activate(\n@@ -48,6 +48,23 @@ export async function activate(\n }\n \n async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyzerExtensionApi> {\n+    // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n+    // only those are in use.\n+    // (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n+    const folders = (vscode.workspace.workspaceFolders || []).filter(\n+        (folder) => folder.uri.scheme === \"file\"\n+    );\n+    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n+        isRustDocument(document)\n+    );\n+\n+    if (folders.length === 0 && rustDocuments.length === 0) {\n+        // FIXME: Ideally we would choose not to activate at all (and avoid registering\n+        // non-functional editor commands), but VS Code doesn't seem to have a good way of doing\n+        // that\n+        return {};\n+    }\n+\n     const config = new Config(context);\n     const state = new PersistentState(context.globalState);\n     const serverPath = await bootstrap(context, config, state).catch((err) => {\n@@ -60,18 +77,11 @@ async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyz\n         throw new Error(message);\n     });\n \n-    if ((vscode.workspace.workspaceFolders || []).length === 0) {\n-        const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n-            isRustDocument(document)\n-        );\n-        if (rustDocuments.length > 0) {\n-            ctx = await Ctx.create(config, context, serverPath, {\n-                kind: \"Detached Files\",\n-                files: rustDocuments,\n-            });\n-        } else {\n-            throw new Error(\"no rust files are opened\");\n-        }\n+    if (folders.length === 0) {\n+        ctx = await Ctx.create(config, context, serverPath, {\n+            kind: \"Detached Files\",\n+            files: rustDocuments,\n+        });\n     } else {\n         // Note: we try to start the server before we activate type hints so that it\n         // registers its `onDidChangeDocument` handler before us."}, {"sha": "36d728456f77c48248c34102ad2ab5f6fc1da12b", "filename": "src/tools/rust-analyzer/lib/lsp-server/src/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f442f8ba174fd4233a14ef4d7b577aa907db594/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs?ref=7f442f8ba174fd4233a14ef4d7b577aa907db594", "patch": "@@ -15,7 +15,7 @@ pub(crate) fn socket_transport(\n     stream: TcpStream,\n ) -> (Sender<Message>, Receiver<Message>, IoThreads) {\n     let (reader_receiver, reader) = make_reader(stream.try_clone().unwrap());\n-    let (writer_sender, writer) = make_write(stream.try_clone().unwrap());\n+    let (writer_sender, writer) = make_write(stream);\n     let io_threads = make_io_threads(reader, writer);\n     (writer_sender, reader_receiver, io_threads)\n }"}]}