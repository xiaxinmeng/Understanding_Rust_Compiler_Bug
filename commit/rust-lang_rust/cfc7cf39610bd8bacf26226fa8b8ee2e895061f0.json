{"sha": "cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzdjZjM5NjEwYmQ4YmFjZjI2MjI2ZmE4YjhlZTJlODk1MDYxZjA=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-25T06:21:22Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-09-09T05:42:27Z"}, "message": "adding E0623 for LateBound regions", "tree": {"sha": "7858e5220035d3978b21969988b7e5d142ce1e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7858e5220035d3978b21969988b7e5d142ce1e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "html_url": "https://github.com/rust-lang/rust/commit/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dead08cb331343b84564628b139b657f93548320", "url": "https://api.github.com/repos/rust-lang/rust/commits/dead08cb331343b84564628b139b657f93548320", "html_url": "https://github.com/rust-lang/rust/commit/dead08cb331343b84564628b139b657f93548320"}], "stats": {"total": 522, "additions": 344, "deletions": 178}, "files": [{"sha": "717d0b0c3be6b96e4afa4120c72eb9c1d690ccfe", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -1389,30 +1389,66 @@ A lifetime of reference outlives lifetime of borrowed content.\n Erroneous code example:\n \n ```compile_fail,E0312\n-fn make_child<'human, 'elve>(x: &mut &'human isize, y: &mut &'elve isize) {\n-    *x = *y;\n-    // error: lifetime of reference outlives lifetime of borrowed content\n+fn make_child<'tree, 'human>(\n+  x: &'human i32,\n+  y: &'tree i32\n+) -> &'human i32 {\n+    if x > y\n+       { x }\n+    else\n+       { y }\n+       // error: lifetime of reference outlives lifetime of borrowed content\n }\n ```\n \n-The compiler cannot determine if the `human` lifetime will live long enough\n-to keep up on the elve one. To solve this error, you have to give an\n-explicit lifetime hierarchy:\n+The function declares that it returns a reference with the `'human`\n+lifetime, but it may return data with the `'tree` lifetime. As neither\n+lifetime is declared longer than the other, this results in an\n+error. Sometimes, this error is because the function *body* is\n+incorrect -- that is, maybe you did not *mean* to return data from\n+`y`. In that case, you should fix the function body.\n+\n+Often, however, the body is correct. In that case, the function\n+signature needs to be altered to match the body, so that the caller\n+understands that data from either `x` or `y` may be returned. The\n+simplest way to do this is to give both function parameters the *same*\n+named lifetime:\n \n ```\n-fn make_child<'human, 'elve: 'human>(x: &mut &'human isize,\n-                                     y: &mut &'elve isize) {\n-    *x = *y; // ok!\n+fn make_child<'human>(\n+  x: &'human i32,\n+  y: &'human i32\n+) -> &'human i32 {\n+    if x > y\n+       { x }\n+    else\n+       { y } // ok!\n }\n ```\n \n-Or use the same lifetime for every variable:\n+However, in some cases, you may prefer to explicitly declare that one lifetime\n+outlives another using a `where` clause:\n \n ```\n-fn make_child<'elve>(x: &mut &'elve isize, y: &mut &'elve isize) {\n-    *x = *y; // ok!\n+fn make_child<'tree, 'human>(\n+  x: &'human i32,\n+  y: &'tree i32\n+) -> &'tree i32\n+where\n+  'tree: 'human\n+{\n+    if x > y\n+       { x }\n+    else\n+       { y } // ok!\n }\n ```\n+\n+Here, the where clause `'tree: 'human` can be read as \"the lifetime\n+'tree outlives the lifetime 'human\" -- meaning, references with the\n+`'tree` lifetime live *at least as long as* references with the\n+`'human` lifetime. Therefore, it is safe to return data with lifetime\n+`'tree` when data with the lifetime `'human` is needed.\n \"##,\n \n E0317: r##\""}, {"sha": "23f6d1a3fb0d4521a1094e9f95d53c3e25fdd546", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "renamed", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let anon_reg_sup = or_false!(self.is_suitable_anonymous_region(sup));\n+        let anon_reg_sup = or_false!(self.is_suitable_region(sup));\n \n-        let anon_reg_sub = or_false!(self.is_suitable_anonymous_region(sub));\n+        let anon_reg_sub = or_false!(self.is_suitable_region(sub));\n         let scope_def_id_sup = anon_reg_sup.def_id;\n         let bregion_sup = anon_reg_sup.boundregion;\n         let scope_def_id_sub = anon_reg_sub.def_id;\n@@ -57,10 +57,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+        debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+               ty_sub,\n+               sup,\n+               bregion_sup);\n+        debug!(\"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+               ty_sup,\n+               sub,\n+               bregion_sub);\n \n         let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_anonymous_region(sup, sup),\n-             self.find_arg_with_anonymous_region(sub, sub)) {\n+            (self.find_arg_with_region(sup, sup), self.find_arg_with_region(sub, sub)) {\n \n             let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n                 (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n@@ -97,6 +104,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (span_label, span_label_var1, span_label_var2)\n             }\n         } else {\n+            debug!(\"no arg with anon region found\");\n+            debug!(\"try_report_anon_anon_conflict: is_suitable(sub) = {:?}\",\n+                   self.is_suitable_region(sub));\n+            debug!(\"try_report_anon_anon_conflict: is_suitable(sup) = {:?}\",\n+                   self.is_suitable_region(sup));\n             return false;\n         };\n \n@@ -124,35 +136,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n     pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n-        if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n+        if let Some(anon_reg) = self.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let ret_ty = self.tcx.type_of(def_id);\n-                if let ty::TyFnDef(_, _) = ret_ty.sty {\n-                    let inputs: &[_] =\n-                        match self.tcx.hir.get(node_id) {\n-                            hir_map::NodeItem(&hir::Item {\n-                                                  node: hir::ItemFn(ref fndecl, ..), ..\n-                                              }) => &fndecl.inputs,\n-                            hir_map::NodeTraitItem(&hir::TraitItem {\n-                                                   node: hir::TraitItemKind::Method(ref fndecl, ..),\n-                                                   ..\n-                                               }) => &fndecl.decl.inputs,\n-                            hir_map::NodeImplItem(&hir::ImplItem {\n-                                                  node: hir::ImplItemKind::Method(ref fndecl, ..),\n-                                                  ..\n-                                              }) => &fndecl.decl.inputs,\n+                let inputs: &[_] = match self.tcx.hir.get(node_id) {\n+                    hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n+                        &fndecl.inputs\n+                    }\n+                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                                               node: hir::TraitItemKind::Method(ref fndecl, ..), ..\n+                                           }) => &fndecl.decl.inputs,\n+                    hir_map::NodeImplItem(&hir::ImplItem {\n+                                              node: hir::ImplItemKind::Method(ref fndecl, ..), ..\n+                                          }) => &fndecl.decl.inputs,\n \n-                            _ => &[],\n-                        };\n+                    _ => &[],\n+                };\n \n-                    return inputs\n-                               .iter()\n-                               .filter_map(|arg| {\n-                                               self.find_component_for_bound_region(&**arg, br)\n-                                           })\n-                               .next();\n-                }\n+                return inputs\n+                           .iter()\n+                           .filter_map(|arg| self.find_component_for_bound_region(&**arg, br))\n+                           .next();\n             }\n         }\n         None\n@@ -199,30 +203,62 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // Find the index of the anonymous region that was part of the\n-        // error. We will then search the function parameters for a bound\n-        // region at the right depth with the same index.\n-        let br_index = match self.bound_region {\n-            ty::BrAnon(index) => index,\n-            _ => return,\n-        };\n-\n         match arg.node {\n             hir::TyRptr(ref lifetime, _) => {\n+                // the lifetime of the TyRptr\n                 let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-                match self.infcx.tcx.named_region(hir_id) {\n-                    // the lifetime of the TyRptr\n-                    Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+                    // Find the index of the anonymous region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                     ty::BrAnon(br_index)) => {\n+                        debug!(\"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n+                               debruijn_index.depth,\n+                               anon_index,\n+                               br_index);\n                         if debruijn_index.depth == 1 && anon_index == br_index {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n                     }\n-                    Some(rl::Region::Static) |\n-                    Some(rl::Region::EarlyBound(_, _)) |\n-                    Some(rl::Region::LateBound(_, _)) |\n-                    Some(rl::Region::Free(_, _)) |\n-                    None => {\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                                        def_id={:?}\",\n+                               self.infcx.tcx.hir.local_def_id(id),\n+                               def_id);\n+                        if self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                               debruijn_index.depth);\n+                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\",\n+                               self.infcx.tcx.hir.local_def_id(id));\n+                        debug!(\"def_id={:?}\", def_id);\n+                        if debruijn_index.depth == 1 &&\n+                           self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    (Some(rl::Region::Static), _) |\n+                    (Some(rl::Region::Free(_, _)), _) |\n+                    (Some(rl::Region::EarlyBound(_, _)), _) |\n+                    (Some(rl::Region::LateBound(_, _)), _) |\n+                    (Some(rl::Region::LateBoundAnon(_, _)), _) |\n+                    (None, _) => {\n                         debug!(\"no arg found\");\n                     }\n                 }", "previous_filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs"}, {"sha": "c0d88f6022c2abf2bb2f824d826dc14036234a5e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -79,7 +79,7 @@ mod need_type_info;\n mod named_anon_conflict;\n #[macro_use]\n mod util;\n-mod anon_anon_conflict;\n+mod different_lifetimes;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,"}, {"sha": "a3bbdab497a9b2439de7250a9ff577bbecfe6fb9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -13,6 +13,7 @@\n use infer::InferCtxt;\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n+use ty;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method generates the error message for the case when\n@@ -24,39 +25,68 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => return false, // inapplicable\n         };\n \n+        debug!(\"try_report_named_anon_conflict(sub={:?}, sup={:?})\",\n+               sub,\n+               sup);\n+\n         // Determine whether the sub and sup consist of one named region ('a)\n         // and one anonymous (elided) region. If so, find the parameter arg\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n         let (named, anon_arg_info, region_info) =\n-            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n+            if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n+               self.find_arg_with_region(sup, sub).is_some() {\n                 (sub,\n-                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-                 self.is_suitable_anonymous_region(sup).unwrap())\n-            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n+                 self.find_arg_with_region(sup, sub).unwrap(),\n+                 self.is_suitable_region(sup).unwrap())\n+            } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n+                      self.find_arg_with_region(sub, sup).is_some() {\n                 (sup,\n-                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-                 self.is_suitable_anonymous_region(sub).unwrap())\n+                 self.find_arg_with_region(sub, sup).unwrap(),\n+                 self.is_suitable_region(sub).unwrap())\n             } else {\n                 return false; // inapplicable\n             };\n \n+        debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n+        debug!(\"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n+               anon_arg_info);\n+        debug!(\"try_report_named_anon_conflict: region_info = {:?}\",\n+               region_info);\n+\n         let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n                                                                        anon_arg_info.arg_ty,\n                                                                        anon_arg_info.bound_region,\n                                                                        anon_arg_info.is_first,\n                                                                        region_info.def_id,\n                                                                        region_info.is_impl_item);\n+        match br {\n+            ty::BrAnon(_) => {}\n+            _ => {\n+                /* not an anonymous region */\n+                debug!(\"try_report_named_anon_conflict: not an anonymous region\");\n+                return false;\n+            }\n+        }\n+\n         if is_impl_item {\n+            debug!(\"try_report_named_anon_conflict: impl item, bail out\");\n             return false;\n         }\n \n-        if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n+        if self.is_return_type_anon(scope_def_id, br) {\n+            debug!(\"try_report_named_anon_conflict: is_return_type_anon({:?}, {:?}) = true\",\n+                   scope_def_id,\n+                   br);\n+            return false;\n+        } else if self.is_self_anon(is_first, scope_def_id) {\n+            debug!(\"try_report_named_anon_conflict: is_self_anon({:?}, {:?}) = true\",\n+                   is_first,\n+                   scope_def_id);\n             return false;\n         } else {\n-\n             let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n                 (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n             } else {\n@@ -72,9 +102,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n                     .span_label(span, format!(\"lifetime `{}` required\", named))\n                     .emit();\n-\n-\n+            return true;\n         }\n-        return true;\n     }\n }"}, {"sha": "b58fa6b0e7cbdc3f3ca153adcde528c0bde086d9", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 102, "deletions": 76, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -18,15 +18,19 @@ use hir::map as hir_map;\n \n macro_rules! or_false {\n      ($v:expr) => {\n-          match $v {\n-               Some(v) => v,\n-               None => return false,\n-          }\n+         match $v {\n+             Some(v) => v,\n+             None => {\n+                 debug!(\"or_false failed: {}\", stringify!($v));\n+                 return false;\n+             }\n+         }\n      }\n }\n \n // The struct contains the information about the anonymous region\n // we are searching for.\n+#[derive(Debug)]\n pub struct AnonymousArgInfo<'tcx> {\n     // the argument corresponding to the anonymous region\n     pub arg: &'tcx hir::Arg,\n@@ -41,6 +45,7 @@ pub struct AnonymousArgInfo<'tcx> {\n \n // This struct contains information regarding the\n // Refree((FreeRegion) corresponding to lifetime conflict\n+#[derive(Debug)]\n pub struct FreeRegionInfo {\n     // def id corresponding to FreeRegion\n     pub def_id: DefId,\n@@ -62,47 +67,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub fn find_arg_with_anonymous_region(&self,\n-                                          anon_region: Region<'tcx>,\n-                                          replace_region: Region<'tcx>)\n-                                          -> Option<AnonymousArgInfo> {\n-\n-        if let ty::ReFree(ref free_region) = *anon_region {\n-            let id = free_region.scope;\n-            let hir = &self.tcx.hir;\n-            if let Some(node_id) = hir.as_local_node_id(id) {\n-                if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n-                    let body = hir.body(body_id);\n-                    if let Some(tables) = self.in_progress_tables {\n-                        body.arguments\n-                            .iter()\n-                            .enumerate()\n-                            .filter_map(|(index, arg)| {\n-                                let ty = tables.borrow().node_id_to_type(arg.hir_id);\n-                                let mut found_anon_region = false;\n-                                let new_arg_ty = self.tcx\n-                                    .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n-                                        found_anon_region = true;\n-                                        replace_region\n-                                    } else {\n-                                        r\n-                                    });\n-                                if found_anon_region {\n-                                    let is_first = index == 0;\n-                                    Some(AnonymousArgInfo {\n-                                             arg: arg,\n-                                             arg_ty: new_arg_ty,\n-                                             bound_region: free_region.bound_region,\n-                                             is_first: is_first,\n-                                         })\n+    pub fn find_arg_with_region(&self,\n+                                anon_region: Region<'tcx>,\n+                                replace_region: Region<'tcx>)\n+                                -> Option<AnonymousArgInfo> {\n+\n+        let (id, bound_region) = match *anon_region {\n+            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+            ty::ReEarlyBound(ref ebr) => {\n+                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            }\n+            _ => return None, // not a free region\n+        };\n+\n+        let hir = &self.tcx.hir;\n+        if let Some(node_id) = hir.as_local_node_id(id) {\n+            if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n+                let body = hir.body(body_id);\n+                if let Some(tables) = self.in_progress_tables {\n+                    body.arguments\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(index, arg)| {\n+                            let ty = match tables.borrow().node_id_to_type_opt(arg.hir_id) {\n+                                Some(v) => v,\n+                                None => return None, // sometimes the tables are not yet populated\n+                            };\n+                            let mut found_anon_region = false;\n+                            let new_arg_ty = self.tcx\n+                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                                    found_anon_region = true;\n+                                    replace_region\n                                 } else {\n-                                    None\n-                                }\n-                            })\n-                            .next()\n-                    } else {\n-                        None\n-                    }\n+                                    r\n+                                });\n+                            if found_anon_region {\n+                                let is_first = index == 0;\n+                                Some(AnonymousArgInfo {\n+                                         arg: arg,\n+                                         arg_ty: new_arg_ty,\n+                                         bound_region: bound_region,\n+                                         is_first: is_first,\n+                                     })\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .next()\n                 } else {\n                     None\n                 }\n@@ -114,37 +126,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // This method returns whether the given Region is Anonymous\n-    // and returns the DefId and the BoundRegion corresponding to the given region.\n-    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n-        if let ty::ReFree(ref free_region) = *region {\n-            if let ty::BrAnon(..) = free_region.bound_region {\n-                let anonymous_region_binding_scope = free_region.scope;\n-                let node_id = self.tcx\n-                    .hir\n-                    .as_local_node_id(anonymous_region_binding_scope)\n-                    .unwrap();\n-                let mut is_impl_item = false;\n-                match self.tcx.hir.find(node_id) {\n-\n-                    Some(hir_map::NodeItem(..)) |\n-                    Some(hir_map::NodeTraitItem(..)) => {\n-                        // Success -- proceed to return Some below\n-                    }\n-                    Some(hir_map::NodeImplItem(..)) => {\n-                        is_impl_item =\n-                            self.is_bound_region_in_impl_item(anonymous_region_binding_scope);\n-                    }\n-                    _ => return None,\n-                }\n-                return Some(FreeRegionInfo {\n-                                def_id: anonymous_region_binding_scope,\n-                                boundregion: free_region.bound_region,\n-                                is_impl_item: is_impl_item,\n-                            });\n+    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n+\n+        let (suitable_region_binding_scope, bound_region) = match *region {\n+            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+            ty::ReEarlyBound(ref ebr) => {\n+                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n             }\n-        }\n-        None\n+            _ => return None, // not a free region\n+        };\n+\n+        let node_id = self.tcx\n+            .hir\n+            .as_local_node_id(suitable_region_binding_scope)\n+            .unwrap();\n+        let is_impl_item = match self.tcx.hir.find(node_id) {\n+\n+            Some(hir_map::NodeItem(..)) |\n+            Some(hir_map::NodeTraitItem(..)) => false,\n+            Some(hir_map::NodeImplItem(..)) => {\n+                self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n+            }\n+            _ => return None,\n+        };\n+\n+        return Some(FreeRegionInfo {\n+                        def_id: suitable_region_binding_scope,\n+                        boundregion: bound_region,\n+                        is_impl_item: is_impl_item,\n+                    });\n+\n     }\n \n     // Here, we check for the case where the anonymous region\n@@ -177,9 +190,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Here we check if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, anonymous_region_binding_scope: DefId) -> bool {\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n         let container_id = self.tcx\n-            .associated_item(anonymous_region_binding_scope)\n+            .associated_item(suitable_region_binding_scope)\n             .container\n             .id();\n         if self.tcx.impl_trait_ref(container_id).is_some() {\n@@ -193,4 +206,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n         false\n     }\n+\n+    // This method returns whether the given Region is Named\n+    pub fn is_named_region(&self, region: Region<'tcx>) -> bool {\n+        match *region {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrNamed(..) => true,\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "14ea66a1b67faadd1a9e961654c3fd359e1f9aed", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -1041,19 +1041,6 @@ impl RegionKind {\n \n         flags\n     }\n-\n-    // This method returns whether the given Region is Named\n-    pub fn is_named_region(&self) -> bool {\n-        match *self {\n-            ty::ReFree(ref free_region) => {\n-                match free_region.bound_region {\n-                    ty::BrNamed(..) => true,\n-                    _ => false,\n-                }\n-            }\n-            _ => false,\n-        }\n-    }\n }\n \n /// Type utilities"}, {"sha": "64dcdd39e7c2c59e30c2aedccd7113844132f336", "filename": "src/test/compile-fail/associated-types-subtyping-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -31,7 +31,7 @@ fn method2<'a,'b,T>(x: &'a T, y: &'b T)\n     // Note that &'static T <: &'a T.\n     let a: <T as Trait<'a>>::Type = loop { };\n     let b: <T as Trait<'b>>::Type = loop { };\n-    let _: <T as Trait<'b>>::Type = a; //~ ERROR mismatched types\n+    let _: <T as Trait<'b>>::Type = a; //~ ERROR E0623\n }\n \n fn method3<'a,'b,T>(x: &'a T, y: &'b T)\n@@ -40,7 +40,7 @@ fn method3<'a,'b,T>(x: &'a T, y: &'b T)\n     // Note that &'static T <: &'a T.\n     let a: <T as Trait<'a>>::Type = loop { };\n     let b: <T as Trait<'b>>::Type = loop { };\n-    let _: <T as Trait<'a>>::Type = b; //~ ERROR mismatched types\n+    let _: <T as Trait<'a>>::Type = b; //~ ERROR E0623\n }\n \n fn method4<'a,'b,T>(x: &'a T, y: &'b T)"}, {"sha": "f886c0255ccbf08631500c18f692fafd98c6dd58", "filename": "src/test/compile-fail/region-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -15,7 +15,7 @@ fn a<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) where 'b: 'a {\n \n fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR E0312\n+    *x = *y; //~ ERROR E0623\n }\n \n fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {"}, {"sha": "bae9608c3f05afa741e68eb59aa52676ec6379a0", "filename": "src/test/compile-fail/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -16,8 +16,8 @@ fn a<'a, 'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) where\n \n fn b<'a, 'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR E0312\n-    *z = *y; //~ ERROR E0312\n+    *x = *y; //~ ERROR E0623\n+    *z = *y; //~ ERROR E0623\n }\n \n fn c<'a,'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {"}, {"sha": "66b16744cc7df38586facf55c2c8f1c3250422ea", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -15,20 +15,16 @@\n struct Paramd<'a> { x: &'a usize }\n \n fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'b &'a usize> = None;\n-    //~^ ERROR reference has a longer lifetime than the data it references\n+    let z: Option<&'b &'a usize> = None;//~ ERROR E0623\n }\n \n fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n     let y: Paramd<'a> = Paramd { x: a };\n-    let z: Option<&'b Paramd<'a>> = None;\n-    //~^ ERROR reference has a longer lifetime than the data it references\n+    let z: Option<&'b Paramd<'a>> = None;//~ ERROR E0623\n }\n \n fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'a &'b usize> = None;\n-    //~^ ERROR reference has a longer lifetime than the data it references\n+    let z: Option<&'a &'b usize> = None;//~ ERROR E0623\n }\n \n-\n fn main() {}"}, {"sha": "6e1c765724b0b8b2eaba427b45f3c69e06f5f70b", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -32,7 +32,7 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // 'short <= 'long, this would be true if the Contravariant type were\n     // covariant with respect to its parameter 'a.\n \n-    let _: Contravariant<'long> = c; //~ ERROR mismatched types\n+    let _: Contravariant<'long> = c; //~ ERROR E0623\n }\n \n fn main() {}"}, {"sha": "1ab8ba4439b5d0568dbe2f5ca5288d0d1fd20e55", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -29,7 +29,7 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // 'short <= 'long, this would be true if the Covariant type were\n     // contravariant with respect to its parameter 'a.\n \n-    let _: Covariant<'short> = c; //~ ERROR mismatched types\n+    let _: Covariant<'short> = c; //~ ERROR E0623\n }\n \n fn main() {}"}, {"sha": "ef1c58bf972e31ba07c8c9a185fae164f1262958", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -15,7 +15,7 @@ fn a<'a, 'b:'a>(x: &mut &'a isize, y: &mut &'b isize) {\n \n fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR E0312\n+    *x = *y; //~ ERROR E0623\n }\n \n fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {"}, {"sha": "1dfebd54ec3b3522ff461485babb426402678a43", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant-in-second-position.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -32,7 +32,7 @@ fn use_<'short,'long>(c: S<'long, 'short>,\n     // 'short <= 'long, this would be true if the Contravariant type were\n     // covariant with respect to its parameter 'a.\n \n-    let _: S<'long, 'long> = c; //~ ERROR mismatched types\n+    let _: S<'long, 'long> = c; //~ ERROR E0623\n }\n \n fn main() {}"}, {"sha": "caf6a86fc0b26e7bbe9bbd51cf1d34ee9b299cfc", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -30,7 +30,7 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // 'short <= 'long, this would be true if the Contravariant type were\n     // covariant with respect to its parameter 'a.\n \n-    let _: Contravariant<'long> = c; //~ ERROR mismatched types\n+    let _: Contravariant<'long> = c; //~ ERROR E0623\n }\n \n fn main() {}"}, {"sha": "60dc3d94a2edb2b3ac66162642a49d64c171e734", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -30,7 +30,7 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // 'short <= 'long, this would be true if the Covariant type were\n     // contravariant with respect to its parameter 'a.\n \n-    let _: Covariant<'short> = c; //~ ERROR mismatched types\n+    let _: Covariant<'short> = c; //~ ERROR E0623\n }\n \n fn main() {}"}, {"sha": "96478fa590979288f66621ef6d5da23e83597a18", "filename": "src/test/compile-fail/regions-variance-invariant-use-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -27,7 +27,7 @@ fn use_<'short,'long>(c: Invariant<'long>,\n     // 'short <= 'long, this would be true if the Invariant type were\n     // contravariant with respect to its parameter 'a.\n \n-    let _: Invariant<'short> = c; //~ ERROR mismatched types\n+    let _: Invariant<'short> = c; //~ ERROR E0623\n }\n \n fn main() { }"}, {"sha": "1ddbcf4ab84c75065bdfd1df2cac8d4b9a40236a", "filename": "src/test/compile-fail/variance-cell-is-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -21,7 +21,7 @@ fn use_<'short,'long>(c: Foo<'short>,\n                       s: &'short isize,\n                       l: &'long isize,\n                       _where:Option<&'short &'long ()>) {\n-    let _: Foo<'long> = c; //~ ERROR mismatched types\n+    let _: Foo<'long> = c; //~ ERROR E0623\n }\n \n fn main() {"}, {"sha": "5d1820082093e544845749f91189054aa6be429f", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-earlybound-regions.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+trait Foo<'a> {}\n+impl<'a, T> Foo<'a> for T {}\n+\n+fn baz<'a, 'b, T>(x: &mut Vec<&'a T>, y: &T)\n+    where i32: Foo<'a>,\n+          u32: Foo<'b>\n+{\n+    x.push(y);\n+}\n+fn main() {\n+let x = baz;\n+}"}, {"sha": "58f2cb94cec1d01ad5fac7bb350493a2ba50e8b5", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-earlybound-regions.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-earlybound-regions.stderr?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -0,0 +1,11 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-earlybound-regions.rs:17:12\n+   |\n+13 | fn baz<'a, 'b, T>(x: &mut Vec<&'a T>, y: &T)\n+   |                               -----      -- these two types are declared with different lifetimes...\n+...\n+17 |     x.push(y);\n+   |            ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "5abfc983f883a321cca763d12176c789e8433d45", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-latebound-regions.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.rs?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a,'b>(x: &mut Vec<&'a u8>, y: &'b u8) {\n+    x.push(y);\n+}\n+\n+fn main() { }\n\\ No newline at end of file"}, {"sha": "be628f226d3ddae6f316e76fc060b35bb847e634", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-latebound-regions.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc7cf39610bd8bacf26226fa8b8ee2e895061f0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.stderr?ref=cfc7cf39610bd8bacf26226fa8b8ee2e895061f0", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-latebound-regions.rs:12:12\n+   |\n+11 | fn foo<'a,'b>(x: &mut Vec<&'a u8>, y: &'b u8) {\n+   |                           ------      ------ these two types are declared with different lifetimes...\n+12 |     x.push(y);\n+   |            ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}]}