{"sha": "185da552635321d51be06e66115199f11a586289", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NWRhNTUyNjM1MzIxZDUxYmUwNmU2NjExNTE5OWYxMWE1ODYyODk=", "commit": {"author": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-09-27T07:39:42Z"}, "committer": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-09-29T14:56:34Z"}, "message": "extending while_let to warn for more statements", "tree": {"sha": "7733d6634d263d86088798d78f61509d81600f7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7733d6634d263d86088798d78f61509d81600f7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/185da552635321d51be06e66115199f11a586289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/185da552635321d51be06e66115199f11a586289", "html_url": "https://github.com/rust-lang/rust/commit/185da552635321d51be06e66115199f11a586289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/185da552635321d51be06e66115199f11a586289/comments", "author": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43", "url": "https://api.github.com/repos/rust-lang/rust/commits/b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43", "html_url": "https://github.com/rust-lang/rust/commit/b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43"}], "stats": {"total": 97, "additions": 69, "deletions": 28}, "files": [{"sha": "b48ae13e73a6a80491ccc4186a82fdea37d36d29", "filename": "src/loops.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/185da552635321d51be06e66115199f11a586289/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da552635321d51be06e66115199f11a586289/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=185da552635321d51be06e66115199f11a586289", "patch": "@@ -6,6 +6,7 @@ use rustc::middle::ty;\n use rustc::middle::def::DefLocal;\n use consts::{constant_simple, Constant};\n use rustc::front::map::Node::{NodeBlock};\n+use std::borrow::Cow;\n use std::collections::{HashSet,HashMap};\n use syntax::ast::Lit_::*;\n \n@@ -159,10 +160,27 @@ impl LateLintPass for LoopsPass {\n             }\n         }\n         // check for `loop { if let {} else break }` that could be `while let`\n-        // (also matches explicit \"match\" instead of \"if let\")\n+        // (also matches an explicit \"match\" instead of \"if let\")\n+        // (even if the \"match\" or \"if let\" is used for declaration)\n         if let ExprLoop(ref block, _) = expr.node {\n+            // extract the first statement (if any) in a block\n+            let inner_stmt = extract_expr_from_first_stmt(block);\n             // extract a single expression\n-            if let Some(inner) = extract_single_expr(block) {\n+            let inner_expr = extract_first_expr(block);\n+            let extracted = match inner_stmt {\n+                Some(_) => inner_stmt,\n+                None => inner_expr,\n+            };\n+\n+            if let Some(inner) = extracted {\n+                // collect remaining expressions below the match\n+                let other_stuff = block.stmts\n+                                  .iter()\n+                                  .skip(1)\n+                                  .map(|stmt| {\n+                                      format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n+                                  }).collect::<Vec<String>>();\n+\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n@@ -174,12 +192,19 @@ impl LateLintPass for LoopsPass {\n                             is_break_expr(&arms[1].body)\n                         {\n                             if in_external_macro(cx, expr.span) { return; }\n+                            let loop_body = match inner_stmt {\n+                                // FIXME: should probably be an ellipsis\n+                                // tabbing and newline is probably a bad idea, especially for large blocks\n+                                Some(_) => Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \"))),\n+                                None => expr_block(cx, &arms[0].body,\n+                                                   Some(other_stuff.join(\"\\n    \")), \"..\"),\n+                            };\n                             span_help_and_lint(cx, WHILE_LET_LOOP, expr.span,\n                                                \"this loop could be written as a `while let` loop\",\n                                                &format!(\"try\\nwhile let {} = {} {}\",\n                                                         snippet(cx, arms[0].pats[0].span, \"..\"),\n                                                         snippet(cx, matchexpr.span, \"..\"),\n-                                                        expr_block(cx, &arms[0].body, \"..\")));\n+                                                        loop_body));\n                         },\n                         _ => ()\n                     }\n@@ -276,31 +301,47 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n }\n \n fn is_iterable_array(ty: ty::Ty) -> bool {\n-    //IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, 0...32) => true,\n         _ => false\n     }\n }\n \n-/// If block consists of a single expression (with or without semicolon), return it.\n-fn extract_single_expr(block: &Block) -> Option<&Expr> {\n-    match (&block.stmts.len(), &block.expr) {\n-        (&1, &None) => match block.stmts[0].node {\n-            StmtExpr(ref expr, _) |\n-            StmtSemi(ref expr, _) => Some(expr),\n+/// If a block begins with a statement (possibly a `let` binding) and has an expression, return it.\n+fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n+    match block.expr {\n+        Some(_) => None,\n+        None => match block.stmts[0].node {\n+            StmtDecl(ref decl, _) => match decl.node {\n+                DeclLocal(ref local) => match local.init {\n+                    Some(ref expr) => Some(expr),\n+                    None => None,\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+    }\n+}\n+\n+/// If a block begins with an expression (with or without semicolon), return it.\n+fn extract_first_expr(block: &Block) -> Option<&Expr> {\n+    match block.expr {\n+        Some(ref expr) => Some(expr),\n+        None => match block.stmts[0].node {\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n             _ => None,\n         },\n-        (&0, &Some(ref expr)) => Some(expr),\n-        _ => None\n     }\n }\n \n /// Return true if expr contains a single break expr (maybe within a block).\n fn is_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBreak(None) => true,\n-        ExprBlock(ref b) => match extract_single_expr(b) {\n+        // there won't be a `let <pat> = break` and so we can safely ignore the StmtDecl case\n+        ExprBlock(ref b) => match extract_first_expr(b) {\n             Some(ref subexpr) => is_break_expr(subexpr),\n             None => false,\n         },"}, {"sha": "e935a6aa6e16ef4c3842c60028b14e07ea62cda6", "filename": "src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/185da552635321d51be06e66115199f11a586289/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da552635321d51be06e66115199f11a586289/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=185da552635321d51be06e66115199f11a586289", "patch": "@@ -43,7 +43,7 @@ impl LateLintPass for MatchPass {\n                                    &format!(\"try\\nif let {} = {} {}\",\n                                             snippet(cx, arms[0].pats[0].span, \"..\"),\n                                             snippet(cx, ex.span, \"..\"),\n-                                            expr_block(cx, &arms[0].body, \"..\")));\n+                                            expr_block(cx, &arms[0].body, None, \"..\")));\n             }\n \n             // check preconditions for MATCH_REF_PATS"}, {"sha": "09924d902d3cf671cb3b1abe6c99e9bf5c903029", "filename": "src/utils.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/185da552635321d51be06e66115199f11a586289/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da552635321d51be06e66115199f11a586289/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=185da552635321d51be06e66115199f11a586289", "patch": "@@ -130,12 +130,18 @@ pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -\n }\n \n /// Like snippet_block, but add braces if the expr is not an ExprBlock\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, default: &'a str) -> Cow<'a, str> {\n+/// Also takes an Option<String> which can be put inside the braces\n+pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr,\n+                                      option: Option<String>,\n+                                      default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n+    let string = option.map_or(\"\".to_owned(), |s| s);\n     if let ExprBlock(_) = expr.node {\n-        code\n-    } else {\n+        Cow::Owned(format!(\"{}{}\", code, string))\n+    } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n+    } else {\n+        Cow::Owned(format!(\"{{\\n{};\\n{}\\n}}\", code, string))\n     }\n }\n "}, {"sha": "ef798b2a79e2b89de7f982039732c1592efd5ef0", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/185da552635321d51be06e66115199f11a586289/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da552635321d51be06e66115199f11a586289/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=185da552635321d51be06e66115199f11a586289", "patch": "@@ -4,13 +4,6 @@\n #[deny(while_let_loop)]\n fn main() {\n     let y = Some(true);\n-    loop { //~ERROR\n-        if let Some(_x) = y {\n-            let _v = 1;\n-        } else {\n-            break;\n-        }\n-    }\n     loop { //~ERROR\n         if let Some(_x) = y {\n             let _v = 1;\n@@ -30,12 +23,13 @@ fn main() {\n             None => break\n         };\n     }\n-    loop { // no error, match is not the only statement\n-        match y {\n-            Some(_x) => true,\n+    loop { //~ERROR\n+        let x = match y {\n+            Some(x) => x,\n             None => break\n         };\n-        let _x = 1;\n+        let _x = x;\n+        let _str = \"foo\";\n     }\n     loop { // no error, else branch does something other than break\n         match y {"}]}