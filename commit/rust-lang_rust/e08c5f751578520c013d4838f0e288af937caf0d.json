{"sha": "e08c5f751578520c013d4838f0e288af937caf0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOGM1Zjc1MTU3ODUyMGMwMTNkNDgzOGYwZTI4OGFmOTM3Y2FmMGQ=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-07-06T23:11:20Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-07-08T04:03:09Z"}, "message": "Change some free functions into methods in libsyntax/diagnostic.rs", "tree": {"sha": "26ae5822c212fb415caac5b2b23b9a2c80833053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26ae5822c212fb415caac5b2b23b9a2c80833053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e08c5f751578520c013d4838f0e288af937caf0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e08c5f751578520c013d4838f0e288af937caf0d", "html_url": "https://github.com/rust-lang/rust/commit/e08c5f751578520c013d4838f0e288af937caf0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e08c5f751578520c013d4838f0e288af937caf0d/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "html_url": "https://github.com/rust-lang/rust/commit/2ceaa77ae26f38b599b5ab09ee925632ad613e1b"}], "stats": {"total": 788, "additions": 392, "deletions": 396}, "files": [{"sha": "fbf015169f858b8086be80939a6e60de2633b7bf", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 392, "deletions": 396, "changes": 788, "blob_url": "https://github.com/rust-lang/rust/blob/e08c5f751578520c013d4838f0e288af937caf0d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08c5f751578520c013d4838f0e288af937caf0d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e08c5f751578520c013d4838f0e288af937caf0d", "patch": "@@ -308,63 +308,6 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(w: &mut EmitterWriter,\n-                      msg: &str,\n-                      color: term::attr::Attr) -> io::Result<()> {\n-    match w.dst {\n-        Terminal(ref mut t) => {\n-            try!(t.attr(color));\n-            // If `msg` ends in a newline, we need to reset the color before\n-            // the newline. We're making the assumption that we end up writing\n-            // to a `LineBufferedWriter`, which means that emitting the reset\n-            // after the newline ends up buffering the reset until we print\n-            // another line or exit. Buffering the reset is a problem if we're\n-            // sharing the terminal with any other programs (e.g. other rustc\n-            // instances via `make -jN`).\n-            //\n-            // Note that if `msg` contains any internal newlines, this will\n-            // result in the `LineBufferedWriter` flushing twice instead of\n-            // once, which still leaves the opportunity for interleaved output\n-            // to be miscolored. We assume this is rare enough that we don't\n-            // have to worry about it.\n-            if msg.ends_with(\"\\n\") {\n-                try!(t.write_all(msg[..msg.len()-1].as_bytes()));\n-                try!(t.reset());\n-                try!(t.write_all(b\"\\n\"));\n-            } else {\n-                try!(t.write_all(msg.as_bytes()));\n-                try!(t.reset());\n-            }\n-            Ok(())\n-        }\n-        Raw(ref mut w) => w.write_all(msg.as_bytes()),\n-    }\n-}\n-\n-fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n-                    msg: &str, code: Option<&str>) -> io::Result<()> {\n-    if !topic.is_empty() {\n-        try!(write!(&mut dst.dst, \"{} \", topic));\n-    }\n-\n-    try!(print_maybe_styled(dst,\n-                            &format!(\"{}: \", lvl.to_string()),\n-                            term::attr::ForegroundColor(lvl.color())));\n-    try!(print_maybe_styled(dst,\n-                            &format!(\"{}\", msg),\n-                            term::attr::Bold));\n-\n-    match code {\n-        Some(code) => {\n-            let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, &format!(\" [{}]\", code.clone()), style));\n-        }\n-        None => ()\n-    }\n-    try!(write!(&mut dst.dst, \"\\n\"));\n-    Ok(())\n-}\n-\n pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<diagnostics::registry::Registry>\n@@ -401,6 +344,392 @@ impl EmitterWriter {\n                registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst), registry: registry }\n     }\n+\n+    fn print_maybe_styled(&mut self,\n+                          msg: &str,\n+                          color: term::attr::Attr) -> io::Result<()> {\n+        match self.dst {\n+            Terminal(ref mut t) => {\n+                try!(t.attr(color));\n+                // If `msg` ends in a newline, we need to reset the color before\n+                // the newline. We're making the assumption that we end up writing\n+                // to a `LineBufferedWriter`, which means that emitting the reset\n+                // after the newline ends up buffering the reset until we print\n+                // another line or exit. Buffering the reset is a problem if we're\n+                // sharing the terminal with any other programs (e.g. other rustc\n+                // instances via `make -jN`).\n+                //\n+                // Note that if `msg` contains any internal newlines, this will\n+                // result in the `LineBufferedWriter` flushing twice instead of\n+                // once, which still leaves the opportunity for interleaved output\n+                // to be miscolored. We assume this is rare enough that we don't\n+                // have to worry about it.\n+                if msg.ends_with(\"\\n\") {\n+                    try!(t.write_all(msg[..msg.len()-1].as_bytes()));\n+                    try!(t.reset());\n+                    try!(t.write_all(b\"\\n\"));\n+                } else {\n+                    try!(t.write_all(msg.as_bytes()));\n+                    try!(t.reset());\n+                }\n+                Ok(())\n+            }\n+            Raw(ref mut w) => w.write_all(msg.as_bytes()),\n+        }\n+    }\n+\n+    fn print_diagnostic(&mut self, topic: &str, lvl: Level,\n+                        msg: &str, code: Option<&str>) -> io::Result<()> {\n+        if !topic.is_empty() {\n+            try!(write!(&mut self.dst, \"{} \", topic));\n+        }\n+\n+        try!(self.print_maybe_styled(&format!(\"{}: \", lvl.to_string()),\n+                                     term::attr::ForegroundColor(lvl.color())));\n+        try!(self.print_maybe_styled(&format!(\"{}\", msg),\n+                                     term::attr::Bold));\n+\n+        match code {\n+            Some(code) => {\n+                let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+                try!(self.print_maybe_styled(&format!(\" [{}]\", code.clone()), style));\n+            }\n+            None => ()\n+        }\n+        try!(write!(&mut self.dst, \"\\n\"));\n+        Ok(())\n+    }\n+\n+    fn emit_(&mut self, cm: &codemap::CodeMap, rsp: RenderSpan,\n+             msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n+        let sp = rsp.span();\n+\n+        // We cannot check equality directly with COMMAND_LINE_SP\n+        // since PartialEq is manually implemented to ignore the ExpnId\n+        let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n+            \"<command line option>\".to_string()\n+        } else if let EndSpan(_) = rsp {\n+            let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+            cm.span_to_string(span_end)\n+        } else {\n+            cm.span_to_string(sp)\n+        };\n+\n+        try!(self.print_diagnostic(&ss[..], lvl, msg, code));\n+\n+        match rsp {\n+            FullSpan(_) => {\n+                try!(self.highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            EndSpan(_) => {\n+                try!(self.end_highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            Suggestion(_, ref suggestion) => {\n+                try!(self.highlight_suggestion(cm, sp, suggestion));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            FileLine(..) => {\n+                // no source text in this case!\n+            }\n+        }\n+\n+        match code {\n+            Some(code) =>\n+                match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n+                    Some(_) => {\n+                        try!(self.print_diagnostic(&ss[..], Help,\n+                                                   &format!(\"run `rustc --explain {}` to see a \\\n+                                                             detailed explanation\", code), None));\n+                    }\n+                    None => ()\n+                },\n+            None => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn highlight_suggestion(&mut self,\n+                            cm: &codemap::CodeMap,\n+                            sp: Span,\n+                            suggestion: &str)\n+                            -> io::Result<()>\n+    {\n+        let lines = cm.span_to_lines(sp).unwrap();\n+        assert!(!lines.lines.is_empty());\n+\n+        // To build up the result, we want to take the snippet from the first\n+        // line that precedes the span, prepend that with the suggestion, and\n+        // then append the snippet from the last line that trails the span.\n+        let fm = &lines.file;\n+\n+        let first_line = &lines.lines[0];\n+        let prefix = fm.get_line(first_line.line_index)\n+                       .map(|l| &l[..first_line.start_col.0])\n+                       .unwrap_or(\"\");\n+\n+        let last_line = lines.lines.last().unwrap();\n+        let suffix = fm.get_line(last_line.line_index)\n+                       .map(|l| &l[last_line.end_col.0..])\n+                       .unwrap_or(\"\");\n+\n+        let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+\n+        // print the suggestion without any line numbers, but leave\n+        // space for them. This helps with lining up with previous\n+        // snippets from the actual error being reported.\n+        let fm = &*lines.file;\n+        let mut lines = complete.lines();\n+        for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n+            let elided_line_num = format!(\"{}\", line_index+1);\n+            try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n+                        fm.name, \"\", elided_line_num.len(), line));\n+        }\n+\n+        // if we elided some lines, add an ellipsis\n+        if lines.next().is_some() {\n+            let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+            try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n+                        \"\", fm.name.len(), elided_line_num.len()));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn highlight_lines(&mut self,\n+                       cm: &codemap::CodeMap,\n+                       sp: Span,\n+                       lvl: Level,\n+                       lines: codemap::FileLinesResult)\n+                       -> io::Result<()>\n+    {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let line_strings: Option<Vec<&str>> =\n+            lines.lines.iter()\n+                       .map(|info| fm.get_line(info.line_index))\n+                       .collect();\n+\n+        let line_strings = match line_strings {\n+            None => { return Ok(()); }\n+            Some(line_strings) => line_strings\n+        };\n+\n+        // Display only the first MAX_LINES lines.\n+        let all_lines = lines.lines.len();\n+        let display_lines = cmp::min(all_lines, MAX_LINES);\n+        let display_line_infos = &lines.lines[..display_lines];\n+        let display_line_strings = &line_strings[..display_lines];\n+\n+        // Calculate the widest number to format evenly and fix #11715\n+        assert!(display_line_infos.len() > 0);\n+        let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n+        let mut digits = 0;\n+        while max_line_num > 0 {\n+            max_line_num /= 10;\n+            digits += 1;\n+        }\n+\n+        // Print the offending lines\n+        for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n+            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n+                        fm.name,\n+                        line_info.line_index + 1,\n+                        line,\n+                        width=digits));\n+        }\n+\n+        // If we elided something, put an ellipsis.\n+        if display_lines < all_lines {\n+            let last_line_index = display_line_infos.last().unwrap().line_index;\n+            let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n+            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", s.len()));\n+        }\n+\n+        // FIXME (#3260)\n+        // If there's one line at fault we can easily point to the problem\n+        if lines.lines.len() == 1 {\n+            let lo = cm.lookup_char_pos(sp.lo);\n+            let mut digits = 0;\n+            let mut num = (lines.lines[0].line_index + 1) / 10;\n+\n+            // how many digits must be indent past?\n+            while num > 0 { num /= 10; digits += 1; }\n+\n+            let mut s = String::new();\n+            // Skip is the number of characters we need to skip because they are\n+            // part of the 'filename:line ' part of the previous line.\n+            let skip = fm.name.chars().count() + digits + 3;\n+            for _ in 0..skip {\n+                s.push(' ');\n+            }\n+            if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n+                let mut col = skip;\n+                let mut lastc = ' ';\n+                let mut iter = orig.chars().enumerate();\n+                for (pos, ch) in iter.by_ref() {\n+                    lastc = ch;\n+                    if pos >= lo.col.to_usize() { break; }\n+                    // Whenever a tab occurs on the previous line, we insert one on\n+                    // the error-point-squiggly-line as well (instead of a space).\n+                    // That way the squiggly line will usually appear in the correct\n+                    // position.\n+                    match ch {\n+                        '\\t' => {\n+                            col += 8 - col%8;\n+                            s.push('\\t');\n+                        },\n+                        _ => {\n+                            col += 1;\n+                            s.push(' ');\n+                        },\n+                    }\n+                }\n+\n+                try!(write!(&mut self.dst, \"{}\", s));\n+                let mut s = String::from(\"^\");\n+                let count = match lastc {\n+                    // Most terminals have a tab stop every eight columns by default\n+                    '\\t' => 8 - col%8,\n+                    _ => 1,\n+                };\n+                col += count;\n+                s.extend(::std::iter::repeat('~').take(count));\n+\n+                let hi = cm.lookup_char_pos(sp.hi);\n+                if hi.col != lo.col {\n+                    for (pos, ch) in iter {\n+                        if pos >= hi.col.to_usize() { break; }\n+                        let count = match ch {\n+                            '\\t' => 8 - col%8,\n+                            _ => 1,\n+                        };\n+                        col += count;\n+                        s.extend(::std::iter::repeat('~').take(count));\n+                    }\n+                }\n+\n+                if s.len() > 1 {\n+                    // One extra squiggly is replaced by a \"^\"\n+                    s.pop();\n+                }\n+\n+                try!(self.print_maybe_styled(&format!(\"{}\\n\", s),\n+                                             term::attr::ForegroundColor(lvl.color())));\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Here are the differences between this and the normal `highlight_lines`:\n+    /// `end_highlight_lines` will always put arrow on the last byte of the\n+    /// span (instead of the first byte). Also, when the span is too long (more\n+    /// than 6 lines), `end_highlight_lines` will print the first line, then\n+    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n+    /// six lines.\n+    #[allow(deprecated)]\n+    fn end_highlight_lines(&mut self,\n+                           cm: &codemap::CodeMap,\n+                           sp: Span,\n+                           lvl: Level,\n+                           lines: codemap::FileLinesResult)\n+                          -> io::Result<()> {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let lines = &lines.lines[..];\n+        if lines.len() > MAX_LINES {\n+            if let Some(line) = fm.get_line(lines[0].line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            lines[0].line_index + 1, line));\n+            }\n+            try!(write!(&mut self.dst, \"...\\n\"));\n+            let last_line_index = lines[lines.len() - 1].line_index;\n+            if let Some(last_line) = fm.get_line(last_line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            last_line_index + 1, last_line));\n+            }\n+        } else {\n+            for line_info in lines {\n+                if let Some(line) = fm.get_line(line_info.line_index) {\n+                    try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                                line_info.line_index + 1, line));\n+                }\n+            }\n+        }\n+        let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n+        let hi = cm.lookup_char_pos(sp.hi);\n+        let skip = last_line_start.chars().count();\n+        let mut s = String::new();\n+        for _ in 0..skip {\n+            s.push(' ');\n+        }\n+        if let Some(orig) = fm.get_line(lines[0].line_index) {\n+            let iter = orig.chars().enumerate();\n+            for (pos, ch) in iter {\n+                // Span seems to use half-opened interval, so subtract 1\n+                if pos >= hi.col.to_usize() - 1 { break; }\n+                // Whenever a tab occurs on the previous line, we insert one on\n+                // the error-point-squiggly-line as well (instead of a space).\n+                // That way the squiggly line will usually appear in the correct\n+                // position.\n+                match ch {\n+                    '\\t' => s.push('\\t'),\n+                    _ => s.push(' '),\n+                }\n+            }\n+        }\n+        s.push('^');\n+        s.push('\\n');\n+        self.print_maybe_styled(&s[..],\n+                                term::attr::ForegroundColor(lvl.color()))\n+    }\n+\n+    fn print_macro_backtrace(&mut self,\n+                             cm: &codemap::CodeMap,\n+                             sp: Span)\n+                             -> io::Result<()> {\n+        let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n+            match expn_info {\n+                Some(ei) => {\n+                    let ss = ei.callee.span.map_or(String::new(),\n+                                                   |span| cm.span_to_string(span));\n+                    let (pre, post) = match ei.callee.format {\n+                        codemap::MacroAttribute => (\"#[\", \"]\"),\n+                        codemap::MacroBang => (\"\", \"!\"),\n+                        codemap::CompilerExpansion => (\"\", \"\"),\n+                    };\n+                    try!(self.print_diagnostic(&ss, Note,\n+                                               &format!(\"in expansion of {}{}{}\",\n+                                                        pre,\n+                                                        ei.callee.name,\n+                                                        post),\n+                                               None));\n+                    let ss = cm.span_to_string(ei.call_site);\n+                    try!(self.print_diagnostic(&ss, Note, \"expansion site\", None));\n+                    Ok(Some(ei.call_site))\n+                }\n+                None => Ok(None)\n+        }\n+        }));\n+        cs.map_or(Ok(()), |call_site| self.print_macro_backtrace(cm, call_site))\n+    }\n }\n \n #[cfg(unix)]\n@@ -442,11 +771,11 @@ impl Emitter for EmitterWriter {\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n+            Some((cm, COMMAND_LINE_SP)) => self.emit_(cm,\n                                                 FileLine(COMMAND_LINE_SP),\n                                                 msg, code, lvl),\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl),\n-            None => print_diagnostic(self, \"\", lvl, msg, code),\n+            Some((cm, sp)) => self.emit_(cm, FullSpan(sp), msg, code, lvl),\n+            None => self.print_diagnostic(\"\", lvl, msg, code),\n         };\n \n         match error {\n@@ -457,346 +786,13 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, None, lvl) {\n+        match self.emit_(cm, sp, msg, None, lvl) {\n             Ok(()) => {}\n             Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n-fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n-    let sp = rsp.span();\n-\n-    // We cannot check equality directly with COMMAND_LINE_SP\n-    // since PartialEq is manually implemented to ignore the ExpnId\n-    let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n-        \"<command line option>\".to_string()\n-    } else if let EndSpan(_) = rsp {\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-        cm.span_to_string(span_end)\n-    } else {\n-        cm.span_to_string(sp)\n-    };\n-\n-    try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n-\n-    match rsp {\n-        FullSpan(_) => {\n-            try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        EndSpan(_) => {\n-            try!(end_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        Suggestion(_, ref suggestion) => {\n-            try!(highlight_suggestion(dst, cm, sp, suggestion));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        FileLine(..) => {\n-            // no source text in this case!\n-        }\n-    }\n-\n-    match code {\n-        Some(code) =>\n-            match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n-                Some(_) => {\n-                    try!(print_diagnostic(dst, &ss[..], Help,\n-                                          &format!(\"run `rustc --explain {}` to see a detailed \\\n-                                                   explanation\", code), None));\n-                }\n-                None => ()\n-            },\n-        None => (),\n-    }\n-    Ok(())\n-}\n-\n-fn highlight_suggestion(err: &mut EmitterWriter,\n-                        cm: &codemap::CodeMap,\n-                        sp: Span,\n-                        suggestion: &str)\n-                        -> io::Result<()>\n-{\n-    let lines = cm.span_to_lines(sp).unwrap();\n-    assert!(!lines.lines.is_empty());\n-\n-    // To build up the result, we want to take the snippet from the first\n-    // line that precedes the span, prepend that with the suggestion, and\n-    // then append the snippet from the last line that trails the span.\n-    let fm = &lines.file;\n-\n-    let first_line = &lines.lines[0];\n-    let prefix = fm.get_line(first_line.line_index)\n-                   .map(|l| &l[..first_line.start_col.0])\n-                   .unwrap_or(\"\");\n-\n-    let last_line = lines.lines.last().unwrap();\n-    let suffix = fm.get_line(last_line.line_index)\n-                   .map(|l| &l[last_line.end_col.0..])\n-                   .unwrap_or(\"\");\n-\n-    let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n-\n-    // print the suggestion without any line numbers, but leave\n-    // space for them. This helps with lining up with previous\n-    // snippets from the actual error being reported.\n-    let fm = &*lines.file;\n-    let mut lines = complete.lines();\n-    for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n-        let elided_line_num = format!(\"{}\", line_index+1);\n-        try!(write!(&mut err.dst, \"{0}:{1:2$} {3}\\n\",\n-                    fm.name, \"\", elided_line_num.len(), line));\n-    }\n-\n-    // if we elided some lines, add an ellipsis\n-    if lines.next().is_some() {\n-        let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n-        try!(write!(&mut err.dst, \"{0:1$} {0:2$} ...\\n\",\n-                    \"\", fm.name.len(), elided_line_num.len()));\n-    }\n-\n-    Ok(())\n-}\n-\n-fn highlight_lines(err: &mut EmitterWriter,\n-                   cm: &codemap::CodeMap,\n-                   sp: Span,\n-                   lvl: Level,\n-                   lines: codemap::FileLinesResult)\n-                   -> io::Result<()>\n-{\n-    let lines = match lines {\n-        Ok(lines) => lines,\n-        Err(_) => {\n-            try!(write!(&mut err.dst, \"(internal compiler error: unprintable span)\\n\"));\n-            return Ok(());\n-        }\n-    };\n-\n-    let fm = &*lines.file;\n-\n-    let line_strings: Option<Vec<&str>> =\n-        lines.lines.iter()\n-                   .map(|info| fm.get_line(info.line_index))\n-                   .collect();\n-\n-    let line_strings = match line_strings {\n-        None => { return Ok(()); }\n-        Some(line_strings) => line_strings\n-    };\n-\n-    // Display only the first MAX_LINES lines.\n-    let all_lines = lines.lines.len();\n-    let display_lines = cmp::min(all_lines, MAX_LINES);\n-    let display_line_infos = &lines.lines[..display_lines];\n-    let display_line_strings = &line_strings[..display_lines];\n-\n-    // Calculate the widest number to format evenly and fix #11715\n-    assert!(display_line_infos.len() > 0);\n-    let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n-    let mut digits = 0;\n-    while max_line_num > 0 {\n-        max_line_num /= 10;\n-        digits += 1;\n-    }\n-\n-    // Print the offending lines\n-    for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n-        try!(write!(&mut err.dst, \"{}:{:>width$} {}\\n\",\n-                    fm.name,\n-                    line_info.line_index + 1,\n-                    line,\n-                    width=digits));\n-    }\n-\n-    // If we elided something, put an ellipsis.\n-    if display_lines < all_lines {\n-        let last_line_index = display_line_infos.last().unwrap().line_index;\n-        let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n-        try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n-    }\n-\n-    // FIXME (#3260)\n-    // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1 {\n-        let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0;\n-        let mut num = (lines.lines[0].line_index + 1) / 10;\n-\n-        // how many digits must be indent past?\n-        while num > 0 { num /= 10; digits += 1; }\n-\n-        let mut s = String::new();\n-        // Skip is the number of characters we need to skip because they are\n-        // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.chars().count() + digits + 3;\n-        for _ in 0..skip {\n-            s.push(' ');\n-        }\n-        if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n-            let mut col = skip;\n-            let mut lastc = ' ';\n-            let mut iter = orig.chars().enumerate();\n-            for (pos, ch) in iter.by_ref() {\n-                lastc = ch;\n-                if pos >= lo.col.to_usize() { break; }\n-                // Whenever a tab occurs on the previous line, we insert one on\n-                // the error-point-squiggly-line as well (instead of a space).\n-                // That way the squiggly line will usually appear in the correct\n-                // position.\n-                match ch {\n-                    '\\t' => {\n-                        col += 8 - col%8;\n-                        s.push('\\t');\n-                    },\n-                    _ => {\n-                        col += 1;\n-                        s.push(' ');\n-                    },\n-                }\n-            }\n-\n-            try!(write!(&mut err.dst, \"{}\", s));\n-            let mut s = String::from(\"^\");\n-            let count = match lastc {\n-                // Most terminals have a tab stop every eight columns by default\n-                '\\t' => 8 - col%8,\n-                _ => 1,\n-            };\n-            col += count;\n-            s.extend(::std::iter::repeat('~').take(count));\n-\n-            let hi = cm.lookup_char_pos(sp.hi);\n-            if hi.col != lo.col {\n-                for (pos, ch) in iter {\n-                    if pos >= hi.col.to_usize() { break; }\n-                    let count = match ch {\n-                        '\\t' => 8 - col%8,\n-                        _ => 1,\n-                    };\n-                    col += count;\n-                    s.extend(::std::iter::repeat('~').take(count));\n-                }\n-            }\n-\n-            if s.len() > 1 {\n-                // One extra squiggly is replaced by a \"^\"\n-                s.pop();\n-            }\n-\n-            try!(print_maybe_styled(err,\n-                                    &format!(\"{}\\n\", s),\n-                                    term::attr::ForegroundColor(lvl.color())));\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Here are the differences between this and the normal `highlight_lines`:\n-/// `end_highlight_lines` will always put arrow on the last byte of the\n-/// span (instead of the first byte). Also, when the span is too long (more\n-/// than 6 lines), `end_highlight_lines` will print the first line, then\n-/// dot dot dot, then last line, whereas `highlight_lines` prints the first\n-/// six lines.\n-#[allow(deprecated)]\n-fn end_highlight_lines(w: &mut EmitterWriter,\n-                          cm: &codemap::CodeMap,\n-                          sp: Span,\n-                          lvl: Level,\n-                          lines: codemap::FileLinesResult)\n-                          -> io::Result<()> {\n-    let lines = match lines {\n-        Ok(lines) => lines,\n-        Err(_) => {\n-            try!(write!(&mut w.dst, \"(internal compiler error: unprintable span)\\n\"));\n-            return Ok(());\n-        }\n-    };\n-\n-    let fm = &*lines.file;\n-\n-    let lines = &lines.lines[..];\n-    if lines.len() > MAX_LINES {\n-        if let Some(line) = fm.get_line(lines[0].line_index) {\n-            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        lines[0].line_index + 1, line));\n-        }\n-        try!(write!(&mut w.dst, \"...\\n\"));\n-        let last_line_index = lines[lines.len() - 1].line_index;\n-        if let Some(last_line) = fm.get_line(last_line_index) {\n-            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        last_line_index + 1, last_line));\n-        }\n-    } else {\n-        for line_info in lines {\n-            if let Some(line) = fm.get_line(line_info.line_index) {\n-                try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                            line_info.line_index + 1, line));\n-            }\n-        }\n-    }\n-    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-    let hi = cm.lookup_char_pos(sp.hi);\n-    let skip = last_line_start.chars().count();\n-    let mut s = String::new();\n-    for _ in 0..skip {\n-        s.push(' ');\n-    }\n-    if let Some(orig) = fm.get_line(lines[0].line_index) {\n-        let iter = orig.chars().enumerate();\n-        for (pos, ch) in iter {\n-            // Span seems to use half-opened interval, so subtract 1\n-            if pos >= hi.col.to_usize() - 1 { break; }\n-            // Whenever a tab occurs on the previous line, we insert one on\n-            // the error-point-squiggly-line as well (instead of a space).\n-            // That way the squiggly line will usually appear in the correct\n-            // position.\n-            match ch {\n-                '\\t' => s.push('\\t'),\n-                _ => s.push(' '),\n-            }\n-        }\n-    }\n-    s.push('^');\n-    s.push('\\n');\n-    print_maybe_styled(w,\n-                       &s[..],\n-                       term::attr::ForegroundColor(lvl.color()))\n-}\n-\n-fn print_macro_backtrace(w: &mut EmitterWriter,\n-                         cm: &codemap::CodeMap,\n-                         sp: Span)\n-                         -> io::Result<()> {\n-    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n-        match expn_info {\n-            Some(ei) => {\n-                let ss = ei.callee.span.map_or(String::new(),\n-                                               |span| cm.span_to_string(span));\n-                let (pre, post) = match ei.callee.format {\n-                    codemap::MacroAttribute => (\"#[\", \"]\"),\n-                    codemap::MacroBang => (\"\", \"!\"),\n-                    codemap::CompilerExpansion => (\"\", \"\"),\n-                };\n-                try!(print_diagnostic(w, &ss, Note,\n-                                      &format!(\"in expansion of {}{}{}\",\n-                                               pre,\n-                                               ei.callee.name,\n-                                               post),\n-                                      None));\n-                let ss = cm.span_to_string(ei.call_site);\n-                try!(print_diagnostic(w, &ss, Note, \"expansion site\", None));\n-                Ok(Some(ei.call_site))\n-            }\n-            None => Ok(None)\n-    }\n-    }));\n-    cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n-}\n-\n pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n     M: FnOnce() -> String,\n {\n@@ -808,7 +804,7 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n \n #[cfg(test)]\n mod test {\n-    use super::{EmitterWriter, highlight_lines, Level};\n+    use super::{EmitterWriter, Level};\n     use codemap::{mk_sp, CodeMap, BytePos};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n@@ -854,7 +850,7 @@ mod test {\n         println!(\"span_to_lines\");\n         let lines = cm.span_to_lines(sp);\n         println!(\"highlight_lines\");\n-        highlight_lines(&mut ew, &cm, sp, lvl, lines).unwrap();\n+        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;"}]}