{"sha": "ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMWRkNDRiNDBhNzI0M2Y0M2E4ZDMyYmE4YmQ2MDI2MTk3YzMyMGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-02T18:08:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-02T18:08:21Z"}, "message": "Merge remote-tracking branch 'origin/master' into 0.11.0-release\n\nConflicts:\n\tsrc/libstd/lib.rs", "tree": {"sha": "4460cbf0a917a289d1d3744d9645c5ab131ea9df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4460cbf0a917a289d1d3744d9645c5ab131ea9df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "html_url": "https://github.com/rust-lang/rust/commit/ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1163b92de7717eb7c5eba002b4012e0574a7fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1163b92de7717eb7c5eba002b4012e0574a7fe", "html_url": "https://github.com/rust-lang/rust/commit/aa1163b92de7717eb7c5eba002b4012e0574a7fe"}, {"sha": "ca2778ede7c21efc3cf2e4e1152875ec09360770", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2778ede7c21efc3cf2e4e1152875ec09360770", "html_url": "https://github.com/rust-lang/rust/commit/ca2778ede7c21efc3cf2e4e1152875ec09360770"}], "stats": {"total": 19529, "additions": 10840, "deletions": 8689}, "files": [{"sha": "a94c154b67d03f92ed255c9afeb40804e88a8a11", "filename": "README.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -54,10 +54,26 @@ documentation.\n     When complete, `make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool.\n-    system.\n 3. Read the [tutorial].\n 4. Enjoy!\n \n+### Building on Windows\n+\n+To easily build on windows we can use [MSYS2](http://sourceforge.net/projects/msys2/):\n+\n+1. Grab the latest MSYS2 installer and go through the installer.\n+2. Now from the MSYS2 terminal we want to install the mingw64 toolchain and the other\n+   tools we need.\n+\n+        $ pacman -S mingw-w64-i686-toolchain\n+        $ pacman -S base-devel\n+\n+3. With that now start `mingw32_shell.bat` from where you installed MSYS2 (i.e. `C:\\msys`).\n+4. From there just navigate to where you have Rust's source code, configure and build it:\n+\n+        $ ./configure --build=i686-pc-mingw32\n+        $ make && make install\n+\n [repo]: https://github.com/rust-lang/rust\n [tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n [tutorial]: http://doc.rust-lang.org/tutorial.html"}, {"sha": "03414ca163ec2a01e09e4d83e5942fe4ccf32b51", "filename": "man/rustdoc.1", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -38,6 +38,15 @@ directory to load plugins from (default: /tmp/rustdoc_ng/plugins)\n -L --library-path <val>\n directory to add to crate search path\n .TP\n+--html-in-header <val>\n+file to add to <head>\n+.TP\n+--html-before-content <val>\n+file to add in <body>, before content\n+.TP\n+--html-after-content <val>\n+file to add in <body>, after content\n+.TP\n -h, --help\n Print help\n "}, {"sha": "76ebfe9b49fd64929ce5b07b49b2faba38ece8e9", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -54,6 +54,7 @@ PKG_FILES := \\\n       driver                                   \\\n       etc                                      \\\n       $(foreach crate,$(CRATES),lib$(crate))   \\\n+      libcoretest                              \\\n       libbacktrace                             \\\n       rt                                       \\\n       rustllvm                                 \\"}, {"sha": "213565b09ac27d0633a81cbdb6fde4cc5cf61b5d", "filename": "mk/docs.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -35,16 +35,16 @@ DOCS := index intro tutorial guide guide-ffi guide-macros guide-lifetimes \\\n PDF_DOCS := tutorial rust\n \n RUSTDOC_DEPS_rust := doc/full-toc.inc\n-RUSTDOC_FLAGS_rust := --markdown-in-header=doc/full-toc.inc\n+RUSTDOC_FLAGS_rust := --html-in-header=doc/full-toc.inc\n \n L10N_LANGS := ja\n \n # Generally no need to edit below here.\n \n # The options are passed to the documentation generators.\n-RUSTDOC_HTML_OPTS_NO_CSS = --markdown-before-content=doc/version_info.html \\\n-\t--markdown-in-header=doc/favicon.inc \\\n-\t--markdown-after-content=doc/footer.inc \\\n+RUSTDOC_HTML_OPTS_NO_CSS = --html-before-content=doc/version_info.html \\\n+\t--html-in-header=doc/favicon.inc \\\n+\t--html-after-content=doc/footer.inc \\\n \t--markdown-playground-url='http://play.rust-lang.org/'\n \n RUSTDOC_HTML_OPTS = $(RUSTDOC_HTML_OPTS_NO_CSS) --markdown-css rust.css"}, {"sha": "44bedde99ccffdba2a1571000adc371b601da523", "filename": "mk/tests.mk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -14,7 +14,12 @@\n ######################################################################\n \n # The names of crates that must be tested\n-TEST_TARGET_CRATES = $(TARGET_CRATES)\n+\n+# libcore tests are in a separate crate\n+DEPS_coretest :=\n+$(eval $(call RUST_CRATE,coretest))\n+\n+TEST_TARGET_CRATES = $(filter-out core,$(TARGET_CRATES)) coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(HOST_CRATES)\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n@@ -172,7 +177,7 @@ check-notidy: cleantmptestlogs cleantestlibs all check-stage2\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n check-lite: cleantestlibs cleantmptestlogs \\\n-\t$(foreach crate,$(TARGET_CRATES),check-stage2-$(crate)) \\\n+\t$(foreach crate,$(TEST_TARGET_CRATES),check-stage2-$(crate)) \\\n \tcheck-stage2-rpass \\\n \tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log"}, {"sha": "9eac38e4cd5b7cb77e70cc03e65fde68c64c45db", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -42,7 +42,7 @@ pub mod common;\n pub mod errors;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "bba9594afeb6d6bf71f017560ae85f5e1fe48f38", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -50,19 +50,19 @@ use libc::{c_int, size_t};\n \n #[link(name = \"snappy\")]\n extern {\n-    fn snappy_compress(input: *u8,\n+    fn snappy_compress(input: *const u8,\n                        input_length: size_t,\n                        compressed: *mut u8,\n                        compressed_length: *mut size_t) -> c_int;\n-    fn snappy_uncompress(compressed: *u8,\n+    fn snappy_uncompress(compressed: *const u8,\n                          compressed_length: size_t,\n                          uncompressed: *mut u8,\n                          uncompressed_length: *mut size_t) -> c_int;\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-    fn snappy_uncompressed_length(compressed: *u8,\n+    fn snappy_uncompressed_length(compressed: *const u8,\n                                   compressed_length: size_t,\n                                   result: *mut size_t) -> c_int;\n-    fn snappy_validate_compressed_buffer(compressed: *u8,\n+    fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                          compressed_length: size_t) -> c_int;\n }\n # fn main() {}\n@@ -82,7 +82,7 @@ the allocated memory. The length is less than or equal to the capacity.\n ~~~~\n # extern crate libc;\n # use libc::{c_int, size_t};\n-# unsafe fn snappy_validate_compressed_buffer(_: *u8, _: size_t) -> c_int { 0 }\n+# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n # fn main() {}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n@@ -106,7 +106,7 @@ the true length after compression for setting the length.\n ~~~~\n # extern crate libc;\n # use libc::{size_t, c_int};\n-# unsafe fn snappy_compress(a: *u8, b: size_t, c: *mut u8,\n+# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n #                           d: *mut size_t) -> c_int { 0 }\n # unsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\n # fn main() {}\n@@ -132,11 +132,11 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n ~~~~\n # extern crate libc;\n # use libc::{size_t, c_int};\n-# unsafe fn snappy_uncompress(compressed: *u8,\n+# unsafe fn snappy_uncompress(compressed: *const u8,\n #                             compressed_length: size_t,\n #                             uncompressed: *mut u8,\n #                             uncompressed_length: *mut size_t) -> c_int { 0 }\n-# unsafe fn snappy_uncompressed_length(compressed: *u8,\n+# unsafe fn snappy_uncompressed_length(compressed: *const u8,\n #                                      compressed_length: size_t,\n #                                      result: *mut size_t) -> c_int { 0 }\n # fn main() {}\n@@ -418,7 +418,7 @@ Unsafe functions, on the other hand, advertise it to the world. An unsafe functi\n this:\n \n ~~~~\n-unsafe fn kaboom(ptr: *int) -> int { *ptr }\n+unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n ~~~~\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n@@ -453,7 +453,7 @@ use std::ptr;\n \n #[link(name = \"readline\")]\n extern {\n-    static mut rl_prompt: *libc::c_char;\n+    static mut rl_prompt: *const libc::c_char;\n }\n \n fn main() {\n@@ -478,7 +478,7 @@ extern crate libc;\n #[link(name = \"kernel32\")]\n #[allow(non_snake_case_functions)]\n extern \"stdcall\" {\n-    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> libc::c_int;\n+    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n }\n # fn main() { }\n ~~~~"}, {"sha": "6d3825f8ecf12c9a84eb1d9d628f9db99599eaa3", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -355,6 +355,7 @@ macro_rules! biased_match_rec (\n             _ => { $err }\n         }\n     );\n+    // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n )\n \n@@ -364,7 +365,7 @@ macro_rules! biased_match (\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n     ) => (\n-        let ( $( $bind_res ),* ) = biased_match_rec!(\n+        let $bind_res = biased_match_rec!(\n             $( ($e) ~ ($p) else $err ; )*\n             binds $bind_res\n         );"}, {"sha": "1367bdc07555fb1ee3650e1db560a8d24040861b", "filename": "src/doc/guide-runtime.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -245,7 +245,7 @@ extern crate green;\n extern crate rustuv;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n \n@@ -261,7 +261,9 @@ inside of an OS thread.\n extern crate native;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+fn start(argc: int, argv: *const *const u8) -> int {\n+    native::start(argc, argv, main)\n+}\n \n fn main() {}\n ~~~"}, {"sha": "9021b761954d05dfd8212e52972c41132dc8d58c", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -457,6 +457,8 @@ the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~\n+#![allow(deprecated)]\n+\n use std::comm::DuplexStream;\n # fn main() {\n fn stringifier(channel: &DuplexStream<String, uint>) {\n@@ -481,6 +483,8 @@ response itself is simply the stringified version of the received value,\n Here is the code for the parent task:\n \n ~~~\n+#![allow(deprecated)]\n+\n use std::comm::duplex;\n # use std::task::spawn;\n # use std::comm::DuplexStream;"}, {"sha": "3852591da5ba2e4a4c0b40447251b727b5bd9792", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -79,7 +79,7 @@ let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n ## Raw pointers\n \n Rust offers two additional pointer types \"raw pointers\", written as\n-`*T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n+`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n respectively; indeed, one of their most common uses is for FFI,\n interfacing with external C libraries.\n \n@@ -100,7 +100,7 @@ offered by the Rust language and libraries. For example, they\n - lack any form of lifetimes, unlike `&`, and so the compiler cannot\n   reason about dangling pointers; and\n - have no guarantees about aliasing or mutability other than mutation\n-  not being allowed directly through a `*T`.\n+  not being allowed directly through a `*const T`.\n \n Fortunately, they come with a redeeming feature: the weaker guarantees\n mean weaker restrictions. The missing restrictions make raw pointers\n@@ -131,13 +131,13 @@ unsafe, and neither is converting to an integer.\n \n At runtime, a raw pointer `*` and a reference pointing to the same\n piece of data have an identical representation. In fact, an `&T`\n-reference will implicitly coerce to an `*T` raw pointer in safe code\n+reference will implicitly coerce to an `*const T` raw pointer in safe code\n and similarly for the `mut` variants (both coercions can be performed\n-explicitly with, respectively, `value as *T` and `value as *mut T`).\n+explicitly with, respectively, `value as *const T` and `value as *mut T`).\n \n-Going the opposite direction, from `*` to a reference `&`, is not\n+Going the opposite direction, from `*const` to a reference `&`, is not\n safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n-`*T` has to be a valid to a valid instance of type `T`. Furthermore,\n+`*const T` has to be a valid to a valid instance of type `T`. Furthermore,\n the resulting pointer must satisfy the aliasing and mutability laws of\n references. The compiler assumes these properties are true for any\n references, no matter how they are created, and so any conversion from\n@@ -149,7 +149,7 @@ The recommended method for the conversion is\n ```\n let i: u32 = 1;\n // explicit cast\n-let p_imm: *u32 = &i as *u32;\n+let p_imm: *const u32 = &i as *const u32;\n let mut m: u32 = 2;\n // implicit coercion\n let p_mut: *mut u32 = &mut m;\n@@ -256,7 +256,7 @@ impl<T: Send> Drop for Unique<T> {\n             // Copy the object out from the pointer onto the stack,\n             // where it is covered by normal Rust destructor semantics\n             // and cleans itself up, if necessary\n-            ptr::read(self.ptr as *T);\n+            ptr::read(self.ptr as *const T);\n \n             // clean-up our allocation\n             free(self.ptr as *mut c_void)\n@@ -267,12 +267,12 @@ impl<T: Send> Drop for Unique<T> {\n // A comparison between the built-in `Box` and this reimplementation\n fn main() {\n     {\n-        let mut x = box 5;\n+        let mut x = box 5i;\n         *x = 10;\n     } // `x` is freed here\n \n     {\n-        let mut y = Unique::new(5);\n+        let mut y = Unique::new(5i);\n         *y.borrow_mut() = 10;\n     } // `y` is freed here\n }\n@@ -457,7 +457,7 @@ extern crate libc;\n \n // Entry point for this program\n #[start]\n-fn start(_argc: int, _argv: **u8) -> int {\n+fn start(_argc: int, _argv: *const *const u8) -> int {\n     0\n }\n \n@@ -482,7 +482,7 @@ compiler's name mangling too:\n extern crate libc;\n \n #[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: int, argv: **u8) -> int {\n+pub extern fn main(argc: int, argv: *const *const u8) -> int {\n     0\n }\n \n@@ -540,8 +540,8 @@ use core::mem;\n use core::raw::Slice;\n \n #[no_mangle]\n-pub extern fn dot_product(a: *u32, a_len: u32,\n-                          b: *u32, b_len: u32) -> u32 {\n+pub extern fn dot_product(a: *const u32, a_len: u32,\n+                          b: *const u32, b_len: u32) -> u32 {\n     // Convert the provided arrays into Rust slices.\n     // The core::raw module guarantees that the Slice\n     // structure has the same memory layout as a &[T]\n@@ -573,7 +573,7 @@ extern fn begin_unwind(args: &core::fmt::Arguments,\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: int, argv: **u8) -> int { 0 }\n+# #[start] fn start(argc: int, argv: *const *const u8) -> int { 0 }\n # fn main() {}\n ```\n \n@@ -595,7 +595,7 @@ standard library itself.\n > parts of the language may never be full specified and so details may\n > differ wildly between implementations (and even versions of `rustc`\n > itself).\n-> \n+>\n > Furthermore, this is just an overview; the best form of\n > documentation for specific instances of these features are their\n > definitions and uses in `std`.\n@@ -627,7 +627,7 @@ via a declaration like\n extern \"rust-intrinsic\" {\n     fn transmute<T, U>(x: T) -> U;\n \n-    fn offset<T>(dst: *T, offset: int) -> *T;\n+    fn offset<T>(dst: *const T, offset: int) -> *const T;\n }\n ```\n \n@@ -677,8 +677,8 @@ unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n }\n \n #[start]\n-fn main(argc: int, argv: **u8) -> int {\n-    let x = box 1;\n+fn main(argc: int, argv: *const *const u8) -> int {\n+    let x = box 1i;\n \n     0\n }"}, {"sha": "cadbd8ee9adf0a6b8d189289bf3fa26bdfa3ec11", "filename": "src/doc/guide.md", "status": "modified", "additions": 226, "deletions": 14, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -160,7 +160,7 @@ Save the file, and then type this into your terminal window:\n \n ```{bash}\n $ rustc hello_world.rs\n-$ ./hello_world # just 'hello_world' on Windows\n+$ ./hello_world # or hello_world.exe on Windows\n Hello, world\n ```\n \n@@ -243,7 +243,7 @@ There are now two files: our source code, with the `.rs` extension, and the\n executable (`hello_world.exe` on Windows, `hello_world` everywhere else)\n \n ```{bash}\n-$ ./hello_world  # or ./hello_world.exe on Windows\n+$ ./hello_world  # or hello_world.exe on Windows\n ```\n \n This prints out our `Hello, world!` text to our terminal.\n@@ -285,8 +285,9 @@ At first, your program doesn't have any dependencies, so we'll only be using\n the first part of its functionality. Eventually, we'll add more. Since we\n started off by using Cargo, it'll be easy to add later.\n \n-Let's convert Hello World to Cargo. The first thing we need to do is install\n-it. To do this, we need to build it from source. There are no binaries yet.\n+Let's convert Hello World to Cargo. The first thing we need to do to begin using Cargo\n+is to install Cargo. To do this, we need to build it from source. There are no binaries\n+yet.\n \n First, let's go back to our projects directory. We don't want Cargo to\n live in our project!\n@@ -412,23 +413,209 @@ rest of your Rust career.\n Next, we'll learn more about Rust itself, by starting to write a more complicated\n program. We hope you want to do more with Rust than just print \"Hello, world!\"\n \n-## If\n+## Guessing Game\n \n-## Functions\n+Let's write a bigger program in Rust. We could just go through a laundry list\n+of Rust features, but that's boring. Instead, we'll learn more about how to\n+code in Rust by writing a few example projects.\n \n-return\n+For our first project, we'll implement a classic beginner programming problem:\n+the guessing game. Here's how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we're too low or too high. Once we\n+guess correctly, it will congratulate us, and print the number of guesses we've\n+taken to the screen. Sound good? It sounds easy, but it'll end up showing off a\n+number of basic features of Rust.\n \n-comments\n+### Set up\n \n-## Testing\n+Let's set up a new project. Go to your projects directory, and make a new\n+directory for the project, as well as a `src` directory for our code:\n \n-attributes\n+```{bash}\n+$ cd ~/projects\n+$ mkdir guessing_game\n+$ cd guessing_game\n+$ mkdir src\n+```\n \n-stability markers\n+Great. Next, let's make a `Cargo.toml` file so Cargo knows how to build our\n+project:\n \n-## Crates and Modules\n+```{ignore}\n+[package]\n \n-visibility\n+name = \"guessing_game\"\n+version = \"0.1.0\"\n+authors = [ \"someone@example.com\" ]\n+\n+[[bin]]\n+\n+name = \"guessing_game\"\n+```\n+\n+Finally, we need our source file. Let's just make it hello world for now, so we\n+can check that our setup works. In `src/guessing_game.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello world!\");\n+}\n+```\n+\n+Let's make sure that worked:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$\n+```\n+\n+Excellent! Open up your `src/guessing_game.rs` again. We'll be writing all of\n+our code in this file. The next section of the tutorial will show you how to\n+build multiple-file projects.\n+\n+## Variable bindings\n+\n+The first thing we'll learn about are 'variable bindings.' They look like this:\n+\n+```{rust}\n+let x = 5i;\n+```\n+\n+In many languages, this is called a 'variable.' But Rust's variable bindings\n+have a few tricks up their sleeves. Rust has a very powerful feature called\n+'pattern matching' that we'll get into detail with later, but the left\n+hand side of a `let` expression is a full pattern, not just a variable name.\n+This means we can do things like:\n+\n+```{rust}\n+let (x, y) = (1i, 2i);\n+```\n+\n+After this expression is evaluated, `x` will be one, and `y` will be two.\n+Patterns are really powerful, but this is about all we can do with them so far.\n+So let's just keep this in the back of our minds as we go forward.\n+\n+By the way, in these examples, `i` indicates that the number is an integer.\n+\n+Rust is a statically typed language, which means that we specify our types up\n+front. So why does our first example compile? Well, Rust has this thing called\n+\"[Hindley-Milner type\n+inference](http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)\",\n+named after some really smart type theorists. If you clicked that link, don't\n+be scared: what this means for you is that Rust will attempt to infer the types\n+in your program, and it's pretty good at it. If it can infer the type, Rust\n+doesn't require you to actually type it out.\n+\n+We can add the type if we want to. Types come after a colon (`:`):\n+\n+```{rust}\n+let x: int = 5;\n+```\n+\n+If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n+is a binding with the type `int` and the value `five`.\" Rust requires you to\n+initialize the binding with a value before you're allowed to use it. If\n+we try...\n+\n+```{ignore}\n+let x;\n+```\n+\n+...we'll get an error:\n+\n+```{ignore}\n+src/guessing_game.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type\n+src/guessing_game.rs:2     let x;\n+                               ^\n+```\n+\n+Giving it a type will compile, though:\n+\n+```{ignore}\n+let x: int;\n+```\n+\n+Let's try it out. Change your `src/guessing_game.rs` file to look like this:\n+\n+```{rust}\n+fn main() {\n+    let x: int;\n+\n+    println!(\"Hello world!\");\n+}\n+```\n+\n+You can use `cargo build` on the command line to build it. You'll get a warning,\n+but it will still print \"Hello, world!\":\n+\n+```{ignore,notrust}\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n+src/guessing_game.rs:2     let x: int;\n+                               ^\n+```\n+\n+Rust warns us that we never use the variable binding, but since we never use it,\n+no harm, no foul. Things change if we try to actually use this `x`, however. Let's\n+do that. Change your program to look like this:\n+\n+```{rust,ignore}\n+fn main() {\n+    let x: int;\n+\n+    println!(\"The value of x is: {}\", x);\n+}\n+```\n+\n+And try to build it. You'll get an error:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n+src/guessing_game.rs:4     println!(\"The value of x is: {}\", x);\n+                                                             ^\n+note: in expansion of format_args!\n+<std macros>:2:23: 2:77 note: expansion site\n+<std macros>:1:1: 3:2 note: in expansion of println!\n+src/guessing_game.rs:4:5: 4:42 note: expansion site\n+error: aborting due to previous error\n+Could not execute process `rustc src/guessing_game.rs --crate-type bin --out-dir /home/you/projects/guessing_game/target -L /home/you/projects/guessing_game/target -L /home/you/projects/guessing_game/target/deps` (status=101)\n+```\n+\n+Rust will not let us use a value that has not been initialized. So why let us\n+declare a binding without initializing it? You'd think our first example would\n+have errored. Well, Rust is smarter than that. Before we get to that, let's talk\n+about this stuff we've added to `println!`.\n+\n+If you include two curly braces (`{}`, some call them moustaches...) in your\n+string to print, Rust will interpret this as a request to interpolate some sort\n+of value. **String interpolation** is a computer science term that means \"stick\n+in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n+want `x` to be the value we're interpolating. The comma is used to separate\n+arguments we pass to functions and macros, if you're passing more than one.\n+\n+When you just use the double curly braces, Rust will attempt to display the\n+value in a meaningful way by checking out its type. If you want to specify the\n+format in a more detailed manner, there are a [wide number of options\n+available](/std/fmt/index.html). Fow now, we'll just stick to the default:\n+integers aren't very complicated to print.\n+\n+So, we've cleared up all of the confusion around bindings, with one exception:\n+why does Rust let us declare a variable binding without an initial value if we\n+must initialize the binding before we use it? And how does it know that we have\n+or have not initialized the binding? For that, we need to learn our next\n+concept: `if`.\n+\n+## If\n+\n+## Functions\n+\n+return\n+\n+comments\n \n ## Compound Data Types\n \n@@ -450,10 +637,35 @@ loop\n \n break/continue\n \n-iterators\n+## Guessing Game: complete\n+\n+At this point, you have successfully built the Guessing Game! Congratulations!\n+For reference, [We've placed the sample code on\n+GitHub](https://github.com/steveklabnik/guessing_game).\n+\n+You've now learned the basic syntax of Rust. All of this is relatively close to\n+various other programming languages you have used in the past. These\n+fundamental syntactical and semantic elements will form the foundation for the\n+rest of your Rust education.\n+\n+Now that you're an expert at the basics, it's time to learn about some of\n+Rust's more unique features.\n+\n+## iterators\n \n ## Lambdas\n \n+## Testing\n+\n+attributes\n+\n+stability markers\n+\n+## Crates and Modules\n+\n+visibility\n+\n+\n ## Generics\n \n ## Traits"}, {"sha": "e8928cb55056c519d65faa4d65d8c220eba5fd46", "filename": "src/doc/intro.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -133,7 +133,7 @@ Check it out:\n ```\n \n fn dangling() -> Box<int> {\n-    let i = box 1234;\n+    let i = box 1234i;\n     return i;\n }\n \n@@ -143,16 +143,16 @@ fn add_one() -> int {\n }\n ```\n \n-Now instead of a stack allocated `1234`,\n-we have a heap allocated `box 1234`.\n+Now instead of a stack allocated `1234i`,\n+we have a heap allocated `box 1234i`.\n Whereas `&` borrows a pointer to existing memory,\n creating an owned box allocates memory on the heap and places a value in it,\n giving you the sole pointer to that memory.\n You can roughly compare these two lines:\n \n ```\n // Rust\n-let i = box 1234;\n+let i = box 1234i;\n ```\n \n ```cpp\n@@ -252,7 +252,7 @@ fn main() {\n }\n ```\n \n-This will result an error indicating that the value is no longer in scope:\n+The compiler will produce an error indicating that the value is no longer in scope:\n \n ```text\n concurrency.rs:12:20: 12:27 error: use of moved value: 'numbers'"}, {"sha": "58819a3cf48ee2454d9958f85cc7aac28ebb7af1", "filename": "src/doc/rust.md", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -442,17 +442,14 @@ of integer literal suffix:\n The type of an _unsuffixed_ integer literal is determined by type inference.\n If an integer type can be _uniquely_ determined from the surrounding program\n context, the unsuffixed integer literal has that type.  If the program context\n-underconstrains the type, the unsuffixed integer literal's type is `int`; if\n-the program context overconstrains the type, it is considered a static type\n-error.\n+underconstrains the type, it is considered a static type error;\n+if the program context overconstrains the type,\n+it is also considered a static type error.\n \n Examples of integer literals of various forms:\n \n ~~~~\n-123; 0xff00;                       // type determined by program context\n-                                   // defaults to int in absence of type\n-                                   // information\n-\n+123i;                              // type int\n 123u;                              // type uint\n 123_u;                             // type uint\n 0xff_u8;                           // type u8\n@@ -469,17 +466,19 @@ A _floating-point literal_ has one of two forms:\n   second decimal literal.\n * A single _decimal literal_ followed by an _exponent_.\n \n-By default, a floating-point literal has a generic type, but will fall back to\n-`f64`. A floating-point literal may be followed (immediately, without any\n+By default, a floating-point literal has a generic type,\n+and, like integer literals, the type must be uniquely determined\n+from the context.\n+A floating-point literal may be followed (immediately, without any\n spaces) by a _floating-point suffix_, which changes the type of the literal.\n There are two floating-point suffixes: `f32`, and `f64` (the 32-bit and 64-bit\n floating point types).\n \n Examples of floating-point literals of various forms:\n \n ~~~~\n-123.0;                             // type f64\n-0.1;                               // type f64\n+123.0f64;                          // type f64\n+0.1f64;                            // type f64\n 0.1f32;                            // type f32\n 12E+99_f64;                        // type f64\n ~~~~\n@@ -1614,7 +1613,7 @@ extern crate libc;\n use libc::{c_char, FILE};\n \n extern {\n-    fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n+    fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n }\n # fn main() {}\n ~~~~\n@@ -2700,9 +2699,9 @@ must be a constant expression that can be evaluated at compile time, such\n as a [literal](#literals) or a [static item](#static-items).\n \n ~~~~\n-[1, 2, 3, 4];\n+[1i, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[0, ..128];             // vector with 128 zeros\n+[0i, ..128];             // vector with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n@@ -2881,7 +2880,7 @@ equals sign (`=`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n Evaluating an assignment expression [either copies or moves](#moved-and-copied-types) its right-hand operand to its left-hand operand.\n \n ~~~~\n-# let mut x = 0;\n+# let mut x = 0i;\n # let y = 0;\n \n x = y;\n@@ -2932,7 +2931,7 @@ paren_expr : '(' expr ')' ;\n An example of a parenthesized expression:\n \n ~~~~\n-let x = (2 + 3) * 4;\n+let x: int = (2 + 3) * 4;\n ~~~~\n \n \n@@ -3016,7 +3015,7 @@ conditional expression evaluates to `false`, the `while` expression completes.\n An example:\n \n ~~~~\n-let mut i = 0;\n+let mut i = 0u;\n \n while i < 10 {\n     println!(\"hello\");\n@@ -3262,7 +3261,7 @@ Patterns can also dereference pointers by using the `&`,\n on `x: &int` are equivalent:\n \n ~~~~\n-# let x = &3;\n+# let x = &3i;\n let y = match *x { 0 => \"zero\", _ => \"some\" };\n let z = match x { &0 => \"zero\", _ => \"some\" };\n \n@@ -3285,7 +3284,7 @@ A range of values may be specified with `..`.\n For example:\n \n ~~~~\n-# let x = 2;\n+# let x = 2i;\n \n let message = match x {\n   0 | 1  => \"not many\","}, {"sha": "8199eaea82c683b7cc29489b682e11fa8d9d89db", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -103,6 +103,17 @@ rustdoc can also generate JSON, for consumption by other tools, with\n `rustdoc --output-format json`, and also consume already-generated JSON with\n `rustdoc --input-format json`.\n \n+rustdoc also supports personalizing the output from crates' documentation,\n+similar to markdown options.\n+\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--html-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  search bar).\n+- `--html-after-content FILE`: includes the contents of `FILE`\n+  after all the rendered content.\n+\n # Using the Documentation\n \n The web pages generated by rustdoc present the same logical hierarchy that one\n@@ -238,16 +249,16 @@ detected by a `.md` or `.markdown` extension.\n There are 4 options to modify the output that Rustdoc creates.\n \n - `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n-- `--markdown-in-header FILE`: includes the contents of `FILE` at the\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n   end of the `<head>...</head>` section.\n-- `--markdown-before-content FILE`: includes the contents of `FILE`\n+- `--html-before-content FILE`: includes the contents of `FILE`\n   directly after `<body>`, before the rendered content (including the\n   title).\n-- `--markdown-after-content FILE`: includes the contents of `FILE`\n+- `--html-after-content FILE`: includes the contents of `FILE`\n   directly before `</body>`, after all the rendered content.\n \n All of these can be specified multiple times, and they are output in\n-the order in which they are specified. The first line of the file must\n+the order in which they are specified. The first line of the file being rendered must\n be the title, prefixed with `%` (e.g. this page has `% Rust\n Documentation` on the first line).\n "}, {"sha": "5fe6a5f14c2b426d55d112a6083dbc0889ddab6e", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -262,7 +262,7 @@ write function, variable, and module names with lowercase letters, using\n underscores where they help readability, while writing types in camel case.\n \n ~~~\n-let my_variable = 100;\n+let my_variable = 100i;\n type MyType = int;     // primitive types are _not_ camel case\n ~~~\n \n@@ -276,7 +276,7 @@ write a piece of code like this:\n \n ~~~~\n # let item = \"salad\";\n-let price;\n+let price: f64;\n if item == \"salad\" {\n     price = 3.50;\n } else if item == \"muffin\" {\n@@ -290,7 +290,7 @@ But, in Rust, you don't have to repeat the name `price`:\n \n ~~~~\n # let item = \"salad\";\n-let price =\n+let price: f64 =\n     if item == \"salad\" {\n         3.50\n     } else if item == \"muffin\" {\n@@ -337,11 +337,10 @@ suffix that can be used to indicate the type of a literal: `i` for `int`,\n In the absence of an integer literal suffix, Rust will infer the\n integer type based on type annotations and function signatures in the\n surrounding program. In the absence of any type information at all,\n-Rust will assume that an unsuffixed integer literal has type\n-`int`.\n+Rust will report an error and request that the type be specified explicitly.\n \n ~~~~\n-let a = 1;       // `a` is an `int`\n+let a: int = 1;  // `a` is an `int`\n let b = 10i;     // `b` is an `int`, due to the `i` suffix\n let c = 100u;    // `c` is a `uint`\n let d = 1000i32; // `d` is an `i32`\n@@ -475,7 +474,7 @@ against each pattern in order until one matches. The matching pattern\n executes its corresponding arm.\n \n ~~~~\n-let my_number = 1;\n+let my_number = 1i;\n match my_number {\n   0     => println!(\"zero\"),\n   1 | 2 => println!(\"one or two\"),\n@@ -501,7 +500,7 @@ matches any single value. (`..`) is a different wildcard that can match\n one or more fields in an `enum` variant.\n \n ~~~\n-# let my_number = 1;\n+# let my_number = 1i;\n match my_number {\n   0 => { println!(\"zero\") }\n   _ => { println!(\"something else\") }\n@@ -584,7 +583,7 @@ keyword `break` aborts the loop, and `continue` aborts the current\n iteration and continues with the next.\n \n ~~~~\n-let mut cake_amount = 8;\n+let mut cake_amount = 8i;\n while cake_amount > 0 {\n     cake_amount -= 1;\n }\n@@ -944,7 +943,7 @@ The `box` operator performs memory allocation on the heap:\n ~~~~\n {\n     // an integer allocated on the heap\n-    let y = box 10;\n+    let y = box 10i;\n }\n // the destructor frees the heap memory as soon as `y` goes out of scope\n ~~~~\n@@ -1165,7 +1164,7 @@ let z = x;\n The mutability of a value may be changed by moving it to a new owner:\n \n ~~~~\n-let r = box 13;\n+let r = box 13i;\n let mut s = r; // box becomes mutable\n *s += 1;\n let t = s; // box becomes immutable\n@@ -1285,9 +1284,9 @@ Using the generic `List<T>` works much like before, thanks to type inference:\n #     Cons(value, box xs)\n # }\n let mut xs = Nil; // Unknown type! This is a `List<T>`, but `T` can be anything.\n-xs = prepend(xs, 10); // Here the compiler infers `xs`'s type as `List<int>`.\n-xs = prepend(xs, 15);\n-xs = prepend(xs, 20);\n+xs = prepend(xs, 10i); // Here the compiler infers `xs`'s type as `List<int>`.\n+xs = prepend(xs, 15i);\n+xs = prepend(xs, 20i);\n ~~~\n \n The code sample above demonstrates type inference making most type annotations optional. It is\n@@ -1410,12 +1409,12 @@ Beyond the properties granted by the size, an owned box behaves as a regular\n value by inheriting the mutability and lifetime of the owner:\n \n ~~~~\n-let x = 5; // immutable\n-let mut y = 5; // mutable\n+let x = 5i; // immutable\n+let mut y = 5i; // mutable\n y += 2;\n \n-let x = box 5; // immutable\n-let mut y = box 5; // mutable\n+let x = box 5i; // immutable\n+let mut y = box 5i; // mutable\n *y += 2; // the `*` operator is needed to access the contained value\n ~~~~\n \n@@ -1507,7 +1506,7 @@ freezing enforced statically at compile-time. An example of a non-`Freeze` type\n is [`RefCell<T>`][refcell].\n \n ~~~~\n-let mut x = 5;\n+let mut x = 5i;\n {\n     let y = &x; // `x` is now frozen. It cannot be modified or re-assigned.\n }\n@@ -1523,8 +1522,8 @@ Rust uses the unary star operator (`*`) to access the contents of a\n box or pointer, similarly to C.\n \n ~~~\n-let owned = box 10;\n-let borrowed = &20;\n+let owned = box 10i;\n+let borrowed = &20i;\n \n let sum = *owned + *borrowed;\n ~~~\n@@ -1534,9 +1533,9 @@ assignments. Such an assignment modifies the value that the pointer\n points to.\n \n ~~~\n-let mut owned = box 10;\n+let mut owned = box 10i;\n \n-let mut value = 20;\n+let mut value = 20i;\n let borrowed = &mut value;\n \n *owned = *borrowed + 100;\n@@ -1654,12 +1653,12 @@ Unicode code points, so they cannot be freely mutated without the ability to\n alter the length.\n \n ~~~\n-let mut xs = [1, 2, 3];\n+let mut xs = [1i, 2i, 3i];\n let view = xs.mut_slice(0, 2);\n view[0] = 5;\n \n // The type of a mutable slice is written as `&mut [T]`\n-let ys: &mut [int] = &mut [1, 2, 3];\n+let ys: &mut [int] = &mut [1i, 2i, 3i];\n ~~~\n \n Square brackets denote indexing into a slice or fixed-size vector:"}, {"sha": "2110f19bf86d1c27cf657ed4ed1ecd9a85ce34f8", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -44,6 +44,7 @@\n     \"libsync/mpsc_intrusive.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n+    \"test/bench/shootout-mandelbrot.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD\n     \"test/bench/shootout-pidigits.rs\", # BSD\n     \"test/bench/shootout-regex-dna.rs\", # BSD"}, {"sha": "a15bd3ca60ff1c7e484b10e1997a1fb525a8bd09", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -77,34 +77,39 @@ syn keyword   rustEnumVariant Ok Err\n \"syn keyword rustFunction drop\n \n \" Types and traits {{{3\n-syn keyword rustTrait Ascii AsciiCast OwnedAsciiCast AsciiStr IntoBytes\n+syn keyword rustTrait Ascii AsciiCast OwnedAsciiCast AsciiStr\n+syn keyword rustTrait IntoBytes\n syn keyword rustTrait ToCStr\n syn keyword rustTrait Char\n syn keyword rustTrait Clone\n-syn keyword rustTrait Eq Ord PartialEq PartialOrd Ordering Equiv\n+syn keyword rustTrait PartialEq PartialOrd Eq Ord Equiv\n+syn keyword rustEnum Ordering\n syn keyword rustEnumVariant Less Equal Greater\n-syn keyword rustTrait Container Mutable Map MutableMap Set MutableSet\n-syn keyword rustTrait FromIterator Extendable\n-syn keyword rustTrait Iterator DoubleEndedIterator RandomAccessIterator CloneableIterator\n-syn keyword rustTrait OrdIterator MutableDoubleEndedIterator ExactSize\n-syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul\n-syn keyword rustTrait Signed Unsigned\n-syn keyword rustTrait Primitive Int Float FloatMath ToPrimitive FromPrimitive\n-\"syn keyword rustTrait Expect\n+syn keyword rustTrait Collection Mutable Map MutableMap\n+syn keyword rustTrait Set MutableSet\n+syn keyword rustTrait FromIterator Extendable ExactSize\n+syn keyword rustTrait Iterator DoubleEndedIterator\n+syn keyword rustTrait RandomAccessIterator CloneableIterator\n+syn keyword rustTrait OrdIterator MutableDoubleEndedIterator\n+syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n+syn keyword rustTrait Signed Unsigned Primitive Int Float\n+syn keyword rustTrait FloatMath ToPrimitive FromPrimitive\n syn keyword rustTrait Box\n syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n-syn keyword rustTrait Str StrVector StrSlice OwnedStr IntoMaybeOwned\n-syn keyword rustTrait StrAllocating\n+syn keyword rustTrait Str StrVector StrSlice OwnedStr\n+syn keyword rustTrait IntoMaybeOwned StrAllocating\n syn keyword rustTrait ToStr IntoStr\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12\n-syn keyword rustTrait CloneableVector ImmutableCloneableVector MutableCloneableVector\n+syn keyword rustTrait CloneableVector ImmutableCloneableVector\n+syn keyword rustTrait MutableCloneableVector MutableOrdVector\n syn keyword rustTrait ImmutableVector MutableVector\n-syn keyword rustTrait ImmutableEqVector ImmutableOrdVector MutableOrdVector\n-syn keyword rustTrait Vector VectorVector OwnedVector MutableVectorAllocating\n+syn keyword rustTrait ImmutableEqVector ImmutableOrdVector\n+syn keyword rustTrait Vector VectorVector\n+syn keyword rustTrait MutableVectorAllocating\n syn keyword rustTrait String\n syn keyword rustTrait Vec\n "}, {"sha": "38ed511c4589a5004a12b6510fff04bde660d845", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -376,14 +376,14 @@ mod tests {\n \n     #[test]\n     fn test_live() {\n-        let x = Arc::new(5);\n+        let x = Arc::new(5i);\n         let y = x.downgrade();\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n-        let x = Arc::new(5);\n+        let x = Arc::new(5i);\n         let y = x.downgrade();\n         drop(x);\n         assert!(y.upgrade().is_none());"}, {"sha": "dc8280e9b8361844aa2cf0e1fd71a5790bde4cd9", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -99,7 +99,7 @@ pub static mut EMPTY: uint = 12345;\n #[inline]\n unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     if size == 0 {\n-        &EMPTY as *uint as *mut u8\n+        &EMPTY as *const uint as *mut u8\n     } else {\n         allocate(size, align)\n     }\n@@ -144,9 +144,10 @@ mod imp {\n                       flags: c_int) -> size_t;\n         fn je_dallocx(ptr: *mut c_void, flags: c_int);\n         fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n-        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n+        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n+                                                                *const c_char)>,\n                                  cbopaque: *mut c_void,\n-                                 opts: *c_char);\n+                                 opts: *const c_char);\n     }\n \n     // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n@@ -226,7 +227,7 @@ mod imp {\n         // a block of memory, so we special case everything under `*uint` to\n         // just pass it to malloc, which is guaranteed to align to at least the\n         // size of `*uint`.\n-        if align < mem::size_of::<*uint>() {\n+        if align < mem::size_of::<uint>() {\n             libc_heap::malloc_raw(size)\n         } else {\n             let mut out = 0 as *mut libc::c_void;\n@@ -244,7 +245,7 @@ mod imp {\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              old_size: uint) -> *mut u8 {\n         let new_ptr = allocate(size, align);\n-        ptr::copy_memory(new_ptr, ptr as *u8, old_size);\n+        ptr::copy_memory(new_ptr, ptr as *const u8, old_size);\n         deallocate(ptr, old_size, align);\n         return new_ptr;\n     }\n@@ -328,7 +329,7 @@ mod bench {\n     #[bench]\n     fn alloc_owned_small(b: &mut Bencher) {\n         b.iter(|| {\n-            box 10\n+            box 10i\n         })\n     }\n }"}, {"sha": "26b8ccaf573718523428bd8f82c76b61be87c3e4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -70,7 +70,6 @@\n \n #![no_std]\n #![feature(lang_items, phase, unsafe_destructor)]\n-#![allow(unknown_features)] // NOTE: remove after a stage0 snap\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "addec396bbef8715d14e88ea237671424b1621b2", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -16,7 +16,9 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::intrinsics;\n+use core::kinds::Send;\n use core::mem;\n+use core::option::Option;\n use core::raw::TraitObject;\n use core::result::{Ok, Err, Result};\n \n@@ -36,7 +38,7 @@ pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang=\"owned_box\"]\n-pub struct Box<T>(*T);\n+pub struct Box<T>(*mut T);\n \n impl<T: Default> Default for Box<T> {\n     fn default() -> Box<T> { box Default::default() }\n@@ -63,6 +65,10 @@ impl<T:PartialEq> PartialEq for Box<T> {\n     fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n }\n impl<T:PartialOrd> PartialOrd for Box<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(*other)\n+    }\n     #[inline]\n     fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n     #[inline]\n@@ -106,6 +112,34 @@ impl AnyOwnExt for Box<Any> {\n     }\n }\n \n+/// Extension methods for an owning `Any+Send` trait object\n+pub trait AnySendOwnExt {\n+    /// Returns the boxed value if it is of type `T`, or\n+    /// `Err(Self)` if it isn't.\n+    fn move_send<T: 'static>(self) -> Result<Box<T>, Self>;\n+}\n+\n+impl AnySendOwnExt for Box<Any+Send> {\n+    #[inline]\n+    fn move_send<T: 'static>(self) -> Result<Box<T>, Box<Any+Send>> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let to: TraitObject =\n+                    *mem::transmute::<&Box<Any+Send>, &TraitObject>(&self);\n+\n+                // Prevent destructor on self being run\n+                intrinsics::forget(self);\n+\n+                // Extract the data pointer\n+                Ok(mem::transmute(to.data))\n+            }\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\n+\n impl<T: fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n@@ -117,3 +151,51 @@ impl fmt::Show for Box<Any> {\n         f.pad(\"Box<Any>\")\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_owned_clone() {\n+        let a = box 5i;\n+        let b: Box<int> = a.clone();\n+        assert!(a == b);\n+    }\n+\n+    #[test]\n+    fn any_move() {\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+\n+        match a.move::<uint>() {\n+            Ok(a) => { assert!(a == box 8u); }\n+            Err(..) => fail!()\n+        }\n+        match b.move::<Test>() {\n+            Ok(a) => { assert!(a == box Test); }\n+            Err(..) => fail!()\n+        }\n+\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+\n+        assert!(a.move::<Box<Test>>().is_err());\n+        assert!(b.move::<Box<uint>>().is_err());\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+        let a_str = a.to_str();\n+        let b_str = b.to_str();\n+        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n+        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n+\n+        let a = &8u as &Any;\n+        let b = &Test as &Any;\n+        let s = format!(\"{}\", a);\n+        assert_eq!(s.as_slice(), \"&Any\");\n+        let s = format!(\"{}\", b);\n+        assert_eq!(s.as_slice(), \"&Any\");\n+    }\n+}"}, {"sha": "d97bce39c2de947693943229e618881f7bd5bfe7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 147, "deletions": 9, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,23 +10,149 @@\n \n /*! Task-local reference-counted boxes (`Rc` type)\n \n-The `Rc` type provides shared ownership of an immutable value. Destruction is deterministic, and\n-will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n-overhead of atomic reference counting.\n+The `Rc` type provides shared ownership of an immutable value. Destruction is\n+deterministic, and will occur as soon as the last owner is gone. It is marked\n+as non-sendable because it avoids the overhead of atomic reference counting.\n \n-The `downgrade` method can be used to create a non-owning `Weak` pointer to the box. A `Weak`\n-pointer can be upgraded to an `Rc` pointer, but will return `None` if the value has already been\n-freed.\n+The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n+box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n+`None` if the value has already been freed.\n \n-For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n-pointers, and then storing the parent pointers as `Weak` pointers.\n+For example, a tree with parent pointers can be represented by putting the\n+nodes behind strong `Rc` pointers, and then storing the parent pointers as\n+`Weak` pointers.\n+\n+\n+## Examples\n+\n+Consider a scenario where a set of Gadgets are owned by a given Owner.  We want\n+to have our Gadgets point to their Owner.  We can't do this with unique\n+ownership, because more than one gadget may belong to the same Owner.  Rc\n+allows us to share an Owner between multiple Gadgets, and have the Owner kept\n+alive as long as any Gadget points at it.\n+\n+```rust\n+use std::rc::Rc;\n+\n+struct Owner {\n+    name: String\n+    // ...other fields\n+}\n+\n+struct Gadget {\n+    id: int,\n+    owner: Rc<Owner>\n+    // ...other fields\n+}\n+\n+fn main() {\n+    // Create a reference counted Owner.\n+    let gadget_owner : Rc<Owner> = Rc::new(\n+            Owner { name: String::from_str(\"Gadget Man\") }\n+    );\n+\n+    // Create Gadgets belonging to gadget_owner.  To increment the reference\n+    // count we clone the Rc object.\n+    let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n+    let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+\n+    drop(gadget_owner);\n+\n+    // Despite dropping gadget_owner, we're still able to print out the name of\n+    // the Owner of the Gadgets. This is because we've only dropped the\n+    // reference count object, not the Owner it wraps. As long as there are\n+    // other Rc objects pointing at the same Owner, it will stay alive. Notice\n+    // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n+    // for us.\n+    println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n+    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n+\n+    // At the end of the method, gadget1 and gadget2 get destroyed, and with\n+    // them the last counted references to our Owner.  Gadget Man now gets\n+    // destroyed as well.\n+}\n+```\n+\n+If our requirements change, and we also need to be able to traverse from\n+Owner->Gadget, we will run into problems: an Rc pointer from Owner->Gadget\n+introduces a cycle between the objects.  This means that their reference counts\n+can never reach 0, and the objects will stay alive: a memory leak.  In order to\n+get around this, we can use `Weak` pointers.  These are reference counted\n+pointers that don't keep an object alive if there are no normal `Rc` (or\n+*strong*) pointers left.\n+\n+Rust actually makes it somewhat difficult to produce this loop in the first\n+place: in order to end up with two objects that point at each other, one of\n+them needs to be mutable.  This is problematic because Rc enforces memory\n+safety by only giving out shared references to the object it wraps, and these\n+don't allow direct mutation.  We need to wrap the part of the object we wish to\n+mutate in a `RefCell`, which provides *interior mutability*: a method to\n+achieve mutability through a shared reference.  `RefCell` enforces Rust's\n+borrowing rules at runtime.  Read the `Cell` documentation for more details on\n+interior mutability.\n+\n+```rust\n+use std::rc::Rc;\n+use std::rc::Weak;\n+use std::cell::RefCell;\n+\n+struct Owner {\n+    name: String,\n+    gadgets: RefCell<Vec<Weak<Gadget>>>\n+    // ...other fields\n+}\n+\n+struct Gadget {\n+    id: int,\n+    owner: Rc<Owner>\n+    // ...other fields\n+}\n+\n+fn main() {\n+    // Create a reference counted Owner.  Note the fact that we've put the\n+    // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n+    // through a shared reference.\n+    let gadget_owner : Rc<Owner> = Rc::new(\n+            Owner {\n+                name: \"Gadget Man\".to_string(),\n+                gadgets: RefCell::new(Vec::new())\n+            }\n+    );\n+\n+    // Create Gadgets belonging to gadget_owner as before.\n+    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n+    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+\n+    // Add the Gadgets to their Owner.  To do this we mutably borrow from\n+    // the RefCell holding the Owner's Gadgets.\n+    gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n+    gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n+\n+    // Iterate over our Gadgets, printing their details out\n+    for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+\n+        // gadget_opt is a Weak<Gadget>.  Since weak pointers can't guarantee\n+        // that their object is still alive, we need to call upgrade() on them\n+        // to turn them into a strong reference.  This returns an Option, which\n+        // contains a reference to our object if it still exists.\n+        let gadget = gadget_opt.upgrade().unwrap();\n+        println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n+    }\n+\n+    // At the end of the method, gadget_owner, gadget1 and gadget2 get\n+    // destroyed.  There are now no strong (Rc) references to the gadgets.\n+    // Once they get destroyed, the Gadgets get destroyed.  This zeroes the\n+    // reference count on Gadget Man, so he gets destroyed as well.\n+}\n+```\n \n */\n \n use core::mem::transmute;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n+use core::default::Default;\n use core::kinds::marker;\n use core::ops::{Deref, Drop};\n use core::option::{Option, Some, None};\n@@ -152,6 +278,13 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n+impl<T: Default> Default for Rc<T> {\n+    #[inline]\n+    fn default() -> Rc<T> {\n+        Rc::new(Default::default())\n+    }\n+}\n+\n impl<T: PartialEq> PartialEq for Rc<T> {\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n@@ -162,6 +295,11 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n impl<T: Eq> Eq for Rc<T> {}\n \n impl<T: PartialOrd> PartialOrd for Rc<T> {\n+    #[inline(always)]\n+    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n+\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n "}, {"sha": "917de94470b35e0bf3ceb4f189e464fb747d2310", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -55,7 +55,7 @@ impl Chunk {\n         self.data.borrow().capacity()\n     }\n \n-    unsafe fn as_ptr(&self) -> *u8 {\n+    unsafe fn as_ptr(&self) -> *const u8 {\n         self.data.borrow().as_ptr()\n     }\n }\n@@ -140,22 +140,22 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *uint = mem::transmute(buf.offset(idx as int));\n+        let tydesc_data: *const uint = mem::transmute(buf.offset(idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n-        let after_tydesc = idx + mem::size_of::<*TyDesc>();\n+        let after_tydesc = idx + mem::size_of::<*const TyDesc>();\n \n         let start = round_up(after_tydesc, align);\n \n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(buf.offset(start as int) as *i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as int) as *const i8);\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up(start + size, mem::align_of::<*TyDesc>());\n+        idx = round_up(start + size, mem::align_of::<*const TyDesc>());\n     }\n }\n \n@@ -164,12 +164,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n #[inline]\n-fn bitpack_tydesc_ptr(p: *TyDesc, is_done: bool) -> uint {\n+fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> uint {\n     p as uint | (is_done as uint)\n }\n #[inline]\n-fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n-    ((p & !1) as *TyDesc, p & 1 == 1)\n+fn un_bitpack_tydesc_ptr(p: uint) -> (*const TyDesc, bool) {\n+    ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n impl Arena {\n@@ -178,7 +178,7 @@ impl Arena {\n     }\n \n     // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *const u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n@@ -190,7 +190,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *const u8 {\n         let start = round_up(self.copy_head.borrow().fill.get(), align);\n \n         let end = start + n_bytes;\n@@ -218,7 +218,8 @@ impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: uint,\n+                          align: uint) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n@@ -230,15 +231,16 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: uint,\n+                           align: uint) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n             let head = self.head.borrow();\n             let fill = head.fill.get();\n \n             let tydesc_start = fill;\n-            let after_tydesc = fill + mem::size_of::<*TyDesc>();\n+            let after_tydesc = fill + mem::size_of::<*const TyDesc>();\n             let start = round_up(after_tydesc, align);\n             let end = start + n_bytes;\n \n@@ -250,7 +252,7 @@ impl Arena {\n         }\n \n         let head = self.head.borrow();\n-        head.fill.set(round_up(end, mem::align_of::<*TyDesc>()));\n+        head.fill.set(round_up(end, mem::align_of::<*const TyDesc>()));\n \n         unsafe {\n             let buf = head.as_ptr();\n@@ -348,11 +350,11 @@ fn test_arena_destructors_fail() {\n /// run again for these objects.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n-    ptr: Cell<*T>,\n+    ptr: Cell<*const T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n-    end: Cell<*T>,\n+    end: Cell<*const T>,\n \n     /// A pointer to the first arena segment.\n     first: RefCell<TypedArenaChunkRef<T>>,\n@@ -398,7 +400,7 @@ impl<T> TypedArenaChunk<T> {\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n             for _ in range(0, len) {\n-                ptr::read(start as *T); // run the destructor on the pointer\n+                ptr::read(start as *const T); // run the destructor on the pointer\n                 start = start.offset(mem::size_of::<T>() as int)\n             }\n         }\n@@ -417,8 +419,8 @@ impl<T> TypedArenaChunk<T> {\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self) -> *u8 {\n-        let this: *TypedArenaChunk<T> = self;\n+    fn start(&self) -> *const u8 {\n+        let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n             mem::transmute(round_up(this.offset(1) as uint,\n                                     mem::min_align_of::<T>()))\n@@ -427,7 +429,7 @@ impl<T> TypedArenaChunk<T> {\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self) -> *u8 {\n+    fn end(&self) -> *const u8 {\n         unsafe {\n             let size = mem::size_of::<T>().checked_mul(&self.capacity).unwrap();\n             self.start().offset(size as int)\n@@ -448,8 +450,8 @@ impl<T> TypedArena<T> {\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n         let chunk = TypedArenaChunk::<T>::new(None, capacity);\n         TypedArena {\n-            ptr: Cell::new(chunk.start() as *T),\n-            end: Cell::new(chunk.end() as *T),\n+            ptr: Cell::new(chunk.start() as *const T),\n+            end: Cell::new(chunk.end() as *const T),\n             first: RefCell::new(Some(chunk)),\n         }\n     }\n@@ -477,8 +479,8 @@ impl<T> TypedArena<T> {\n         let chunk = self.first.borrow_mut().take_unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n         let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n-        self.ptr.set(chunk.start() as *T);\n-        self.end.set(chunk.end() as *T);\n+        self.ptr.set(chunk.start() as *const T);\n+        self.end.set(chunk.end() as *const T);\n         *self.first.borrow_mut() = Some(chunk)\n     }\n }"}, {"sha": "92abfaad3483301016fa4449e51221967446f2c9", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -107,8 +107,8 @@ impl<K: Ord, V: Eq> PartialEq for BTree<K, V> {\n impl<K: Ord, V: Eq> Eq for BTree<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for BTree<K, V> {\n-    fn lt(&self, other: &BTree<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BTree<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -229,8 +229,8 @@ impl<K: Ord, V: Eq> PartialEq for Node<K, V> {\n impl<K: Ord, V: Eq> Eq for Node<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Node<K, V> {\n-    fn lt(&self, other: &Node<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Node<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -408,8 +408,8 @@ impl<K: Ord, V: Eq> PartialEq for Leaf<K, V> {\n impl<K: Ord, V: Eq> Eq for Leaf<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Leaf<K, V> {\n-    fn lt(&self, other: &Leaf<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Leaf<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -638,8 +638,8 @@ impl<K: Ord, V: Eq> PartialEq for Branch<K, V> {\n impl<K: Ord, V: Eq> Eq for Branch<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Branch<K, V> {\n-    fn lt(&self, other: &Branch<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Branch<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -706,8 +706,8 @@ impl<K: Ord, V: Eq> PartialEq for LeafElt<K, V> {\n impl<K: Ord, V: Eq> Eq for LeafElt<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for LeafElt<K, V> {\n-    fn lt(&self, other: &LeafElt<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &LeafElt<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -755,8 +755,8 @@ impl<K: Ord, V: Eq> PartialEq for BranchElt<K, V>{\n impl<K: Ord, V: Eq> Eq for BranchElt<K, V>{}\n \n impl<K: Ord, V: Eq> PartialOrd for BranchElt<K, V> {\n-    fn lt(&self, other: &BranchElt<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BranchElt<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "4114c8cb1c4ddc8b7a5a489de9ea5ee1f7a8c518", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -595,17 +595,8 @@ impl<A: PartialEq> PartialEq for DList<A> {\n }\n \n impl<A: PartialOrd> PartialOrd for DList<A> {\n-    fn lt(&self, other: &DList<A>) -> bool {\n-        iter::order::lt(self.iter(), other.iter())\n-    }\n-    fn le(&self, other: &DList<A>) -> bool {\n-        iter::order::le(self.iter(), other.iter())\n-    }\n-    fn gt(&self, other: &DList<A>) -> bool {\n-        iter::order::gt(self.iter(), other.iter())\n-    }\n-    fn ge(&self, other: &DList<A>) -> bool {\n-        iter::order::ge(self.iter(), other.iter())\n+    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n+        iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n@@ -652,7 +643,7 @@ mod tests {\n                 (None   , None      ) => {}\n                 (None   , _         ) => fail!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n-                    assert_eq!(p as *Node<T>, pptr as *Node<T>);\n+                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n                 }\n                 _ => fail!(\"prev link is none, not good\"),\n             }"}, {"sha": "e3d1c9a3216bc8252c7110d079b5b6b6f7ff2799", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -247,7 +247,7 @@ impl<S: Writer, T: Hash<S>> Hash<S> for Option<T> {\n     }\n }\n \n-impl<S: Writer, T> Hash<S> for *T {\n+impl<S: Writer, T> Hash<S> for *const T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         // NB: raw-pointer Hash does _not_ dereference\n@@ -342,12 +342,12 @@ mod tests {\n         assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n \n         unsafe {\n-            let ptr: *int = mem::transmute(5);\n+            let ptr: *const int = mem::transmute(5i);\n             assert_eq!(hasher.hash(&ptr), 5);\n         }\n \n         unsafe {\n-            let ptr: *mut int = mem::transmute(5);\n+            let ptr: *mut int = mem::transmute(5i);\n             assert_eq!(hasher.hash(&ptr), 5);\n         }\n     }"}, {"sha": "4fd98538af7ddc93068901d28b657698a6d20f05", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -265,8 +265,6 @@ pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     state.result()\n }\n \n-\n-\n #[cfg(test)]\n mod tests {\n     use test::Bencher;"}, {"sha": "5e19accdd67152854d0bc355e3da11555b33ddb1", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -572,15 +572,15 @@ mod tests {\n     fn bench_push_back(b: &mut test::Bencher) {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n-            deq.push_back(0);\n+            deq.push_back(0i);\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n-            deq.push_front(0);\n+            deq.push_front(0i);\n         })\n     }\n \n@@ -589,7 +589,7 @@ mod tests {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n             for _ in range(0i, 65) {\n-                deq.push_front(1);\n+                deq.push_front(1i);\n             }\n         })\n     }\n@@ -651,10 +651,10 @@ mod tests {\n     #[test]\n     fn test_with_capacity() {\n         let mut d = RingBuf::with_capacity(0);\n-        d.push_back(1);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n         let mut d = RingBuf::with_capacity(50);\n-        d.push_back(1);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n     }\n "}, {"sha": "40cf8495a40593996e7f259d13f9fda43ef91ed8", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -17,7 +17,7 @@ Vectors are Rust's list type. Vectors contain zero or more values of\n homogeneous types:\n \n ```rust\n-let int_vector = [1,2,3];\n+let int_vector = [1i, 2i, 3i];\n let str_vector = [\"one\", \"two\", \"three\"];\n ```\n \n@@ -41,9 +41,9 @@ An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n a vector or a vector slice from the index interval `[a, b)`:\n \n ```rust\n-let numbers = [0, 1, 2];\n+let numbers = [0i, 1i, 2i];\n let last_numbers = numbers.slice(1, 3);\n-// last_numbers is now &[1, 2]\n+// last_numbers is now &[1i, 2i]\n ```\n \n Traits defined for the `~[T]` type, like `OwnedVector`, can only be called\n@@ -54,9 +54,9 @@ An example is the method `.push(element)` that will add an element at the end\n of the vector:\n \n ```rust\n-let mut numbers = vec![0, 1, 2];\n+let mut numbers = vec![0i, 1i, 2i];\n numbers.push(7);\n-// numbers is now vec![0, 1, 2, 7];\n+// numbers is now vec![0i, 1i, 2i, 7i];\n ```\n \n ## Implementations of other traits\n@@ -341,7 +341,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n         let mut j = i;\n         unsafe {\n             // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *T;\n+            let read_ptr = buf_v.offset(i) as *const T;\n \n             // find where to insert, we need to do strict <,\n             // rather than <=, to maintain stability.\n@@ -365,7 +365,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                                  &*buf_v.offset(j),\n                                  (i - j) as uint);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp as *T,\n+                                                &tmp as *const T,\n                                                 1);\n                 mem::forget(tmp);\n             }\n@@ -779,7 +779,7 @@ mod tests {\n     fn test_is_empty() {\n         let xs: [int, ..0] = [];\n         assert!(xs.is_empty());\n-        assert!(![0].is_empty());\n+        assert!(![0i].is_empty());\n     }\n \n     #[test]\n@@ -1528,7 +1528,7 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(box 0i, Rc::new(0i)), (box 0i, Rc::new(0i)),\n                  (box 0i, Rc::new(0i)), (box 0i, Rc::new(0i))];\n-        let mut i = 0;\n+        let mut i = 0u;\n         for _ in v.permutations() {\n             if i == 2 {\n                 fail!()\n@@ -1870,16 +1870,16 @@ mod tests {\n     fn test_overflow_does_not_cause_segfault() {\n         let mut v = vec![];\n         v.reserve_exact(-1);\n-        v.push(1);\n+        v.push(1i);\n         v.push(2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault_managed() {\n-        let mut v = vec![Rc::new(1)];\n+        let mut v = vec![Rc::new(1i)];\n         v.reserve_exact(-1);\n-        v.push(Rc::new(2));\n+        v.push(Rc::new(2i));\n     }\n \n     #[test]\n@@ -2279,7 +2279,7 @@ mod bench {\n                 v.set_len(1024);\n             }\n             for x in v.mut_iter() {\n-                *x = 0;\n+                *x = 0i;\n             }\n             v\n         });"}, {"sha": "fd8ce11d0b5a4bfdfc0256a830edff57445a8229", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -97,6 +97,15 @@ Section: Creating a string\n ///\n /// Returns `Err` with the original vector if the vector contains invalid\n /// UTF-8.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// let hello_vec = vec![104, 101, 108, 108, 111];\n+/// let string = str::from_utf8_owned(hello_vec);\n+/// assert_eq!(string, Ok(\"hello\".to_string()));\n+/// ```\n pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n     String::from_utf8(vv)\n }\n@@ -106,19 +115,44 @@ pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// let string = str::from_byte(104);\n+/// assert_eq!(string.as_slice(), \"h\");\n+/// ```\n pub fn from_byte(b: u8) -> String {\n     assert!(b < 128u8);\n     String::from_char(1, b as char)\n }\n \n /// Convert a char to a string\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// let string = str::from_char('b');\n+/// assert_eq!(string.as_slice(), \"b\");\n+/// ```\n pub fn from_char(ch: char) -> String {\n     let mut buf = String::new();\n     buf.push_char(ch);\n     buf\n }\n \n /// Convert a vector of chars to a string\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// let chars = ['h', 'e', 'l', 'l', 'o'];\n+/// let string = str::from_chars(chars);\n+/// assert_eq!(string.as_slice(), \"hello\");\n+/// ```\n pub fn from_chars(chs: &[char]) -> String {\n     chs.iter().map(|c| *c).collect()\n }\n@@ -572,8 +606,8 @@ impl<'a> Eq for MaybeOwned<'a> {}\n \n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n-    fn lt(&self, other: &MaybeOwned) -> bool {\n-        self.as_slice().lt(&other.as_slice())\n+    fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -661,7 +695,7 @@ pub mod raw {\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> String {\n+    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n         let mut result = String::new();\n         result.push_bytes(mem::transmute(Slice {\n             data: buf,\n@@ -671,7 +705,7 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(c_string: *i8) -> String {\n+    pub unsafe fn from_c_str(c_string: *const i8) -> String {\n         let mut buf = String::new();\n         let mut len = 0;\n         while *c_string.offset(len) != 0 {\n@@ -803,15 +837,9 @@ pub trait StrAllocating: Str {\n     }\n \n     /// Converts to a vector of `u16` encoded as UTF-16.\n+    #[deprecated = \"use `utf16_units` instead\"]\n     fn to_utf16(&self) -> Vec<u16> {\n-        let me = self.as_slice();\n-        let mut u = Vec::new();\n-        for ch in me.chars() {\n-            let mut buf = [0u16, ..2];\n-            let n = ch.encode_utf16(buf /* as mut slice! */);\n-            u.push_all(buf.slice_to(n));\n-        }\n-        u\n+        self.as_slice().utf16_units().collect::<Vec<u16>>()\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n@@ -1103,7 +1131,7 @@ mod tests {\n         assert_eq!(\"bc\", unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n         assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n         fn a_million_letter_a() -> String {\n-            let mut i = 0;\n+            let mut i = 0u;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaaaaaaa\");\n@@ -1112,7 +1140,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_a() -> String {\n-            let mut i = 0;\n+            let mut i = 0u;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaa\");\n@@ -1220,7 +1248,7 @@ mod tests {\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n         fn a_million_letter_x() -> String {\n-            let mut i = 0;\n+            let mut i = 0u;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n@@ -1229,7 +1257,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_x() -> String {\n-            let mut i = 0;\n+            let mut i = 0u;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n@@ -1541,8 +1569,8 @@ mod tests {\n         let n2: uint = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n-            let a: u8 = s1.as_slice()[i];\n-            let b: u8 = s2.as_slice()[i];\n+            let a: u8 = s1.as_bytes()[i];\n+            let b: u8 = s2.as_bytes()[i];\n             debug!(\"{}\", a);\n             debug!(\"{}\", b);\n             assert_eq!(a, b);\n@@ -1619,14 +1647,17 @@ mod tests {\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n+            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let u_as_string = from_utf16(u.as_slice()).unwrap();\n+\n             assert!(is_utf16(u.as_slice()));\n-            assert_eq!(s.to_utf16(), u);\n+            assert_eq!(s_as_utf16, u);\n \n-            assert_eq!(from_utf16(u.as_slice()).unwrap(), s);\n+            assert_eq!(u_as_string, s);\n             assert_eq!(from_utf16_lossy(u.as_slice()), s);\n \n-            assert_eq!(from_utf16(s.to_utf16().as_slice()).unwrap(), s);\n-            assert_eq!(from_utf16(u.as_slice()).unwrap().to_utf16(), u);\n+            assert_eq!(from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n+            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n         }\n     }\n "}, {"sha": "936e60388a66ae8223cca470b4f837d626399bfc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -222,7 +222,7 @@ impl String {\n             return None\n         }\n \n-        let byte = self.as_slice()[len - 1];\n+        let byte = self.as_bytes()[len - 1];\n         self.vec.set_len(len - 1);\n         Some(byte)\n     }"}, {"sha": "becceffe6d0270254fe0017f0c3be5e4cee6abb9", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -56,23 +56,11 @@ impl<K: PartialEq + Ord, V: PartialEq> PartialEq for TreeMap<K, V> {\n     }\n }\n \n-// Lexicographical comparison\n-fn lt<K: PartialOrd + Ord, V: PartialOrd>(a: &TreeMap<K, V>,\n-                                 b: &TreeMap<K, V>) -> bool {\n-    // the Zip iterator is as long as the shortest of a and b.\n-    for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n-        if *key_a < *key_b { return true; }\n-        if *key_a > *key_b { return false; }\n-        if *value_a < *value_b { return true; }\n-        if *value_a > *value_b { return false; }\n-    }\n-\n-    a.len() < b.len()\n-}\n-\n-impl<K: PartialOrd + Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n+impl<K: Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n     #[inline]\n-    fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n+    fn partial_cmp(&self, other: &TreeMap<K, V>) -> Option<Ordering> {\n+        iter::order::partial_cmp(self.iter(), other.iter())\n+    }\n }\n \n impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n@@ -287,7 +275,7 @@ pub struct Entries<'a, K, V> {\n     // See the comment on MutEntries; this is just to allow\n     // code-sharing (for this immutable-values iterator it *could* very\n     // well be Option<&'a TreeNode<K,V>>).\n-    node: *TreeNode<K, V>,\n+    node: *const TreeNode<K, V>,\n     remaining_min: uint,\n     remaining_max: uint\n }\n@@ -468,11 +456,11 @@ define_iterator! {\n     addr_mut = mut\n }\n \n-fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *TreeNode<K, V> {\n+fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *const TreeNode<K, V> {\n     match *node {\n         Some(ref n) => {\n             let n: &TreeNode<K, V> = *n;\n-            n as *TreeNode<K, V>\n+            n as *const TreeNode<K, V>\n         }\n         None => ptr::null()\n     }\n@@ -568,9 +556,11 @@ impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n }\n \n-impl<T: PartialOrd + Ord> PartialOrd for TreeSet<T> {\n+impl<T: Ord> PartialOrd for TreeSet<T> {\n     #[inline]\n-    fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n+    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n+        self.map.partial_cmp(&other.map)\n+    }\n }\n \n impl<T: Ord + Show> Show for TreeSet<T> {"}, {"sha": "9b6355e121bea459af7c7e4336e3e7396256648d", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -189,7 +189,9 @@ macro_rules! bound {\n             // We like sharing code so much that even a little unsafe won't\n             // stop us.\n             let this = $this;\n-            let mut node = addr!(& $($mut_)* this.root as * $($mut_)* TrieNode<T>);\n+            let mut node = unsafe {\n+                mem::transmute::<_, uint>(&this.root) as *mut TrieNode<T>\n+            };\n \n             let key = $key;\n \n@@ -205,7 +207,10 @@ macro_rules! bound {\n                     let child_id = chunk(key, it.length);\n                     let (slice_idx, ret) = match children[child_id] {\n                         Internal(ref $($mut_)* n) => {\n-                            node = addr!(& $($mut_)* **n as * $($mut_)* TrieNode<T>);\n+                            node = unsafe {\n+                                mem::transmute::<_, uint>(&**n)\n+                                    as *mut TrieNode<T>\n+                            };\n                             (child_id + 1, false)\n                         }\n                         External(stored, _) => {"}, {"sha": "2ffc168f82c0eef4b4d77244a873ed3cd327d1a6", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -389,8 +389,8 @@ impl<T: PartialEq> PartialEq for Vec<T> {\n \n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n-    fn lt(&self, other: &Vec<T>) -> bool {\n-        self.as_slice() < other.as_slice()\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(&other.as_slice())\n     }\n }\n \n@@ -615,7 +615,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n+            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -674,7 +674,10 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            mem::transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n+            mem::transmute(Slice {\n+                data: self.as_mut_ptr() as *const T,\n+                len: self.len,\n+            })\n         }\n     }\n \n@@ -956,14 +959,17 @@ impl<T> Vec<T> {\n     ///\n     /// # Failure\n     ///\n-    /// Fails if `index` is out of bounds of the vector.\n+    /// Fails if `index` is not between `0` and the vector's length (both\n+    /// bounds inclusive).\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let mut vec = vec!(1i, 2, 3);\n     /// vec.insert(1, 4);\n     /// assert_eq!(vec, vec!(1, 4, 2, 3));\n+    /// vec.insert(4, 5);\n+    /// assert_eq!(vec, vec!(1, 4, 2, 3, 5));\n     /// ```\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n@@ -1011,7 +1017,7 @@ impl<T> Vec<T> {\n                     let ptr = self.as_mut_ptr().offset(index as int);\n                     // copy it out, unsafely having a copy of the value on\n                     // the stack and in the vector at the same time.\n-                    ret = Some(ptr::read(ptr as *T));\n+                    ret = Some(ptr::read(ptr as *const T));\n \n                     // Shift everything down to fill in that spot.\n                     ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n@@ -1200,15 +1206,15 @@ impl<T> Vec<T> {\n     /// Modifying the vector may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    pub fn as_ptr(&self) -> *T {\n+    pub fn as_ptr(&self) -> *const T {\n         // If we have a 0-sized vector, then the base pointer should not be NULL\n         // because an iterator over the slice will attempt to yield the base\n         // pointer as the first element in the vector, but this will end up\n         // being Some(NULL) which is optimized to None.\n         if mem::size_of::<T>() == 0 {\n-            1 as *T\n+            1 as *const T\n         } else {\n-            self.ptr as *T\n+            self.ptr as *const T\n         }\n     }\n \n@@ -1542,7 +1548,7 @@ pub mod raw {\n     /// The elements of the buffer are copied into the vector without cloning,\n     /// as if `ptr::read()` were called on them.\n     #[inline]\n-    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> Vec<T> {\n+    pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);"}, {"sha": "8021fa50d8f4647ac3155d8050f9d329c6aff435", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -115,179 +115,3 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-    use realstd::owned::{Box, AnyOwnExt};\n-    use realstd::str::Str;\n-\n-    #[deriving(PartialEq, Show)]\n-    struct Test;\n-\n-    static TEST: &'static str = \"Test\";\n-\n-    #[test]\n-    fn any_referenced() {\n-        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_owning() {\n-        let (a, b, c) = (box 5u as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_as_ref() {\n-        let a = &5u as &Any;\n-\n-        match a.as_ref::<uint>() {\n-            Some(&5) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a.as_ref::<Test>() {\n-            None => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_as_mut() {\n-        let mut a = 5u;\n-        let mut b = box 7u;\n-\n-        let a_r = &mut a as &mut Any;\n-        let tmp: &mut uint = &mut *b;\n-        let b_r = tmp as &mut Any;\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 5u);\n-                *x = 612;\n-            }\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 7u);\n-                *x = 413;\n-            }\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(&612) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(&413) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_move() {\n-        use realstd::any::Any;\n-        use realstd::result::{Ok, Err};\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n-\n-        match a.move::<uint>() {\n-            Ok(a) => { assert!(a == box 8u); }\n-            Err(..) => fail!()\n-        }\n-        match b.move::<Test>() {\n-            Ok(a) => { assert!(a == box Test); }\n-            Err(..) => fail!()\n-        }\n-\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n-\n-        assert!(a.move::<Box<Test>>().is_err());\n-        assert!(b.move::<Box<uint>>().is_err());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        use realstd::to_str::ToStr;\n-        let a = box 8u as Box<::realstd::any::Any>;\n-        let b = box Test as Box<::realstd::any::Any>;\n-        let a_str = a.to_str();\n-        let b_str = b.to_str();\n-        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n-        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n-\n-        let a = &8u as &Any;\n-        let b = &Test as &Any;\n-        let s = format!(\"{}\", a);\n-        assert_eq!(s.as_slice(), \"&Any\");\n-        let s = format!(\"{}\", b);\n-        assert_eq!(s.as_slice(), \"&Any\");\n-    }\n-\n-    #[test]\n-    fn any_fixed_vec() {\n-        let test = [0u, ..8];\n-        let test = &test as &Any;\n-        assert!(test.is::<[uint, ..8]>());\n-        assert!(!test.is::<[uint, ..10]>());\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use any::{Any, AnyRefExt};\n-    use option::Some;\n-    use self::test::Bencher;\n-\n-    #[bench]\n-    fn bench_as_ref(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut x = 0i;\n-            let mut y = &mut x as &mut Any;\n-            test::black_box(&mut y);\n-            test::black_box(y.as_ref::<int>() == Some(&0));\n-        });\n-    }\n-}"}, {"sha": "971799acc7862e61efb2112990ddf8fa045a5bef", "filename": "src/libcore/atomics.rs", "status": "modified", "additions": 5, "deletions": 99, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -94,7 +94,7 @@ impl AtomicBool {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n+        unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n \n     /// Store the value\n@@ -295,7 +295,7 @@ impl AtomicInt {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(self.v.get() as *int, order) }\n+        unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n \n     /// Store the value\n@@ -407,7 +407,7 @@ impl AtomicUint {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(self.v.get() as *uint, order) }\n+        unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n \n     /// Store the value\n@@ -520,7 +520,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(self.p.get() as **mut T, order) as *mut T\n+            atomic_load(self.p.get() as *const *mut T, order) as *mut T\n         }\n     }\n \n@@ -560,7 +560,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n+unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n@@ -693,97 +693,3 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn bool_() {\n-        let a = AtomicBool::new(false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n-\n-        a.store(false, SeqCst);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    }\n-\n-    #[test]\n-    fn bool_and() {\n-        let a = AtomicBool::new(true);\n-        assert_eq!(a.fetch_and(false, SeqCst),true);\n-        assert_eq!(a.load(SeqCst),false);\n-    }\n-\n-    #[test]\n-    fn uint_and() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_or() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_xor() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_and() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_or() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_xor() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n-\n-    #[test]\n-    fn static_init() {\n-        unsafe {\n-            assert!(!S_BOOL.load(SeqCst));\n-            assert!(S_INT.load(SeqCst) == 0);\n-            assert!(S_UINT.load(SeqCst) == 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn different_sizes() {\n-        unsafe {\n-            let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n-\n-            let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n-\n-            let slot = 0u32;\n-            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n-\n-            let mut slot = 0u64;\n-            super::atomic_store(&mut slot, 2, SeqCst);\n-        }\n-    }\n-}"}, {"sha": "355ee7c7a16f010c48b2f954b4d58eef7e2adbcb", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 133, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -67,10 +67,10 @@\n //!\n //! fn main() {\n //!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n-//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n-//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n-//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n-//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n+//!     shared_map.borrow_mut().insert(\"africa\", 92388i);\n+//!     shared_map.borrow_mut().insert(\"kyoto\", 11837i);\n+//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826i);\n+//!     shared_map.borrow_mut().insert(\"marbles\", 38i);\n //! }\n //! ```\n //!\n@@ -383,132 +383,3 @@ impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n         unsafe { &mut *self._parent.value.get() }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use mem::drop;\n-\n-    #[test]\n-    fn smoketest_cell() {\n-        let x = Cell::new(10i);\n-        assert!(x == Cell::new(10));\n-        assert!(x.get() == 10);\n-        x.set(20);\n-        assert!(x == Cell::new(20));\n-        assert!(x.get() == 20);\n-\n-        let y = Cell::new((30i, 40i));\n-        assert!(y == Cell::new((30, 40)));\n-        assert!(y.get() == (30, 40));\n-    }\n-\n-    #[test]\n-    fn cell_has_sensible_show() {\n-        use str::StrSlice;\n-        use realstd::str::Str;\n-\n-        let x = Cell::new(\"foo bar\");\n-        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n-\n-        x.set(\"baz qux\");\n-        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n-    }\n-\n-    #[test]\n-    fn ref_and_refmut_have_sensible_show() {\n-        use str::StrSlice;\n-        use realstd::str::Str;\n-\n-        let refcell = RefCell::new(\"foo\");\n-\n-        let refcell_refmut = refcell.borrow_mut();\n-        assert!(format!(\"{}\", refcell_refmut).as_slice().contains(\"foo\"));\n-        drop(refcell_refmut);\n-\n-        let refcell_ref = refcell.borrow();\n-        assert!(format!(\"{}\", refcell_ref).as_slice().contains(\"foo\"));\n-        drop(refcell_ref);\n-    }\n-\n-    #[test]\n-    fn double_imm_borrow() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn no_mut_then_imm_borrow() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow().is_none());\n-    }\n-\n-    #[test]\n-    fn no_imm_then_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn no_double_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn imm_release_borrow_mut() {\n-        let x = RefCell::new(0);\n-        {\n-            let _b1 = x.borrow();\n-        }\n-        x.borrow_mut();\n-    }\n-\n-    #[test]\n-    fn mut_release_borrow_mut() {\n-        let x = RefCell::new(0);\n-        {\n-            let _b1 = x.borrow_mut();\n-        }\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn double_borrow_single_release_no_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        {\n-            let _b2 = x.borrow();\n-        }\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn discard_doesnt_unborrow() {\n-        let x = RefCell::new(0);\n-        let _b = x.borrow();\n-        let _ = _b;\n-        let _b = x.borrow_mut();\n-    }\n-\n-    #[test]\n-    #[allow(experimental)]\n-    fn clone_ref_updates_flag() {\n-        let x = RefCell::new(0);\n-        {\n-            let b1 = x.borrow();\n-            assert!(x.try_borrow_mut().is_none());\n-            {\n-                let _b2 = clone_ref(&b1);\n-                assert!(x.try_borrow_mut().is_none());\n-            }\n-            assert!(x.try_borrow_mut().is_none());\n-        }\n-        assert!(x.try_borrow_mut().is_some());\n-    }\n-}"}, {"sha": "da67772d0f1229c3a311bfeaf2166c549c6f1037", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -602,205 +602,3 @@ impl Char for char {\n }\n \n \n-#[cfg(test)]\n-mod test {\n-    use super::{escape_unicode, escape_default};\n-\n-    use char::Char;\n-    use slice::ImmutableVector;\n-    use option::{Some, None};\n-    use realstd::string::String;\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_is_lowercase() {\n-        assert!('a'.is_lowercase());\n-        assert!('\u00f6'.is_lowercase());\n-        assert!('\u00df'.is_lowercase());\n-        assert!(!'\u00dc'.is_lowercase());\n-        assert!(!'P'.is_lowercase());\n-    }\n-\n-    #[test]\n-    fn test_is_uppercase() {\n-        assert!(!'h'.is_uppercase());\n-        assert!(!'\u00e4'.is_uppercase());\n-        assert!(!'\u00df'.is_uppercase());\n-        assert!('\u00d6'.is_uppercase());\n-        assert!('T'.is_uppercase());\n-    }\n-\n-    #[test]\n-    fn test_is_whitespace() {\n-        assert!(' '.is_whitespace());\n-        assert!('\\u2007'.is_whitespace());\n-        assert!('\\t'.is_whitespace());\n-        assert!('\\n'.is_whitespace());\n-        assert!(!'a'.is_whitespace());\n-        assert!(!'_'.is_whitespace());\n-        assert!(!'\\u0000'.is_whitespace());\n-    }\n-\n-    #[test]\n-    fn test_to_digit() {\n-        assert_eq!('0'.to_digit(10u), Some(0u));\n-        assert_eq!('1'.to_digit(2u), Some(1u));\n-        assert_eq!('2'.to_digit(3u), Some(2u));\n-        assert_eq!('9'.to_digit(10u), Some(9u));\n-        assert_eq!('a'.to_digit(16u), Some(10u));\n-        assert_eq!('A'.to_digit(16u), Some(10u));\n-        assert_eq!('b'.to_digit(16u), Some(11u));\n-        assert_eq!('B'.to_digit(16u), Some(11u));\n-        assert_eq!('z'.to_digit(36u), Some(35u));\n-        assert_eq!('Z'.to_digit(36u), Some(35u));\n-        assert_eq!(' '.to_digit(10u), None);\n-        assert_eq!('$'.to_digit(36u), None);\n-    }\n-\n-    #[test]\n-    fn test_to_lowercase() {\n-        assert_eq!('A'.to_lowercase(), 'a');\n-        assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n-        assert_eq!('\u00df'.to_lowercase(), '\u00df');\n-        assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n-        assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n-        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-        assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n-        assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n-        assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n-        assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n-        assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n-        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-    }\n-\n-    #[test]\n-    fn test_to_uppercase() {\n-        assert_eq!('a'.to_uppercase(), 'A');\n-        assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n-        assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n-        assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n-        assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n-\n-        assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n-        assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n-        assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n-        assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n-        assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n-        assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n-        assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n-    }\n-\n-    #[test]\n-    fn test_is_control() {\n-        assert!('\\u0000'.is_control());\n-        assert!('\\u0003'.is_control());\n-        assert!('\\u0006'.is_control());\n-        assert!('\\u0009'.is_control());\n-        assert!('\\u007f'.is_control());\n-        assert!('\\u0092'.is_control());\n-        assert!(!'\\u0020'.is_control());\n-        assert!(!'\\u0055'.is_control());\n-        assert!(!'\\u0068'.is_control());\n-    }\n-\n-    #[test]\n-    fn test_is_digit() {\n-       assert!('2'.is_digit());\n-       assert!('7'.is_digit());\n-       assert!(!'c'.is_digit());\n-       assert!(!'i'.is_digit());\n-       assert!(!'z'.is_digit());\n-       assert!(!'Q'.is_digit());\n-    }\n-\n-    #[test]\n-    fn test_escape_default() {\n-        fn string(c: char) -> String {\n-            let mut result = String::new();\n-            escape_default(c, |c| { result.push_char(c); });\n-            return result;\n-        }\n-        let s = string('\\n');\n-        assert_eq!(s.as_slice(), \"\\\\n\");\n-        let s = string('\\r');\n-        assert_eq!(s.as_slice(), \"\\\\r\");\n-        let s = string('\\'');\n-        assert_eq!(s.as_slice(), \"\\\\'\");\n-        let s = string('\"');\n-        assert_eq!(s.as_slice(), \"\\\\\\\"\");\n-        let s = string(' ');\n-        assert_eq!(s.as_slice(), \" \");\n-        let s = string('a');\n-        assert_eq!(s.as_slice(), \"a\");\n-        let s = string('~');\n-        assert_eq!(s.as_slice(), \"~\");\n-        let s = string('\\x00');\n-        assert_eq!(s.as_slice(), \"\\\\x00\");\n-        let s = string('\\x1f');\n-        assert_eq!(s.as_slice(), \"\\\\x1f\");\n-        let s = string('\\x7f');\n-        assert_eq!(s.as_slice(), \"\\\\x7f\");\n-        let s = string('\\xff');\n-        assert_eq!(s.as_slice(), \"\\\\xff\");\n-        let s = string('\\u011b');\n-        assert_eq!(s.as_slice(), \"\\\\u011b\");\n-        let s = string('\\U0001d4b6');\n-        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n-    }\n-\n-    #[test]\n-    fn test_escape_unicode() {\n-        fn string(c: char) -> String {\n-            let mut result = String::new();\n-            escape_unicode(c, |c| { result.push_char(c); });\n-            return result;\n-        }\n-        let s = string('\\x00');\n-        assert_eq!(s.as_slice(), \"\\\\x00\");\n-        let s = string('\\n');\n-        assert_eq!(s.as_slice(), \"\\\\x0a\");\n-        let s = string(' ');\n-        assert_eq!(s.as_slice(), \"\\\\x20\");\n-        let s = string('a');\n-        assert_eq!(s.as_slice(), \"\\\\x61\");\n-        let s = string('\\u011b');\n-        assert_eq!(s.as_slice(), \"\\\\u011b\");\n-        let s = string('\\U0001d4b6');\n-        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n-    }\n-\n-    #[test]\n-    fn test_to_str() {\n-        use realstd::to_str::ToStr;\n-        let s = 't'.to_str();\n-        assert_eq!(s.as_slice(), \"t\");\n-    }\n-\n-    #[test]\n-    fn test_encode_utf8() {\n-        fn check(input: char, expect: &[u8]) {\n-            let mut buf = [0u8, ..4];\n-            let n = input.encode_utf8(buf /* as mut slice! */);\n-            assert_eq!(buf.slice_to(n), expect);\n-        }\n-\n-        check('x', [0x78]);\n-        check('\\u00e9', [0xc3, 0xa9]);\n-        check('\\ua66e', [0xea, 0x99, 0xae]);\n-        check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n-    }\n-\n-    #[test]\n-    fn test_encode_utf16() {\n-        fn check(input: char, expect: &[u16]) {\n-            let mut buf = [0u16, ..2];\n-            let n = input.encode_utf16(buf /* as mut slice! */);\n-            assert_eq!(buf.slice_to(n), expect);\n-        }\n-\n-        check('x', [0x0078]);\n-        check('\\u00e9', [0x00e9]);\n-        check('\\ua66e', [0xa66e]);\n-        check('\\U0001f4a9', [0xd83d, 0xdca9]);\n-    }\n-}"}, {"sha": "247f63115a783be9dba296ec49c69a7f8b816bd4", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -110,63 +110,3 @@ extern_fn_clone!(A, B, C, D, E, F)\n extern_fn_clone!(A, B, C, D, E, F, G)\n extern_fn_clone!(A, B, C, D, E, F, G, H)\n \n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use realstd::owned::Box;\n-    use realstd::gc::{Gc, GC};\n-\n-    fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n-        use realstd::clone::Clone;\n-        t.clone()\n-    }\n-\n-    fn realclone_from<T: ::realstd::clone::Clone>(t1: &mut T, t2: &T) {\n-        use realstd::clone::Clone;\n-        t1.clone_from(t2)\n-    }\n-\n-    #[test]\n-    fn test_owned_clone() {\n-        let a = box 5i;\n-        let b: Box<int> = realclone(&a);\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_managed_clone() {\n-        let a = box(GC) 5i;\n-        let b: Gc<int> = realclone(&a);\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_borrowed_clone() {\n-        let x = 5i;\n-        let y: &int = &x;\n-        let z: &int = (&y).clone();\n-        assert_eq!(*z, 5);\n-    }\n-\n-    #[test]\n-    fn test_clone_from() {\n-        let a = box 5i;\n-        let mut b = box 10i;\n-        realclone_from(&mut b, &a);\n-        assert_eq!(*b, 5);\n-    }\n-\n-    #[test]\n-    fn test_extern_fn_clone() {\n-        trait Empty {}\n-        impl Empty for int {}\n-\n-        fn test_fn_a() -> f64 { 1.0 }\n-        fn test_fn_b<T: Empty>(x: T) -> T { x }\n-        fn test_fn_c(_: int, _: f64, _: int, _: int, _: int) {}\n-\n-        let _ = test_fn_a.clone();\n-        let _ = test_fn_b::<int>.clone();\n-        let _ = test_fn_c.clone();\n-    }\n-}"}, {"sha": "8696d385c44884d6d257b03818de2360e7f574c3", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 75, "deletions": 76, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -37,6 +37,10 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n+use option::{Option, Some};\n+#[cfg(stage0)]\n+use option::None;\n+\n /// Trait for values that can be compared for equality and inequality.\n ///\n /// This trait allows for partial equality, for types that do not have an\n@@ -86,11 +90,11 @@ pub trait Eq: PartialEq {\n #[deriving(Clone, PartialEq, Show)]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n-   Less = -1,\n+   Less = -1i,\n    /// An ordering where a compared value is equal [to another].\n-   Equal = 0,\n+   Equal = 0i,\n    /// An ordering where a compared value is greater [than another].\n-   Greater = 1\n+   Greater = 1i,\n }\n \n /// Trait for types that form a [total order](\n@@ -127,7 +131,9 @@ impl Ord for Ordering {\n \n impl PartialOrd for Ordering {\n     #[inline]\n-    fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n+    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n+        (*self as int).partial_cmp(&(*other as int))\n+    }\n }\n \n /// Combine orderings, lexically.\n@@ -145,7 +151,7 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n-/// PartialOrd only requires implementation of the `lt` method,\n+/// PartialOrd only requires implementation of the `partial_cmp` method,\n /// with the others generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types\n@@ -154,20 +160,57 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n pub trait PartialOrd: PartialEq {\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    #[cfg(stage0)]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        match (!self.lt(other), !other.lt(self)) {\n+            (false, false) => None,\n+            (false, true) => Some(Less),\n+            (true, false) => Some(Greater),\n+            (true, true) => Some(Equal),\n+        }\n+    }\n+\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    #[cfg(not(stage0))]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n+\n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n-    fn lt(&self, other: &Self) -> bool;\n+    fn lt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    fn le(&self, other: &Self) -> bool { !other.lt(self) }\n+    fn le(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n+    fn gt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n+    fn ge(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// The equivalence relation. Two values may be equivalent even if they are\n@@ -192,10 +235,10 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n-#[cfg(not(test))]\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n+    use option::{Option, Some, None};\n \n     macro_rules! eq_impl(\n         ($($t:ty)*) => ($(\n@@ -228,6 +271,15 @@ mod impls {\n     macro_rules! ord_impl(\n         ($($t:ty)*) => ($(\n             impl PartialOrd for $t {\n+                #[inline]\n+                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n+                    match (self <= other, self >= other) {\n+                        (false, false) => None,\n+                        (false, true) => Some(Greater),\n+                        (true, false) => Some(Less),\n+                        (true, true) => Some(Equal),\n+                    }\n+                }\n                 #[inline]\n                 fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                 #[inline]\n@@ -242,13 +294,15 @@ mod impls {\n \n     impl PartialOrd for () {\n         #[inline]\n-        fn lt(&self, _other: &()) -> bool { false }\n+        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n+            Some(Equal)\n+        }\n     }\n \n     impl PartialOrd for bool {\n         #[inline]\n-        fn lt(&self, other: &bool) -> bool {\n-            (*self as u8) < (*other as u8)\n+        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n+            (*self as u8).partial_cmp(&(*other as u8))\n         }\n     }\n \n@@ -289,6 +343,10 @@ mod impls {\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+            (**self).partial_cmp(*other)\n+        }\n         #[inline]\n         fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }\n         #[inline]\n@@ -312,6 +370,10 @@ mod impls {\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+            (**self).partial_cmp(*other)\n+        }\n         #[inline]\n         fn lt(&self, other: &&'a mut T) -> bool { **self < **other }\n         #[inline]\n@@ -327,66 +389,3 @@ mod impls {\n     }\n     impl<'a, T: Eq> Eq for &'a mut T {}\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::lexical_ordering;\n-\n-    #[test]\n-    fn test_int_totalord() {\n-        assert_eq!(5u.cmp(&10), Less);\n-        assert_eq!(10u.cmp(&5), Greater);\n-        assert_eq!(5u.cmp(&5), Equal);\n-        assert_eq!((-5u).cmp(&12), Less);\n-        assert_eq!(12u.cmp(-5), Greater);\n-    }\n-\n-    #[test]\n-    fn test_mut_int_totalord() {\n-        assert_eq!((&mut 5u).cmp(&10), Less);\n-        assert_eq!((&mut 10u).cmp(&5), Greater);\n-        assert_eq!((&mut 5u).cmp(&5), Equal);\n-        assert_eq!((&mut -5u).cmp(&12), Less);\n-        assert_eq!((&mut 12u).cmp(-5), Greater);\n-    }\n-\n-    #[test]\n-    fn test_ordering_order() {\n-        assert!(Less < Equal);\n-        assert_eq!(Greater.cmp(&Less), Greater);\n-    }\n-\n-    #[test]\n-    fn test_lexical_ordering() {\n-        fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n-            assert_eq!(lexical_ordering(o1, o2), e);\n-        }\n-\n-        let xs = [Less, Equal, Greater];\n-        for &o in xs.iter() {\n-            t(Less, o, Less);\n-            t(Equal, o, o);\n-            t(Greater, o, Greater);\n-         }\n-    }\n-\n-    #[test]\n-    fn test_user_defined_eq() {\n-        // Our type.\n-        struct SketchyNum {\n-            num : int\n-        }\n-\n-        // Our implementation of `PartialEq` to support `==` and `!=`.\n-        impl PartialEq for SketchyNum {\n-            // Our custom eq allows numbers which are near each other to be equal! :D\n-            fn eq(&self, other: &SketchyNum) -> bool {\n-                (self.num - other.num).abs() < 5\n-            }\n-        }\n-\n-        // Now these binary operators will work when applied!\n-        assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-        assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n-    }\n-}"}, {"sha": "4bc39db8ecf0932e2baef0c8e67406ed325f5110", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -31,11 +31,10 @@\n #![allow(dead_code, missing_doc)]\n \n use fmt;\n-#[cfg(not(test))] use intrinsics;\n+use intrinsics;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n-#[cfg(not(test))]\n fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     format_args!(|args| -> () {\n         begin_unwind(args, file, line);\n@@ -46,7 +45,6 @@ fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n \n #[cold]\n #[lang=\"fail_bounds_check\"]\n-#[cfg(not(test))]\n fn fail_bounds_check(file: &'static str, line: uint,\n                      index: uint, len: uint) -> ! {\n     format_args!(|args| -> () {"}, {"sha": "514b3f90df7c0dfde86baa6d9b56f9bd93da9072", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -115,55 +115,3 @@ impl<'a,A> Drop for Finallyalizer<'a,A> {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n-    use super::{try_finally, Finally};\n-    use realstd::task::failing;\n-\n-    #[test]\n-    fn test_success() {\n-        let mut i = 0i;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| {\n-                *i = 10;\n-            },\n-            |i| {\n-                assert!(!failing());\n-                assert_eq!(*i, 10);\n-                *i = 20;\n-            });\n-        assert_eq!(i, 20);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_fail() {\n-        let mut i = 0i;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| {\n-                *i = 10;\n-                fail!();\n-            },\n-            |i| {\n-                assert!(failing());\n-                assert_eq!(*i, 10);\n-            })\n-    }\n-\n-    #[test]\n-    fn test_retval() {\n-        let mut closure: || -> int = || 10;\n-        let i = closure.finally(|| { });\n-        assert_eq!(i, 10);\n-    }\n-\n-    #[test]\n-    fn test_compact() {\n-        fn do_some_fallible_work() {}\n-        fn but_always_run_this_function() { }\n-        let mut f = do_some_fallible_work;\n-        f.finally(but_always_run_this_function);\n-    }\n-}"}, {"sha": "7b84c005db548667c25f635e76d14888138858b9", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -314,11 +314,11 @@ impl<'a> Formatter<'a> {\n             rt::CountImplied => { None }\n             rt::CountIsParam(i) => {\n                 let v = self.args[i].value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n+                unsafe { Some(*(v as *const _ as *const uint)) }\n             }\n             rt::CountIsNextParam => {\n                 let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n+                unsafe { Some(*(v as *const _ as *const uint)) }\n             }\n         }\n     }\n@@ -496,31 +496,6 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n     }\n }\n \n-#[cfg(test)]\n-pub fn format(args: &Arguments) -> ::realstd::string::String {\n-    use str;\n-    use realstd::io::MemWriter;\n-\n-    fn mywrite<T: ::realstd::io::Writer>(t: &mut T, b: &[u8]) {\n-        use realstd::io::Writer;\n-        let _ = t.write(b);\n-    }\n-\n-    impl FormatWriter for MemWriter {\n-        fn write(&mut self, bytes: &[u8]) -> Result {\n-            mywrite(self, bytes);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut i = MemWriter::new();\n-    let _ = write(&mut i, args);\n-\n-    let mut result = ::realstd::string::String::new();\n-    result.push_str(str::from_utf8(i.get_ref()).unwrap());\n-    result\n-}\n-\n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n #[doc(hidden)] #[inline]\n@@ -543,6 +518,9 @@ impl<'a, T: Show> Show for &'a T {\n impl<'a, T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n }\n+impl<'a> Show for &'a Show {\n+    fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n+}\n \n impl Bool for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n@@ -565,25 +543,25 @@ impl Char for char {\n     }\n }\n \n-impl<T> Pointer for *T {\n+impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(*self as *T), f)\n+        secret_pointer::<*const T>(&(*self as *const T), f)\n     }\n }\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n+        secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n+        secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n \n@@ -669,7 +647,7 @@ delegate!(char to char)\n delegate!(f32 to float)\n delegate!(f64 to float)\n \n-impl<T> Show for *T {\n+impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n impl<T> Show for *mut T {\n@@ -686,7 +664,7 @@ macro_rules! tuple (\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 try!(write!(f, \"(\"));\n                 let ($(ref $name,)*) = *self;\n-                let mut n = 0;\n+                let mut n = 0i;\n                 $(\n                     if n > 0 {\n                         try!(write!(f, \", \"));"}, {"sha": "d52791f6b0ea2e2768240bd6484d09099a6a1d8a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -188,283 +188,3 @@ integer!(i8, u8)\n integer!(i16, u16)\n integer!(i32, u32)\n integer!(i64, u64)\n-\n-#[cfg(test)]\n-mod tests {\n-    use fmt::radix;\n-    use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n-    use super::{GenericRadix, Radix};\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_radix_base() {\n-        assert_eq!(Binary.base(), 2);\n-        assert_eq!(Octal.base(), 8);\n-        assert_eq!(Decimal.base(), 10);\n-        assert_eq!(LowerHex.base(), 16);\n-        assert_eq!(UpperHex.base(), 16);\n-        assert_eq!(Radix { base: 36 }.base(), 36);\n-    }\n-\n-    #[test]\n-    fn test_radix_prefix() {\n-        assert_eq!(Binary.prefix(), \"0b\");\n-        assert_eq!(Octal.prefix(), \"0o\");\n-        assert_eq!(Decimal.prefix(), \"\");\n-        assert_eq!(LowerHex.prefix(), \"0x\");\n-        assert_eq!(UpperHex.prefix(), \"0x\");\n-        assert_eq!(Radix { base: 36 }.prefix(), \"\");\n-    }\n-\n-    #[test]\n-    fn test_radix_digit() {\n-        assert_eq!(Binary.digit(0), '0' as u8);\n-        assert_eq!(Binary.digit(2), '2' as u8);\n-        assert_eq!(Octal.digit(0), '0' as u8);\n-        assert_eq!(Octal.digit(7), '7' as u8);\n-        assert_eq!(Decimal.digit(0), '0' as u8);\n-        assert_eq!(Decimal.digit(9), '9' as u8);\n-        assert_eq!(LowerHex.digit(0), '0' as u8);\n-        assert_eq!(LowerHex.digit(10), 'a' as u8);\n-        assert_eq!(LowerHex.digit(15), 'f' as u8);\n-        assert_eq!(UpperHex.digit(0), '0' as u8);\n-        assert_eq!(UpperHex.digit(10), 'A' as u8);\n-        assert_eq!(UpperHex.digit(15), 'F' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(0), '0' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(15), 'f' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(35), 'z' as u8);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_hex_radix_digit_overflow() {\n-        let _ = LowerHex.digit(16);\n-    }\n-\n-    #[test]\n-    fn test_format_int() {\n-        // Formatting integers should select the right implementation based off\n-        // the type of the argument. Also, hex/octal/binary should be defined\n-        // for integers, but they shouldn't emit the negative sign.\n-        assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n-        assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n-\n-        assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n-\n-        // Test a larger number\n-        assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n-        assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n-        assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n-        assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n-        assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_zero() {\n-        assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n-\n-        assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_flags() {\n-        assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n-        assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n-        assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n-        assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n-        assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n-        assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n-        assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n-        assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n-        assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n-        assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n-        assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n-        assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n-        assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n-        assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n-        assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n-        assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n-        assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n-        assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n-        assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n-        assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n-        assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n-        assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_sign_padding() {\n-        assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n-        assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n-        assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n-        assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n-        assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n-        assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_twos_complement() {\n-        use {i8, i16, i32, i64};\n-        assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n-        assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n-        assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n-        assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n-    }\n-\n-    #[test]\n-    fn test_format_radix() {\n-        assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n-        assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_radix_base_too_large() {\n-        let _ = radix(55, 37);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    mod uint {\n-        use super::test::Bencher;\n-        use fmt::radix;\n-        use realstd::rand::{weak_rng, Rng};\n-\n-        #[bench]\n-        fn format_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n-        }\n-    }\n-\n-    mod int {\n-        use super::test::Bencher;\n-        use fmt::radix;\n-        use realstd::rand::{weak_rng, Rng};\n-\n-        #[bench]\n-        fn format_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n-        }\n-    }\n-}"}, {"sha": "161dd7cef7e13fc3efdde9818fb24ece8df3ec6d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -44,14 +44,9 @@ A quick refresher on memory ordering:\n #![experimental]\n #![allow(missing_doc)]\n \n-// This is needed to prevent duplicate lang item definitions.\n-#[cfg(test)]\n-pub use realcore::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n-\n-pub type GlueFn = extern \"Rust\" fn(*i8);\n+pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n-#[cfg(not(test))]\n pub struct TyDesc {\n     // sizeof(T)\n     pub size: uint,\n@@ -70,13 +65,11 @@ pub struct TyDesc {\n }\n \n #[lang=\"opaque\"]\n-#[cfg(not(test))]\n pub enum Opaque { }\n \n pub type Disr = u64;\n \n #[lang=\"ty_visitor\"]\n-#[cfg(not(test))]\n pub trait TyVisitor {\n     fn visit_bot(&mut self) -> bool;\n     fn visit_nil(&mut self) -> bool;\n@@ -102,55 +95,58 @@ pub trait TyVisitor {\n     fn visit_estr_slice(&mut self) -> bool;\n     fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool;\n+                        mtbl: uint, inner: *const TyDesc) -> bool;\n \n     fn visit_enter_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool;\n+                       mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          sz: uint, align: uint) -> bool;\n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *TyDesc) -> bool;\n+                         mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          sz: uint, align: uint) -> bool;\n \n     fn visit_enter_tup(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool;\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_tup(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n     fn visit_enter_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n+                                inner: *const TyDesc) -> bool;\n     fn visit_leave_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n \n     fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool;\n+    fn visit_fn_input(&mut self, i: uint, mode: uint,\n+                      inner: *const TyDesc) -> bool;\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n+                       inner: *const TyDesc) -> bool;\n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n \n@@ -170,9 +166,9 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;\n \n-    pub fn atomic_load<T>(src: *T) -> T;\n-    pub fn atomic_load_acq<T>(src: *T) -> T;\n-    pub fn atomic_load_relaxed<T>(src: *T) -> T;\n+    pub fn atomic_load<T>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n \n     pub fn atomic_store<T>(dst: *mut T, val: T);\n     pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n@@ -276,7 +272,7 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n-    pub fn get_tydesc<T>() -> *TyDesc;\n+    pub fn get_tydesc<T>() -> *const TyDesc;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n@@ -320,25 +316,25 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn owns_managed<T>() -> bool;\n \n-    pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);\n+    pub fn visit_tydesc(td: *const TyDesc, tv: &mut TyVisitor);\n \n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n-    pub fn offset<T>(dst: *T, offset: int) -> *T;\n+    pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n-    pub fn copy_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n@@ -350,13 +346,14 @@ extern \"rust-intrinsic\" {\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n+                                                  count: uint);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_copy_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n@@ -365,7 +362,7 @@ extern \"rust-intrinsic\" {\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Perform a volatile load from the `src` pointer.\n-    pub fn volatile_load<T>(src: *T) -> T;\n+    pub fn volatile_load<T>(src: *const T) -> T;\n     /// Perform a volatile store to the `dst` pointer.\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n@@ -560,12 +557,10 @@ extern \"rust-intrinsic\" {\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n #[deriving(PartialEq, Eq, Show)]\n-#[cfg(not(test))]\n pub struct TypeId {\n     t: u64,\n }\n \n-#[cfg(not(test))]\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n     pub fn of<T: 'static>() -> TypeId {"}, {"sha": "5895d871dbe18e2bb3467f72c09f1fb630e3b9c0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 25, "deletions": 870, "changes": 895, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -135,7 +135,8 @@ pub trait Iterator<A> {\n     /// let a = [0i];\n     /// let b = [1i];\n     /// let mut it = a.iter().zip(b.iter());\n-    /// assert_eq!(it.next().unwrap(), (&0, &1));\n+    /// let (x0, x1) = (0i, 1i);\n+    /// assert_eq!(it.next().unwrap(), (&x0, &x1));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -202,8 +203,9 @@ pub trait Iterator<A> {\n     /// ```rust\n     /// let a = [100i, 200];\n     /// let mut it = a.iter().enumerate();\n-    /// assert_eq!(it.next().unwrap(), (0, &100));\n-    /// assert_eq!(it.next().unwrap(), (1, &200));\n+    /// let (x100, x200) = (100i, 200i);\n+    /// assert_eq!(it.next().unwrap(), (0, &x100));\n+    /// assert_eq!(it.next().unwrap(), (1, &x200));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -220,11 +222,11 @@ pub trait Iterator<A> {\n     /// ```rust\n     /// let xs = [100i, 200, 300];\n     /// let mut it = xs.iter().map(|x| *x).peekable();\n-    /// assert_eq!(it.peek().unwrap(), &100);\n+    /// assert_eq!(*it.peek().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 200);\n-    /// assert_eq!(it.peek().unwrap(), &300);\n-    /// assert_eq!(it.peek().unwrap(), &300);\n+    /// assert_eq!(*it.peek().unwrap(), 300);\n+    /// assert_eq!(*it.peek().unwrap(), 300);\n     /// assert_eq!(it.next().unwrap(), 300);\n     /// assert!(it.peek().is_none());\n     /// assert!(it.next().is_none());\n@@ -2181,7 +2183,7 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `Eq`\n@@ -2210,6 +2212,22 @@ pub mod order {\n         }\n     }\n \n+    /// Order `a` and `b` lexicographically using `PartialOrd`\n+    pub fn partial_cmp<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S)\n+            -> Option<cmp::Ordering> {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return Some(cmp::Equal),\n+                (None, _   ) => return Some(cmp::Less),\n+                (_   , None) => return Some(cmp::Greater),\n+                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n+                    Some(cmp::Equal) => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n     pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n@@ -2279,868 +2297,5 @@ pub mod order {\n             }\n         }\n     }\n-\n-    #[test]\n-    fn test_lt() {\n-        use slice::ImmutableVector;\n-\n-        let empty: [int, ..0] = [];\n-        let xs = [1i,2,3];\n-        let ys = [1i,2,0];\n-\n-        assert!(!lt(xs.iter(), ys.iter()));\n-        assert!(!le(xs.iter(), ys.iter()));\n-        assert!( gt(xs.iter(), ys.iter()));\n-        assert!( ge(xs.iter(), ys.iter()));\n-\n-        assert!( lt(ys.iter(), xs.iter()));\n-        assert!( le(ys.iter(), xs.iter()));\n-        assert!(!gt(ys.iter(), xs.iter()));\n-        assert!(!ge(ys.iter(), xs.iter()));\n-\n-        assert!( lt(empty.iter(), xs.iter()));\n-        assert!( le(empty.iter(), xs.iter()));\n-        assert!(!gt(empty.iter(), xs.iter()));\n-        assert!(!ge(empty.iter(), xs.iter()));\n-\n-        // Sequence with NaN\n-        let u = [1.0f64, 2.0];\n-        let v = [0.0f64/0.0, 3.0];\n-\n-        assert!(!lt(u.iter(), v.iter()));\n-        assert!(!le(u.iter(), v.iter()));\n-        assert!(!gt(u.iter(), v.iter()));\n-        assert!(!ge(u.iter(), v.iter()));\n-\n-        let a = [0.0f64/0.0];\n-        let b = [1.0f64];\n-        let c = [2.0f64];\n-\n-        assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n-        assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n-        assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n-        assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n-\n-        assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n-        assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n-        assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n-        assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n-    }\n-\n-    #[test]\n-    fn test_multi_iter() {\n-        use slice::ImmutableVector;\n-        use iter::DoubleEndedIterator;\n-        let xs = [1i,2,3,4];\n-        let ys = [4i,3,2,1];\n-        assert!(eq(xs.iter(), ys.iter().rev()));\n-        assert!(lt(xs.iter(), xs.iter().skip(2)));\n-    }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use iter::*;\n-    use num;\n-    use realstd::vec::Vec;\n-    use realstd::slice::Vector;\n-    use realstd::gc::GC;\n-\n-    use cmp;\n-    use realstd::owned::Box;\n-    use uint;\n-\n-    impl<T> FromIterator<T> for Vec<T> {\n-        fn from_iter<I: Iterator<T>>(mut iterator: I) -> Vec<T> {\n-            let mut v = Vec::new();\n-            for e in iterator {\n-                v.push(e);\n-            }\n-            return v;\n-        }\n-    }\n-\n-    impl<'a, T> Iterator<&'a T> for ::realcore::slice::Items<'a, T> {\n-        fn next(&mut self) -> Option<&'a T> {\n-            use RealSome = realcore::option::Some;\n-            use RealNone = realcore::option::None;\n-            fn mynext<T, I: ::realcore::iter::Iterator<T>>(i: &mut I)\n-                -> ::realcore::option::Option<T>\n-            {\n-                use realcore::iter::Iterator;\n-                i.next()\n-            }\n-            match mynext(self) {\n-                RealSome(t) => Some(t),\n-                RealNone => None,\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_counter_from_iter() {\n-        let it = count(0i, 5).take(10);\n-        let xs: Vec<int> = FromIterator::from_iter(it);\n-        assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n-    }\n-\n-    #[test]\n-    fn test_iterator_chain() {\n-        let xs = [0u, 1, 2, 3, 4, 5];\n-        let ys = [30u, 40, 50, 60];\n-        let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-        let mut it = xs.iter().chain(ys.iter());\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, expected[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        let ys = count(30u, 10).take(4);\n-        let mut it = xs.iter().map(|&x| x).chain(ys);\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, expected[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_filter_map() {\n-        let mut it = count(0u, 1u).take(10)\n-            .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n-    }\n-\n-    #[test]\n-    fn test_iterator_enumerate() {\n-        let xs = [0u, 1, 2, 3, 4, 5];\n-        let mut it = xs.iter().enumerate();\n-        for (i, &x) in it {\n-            assert_eq!(i, x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_peekable() {\n-        let xs = vec![0u, 1, 2, 3, 4, 5];\n-        let mut it = xs.iter().map(|&x|x).peekable();\n-        assert_eq!(it.peek().unwrap(), &0);\n-        assert_eq!(it.next().unwrap(), 0);\n-        assert_eq!(it.next().unwrap(), 1);\n-        assert_eq!(it.next().unwrap(), 2);\n-        assert_eq!(it.peek().unwrap(), &3);\n-        assert_eq!(it.peek().unwrap(), &3);\n-        assert_eq!(it.next().unwrap(), 3);\n-        assert_eq!(it.next().unwrap(), 4);\n-        assert_eq!(it.peek().unwrap(), &5);\n-        assert_eq!(it.next().unwrap(), 5);\n-        assert!(it.peek().is_none());\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iterator_take_while() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [0u, 1, 2, 3, 5, 13];\n-        let mut it = xs.iter().take_while(|&x| *x < 15u);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_skip_while() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [15, 16, 17, 19];\n-        let mut it = xs.iter().skip_while(|&x| *x < 15u);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_skip() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n-        let ys = [13, 15, 16, 17, 19, 20, 30];\n-        let mut it = xs.iter().skip(5);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_take() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [0u, 1, 2, 3, 5];\n-        let mut it = xs.iter().take(5);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_scan() {\n-        // test the type inference\n-        fn add(old: &mut int, new: &uint) -> Option<f64> {\n-            *old += *new as int;\n-            Some(*old as f64)\n-        }\n-        let xs = [0u, 1, 2, 3, 4];\n-        let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n-\n-        let mut it = xs.iter().scan(0, add);\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_flat_map() {\n-        let xs = [0u, 3, 6];\n-        let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_inspect() {\n-        let xs = [1u, 2, 3, 4];\n-        let mut n = 0;\n-\n-        let ys = xs.iter()\n-                   .map(|&x| x)\n-                   .inspect(|_| n += 1)\n-                   .collect::<Vec<uint>>();\n-\n-        assert_eq!(n, xs.len());\n-        assert_eq!(xs.as_slice(), ys.as_slice());\n-    }\n-\n-    #[test]\n-    fn test_unfoldr() {\n-        fn count(st: &mut uint) -> Option<uint> {\n-            if *st < 10 {\n-                let ret = Some(*st);\n-                *st += 1;\n-                ret\n-            } else {\n-                None\n-            }\n-        }\n-\n-        let mut it = Unfold::new(0, count);\n-        let mut i = 0;\n-        for counted in it {\n-            assert_eq!(counted, i);\n-            i += 1;\n-        }\n-        assert_eq!(i, 10);\n-    }\n-\n-    #[test]\n-    fn test_cycle() {\n-        let cycle_len = 3;\n-        let it = count(0u, 1).take(cycle_len).cycle();\n-        assert_eq!(it.size_hint(), (uint::MAX, None));\n-        for (i, x) in it.take(100).enumerate() {\n-            assert_eq!(i % cycle_len, x);\n-        }\n-\n-        let mut it = count(0u, 1).take(0).cycle();\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_nth() {\n-        let v = &[0i, 1, 2, 3, 4];\n-        for i in range(0u, v.len()) {\n-            assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_last() {\n-        let v = &[0i, 1, 2, 3, 4];\n-        assert_eq!(v.iter().last().unwrap(), &4);\n-        assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_len() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().count(), 4);\n-        assert_eq!(v.slice(0, 10).iter().count(), 10);\n-        assert_eq!(v.slice(0, 0).iter().count(), 0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_sum() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n-        assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_product() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n-        assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n-    }\n-\n-    #[test]\n-    fn test_iterator_max() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n-        assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_min() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n-        assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_size_hint() {\n-        let c = count(0i, 1);\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-        let v2 = &[10i, 11, 12];\n-        let vi = v.iter();\n-\n-        assert_eq!(c.size_hint(), (uint::MAX, None));\n-        assert_eq!(vi.size_hint(), (10, Some(10)));\n-\n-        assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-        assert_eq!(c.skip(5).size_hint().val1(), None);\n-        assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n-        assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n-        assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n-        assert_eq!(c.scan(0, |_,_| Some(0)).size_hint(), (0, None));\n-        assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.map(|_| 0).size_hint(), (uint::MAX, None));\n-        assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n-\n-        assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n-        assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n-        assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n-        assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n-        assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n-        assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n-        assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n-        assert_eq!(vi.scan(0, |_,_| Some(0)).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n-        assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let a = vec![1i, 2, 3, 4, 5];\n-        let b: Vec<int> = a.iter().map(|&x| x).collect();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n-        assert!(v.iter().all(|&x| x < 10));\n-        assert!(!v.iter().all(|&x| x % 2 == 0));\n-        assert!(!v.iter().all(|&x| x > 100));\n-        assert!(v.slice(0, 0).iter().all(|_| fail!()));\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n-        assert!(v.iter().any(|&x| x < 10));\n-        assert!(v.iter().any(|&x| x % 2 == 0));\n-        assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n-        assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n-        assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n-    }\n-\n-    #[test]\n-    fn test_position() {\n-        let v = &[1i, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n-        assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n-        assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n-    }\n-\n-    #[test]\n-    fn test_count() {\n-        let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n-        assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n-        assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n-        assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n-    }\n-\n-    #[test]\n-    fn test_max_by() {\n-        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n-        assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n-    }\n-\n-    #[test]\n-    fn test_min_by() {\n-        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n-        assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_by_ref() {\n-        let mut xs = range(0i, 10);\n-        // sum the first five values\n-        let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n-        assert_eq!(partial_sum, 10);\n-        assert_eq!(xs.next(), Some(5));\n-    }\n-\n-    #[test]\n-    fn test_rev() {\n-        let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n-        let mut it = xs.iter();\n-        it.next();\n-        it.next();\n-        assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n-                vec![16, 14, 12, 10, 8, 6]);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_map() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().map(|&x| x * -1);\n-        assert_eq!(it.next(), Some(-1));\n-        assert_eq!(it.next(), Some(-2));\n-        assert_eq!(it.next_back(), Some(-6));\n-        assert_eq!(it.next_back(), Some(-5));\n-        assert_eq!(it.next(), Some(-3));\n-        assert_eq!(it.next_back(), Some(-4));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_enumerate() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().map(|&x| x).enumerate();\n-        assert_eq!(it.next(), Some((0, 1)));\n-        assert_eq!(it.next(), Some((1, 2)));\n-        assert_eq!(it.next_back(), Some((5, 6)));\n-        assert_eq!(it.next_back(), Some((4, 5)));\n-        assert_eq!(it.next_back(), Some((3, 4)));\n-        assert_eq!(it.next_back(), Some((2, 3)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_zip() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let ys = [1i, 2, 3, 7];\n-        let a = xs.iter().map(|&x| x);\n-        let b = ys.iter().map(|&x| x);\n-        let mut it = a.zip(b);\n-        assert_eq!(it.next(), Some((1, 1)));\n-        assert_eq!(it.next(), Some((2, 2)));\n-        assert_eq!(it.next_back(), Some((4, 7)));\n-        assert_eq!(it.next_back(), Some((3, 3)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_filter() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n-        assert_eq!(it.next_back().unwrap(), &6);\n-        assert_eq!(it.next_back().unwrap(), &4);\n-        assert_eq!(it.next().unwrap(), &2);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_filter_map() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n-        assert_eq!(it.next_back().unwrap(), 12);\n-        assert_eq!(it.next_back().unwrap(), 8);\n-        assert_eq!(it.next().unwrap(), 4);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_chain() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        let mut it = xs.iter().chain(ys.iter()).rev();\n-        assert_eq!(it.next().unwrap(), &11)\n-        assert_eq!(it.next().unwrap(), &9)\n-        assert_eq!(it.next_back().unwrap(), &1)\n-        assert_eq!(it.next_back().unwrap(), &2)\n-        assert_eq!(it.next_back().unwrap(), &3)\n-        assert_eq!(it.next_back().unwrap(), &4)\n-        assert_eq!(it.next_back().unwrap(), &5)\n-        assert_eq!(it.next_back().unwrap(), &7)\n-        assert_eq!(it.next_back(), None)\n-    }\n-\n-    #[test]\n-    fn test_rposition() {\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert_eq!(v.iter().rposition(f), Some(3u));\n-        assert!(v.iter().rposition(g).is_none());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_rposition_fail() {\n-        let v = [(box 0i, box(GC) 0i), (box 0i, box(GC) 0i),\n-                 (box 0i, box(GC) 0i), (box 0i, box(GC) 0i)];\n-        let mut i = 0i;\n-        v.iter().rposition(|_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-            false\n-        });\n-    }\n-\n-\n-    #[cfg(test)]\n-    fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n-    {\n-        let mut b = a.clone();\n-        assert_eq!(len, b.indexable());\n-        let mut n = 0u;\n-        for (i, elt) in a.enumerate() {\n-            assert!(Some(elt) == b.idx(i));\n-            n += 1;\n-        }\n-        assert_eq!(n, len);\n-        assert!(None == b.idx(n));\n-        // call recursively to check after picking off an element\n-        if len > 0 {\n-            b.next();\n-            check_randacc_iter(b, len-1);\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_double_ended_flat_map() {\n-        let u = [0u,1];\n-        let v = [5u,6,7,8];\n-        let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n-        assert_eq!(it.next_back().unwrap(), &8);\n-        assert_eq!(it.next().unwrap(),      &5);\n-        assert_eq!(it.next_back().unwrap(), &7);\n-        assert_eq!(it.next_back().unwrap(), &6);\n-        assert_eq!(it.next_back().unwrap(), &8);\n-        assert_eq!(it.next().unwrap(),      &6);\n-        assert_eq!(it.next_back().unwrap(), &7);\n-        assert_eq!(it.next_back(), None);\n-        assert_eq!(it.next(),      None);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_random_access_chain() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        let mut it = xs.iter().chain(ys.iter());\n-        assert_eq!(it.idx(0).unwrap(), &1);\n-        assert_eq!(it.idx(5).unwrap(), &7);\n-        assert_eq!(it.idx(7).unwrap(), &11);\n-        assert!(it.idx(8).is_none());\n-\n-        it.next();\n-        it.next();\n-        it.next_back();\n-\n-        assert_eq!(it.idx(0).unwrap(), &3);\n-        assert_eq!(it.idx(4).unwrap(), &9);\n-        assert!(it.idx(6).is_none());\n-\n-        check_randacc_iter(it, xs.len() + ys.len() - 3);\n-    }\n-\n-    #[test]\n-    fn test_random_access_enumerate() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        check_randacc_iter(xs.iter().enumerate(), xs.len());\n-    }\n-\n-    #[test]\n-    fn test_random_access_rev() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        check_randacc_iter(xs.iter().rev(), xs.len());\n-        let mut it = xs.iter().rev();\n-        it.next();\n-        it.next_back();\n-        it.next();\n-        check_randacc_iter(it, xs.len() - 3);\n-    }\n-\n-    #[test]\n-    fn test_random_access_zip() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n-    }\n-\n-    #[test]\n-    fn test_random_access_take() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().take(3), 3);\n-        check_randacc_iter(xs.iter().take(20), xs.len());\n-        check_randacc_iter(xs.iter().take(0), 0);\n-        check_randacc_iter(empty.iter().take(2), 0);\n-    }\n-\n-    #[test]\n-    fn test_random_access_skip() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n-        check_randacc_iter(empty.iter().skip(2), 0);\n-    }\n-\n-    #[test]\n-    fn test_random_access_inspect() {\n-        let xs = [1i, 2, 3, 4, 5];\n-\n-        // test .map and .inspect that don't implement Clone\n-        let mut it = xs.iter().inspect(|_| {});\n-        assert_eq!(xs.len(), it.indexable());\n-        for (i, elt) in xs.iter().enumerate() {\n-            assert_eq!(Some(elt), it.idx(i));\n-        }\n-\n-    }\n-\n-    #[test]\n-    fn test_random_access_map() {\n-        let xs = [1i, 2, 3, 4, 5];\n-\n-        let mut it = xs.iter().map(|x| *x);\n-        assert_eq!(xs.len(), it.indexable());\n-        for (i, elt) in xs.iter().enumerate() {\n-            assert_eq!(Some(*elt), it.idx(i));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_random_access_cycle() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().cycle().take(27), 27);\n-        check_randacc_iter(empty.iter().cycle(), 0);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_range() {\n-        assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n-        for _ in range(10i, 0).rev() {\n-            fail!(\"unreachable\");\n-        }\n-\n-        assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n-        for _ in range(10u, 0).rev() {\n-            fail!(\"unreachable\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_range() {\n-        /// A mock type to check Range when ToPrimitive returns None\n-        struct Foo;\n-\n-        impl ToPrimitive for Foo {\n-            fn to_i64(&self) -> Option<i64> { None }\n-            fn to_u64(&self) -> Option<u64> { None }\n-        }\n-\n-        impl Add<Foo, Foo> for Foo {\n-            fn add(&self, _: &Foo) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl PartialEq for Foo {\n-            fn eq(&self, _: &Foo) -> bool {\n-                true\n-            }\n-        }\n-\n-        impl PartialOrd for Foo {\n-            fn lt(&self, _: &Foo) -> bool {\n-                false\n-            }\n-        }\n-\n-        impl Clone for Foo {\n-            fn clone(&self) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl Mul<Foo, Foo> for Foo {\n-            fn mul(&self, _: &Foo) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl num::One for Foo {\n-            fn one() -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n-        assert!(range(-10i, -1).collect::<Vec<int>>() ==\n-                   vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n-        assert_eq!(range(200i, -5).count(), 0);\n-        assert_eq!(range(200i, -5).rev().count(), 0);\n-        assert_eq!(range(200i, 200).count(), 0);\n-        assert_eq!(range(200i, 200).rev().count(), 0);\n-\n-        assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n-        // this test is only meaningful when sizeof uint < sizeof u64\n-        assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n-        assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n-        assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n-    }\n-\n-    #[test]\n-    fn test_range_inclusive() {\n-        assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n-                vec![0i, 1, 2, 3, 4, 5]);\n-        assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n-                vec![5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200i, -5).count(), 0);\n-        assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n-        assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n-        assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n-    }\n-\n-    #[test]\n-    fn test_range_step() {\n-        assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n-                vec![0, 5, 10, 15]);\n-        assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n-                vec![20, 15, 10, 5]);\n-        assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n-                vec![20, 14, 8, 2]);\n-        assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n-                vec![200u8, 250]);\n-        assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n-        assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n-    }\n-\n-    #[test]\n-    fn test_range_step_inclusive() {\n-        assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n-                vec![0, 5, 10, 15, 20]);\n-        assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n-                vec![20, 15, 10, 5, 0]);\n-        assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n-                vec![20, 14, 8, 2]);\n-        assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n-                vec![200u8, 250]);\n-        assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n-                vec![]);\n-        assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n-                vec![200]);\n-    }\n-\n-    #[test]\n-    fn test_reverse() {\n-        let mut ys = [1i, 2, 3, 4, 5];\n-        ys.mut_iter().reverse_();\n-        assert!(ys == [5, 4, 3, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_peekable_is_empty() {\n-        let a = [1i];\n-        let mut it = a.iter().peekable();\n-        assert!( !it.is_empty() );\n-        it.next();\n-        assert!( it.is_empty() );\n-    }\n-\n-    #[test]\n-    fn test_min_max() {\n-        let v: [int, ..0] = [];\n-        assert_eq!(v.iter().min_max(), NoElements);\n-\n-        let v = [1i];\n-        assert!(v.iter().min_max() == OneElement(&1));\n-\n-        let v = [1i, 2, 3, 4, 5];\n-        assert!(v.iter().min_max() == MinMax(&1, &5));\n-\n-        let v = [1i, 2, 3, 4, 5, 6];\n-        assert!(v.iter().min_max() == MinMax(&1, &6));\n-\n-        let v = [1i, 1, 1, 1];\n-        assert!(v.iter().min_max() == MinMax(&1, &1));\n-    }\n-\n-    #[test]\n-    fn test_min_max_result() {\n-        let r: MinMaxResult<int> = NoElements;\n-        assert_eq!(r.into_option(), None)\n-\n-        let r = OneElement(1i);\n-        assert_eq!(r.into_option(), Some((1,1)));\n-\n-        let r = MinMax(1i,2);\n-        assert_eq!(r.into_option(), Some((1,2)));\n-    }\n-}"}, {"sha": "9a6cdb1c7697654008d3ce1a4b6294679d764e47", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -155,7 +155,7 @@ pub mod marker {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// struct S<T> { x: *() }\n+    /// struct S<T> { x: *const () }\n     /// fn get<T>(s: &S<T>, v: T) {\n     ///    unsafe {\n     ///        let x: fn(T) = mem::transmute(s.x);"}, {"sha": "08153355e9e2d613a2eebf79461bd6b373bae52f", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -43,7 +43,9 @@\n //!   the failure message, the file at which failure was invoked, and the line.\n //!   It is up to consumers of this core library to define this failure\n //!   function; it is only required to never return.\n-//!\n+\n+// Since libcore defines many fundamental lang items, all tests live in a\n+// separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_id = \"core#0.11.0\"]\n #![experimental]\n@@ -58,17 +60,6 @@\n #![feature(globs, intrinsics, lang_items, macro_rules, managed_boxes, phase)]\n #![feature(simd, unsafe_destructor)]\n #![deny(missing_doc)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n-\n-#[cfg(test)] extern crate realcore = \"core\";\n-#[cfg(test)] extern crate libc;\n-#[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate realstd = \"std\";\n-\n-#[cfg(test)] pub use cmp = realcore::cmp;\n-#[cfg(test)] pub use kinds = realcore::kinds;\n-#[cfg(test)] pub use ops = realcore::ops;\n-#[cfg(test)] pub use ty = realcore::ty;\n \n mod macros;\n \n@@ -105,10 +96,10 @@ pub mod ptr;\n \n /* Core language traits */\n \n-#[cfg(not(test))] pub mod kinds;\n-#[cfg(not(test))] pub mod ops;\n-#[cfg(not(test))] pub mod ty;\n-#[cfg(not(test))] pub mod cmp;\n+pub mod kinds;\n+pub mod ops;\n+pub mod ty;\n+pub mod cmp;\n pub mod clone;\n pub mod default;\n pub mod collections;\n@@ -145,11 +136,4 @@ mod std {\n     pub use kinds;\n     pub use option;\n     pub use fmt;\n-\n-    #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n-    // #[cfg(test)] pub use realstd::option; // needed for fail!()\n-    // #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n-    #[cfg(test)] pub use realstd::os;     // needed for tests\n-    #[cfg(test)] pub use realstd::slice;  // needed for tests\n-    #[cfg(test)] pub use realstd::vec;    // needed for vec![]\n }"}, {"sha": "93c838198c559b60792b945f2f49cfa68af86089", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -112,16 +112,6 @@ macro_rules! writeln(\n     )\n )\n \n-#[cfg(test)]\n-macro_rules! vec( ($($e:expr),*) => ({\n-    let mut _v = ::std::vec::Vec::new();\n-    $(_v.push($e);)*\n-    _v\n-}) )\n-\n-#[cfg(test)]\n-macro_rules! format( ($($arg:tt)*) => (format_args!(::fmt::format, $($arg)*)) )\n-\n /// Write some formatted data into a stream.\n ///\n /// Identical to the macro in `std::macros`"}, {"sha": "06e28816c1cd5015cca5bb4901b6c258f10d500b", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 180, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -363,7 +363,7 @@ pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }\n #[inline]\n #[stable]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read(src as *T as *U)\n+    ptr::read(src as *const T as *const U)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n@@ -382,182 +382,3 @@ pub unsafe fn copy_mut_lifetime<'a, S, T>(_ptr: &'a mut S,\n                                           ptr: &mut T) -> &'a mut T {\n     transmute(ptr)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use mem::*;\n-    use option::{Some,None};\n-    use realstd::str::StrAllocating;\n-    use realstd::owned::Box;\n-    use realstd::vec::Vec;\n-    use raw;\n-\n-    #[test]\n-    fn size_of_basic() {\n-        assert_eq!(size_of::<u8>(), 1u);\n-        assert_eq!(size_of::<u16>(), 2u);\n-        assert_eq!(size_of::<u32>(), 4u);\n-        assert_eq!(size_of::<u64>(), 8u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    fn size_of_32() {\n-        assert_eq!(size_of::<uint>(), 4u);\n-        assert_eq!(size_of::<*uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn size_of_64() {\n-        assert_eq!(size_of::<uint>(), 8u);\n-        assert_eq!(size_of::<*uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn size_of_val_basic() {\n-        assert_eq!(size_of_val(&1u8), 1);\n-        assert_eq!(size_of_val(&1u16), 2);\n-        assert_eq!(size_of_val(&1u32), 4);\n-        assert_eq!(size_of_val(&1u64), 8);\n-    }\n-\n-    #[test]\n-    fn align_of_basic() {\n-        assert_eq!(align_of::<u8>(), 1u);\n-        assert_eq!(align_of::<u16>(), 2u);\n-        assert_eq!(align_of::<u32>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    fn align_of_32() {\n-        assert_eq!(align_of::<uint>(), 4u);\n-        assert_eq!(align_of::<*uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn align_of_64() {\n-        assert_eq!(align_of::<uint>(), 8u);\n-        assert_eq!(align_of::<*uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn align_of_val_basic() {\n-        assert_eq!(align_of_val(&1u8), 1u);\n-        assert_eq!(align_of_val(&1u16), 2u);\n-        assert_eq!(align_of_val(&1u32), 4u);\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut x = 31337i;\n-        let mut y = 42i;\n-        swap(&mut x, &mut y);\n-        assert_eq!(x, 42);\n-        assert_eq!(y, 31337);\n-    }\n-\n-    #[test]\n-    fn test_replace() {\n-        let mut x = Some(\"test\".to_string());\n-        let y = replace(&mut x, None);\n-        assert!(x.is_none());\n-        assert!(y.is_some());\n-    }\n-\n-    #[test]\n-    fn test_transmute_copy() {\n-        assert_eq!(1u, unsafe { ::mem::transmute_copy(&1) });\n-    }\n-\n-    #[test]\n-    fn test_transmute() {\n-        trait Foo {}\n-        impl Foo for int {}\n-\n-        let a = box 100i as Box<Foo>;\n-        unsafe {\n-            let x: raw::TraitObject = transmute(a);\n-            assert!(*(x.data as *int) == 100);\n-            let _x: Box<Foo> = transmute(x);\n-        }\n-\n-        unsafe {\n-            assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n-        }\n-    }\n-}\n-\n-// FIXME #13642 (these benchmarks should be in another place)\n-/// Completely miscellaneous language-construct benchmarks.\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use option::{Some,None};\n-\n-    // Static/dynamic method dispatch\n-\n-    struct Struct {\n-        field: int\n-    }\n-\n-    trait Trait {\n-        fn method(&self) -> int;\n-    }\n-\n-    impl Trait for Struct {\n-        fn method(&self) -> int {\n-            self.field\n-        }\n-    }\n-\n-    #[bench]\n-    fn trait_vtable_method_call(b: &mut Bencher) {\n-        let s = Struct { field: 10 };\n-        let t = &s as &Trait;\n-        b.iter(|| {\n-            t.method()\n-        });\n-    }\n-\n-    #[bench]\n-    fn trait_static_method_call(b: &mut Bencher) {\n-        let s = Struct { field: 10 };\n-        b.iter(|| {\n-            s.method()\n-        });\n-    }\n-\n-    // Overhead of various match forms\n-\n-    #[bench]\n-    fn match_option_some(b: &mut Bencher) {\n-        let x = Some(10);\n-        b.iter(|| {\n-            match x {\n-                Some(y) => y,\n-                None => 11\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn match_vec_pattern(b: &mut Bencher) {\n-        let x = [1,2,3,4,5,6];\n-        b.iter(|| {\n-            match x {\n-                [1,2,3,..] => 10,\n-                _ => 11\n-            }\n-        });\n-    }\n-}"}, {"sha": "ff0494725f849316f04c5bf6b60f3b394777c577", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -32,152 +32,4 @@ pub static MIN: $T = (-1 as $T) << (BITS - 1);\n #[unstable]\n pub static MAX: $T = !MIN;\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use int;\n-    use num;\n-    use num::CheckedDiv;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert!((1 as $T).abs() == 1 as $T);\n-        assert!((0 as $T).abs() == 0 as $T);\n-        assert!((-1 as $T).abs() == 1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n-        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert!((1 as $T).signum() == 1 as $T);\n-        assert!((0 as $T).signum() == 0 as $T);\n-        assert!((-0 as $T).signum() == 0 as $T);\n-        assert!((-1 as $T).signum() == -1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!((1 as $T).is_positive());\n-        assert!(!(0 as $T).is_positive());\n-        assert!(!(-0 as $T).is_positive());\n-        assert!(!(-1 as $T).is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!(1 as $T).is_negative());\n-        assert!(!(0 as $T).is_negative());\n-        assert!(!(-0 as $T).is_negative());\n-        assert!((-1 as $T).is_negative());\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n-        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n-    }\n-\n-    static A: $T = 0b0101100;\n-    static B: $T = 0b0100001;\n-    static C: $T = 0b1111001;\n-\n-    static _0: $T = 0;\n-    static _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS as $T - 3);\n-        assert!(B.count_zeros() == BITS as $T - 2);\n-        assert!(C.count_zeros() == BITS as $T - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_signed_checked_div() {\n-        assert!(10i.checked_div(&2) == Some(5));\n-        assert!(5i.checked_div(&0) == None);\n-        assert!(int::MIN.checked_div(&-1) == None);\n-    }\n-}\n-\n ))"}, {"sha": "b32e4167da1d45e90517b74a4e36b0a55af6791b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -1375,22 +1375,6 @@ macro_rules! checkeddiv_uint_impl(\n \n checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n \n-/// Helper function for testing numeric operations\n-#[cfg(test)]\n-pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n-\n-    assert_eq!(ten.add(&two),  ten + two);\n-    assert_eq!(ten.sub(&two),  ten - two);\n-    assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.div(&two),  ten / two);\n-    assert_eq!(ten.rem(&two),  ten % two);\n-}\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(PartialEq, Show)]\n pub enum FPCategory {"}, {"sha": "b0c570af04ac0f1fc664d08509458f4bc2407d26", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -23,111 +23,4 @@ pub static MIN: $T = 0 as $T;\n #[unstable]\n pub static MAX: $T = 0 as $T - 1 as $T;\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use num;\n-    use num::CheckedDiv;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n-        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n-    }\n-\n-    static A: $T = 0b0101100;\n-    static B: $T = 0b0100001;\n-    static C: $T = 0b1111001;\n-\n-    static _0: $T = 0;\n-    static _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS as $T - 3);\n-        assert!(B.count_zeros() == BITS as $T - 2);\n-        assert!(C.count_zeros() == BITS as $T - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_unsigned_checked_div() {\n-        assert!(10u.checked_div(&2) == Some(5));\n-        assert!(5u.checked_div(&0) == None);\n-    }\n-}\n-\n ))"}, {"sha": "d42c09b8163dd1d6159264109b8ae85847f84d58", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -117,7 +117,6 @@ pub trait Add<RHS,Result> {\n \n macro_rules! add_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Add<$t, $t> for $t {\n             #[inline]\n             fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n@@ -159,7 +158,6 @@ pub trait Sub<RHS,Result> {\n \n macro_rules! sub_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Sub<$t, $t> for $t {\n             #[inline]\n             fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n@@ -201,7 +199,6 @@ pub trait Mul<RHS,Result> {\n \n macro_rules! mul_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Mul<$t, $t> for $t {\n             #[inline]\n             fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n@@ -243,7 +240,6 @@ pub trait Div<RHS,Result> {\n \n macro_rules! div_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Div<$t, $t> for $t {\n             #[inline]\n             fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n@@ -285,7 +281,6 @@ pub trait Rem<RHS,Result> {\n \n macro_rules! rem_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n@@ -295,7 +290,6 @@ macro_rules! rem_impl(\n \n macro_rules! rem_float_impl(\n     ($t:ty, $fmod:ident) => {\n-        #[cfg(not(test))]\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(&self, other: &$t) -> $t {\n@@ -342,7 +336,6 @@ pub trait Neg<Result> {\n \n macro_rules! neg_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -*self }\n@@ -352,7 +345,6 @@ macro_rules! neg_impl(\n \n macro_rules! neg_uint_impl(\n     ($t:ty, $t_signed:ty) => {\n-        #[cfg(not(test))]\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n@@ -402,7 +394,6 @@ pub trait Not<Result> {\n \n macro_rules! not_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Not<$t> for $t {\n             #[inline]\n             fn not(&self) -> $t { !*self }\n@@ -444,7 +435,6 @@ pub trait BitAnd<RHS,Result> {\n \n macro_rules! bitand_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitAnd<$t, $t> for $t {\n             #[inline]\n             fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n@@ -486,7 +476,6 @@ pub trait BitOr<RHS,Result> {\n \n macro_rules! bitor_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitOr<$t,$t> for $t {\n             #[inline]\n             fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n@@ -528,7 +517,6 @@ pub trait BitXor<RHS,Result> {\n \n macro_rules! bitxor_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitXor<$t, $t> for $t {\n             #[inline]\n             fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n@@ -570,12 +558,6 @@ pub trait Shl<RHS,Result> {\n \n macro_rules! shl_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(stage0)]\n-        impl Shl<$t, $t> for $t {\n-            #[inline]\n-            fn shl(&self, other: &$t) -> $t { (*self) << (*other) }\n-        }\n-        #[cfg(not(stage0), not(test))]\n         impl Shl<$t, $t> for $t {\n             #[inline]\n             fn shl(&self, other: &$t) -> $t {\n@@ -619,12 +601,6 @@ pub trait Shr<RHS,Result> {\n \n macro_rules! shr_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(stage0, not(test))]\n-        impl Shr<$t, $t> for $t {\n-            #[inline]\n-            fn shr(&self, other: &$t) -> $t { (*self) >> (*other) }\n-        }\n-        #[cfg(not(stage0), not(test))]\n         impl Shr<$t, $t> for $t {\n             #[inline]\n             fn shr(&self, other: &$t) -> $t { (*self) >> (*other as uint) }\n@@ -758,28 +734,3 @@ pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     fn call_once(self, args: Args) -> Result;\n }\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use ops::Drop;\n-\n-    // Overhead of dtors\n-\n-    struct HasDtor {\n-        x: int\n-    }\n-\n-    impl Drop for HasDtor {\n-        fn drop(&mut self) {\n-        }\n-    }\n-\n-    #[bench]\n-    fn alloc_obj_with_dtor(b: &mut Bencher) {\n-        b.iter(|| {\n-            HasDtor { x : 10 };\n-        })\n-    }\n-}"}, {"sha": "b8612ed93e02dcd39dd1229c1e8da14a460b9f16", "filename": "src/libcore/option.rs", "status": "modified", "additions": 22, "deletions": 298, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -587,310 +587,34 @@ impl<A> ExactSize<A> for Item<A> {}\n /// ```\n #[inline]\n pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n-    // FIXME(#11084): This should be twice as fast once this bug is closed.\n-    let mut iter = iter.scan(false, |state, x| {\n-        match x {\n-            Some(x) => Some(x),\n-            None => {\n-                *state = true;\n-                None\n+    // FIXME(#11084): This could be replaced with Iterator::scan when this\n+    // performance bug is closed.\n+\n+    struct Adapter<Iter> {\n+        iter: Iter,\n+        found_none: bool,\n+    }\n+\n+    impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n+        #[inline]\n+        fn next(&mut self) -> Option<T> {\n+            match self.iter.next() {\n+                Some(Some(value)) => Some(value),\n+                Some(None) => {\n+                    self.found_none = true;\n+                    None\n+                }\n+                None => None,\n             }\n         }\n-    });\n+    }\n \n-    let v: V = FromIterator::from_iter(iter.by_ref());\n+    let mut adapter = Adapter { iter: iter, found_none: false };\n+    let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    if iter.state {\n+    if adapter.found_none {\n         None\n     } else {\n         Some(v)\n     }\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use realstd::vec::Vec;\n-    use realstd::string::String;\n-    use option::collect;\n-    use prelude::*;\n-    use realstd::str::{Str, StrAllocating};\n-    use iter::range;\n-\n-    use str::StrSlice;\n-    use kinds::marker;\n-    use slice::ImmutableVector;\n-\n-    #[test]\n-    fn test_get_ptr() {\n-        unsafe {\n-            let x = box 0;\n-            let addr_x: *int = ::mem::transmute(&*x);\n-            let opt = Some(x);\n-            let y = opt.unwrap();\n-            let addr_y: *int = ::mem::transmute(&*y);\n-            assert_eq!(addr_x, addr_y);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get_str() {\n-        let x = \"test\".to_string();\n-        let addr_x = x.as_slice().as_ptr();\n-        let opt = Some(x);\n-        let y = opt.unwrap();\n-        let addr_y = y.as_slice().as_ptr();\n-        assert_eq!(addr_x, addr_y);\n-    }\n-\n-    #[test]\n-    fn test_get_resource() {\n-        use realstd::rc::Rc;\n-        use cell::RefCell;\n-\n-        struct R {\n-           i: Rc<RefCell<int>>,\n-        }\n-\n-        #[unsafe_destructor]\n-        impl ::ops::Drop for R {\n-           fn drop(&mut self) {\n-                let ii = &*self.i;\n-                let i = *ii.borrow();\n-                *ii.borrow_mut() = i + 1;\n-            }\n-        }\n-\n-        fn r(i: Rc<RefCell<int>>) -> R {\n-            R {\n-                i: i\n-            }\n-        }\n-\n-        fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n-            use realstd::clone::Clone;\n-            t.clone()\n-        }\n-\n-        let i = Rc::new(RefCell::new(0i));\n-        {\n-            let x = r(realclone(&i));\n-            let opt = Some(x);\n-            let _y = opt.unwrap();\n-        }\n-        assert_eq!(*i.borrow(), 1);\n-    }\n-\n-    #[test]\n-    fn test_option_dance() {\n-        let x = Some(());\n-        let mut y = Some(5i);\n-        let mut y2 = 0;\n-        for _x in x.iter() {\n-            y2 = y.take_unwrap();\n-        }\n-        assert_eq!(y2, 5);\n-        assert!(y.is_none());\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_option_too_much_dance() {\n-        let mut y = Some(marker::NoCopy);\n-        let _y2 = y.take_unwrap();\n-        let _y3 = y.take_unwrap();\n-    }\n-\n-    #[test]\n-    fn test_and() {\n-        let x: Option<int> = Some(1i);\n-        assert_eq!(x.and(Some(2i)), Some(2));\n-        assert_eq!(x.and(None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and(Some(2i)), None);\n-        assert_eq!(x.and(None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_and_then() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or(Some(2)), Some(1));\n-        assert_eq!(x.or(None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or(Some(2)), Some(2));\n-        assert_eq!(x.or(None), None);\n-    }\n-\n-    #[test]\n-    fn test_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or_else(|| Some(2)), Some(1));\n-        assert_eq!(x.or_else(|| None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or_else(|| Some(2)), Some(2));\n-        assert_eq!(x.or_else(|| None), None);\n-    }\n-\n-    #[test]\n-    fn test_option_while_some() {\n-        let mut i = 0i;\n-        Some(10).while_some(|j| {\n-            i += 1;\n-            if j > 0 {\n-                Some(j-1)\n-            } else {\n-                None\n-            }\n-        });\n-        assert_eq!(i, 11);\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        assert_eq!(Some(1i).unwrap(), 1);\n-        let s = Some(\"hello\".to_string()).unwrap();\n-        assert_eq!(s.as_slice(), \"hello\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail1() {\n-        let x: Option<int> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail2() {\n-        let x: Option<String> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or(2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or(2), 2);\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or_else(|| 2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or_else(|| 2), 2);\n-    }\n-\n-    #[test]\n-    fn test_filtered() {\n-        let some_stuff = Some(42i);\n-        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-        assert_eq!(some_stuff.unwrap(), 42);\n-        assert!(modified_stuff.is_none());\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        let val = 5i;\n-\n-        let x = Some(val);\n-        let mut it = x.iter();\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next(), Some(&val));\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let val = 5i;\n-        let new_val = 11i;\n-\n-        let mut x = Some(val);\n-        {\n-            let mut it = x.mut_iter();\n-\n-            assert_eq!(it.size_hint(), (1, Some(1)));\n-\n-            match it.next() {\n-                Some(interior) => {\n-                    assert_eq!(*interior, val);\n-                    *interior = new_val;\n-                }\n-                None => assert!(false),\n-            }\n-\n-            assert_eq!(it.size_hint(), (0, Some(0)));\n-            assert!(it.next().is_none());\n-        }\n-        assert_eq!(x, Some(new_val));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let small = Some(1.0f64);\n-        let big = Some(5.0f64);\n-        let nan = Some(0.0f64/0.0);\n-        assert!(!(nan < big));\n-        assert!(!(nan > big));\n-        assert!(small < big);\n-        assert!(None < big);\n-        assert!(big > None);\n-    }\n-\n-    #[test]\n-    fn test_mutate() {\n-        let mut x = Some(3i);\n-        assert!(x.mutate(|i| i+1));\n-        assert_eq!(x, Some(4i));\n-        assert!(x.mutate_or_set(0, |i| i+1));\n-        assert_eq!(x, Some(5i));\n-        x = None;\n-        assert!(!x.mutate(|i| i+1));\n-        assert_eq!(x, None);\n-        assert!(!x.mutate_or_set(0i, |i| i+1));\n-        assert_eq!(x, Some(0i));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Option<Vec<int>> = collect(range(0i, 0)\n-                                          .map(|_| Some(0i)));\n-        assert!(v == Some(vec![]));\n-\n-        let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                          .map(|x| Some(x)));\n-        assert!(v == Some(vec![0, 1, 2]));\n-\n-        let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                          .map(|x| if x > 1 { None } else { Some(x) }));\n-        assert!(v == None);\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Some(()), || None, || fail!()];\n-\n-        let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n-\n-        assert!(v == None);\n-    }\n-}"}, {"sha": "093591cd796d1cf4026605f338da2be55a87af46", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 75, "deletions": 300, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Operations on unsafe pointers, `*T`, and `*mut T`.\n+//! Operations on unsafe pointers, `*const T`, and `*mut T`.\n //!\n //! Working with unsafe pointers in Rust is uncommon,\n //! typically limited to a few patterns.\n@@ -29,7 +29,7 @@\n //!\n //! ```\n //! let my_num: int = 10;\n-//! let my_num_ptr: *int = &my_num;\n+//! let my_num_ptr: *const int = &my_num;\n //! let mut my_speed: int = 88;\n //! let my_speed_ptr: *mut int = &mut my_speed;\n //! ```\n@@ -42,7 +42,7 @@\n //!\n //! The `transmute` function takes, by value, whatever it's given\n //! and returns it as whatever type is requested, as long as the\n-//! types are the same size. Because `Box<T>` and `*T` have the same\n+//! types are the same size. Because `Box<T>` and `*mut T` have the same\n //! representation they can be trivially,\n //! though unsafely, transformed from one type to the other.\n //!\n@@ -51,7 +51,7 @@\n //!\n //! unsafe {\n //!     let my_num: Box<int> = box 10;\n-//!     let my_num: *int = mem::transmute(my_num);\n+//!     let my_num: *const int = mem::transmute(my_num);\n //!     let my_speed: Box<int> = box 88;\n //!     let my_speed: *mut int = mem::transmute(my_speed);\n //!\n@@ -93,7 +93,7 @@ use intrinsics;\n use iter::{range, Iterator};\n use option::{Some, None, Option};\n \n-#[cfg(not(test))] use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n+use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n \n /// Create a null pointer.\n ///\n@@ -102,12 +102,12 @@ use option::{Some, None, Option};\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *int = ptr::null();\n+/// let p: *const int = ptr::null();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n-pub fn null<T>() -> *T { 0 as *T }\n+pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Create an unsafe mutable null pointer.\n ///\n@@ -137,7 +137,7 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n /// ```\n /// use std::ptr;\n ///\n-/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> Vec<T> {\n+/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n ///     let mut dst = Vec::with_capacity(elts);\n ///     dst.set_len(elts);\n ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n@@ -147,7 +147,7 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n ///\n #[inline]\n #[unstable]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     intrinsics::copy_memory(dst, src, count)\n }\n \n@@ -190,7 +190,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n #[inline]\n #[unstable]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n-                                            src: *T,\n+                                            src: *const T,\n                                             count: uint) {\n     intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n@@ -242,7 +242,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// Reads the value from `*src` and returns it.\n #[inline(always)]\n #[unstable]\n-pub unsafe fn read<T>(src: *T) -> T {\n+pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n@@ -275,11 +275,12 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n-/// Given a **T (pointer to an array of pointers),\n-/// iterate through each *T, up to the provided `len`,\n+/// Given a *const *const T (pointer to an array of pointers),\n+/// iterate through each *const T, up to the provided `len`,\n /// passing to the provided callback function\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n+pub unsafe fn array_each_with_len<T>(arr: *const *const T, len: uint,\n+                                     cb: |*const T|) {\n     if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n@@ -290,8 +291,8 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n }\n \n-/// Given a null-pointer-terminated **T (pointer to\n-/// an array of pointers), iterate through each *T,\n+/// Given a null-pointer-terminated *const *const T (pointer to\n+/// an array of pointers), iterate through each *const T,\n /// passing to the provided callback function\n ///\n /// # Safety Note\n@@ -300,7 +301,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n /// pointer array.\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n #[allow(deprecated)]\n-pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n+pub unsafe fn array_each<T>(arr: *const  *const T, cb: |*const T|) {\n     if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n@@ -312,14 +313,14 @@ pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n #[inline]\n #[deprecated = \"use a loop and RawPtr::offset\"]\n #[allow(deprecated)]\n-pub unsafe fn buf_len<T>(buf: **T) -> uint {\n+pub unsafe fn buf_len<T>(buf: *const *const T) -> uint {\n     position(buf, |i| *i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline]\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*buf.offset(i as int))) { return i; }\n@@ -352,9 +353,9 @@ pub trait RawPtr<T> {\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n-impl<T> RawPtr<T> for *T {\n+impl<T> RawPtr<T> for *const T {\n     #[inline]\n-    fn null() -> *T { null() }\n+    fn null() -> *const T { null() }\n \n     #[inline]\n     fn is_null(&self) -> bool { *self == RawPtr::null() }\n@@ -363,7 +364,9 @@ impl<T> RawPtr<T> for *T {\n     fn to_uint(&self) -> uint { *self as uint }\n \n     #[inline]\n-    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *const T {\n+        intrinsics::offset(self, count)\n+    }\n \n     #[inline]\n     unsafe fn to_option(&self) -> Option<&T> {\n@@ -387,7 +390,7 @@ impl<T> RawPtr<T> for *mut T {\n \n     #[inline]\n     unsafe fn offset(self, count: int) -> *mut T {\n-        intrinsics::offset(self as *T, count) as *mut T\n+        intrinsics::offset(self as *const T, count) as *mut T\n     }\n \n     #[inline]\n@@ -401,20 +404,17 @@ impl<T> RawPtr<T> for *mut T {\n }\n \n // Equality for pointers\n-#[cfg(not(test))]\n-impl<T> PartialEq for *T {\n+impl<T> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*T) -> bool {\n+    fn eq(&self, other: &*const T) -> bool {\n         *self == *other\n     }\n     #[inline]\n-    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(not(test))]\n-impl<T> Eq for *T {}\n+impl<T> Eq for *const T {}\n \n-#[cfg(not(test))]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -424,27 +424,24 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(not(test))]\n impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n-#[cfg(not(test))]\n-impl<T> Equiv<*mut T> for *T {\n+impl<T> Equiv<*mut T> for *const T {\n     fn equiv(&self, other: &*mut T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n-#[cfg(not(test))]\n-impl<T> Equiv<*T> for *mut T {\n-    fn equiv(&self, other: &*T) -> bool {\n+impl<T> Equiv<*const T> for *mut T {\n+    fn equiv(&self, other: &*const T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n-impl<T> Clone for *T {\n+impl<T> Clone for *const T {\n     #[inline]\n-    fn clone(&self) -> *T {\n+    fn clone(&self) -> *const T {\n         *self\n     }\n }\n@@ -457,16 +454,15 @@ impl<T> Clone for *mut T {\n }\n \n // Equality for extern \"C\" fn pointers\n-#[cfg(not(test))]\n mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n-            let self_: *() = unsafe { mem::transmute(*self) };\n-            let other_: *() = unsafe { mem::transmute(*other) };\n+            let self_: *const () = unsafe { mem::transmute(*self) };\n+            let other_: *const () = unsafe { mem::transmute(*other) };\n             self_ == other_\n         }\n     }\n@@ -475,8 +471,9 @@ mod externfnpointers {\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n-                    let self_: *() = unsafe { mem::transmute(*self) };\n-                    let other_: *() = unsafe { mem::transmute(*other) };\n+                    let self_: *const () = unsafe { mem::transmute(*self) };\n+\n+                    let other_: *const () = unsafe { mem::transmute(*other) };\n                     self_ == other_\n                 }\n             }\n@@ -490,274 +487,52 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[cfg(not(test))]\n-impl<T> PartialOrd for *T {\n-    #[inline]\n-    fn lt(&self, other: &*T) -> bool { *self < *other }\n-}\n-\n-#[cfg(not(test))]\n-impl<T> PartialOrd for *mut T {\n+impl<T> PartialOrd for *const T {\n     #[inline]\n-    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n-}\n-\n-#[cfg(test)]\n-#[allow(deprecated, experimental)]\n-pub mod test {\n-    use super::*;\n-    use prelude::*;\n-\n-    use realstd::c_str::ToCStr;\n-    use mem;\n-    use libc;\n-    use realstd::str;\n-    use realstd::str::Str;\n-    use realstd::vec::Vec;\n-    use realstd::collections::Collection;\n-    use slice::{ImmutableVector, MutableVector};\n-\n-    #[test]\n-    fn test() {\n-        unsafe {\n-            struct Pair {\n-                fst: int,\n-                snd: int\n-            };\n-            let mut p = Pair {fst: 10, snd: 20};\n-            let pptr: *mut Pair = &mut p;\n-            let iptr: *mut int = mem::transmute(pptr);\n-            assert_eq!(*iptr, 10);\n-            *iptr = 30;\n-            assert_eq!(*iptr, 30);\n-            assert_eq!(p.fst, 30);\n-\n-            *pptr = Pair {fst: 50, snd: 60};\n-            assert_eq!(*iptr, 50);\n-            assert_eq!(p.fst, 50);\n-            assert_eq!(p.snd, 60);\n-\n-            let v0 = vec![32000u16, 32001u16, 32002u16];\n-            let mut v1 = vec![0u16, 0u16, 0u16];\n-\n-            copy_memory(v1.as_mut_ptr().offset(1),\n-                        v0.as_ptr().offset(1), 1);\n-            assert!((*v1.get(0) == 0u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 0u16));\n-            copy_memory(v1.as_mut_ptr(),\n-                        v0.as_ptr().offset(2), 1);\n-            assert!((*v1.get(0) == 32002u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 0u16));\n-            copy_memory(v1.as_mut_ptr().offset(2),\n-                        v0.as_ptr(), 1u);\n-            assert!((*v1.get(0) == 32002u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 32000u16));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_position() {\n-        use libc::c_char;\n-\n-        \"hello\".with_c_str(|p| {\n-            unsafe {\n-                assert!(2u == position(p, |c| *c == 'l' as c_char));\n-                assert!(4u == position(p, |c| *c == 'o' as c_char));\n-                assert!(5u == position(p, |c| *c == 0 as c_char));\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_buf_len() {\n-        \"hello\".with_c_str(|p0| {\n-            \"there\".with_c_str(|p1| {\n-                \"thing\".with_c_str(|p2| {\n-                    let v = vec![p0, p1, p2, null()];\n-                    unsafe {\n-                        assert_eq!(buf_len(v.as_ptr()), 3u);\n-                    }\n-                })\n-            })\n-        })\n-    }\n-\n-    #[test]\n-    fn test_is_null() {\n-        let p: *int = null();\n-        assert!(p.is_null());\n-        assert!(!p.is_not_null());\n-\n-        let q = unsafe { p.offset(1) };\n-        assert!(!q.is_null());\n-        assert!(q.is_not_null());\n-\n-        let mp: *mut int = mut_null();\n-        assert!(mp.is_null());\n-        assert!(!mp.is_not_null());\n-\n-        let mq = unsafe { mp.offset(1) };\n-        assert!(!mq.is_null());\n-        assert!(mq.is_not_null());\n-    }\n-\n-    #[test]\n-    fn test_to_option() {\n-        unsafe {\n-            let p: *int = null();\n-            assert_eq!(p.to_option(), None);\n-\n-            let q: *int = &2;\n-            assert_eq!(q.to_option().unwrap(), &2);\n-\n-            let p: *mut int = mut_null();\n-            assert_eq!(p.to_option(), None);\n-\n-            let q: *mut int = &mut 2;\n-            assert_eq!(q.to_option().unwrap(), &2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_ptr_addition() {\n-        unsafe {\n-            let xs = Vec::from_elem(16, 5i);\n-            let mut ptr = xs.as_ptr();\n-            let end = ptr.offset(16);\n-\n-            while ptr < end {\n-                assert_eq!(*ptr, 5);\n-                ptr = ptr.offset(1);\n-            }\n-\n-            let mut xs_mut = xs;\n-            let mut m_ptr = xs_mut.as_mut_ptr();\n-            let m_end = m_ptr.offset(16);\n-\n-            while m_ptr < m_end {\n-                *m_ptr += 5;\n-                m_ptr = m_ptr.offset(1);\n-            }\n-\n-            assert!(xs_mut == Vec::from_elem(16, 10i));\n+    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n+        if self < other {\n+            Some(Less)\n+        } else if self == other {\n+            Some(Equal)\n+        } else {\n+            Some(Greater)\n         }\n     }\n \n-    #[test]\n-    fn test_ptr_subtraction() {\n-        unsafe {\n-            let xs = vec![0,1,2,3,4,5,6,7,8,9];\n-            let mut idx = 9i8;\n-            let ptr = xs.as_ptr();\n+    #[inline]\n+    fn lt(&self, other: &*const T) -> bool { *self < *other }\n \n-            while idx >= 0i8 {\n-                assert_eq!(*(ptr.offset(idx as int)), idx as int);\n-                idx = idx - 1i8;\n-            }\n+    #[inline]\n+    fn le(&self, other: &*const T) -> bool { *self <= *other }\n \n-            let mut xs_mut = xs;\n-            let m_start = xs_mut.as_mut_ptr();\n-            let mut m_ptr = m_start.offset(9);\n+    #[inline]\n+    fn gt(&self, other: &*const T) -> bool { *self > *other }\n \n-            while m_ptr >= m_start {\n-                *m_ptr += *m_ptr;\n-                m_ptr = m_ptr.offset(-1);\n-            }\n+    #[inline]\n+    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n+}\n \n-            assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n+impl<T> PartialOrd for *mut T {\n+    #[inline]\n+    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n+        if self < other {\n+            Some(Less)\n+        } else if self == other {\n+            Some(Equal)\n+        } else {\n+            Some(Greater)\n         }\n     }\n \n-    #[test]\n-    fn test_ptr_array_each_with_len() {\n-        unsafe {\n-            let one = \"oneOne\".to_c_str();\n-            let two = \"twoTwo\".to_c_str();\n-            let three = \"threeThree\".to_c_str();\n-            let arr = vec![\n-                one.with_ref(|buf| buf),\n-                two.with_ref(|buf| buf),\n-                three.with_ref(|buf| buf)\n-            ];\n-            let expected_arr = [\n-                one, two, three\n-            ];\n-\n-            let mut ctr = 0;\n-            let mut iteration_count = 0;\n-            array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n-                    let actual = str::raw::from_c_str(e);\n-                    let expected = expected_arr[ctr].with_ref(|buf| {\n-                            str::raw::from_c_str(buf)\n-                        });\n-                    assert_eq!(actual.as_slice(), expected.as_slice());\n-                    ctr += 1;\n-                    iteration_count += 1;\n-                });\n-            assert_eq!(iteration_count, 3u);\n-        }\n-    }\n+    #[inline]\n+    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n \n-    #[test]\n-    fn test_ptr_array_each() {\n-        unsafe {\n-            let one = \"oneOne\".to_c_str();\n-            let two = \"twoTwo\".to_c_str();\n-            let three = \"threeThree\".to_c_str();\n-            let arr = vec![\n-                one.with_ref(|buf| buf),\n-                two.with_ref(|buf| buf),\n-                three.with_ref(|buf| buf),\n-                // fake a null terminator\n-                null()\n-            ];\n-            let expected_arr = [\n-                one, two, three\n-            ];\n-\n-            let arr_ptr = arr.as_ptr();\n-            let mut ctr = 0u;\n-            let mut iteration_count = 0u;\n-            array_each(arr_ptr, |e| {\n-                    let actual = str::raw::from_c_str(e);\n-                    let expected = expected_arr[ctr].with_ref(|buf| {\n-                        str::raw::from_c_str(buf)\n-                    });\n-                    assert_eq!(actual.as_slice(), expected.as_slice());\n-                    ctr += 1;\n-                    iteration_count += 1;\n-                });\n-            assert_eq!(iteration_count, 3);\n-        }\n-    }\n+    #[inline]\n+    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_ptr_array_each_with_len_null_ptr() {\n-        unsafe {\n-            array_each_with_len(0 as **libc::c_char, 1, |e| {\n-                str::raw::from_c_str(e);\n-            });\n-        }\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_ptr_array_each_null_ptr() {\n-        unsafe {\n-            array_each(0 as **libc::c_char, |e| {\n-                str::raw::from_c_str(e);\n-            });\n-        }\n-    }\n+    #[inline]\n+    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n \n-    #[test]\n-    fn test_set_memory() {\n-        let mut xs = [0u8, ..20];\n-        let ptr = xs.as_mut_ptr();\n-        unsafe { set_memory(ptr, 5u8, xs.len()); }\n-        assert!(xs == [5u8, ..20]);\n-    }\n+    #[inline]\n+    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }"}, {"sha": "da9fab0fc6f50ef8894618d0076214a703df268f", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -31,29 +31,29 @@ pub struct Box<T> {\n \n /// The representation of a Rust slice\n pub struct Slice<T> {\n-    pub data: *T,\n+    pub data: *const T,\n     pub len: uint,\n }\n \n /// The representation of a Rust closure\n pub struct Closure {\n-    pub code: *(),\n-    pub env: *(),\n+    pub code: *mut (),\n+    pub env: *mut (),\n }\n \n /// The representation of a Rust procedure (`proc()`)\n pub struct Procedure {\n-    pub code: *(),\n-    pub env: *(),\n+    pub code: *mut (),\n+    pub env: *mut (),\n }\n \n /// The representation of a Rust trait object.\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n pub struct TraitObject {\n-    pub vtable: *(),\n-    pub data: *(),\n+    pub vtable: *mut (),\n+    pub data: *mut (),\n }\n \n /// This trait is meant to map equivalences between raw structs and their\n@@ -70,32 +70,3 @@ pub trait Repr<T> {\n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n \n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use mem;\n-\n-    #[test]\n-    fn synthesize_closure() {\n-        unsafe {\n-            let x = 10;\n-            let f: |int| -> int = |y| x + y;\n-\n-            assert_eq!(f(20), 30);\n-\n-            let original_closure: Closure = mem::transmute(f);\n-\n-            let actual_function_pointer = original_closure.code;\n-            let environment = original_closure.env;\n-\n-            let new_closure = Closure {\n-                code: actual_function_pointer,\n-                env: environment\n-            };\n-\n-            let new_f: |int| -> int = mem::transmute(new_closure);\n-            assert_eq!(new_f(20), 30);\n-        }\n-    }\n-}"}, {"sha": "5cbbf30cd360721c912bdb4e63fd07031c6e93c9", "filename": "src/libcore/result.rs", "status": "modified", "additions": 22, "deletions": 173, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -585,20 +585,32 @@ impl<T: Show, E> Result<T, E> {\n /// ```\n #[inline]\n pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n-    // FIXME(#11084): This should be twice as fast once this bug is closed.\n-    let mut iter = iter.scan(None, |state, x| {\n-        match x {\n-            Ok(x) => Some(x),\n-            Err(err) => {\n-                *state = Some(err);\n-                None\n+    // FIXME(#11084): This could be replaced with Iterator::scan when this\n+    // performance bug is closed.\n+\n+    struct Adapter<Iter, E> {\n+        iter: Iter,\n+        err: Option<E>,\n+    }\n+\n+    impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n+        #[inline]\n+        fn next(&mut self) -> Option<T> {\n+            match self.iter.next() {\n+                Some(Ok(value)) => Some(value),\n+                Some(Err(err)) => {\n+                    self.err = Some(err);\n+                    None\n+                }\n+                None => None,\n             }\n         }\n-    });\n+    }\n \n-    let v: V = FromIterator::from_iter(iter.by_ref());\n+    let mut adapter = Adapter { iter: iter, err: None };\n+    let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    match iter.state {\n+    match adapter.err {\n         Some(err) => Err(err),\n         None => Ok(v),\n     }\n@@ -635,166 +647,3 @@ pub fn fold<T,\n pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use realstd::vec::Vec;\n-\n-    use result::{collect, fold, fold_};\n-    use prelude::*;\n-    use realstd::str::Str;\n-    use iter::range;\n-\n-    pub fn op1() -> Result<int, &'static str> { Ok(666) }\n-    pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n-\n-    #[test]\n-    pub fn test_and() {\n-        assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n-        assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n-                   \"bad\");\n-\n-        assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n-        assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_and_then() {\n-        assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n-        assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n-                   \"bad\");\n-\n-        assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n-                   \"sadface\");\n-        assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_or() {\n-        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n-        assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n-\n-        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n-        assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n-    }\n-\n-    #[test]\n-    pub fn test_or_else() {\n-        assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n-        assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n-\n-        assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n-        assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map() {\n-        assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n-        assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map_err() {\n-        assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n-        assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n-        assert!(v == Ok(vec![]));\n-\n-        let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n-        assert!(v == Ok(vec![0, 1, 2]));\n-\n-        let v: Result<Vec<int>, int> = collect(range(0i, 3)\n-                                               .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n-        assert!(v == Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-        let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n-        assert!(v == Err(1));\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold_(range(0i, 0)\n-                        .map(|_| Ok::<(), ()>(()))),\n-                   Ok(()));\n-        assert_eq!(fold(range(0i, 3)\n-                        .map(|x| Ok::<int, ()>(x)),\n-                        0, |a, b| a + b),\n-                   Ok(3));\n-        assert_eq!(fold_(range(0i, 3)\n-                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n-                   Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-        assert_eq!(fold_(functions.mut_iter()\n-                        .map(|f| (*f)())),\n-                   Err(1));\n-    }\n-\n-    #[test]\n-    pub fn test_fmt_default() {\n-        let ok: Result<int, &'static str> = Ok(100);\n-        let err: Result<int, &'static str> = Err(\"Err\");\n-\n-        let s = format!(\"{}\", ok);\n-        assert_eq!(s.as_slice(), \"Ok(100)\");\n-        let s = format!(\"{}\", err);\n-        assert_eq!(s.as_slice(), \"Err(Err)\");\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or() {\n-        let ok: Result<int, &'static str> = Ok(100i);\n-        let ok_err: Result<int, &'static str> = Err(\"Err\");\n-\n-        assert_eq!(ok.unwrap_or(50), 100);\n-        assert_eq!(ok_err.unwrap_or(50), 50);\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or_else() {\n-        fn handler(msg: &'static str) -> int {\n-            if msg == \"I got this.\" {\n-                50i\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let ok: Result<int, &'static str> = Ok(100);\n-        let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n-\n-        assert_eq!(ok.unwrap_or_else(handler), 100);\n-        assert_eq!(ok_err.unwrap_or_else(handler), 50);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn test_unwrap_or_else_failure() {\n-        fn handler(msg: &'static str) -> int {\n-            if msg == \"I got this.\" {\n-                50i\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n-        let _ : int = bad_err.unwrap_or_else(handler);\n-    }\n-}"}, {"sha": "0178c0318b81c2afde7be72eec396e4cfc55a425", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1010, "deletions": 962, "changes": 1972, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -14,10 +14,29 @@\n \n #![doc(primitive = \"slice\")]\n \n+// How this module is organized.\n+//\n+// The library infrastructure for slices is fairly messy. There's\n+// a lot of stuff defined here. Let's keep it clean.\n+//\n+// Since slices don't support inherent methods; all operations\n+// on them are defined on traits, which are then reexported from\n+// the prelude for convenience. So there are a lot of traits here.\n+//\n+// The layout of this file is thus:\n+//\n+// * Slice-specific 'extension' traits and their implementations. This\n+//   is where most of the slice API resides.\n+// * Implementations of a few common traits with important slice ops.\n+// * Definitions of a bunch of iterators.\n+// * Free functions.\n+// * The `raw` and `bytes` submodules.\n+// * Boilerplate trait implementations.\n+\n use mem::transmute;\n use clone::Clone;\n use collections::Collection;\n-use cmp::{PartialEq, Ord, Ordering, Less, Equal, Greater};\n+use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Less, Equal, Greater, Equiv};\n use cmp;\n use default::Default;\n use iter::*;\n@@ -30,624 +49,693 @@ use mem::size_of;\n use kinds::marker;\n use raw::{Repr, Slice};\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n-    unsafe {\n-        transmute(Slice { data: s, len: 1 })\n-    }\n-}\n+//\n+// Extension traits\n+//\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n-    unsafe {\n-        let ptr: *A = transmute(s);\n-        transmute(Slice { data: ptr, len: 1 })\n-    }\n-}\n+/// Extension methods for vectors\n+pub trait ImmutableVector<'a, T> {\n+    /**\n+     * Returns a slice of self spanning the interval [`start`, `end`).\n+     *\n+     * Fails when the slice (or part of it) is outside the bounds of self,\n+     * or when `start` > `end`.\n+     */\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function.\n-pub struct Splits<'a, T> {\n-    v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn slice_from(&self, start: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn slice_to(&self, end: uint) -> &'a [T];\n+    /// Returns an iterator over the vector\n+    fn iter(self) -> Items<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.  The matched element\n+    /// is not contained in the subslices.\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.  The matched element is not contained in\n+    /// the subslices.\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.  The matched element is not contained in the\n+    /// subslices.\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ```rust\n+     * let v = &[1i, 2, 3, 4];\n+     * for win in v.windows(2) {\n+     *     println!(\"{}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn windows(self, size: uint) -> Windows<'a, T>;\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ```rust\n+     * let v = &[1i, 2, 3, 4, 5];\n+     * for win in v.chunks(2) {\n+     *     println!(\"{}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn chunks(self, size: uint) -> Chunks<'a, T>;\n+\n+    /// Returns the element of a vector at the given index, or `None` if the\n+    /// index is out of bounds\n+    fn get(&self, index: uint) -> Option<&'a T>;\n+    /// Returns the first element of a vector, or `None` if it is empty\n+    fn head(&self) -> Option<&'a T>;\n+    /// Returns all but the first element of a vector\n+    fn tail(&self) -> &'a [T];\n+    /// Returns all but the first `n' elements of a vector\n+    fn tailn(&self, n: uint) -> &'a [T];\n+    /// Returns all but the last element of a vector\n+    fn init(&self) -> &'a [T];\n+    /// Returns all but the last `n' elements of a vector\n+    fn initn(&self, n: uint) -> &'a [T];\n+    /// Returns the last element of a vector, or `None` if it is empty.\n+    fn last(&self) -> Option<&'a T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+\n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *const T;\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator function should implement an order consistent\n+     * with the sort order of the underlying vector, returning an\n+     * order code that indicates whether its argument is `Less`,\n+     * `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+\n+    /**\n+     * Returns an immutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None }\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if vector is empty\n+     */\n+    fn shift_ref(&mut self) -> Option<&'a T>;\n+\n+    /**\n+     * Returns an immutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n-                ret\n-            }\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(self.v.len() + 1))\n-        }\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n     }\n-}\n \n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n \n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n-                ret\n+    #[inline]\n+    fn iter(self) -> Items<'a, T> {\n+        unsafe {\n+            let p = self.as_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                Items{ptr: p,\n+                      end: (p as uint + self.len()) as *const T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            } else {\n+                Items{ptr: p,\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n-}\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, splitting at most a fixed number of times.\n-pub struct SplitsN<'a, T> {\n-    iter: Splits<'a, T>,\n-    count: uint,\n-    invert: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.count == 0 {\n-            if self.iter.finished {\n-                None\n-            } else {\n-                self.iter.finished = true;\n-                Some(self.iter.v)\n-            }\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+        Splits {\n+            v: self,\n+            pred: pred,\n+            finished: false\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.iter.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n         }\n     }\n-}\n-\n-// Functional utilities\n-\n-/// An iterator over the (overlapping) slices of length `size` within\n-/// a vector.\n-#[deriving(Clone)]\n-pub struct Windows<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n \n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n-            None\n-        } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n-            ret\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.size > self.v.len() {\n-            (0, Some(0))\n-        } else {\n-            let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n-        }\n+    fn windows(self, size: uint) -> Windows<'a, T> {\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n     }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) chunks (`size`\n-/// elements at a time).\n-///\n-/// When the vector len is not evenly divided by the chunk size,\n-/// the last slice of the iteration will be the remainder.\n-#[deriving(Clone)]\n-pub struct Chunks<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n \n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let chunksz = cmp::min(self.v.len(), self.size);\n-            let (fst, snd) = (self.v.slice_to(chunksz),\n-                              self.v.slice_from(chunksz));\n-            self.v = snd;\n-            Some(fst)\n-        }\n+    fn chunks(self, size: uint) -> Chunks<'a, T> {\n+        assert!(size != 0);\n+        Chunks { v: self, size: size }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.size);\n-            let n = if rem > 0 { n+1 } else { n };\n-            (n, Some(n))\n-        }\n+    fn get(&self, index: uint) -> Option<&'a T> {\n+        if index < self.len() { Some(&self[index]) } else { None }\n     }\n-}\n \n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.size;\n-            let chunksz = if remainder != 0 { remainder } else { self.size };\n-            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n-                              self.v.slice_from(self.v.len() - chunksz));\n-            self.v = fst;\n-            Some(snd)\n-        }\n+    fn head(&self) -> Option<&'a T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n-}\n \n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n-        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n-    }\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n-        if index < self.indexable() {\n-            let lo = index * self.size;\n-            let mut hi = lo + self.size;\n-            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n-            Some(self.v.slice(lo, hi))\n-        } else {\n-            None\n-        }\n+    #[inline]\n+    fn init(&self) -> &'a [T] {\n+        self.slice(0, self.len() - 1)\n     }\n-}\n \n-// Equality\n+    #[inline]\n+    fn initn(&self, n: uint) -> &'a [T] {\n+        self.slice(0, self.len() - n)\n+    }\n \n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use super::*;\n+    #[inline]\n+    fn last(&self) -> Option<&'a T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n \n-    use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n-    use iter::order;\n-    use collections::Collection;\n+    #[inline]\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n+        transmute(self.repr().data.offset(index as int))\n+    }\n \n-    impl<'a,T:PartialEq> PartialEq for &'a [T] {\n-        fn eq(&self, other: & &'a [T]) -> bool {\n-            self.len() == other.len() &&\n-                order::eq(self.iter(), other.iter())\n-        }\n-        fn ne(&self, other: & &'a [T]) -> bool {\n-            self.len() != other.len() ||\n-                order::ne(self.iter(), other.iter())\n-        }\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        self.repr().data\n     }\n \n-    impl<'a,T:Eq> Eq for &'a [T] {}\n \n-    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n \n-    impl<'a,T:Ord> Ord for &'a [T] {\n-        fn cmp(&self, other: & &'a [T]) -> Ordering {\n-            order::cmp(self.iter(), other.iter())\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n         }\n+        return None;\n     }\n \n-    impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n-        fn lt(&self, other: & &'a [T]) -> bool {\n-            order::lt(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn le(&self, other: & &'a [T]) -> bool {\n-            order::le(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn ge(&self, other: & &'a [T]) -> bool {\n-            order::ge(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn gt(&self, other: & &'a [T]) -> bool {\n-            order::gt(self.iter(), other.iter())\n+    fn shift_ref(&mut self) -> Option<&'a T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::shift_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n         }\n     }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-/// Any vector that can be represented as a slice.\n-pub trait Vector<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n-\n-impl<'a,T> Vector<T> for &'a [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n-}\n \n-impl<'a, T> Collection for &'a [T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::pop_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n+        }\n     }\n }\n \n-/// Extension methods for vectors\n-pub trait ImmutableVector<'a, T> {\n-    /**\n-     * Returns a slice of self spanning the interval [`start`, `end`).\n-     *\n-     * Fails when the slice (or part of it) is outside the bounds of self,\n-     * or when `start` > `end`.\n-     */\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+/// Extension methods for vectors such that their elements are\n+/// mutable.\n+pub trait MutableVector<'a, T> {\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    fn get_mut(self, index: uint) -> Option<&'a mut T>;\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(self) -> &'a mut [T];\n+\n+    /// Return a slice that points into another slice.\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n-    fn slice_from(&self, start: uint) -> &'a [T];\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n-    fn slice_to(&self, end: uint) -> &'a [T];\n-    /// Returns an iterator over the vector\n-    fn iter(self) -> Items<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`.  The matched element\n-    /// is not contained in the subslices.\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`, limited to splitting\n-    /// at most `n` times.  The matched element is not contained in\n-    /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred` limited to splitting\n-    /// at most `n` times. This starts at the end of the vector and\n-    /// works backwards.  The matched element is not contained in the\n-    /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    fn mut_iter(self) -> MutItems<'a, T>;\n+\n+    /// Returns a mutable pointer to the last item in the vector.\n+    fn mut_last(self) -> Option<&'a mut T>;\n+\n+    /// Returns an iterator over the mutable subslices of the vector\n+    /// which are separated by elements that match `pred`.  The\n+    /// matched element is not contained in the subslices.\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n     /**\n-     * Returns an iterator over all contiguous windows of length\n-     * `size`. The windows overlap. If the vector is shorter than\n-     * `size`, the iterator returns no values.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n-     * `[3,4]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4];\n-     * for win in v.windows(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn windows(self, size: uint) -> Windows<'a, T>;\n-    /**\n-     *\n-     * Returns an iterator over `size` elements of the vector at a\n-     * time. The chunks do not overlap. If `size` does not divide the\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n      * length of the vector, then the last chunk will not have length\n      * `size`.\n      *\n      * # Failure\n      *\n      * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the vector two elements at a time (i.e. `[1,2]`,\n-     * `[3,4]`, `[5]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4, 5];\n-     * for win in v.chunks(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn chunks(self, size: uint) -> Chunks<'a, T>;\n-\n-    /// Returns the element of a vector at the given index, or `None` if the\n-    /// index is out of bounds\n-    fn get(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, or `None` if it is empty\n-    fn head(&self) -> Option<&'a T>;\n-    /// Returns all but the first element of a vector\n-    fn tail(&self) -> &'a [T];\n-    /// Returns all but the first `n' elements of a vector\n-    fn tailn(&self, n: uint) -> &'a [T];\n-    /// Returns all but the last element of a vector\n-    fn init(&self) -> &'a [T];\n-    /// Returns all but the last `n' elements of a vector\n-    fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last(&self) -> Option<&'a T>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n-\n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n      */\n-    fn as_ptr(&self) -> *T;\n-\n-    /**\n-     * Binary search a sorted vector with a comparator function.\n-     *\n-     * The comparator function should implement an order consistent\n-     * with the sort order of the underlying vector, returning an\n-     * order code that indicates whether its argument is `Less`,\n-     * `Equal` or `Greater` the desired target.\n-     *\n-     * Returns the index where the comparator returned `Equal`, or `None` if\n-     * not found.\n-     */\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /**\n-     * Returns an immutable reference to the first element in this slice\n+     * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n      * Equivalent to:\n      *\n      * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n+     *     if self.len() == 0 { return None; }\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n      *     Some(head)\n      * ```\n      *\n-     * Returns `None` if vector is empty\n+     * Returns `None` if slice is empty\n      */\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n-     * Returns an immutable reference to the last element in this slice\n+     * Returns a mutable reference to the last element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n      * Equivalent to:\n      *\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n      * Returns `None` if slice is empty.\n      */\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n+\n+    /// Swaps two elements in a vector.\n+    ///\n+    /// Fails if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    fn swap(self, a: uint, b: uint);\n+\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Fails if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.mut_split_at(0);\n+    ///    assert!(left == &mut []);\n+    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(2);\n+    ///     assert!(left == &mut [1i, 2]);\n+    ///     assert!(right == &mut [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(6);\n+    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == &mut []);\n+    /// }\n+    /// ```\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+\n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    fn reverse(self);\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n+\n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T;\n+\n+    /// Unsafely sets the element in index to the value.\n+    ///\n+    /// This performs no bounds checks, and it is undefined behaviour\n+    /// if `index` is larger than the length of `self`. However, it\n+    /// does run the destructor at `index`. It is equivalent to\n+    /// `self[index] = val`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n+    ///\n+    /// unsafe {\n+    ///     // `\"baz\".to_string()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_string());\n+    ///\n+    ///     // Out of bounds: could cause a crash, or overwriting\n+    ///     // other data, or something else.\n+    ///     // v.unsafe_set(10, \"oops\".to_string());\n+    /// }\n+    /// ```\n+    unsafe fn unsafe_set(self, index: uint, val: T);\n+\n+    /// Unchecked vector index assignment.  Does not drop the\n+    /// old value and hence is only suitable when the vector\n+    /// is newly allocated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n+    ///\n+    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n+    /// ```\n+    unsafe fn init_elem(self, i: uint, val: T);\n+\n+    /// Copies raw bytes from `src` to `self`.\n+    ///\n+    /// This does not run destructors on the overwritten elements, and\n+    /// ignores move semantics. `self` and `src` must not\n+    /// overlap. Fails if `self` is shorter than `src`.\n+    unsafe fn copy_memory(self, src: &[T]);\n }\n \n-impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+    fn get_mut(self, index: uint) -> Option<&'a mut T> {\n+        if index < self.len() { Some(&mut self[index]) } else { None }\n+    }\n+\n+    #[inline]\n+    fn as_mut_slice(self) -> &'a mut [T] { self }\n+\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n             transmute(Slice {\n-                    data: self.as_ptr().offset(start as int),\n+                    data: self.as_mut_ptr().offset(start as int) as *const T,\n                     len: (end - start)\n                 })\n         }\n     }\n \n     #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n-        self.slice(start, self.len())\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.mut_slice(start, len)\n     }\n \n     #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n-        self.slice(0, end)\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.mut_slice(0, end)\n     }\n \n     #[inline]\n-    fn iter(self) -> Items<'a, T> {\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n-            let p = self.as_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n-                      end: (p as uint + self.len()) as *T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            } else {\n-                Items{ptr: p,\n-                      end: p.offset(self.len() as int),\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            }\n+            let len = self.len();\n+            let self2: &'a mut [T] = mem::transmute_copy(&self);\n+            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n         }\n     }\n \n     #[inline]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        Splits {\n-            v: self,\n-            pred: pred,\n-            finished: false\n+    fn mut_iter(self) -> MutItems<'a, T> {\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                MutItems{ptr: p,\n+                         end: (p as uint + self.len()) as *mut T,\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            } else {\n+                MutItems{ptr: p,\n+                         end: p.offset(self.len() as int),\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            }\n         }\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n-        }\n+    fn mut_last(self) -> Option<&'a mut T> {\n+        let len = self.len();\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n-        }\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+        MutSplits { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn windows(self, size: uint) -> Windows<'a, T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n+        assert!(chunk_size > 0);\n+        MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    #[inline]\n-    fn chunks(self, size: uint) -> Chunks<'a, T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::shift_ptr(s) {\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n+            }\n+        }\n     }\n \n-    #[inline]\n-    fn get(&self, index: uint) -> Option<&'a T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::pop_ptr(s) {\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n+            }\n+        }\n     }\n \n-    #[inline]\n-    fn head(&self) -> Option<&'a T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n+    fn swap(self, a: uint, b: uint) {\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap(pa, pb);\n+        }\n     }\n \n-    #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n-\n-    #[inline]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n-\n-    #[inline]\n-    fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+    fn reverse(self) {\n+        let mut i: uint = 0;\n+        let ln = self.len();\n+        while i < ln / 2 {\n+            self.swap(i, ln - i - 1);\n+            i += 1;\n+        }\n     }\n \n     #[inline]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n+        transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n     #[inline]\n-    fn last(&self) -> Option<&'a T> {\n-            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n     }\n \n     #[inline]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n+    unsafe fn unsafe_set(self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n     }\n \n     #[inline]\n-    fn as_ptr(&self) -> *T {\n-        self.repr().data\n-    }\n-\n-\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n-    }\n-\n-    fn shift_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n+    unsafe fn init_elem(self, i: uint, val: T) {\n+        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n     }\n \n-    fn pop_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n+    #[inline]\n+    unsafe fn copy_memory(self, src: &[T]) {\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n     }\n }\n \n@@ -714,395 +802,523 @@ impl<'a, T: Ord> ImmutableOrdVector<T> for &'a [T] {\n     }\n }\n \n-/// Extension methods for vectors such that their elements are\n-/// mutable.\n-pub trait MutableVector<'a, T> {\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    fn get_mut(self, index: uint) -> Option<&'a mut T>;\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(self) -> &'a mut [T];\n+/// Trait for &[T] where T is Cloneable\n+pub trait MutableCloneableVector<T> {\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::slice::MutableCloneableVector;\n+    ///\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    fn copy_from(self, &[T]) -> uint;\n+}\n \n-    /// Return a slice that points into another slice.\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n+impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn copy_from(self, src: &[T]) -> uint {\n+        for (a, b) in self.mut_iter().zip(src.iter()) {\n+            a.clone_from(b);\n+        }\n+        cmp::min(self.len(), src.len())\n+    }\n+}\n \n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n \n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n \n-    /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> MutItems<'a, T>;\n \n-    /// Returns a mutable pointer to the last item in the vector.\n-    fn mut_last(self) -> Option<&'a mut T>;\n+//\n+// Common traits\n+//\n \n-    /// Returns an iterator over the mutable subslices of the vector\n-    /// which are separated by elements that match `pred`.  The\n-    /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n+}\n \n-    /**\n-     * Returns an iterator over `size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n+impl<'a,T> Vector<T> for &'a [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n+}\n \n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self.mut_slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n+impl<'a, T> Collection for &'a [T] {\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.repr().len\n+    }\n+}\n \n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.mut_slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n+impl<'a, T> Default for &'a [T] {\n+    fn default() -> &'a [T] { &[] }\n+}\n \n-    /// Swaps two elements in a vector.\n-    ///\n-    /// Fails if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    fn swap(self, a: uint, b: uint);\n \n \n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Fails if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.mut_split_at(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert!(left == &mut [1i, 2]);\n-    ///     assert!(right == &mut [3i, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n-    /// ```\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n \n-    /// Reverse the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n-    /// ```\n-    fn reverse(self);\n+//\n+// Iterators\n+//\n \n-    /// Returns an unsafe mutable pointer to the element in index\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n+// The shared definition of the `Item` and `MutItems` iterators\n+macro_rules! iterator {\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.ptr == self.end {\n+                        None\n+                    } else {\n+                        let old = self.ptr;\n+                        self.ptr = if mem::size_of::<T>() == 0 {\n+                            // purposefully don't use 'ptr.offset' because for\n+                            // vectors with 0-size elements this would return the\n+                            // same pointer.\n+                            transmute(self.ptr as uint + 1)\n+                        } else {\n+                            self.ptr.offset(1)\n+                        };\n \n-    /// Return an unsafe mutable pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n+                        Some(transmute(old))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                let diff = (self.end as uint) - (self.ptr as uint);\n+                let size = mem::size_of::<T>();\n+                let exact = diff / (if size == 0 {1} else {size});\n+                (exact, Some(exact))\n+            }\n+        }\n+\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.end == self.ptr {\n+                        None\n+                    } else {\n+                        self.end = if mem::size_of::<T>() == 0 {\n+                            // See above for why 'ptr.offset' isn't used\n+                            transmute(self.end as uint - 1)\n+                        } else {\n+                            self.end.offset(-1)\n+                        };\n+                        Some(transmute(self.end))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Immutable slice iterator\n+pub struct Items<'a, T> {\n+    ptr: *const T,\n+    end: *const T,\n+    marker: marker::ContravariantLifetime<'a>\n+}\n+\n+iterator!{struct Items -> *const T, &'a T}\n+\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+\n+impl<'a, T> Clone for Items<'a, T> {\n+    fn clone(&self) -> Items<'a, T> { *self }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn as_mut_ptr(self) -> *mut T;\n+    fn indexable(&self) -> uint {\n+        let (exact, _) = self.size_hint();\n+        exact\n+    }\n \n-    /// Unsafely sets the element in index to the value.\n-    ///\n-    /// This performs no bounds checks, and it is undefined behaviour\n-    /// if `index` is larger than the length of `self`. However, it\n-    /// does run the destructor at `index`. It is equivalent to\n-    /// `self[index] = val`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n-    ///\n-    /// unsafe {\n-    ///     // `\"baz\".to_string()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_string());\n-    ///\n-    ///     // Out of bounds: could cause a crash, or overwriting\n-    ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_string());\n-    /// }\n-    /// ```\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a T> {\n+        unsafe {\n+            if index < self.indexable() {\n+                transmute(self.ptr.offset(index as int))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n \n-    /// Unchecked vector index assignment.  Does not drop the\n-    /// old value and hence is only suitable when the vector\n-    /// is newly allocated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n-    ///\n-    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n-    /// ```\n-    unsafe fn init_elem(self, i: uint, val: T);\n+/// Mutable slice iterator\n+pub struct MutItems<'a, T> {\n+    ptr: *mut T,\n+    end: *mut T,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n+}\n \n-    /// Copies raw bytes from `src` to `self`.\n-    ///\n-    /// This does not run destructors on the overwritten elements, and\n-    /// ignores move semantics. `self` and `src` must not\n-    /// overlap. Fails if `self` is shorter than `src`.\n-    unsafe fn copy_memory(self, src: &[T]);\n+iterator!{struct MutItems -> *mut T, &'a mut T}\n+\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct Splits<'a, T> {\n+    v: &'a [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n }\n \n-impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n+impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn get_mut(self, index: uint) -> Option<&'a mut T> {\n-        if index < self.len() { Some(&mut self[index]) } else { None }\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                ret\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn as_mut_slice(self) -> &'a mut [T] { self }\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n \n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(Slice {\n-                    data: self.as_mut_ptr().offset(start as int) as *T,\n-                    len: (end - start)\n-                })\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`.\n+pub struct MutSplits<'a, T> {\n+    v: &'a mut [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let len = tmp.len();\n+                let (head, tail) = tmp.mut_split_at(len);\n+                self.v = tail;\n+                Some(head)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = tail.mut_slice_from(1);\n+                Some(head)\n+            }\n         }\n     }\n \n     #[inline]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.mut_slice(start, len)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n     }\n+}\n \n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.mut_slice(0, end)\n-    }\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n \n-    #[inline]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        unsafe {\n-            let len = self.len();\n-            let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                Some(tmp)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = head;\n+                Some(tail.mut_slice_from(1))\n+            }\n         }\n     }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n \n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n             } else {\n-                MutItems{ptr: p,\n-                         end: p.offset(self.len() as int),\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n             }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         }\n     }\n \n     #[inline]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        MutSplits { v: self, pred: pred, finished: false }\n-    }\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+#[deriving(Clone)]\n+pub struct Windows<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n \n+impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n     }\n \n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let x = self.v.len() - self.size;\n+            (x.saturating_add(1), x.checked_add(&1u))\n         }\n     }\n+}\n \n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainder.\n+#[deriving(Clone)]\n+pub struct Chunks<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n         }\n     }\n \n-    fn swap(self, a: uint, b: uint) {\n-        unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n-            ptr::swap(pa, pb);\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.size);\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n         }\n     }\n+}\n \n-    fn reverse(self) {\n-        let mut i: uint = 0;\n-        let ln = self.len();\n-        while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n-            i += 1;\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n         }\n     }\n+}\n \n+impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n     }\n \n     #[inline]\n-    fn as_mut_ptr(self) -> *mut T {\n-        self.repr().data as *mut T\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n+        }\n     }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunks<'a, T> {\n+    v: &'a mut [T],\n+    chunk_size: uint\n+}\n \n+impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut_ref(index) = val;\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split_at(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n     }\n \n     #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n     }\n+}\n \n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n     }\n }\n \n-/// Trait for &[T] where T is Cloneable\n-pub trait MutableCloneableVector<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::slice::MutableCloneableVector;\n-    ///\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.copy_from(src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.copy_from(src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    fn copy_from(self, &[T]) -> uint;\n+\n+\n+\n+//\n+// Free functions\n+//\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+    unsafe {\n+        transmute(Slice { data: s, len: 1 })\n+    }\n }\n \n-impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n-    #[inline]\n-    fn copy_from(self, src: &[T]) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.iter()) {\n-            a.clone_from(b);\n-        }\n-        cmp::min(self.len(), src.len())\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+    unsafe {\n+        let ptr: *const A = transmute(s);\n+        transmute(Slice { data: ptr, len: 1 })\n     }\n }\n \n+\n+\n+\n+//\n+// Submodules\n+//\n+\n /// Unsafe operations\n pub mod raw {\n     use mem::transmute;\n@@ -1115,7 +1331,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+    pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)\n                                -> U {\n         f(transmute(Slice {\n             data: p,\n@@ -1135,7 +1351,7 @@ pub mod raw {\n                                    f: |v: &mut [T]| -> U)\n                                    -> U {\n         f(transmute(Slice {\n-            data: p as *T,\n+            data: p as *const T,\n             len: len\n         }))\n     }\n@@ -1146,9 +1362,9 @@ pub mod raw {\n      * if the slice is empty. O(1).\n      */\n      #[inline]\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n-        let head: *T = slice.data;\n+        let head: *const T = slice.data;\n         slice.data = slice.data.offset(1);\n         slice.len -= 1;\n         Some(head)\n@@ -1160,9 +1376,9 @@ pub mod raw {\n      * if the slice is empty. O(1).\n      */\n      #[inline]\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n-        let tail: *T = slice.data.offset((slice.len - 1) as int);\n+        let tail: *const T = slice.data.offset((slice.len - 1) as int);\n         slice.len -= 1;\n         Some(tail)\n     }\n@@ -1199,224 +1415,56 @@ pub mod bytes {\n     }\n }\n \n-/// Immutable slice iterator\n-pub struct Items<'a, T> {\n-    ptr: *T,\n-    end: *T,\n-    marker: marker::ContravariantLifetime<'a>\n-}\n-\n-/// Mutable slice iterator\n-pub struct MutItems<'a, T> {\n-    ptr: *mut T,\n-    end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n-}\n-\n-macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            transmute(self.ptr as uint + 1)\n-                        } else {\n-                            self.ptr.offset(1)\n-                        };\n \n-                        Some(transmute(old))\n-                    }\n-                }\n-            }\n \n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n-                let size = mem::size_of::<T>();\n-                let exact = diff / (if size == 0 {1} else {size});\n-                (exact, Some(exact))\n-            }\n-        }\n \n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n-                        } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n+//\n+// Boilerplate traits\n+//\n \n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        let (exact, _) = self.size_hint();\n-        exact\n+impl<'a,T:PartialEq> PartialEq for &'a [T] {\n+    fn eq(&self, other: & &'a [T]) -> bool {\n+        self.len() == other.len() &&\n+            order::eq(self.iter(), other.iter())\n     }\n-\n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n-        unsafe {\n-            if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n-            } else {\n-                None\n-            }\n-        }\n+    fn ne(&self, other: & &'a [T]) -> bool {\n+        self.len() != other.len() ||\n+            order::ne(self.iter(), other.iter())\n     }\n }\n \n-iterator!{struct Items -> *T, &'a T}\n-\n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n-impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n-\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n-}\n-\n-iterator!{struct MutItems -> *mut T, &'a mut T}\n-\n-/// An iterator over the subslices of the vector which are separated\n-/// by elements that match `pred`.\n-pub struct MutSplits<'a, T> {\n-    v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n+impl<'a,T:Eq> Eq for &'a [T] {}\n \n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().position(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n-                self.v = tail;\n-                Some(head)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = tail.mut_slice_from(1);\n-                Some(head)\n-            }\n-        }\n+impl<'a,T:Ord> Ord for &'a [T] {\n+    fn cmp(&self, other: & &'a [T]) -> Ordering {\n+        order::cmp(self.iter(), other.iter())\n     }\n+}\n \n+impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n-            (1, Some(self.v.len() + 1))\n-        }\n+    fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n+        order::partial_cmp(self.iter(), other.iter())\n     }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n-\n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                Some(tmp)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = head;\n-                Some(tail.mut_slice_from(1))\n-            }\n-        }\n+    fn lt(&self, other: & &'a [T]) -> bool {\n+        order::lt(self.iter(), other.iter())\n     }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n-/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n-/// the remainder.\n-pub struct MutChunks<'a, T> {\n-    v: &'a mut [T],\n-    chunk_size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(sz);\n-            self.v = tail;\n-            Some(head)\n-        }\n+    fn le(&self, other: & &'a [T]) -> bool {\n+        order::le(self.iter(), other.iter())\n     }\n-\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n-            let n = if rem > 0 { n + 1 } else { n };\n-            (n, Some(n))\n-        }\n+    fn ge(&self, other: & &'a [T]) -> bool {\n+        order::ge(self.iter(), other.iter())\n     }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.chunk_size;\n-            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n-            self.v = head;\n-            Some(tail)\n-        }\n+    fn gt(&self, other: & &'a [T]) -> bool {\n+        order::gt(self.iter(), other.iter())\n     }\n }\n-\n-impl<'a, T> Default for &'a [T] {\n-    fn default() -> &'a [T] { &[] }\n-}"}, {"sha": "94df7a5a6c2d9c7548a089e8e949fbc32936f226", "filename": "src/libcore/str.rs", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -16,6 +16,7 @@\n \n use mem;\n use char;\n+use char::Char;\n use clone::Clone;\n use cmp;\n use cmp::{PartialEq, Eq};\n@@ -24,7 +25,7 @@ use default::Default;\n use iter::{Filter, Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n-use num::Saturating;\n+use num::{CheckedMul, Saturating};\n use option::{None, Option, Some};\n use raw::Repr;\n use slice::ImmutableVector;\n@@ -557,6 +558,41 @@ impl<'a> Iterator<&'a str> for StrSplits<'a> {\n     }\n }\n \n+/// External iterator for a string's UTF16 codeunits.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct Utf16CodeUnits<'a> {\n+    chars: Chars<'a>,\n+    extra: u16\n+}\n+\n+impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0u16, ..2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(buf /* as mut slice! */);\n+            if n == 2 { self.extra = buf[1]; }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(&2)))\n+    }\n+}\n+\n /*\n Section: Comparing strings\n */\n@@ -568,31 +604,23 @@ Section: Comparing strings\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n     #[allow(ctypes)]\n-    extern { fn memcmp(s1: *i8, s2: *i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n     a.len() == b.len() && unsafe {\n-        memcmp(a.as_ptr() as *i8,\n-               b.as_ptr() as *i8,\n+        memcmp(a.as_ptr() as *const i8,\n+               b.as_ptr() as *const i8,\n                a.len()) == 0\n     }\n }\n \n /// Bytewise slice equality\n /// NOTE: This function is (ab)used in rustc::middle::trans::_match\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n }\n \n-/// Bytewise slice equality\n-#[cfg(test)]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n /*\n Section: Misc\n */\n@@ -888,8 +916,8 @@ pub mod raw {\n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n-    pub unsafe fn c_str_to_static_slice(s: *i8) -> &'static str {\n-        let s = s as *u8;\n+    pub unsafe fn c_str_to_static_slice(s: *const i8) -> &'static str {\n+        let s = s as *const u8;\n         let mut curr = s;\n         let mut len = 0u;\n         while *curr != 0u8 {\n@@ -934,13 +962,12 @@ pub mod raw {\n Section: Trait implementations\n */\n \n-#[cfg(not(test))]\n #[allow(missing_doc)]\n pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n     use collections::Collection;\n     use iter::Iterator;\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n     use str::{Str, StrSlice, eq_slice};\n \n     impl<'a> Ord for &'a str {\n@@ -971,7 +998,9 @@ pub mod traits {\n \n     impl<'a> PartialOrd for &'a str {\n         #[inline]\n-        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n+        fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n     }\n \n     impl<'a, S: Str> Equiv<S> for &'a str {\n@@ -980,9 +1009,6 @@ pub mod traits {\n     }\n }\n \n-#[cfg(test)]\n-pub mod traits {}\n-\n /// Any string that can be represented as a slice\n pub trait Str {\n     /// Work with `self` as a slice.\n@@ -1618,7 +1644,10 @@ pub trait StrSlice<'a> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    fn as_ptr(&self) -> *u8;\n+    fn as_ptr(&self) -> *const u8;\n+\n+    /// Return an iterator of `u16` over the string encoded as UTF-16.\n+    fn utf16_units(&self) -> Utf16CodeUnits<'a>;\n }\n \n impl<'a> StrSlice<'a> for &'a str {\n@@ -1714,7 +1743,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn lines_any(&self) -> AnyLines<'a> {\n         self.lines().map(|line| {\n             let l = line.len();\n-            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n         })\n     }\n@@ -1838,26 +1867,26 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         if index > self.len() { return false; }\n-        let b = self[index];\n+        let b = self.as_bytes()[index];\n         return b < 128u8 || b >= 192u8;\n     }\n \n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        if self[i] < 128u8 {\n-            return CharRange {ch: self[i] as char, next: i + 1 };\n+        if self.as_bytes()[i] < 128u8 {\n+            return CharRange {ch: self.as_bytes()[i] as char, next: i + 1 };\n         }\n \n         // Multibyte case is a fn to allow char_range_at to inline cleanly\n         fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as u32;\n+            let mut val = s.as_bytes()[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n         }\n@@ -1870,23 +1899,25 @@ impl<'a> StrSlice<'a> for &'a str {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n-        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n+        if self.as_bytes()[prev] < 128 {\n+            return CharRange{ch: self.as_bytes()[prev] as char, next: prev}\n+        }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n         fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n-            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n+            while i > 0 && s.as_bytes()[i] & 192u8 == TAG_CONT_U8 {\n                 i -= 1u;\n             }\n \n-            let mut val = s[i] as u32;\n+            let mut val = s.as_bytes()[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }\n@@ -1964,9 +1995,14 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn as_ptr(&self) -> *u8 {\n+    fn as_ptr(&self) -> *const u8 {\n         self.repr().data\n     }\n+\n+    #[inline]\n+    fn utf16_units(&self) -> Utf16CodeUnits<'a> {\n+        Utf16CodeUnits{ chars: self.chars(), extra: 0}\n+    }\n }\n \n impl<'a> Default for &'a str {"}, {"sha": "0e3722894bc467771f52af3266c888691733581a", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 17, "deletions": 97, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -62,8 +62,9 @@\n #![doc(primitive = \"tuple\")]\n \n use clone::Clone;\n-#[cfg(not(test))] use cmp::*;\n-#[cfg(not(test))] use default::Default;\n+use cmp::*;\n+use default::Default;\n+use option::{Option, Some};\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n@@ -111,7 +112,6 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -123,11 +123,13 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[cfg(not(test))]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n+                #[inline]\n+                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                    lexical_partial_cmp!($(self.$refN(), other.$refN()),+)\n+                }\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n                     lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n@@ -146,15 +148,13 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n@@ -177,6 +177,16 @@ macro_rules! lexical_ord {\n     ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n }\n \n+macro_rules! lexical_partial_cmp {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        match ($a).partial_cmp($b) {\n+            Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n+            ordering   => ordering\n+        }\n+    };\n+    ($a:expr, $b:expr) => { ($a).partial_cmp($b) };\n+}\n+\n macro_rules! lexical_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n         match ($a).cmp($b) {\n@@ -292,93 +302,3 @@ tuple_impls! {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use clone::Clone;\n-    use cmp::*;\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_clone() {\n-        let a = (1i, \"2\");\n-        let b = a.clone();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_getters() {\n-        macro_rules! test_getter(\n-            ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n-             $init:expr, $incr:expr, $result:expr) => ({\n-                assert_eq!($x.$valN(), $init);\n-                assert_eq!(*$x.$refN(), $init);\n-                *$x.$mutN() += $incr;\n-                assert_eq!(*$x.$refN(), $result);\n-            })\n-        )\n-        let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-        test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n-        test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n-        test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n-        test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n-        test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n-        test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n-        test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n-        test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n-        test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n-        test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n-        test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n-        test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n-    }\n-\n-    #[test]\n-    fn test_tuple_cmp() {\n-        let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n-\n-        let nan = 0.0f64/0.0;\n-\n-        // PartialEq\n-        assert_eq!(small, small);\n-        assert_eq!(big, big);\n-        assert!(small != big);\n-        assert!(big != small);\n-\n-        // PartialOrd\n-        assert!(small < big);\n-        assert!(!(small < small));\n-        assert!(!(big < small));\n-        assert!(!(big < big));\n-\n-        assert!(small <= small);\n-        assert!(big <= big);\n-\n-        assert!(big > small);\n-        assert!(small >= small);\n-        assert!(big >= small);\n-        assert!(big >= big);\n-\n-        assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n-        assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n-        assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n-\n-        // Ord\n-        assert!(small.cmp(&small) == Equal);\n-        assert!(big.cmp(&big) == Equal);\n-        assert!(small.cmp(&big) == Less);\n-        assert!(big.cmp(&small) == Greater);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let s = format!(\"{}\", (1i,));\n-        assert_eq!(s.as_slice(), \"(1,)\");\n-        let s = format!(\"{}\", (1i, true));\n-        assert_eq!(s.as_slice(), \"(1, true)\");\n-        let s = format!(\"{}\", (1i, \"hi\", true));\n-        assert_eq!(s.as_slice(), \"(1, hi, true)\");\n-    }\n-}"}, {"sha": "5bdab6a78ca337d207a63394678360475e5db2a4", "filename": "src/libcore/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -62,7 +62,7 @@ impl<T> Unsafe<T> {\n \n     /// Gets a mutable pointer to the wrapped value\n     #[inline]\n-    pub unsafe fn get(&self) -> *mut T { &self.value as *T as *mut T }\n+    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     #[inline]"}, {"sha": "fae4a26cd3863ff555969cf6c1b8c88b52c42c4b", "filename": "src/libcoretest/any.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use core::any::*;\n+use test::Bencher;\n+use test;\n+\n+#[deriving(PartialEq, Show)]\n+struct Test;\n+\n+static TEST: &'static str = \"Test\";\n+\n+#[test]\n+fn any_referenced() {\n+    let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n+\n+    assert!(a.is::<uint>());\n+    assert!(!b.is::<uint>());\n+    assert!(!c.is::<uint>());\n+\n+    assert!(!a.is::<&'static str>());\n+    assert!(b.is::<&'static str>());\n+    assert!(!c.is::<&'static str>());\n+\n+    assert!(!a.is::<Test>());\n+    assert!(!b.is::<Test>());\n+    assert!(c.is::<Test>());\n+}\n+\n+#[test]\n+fn any_owning() {\n+    let (a, b, c) = (box 5u as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n+\n+    assert!(a.is::<uint>());\n+    assert!(!b.is::<uint>());\n+    assert!(!c.is::<uint>());\n+\n+    assert!(!a.is::<&'static str>());\n+    assert!(b.is::<&'static str>());\n+    assert!(!c.is::<&'static str>());\n+\n+    assert!(!a.is::<Test>());\n+    assert!(!b.is::<Test>());\n+    assert!(c.is::<Test>());\n+}\n+\n+#[test]\n+fn any_as_ref() {\n+    let a = &5u as &Any;\n+\n+    match a.as_ref::<uint>() {\n+        Some(&5) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a.as_ref::<Test>() {\n+        None => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+}\n+\n+#[test]\n+fn any_as_mut() {\n+    let mut a = 5u;\n+    let mut b = box 7u;\n+\n+    let a_r = &mut a as &mut Any;\n+    let tmp: &mut uint = &mut *b;\n+    let b_r = tmp as &mut Any;\n+\n+    match a_r.as_mut::<uint>() {\n+        Some(x) => {\n+            assert_eq!(*x, 5u);\n+            *x = 612;\n+        }\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<uint>() {\n+        Some(x) => {\n+            assert_eq!(*x, 7u);\n+            *x = 413;\n+        }\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a_r.as_mut::<Test>() {\n+        None => (),\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<Test>() {\n+        None => (),\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a_r.as_mut::<uint>() {\n+        Some(&612) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<uint>() {\n+        Some(&413) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+}\n+\n+#[test]\n+fn any_fixed_vec() {\n+    let test = [0u, ..8];\n+    let test = &test as &Any;\n+    assert!(test.is::<[uint, ..8]>());\n+    assert!(!test.is::<[uint, ..10]>());\n+}\n+\n+\n+#[bench]\n+fn bench_as_ref(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut x = 0i;\n+        let mut y = &mut x as &mut Any;\n+        test::black_box(&mut y);\n+        test::black_box(y.as_ref::<int>() == Some(&0));\n+    });\n+}"}, {"sha": "3f960ae1f267fbf9caa8dcc75380ff73199f7841", "filename": "src/libcoretest/atomics.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomics.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::atomics::*;\n+\n+#[test]\n+fn bool_() {\n+    let a = AtomicBool::new(false);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n+\n+    a.store(false, SeqCst);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+}\n+\n+#[test]\n+fn bool_and() {\n+    let a = AtomicBool::new(true);\n+    assert_eq!(a.fetch_and(false, SeqCst),true);\n+    assert_eq!(a.load(SeqCst),false);\n+}\n+\n+#[test]\n+fn uint_and() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+}\n+\n+#[test]\n+fn uint_or() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+}\n+\n+#[test]\n+fn uint_xor() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+}\n+\n+#[test]\n+fn int_and() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+}\n+\n+#[test]\n+fn int_or() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+}\n+\n+#[test]\n+fn int_xor() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+}\n+\n+static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n+static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n+static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+\n+#[test]\n+fn static_init() {\n+    unsafe {\n+        assert!(!S_BOOL.load(SeqCst));\n+        assert!(S_INT.load(SeqCst) == 0);\n+        assert!(S_UINT.load(SeqCst) == 0);\n+    }\n+}"}, {"sha": "b3ae110363cb56e357ddcf3adfded634a6673cda", "filename": "src/libcoretest/cell.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cell::*;\n+use std::mem::drop;\n+\n+#[test]\n+fn smoketest_cell() {\n+    let x = Cell::new(10i);\n+    assert!(x == Cell::new(10));\n+    assert!(x.get() == 10);\n+    x.set(20);\n+    assert!(x == Cell::new(20));\n+    assert!(x.get() == 20);\n+\n+    let y = Cell::new((30i, 40i));\n+    assert!(y == Cell::new((30, 40)));\n+    assert!(y.get() == (30, 40));\n+}\n+\n+#[test]\n+fn cell_has_sensible_show() {\n+    let x = Cell::new(\"foo bar\");\n+    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+\n+    x.set(\"baz qux\");\n+    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+}\n+\n+#[test]\n+fn ref_and_refmut_have_sensible_show() {\n+    let refcell = RefCell::new(\"foo\");\n+\n+    let refcell_refmut = refcell.borrow_mut();\n+    assert!(format!(\"{}\", refcell_refmut).as_slice().contains(\"foo\"));\n+    drop(refcell_refmut);\n+\n+    let refcell_ref = refcell.borrow();\n+    assert!(format!(\"{}\", refcell_ref).as_slice().contains(\"foo\"));\n+    drop(refcell_ref);\n+}\n+\n+#[test]\n+fn double_imm_borrow() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    x.borrow();\n+}\n+\n+#[test]\n+fn no_mut_then_imm_borrow() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow_mut();\n+    assert!(x.try_borrow().is_none());\n+}\n+\n+#[test]\n+fn no_imm_then_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+fn no_double_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow_mut();\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+fn imm_release_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    {\n+        let _b1 = x.borrow();\n+    }\n+    x.borrow_mut();\n+}\n+\n+#[test]\n+fn mut_release_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    {\n+        let _b1 = x.borrow_mut();\n+    }\n+    x.borrow();\n+}\n+\n+#[test]\n+fn double_borrow_single_release_no_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    {\n+        let _b2 = x.borrow();\n+    }\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+#[should_fail]\n+fn discard_doesnt_unborrow() {\n+    let x = RefCell::new(0i);\n+    let _b = x.borrow();\n+    let _ = _b;\n+    let _b = x.borrow_mut();\n+}\n+\n+#[test]\n+#[allow(experimental)]\n+fn clone_ref_updates_flag() {\n+    let x = RefCell::new(0i);\n+    {\n+        let b1 = x.borrow();\n+        assert!(x.try_borrow_mut().is_none());\n+        {\n+            let _b2 = clone_ref(&b1);\n+            assert!(x.try_borrow_mut().is_none());\n+        }\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+    assert!(x.try_borrow_mut().is_some());\n+}"}, {"sha": "852edd90b0f3fb28ecb6ad4b574dce7fe2079d50", "filename": "src/libcoretest/char.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::char::{escape_unicode, escape_default};\n+\n+#[test]\n+fn test_is_lowercase() {\n+    assert!('a'.is_lowercase());\n+    assert!('\u00f6'.is_lowercase());\n+    assert!('\u00df'.is_lowercase());\n+    assert!(!'\u00dc'.is_lowercase());\n+    assert!(!'P'.is_lowercase());\n+}\n+\n+#[test]\n+fn test_is_uppercase() {\n+    assert!(!'h'.is_uppercase());\n+    assert!(!'\u00e4'.is_uppercase());\n+    assert!(!'\u00df'.is_uppercase());\n+    assert!('\u00d6'.is_uppercase());\n+    assert!('T'.is_uppercase());\n+}\n+\n+#[test]\n+fn test_is_whitespace() {\n+    assert!(' '.is_whitespace());\n+    assert!('\\u2007'.is_whitespace());\n+    assert!('\\t'.is_whitespace());\n+    assert!('\\n'.is_whitespace());\n+    assert!(!'a'.is_whitespace());\n+    assert!(!'_'.is_whitespace());\n+    assert!(!'\\u0000'.is_whitespace());\n+}\n+\n+#[test]\n+fn test_to_digit() {\n+    assert_eq!('0'.to_digit(10u), Some(0u));\n+    assert_eq!('1'.to_digit(2u), Some(1u));\n+    assert_eq!('2'.to_digit(3u), Some(2u));\n+    assert_eq!('9'.to_digit(10u), Some(9u));\n+    assert_eq!('a'.to_digit(16u), Some(10u));\n+    assert_eq!('A'.to_digit(16u), Some(10u));\n+    assert_eq!('b'.to_digit(16u), Some(11u));\n+    assert_eq!('B'.to_digit(16u), Some(11u));\n+    assert_eq!('z'.to_digit(36u), Some(35u));\n+    assert_eq!('Z'.to_digit(36u), Some(35u));\n+    assert_eq!(' '.to_digit(10u), None);\n+    assert_eq!('$'.to_digit(36u), None);\n+}\n+\n+#[test]\n+fn test_to_lowercase() {\n+    assert_eq!('A'.to_lowercase(), 'a');\n+    assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n+    assert_eq!('\u00df'.to_lowercase(), '\u00df');\n+    assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n+    assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n+    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+    assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n+    assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n+    assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n+    assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n+    assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n+    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+}\n+\n+#[test]\n+fn test_to_uppercase() {\n+    assert_eq!('a'.to_uppercase(), 'A');\n+    assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n+    assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n+    assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n+\n+    assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n+    assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n+    assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n+    assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n+    assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n+    assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n+    assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n+}\n+\n+#[test]\n+fn test_is_control() {\n+    assert!('\\u0000'.is_control());\n+    assert!('\\u0003'.is_control());\n+    assert!('\\u0006'.is_control());\n+    assert!('\\u0009'.is_control());\n+    assert!('\\u007f'.is_control());\n+    assert!('\\u0092'.is_control());\n+    assert!(!'\\u0020'.is_control());\n+    assert!(!'\\u0055'.is_control());\n+    assert!(!'\\u0068'.is_control());\n+}\n+\n+#[test]\n+fn test_is_digit() {\n+   assert!('2'.is_digit());\n+   assert!('7'.is_digit());\n+   assert!(!'c'.is_digit());\n+   assert!(!'i'.is_digit());\n+   assert!(!'z'.is_digit());\n+   assert!(!'Q'.is_digit());\n+}\n+\n+#[test]\n+fn test_escape_default() {\n+    fn string(c: char) -> String {\n+        let mut result = String::new();\n+        escape_default(c, |c| { result.push_char(c); });\n+        return result;\n+    }\n+    let s = string('\\n');\n+    assert_eq!(s.as_slice(), \"\\\\n\");\n+    let s = string('\\r');\n+    assert_eq!(s.as_slice(), \"\\\\r\");\n+    let s = string('\\'');\n+    assert_eq!(s.as_slice(), \"\\\\'\");\n+    let s = string('\"');\n+    assert_eq!(s.as_slice(), \"\\\\\\\"\");\n+    let s = string(' ');\n+    assert_eq!(s.as_slice(), \" \");\n+    let s = string('a');\n+    assert_eq!(s.as_slice(), \"a\");\n+    let s = string('~');\n+    assert_eq!(s.as_slice(), \"~\");\n+    let s = string('\\x00');\n+    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    let s = string('\\x1f');\n+    assert_eq!(s.as_slice(), \"\\\\x1f\");\n+    let s = string('\\x7f');\n+    assert_eq!(s.as_slice(), \"\\\\x7f\");\n+    let s = string('\\xff');\n+    assert_eq!(s.as_slice(), \"\\\\xff\");\n+    let s = string('\\u011b');\n+    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    let s = string('\\U0001d4b6');\n+    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+}\n+\n+#[test]\n+fn test_escape_unicode() {\n+    fn string(c: char) -> String {\n+        let mut result = String::new();\n+        escape_unicode(c, |c| { result.push_char(c); });\n+        return result;\n+    }\n+    let s = string('\\x00');\n+    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    let s = string('\\n');\n+    assert_eq!(s.as_slice(), \"\\\\x0a\");\n+    let s = string(' ');\n+    assert_eq!(s.as_slice(), \"\\\\x20\");\n+    let s = string('a');\n+    assert_eq!(s.as_slice(), \"\\\\x61\");\n+    let s = string('\\u011b');\n+    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    let s = string('\\U0001d4b6');\n+    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+}\n+\n+#[test]\n+fn test_to_str() {\n+    let s = 't'.to_str();\n+    assert_eq!(s.as_slice(), \"t\");\n+}\n+\n+#[test]\n+fn test_encode_utf8() {\n+    fn check(input: char, expect: &[u8]) {\n+        let mut buf = [0u8, ..4];\n+        let n = input.encode_utf8(buf /* as mut slice! */);\n+        assert_eq!(buf.slice_to(n), expect);\n+    }\n+\n+    check('x', [0x78]);\n+    check('\\u00e9', [0xc3, 0xa9]);\n+    check('\\ua66e', [0xea, 0x99, 0xae]);\n+    check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n+}\n+\n+#[test]\n+fn test_encode_utf16() {\n+    fn check(input: char, expect: &[u16]) {\n+        let mut buf = [0u16, ..2];\n+        let n = input.encode_utf16(buf /* as mut slice! */);\n+        assert_eq!(buf.slice_to(n), expect);\n+    }\n+\n+    check('x', [0x0078]);\n+    check('\\u00e9', [0x00e9]);\n+    check('\\ua66e', [0xa66e]);\n+    check('\\U0001f4a9', [0xd83d, 0xdca9]);\n+}"}, {"sha": "67c30d945d497383b2f8edc31e532036a7dc239c", "filename": "src/libcoretest/clone.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fclone.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn test_borrowed_clone() {\n+    let x = 5i;\n+    let y: &int = &x;\n+    let z: &int = (&y).clone();\n+    assert_eq!(*z, 5);\n+}\n+\n+#[test]\n+fn test_clone_from() {\n+    let a = box 5i;\n+    let mut b = box 10i;\n+    b.clone_from(&a);\n+    assert_eq!(*b, 5);\n+}\n+\n+#[test]\n+fn test_extern_fn_clone() {\n+    trait Empty {}\n+    impl Empty for int {}\n+\n+    fn test_fn_a() -> f64 { 1.0 }\n+    fn test_fn_b<T: Empty>(x: T) -> T { x }\n+    fn test_fn_c(_: int, _: f64, _: int, _: int, _: int) {}\n+\n+    let _ = test_fn_a.clone();\n+    let _ = test_fn_b::<int>.clone();\n+    let _ = test_fn_c.clone();\n+}"}, {"sha": "88e944be3e860da442b41495447b8dd958e8fe1d", "filename": "src/libcoretest/cmp.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cmp::lexical_ordering;\n+\n+#[test]\n+fn test_int_totalord() {\n+    assert_eq!(5i.cmp(&10), Less);\n+    assert_eq!(10i.cmp(&5), Greater);\n+    assert_eq!(5i.cmp(&5), Equal);\n+    assert_eq!((-5i).cmp(&12), Less);\n+    assert_eq!(12i.cmp(&-5), Greater);\n+}\n+\n+#[test]\n+fn test_mut_int_totalord() {\n+    assert_eq!((&mut 5i).cmp(&&mut 10), Less);\n+    assert_eq!((&mut 10i).cmp(&&mut 5), Greater);\n+    assert_eq!((&mut 5i).cmp(&&mut 5), Equal);\n+    assert_eq!((&mut -5i).cmp(&&mut 12), Less);\n+    assert_eq!((&mut 12i).cmp(&&mut -5), Greater);\n+}\n+\n+#[test]\n+fn test_ordering_order() {\n+    assert!(Less < Equal);\n+    assert_eq!(Greater.cmp(&Less), Greater);\n+}\n+\n+#[test]\n+fn test_lexical_ordering() {\n+    fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n+        assert_eq!(lexical_ordering(o1, o2), e);\n+    }\n+\n+    let xs = [Less, Equal, Greater];\n+    for &o in xs.iter() {\n+        t(Less, o, Less);\n+        t(Equal, o, o);\n+        t(Greater, o, Greater);\n+     }\n+}\n+\n+#[test]\n+fn test_user_defined_eq() {\n+    // Our type.\n+    struct SketchyNum {\n+        num : int\n+    }\n+\n+    // Our implementation of `PartialEq` to support `==` and `!=`.\n+    impl PartialEq for SketchyNum {\n+        // Our custom eq allows numbers which are near each other to be equal! :D\n+        fn eq(&self, other: &SketchyNum) -> bool {\n+            (self.num - other.num).abs() < 5\n+        }\n+    }\n+\n+    // Now these binary operators will work when applied!\n+    assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+    assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+}"}, {"sha": "5da004086d27f84dfe97922cba49f27c9911d976", "filename": "src/libcoretest/finally.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::finally::{try_finally, Finally};\n+use std::task::failing;\n+\n+#[test]\n+fn test_success() {\n+    let mut i = 0i;\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+        },\n+        |i| {\n+            assert!(!failing());\n+            assert_eq!(*i, 10);\n+            *i = 20;\n+        });\n+    assert_eq!(i, 20);\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_fail() {\n+    let mut i = 0i;\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+            fail!();\n+        },\n+        |i| {\n+            assert!(failing());\n+            assert_eq!(*i, 10);\n+        })\n+}\n+\n+#[test]\n+fn test_retval() {\n+    let mut closure: || -> int = || 10;\n+    let i = closure.finally(|| { });\n+    assert_eq!(i, 10);\n+}\n+\n+#[test]\n+fn test_compact() {\n+    fn do_some_fallible_work() {}\n+    fn but_always_run_this_function() { }\n+    let mut f = do_some_fallible_work;\n+    f.finally(but_always_run_this_function);\n+}"}, {"sha": "9fc09b3124ef381864c131bbe8710639faa65ed4", "filename": "src/libcoretest/fmt/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod num;"}, {"sha": "baef7e3a11e8561bdeb6d10f1a781da68a8341b1", "filename": "src/libcoretest/fmt/num.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(unsigned_negate)]\n+\n+use core::fmt::radix;\n+\n+#[test]\n+fn test_format_int() {\n+    // Formatting integers should select the right implementation based off\n+    // the type of the argument. Also, hex/octal/binary should be defined\n+    // for integers, but they shouldn't emit the negative sign.\n+    assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n+    assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n+\n+    assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n+\n+    // Test a larger number\n+    assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n+    assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n+    assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n+    assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n+    assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n+}\n+\n+#[test]\n+fn test_format_int_zero() {\n+    assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n+\n+    assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n+}\n+\n+#[test]\n+fn test_format_int_flags() {\n+    assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n+    assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n+    assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n+    assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n+    assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n+    assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n+    assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n+    assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n+    assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n+    assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n+    assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n+    assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n+    assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n+    assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n+    assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n+    assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n+    assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n+    assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n+    assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n+    assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n+}\n+\n+#[test]\n+fn test_format_int_sign_padding() {\n+    assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n+    assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n+    assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n+    assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n+    assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n+    assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n+}\n+\n+#[test]\n+fn test_format_int_twos_complement() {\n+    use core::{i8, i16, i32, i64};\n+    assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n+    assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n+    assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n+    assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n+}\n+\n+#[test]\n+fn test_format_radix() {\n+    assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n+    assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_radix_base_too_large() {\n+    let _ = radix(55i, 37);\n+}\n+\n+mod uint {\n+    use test::Bencher;\n+    use core::fmt::radix;\n+    use std::rand::{weak_rng, Rng};\n+\n+    #[bench]\n+    fn format_bin(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_oct(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_dec(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_hex(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_base_36(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n+    }\n+}\n+\n+mod int {\n+    use test::Bencher;\n+    use core::fmt::radix;\n+    use std::rand::{weak_rng, Rng};\n+\n+    #[bench]\n+    fn format_bin(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_oct(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_dec(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_hex(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_base_36(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n+    }\n+}"}, {"sha": "86b5ffece41033c7a8b851a637b2490c4b2ccee9", "filename": "src/libcoretest/iter.rs", "status": "added", "additions": 835, "deletions": 0, "changes": 835, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,835 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::iter::*;\n+use core::iter::order::*;\n+use core::uint;\n+use core::cmp;\n+use core::num;\n+\n+#[test]\n+fn test_lt() {\n+    let empty: [int, ..0] = [];\n+    let xs = [1i,2,3];\n+    let ys = [1i,2,0];\n+\n+    assert!(!lt(xs.iter(), ys.iter()));\n+    assert!(!le(xs.iter(), ys.iter()));\n+    assert!( gt(xs.iter(), ys.iter()));\n+    assert!( ge(xs.iter(), ys.iter()));\n+\n+    assert!( lt(ys.iter(), xs.iter()));\n+    assert!( le(ys.iter(), xs.iter()));\n+    assert!(!gt(ys.iter(), xs.iter()));\n+    assert!(!ge(ys.iter(), xs.iter()));\n+\n+    assert!( lt(empty.iter(), xs.iter()));\n+    assert!( le(empty.iter(), xs.iter()));\n+    assert!(!gt(empty.iter(), xs.iter()));\n+    assert!(!ge(empty.iter(), xs.iter()));\n+\n+    // Sequence with NaN\n+    let u = [1.0f64, 2.0];\n+    let v = [0.0f64/0.0, 3.0];\n+\n+    assert!(!lt(u.iter(), v.iter()));\n+    assert!(!le(u.iter(), v.iter()));\n+    assert!(!gt(u.iter(), v.iter()));\n+    assert!(!ge(u.iter(), v.iter()));\n+\n+    let a = [0.0f64/0.0];\n+    let b = [1.0f64];\n+    let c = [2.0f64];\n+\n+    assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n+    assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n+    assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n+    assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n+\n+    assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n+    assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n+    assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n+    assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n+}\n+\n+#[test]\n+fn test_multi_iter() {\n+    let xs = [1i,2,3,4];\n+    let ys = [4i,3,2,1];\n+    assert!(eq(xs.iter(), ys.iter().rev()));\n+    assert!(lt(xs.iter(), xs.iter().skip(2)));\n+}\n+\n+#[test]\n+fn test_counter_from_iter() {\n+    let it = count(0i, 5).take(10);\n+    let xs: Vec<int> = FromIterator::from_iter(it);\n+    assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+}\n+\n+#[test]\n+fn test_iterator_chain() {\n+    let xs = [0u, 1, 2, 3, 4, 5];\n+    let ys = [30u, 40, 50, 60];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    let mut it = xs.iter().chain(ys.iter());\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    let ys = count(30u, 10).take(4);\n+    let mut it = xs.iter().map(|&x| x).chain(ys);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_filter_map() {\n+    let mut it = count(0u, 1u).take(10)\n+        .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n+    assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate() {\n+    let xs = [0u, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    for (i, &x) in it {\n+        assert_eq!(i, x);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_peekable() {\n+    let xs = vec![0u, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().map(|&x|x).peekable();\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.next().unwrap(), 0);\n+    assert_eq!(it.next().unwrap(), 1);\n+    assert_eq!(it.next().unwrap(), 2);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.next().unwrap(), 3);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.peek().unwrap(), &5);\n+    assert_eq!(it.next().unwrap(), 5);\n+    assert!(it.peek().is_none());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_take_while() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0u, 1, 2, 3, 5, 13];\n+    let mut it = xs.iter().take_while(|&x| *x < 15u);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_skip_while() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let mut it = xs.iter().skip_while(|&x| *x < 15u);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_skip() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+    let mut it = xs.iter().skip(5);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_take() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0u, 1, 2, 3, 5];\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_scan() {\n+    // test the type inference\n+    fn add(old: &mut int, new: &uint) -> Option<f64> {\n+        *old += *new as int;\n+        Some(*old as f64)\n+    }\n+    let xs = [0u, 1, 2, 3, 4];\n+    let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n+\n+    let mut it = xs.iter().scan(0, add);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_flat_map() {\n+    let xs = [0u, 3, 6];\n+    let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_inspect() {\n+    let xs = [1u, 2, 3, 4];\n+    let mut n = 0;\n+\n+    let ys = xs.iter()\n+               .map(|&x| x)\n+               .inspect(|_| n += 1)\n+               .collect::<Vec<uint>>();\n+\n+    assert_eq!(n, xs.len());\n+    assert_eq!(xs.as_slice(), ys.as_slice());\n+}\n+\n+#[test]\n+fn test_unfoldr() {\n+    fn count(st: &mut uint) -> Option<uint> {\n+        if *st < 10 {\n+            let ret = Some(*st);\n+            *st += 1;\n+            ret\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let mut it = Unfold::new(0, count);\n+    let mut i = 0;\n+    for counted in it {\n+        assert_eq!(counted, i);\n+        i += 1;\n+    }\n+    assert_eq!(i, 10);\n+}\n+\n+#[test]\n+fn test_cycle() {\n+    let cycle_len = 3;\n+    let it = count(0u, 1).take(cycle_len).cycle();\n+    assert_eq!(it.size_hint(), (uint::MAX, None));\n+    for (i, x) in it.take(100).enumerate() {\n+        assert_eq!(i % cycle_len, x);\n+    }\n+\n+    let mut it = count(0u, 1).take(0).cycle();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_nth() {\n+    let v = &[0i, 1, 2, 3, 4];\n+    for i in range(0u, v.len()) {\n+        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_last() {\n+    let v = &[0i, 1, 2, 3, 4];\n+    assert_eq!(v.iter().last().unwrap(), &4);\n+    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n+}\n+\n+#[test]\n+fn test_iterator_len() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().count(), 4);\n+    assert_eq!(v.slice(0, 10).iter().count(), 10);\n+    assert_eq!(v.slice(0, 0).iter().count(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_sum() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n+    assert_eq!(v.iter().map(|&x| x).sum(), 55);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_product() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n+    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n+}\n+\n+#[test]\n+fn test_iterator_max() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n+    assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n+}\n+\n+#[test]\n+fn test_iterator_min() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n+}\n+\n+#[test]\n+fn test_iterator_size_hint() {\n+    let c = count(0i, 1);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v2 = &[10i, 11, 12];\n+    let vi = v.iter();\n+\n+    assert_eq!(c.size_hint(), (uint::MAX, None));\n+    assert_eq!(vi.size_hint(), (10, Some(10)));\n+\n+    assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(c.skip(5).size_hint().val1(), None);\n+    assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n+    assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n+    assert_eq!(c.scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n+    assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.map(|_| 0i).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.filter_map(|_| Some(0i)).size_hint(), (0, None));\n+\n+    assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n+    assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n+    assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n+    assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let a = vec![1i, 2, 3, 4, 5];\n+    let b: Vec<int> = a.iter().map(|&x| x).collect();\n+    assert!(a == b);\n+}\n+\n+#[test]\n+fn test_all() {\n+    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    assert!(v.iter().all(|&x| x < 10));\n+    assert!(!v.iter().all(|&x| x % 2 == 0));\n+    assert!(!v.iter().all(|&x| x > 100));\n+    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+}\n+\n+#[test]\n+fn test_any() {\n+    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    assert!(v.iter().any(|&x| x < 10));\n+    assert!(v.iter().any(|&x| x % 2 == 0));\n+    assert!(!v.iter().any(|&x| x > 100));\n+    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+}\n+\n+#[test]\n+fn test_find() {\n+    let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n+    assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n+    assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n+}\n+\n+#[test]\n+fn test_position() {\n+    let v = &[1i, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n+    assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n+    assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n+}\n+\n+#[test]\n+fn test_count() {\n+    let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n+    assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n+    assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n+    assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n+}\n+\n+#[test]\n+fn test_max_by() {\n+    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+}\n+\n+#[test]\n+fn test_min_by() {\n+    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_by_ref() {\n+    let mut xs = range(0i, 10);\n+    // sum the first five values\n+    let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n+    assert_eq!(partial_sum, 10);\n+    assert_eq!(xs.next(), Some(5));\n+}\n+\n+#[test]\n+fn test_rev() {\n+    let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n+    let mut it = xs.iter();\n+    it.next();\n+    it.next();\n+    assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n+            vec![16, 14, 12, 10, 8, 6]);\n+}\n+\n+#[test]\n+fn test_double_ended_map() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().map(|&x| x * -1);\n+    assert_eq!(it.next(), Some(-1));\n+    assert_eq!(it.next(), Some(-2));\n+    assert_eq!(it.next_back(), Some(-6));\n+    assert_eq!(it.next_back(), Some(-5));\n+    assert_eq!(it.next(), Some(-3));\n+    assert_eq!(it.next_back(), Some(-4));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_enumerate() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().map(|&x| x).enumerate();\n+    assert_eq!(it.next(), Some((0, 1)));\n+    assert_eq!(it.next(), Some((1, 2)));\n+    assert_eq!(it.next_back(), Some((5, 6)));\n+    assert_eq!(it.next_back(), Some((4, 5)));\n+    assert_eq!(it.next_back(), Some((3, 4)));\n+    assert_eq!(it.next_back(), Some((2, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_zip() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let ys = [1i, 2, 3, 7];\n+    let a = xs.iter().map(|&x| x);\n+    let b = ys.iter().map(|&x| x);\n+    let mut it = a.zip(b);\n+    assert_eq!(it.next(), Some((1, 1)));\n+    assert_eq!(it.next(), Some((2, 2)));\n+    assert_eq!(it.next_back(), Some((4, 7)));\n+    assert_eq!(it.next_back(), Some((3, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_filter() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.next().unwrap(), &2);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_filter_map() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n+    assert_eq!(it.next_back().unwrap(), 12);\n+    assert_eq!(it.next_back().unwrap(), 8);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_chain() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    let mut it = xs.iter().chain(ys.iter()).rev();\n+    assert_eq!(it.next().unwrap(), &11)\n+    assert_eq!(it.next().unwrap(), &9)\n+    assert_eq!(it.next_back().unwrap(), &1)\n+    assert_eq!(it.next_back().unwrap(), &2)\n+    assert_eq!(it.next_back().unwrap(), &3)\n+    assert_eq!(it.next_back().unwrap(), &4)\n+    assert_eq!(it.next_back().unwrap(), &5)\n+    assert_eq!(it.next_back().unwrap(), &7)\n+    assert_eq!(it.next_back(), None)\n+}\n+\n+#[test]\n+fn test_rposition() {\n+    fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+    fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n+    let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+    assert_eq!(v.iter().rposition(f), Some(3u));\n+    assert!(v.iter().rposition(g).is_none());\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_rposition_fail() {\n+    use std::gc::GC;\n+    let v = [(box 0i, box(GC) 0i), (box 0i, box(GC) 0i),\n+             (box 0i, box(GC) 0i), (box 0i, box(GC) 0i)];\n+    let mut i = 0i;\n+    v.iter().rposition(|_elt| {\n+        if i == 2 {\n+            fail!()\n+        }\n+        i += 1;\n+        false\n+    });\n+}\n+\n+\n+#[cfg(test)]\n+fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+{\n+    let mut b = a.clone();\n+    assert_eq!(len, b.indexable());\n+    let mut n = 0u;\n+    for (i, elt) in a.enumerate() {\n+        assert!(Some(elt) == b.idx(i));\n+        n += 1;\n+    }\n+    assert_eq!(n, len);\n+    assert!(None == b.idx(n));\n+    // call recursively to check after picking off an element\n+    if len > 0 {\n+        b.next();\n+        check_randacc_iter(b, len-1);\n+    }\n+}\n+\n+\n+#[test]\n+fn test_double_ended_flat_map() {\n+    let u = [0u,1];\n+    let v = [5u,6,7,8];\n+    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_random_access_chain() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    let mut it = xs.iter().chain(ys.iter());\n+    assert_eq!(it.idx(0).unwrap(), &1);\n+    assert_eq!(it.idx(5).unwrap(), &7);\n+    assert_eq!(it.idx(7).unwrap(), &11);\n+    assert!(it.idx(8).is_none());\n+\n+    it.next();\n+    it.next();\n+    it.next_back();\n+\n+    assert_eq!(it.idx(0).unwrap(), &3);\n+    assert_eq!(it.idx(4).unwrap(), &9);\n+    assert!(it.idx(6).is_none());\n+\n+    check_randacc_iter(it, xs.len() + ys.len() - 3);\n+}\n+\n+#[test]\n+fn test_random_access_enumerate() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    check_randacc_iter(xs.iter().enumerate(), xs.len());\n+}\n+\n+#[test]\n+fn test_random_access_rev() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    check_randacc_iter(xs.iter().rev(), xs.len());\n+    let mut it = xs.iter().rev();\n+    it.next();\n+    it.next_back();\n+    it.next();\n+    check_randacc_iter(it, xs.len() - 3);\n+}\n+\n+#[test]\n+fn test_random_access_zip() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n+}\n+\n+#[test]\n+fn test_random_access_take() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().take(3), 3);\n+    check_randacc_iter(xs.iter().take(20), xs.len());\n+    check_randacc_iter(xs.iter().take(0), 0);\n+    check_randacc_iter(empty.iter().take(2), 0);\n+}\n+\n+#[test]\n+fn test_random_access_skip() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n+    check_randacc_iter(empty.iter().skip(2), 0);\n+}\n+\n+#[test]\n+fn test_random_access_inspect() {\n+    let xs = [1i, 2, 3, 4, 5];\n+\n+    // test .map and .inspect that don't implement Clone\n+    let mut it = xs.iter().inspect(|_| {});\n+    assert_eq!(xs.len(), it.indexable());\n+    for (i, elt) in xs.iter().enumerate() {\n+        assert_eq!(Some(elt), it.idx(i));\n+    }\n+\n+}\n+\n+#[test]\n+fn test_random_access_map() {\n+    let xs = [1i, 2, 3, 4, 5];\n+\n+    let mut it = xs.iter().map(|x| *x);\n+    assert_eq!(xs.len(), it.indexable());\n+    for (i, elt) in xs.iter().enumerate() {\n+        assert_eq!(Some(*elt), it.idx(i));\n+    }\n+}\n+\n+#[test]\n+fn test_random_access_cycle() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().cycle().take(27), 27);\n+    check_randacc_iter(empty.iter().cycle(), 0);\n+}\n+\n+#[test]\n+fn test_double_ended_range() {\n+    assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n+    for _ in range(10i, 0).rev() {\n+        fail!(\"unreachable\");\n+    }\n+\n+    assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n+    for _ in range(10u, 0).rev() {\n+        fail!(\"unreachable\");\n+    }\n+}\n+\n+#[test]\n+fn test_range() {\n+    /// A mock type to check Range when ToPrimitive returns None\n+    struct Foo;\n+\n+    impl ToPrimitive for Foo {\n+        fn to_i64(&self) -> Option<i64> { None }\n+        fn to_u64(&self) -> Option<u64> { None }\n+    }\n+\n+    impl Add<Foo, Foo> for Foo {\n+        fn add(&self, _: &Foo) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, _: &Foo) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl PartialOrd for Foo {\n+        fn partial_cmp(&self, _: &Foo) -> Option<Ordering> {\n+            None\n+        }\n+    }\n+\n+    impl Clone for Foo {\n+        fn clone(&self) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl Mul<Foo, Foo> for Foo {\n+        fn mul(&self, _: &Foo) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl num::One for Foo {\n+        fn one() -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n+    assert!(range(-10i, -1).collect::<Vec<int>>() ==\n+               vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+    assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!(range(200i, -5).count(), 0);\n+    assert_eq!(range(200i, -5).rev().count(), 0);\n+    assert_eq!(range(200i, 200).count(), 0);\n+    assert_eq!(range(200i, 200).rev().count(), 0);\n+\n+    assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n+    // this test is only meaningful when sizeof uint < sizeof u64\n+    assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n+    assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n+    assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n+}\n+\n+#[test]\n+fn test_range_inclusive() {\n+    assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n+            vec![0i, 1, 2, 3, 4, 5]);\n+    assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n+            vec![5i, 4, 3, 2, 1, 0]);\n+    assert_eq!(range_inclusive(200i, -5).count(), 0);\n+    assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n+    assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n+    assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n+}\n+\n+#[test]\n+fn test_range_step() {\n+    assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n+            vec![0, 5, 10, 15]);\n+    assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n+            vec![20, 15, 10, 5]);\n+    assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n+            vec![20, 14, 8, 2]);\n+    assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n+            vec![200u8, 250]);\n+    assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n+    assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n+}\n+\n+#[test]\n+fn test_range_step_inclusive() {\n+    assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n+            vec![0, 5, 10, 15, 20]);\n+    assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n+            vec![20, 15, 10, 5, 0]);\n+    assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n+            vec![20, 14, 8, 2]);\n+    assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n+            vec![200u8, 250]);\n+    assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n+            vec![]);\n+    assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n+            vec![200]);\n+}\n+\n+#[test]\n+fn test_reverse() {\n+    let mut ys = [1i, 2, 3, 4, 5];\n+    ys.mut_iter().reverse_();\n+    assert!(ys == [5, 4, 3, 2, 1]);\n+}\n+\n+#[test]\n+fn test_peekable_is_empty() {\n+    let a = [1i];\n+    let mut it = a.iter().peekable();\n+    assert!( !it.is_empty() );\n+    it.next();\n+    assert!( it.is_empty() );\n+}\n+\n+#[test]\n+fn test_min_max() {\n+    let v: [int, ..0] = [];\n+    assert_eq!(v.iter().min_max(), NoElements);\n+\n+    let v = [1i];\n+    assert!(v.iter().min_max() == OneElement(&1));\n+\n+    let v = [1i, 2, 3, 4, 5];\n+    assert!(v.iter().min_max() == MinMax(&1, &5));\n+\n+    let v = [1i, 2, 3, 4, 5, 6];\n+    assert!(v.iter().min_max() == MinMax(&1, &6));\n+\n+    let v = [1i, 1, 1, 1];\n+    assert!(v.iter().min_max() == MinMax(&1, &1));\n+}\n+\n+#[test]\n+fn test_min_max_result() {\n+    let r: MinMaxResult<int> = NoElements;\n+    assert_eq!(r.into_option(), None)\n+\n+    let r = OneElement(1i);\n+    assert_eq!(r.into_option(), Some((1,1)));\n+\n+    let r = MinMax(1i,2);\n+    assert_eq!(r.into_option(), Some((1,2)));\n+}"}, {"sha": "3a3cac542c91b34a1092e444d25d01bdf82e1580", "filename": "src/libcoretest/lib.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(globs, unsafe_destructor, macro_rules)]\n+\n+extern crate core;\n+extern crate test;\n+extern crate libc;\n+\n+mod any;\n+mod atomics;\n+mod cell;\n+mod char;\n+mod cmp;\n+mod finally;\n+mod fmt;\n+mod iter;\n+mod mem;\n+mod num;\n+mod ops;\n+mod option;\n+mod ptr;\n+mod raw;\n+mod result;\n+mod tuple;"}, {"sha": "fde640158f51e09c9a9c269cd99274638cb62009", "filename": "src/libcoretest/mem.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use core::mem::*;\n+use test::Bencher;\n+\n+#[test]\n+fn size_of_basic() {\n+    assert_eq!(size_of::<u8>(), 1u);\n+    assert_eq!(size_of::<u16>(), 2u);\n+    assert_eq!(size_of::<u32>(), 4u);\n+    assert_eq!(size_of::<u64>(), 8u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+fn size_of_32() {\n+    assert_eq!(size_of::<uint>(), 4u);\n+    assert_eq!(size_of::<*const uint>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86_64\")]\n+fn size_of_64() {\n+    assert_eq!(size_of::<uint>(), 8u);\n+    assert_eq!(size_of::<*const uint>(), 8u);\n+}\n+\n+#[test]\n+fn size_of_val_basic() {\n+    assert_eq!(size_of_val(&1u8), 1);\n+    assert_eq!(size_of_val(&1u16), 2);\n+    assert_eq!(size_of_val(&1u32), 4);\n+    assert_eq!(size_of_val(&1u64), 8);\n+}\n+\n+#[test]\n+fn align_of_basic() {\n+    assert_eq!(align_of::<u8>(), 1u);\n+    assert_eq!(align_of::<u16>(), 2u);\n+    assert_eq!(align_of::<u32>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+fn align_of_32() {\n+    assert_eq!(align_of::<uint>(), 4u);\n+    assert_eq!(align_of::<*const uint>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86_64\")]\n+fn align_of_64() {\n+    assert_eq!(align_of::<uint>(), 8u);\n+    assert_eq!(align_of::<*const uint>(), 8u);\n+}\n+\n+#[test]\n+fn align_of_val_basic() {\n+    assert_eq!(align_of_val(&1u8), 1u);\n+    assert_eq!(align_of_val(&1u16), 2u);\n+    assert_eq!(align_of_val(&1u32), 4u);\n+}\n+\n+#[test]\n+fn test_swap() {\n+    let mut x = 31337i;\n+    let mut y = 42i;\n+    swap(&mut x, &mut y);\n+    assert_eq!(x, 42);\n+    assert_eq!(y, 31337);\n+}\n+\n+#[test]\n+fn test_replace() {\n+    let mut x = Some(\"test\".to_string());\n+    let y = replace(&mut x, None);\n+    assert!(x.is_none());\n+    assert!(y.is_some());\n+}\n+\n+#[test]\n+fn test_transmute_copy() {\n+    assert_eq!(1u, unsafe { transmute_copy(&1i) });\n+}\n+\n+#[test]\n+fn test_transmute() {\n+    trait Foo {}\n+    impl Foo for int {}\n+\n+    let a = box 100i as Box<Foo>;\n+    unsafe {\n+        let x: ::core::raw::TraitObject = transmute(a);\n+        assert!(*(x.data as *const int) == 100);\n+        let _x: Box<Foo> = transmute(x);\n+    }\n+\n+    unsafe {\n+        assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n+    }\n+}\n+\n+// FIXME #13642 (these benchmarks should be in another place)\n+/// Completely miscellaneous language-construct benchmarks.\n+// Static/dynamic method dispatch\n+\n+struct Struct {\n+    field: int\n+}\n+\n+trait Trait {\n+    fn method(&self) -> int;\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) -> int {\n+        self.field\n+    }\n+}\n+\n+#[bench]\n+fn trait_vtable_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    let t = &s as &Trait;\n+    b.iter(|| {\n+        t.method()\n+    });\n+}\n+\n+#[bench]\n+fn trait_static_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    b.iter(|| {\n+        s.method()\n+    });\n+}\n+\n+// Overhead of various match forms\n+\n+#[bench]\n+fn match_option_some(b: &mut Bencher) {\n+    let x = Some(10i);\n+    b.iter(|| {\n+        match x {\n+            Some(y) => y,\n+            None => 11\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn match_vec_pattern(b: &mut Bencher) {\n+    let x = [1i,2,3,4,5,6];\n+    b.iter(|| {\n+        match x {\n+            [1,2,3,..] => 10i,\n+            _ => 11i,\n+        }\n+    });\n+}"}, {"sha": "f3c2d67cdeb1b7c6eb29e7a131f06ec092ff9376", "filename": "src/libcoretest/num/i16.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi16.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i16, i16)"}, {"sha": "7232fc7505df9af78fcc16af60e9dbcd1f7cfb16", "filename": "src/libcoretest/num/i32.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i32, i32)"}, {"sha": "075b8448f3529e5a35aeb5d4ed01c3620f894cec", "filename": "src/libcoretest/num/i64.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi64.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i64, i64)"}, {"sha": "9e0439f281889ba32393e0752e40d4da0e6fb53c", "filename": "src/libcoretest/num/i8.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi8.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i8, i8)"}, {"sha": "f01ec3f0310a31d7ac34ed394fa8673422e5ea49", "filename": "src/libcoretest/num/int.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(int, int)"}, {"sha": "940b036ca907be036b4a7003ba70186d79c66738", "filename": "src/libcoretest/num/int_macros.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+macro_rules! int_module (($T:ty, $T_i:ident) => (\n+#[cfg(test)]\n+mod tests {\n+    use core::$T_i::*;\n+    use core::int;\n+    use num;\n+    use core::num::CheckedDiv;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    pub fn test_abs() {\n+        assert!((1 as $T).abs() == 1 as $T);\n+        assert!((0 as $T).abs() == 0 as $T);\n+        assert!((-1 as $T).abs() == 1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n+        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert!((1 as $T).signum() == 1 as $T);\n+        assert!((0 as $T).signum() == 0 as $T);\n+        assert!((-0 as $T).signum() == 0 as $T);\n+        assert!((-1 as $T).signum() == -1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!((1 as $T).is_positive());\n+        assert!(!(0 as $T).is_positive());\n+        assert!(!(-0 as $T).is_positive());\n+        assert!(!(-1 as $T).is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!(1 as $T).is_negative());\n+        assert!(!(0 as $T).is_negative());\n+        assert!(!(-0 as $T).is_negative());\n+        assert!((-1 as $T).is_negative());\n+    }\n+\n+    #[test]\n+    fn test_bitwise_operators() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n+    }\n+\n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n+\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n+    }\n+\n+    #[test]\n+    fn test_signed_checked_div() {\n+        assert!(10i.checked_div(&2) == Some(5));\n+        assert!(5i.checked_div(&0) == None);\n+        assert!(int::MIN.checked_div(&-1) == None);\n+    }\n+}\n+\n+))"}, {"sha": "8bb238c0b66e8be401b2c1ab758d4d90c6bbc4d6", "filename": "src/libcoretest/num/mod.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::num::cast;\n+\n+mod int_macros;\n+mod i8;\n+mod i16;\n+mod i32;\n+mod i64;\n+mod int;\n+mod uint_macros;\n+mod u8;\n+mod u16;\n+mod u32;\n+mod u64;\n+mod uint;\n+\n+/// Helper function for testing numeric operations\n+pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n+    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n+\n+    assert_eq!(ten.add(&two),  ten + two);\n+    assert_eq!(ten.sub(&two),  ten - two);\n+    assert_eq!(ten.mul(&two),  ten * two);\n+    assert_eq!(ten.div(&two),  ten / two);\n+    assert_eq!(ten.rem(&two),  ten % two);\n+}"}, {"sha": "d6aa6476678040e7bc2218c870c9780105d5fcb5", "filename": "src/libcoretest/num/u16.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu16.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u16, u16)"}, {"sha": "218e79df5aecec458dcb8fa4ec33e062cf995bce", "filename": "src/libcoretest/num/u32.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u32, u32)"}, {"sha": "f78d4813503e7349fa1c1e584d50fbae26b5c56c", "filename": "src/libcoretest/num/u64.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu64.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u64, u64)"}, {"sha": "bb08072320b70cad64ac9c75d00c05058e0a61f9", "filename": "src/libcoretest/num/u8.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu8.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u8, u8)"}, {"sha": "0db865f4cde7ac0db43f222eb13db6b011c91e49", "filename": "src/libcoretest/num/uint.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(uint, uint)"}, {"sha": "2272af67daf8580b7303aeb1f84d4a341ba70a5a", "filename": "src/libcoretest/num/uint_macros.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+macro_rules! uint_module (($T:ty, $T_i:ident) => (\n+#[cfg(test)]\n+mod tests {\n+    use core::$T_i::*;\n+    use num;\n+    use core::num::CheckedDiv;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_bitwise_operators() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n+    }\n+\n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n+\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n+    }\n+\n+    #[test]\n+    fn test_unsigned_checked_div() {\n+        assert!(10u.checked_div(&2) == Some(5));\n+        assert!(5u.checked_div(&0) == None);\n+    }\n+}\n+))"}, {"sha": "447fd1c699d3d1bfe4d96664a931156671690781", "filename": "src/libcoretest/ops.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+\n+// Overhead of dtors\n+\n+struct HasDtor {\n+    _x: int\n+}\n+\n+impl Drop for HasDtor {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+#[bench]\n+fn alloc_obj_with_dtor(b: &mut Bencher) {\n+    b.iter(|| {\n+        HasDtor { _x : 10 };\n+    })\n+}"}, {"sha": "776637f3be97d5c59c49d85f87ea594bdfc046ba", "filename": "src/libcoretest/option.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::option::*;\n+use core::kinds::marker;\n+use core::mem;\n+\n+#[test]\n+fn test_get_ptr() {\n+    unsafe {\n+        let x = box 0i;\n+        let addr_x: *const int = mem::transmute(&*x);\n+        let opt = Some(x);\n+        let y = opt.unwrap();\n+        let addr_y: *const int = mem::transmute(&*y);\n+        assert_eq!(addr_x, addr_y);\n+    }\n+}\n+\n+#[test]\n+fn test_get_str() {\n+    let x = \"test\".to_string();\n+    let addr_x = x.as_slice().as_ptr();\n+    let opt = Some(x);\n+    let y = opt.unwrap();\n+    let addr_y = y.as_slice().as_ptr();\n+    assert_eq!(addr_x, addr_y);\n+}\n+\n+#[test]\n+fn test_get_resource() {\n+    use std::rc::Rc;\n+    use core::cell::RefCell;\n+\n+    struct R {\n+       i: Rc<RefCell<int>>,\n+    }\n+\n+    #[unsafe_destructor]\n+    impl Drop for R {\n+       fn drop(&mut self) {\n+            let ii = &*self.i;\n+            let i = *ii.borrow();\n+            *ii.borrow_mut() = i + 1;\n+        }\n+    }\n+\n+    fn r(i: Rc<RefCell<int>>) -> R {\n+        R {\n+            i: i\n+        }\n+    }\n+\n+    let i = Rc::new(RefCell::new(0i));\n+    {\n+        let x = r(i.clone());\n+        let opt = Some(x);\n+        let _y = opt.unwrap();\n+    }\n+    assert_eq!(*i.borrow(), 1);\n+}\n+\n+#[test]\n+fn test_option_dance() {\n+    let x = Some(());\n+    let mut y = Some(5i);\n+    let mut y2 = 0;\n+    for _x in x.iter() {\n+        y2 = y.take_unwrap();\n+    }\n+    assert_eq!(y2, 5);\n+    assert!(y.is_none());\n+}\n+\n+#[test] #[should_fail]\n+fn test_option_too_much_dance() {\n+    let mut y = Some(marker::NoCopy);\n+    let _y2 = y.take_unwrap();\n+    let _y3 = y.take_unwrap();\n+}\n+\n+#[test]\n+fn test_and() {\n+    let x: Option<int> = Some(1i);\n+    assert_eq!(x.and(Some(2i)), Some(2));\n+    assert_eq!(x.and(None::<int>), None);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.and(Some(2i)), None);\n+    assert_eq!(x.and(None::<int>), None);\n+}\n+\n+#[test]\n+fn test_and_then() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n+    assert_eq!(x.and_then(|_| None::<int>), None);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.and_then(|x| Some(x + 1)), None);\n+    assert_eq!(x.and_then(|_| None::<int>), None);\n+}\n+\n+#[test]\n+fn test_or() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.or(Some(2)), Some(1));\n+    assert_eq!(x.or(None), Some(1));\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.or(Some(2)), Some(2));\n+    assert_eq!(x.or(None), None);\n+}\n+\n+#[test]\n+fn test_or_else() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.or_else(|| Some(2)), Some(1));\n+    assert_eq!(x.or_else(|| None), Some(1));\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.or_else(|| Some(2)), Some(2));\n+    assert_eq!(x.or_else(|| None), None);\n+}\n+\n+#[test]\n+fn test_option_while_some() {\n+    let mut i = 0i;\n+    Some(10i).while_some(|j| {\n+        i += 1;\n+        if j > 0 {\n+            Some(j-1)\n+        } else {\n+            None\n+        }\n+    });\n+    assert_eq!(i, 11);\n+}\n+\n+#[test]\n+fn test_unwrap() {\n+    assert_eq!(Some(1i).unwrap(), 1);\n+    let s = Some(\"hello\".to_string()).unwrap();\n+    assert_eq!(s.as_slice(), \"hello\");\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_unwrap_fail1() {\n+    let x: Option<int> = None;\n+    x.unwrap();\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_unwrap_fail2() {\n+    let x: Option<String> = None;\n+    x.unwrap();\n+}\n+\n+#[test]\n+fn test_unwrap_or() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.unwrap_or(2), 1);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.unwrap_or(2), 2);\n+}\n+\n+#[test]\n+fn test_unwrap_or_else() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.unwrap_or_else(|| 2), 1);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.unwrap_or_else(|| 2), 2);\n+}\n+\n+#[test]\n+fn test_filtered() {\n+    let some_stuff = Some(42i);\n+    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n+    assert_eq!(some_stuff.unwrap(), 42);\n+    assert!(modified_stuff.is_none());\n+}\n+\n+#[test]\n+fn test_iter() {\n+    let val = 5i;\n+\n+    let x = Some(val);\n+    let mut it = x.iter();\n+\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next(), Some(&val));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let val = 5i;\n+    let new_val = 11i;\n+\n+    let mut x = Some(val);\n+    {\n+        let mut it = x.mut_iter();\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+        match it.next() {\n+            Some(interior) => {\n+                assert_eq!(*interior, val);\n+                *interior = new_val;\n+            }\n+            None => assert!(false),\n+        }\n+\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n+    assert_eq!(x, Some(new_val));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let small = Some(1.0f64);\n+    let big = Some(5.0f64);\n+    let nan = Some(0.0f64/0.0);\n+    assert!(!(nan < big));\n+    assert!(!(nan > big));\n+    assert!(small < big);\n+    assert!(None < big);\n+    assert!(big > None);\n+}\n+\n+#[test]\n+fn test_mutate() {\n+    let mut x = Some(3i);\n+    assert!(x.mutate(|i| i+1));\n+    assert_eq!(x, Some(4i));\n+    assert!(x.mutate_or_set(0, |i| i+1));\n+    assert_eq!(x, Some(5i));\n+    x = None;\n+    assert!(!x.mutate(|i| i+1));\n+    assert_eq!(x, None);\n+    assert!(!x.mutate_or_set(0i, |i| i+1));\n+    assert_eq!(x, Some(0i));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let v: Option<Vec<int>> = collect(range(0i, 0)\n+                                      .map(|_| Some(0i)));\n+    assert!(v == Some(vec![]));\n+\n+    let v: Option<Vec<int>> = collect(range(0i, 3)\n+                                      .map(|x| Some(x)));\n+    assert!(v == Some(vec![0, 1, 2]));\n+\n+    let v: Option<Vec<int>> = collect(range(0i, 3)\n+                                      .map(|x| if x > 1 { None } else { Some(x) }));\n+    assert!(v == None);\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Some(()), || None, || fail!()];\n+\n+    let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n+\n+    assert!(v == None);\n+}"}, {"sha": "2a4ef5e275d20b271eeaf6f8a18a63f3f6cbbe9a", "filename": "src/libcoretest/ptr.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,255 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(deprecated)]\n+use core::ptr::*;\n+use libc::c_char;\n+use core::mem;\n+use std::str;\n+use libc;\n+\n+#[test]\n+fn test() {\n+    unsafe {\n+        struct Pair {\n+            fst: int,\n+            snd: int\n+        };\n+        let mut p = Pair {fst: 10, snd: 20};\n+        let pptr: *mut Pair = &mut p;\n+        let iptr: *mut int = mem::transmute(pptr);\n+        assert_eq!(*iptr, 10);\n+        *iptr = 30;\n+        assert_eq!(*iptr, 30);\n+        assert_eq!(p.fst, 30);\n+\n+        *pptr = Pair {fst: 50, snd: 60};\n+        assert_eq!(*iptr, 50);\n+        assert_eq!(p.fst, 50);\n+        assert_eq!(p.snd, 60);\n+\n+        let v0 = vec![32000u16, 32001u16, 32002u16];\n+        let mut v1 = vec![0u16, 0u16, 0u16];\n+\n+        copy_memory(v1.as_mut_ptr().offset(1),\n+                    v0.as_ptr().offset(1), 1);\n+        assert!((*v1.get(0) == 0u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 0u16));\n+        copy_memory(v1.as_mut_ptr(),\n+                    v0.as_ptr().offset(2), 1);\n+        assert!((*v1.get(0) == 32002u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 0u16));\n+        copy_memory(v1.as_mut_ptr().offset(2),\n+                    v0.as_ptr(), 1u);\n+        assert!((*v1.get(0) == 32002u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 32000u16));\n+    }\n+}\n+\n+#[test]\n+fn test_position() {\n+    use libc::c_char;\n+\n+    \"hello\".with_c_str(|p| {\n+        unsafe {\n+            assert!(2u == position(p, |c| *c == 'l' as c_char));\n+            assert!(4u == position(p, |c| *c == 'o' as c_char));\n+            assert!(5u == position(p, |c| *c == 0 as c_char));\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_buf_len() {\n+    \"hello\".with_c_str(|p0| {\n+        \"there\".with_c_str(|p1| {\n+            \"thing\".with_c_str(|p2| {\n+                let v = vec![p0, p1, p2, null()];\n+                unsafe {\n+                    assert_eq!(buf_len(v.as_ptr()), 3u);\n+                }\n+            })\n+        })\n+    })\n+}\n+\n+#[test]\n+fn test_is_null() {\n+    let p: *const int = null();\n+    assert!(p.is_null());\n+    assert!(!p.is_not_null());\n+\n+    let q = unsafe { p.offset(1) };\n+    assert!(!q.is_null());\n+    assert!(q.is_not_null());\n+\n+    let mp: *mut int = mut_null();\n+    assert!(mp.is_null());\n+    assert!(!mp.is_not_null());\n+\n+    let mq = unsafe { mp.offset(1) };\n+    assert!(!mq.is_null());\n+    assert!(mq.is_not_null());\n+}\n+\n+#[test]\n+fn test_to_option() {\n+    unsafe {\n+        let p: *const int = null();\n+        assert_eq!(p.to_option(), None);\n+\n+        let q: *const int = &2;\n+        assert_eq!(q.to_option().unwrap(), &2);\n+\n+        let p: *mut int = mut_null();\n+        assert_eq!(p.to_option(), None);\n+\n+        let q: *mut int = &mut 2;\n+        assert_eq!(q.to_option().unwrap(), &2);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_addition() {\n+    unsafe {\n+        let xs = Vec::from_elem(16, 5i);\n+        let mut ptr = xs.as_ptr();\n+        let end = ptr.offset(16);\n+\n+        while ptr < end {\n+            assert_eq!(*ptr, 5);\n+            ptr = ptr.offset(1);\n+        }\n+\n+        let mut xs_mut = xs;\n+        let mut m_ptr = xs_mut.as_mut_ptr();\n+        let m_end = m_ptr.offset(16);\n+\n+        while m_ptr < m_end {\n+            *m_ptr += 5;\n+            m_ptr = m_ptr.offset(1);\n+        }\n+\n+        assert!(xs_mut == Vec::from_elem(16, 10i));\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_subtraction() {\n+    unsafe {\n+        let xs = vec![0,1,2,3,4,5,6,7,8,9];\n+        let mut idx = 9i8;\n+        let ptr = xs.as_ptr();\n+\n+        while idx >= 0i8 {\n+            assert_eq!(*(ptr.offset(idx as int)), idx as int);\n+            idx = idx - 1i8;\n+        }\n+\n+        let mut xs_mut = xs;\n+        let m_start = xs_mut.as_mut_ptr();\n+        let mut m_ptr = m_start.offset(9);\n+\n+        while m_ptr >= m_start {\n+            *m_ptr += *m_ptr;\n+            m_ptr = m_ptr.offset(-1);\n+        }\n+\n+        assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_array_each_with_len() {\n+    unsafe {\n+        let one = \"oneOne\".to_c_str();\n+        let two = \"twoTwo\".to_c_str();\n+        let three = \"threeThree\".to_c_str();\n+        let arr = vec![\n+            one.as_ptr(),\n+            two.as_ptr(),\n+            three.as_ptr()\n+        ];\n+        let expected_arr = [\n+            one, two, three\n+        ];\n+\n+        let mut ctr = 0;\n+        let mut iteration_count = 0;\n+        array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n+                assert_eq!(actual.as_slice(), expected.as_slice());\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+        assert_eq!(iteration_count, 3u);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_array_each() {\n+    unsafe {\n+        let one = \"oneOne\".to_c_str();\n+        let two = \"twoTwo\".to_c_str();\n+        let three = \"threeThree\".to_c_str();\n+        let arr = vec![\n+            one.as_ptr(),\n+            two.as_ptr(),\n+            three.as_ptr(),\n+            // fake a null terminator\n+            null()\n+        ];\n+        let expected_arr = [\n+            one, two, three\n+        ];\n+\n+        let arr_ptr = arr.as_ptr();\n+        let mut ctr = 0u;\n+        let mut iteration_count = 0u;\n+        array_each(arr_ptr, |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n+                assert_eq!(actual.as_slice(), expected.as_slice());\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+        assert_eq!(iteration_count, 3);\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_ptr_array_each_with_len_null_ptr() {\n+    unsafe {\n+        array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n+            str::raw::from_c_str(e);\n+        });\n+    }\n+}\n+#[test]\n+#[should_fail]\n+fn test_ptr_array_each_null_ptr() {\n+    unsafe {\n+        array_each(0 as *const *const libc::c_char, |e| {\n+            str::raw::from_c_str(e);\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_set_memory() {\n+    let mut xs = [0u8, ..20];\n+    let ptr = xs.as_mut_ptr();\n+    unsafe { set_memory(ptr, 5u8, xs.len()); }\n+    assert!(xs == [5u8, ..20]);\n+}"}, {"sha": "f2c23c7c77327762e47e0fa49fa085bf3bc812fe", "filename": "src/libcoretest/raw.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fraw.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::raw::*;\n+use core::mem;\n+\n+#[test]\n+fn synthesize_closure() {\n+    unsafe {\n+        let x = 10;\n+        let f: |int| -> int = |y| x + y;\n+\n+        assert_eq!(f(20), 30);\n+\n+        let original_closure: Closure = mem::transmute(f);\n+\n+        let actual_function_pointer = original_closure.code;\n+        let environment = original_closure.env;\n+\n+        let new_closure = Closure {\n+            code: actual_function_pointer,\n+            env: environment\n+        };\n+\n+        let new_f: |int| -> int = mem::transmute(new_closure);\n+        assert_eq!(new_f(20), 30);\n+    }\n+}"}, {"sha": "7c7e0a542cd8729ac7c5298b34ba37cfc035983c", "filename": "src/libcoretest/result.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::result::{collect, fold, fold_};\n+use core::iter::range;\n+\n+pub fn op1() -> Result<int, &'static str> { Ok(666) }\n+pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n+\n+#[test]\n+pub fn test_and() {\n+    assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n+    assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n+               \"bad\");\n+\n+    assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n+    assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_and_then() {\n+    assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n+    assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+               \"bad\");\n+\n+    assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n+               \"sadface\");\n+    assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_or() {\n+    assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+    assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n+\n+    assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+    assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n+}\n+\n+#[test]\n+pub fn test_or_else() {\n+    assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n+\n+    assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n+    assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_impl_map() {\n+    assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n+    assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n+}\n+\n+#[test]\n+pub fn test_impl_map_err() {\n+    assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n+    assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n+    assert!(v == Ok(vec![]));\n+\n+    let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n+    assert!(v == Ok(vec![0, 1, 2]));\n+\n+    let v: Result<Vec<int>, int> = collect(range(0i, 3)\n+                                           .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+    assert!(v == Err(2));\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n+\n+    let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n+    assert!(v == Err(1));\n+}\n+\n+#[test]\n+fn test_fold() {\n+    assert_eq!(fold_(range(0i, 0)\n+                    .map(|_| Ok::<(), ()>(()))),\n+               Ok(()));\n+    assert_eq!(fold(range(0i, 3)\n+                    .map(|x| Ok::<int, ()>(x)),\n+                    0, |a, b| a + b),\n+               Ok(3));\n+    assert_eq!(fold_(range(0i, 3)\n+                    .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n+               Err(2));\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n+\n+    assert_eq!(fold_(functions.mut_iter()\n+                    .map(|f| (*f)())),\n+               Err(1));\n+}\n+\n+#[test]\n+pub fn test_fmt_default() {\n+    let ok: Result<int, &'static str> = Ok(100);\n+    let err: Result<int, &'static str> = Err(\"Err\");\n+\n+    let s = format!(\"{}\", ok);\n+    assert_eq!(s.as_slice(), \"Ok(100)\");\n+    let s = format!(\"{}\", err);\n+    assert_eq!(s.as_slice(), \"Err(Err)\");\n+}\n+\n+#[test]\n+pub fn test_unwrap_or() {\n+    let ok: Result<int, &'static str> = Ok(100i);\n+    let ok_err: Result<int, &'static str> = Err(\"Err\");\n+\n+    assert_eq!(ok.unwrap_or(50), 100);\n+    assert_eq!(ok_err.unwrap_or(50), 50);\n+}\n+\n+#[test]\n+pub fn test_unwrap_or_else() {\n+    fn handler(msg: &'static str) -> int {\n+        if msg == \"I got this.\" {\n+            50i\n+        } else {\n+            fail!(\"BadBad\")\n+        }\n+    }\n+\n+    let ok: Result<int, &'static str> = Ok(100);\n+    let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n+\n+    assert_eq!(ok.unwrap_or_else(handler), 100);\n+    assert_eq!(ok_err.unwrap_or_else(handler), 50);\n+}\n+\n+#[test]\n+#[should_fail]\n+pub fn test_unwrap_or_else_failure() {\n+    fn handler(msg: &'static str) -> int {\n+        if msg == \"I got this.\" {\n+            50i\n+        } else {\n+            fail!(\"BadBad\")\n+        }\n+    }\n+\n+    let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n+    let _ : int = bad_err.unwrap_or_else(handler);\n+}"}, {"sha": "be71e42ae9ad6561af273a2007dd1a218fd82f9a", "filename": "src/libcoretest/tuple.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn test_clone() {\n+    let a = (1i, \"2\");\n+    let b = a.clone();\n+    assert_eq!(a, b);\n+}\n+\n+#[test]\n+fn test_getters() {\n+    macro_rules! test_getter(\n+        ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n+         $init:expr, $incr:expr, $result:expr) => ({\n+            assert_eq!($x.$valN(), $init);\n+            assert_eq!(*$x.$refN(), $init);\n+            *$x.$mutN() += $incr;\n+            assert_eq!(*$x.$refN(), $result);\n+        })\n+    )\n+    let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n+    test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n+    test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n+    test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n+    test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n+    test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n+    test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n+    test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n+    test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n+    test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n+    test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n+    test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n+    test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n+}\n+\n+#[test]\n+fn test_tuple_cmp() {\n+    let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n+\n+    let nan = 0.0f64/0.0;\n+\n+    // PartialEq\n+    assert_eq!(small, small);\n+    assert_eq!(big, big);\n+    assert!(small != big);\n+    assert!(big != small);\n+\n+    // PartialOrd\n+    assert!(small < big);\n+    assert!(!(small < small));\n+    assert!(!(big < small));\n+    assert!(!(big < big));\n+\n+    assert!(small <= small);\n+    assert!(big <= big);\n+\n+    assert!(big > small);\n+    assert!(small >= small);\n+    assert!(big >= small);\n+    assert!(big >= big);\n+\n+    assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n+    assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n+    assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n+\n+    // Ord\n+    assert!(small.cmp(&small) == Equal);\n+    assert!(big.cmp(&big) == Equal);\n+    assert!(small.cmp(&big) == Less);\n+    assert!(big.cmp(&small) == Greater);\n+}\n+\n+#[test]\n+fn test_show() {\n+    let s = format!(\"{}\", (1i,));\n+    assert_eq!(s.as_slice(), \"(1,)\");\n+    let s = format!(\"{}\", (1i, true));\n+    assert_eq!(s.as_slice(), \"(1, true)\");\n+    let s = format!(\"{}\", (1i, \"hi\", true));\n+    assert_eq!(s.as_slice(), \"(1, hi, true)\");\n+}"}, {"sha": "0cbae6ee2d3a3910104fd851929655bb0857e713", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -28,7 +28,7 @@ use std::gc::Gc;\n  * as `TyVisitor`; then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);\n+    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8);\n     fn push_ptr(&mut self);\n     fn pop_ptr(&mut self);\n }\n@@ -51,12 +51,12 @@ impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n \n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)\n+        self.inner.move_ptr(|p| ((p as uint) + sz) as *const u8)\n     }\n \n     #[inline]\n     pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *u8)\n+        self.inner.move_ptr(|p| align(p as uint, a) as *const u8)\n     }\n \n     #[inline]\n@@ -202,43 +202,43 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<Gc<u8>>();\n         if ! self.inner.visit_box(mtbl, inner) { return false; }\n         self.bump_past::<Gc<u8>>();\n         true\n     }\n \n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<Box<u8>>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<Box<u8>>();\n         true\n     }\n \n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n+        self.align_to::<*const u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n+        self.bump_past::<*const u8>();\n         true\n     }\n \n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&'static u8>();\n         true\n     }\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&'static [u8]>();\n         true\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n+                        mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n             return false;\n@@ -254,7 +254,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n+                       mtbl: uint, inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n             return false;\n@@ -278,7 +278,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,\n-                         inner: *TyDesc) -> bool {\n+                         inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n             return false;\n@@ -301,7 +301,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_tup_field(i, inner) { return false; }\n         unsafe { self.bump((*inner).size); }\n@@ -321,12 +321,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, mode: uint,\n+                      inner: *const TyDesc) -> bool {\n         if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n+                       inner: *const TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n         true\n     }\n@@ -340,7 +342,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n         self.align(align);\n@@ -361,7 +363,8 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n+                                inner: *const TyDesc) -> bool {\n         self.inner.push_ptr();\n         self.bump(offset);\n         if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n@@ -381,7 +384,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n             return false;"}, {"sha": "133353ec3d717a09a9225a332d77ae0e5b61f55a", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -92,16 +92,16 @@ enum VariantState {\n }\n \n pub struct ReprVisitor<'a> {\n-    ptr: *u8,\n-    ptr_stk: Vec<*u8>,\n+    ptr: *const u8,\n+    ptr_stk: Vec<*const u8>,\n     var_stk: Vec<VariantState>,\n     writer: &'a mut io::Writer,\n     last_err: Option<io::IoError>,\n }\n \n impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n+    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&mut self) {\n@@ -114,7 +114,7 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n \n impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n-    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n+    pub fn new(ptr: *const u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n         ReprVisitor {\n             ptr: ptr,\n             ptr_stk: vec!(),\n@@ -128,18 +128,19 @@ impl<'a> ReprVisitor<'a> {\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n             let ptr = self.ptr;\n-            f(self, mem::transmute::<*u8,&T>(ptr))\n+            f(self, mem::transmute::<*const u8,&T>(ptr))\n         }\n     }\n \n     #[inline]\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n+    pub fn visit_inner(&mut self, inner: *const TyDesc) -> bool {\n         let ptr = self.ptr;\n         self.visit_ptr_inner(ptr, inner)\n     }\n \n     #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n+    pub fn visit_ptr_inner(&mut self, ptr: *const u8,\n+                           inner: *const TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor::new(ptr, mem::transmute_copy(&self.writer));\n             let mut v = reflect::MovePtrAdaptor::new(u);\n@@ -183,8 +184,9 @@ impl<'a> ReprVisitor<'a> {\n         true\n     }\n \n-    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n-        let mut p = ptr as *u8;\n+    pub fn write_vec_range(&mut self, ptr: *const (), len: uint,\n+                           inner: *const TyDesc) -> bool {\n+        let mut p = ptr as *const u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n         try!(self, self.writer.write(['[' as u8]));\n         let mut first = true;\n@@ -197,8 +199,8 @@ impl<'a> ReprVisitor<'a> {\n             } else {\n                 try!(self, self.writer.write(\", \".as_bytes()));\n             }\n-            self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n+            self.visit_ptr_inner(p as *const u8, inner);\n+            p = align(unsafe { p.offset(sz as int) as uint }, al) as *const u8;\n             left -= dec;\n         }\n         try!(self, self.writer.write([']' as u8]));\n@@ -276,40 +278,46 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { fail!(); }\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(\"box(GC) \".as_bytes()));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n-            let p = &b.data as *() as *u8;\n+            let p = &b.data as *const () as *const u8;\n             this.visit_ptr_inner(p, inner)\n         })\n     }\n \n-    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, _mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(\"box \".as_bytes()));\n-        self.get::<*u8>(|this, b| {\n+        self.get::<*const u8>(|this, b| {\n             this.visit_ptr_inner(*b, inner)\n         })\n     }\n \n-    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.get::<*u8>(|this, p| {\n+    fn visit_ptr(&mut self, mtbl: uint, _inner: *const TyDesc) -> bool {\n+        self.get::<*const u8>(|this, p| {\n             try!(this, write!(this.writer, \"({} as *\", *p));\n-            this.write_mut_qualifier(mtbl);\n+            if mtbl == 0 {\n+                try!(this, this.writer.write(\"mut \".as_bytes()));\n+            } else if mtbl == 1 {\n+                try!(this, this.writer.write(\"const \".as_bytes()));\n+            } else {\n+                fail!(\"invalid mutability value\");\n+            }\n             try!(this, this.writer.write(\"())\".as_bytes()));\n             true\n         })\n     }\n \n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(['&' as u8]));\n         self.write_mut_qualifier(mtbl);\n-        self.get::<*u8>(|this, p| {\n+        self.get::<*const u8>(|this, p| {\n             this.visit_ptr_inner(*p, inner)\n         })\n     }\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n             try!(this, this.writer.write(['&' as u8]));\n             this.write_mut_qualifier(mtbl);\n@@ -321,7 +329,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        _: uint, inner: *TyDesc) -> bool {\n+                        _: uint, inner: *const TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n             this.write_vec_range(b, assumed_size, inner)\n@@ -335,7 +343,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n+                       mtbl: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -366,7 +374,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n+                         _mtbl: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -396,7 +404,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         true\n     }\n \n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -415,7 +423,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_enum(&mut self,\n                         _n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint) -> bool {\n         let disr = unsafe {\n@@ -456,7 +464,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_enum_variant_field(&mut self,\n                                 i: uint,\n                                 _offset: uint,\n-                                inner: *TyDesc)\n+                                inner: *const TyDesc)\n                                 -> bool {\n         match *self.var_stk.get(self.var_stk.len() - 1) {\n             Matched => {\n@@ -489,7 +497,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {\n@@ -505,7 +513,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         true\n     }\n \n-    fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, _mode: uint,\n+                      inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -515,7 +524,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n-                       inner: *TyDesc) -> bool {\n+                       inner: *const TyDesc) -> bool {\n         if variadic {\n             try!(self, self.writer.write(\", ...\".as_bytes()));\n         }\n@@ -543,7 +552,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n-        let ptr = object as *T as *u8;\n+        let ptr = object as *const T as *const u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor::new(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor::new(u);\n@@ -579,22 +588,22 @@ fn test_repr() {\n         assert_eq!(s.as_slice(), e);\n     }\n \n-    exact_test(&10, \"10\");\n+    exact_test(&10i, \"10\");\n     exact_test(&true, \"true\");\n     exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.234f64\");\n+    exact_test(&1.234f64, \"1.234f64\");\n     exact_test(&(\"hello\"), \"\\\"hello\\\"\");\n \n-    exact_test(&(box(GC) 10), \"box(GC) 10\");\n-    exact_test(&(box 10), \"box 10\");\n-    exact_test(&(&10), \"&10\");\n-    let mut x = 10;\n+    exact_test(&(box(GC) 10i), \"box(GC) 10\");\n+    exact_test(&(box 10i), \"box 10\");\n+    exact_test(&(&10i), \"&10\");\n+    let mut x = 10i;\n     exact_test(&(&mut x), \"&mut 10\");\n \n-    exact_test(&(0 as *()), \"(0x0 as *())\");\n-    exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n+    exact_test(&(0i as *const()), \"(0x0 as *const ())\");\n+    exact_test(&(0i as *mut ()), \"(0x0 as *mut ())\");\n \n-    exact_test(&(1,), \"(1,)\");\n+    exact_test(&(1i,), \"(1,)\");\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n@@ -604,8 +613,8 @@ fn test_repr() {\n     exact_test(&(box P{a:10, b:1.234}),\n                \"box repr::P{a: 10, b: 1.234f64}\");\n \n-    exact_test(&(&[1, 2]), \"&[1, 2]\");\n-    exact_test(&(&mut [1, 2]), \"&mut [1, 2]\");\n+    exact_test(&(&[1i, 2i]), \"&[1, 2]\");\n+    exact_test(&(&mut [1i, 2i]), \"&mut [1, 2]\");\n \n     exact_test(&'\\'', \"'\\\\''\");\n     exact_test(&'\"', \"'\\\"'\");"}, {"sha": "d944818abc56ad3a4054aa87590448e4d4c1a9b5", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -38,18 +38,18 @@ use libc::{c_void, size_t, c_int};\n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n     /// Raw miniz compression function.\n-    fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n-                                      src_buf_len: size_t,\n-                                      pout_len: *mut size_t,\n-                                      flags: c_int)\n-                                      -> *mut c_void;\n+    fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+                                  src_buf_len: size_t,\n+                                  pout_len: *mut size_t,\n+                                  flags: c_int)\n+                                  -> *mut c_void;\n \n     /// Raw miniz decompression function.\n-    fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n-                                        src_buf_len: size_t,\n-                                        pout_len: *mut size_t,\n-                                        flags: c_int)\n-                                        -> *mut c_void;\n+    fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+                                    src_buf_len: size_t,\n+                                    pout_len: *mut size_t,\n+                                    flags: c_int)\n+                                    -> *mut c_void;\n }\n \n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n@@ -59,10 +59,10 @@ static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler\n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n-                                                     bytes.len() as size_t,\n-                                                     &mut outsz,\n-                                                     flags);\n+        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n+                                             bytes.len() as size_t,\n+                                             &mut outsz,\n+                                             flags);\n         if !res.is_null() {\n             Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n         } else {\n@@ -84,10 +84,10 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n-                                                       bytes.len() as size_t,\n-                                                       &mut outsz,\n-                                                       flags);\n+        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n+                                               bytes.len() as size_t,\n+                                               &mut outsz,\n+                                               flags);\n         if !res.is_null() {\n             Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n         } else {"}, {"sha": "00e6df9ffbbb2eab49343ac77ca144970fe07e07", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -370,7 +370,7 @@ impl Matches {\n }\n \n fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg[0] == '-' as u8\n+    arg.len() > 1 && arg.as_bytes()[0] == '-' as u8\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n@@ -553,7 +553,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         } else {\n             let mut names;\n             let mut i_arg = None;\n-            if cur.as_slice()[1] == '-' as u8 {\n+            if cur.as_bytes()[1] == '-' as u8 {\n                 let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {"}, {"sha": "bd19f19cec6b2f86a9a1beee94f87b60c3720eab", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::Collection;\n+use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n+use std::path::BytesContainer;\n use std::slice;\n \n // Note 1: It is not clear whether the flexibility of providing both\n@@ -61,6 +64,32 @@ impl<'a,T> MaybeOwnedVector<'a,T> {\n     }\n }\n \n+impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n+    fn eq(&self, other: &MaybeOwnedVector<T>) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n+\n+impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n+    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(&other.as_slice())\n+    }\n+}\n+\n+impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n+    fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl<'a, T: PartialEq, V: Vector<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n+    fn equiv(&self, other: &V) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n // The `Vector` trait is provided in the prelude and is implemented on\n // both `&'a [T]` and `Vec<T>`, so it makes sense to try to support it\n // seamlessly.  The other vector related traits from the prelude do\n@@ -108,6 +137,34 @@ impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n     }\n }\n \n+impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n+    fn clone(&self) -> MaybeOwnedVector<'a, T> {\n+        match *self {\n+            Growable(ref v) => Growable(v.to_owned()),\n+            Borrowed(v) => Borrowed(v)\n+        }\n+    }\n+}\n+\n+\n+impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n+    fn default() -> MaybeOwnedVector<'a, T> {\n+        Growable(Vec::new())\n+    }\n+}\n+\n+impl<'a, T> Collection for MaybeOwnedVector<'a, T> {\n+    fn len(&self) -> uint {\n+        self.as_slice().len()\n+    }\n+}\n+\n+impl<'a> BytesContainer for MaybeOwnedVector<'a, u8> {\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_slice()\n+    }\n+}\n+\n impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n     /// Convert `self` into a growable `Vec`, not making a copy if possible.\n     pub fn into_vec(self) -> Vec<T> {"}, {"sha": "8c60f3d9fe1dc19f3b83de676c20ce45f73fa27c", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -27,7 +27,7 @@ pub struct Context {\n     stack_bounds: Option<(uint, uint)>,\n }\n \n-pub type InitFn = extern \"C\" fn(uint, *(), *()) -> !;\n+pub type InitFn = extern \"C\" fn(uint, *mut (), *mut ()) -> !;\n \n impl Context {\n     pub fn empty() -> Context {\n@@ -49,7 +49,7 @@ impl Context {\n     pub fn new(init: InitFn, arg: uint, start: proc():Send,\n                stack: &mut Stack) -> Context {\n \n-        let sp: *uint = stack.end();\n+        let sp: *const uint = stack.end();\n         let sp: *mut uint = sp as *mut uint;\n         // Save and then immediately load the current context,\n         // which we will then modify to call the given function when restored\n@@ -66,7 +66,7 @@ impl Context {\n         // them in terms of the code running on them (and hopefully they don't\n         // overflow). Additionally, their coroutine stacks are listed as being\n         // zero-length, so that's how we detect what's what here.\n-        let stack_base: *uint = stack.start();\n+        let stack_base: *const uint = stack.start();\n         let bounds = if sp as uint == stack_base as uint {\n             None\n         } else {\n@@ -116,7 +116,7 @@ impl Context {\n \n #[link(name = \"context_switch\", kind = \"static\")]\n extern {\n-    fn rust_swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n+    fn rust_swap_registers(out_regs: *mut Registers, in_regs: *const Registers);\n }\n \n // Register contexts used in various architectures"}, {"sha": "1b34679b0a18a67a0857d39ee3ce5aaf68c23f0c", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -116,7 +116,7 @@\n //! extern crate green;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int {\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n //!     green::start(argc, argv, green::basic::event_loop, main)\n //! }\n //!\n@@ -135,7 +135,7 @@\n //! extern crate rustuv;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int {\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n //!     green::start(argc, argv, rustuv::event_loop, main)\n //! }\n //!\n@@ -267,7 +267,7 @@ macro_rules! green_start( ($f:ident) => (\n         extern crate rustuv;\n \n         #[start]\n-        fn start(argc: int, argv: **u8) -> int {\n+        fn start(argc: int, argv: *const *const u8) -> int {\n             green::start(argc, argv, rustuv::event_loop, super::$f)\n         }\n     }\n@@ -291,7 +291,7 @@ macro_rules! green_start( ($f:ident) => (\n ///\n /// The return value is used as the process return code. 0 on success, 101 on\n /// error.\n-pub fn start(argc: int, argv: **u8,\n+pub fn start(argc: int, argv: *const *const u8,\n              event_loop_factory: fn() -> Box<rtio::EventLoop + Send>,\n              main: proc():Send) -> int {\n     rt::init(argc, argv);"}, {"sha": "7603b0a8013c75d25ad7d3a15ae86c2c5bb580d1", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -611,13 +611,13 @@ impl Scheduler {\n     // old task as inputs.\n \n     pub fn change_task_context(mut ~self,\n-                               current_task: Box<GreenTask>,\n+                               mut current_task: Box<GreenTask>,\n                                mut next_task: Box<GreenTask>,\n                                f: |&mut Scheduler, Box<GreenTask>|)\n                                -> Box<GreenTask> {\n         let f_opaque = ClosureConverter::from_fn(f);\n \n-        let current_task_dupe = &*current_task as *GreenTask;\n+        let current_task_dupe = &mut *current_task as *mut GreenTask;\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n@@ -871,7 +871,7 @@ impl Scheduler {\n \n     // * Utility Functions\n \n-    pub fn sched_id(&self) -> uint { self as *Scheduler as uint }\n+    pub fn sched_id(&self) -> uint { self as *const Scheduler as uint }\n \n     pub fn run_cleanup_job(&mut self) {\n         let cleanup_job = self.cleanup_job.take_unwrap();\n@@ -1413,7 +1413,7 @@ mod test {\n \n             impl Drop for S {\n                 fn drop(&mut self) {\n-                    let _foo = box 0;\n+                    let _foo = box 0i;\n                 }\n             }\n "}, {"sha": "874ddbfe7ed0e3137775f4d219b2919834403e4f", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -32,7 +32,7 @@ impl Runtime for SimpleTask {\n         assert!(times == 1);\n \n         let me = &mut *self as *mut SimpleTask;\n-        let cur_dupe = &*cur_task as *Task;\n+        let cur_dupe = &mut *cur_task as *mut Task;\n         cur_task.put_runtime(self);\n         let task = BlockedTask::block(cur_task);\n "}, {"sha": "c4885edb7d3a776f63cb3df282c6c65f6ed36a13", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -78,14 +78,14 @@ impl Stack {\n     }\n \n     /// Point to the low end of the allocated stack\n-    pub fn start(&self) -> *uint {\n-        self.buf.data as *uint\n+    pub fn start(&self) -> *const uint {\n+        self.buf.data as *const uint\n     }\n \n     /// Point one uint beyond the high end of the allocated stack\n-    pub fn end(&self) -> *uint {\n+    pub fn end(&self) -> *const uint {\n         unsafe {\n-            self.buf.data.offset(self.buf.len as int) as *uint\n+            self.buf.data.offset(self.buf.len as int) as *const uint\n         }\n     }\n }\n@@ -168,8 +168,8 @@ fn max_cached_stacks() -> uint {\n }\n \n extern {\n-    fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n-                                    end: *libc::uintptr_t) -> libc::c_uint;\n+    fn rust_valgrind_stack_register(start: *const libc::uintptr_t,\n+                                    end: *const libc::uintptr_t) -> libc::c_uint;\n     fn rust_valgrind_stack_deregister(id: libc::c_uint);\n }\n "}, {"sha": "68a454233cf9a2ce7594568c97dc149ce2c00c5a", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -89,7 +89,7 @@ pub enum Home {\n ///\n /// The goal for having this weird-looking function is to reduce the number of\n /// allocations done on a green-task startup as much as possible.\n-extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n+extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n     // Acquire ownership of the `proc()`\n     let start: proc() = unsafe {\n         mem::transmute(raw::Procedure { code: code, env: env })\n@@ -256,7 +256,7 @@ impl GreenTask {\n     // context switches\n \n     pub fn as_uint(&self) -> uint {\n-        self as *GreenTask as uint\n+        self as *const GreenTask as uint\n     }\n \n     pub unsafe fn from_uint(val: uint) -> Box<GreenTask> {"}, {"sha": "6b2c39628fc88a52ac49e7928872b14d6ebe48db", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -77,12 +77,12 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n     if chars.next() != Some('x') {\n         return Some((i, \"Expected 'x'\".to_string()));\n     } i+=1;\n-    let mut d_len = 0;\n+    let mut d_len = 0i;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n     if chars.next() != Some('.') {\n         return Some((i, \"Expected '.'\".to_string()));\n     } i+=1;\n-    let mut f_len = 0;\n+    let mut f_len = 0i;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n     if d_len == 0 && f_len == 0 {\n         return Some((i, \"Expected digits before or after decimal \\\n@@ -92,7 +92,7 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n         return Some((i, \"Expected 'p'\".to_string()));\n     } i+=1;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    let mut e_len = 0;\n+    let mut e_len = 0i;\n     for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n     if e_len == 0 {\n         return Some((i, \"Expected exponent digits\".to_string()));"}, {"sha": "81e50889952ec2671e931604c50654d03e2dd996", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 222, "deletions": 195, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -369,14 +369,14 @@ pub mod types {\n \n                 pub struct glob_t {\n                     pub gl_pathc: size_t,\n-                    pub gl_pathv: **c_char,\n+                    pub gl_pathv: *mut *mut c_char,\n                     pub gl_offs:  size_t,\n \n-                    pub __unused1: *c_void,\n-                    pub __unused2: *c_void,\n-                    pub __unused3: *c_void,\n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n+                    pub __unused1: *mut c_void,\n+                    pub __unused2: *mut c_void,\n+                    pub __unused3: *mut c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -444,18 +444,18 @@ pub mod types {\n                     pub ai_addrlen: socklen_t,\n \n                     #[cfg(target_os = \"linux\")]\n-                    pub ai_addr: *sockaddr,\n+                    pub ai_addr: *mut sockaddr,\n \n                     #[cfg(target_os = \"linux\")]\n-                    pub ai_canonname: *c_char,\n+                    pub ai_canonname: *mut c_char,\n \n                     #[cfg(target_os = \"android\")]\n-                    pub ai_canonname: *c_char,\n+                    pub ai_canonname: *mut c_char,\n \n                     #[cfg(target_os = \"android\")]\n-                    pub ai_addr: *sockaddr,\n+                    pub ai_addr: *mut sockaddr,\n \n-                    pub ai_next: *addrinfo,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n@@ -755,15 +755,15 @@ pub mod types {\n                     pub __unused1: size_t,\n                     pub gl_offs:   size_t,\n                     pub __unused2: c_int,\n-                    pub gl_pathv:  **c_char,\n+                    pub gl_pathv:  *mut *mut c_char,\n \n-                    pub __unused3: *c_void,\n+                    pub __unused3: *mut c_void,\n \n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n-                    pub __unused6: *c_void,\n-                    pub __unused7: *c_void,\n-                    pub __unused8: *c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n+                    pub __unused6: *mut c_void,\n+                    pub __unused7: *mut c_void,\n+                    pub __unused8: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -834,9 +834,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: socklen_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n@@ -926,7 +926,7 @@ pub mod types {\n                     pub modtime: time_t,\n                 }\n \n-                pub type pthread_attr_t = *c_void;\n+                pub type pthread_attr_t = *mut c_void;\n             }\n             pub mod posix08 {\n             }\n@@ -1032,9 +1032,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: size_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n@@ -1146,8 +1146,8 @@ pub mod types {\n                 pub type LARGE_INTEGER = c_longlong;\n                 pub type PLARGE_INTEGER = *mut c_longlong;\n \n-                pub type LPCWSTR = *WCHAR;\n-                pub type LPCSTR = *CHAR;\n+                pub type LPCWSTR = *const WCHAR;\n+                pub type LPCSTR = *const CHAR;\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n@@ -1163,7 +1163,7 @@ pub mod types {\n                 pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n \n                 pub type LPVOID = *mut c_void;\n-                pub type LPCVOID = *c_void;\n+                pub type LPCVOID = *const c_void;\n                 pub type LPBYTE = *mut BYTE;\n                 pub type LPWORD = *mut WORD;\n                 pub type LPDWORD = *mut DWORD;\n@@ -1235,8 +1235,8 @@ pub mod types {\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n \n                 pub struct OVERLAPPED {\n-                    pub Internal: *c_ulong,\n-                    pub InternalHigh: *c_ulong,\n+                    pub Internal: *mut c_ulong,\n+                    pub InternalHigh: *mut c_ulong,\n                     pub Offset: DWORD,\n                     pub OffsetHigh: DWORD,\n                     pub hEvent: HANDLE,\n@@ -1312,15 +1312,15 @@ pub mod types {\n                     pub __unused1: c_int,\n                     pub gl_offs:   size_t,\n                     pub __unused2: c_int,\n-                    pub gl_pathv:  **c_char,\n+                    pub gl_pathv:  *mut *mut c_char,\n \n-                    pub __unused3: *c_void,\n+                    pub __unused3: *mut c_void,\n \n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n-                    pub __unused6: *c_void,\n-                    pub __unused7: *c_void,\n-                    pub __unused8: *c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n+                    pub __unused6: *mut c_void,\n+                    pub __unused7: *mut c_void,\n+                    pub __unused8: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -1392,9 +1392,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: socklen_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n@@ -3543,53 +3543,56 @@ pub mod funcs {\n             use types::os::arch::c95::{c_char, c_int, c_long, size_t};\n \n             extern {\n-                pub fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n-                pub fn freopen(filename: *c_char, mode: *c_char, file: *FILE)\n-                               -> *FILE;\n-                pub fn fflush(file: *FILE) -> c_int;\n-                pub fn fclose(file: *FILE) -> c_int;\n-                pub fn remove(filename: *c_char) -> c_int;\n-                pub fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n-                pub fn tmpfile() -> *FILE;\n-                pub fn setvbuf(stream: *FILE,\n-                               buffer: *c_char,\n+                pub fn fopen(filename: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n+                pub fn freopen(filename: *const c_char, mode: *const c_char,\n+                               file: *mut FILE)\n+                               -> *mut FILE;\n+                pub fn fflush(file: *mut FILE) -> c_int;\n+                pub fn fclose(file: *mut FILE) -> c_int;\n+                pub fn remove(filename: *const c_char) -> c_int;\n+                pub fn rename(oldname: *const c_char,\n+                              newname: *const c_char) -> c_int;\n+                pub fn tmpfile() -> *mut FILE;\n+                pub fn setvbuf(stream: *mut FILE,\n+                               buffer: *mut c_char,\n                                mode: c_int,\n                                size: size_t)\n                                -> c_int;\n-                pub fn setbuf(stream: *FILE, buf: *c_char);\n+                pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n                 // Omitted: printf and scanf variants.\n-                pub fn fgetc(stream: *FILE) -> c_int;\n-                pub fn fgets(buf: *mut c_char, n: c_int, stream: *FILE)\n-                             -> *c_char;\n-                pub fn fputc(c: c_int, stream: *FILE) -> c_int;\n-                pub fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n+                pub fn fgetc(stream: *mut FILE) -> c_int;\n+                pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)\n+                             -> *mut c_char;\n+                pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n+                pub fn fputs(s: *const c_char, stream: *mut FILE)-> c_int;\n                 // Omitted: getc, getchar (might be macros).\n \n                 // Omitted: gets, so ridiculously unsafe that it should not\n                 // survive.\n \n                 // Omitted: putc, putchar (might be macros).\n-                pub fn puts(s: *c_char) -> c_int;\n-                pub fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+                pub fn puts(s: *const c_char) -> c_int;\n+                pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n                 pub fn fread(ptr: *mut c_void,\n                              size: size_t,\n                              nobj: size_t,\n-                             stream: *FILE)\n+                             stream: *mut FILE)\n                              -> size_t;\n-                pub fn fwrite(ptr: *c_void,\n+                pub fn fwrite(ptr: *const c_void,\n                               size: size_t,\n                               nobj: size_t,\n-                              stream: *FILE)\n+                              stream: *mut FILE)\n                               -> size_t;\n-                pub fn fseek(stream: *FILE, offset: c_long, whence: c_int)\n+                pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int)\n                              -> c_int;\n-                pub fn ftell(stream: *FILE) -> c_long;\n-                pub fn rewind(stream: *FILE);\n-                pub fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-                pub fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-                pub fn feof(stream: *FILE) -> c_int;\n-                pub fn ferror(stream: *FILE) -> c_int;\n-                pub fn perror(s: *c_char);\n+                pub fn ftell(stream: *mut FILE) -> c_long;\n+                pub fn rewind(stream: *mut FILE);\n+                pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+                pub fn fsetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+                pub fn feof(stream: *mut FILE) -> c_int;\n+                pub fn ferror(stream: *mut FILE) -> c_int;\n+                pub fn perror(s: *const c_char);\n             }\n         }\n \n@@ -3603,22 +3606,23 @@ pub mod funcs {\n                 pub fn abs(i: c_int) -> c_int;\n                 pub fn labs(i: c_long) -> c_long;\n                 // Omitted: div, ldiv (return pub type incomplete).\n-                pub fn atof(s: *c_char) -> c_double;\n-                pub fn atoi(s: *c_char) -> c_int;\n-                pub fn strtod(s: *c_char, endp: **c_char) -> c_double;\n-                pub fn strtol(s: *c_char, endp: **c_char, base: c_int)\n-                              -> c_long;\n-                pub fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n-                               -> c_ulong;\n-                pub fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+                pub fn atof(s: *const c_char) -> c_double;\n+                pub fn atoi(s: *const c_char) -> c_int;\n+                pub fn strtod(s: *const c_char,\n+                              endp: *mut *mut c_char) -> c_double;\n+                pub fn strtol(s: *const c_char,\n+                              endp: *mut *mut c_char, base: c_int) -> c_long;\n+                pub fn strtoul(s: *const c_char, endp: *mut *mut c_char,\n+                               base: c_int) -> c_ulong;\n+                pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n                 pub fn malloc(size: size_t) -> *mut c_void;\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n                 pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n                 pub fn _exit(status: c_int) -> !;\n                 // Omitted: atexit.\n-                pub fn system(s: *c_char) -> c_int;\n-                pub fn getenv(s: *c_char) -> *c_char;\n+                pub fn system(s: *const c_char) -> c_int;\n+                pub fn getenv(s: *const c_char) -> *mut c_char;\n                 // Omitted: bsearch, qsort\n                 pub fn rand() -> c_int;\n                 pub fn srand(seed: c_uint);\n@@ -3631,32 +3635,40 @@ pub mod funcs {\n             use types::os::arch::c95::{wchar_t};\n \n             extern {\n-                pub fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n-                pub fn strncpy(dst: *c_char, src: *c_char, n: size_t)\n-                               -> *c_char;\n-                pub fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;\n-                pub fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n-                pub fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;\n-                pub fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n-                pub fn strchr(cs: *c_char, c: c_int) -> *c_char;\n-                pub fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n-                pub fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n-                pub fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n-                pub fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strlen(cs: *c_char) -> size_t;\n-                pub fn strerror(n: c_int) -> *c_char;\n-                pub fn strtok(s: *c_char, t: *c_char) -> *c_char;\n-                pub fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;\n-                pub fn wcslen(buf: *wchar_t) -> size_t;\n+                pub fn strcpy(dst: *mut c_char,\n+                              src: *const c_char) -> *mut c_char;\n+                pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t)\n+                               -> *mut c_char;\n+                pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n+                pub fn strncat(s: *mut c_char, ct: *const c_char,\n+                               n: size_t) -> *mut c_char;\n+                pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n+                pub fn strncmp(cs: *const c_char, ct: *const c_char,\n+                               n: size_t) -> c_int;\n+                pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n+                pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+                pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+                pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+                pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+                pub fn strpbrk(cs: *const c_char,\n+                               ct: *const c_char) -> *mut c_char;\n+                pub fn strstr(cs: *const c_char,\n+                              ct: *const c_char) -> *mut c_char;\n+                pub fn strlen(cs: *const c_char) -> size_t;\n+                pub fn strerror(n: c_int) -> *mut c_char;\n+                pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n+                pub fn strxfrm(s: *mut c_char, ct: *const c_char,\n+                               n: size_t) -> size_t;\n+                pub fn wcslen(buf: *const wchar_t) -> size_t;\n \n                 // Omitted: memcpy, memmove, memset (provided by LLVM)\n \n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n-                pub fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n-                pub fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n+                pub fn memcmp(cx: *const c_void, ct: *const c_void,\n+                              n: size_t) -> c_int;\n+                pub fn memchr(cx: *const c_void, c: c_int,\n+                              n: size_t) -> *mut c_void;\n             }\n         }\n     }\n@@ -3675,21 +3687,21 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_chmod\"]\n-                pub fn chmod(path: *c_char, mode: c_int) -> c_int;\n+                pub fn chmod(path: *const c_char, mode: c_int) -> c_int;\n                 #[link_name = \"_wchmod\"]\n-                pub fn wchmod(path: *wchar_t, mode: c_int) -> c_int;\n+                pub fn wchmod(path: *const wchar_t, mode: c_int) -> c_int;\n                 #[link_name = \"_mkdir\"]\n-                pub fn mkdir(path: *c_char) -> c_int;\n+                pub fn mkdir(path: *const c_char) -> c_int;\n                 #[link_name = \"_wrmdir\"]\n-                pub fn wrmdir(path: *wchar_t) -> c_int;\n+                pub fn wrmdir(path: *const wchar_t) -> c_int;\n                 #[link_name = \"_fstat64\"]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n                 #[link_name = \"_stat64\"]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n                 #[link_name = \"_wstat64\"]\n-                pub fn wstat(path: *wchar_t, buf: *mut stat) -> c_int;\n+                pub fn wstat(path: *const wchar_t, buf: *mut stat) -> c_int;\n                 #[link_name = \"_wutime64\"]\n-                pub fn wutime(file: *wchar_t, buf: *utimbuf) -> c_int;\n+                pub fn wutime(file: *const wchar_t, buf: *mut utimbuf) -> c_int;\n             }\n         }\n \n@@ -3699,27 +3711,28 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_popen\"]\n-                pub fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+                pub fn popen(command: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n                 #[link_name = \"_pclose\"]\n-                pub fn pclose(stream: *FILE) -> c_int;\n+                pub fn pclose(stream: *mut FILE) -> c_int;\n                 #[link_name = \"_fdopen\"]\n-                pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+                pub fn fdopen(fd: c_int, mode: *const c_char) -> *mut FILE;\n                 #[link_name = \"_fileno\"]\n-                pub fn fileno(stream: *FILE) -> c_int;\n+                pub fn fileno(stream: *mut FILE) -> c_int;\n             }\n         }\n \n         pub mod fcntl {\n             use types::os::arch::c95::{c_int, c_char, wchar_t};\n             extern {\n                 #[link_name = \"_open\"]\n-                pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                pub fn open(path: *const c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 #[link_name = \"_wopen\"]\n-                pub fn wopen(path: *wchar_t, oflag: c_int, mode: c_int)\n+                pub fn wopen(path: *const wchar_t, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 #[link_name = \"_creat\"]\n-                pub fn creat(path: *c_char, mode: c_int) -> c_int;\n+                pub fn creat(path: *const c_char, mode: c_int) -> c_int;\n             }\n         }\n \n@@ -3735,27 +3748,30 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_access\"]\n-                pub fn access(path: *c_char, amode: c_int) -> c_int;\n+                pub fn access(path: *const c_char, amode: c_int) -> c_int;\n                 #[link_name = \"_chdir\"]\n-                pub fn chdir(dir: *c_char) -> c_int;\n+                pub fn chdir(dir: *const c_char) -> c_int;\n                 #[link_name = \"_close\"]\n                 pub fn close(fd: c_int) -> c_int;\n                 #[link_name = \"_dup\"]\n                 pub fn dup(fd: c_int) -> c_int;\n                 #[link_name = \"_dup2\"]\n                 pub fn dup2(src: c_int, dst: c_int) -> c_int;\n                 #[link_name = \"_execv\"]\n-                pub fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n+                pub fn execv(prog: *const c_char,\n+                             argv: *mut *const c_char) -> intptr_t;\n                 #[link_name = \"_execve\"]\n-                pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n+                pub fn execve(prog: *const c_char, argv: *mut *const c_char,\n+                              envp: *mut *const c_char)\n                               -> c_int;\n                 #[link_name = \"_execvp\"]\n-                pub fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                pub fn execvp(c: *const c_char,\n+                              argv: *mut *const c_char) -> c_int;\n                 #[link_name = \"_execvpe\"]\n-                pub fn execvpe(c: *c_char, argv: **c_char, envp: **c_char)\n-                               -> c_int;\n+                pub fn execvpe(c: *const c_char, argv: *mut *const c_char,\n+                               envp: *mut *const c_char) -> c_int;\n                 #[link_name = \"_getcwd\"]\n-                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;\n                 #[link_name = \"_getpid\"]\n                 pub fn getpid() -> c_int;\n                 #[link_name = \"_isatty\"]\n@@ -3770,11 +3786,12 @@ pub mod funcs {\n                 pub fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n                             -> c_int;\n                 #[link_name = \"_rmdir\"]\n-                pub fn rmdir(path: *c_char) -> c_int;\n+                pub fn rmdir(path: *const c_char) -> c_int;\n                 #[link_name = \"_unlink\"]\n-                pub fn unlink(c: *c_char) -> c_int;\n+                pub fn unlink(c: *const c_char) -> c_int;\n                 #[link_name = \"_write\"]\n-                pub fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n+                pub fn write(fd: c_int, buf: *const c_void,\n+                             count: c_uint) -> c_int;\n             }\n         }\n \n@@ -3795,7 +3812,7 @@ pub mod funcs {\n             use types::os::arch::posix88::mode_t;\n \n             extern {\n-                pub fn chmod(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn chmod(path: *const c_char, mode: mode_t) -> c_int;\n                 pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n \n                 #[cfg(target_os = \"linux\")]\n@@ -3808,18 +3825,18 @@ pub mod funcs {\n                 #[link_name = \"fstat64\"]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n-                pub fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n-                pub fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn mkdir(path: *const c_char, mode: mode_t) -> c_int;\n+                pub fn mkfifo(path: *const c_char, mode: mode_t) -> c_int;\n \n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n                 #[cfg(target_os = \"ios\")]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n                 #[link_name = \"stat64\"]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n             }\n         }\n \n@@ -3828,10 +3845,11 @@ pub mod funcs {\n             use types::os::arch::c95::{c_char, c_int};\n \n             extern {\n-                pub fn popen(command: *c_char, mode: *c_char) -> *FILE;\n-                pub fn pclose(stream: *FILE) -> c_int;\n-                pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n-                pub fn fileno(stream: *FILE) -> c_int;\n+                pub fn popen(command: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n+                pub fn pclose(stream: *mut FILE) -> c_int;\n+                pub fn fdopen(fd: c_int, mode: *const c_char) -> *mut FILE;\n+                pub fn fileno(stream: *mut FILE) -> c_int;\n             }\n         }\n \n@@ -3840,9 +3858,9 @@ pub mod funcs {\n             use types::os::arch::posix88::mode_t;\n \n             extern {\n-                pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                pub fn open(path: *const c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n-                pub fn creat(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn creat(path: *const c_char, mode: mode_t) -> c_int;\n                 pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;\n             }\n         }\n@@ -3860,17 +3878,17 @@ pub mod funcs {\n \n             extern {\n                 #[link_name=\"rust_opendir\"]\n-                pub fn opendir(dirname: *c_char) -> *DIR;\n+                pub fn opendir(dirname: *const c_char) -> *mut DIR;\n                 #[link_name=\"rust_readdir_r\"]\n-                pub fn readdir_r(dirp: *DIR, entry: *mut dirent_t,\n+                pub fn readdir_r(dirp: *mut DIR, entry: *mut dirent_t,\n                                   result: *mut *mut dirent_t) -> c_int;\n             }\n \n             extern {\n-                pub fn closedir(dirp: *DIR) -> c_int;\n-                pub fn rewinddir(dirp: *DIR);\n-                pub fn seekdir(dirp: *DIR, loc: c_long);\n-                pub fn telldir(dirp: *DIR) -> c_long;\n+                pub fn closedir(dirp: *mut DIR) -> c_int;\n+                pub fn rewinddir(dirp: *mut DIR);\n+                pub fn seekdir(dirp: *mut DIR, loc: c_long);\n+                pub fn telldir(dirp: *mut DIR) -> c_long;\n             }\n         }\n \n@@ -3886,60 +3904,65 @@ pub mod funcs {\n             pub static _PC_NAME_MAX: c_int = 4;\n \n             extern {\n-                pub fn access(path: *c_char, amode: c_int) -> c_int;\n+                pub fn access(path: *const c_char, amode: c_int) -> c_int;\n                 pub fn alarm(seconds: c_uint) -> c_uint;\n-                pub fn chdir(dir: *c_char) -> c_int;\n-                pub fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;\n+                pub fn chdir(dir: *const c_char) -> c_int;\n+                pub fn chown(path: *const c_char, uid: uid_t,\n+                             gid: gid_t) -> c_int;\n                 pub fn close(fd: c_int) -> c_int;\n                 pub fn dup(fd: c_int) -> c_int;\n                 pub fn dup2(src: c_int, dst: c_int) -> c_int;\n-                pub fn execv(prog: *c_char, argv: **c_char) -> c_int;\n-                pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n+                pub fn execv(prog: *const c_char,\n+                             argv: *mut *const c_char) -> c_int;\n+                pub fn execve(prog: *const c_char, argv: *mut *const c_char,\n+                              envp: *mut *const c_char)\n                               -> c_int;\n-                pub fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                pub fn execvp(c: *const c_char,\n+                              argv: *mut *const c_char) -> c_int;\n                 pub fn fork() -> pid_t;\n                 pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n-                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;\n                 pub fn getegid() -> gid_t;\n                 pub fn geteuid() -> uid_t;\n                 pub fn getgid() -> gid_t ;\n                 pub fn getgroups(ngroups_max: c_int, groups: *mut gid_t)\n                                  -> c_int;\n-                pub fn getlogin() -> *c_char;\n-                pub fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)\n-                              -> c_int;\n+                pub fn getlogin() -> *mut c_char;\n+                pub fn getopt(argc: c_int, argv: *mut *const c_char,\n+                              optstr: *const c_char) -> c_int;\n                 pub fn getpgrp() -> pid_t;\n                 pub fn getpid() -> pid_t;\n                 pub fn getppid() -> pid_t;\n                 pub fn getuid() -> uid_t;\n                 pub fn isatty(fd: c_int) -> c_int;\n-                pub fn link(src: *c_char, dst: *c_char) -> c_int;\n+                pub fn link(src: *const c_char, dst: *const c_char) -> c_int;\n                 pub fn lseek(fd: c_int, offset: off_t, whence: c_int)\n                              -> off_t;\n-                pub fn pathconf(path: *c_char, name: c_int) -> c_long;\n+                pub fn pathconf(path: *mut c_char, name: c_int) -> c_long;\n                 pub fn pause() -> c_int;\n                 pub fn pipe(fds: *mut c_int) -> c_int;\n                 pub fn read(fd: c_int, buf: *mut c_void, count: size_t)\n                             -> ssize_t;\n-                pub fn rmdir(path: *c_char) -> c_int;\n+                pub fn rmdir(path: *const c_char) -> c_int;\n                 pub fn setgid(gid: gid_t) -> c_int;\n                 pub fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n                 pub fn setsid() -> pid_t;\n                 pub fn setuid(uid: uid_t) -> c_int;\n                 pub fn sleep(secs: c_uint) -> c_uint;\n                 pub fn usleep(secs: c_uint) -> c_int;\n-                pub fn nanosleep(rqtp: *timespec, rmtp: *mut timespec) -> c_int;\n+                pub fn nanosleep(rqtp: *const timespec,\n+                                 rmtp: *mut timespec) -> c_int;\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n-                pub fn ttyname(fd: c_int) -> *c_char;\n-                pub fn unlink(c: *c_char) -> c_int;\n-                pub fn write(fd: c_int, buf: *c_void, count: size_t)\n+                pub fn ttyname(fd: c_int) -> *mut c_char;\n+                pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n-                pub fn pread(fd: c_int, buf: *c_void, count: size_t,\n+                pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,\n                              offset: off_t) -> ssize_t;\n-                pub fn pwrite(fd: c_int, buf: *c_void, count: size_t,\n+                pub fn pwrite(fd: c_int, buf: *const c_void, count: size_t,\n                               offset: off_t) -> ssize_t;\n-                pub fn utime(file: *c_char, buf: *utimbuf) -> c_int;\n+                pub fn utime(file: *const c_char, buf: *const utimbuf) -> c_int;\n             }\n         }\n \n@@ -3958,8 +3981,8 @@ pub mod funcs {\n             use types::os::arch::posix88::{mode_t, off_t};\n \n             extern {\n-                pub fn mlock(addr: *c_void, len: size_t) -> c_int;\n-                pub fn munlock(addr: *c_void, len: size_t) -> c_int;\n+                pub fn mlock(addr: *const c_void, len: size_t) -> c_int;\n+                pub fn munlock(addr: *const c_void, len: size_t) -> c_int;\n                 pub fn mlockall(flags: c_int) -> c_int;\n                 pub fn munlockall() -> c_int;\n \n@@ -3977,9 +4000,9 @@ pub mod funcs {\n \n                 pub fn msync(addr: *mut c_void, len: size_t, flags: c_int)\n                              -> c_int;\n-                pub fn shm_open(name: *c_char, oflag: c_int, mode: mode_t)\n+                pub fn shm_open(name: *const c_char, oflag: c_int, mode: mode_t)\n                                 -> c_int;\n-                pub fn shm_unlink(name: *c_char) -> c_int;\n+                pub fn shm_unlink(name: *const c_char) -> c_int;\n             }\n         }\n     }\n@@ -3999,11 +4022,11 @@ pub mod funcs {\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n                 #[cfg(target_os = \"ios\")]\n-                pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n                 #[link_name = \"lstat64\"]\n-                pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;\n             }\n         }\n \n@@ -4012,7 +4035,7 @@ pub mod funcs {\n             use types::os::arch::posix88::{ssize_t, off_t};\n \n             extern {\n-                pub fn readlink(path: *c_char,\n+                pub fn readlink(path: *const c_char,\n                                 buf: *mut c_char,\n                                 bufsz: size_t)\n                                 -> ssize_t;\n@@ -4023,12 +4046,13 @@ pub mod funcs {\n                 #[cfg(target_os = \"android\")]\n                 pub fn fdatasync(fd: c_int) -> c_int;\n \n-                pub fn setenv(name: *c_char, val: *c_char, overwrite: c_int)\n-                              -> c_int;\n-                pub fn unsetenv(name: *c_char) -> c_int;\n-                pub fn putenv(string: *c_char) -> c_int;\n+                pub fn setenv(name: *const c_char, val: *const c_char,\n+                              overwrite: c_int) -> c_int;\n+                pub fn unsetenv(name: *const c_char) -> c_int;\n+                pub fn putenv(string: *mut c_char) -> c_int;\n \n-                pub fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+                pub fn symlink(path1: *const c_char,\n+                               path2: *const c_char) -> c_int;\n \n                 pub fn ftruncate(fd: c_int, length: off_t) -> c_int;\n             }\n@@ -4057,9 +4081,10 @@ pub mod funcs {\n             use types::os::common::posix01::{glob_t};\n \n             extern {\n-                pub fn glob(pattern: *c_char,\n+                pub fn glob(pattern: *const c_char,\n                             flags: c_int,\n-                            errfunc: ::Nullable<extern \"C\" fn(epath: *c_char, errno: int) -> int>,\n+                            errfunc: ::Nullable<extern \"C\" fn(epath: *const c_char,\n+                                                              errno: int) -> int>,\n                             pglob: *mut glob_t);\n                 pub fn globfree(pglob: *mut glob_t);\n             }\n@@ -4070,7 +4095,7 @@ pub mod funcs {\n             use types::os::arch::c95::{c_int, size_t};\n \n             extern {\n-                pub fn posix_madvise(addr: *c_void,\n+                pub fn posix_madvise(addr: *mut c_void,\n                                      len: size_t,\n                                      advice: c_int)\n                                      -> c_int;\n@@ -4114,9 +4139,9 @@ pub mod funcs {\n \n         extern \"system\" {\n             pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;\n-            pub fn connect(socket: c_int, address: *sockaddr,\n+            pub fn connect(socket: c_int, address: *const sockaddr,\n                            len: socklen_t) -> c_int;\n-            pub fn bind(socket: c_int, address: *sockaddr,\n+            pub fn bind(socket: c_int, address: *const sockaddr,\n                         address_len: socklen_t) -> c_int;\n             pub fn listen(socket: c_int, backlog: c_int) -> c_int;\n             pub fn accept(socket: c_int, address: *mut sockaddr,\n@@ -4126,16 +4151,17 @@ pub mod funcs {\n             pub fn getsockname(socket: c_int, address: *mut sockaddr,\n                                address_len: *mut socklen_t) -> c_int;\n             pub fn setsockopt(socket: c_int, level: c_int, name: c_int,\n-                              value: *c_void, option_len: socklen_t) -> c_int;\n+                              value: *const c_void,\n+                              option_len: socklen_t) -> c_int;\n             pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,\n                         flags: c_int) -> ssize_t;\n             pub fn send(socket: c_int, buf: *mut c_void, len: size_t,\n                         flags: c_int) -> ssize_t;\n             pub fn recvfrom(socket: c_int, buf: *mut c_void, len: size_t,\n                             flags: c_int, addr: *mut sockaddr,\n                             addrlen: *mut socklen_t) -> ssize_t;\n-            pub fn sendto(socket: c_int, buf: *c_void, len: size_t,\n-                          flags: c_int, addr: *sockaddr,\n+            pub fn sendto(socket: c_int, buf: *const c_void, len: size_t,\n+                          flags: c_int, addr: *const sockaddr,\n                           addrlen: socklen_t) -> ssize_t;\n             pub fn shutdown(socket: c_int, how: c_int) -> c_int;\n         }\n@@ -4150,9 +4176,9 @@ pub mod funcs {\n \n         extern \"system\" {\n             pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;\n-            pub fn connect(socket: SOCKET, address: *sockaddr,\n+            pub fn connect(socket: SOCKET, address: *const sockaddr,\n                            len: socklen_t) -> c_int;\n-            pub fn bind(socket: SOCKET, address: *sockaddr,\n+            pub fn bind(socket: SOCKET, address: *const sockaddr,\n                         address_len: socklen_t) -> c_int;\n             pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n             pub fn accept(socket: SOCKET, address: *mut sockaddr,\n@@ -4162,7 +4188,8 @@ pub mod funcs {\n             pub fn getsockname(socket: SOCKET, address: *mut sockaddr,\n                                address_len: *mut socklen_t) -> c_int;\n             pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,\n-                              value: *c_void, option_len: socklen_t) -> c_int;\n+                              value: *const c_void,\n+                              option_len: socklen_t) -> c_int;\n             pub fn closesocket(socket: SOCKET) -> c_int;\n             pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n                         flags: c_int) -> c_int;\n@@ -4171,8 +4198,8 @@ pub mod funcs {\n             pub fn recvfrom(socket: SOCKET, buf: *mut c_void, len: c_int,\n                             flags: c_int, addr: *mut sockaddr,\n                             addrlen: *mut c_int) -> ssize_t;\n-            pub fn sendto(socket: SOCKET, buf: *c_void, len: c_int,\n-                          flags: c_int, addr: *sockaddr,\n+            pub fn sendto(socket: SOCKET, buf: *const c_void, len: c_int,\n+                          flags: c_int, addr: *const sockaddr,\n                           addrlen: c_int) -> c_int;\n             pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n         }\n@@ -4186,27 +4213,27 @@ pub mod funcs {\n         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, size_t};\n \n         extern {\n-            pub fn sysctl(name: *c_int,\n+            pub fn sysctl(name: *mut c_int,\n                           namelen: c_uint,\n                           oldp: *mut c_void,\n                           oldlenp: *mut size_t,\n-                          newp: *c_void,\n+                          newp: *mut c_void,\n                           newlen: size_t)\n                           -> c_int;\n-            pub fn sysctlbyname(name: *c_char,\n+            pub fn sysctlbyname(name: *const c_char,\n                                 oldp: *mut c_void,\n                                 oldlenp: *mut size_t,\n-                                newp: *c_void,\n+                                newp: *mut c_void,\n                                 newlen: size_t)\n                                 -> c_int;\n-            pub fn sysctlnametomib(name: *c_char,\n+            pub fn sysctlnametomib(name: *const c_char,\n                                    mibp: *mut c_int,\n                                    sizep: *mut size_t)\n                                    -> c_int;\n             pub fn getdtablesize() -> c_int;\n-            pub fn madvise(addr: *c_void, len: size_t, advice: c_int)\n+            pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int)\n                            -> c_int;\n-            pub fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)\n+            pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar)\n                            -> c_int;\n         }\n     }\n@@ -4298,7 +4325,7 @@ pub mod funcs {\n                                             -> DWORD;\n                 pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n                 pub fn GetLastError() -> DWORD;\n-                pub fn FindFirstFileW(fileName: *u16, findFileData: HANDLE)\n+                pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: HANDLE)\n                                       -> HANDLE;\n                 pub fn FindNextFileW(findFile: HANDLE, findFileData: HANDLE)\n                                      -> BOOL;"}, {"sha": "b99a9d75f33e52014c4e78cfa377dbb46b51420d", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -144,8 +144,8 @@ static DEFAULT_LOG_LEVEL: u32 = 1;\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *Vec<directive::LogDirective> =\n-    0 as *Vec<directive::LogDirective>;\n+static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n+    0 as *const Vec<directive::LogDirective>;\n \n /// Debug log level\n pub static DEBUG: u32 = 4;\n@@ -351,7 +351,7 @@ fn init() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 0 as *Vec<directive::LogDirective>;\n+            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n         });\n     }\n }"}, {"sha": "0977b55d8b9780d437f385fb473e1ecf49997943", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -37,19 +37,21 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: null(),\n-                ai_addr: null(),\n-                ai_next: null()\n+                ai_canonname: mut_null(),\n+                ai_addr: mut_null(),\n+                ai_next: mut_null()\n             }\n         });\n \n-        let hint_ptr = hint.as_ref().map_or(null(), |x| x as *libc::addrinfo);\n+        let hint_ptr = hint.as_ref().map_or(null(), |x| {\n+            x as *const libc::addrinfo\n+        });\n         let mut res = mut_null();\n \n         // Make the call\n         let s = unsafe {\n-            let ch = if c_host.is_null() { null() } else { c_host.with_ref(|x| x) };\n-            let cs = if c_serv.is_null() { null() } else { c_serv.with_ref(|x| x) };\n+            let ch = if c_host.is_null() { null() } else { c_host.as_ptr() };\n+            let cs = if c_serv.is_null() { null() } else { c_serv.as_ptr() };\n             getaddrinfo(ch, cs, hint_ptr, &mut res)\n         };\n \n@@ -87,11 +89,12 @@ impl GetAddrInfoRequest {\n }\n \n extern \"system\" {\n-    fn getaddrinfo(node: *c_char, service: *c_char,\n-                   hints: *libc::addrinfo, res: *mut *mut libc::addrinfo) -> c_int;\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n     fn freeaddrinfo(res: *mut libc::addrinfo);\n     #[cfg(not(windows))]\n-    fn gai_strerror(errcode: c_int) -> *c_char;\n+    fn gai_strerror(errcode: c_int) -> *const c_char;\n }\n \n #[cfg(windows)]"}, {"sha": "9fbf3659d3f6ba900a0883655045394558343304", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -57,12 +57,12 @@ pub static WNOHANG: libc::c_int = 1;\n \n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n-                        tzp: *libc::c_void) -> libc::c_int;\n+                        tzp: *mut libc::c_void) -> libc::c_int;\n     pub fn select(nfds: libc::c_int,\n-                  readfds: *fd_set,\n-                  writefds: *fd_set,\n-                  errorfds: *fd_set,\n-                  timeout: *libc::timeval) -> libc::c_int;\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  errorfds: *mut fd_set,\n+                  timeout: *mut libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::c_int,\n                       level: libc::c_int,\n                       optname: libc::c_int,\n@@ -75,7 +75,7 @@ extern {\n                    options: libc::c_int) -> libc::pid_t;\n \n     pub fn sigaction(signum: libc::c_int,\n-                     act: *sigaction,\n+                     act: *const sigaction,\n                      oldact: *mut sigaction) -> libc::c_int;\n \n     pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;"}, {"sha": "802526c91969524a9cfd4023466b7fce9f93aa72", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -28,7 +28,7 @@ pub struct WSADATA {\n     pub szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n     pub iMaxSockets: u16,\n     pub iMaxUdpDg: u16,\n-    pub lpVendorInfo: *u8,\n+    pub lpVendorInfo: *mut u8,\n }\n \n pub type LPWSADATA = *mut WSADATA;\n@@ -53,10 +53,10 @@ extern \"system\" {\n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;\n     pub fn select(nfds: libc::c_int,\n-                  readfds: *fd_set,\n-                  writefds: *fd_set,\n-                  exceptfds: *fd_set,\n-                  timeout: *libc::timeval) -> libc::c_int;\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  exceptfds: *mut fd_set,\n+                  timeout: *mut libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::SOCKET,\n                       level: libc::c_int,\n                       optname: libc::c_int,\n@@ -70,6 +70,7 @@ extern \"system\" {\n \n pub mod compat {\n     use std::intrinsics::{atomic_store_relaxed, transmute};\n+    use std::iter::Iterator;\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n \n     extern \"system\" {\n@@ -82,7 +83,8 @@ pub mod compat {\n     // layer (after it's loaded) shouldn't be any slower than a regular DLL\n     // call.\n     unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n-        let module = module.to_utf16().append_one(0);\n+        let module: Vec<u16> = module.utf16_units().collect();\n+        let module = module.append_one(0);\n         symbol.with_c_str(|symbol| {\n             let handle = GetModuleHandleW(module.as_ptr());\n             let func: uint = transmute(GetProcAddress(handle, symbol));"}, {"sha": "ddcff2be5f340c02eb8f43bc7aca910136c92bda", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -68,7 +68,7 @@ impl FileDesc {\n     pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::write(self.fd(), buf as *libc::c_void,\n+                libc::write(self.fd(), buf as *const libc::c_void,\n                             len as libc::size_t) as i64\n             }\n         });\n@@ -91,7 +91,7 @@ impl rtio::RtioFileStream for FileDesc {\n     }\n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         match retry(|| unsafe {\n-            libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n+            libc::pread(self.fd(), buf.as_ptr() as *mut _,\n                         buf.len() as libc::size_t,\n                         offset as libc::off_t) as libc::c_int\n         }) {\n@@ -101,7 +101,7 @@ impl rtio::RtioFileStream for FileDesc {\n     }\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n-            libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n+            libc::pwrite(self.fd(), buf.as_ptr() as *const _,\n                          buf.len() as libc::size_t, offset as libc::off_t)\n         } as c_int))\n     }\n@@ -222,7 +222,7 @@ impl Drop for Inner {\n }\n \n pub struct CFile {\n-    file: *libc::FILE,\n+    file: *mut libc::FILE,\n     fd: FileDesc,\n }\n \n@@ -231,7 +231,7 @@ impl CFile {\n     ///\n     /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n     /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile {\n+    pub fn new(file: *mut libc::FILE) -> CFile {\n         CFile {\n             file: file,\n             fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n@@ -263,7 +263,7 @@ impl rtio::RtioFileStream for CFile {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                libc::fwrite(buf as *const libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         });\n@@ -339,15 +339,15 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n                             libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n-    match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n+    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n         -1 => Err(super::last_error()),\n         fd => Ok(FileDesc::new(fd, true)),\n     }\n }\n \n pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n+        libc::mkdir(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n@@ -356,7 +356,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use libc::{opendir, readdir_r, closedir};\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n@@ -366,14 +366,14 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n \n     extern {\n         fn rust_dirent_t_size() -> libc::c_int;\n-        fn rust_list_dir_val(ptr: *mut dirent_t) -> *libc::c_char;\n+        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n     }\n \n     let size = unsafe { rust_dirent_t_size() };\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n     let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n \n-    let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n+    let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n     if dir_ptr as uint != 0 {\n         let mut paths = vec!();\n@@ -393,37 +393,37 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n }\n \n pub fn unlink(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n+    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.as_ptr()) }))\n }\n \n pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n+        libc::rename(old.as_ptr(), new.as_ptr())\n     }))\n }\n \n pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n+        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n pub fn rmdir(p: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::rmdir(p.with_ref(|p| p))\n+        libc::rmdir(p.as_ptr())\n     }))\n }\n \n pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n+        libc::chown(p.as_ptr(), uid as libc::uid_t,\n                     gid as libc::gid_t)\n     }))\n }\n \n pub fn readlink(p: &CString) -> IoResult<CString> {\n-    let p = p.with_ref(|p| p);\n-    let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n+    let p = p.as_ptr();\n+    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }\n@@ -443,13 +443,13 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        libc::symlink(src.as_ptr(), dst.as_ptr())\n     }))\n }\n \n pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        libc::link(src.as_ptr(), dst.as_ptr())\n     }))\n }\n \n@@ -489,15 +489,15 @@ fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n \n pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n+    match retry(|| unsafe { libc::stat(p.as_ptr(), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n }\n \n pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n+    match retry(|| unsafe { libc::lstat(p.as_ptr(), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n@@ -509,7 +509,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n         modtime: (mtime / 1000) as libc::time_t,\n     };\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::utime(p.with_ref(|p| p), &buf)\n+        libc::utime(p.as_ptr(), &buf)\n     }))\n }\n "}, {"sha": "98553603313404382aafa07a63d726c28ef9b1a6", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -255,7 +255,7 @@ impl Drop for Inner {\n \n pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n     match s.as_str() {\n-        Some(s) => Ok(s.to_utf16().append_one(0)),\n+        Some(s) => Ok(s.utf16_units().collect::<Vec<u16>>().append_one(0)),\n         None => Err(IoError {\n             code: libc::ERROR_INVALID_NAME as uint,\n             extra: 0,\n@@ -347,7 +347,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use std::rt::libc_heap::malloc_raw;\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n@@ -357,21 +357,22 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n \n     extern {\n         fn rust_list_dir_wfd_size() -> libc::size_t;\n-        fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+        fn rust_list_dir_wfd_fp_buf(wfd: *mut libc::c_void) -> *const u16;\n     }\n     let star = Path::new(unsafe {\n-        CString::new(p.with_ref(|p| p), false)\n+        CString::new(p.as_ptr(), false)\n     }).join(\"*\");\n     let path = try!(to_utf16(&star.to_c_str()));\n \n     unsafe {\n         let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-        let find_handle = libc::FindFirstFileW(path.as_ptr(), wfd_ptr as libc::HANDLE);\n+        let find_handle = libc::FindFirstFileW(path.as_ptr(),\n+                                               wfd_ptr as libc::HANDLE);\n         if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n             let mut paths = vec!();\n             let mut more_files = 1 as libc::c_int;\n             while more_files != 0 {\n-                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n+                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *mut c_void);\n                 if fp_buf as uint == 0 {\n                     fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                 } else {\n@@ -446,7 +447,7 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n     // without the null pointer\n     let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n         GetFinalPathNameByHandleW(handle,\n-                                  buf as *u16,\n+                                  buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n     });\n@@ -514,12 +515,12 @@ pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n }\n \n pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    let buf = libc::utimbuf {\n+    let mut buf = libc::utimbuf {\n         actime: (atime / 1000) as libc::time64_t,\n         modtime: (mtime / 1000) as libc::time64_t,\n     };\n     let p = try!(to_utf16(p));\n     super::mkerr_libc(unsafe {\n-        libc::wutime(p.as_ptr(), &buf)\n+        libc::wutime(p.as_ptr(), &mut buf)\n     })\n }"}, {"sha": "f6764b8f26a790893853e1c88e716bb1bb51341e", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -132,7 +132,7 @@ fn retry(f: || -> libc::c_int) -> libc::c_int {\n     }\n }\n \n-fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n     let mut amt = origamt;"}, {"sha": "dfc2c55cde7cb511bb79303ed6942d7b69f1572f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -105,7 +105,7 @@ fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n-        let payload = &payload as *T as *libc::c_void;\n+        let payload = &payload as *const T as *const libc::c_void;\n         let ret = libc::setsockopt(fd, opt, val,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n@@ -278,7 +278,7 @@ impl TcpStream {\n         let ret = TcpStream::new(Inner::new(fd));\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         match timeout {\n@@ -369,7 +369,7 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *mut libc::c_void,\n@@ -456,7 +456,7 @@ impl TcpListener {\n         let ret = TcpListener { inner: Inner::new(fd) };\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         // On platforms with Berkeley-derived sockets, this allows\n@@ -564,7 +564,7 @@ impl UdpSocket {\n         };\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n@@ -630,7 +630,7 @@ impl rtio::RtioSocket for UdpSocket {\n #[cfg(unix)]    type msglen_t = libc::size_t;\n \n impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n+    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -652,17 +652,17 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n+    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n         let (dst, dstlen) = addr_to_sockaddr(dst);\n-        let dstp = &dst as *_ as *libc::sockaddr;\n+        let dstp = &dst as *const _ as *const libc::sockaddr;\n         let dstlen = dstlen as libc::socklen_t;\n \n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::sendto(fd,\n-                         buf as *libc::c_void,\n+                         buf as *const libc::c_void,\n                          len as msglen_t,\n                          flags,\n                          dstp,\n@@ -842,7 +842,7 @@ pub fn write<T>(fd: sock_t,\n                 buf: &[u8],\n                 write_everything: bool,\n                 lock: || -> T,\n-                write: |bool, *u8, uint| -> i64) -> IoResult<uint> {\n+                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n     let mut ret = -1;\n     let mut written = 0;\n     if deadline == 0 {"}, {"sha": "b5b2065f996ed29d079807a1454c3f86f2763269", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -78,7 +78,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n            timeout: Option<u64>) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *_ as *libc::sockaddr;\n+    let addrp = &addr as *const _ as *const libc::sockaddr;\n     let len = len as libc::socklen_t;\n \n     match timeout {\n@@ -98,9 +98,9 @@ fn connect(addr: &CString, ty: libc::c_int,\n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *libc::sockaddr_storage;\n+    let addrp = &addr as *const _;\n     match unsafe {\n-        libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n+        libc::bind(inner.fd, addrp as *const _, len as libc::socklen_t)\n     } {\n         -1 => Err(super::last_error()),\n         _  => Ok(inner)\n@@ -166,7 +166,7 @@ impl rtio::RtioPipe for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *mut libc::c_void,\n@@ -278,7 +278,7 @@ impl Drop for UnixListener {\n         // careful to unlink the path before we close the file descriptor to\n         // prevent races where we unlink someone else's path.\n         unsafe {\n-            let _ = libc::unlink(self.path.with_ref(|p| p));\n+            let _ = libc::unlink(self.path.as_ptr());\n         }\n     }\n }"}, {"sha": "da713e3f2a931e9394a02f90b5bd3061175d2601", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -152,7 +152,7 @@ impl Drop for Inner {\n     }\n }\n \n-unsafe fn pipe(name: *u16, init: bool) -> libc::HANDLE {\n+unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n     libc::CreateNamedPipeW(\n         name,\n         libc::PIPE_ACCESS_DUPLEX |\n@@ -210,7 +210,7 @@ pub struct UnixStream {\n }\n \n impl UnixStream {\n-    fn try_connect(p: *u16) -> Option<libc::HANDLE> {\n+    fn try_connect(p: *const u16) -> Option<libc::HANDLE> {\n         // Note that most of this is lifted from the libuv implementation.\n         // The idea is that if we fail to open a pipe in read/write mode\n         // that we try afterwards in just read or just write"}, {"sha": "6fab73115cf9a5e2dcd1ddf7847f2796b4f44e4d", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -43,7 +43,7 @@ pub struct Process {\n     /// A handle to the process - on unix this will always be NULL, but on\n     /// windows it will be a HANDLE to the process, which will prevent the\n     /// pid being re-used until the handle is closed.\n-    handle: *(),\n+    handle: *mut (),\n \n     /// None until finish() is called.\n     exit_code: Option<rtio::ProcessExit>,\n@@ -269,7 +269,7 @@ unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n \n struct SpawnProcessResult {\n     pid: pid_t,\n-    handle: *(),\n+    handle: *mut (),\n }\n \n #[cfg(windows)]\n@@ -294,6 +294,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n     use libc::funcs::extra::msvcrt::get_osfhandle;\n \n     use std::mem;\n+    use std::iter::Iterator;\n+    use std::str::StrSlice;\n \n     if cfg.gid.is_some() || cfg.uid.is_some() {\n         return Err(IoError {\n@@ -328,7 +330,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n                         lpSecurityDescriptor: ptr::mut_null(),\n                         bInheritHandle: 1,\n                     };\n-                    let filename = \"NUL\".to_utf16().append_one(0);\n+                    let filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                    let filename = filename.append_one(0);\n                     *slot = libc::CreateFileW(filename.as_ptr(),\n                                               access,\n                                               libc::FILE_SHARE_READ |\n@@ -371,7 +374,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n-                let mut cmd_str = cmd_str.to_utf16().append_one(0);\n+                let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n+                cmd_str = cmd_str.append_one(0);\n                 let created = CreateProcessW(ptr::null(),\n                                              cmd_str.as_mut_ptr(),\n                                              ptr::mut_null(),\n@@ -403,7 +407,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n         Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *()\n+            handle: pi.hProcess as *mut ()\n         })\n     }\n }\n@@ -515,14 +519,14 @@ fn spawn_process_os(cfg: ProcessConfig,\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern { fn _NSGetEnviron() -> *mut *c_void; }\n+    unsafe fn set_environ(envp: *const c_void) {\n+        extern { fn _NSGetEnviron() -> *mut *const c_void; }\n \n         *_NSGetEnviron() = envp;\n     }\n     #[cfg(not(target_os = \"macos\"))]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern { static mut environ: *c_void; }\n+    unsafe fn set_environ(envp: *const c_void) {\n+        extern { static mut environ: *const c_void; }\n         environ = envp;\n     }\n \n@@ -531,7 +535,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n         assert_eq!(ret, 0);\n     }\n \n-    let dirp = cfg.cwd.map(|c| c.with_ref(|p| p)).unwrap_or(ptr::null());\n+    let dirp = cfg.cwd.map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n     let cfg = unsafe {\n         mem::transmute::<ProcessConfig,ProcessConfig<'static>>(cfg)\n@@ -568,7 +572,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     Err(..) => {\n                         Ok(SpawnProcessResult {\n                             pid: pid,\n-                            handle: ptr::null()\n+                            handle: ptr::mut_null()\n                         })\n                     }\n                     Ok(..) => fail!(\"short read on the cloexec pipe\"),\n@@ -633,7 +637,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                         } else {\n                             libc::O_RDWR\n                         };\n-                        devnull.with_ref(|p| libc::open(p, flags, 0))\n+                        libc::open(devnull.as_ptr(), flags, 0)\n                     }\n                     Some(obj) => {\n                         let fd = obj.fd();\n@@ -668,17 +672,18 @@ fn spawn_process_os(cfg: ProcessConfig,\n             }\n             match cfg.uid {\n                 Some(u) => {\n-                    // When dropping privileges from root, the `setgroups` call will\n-                    // remove any extraneous groups. If we don't call this, then\n-                    // even though our uid has dropped, we may still have groups\n-                    // that enable us to do super-user things. This will fail if we\n-                    // aren't root, so don't bother checking the return value, this\n-                    // is just done as an optimistic privilege dropping function.\n+                    // When dropping privileges from root, the `setgroups` call\n+                    // will remove any extraneous groups. If we don't call this,\n+                    // then even though our uid has dropped, we may still have\n+                    // groups that enable us to do super-user things. This will\n+                    // fail if we aren't root, so don't bother checking the\n+                    // return value, this is just done as an optimistic\n+                    // privilege dropping function.\n                     extern {\n                         fn setgroups(ngroups: libc::c_int,\n-                                     ptr: *libc::c_void) -> libc::c_int;\n+                                     ptr: *const libc::c_void) -> libc::c_int;\n                     }\n-                    let _ = setgroups(0, 0 as *libc::c_void);\n+                    let _ = setgroups(0, 0 as *const libc::c_void);\n \n                     if libc::setuid(u as libc::uid_t) != 0 {\n                         fail(&mut output);\n@@ -698,23 +703,24 @@ fn spawn_process_os(cfg: ProcessConfig,\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            let _ = execvp(*argv, argv);\n+            let _ = execvp(*argv, argv as *mut _);\n             fail(&mut output);\n         })\n     })\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &CString, args: &[CString], cb: proc(**libc::c_char) -> T) -> T {\n-    let mut ptrs: Vec<*libc::c_char> = Vec::with_capacity(args.len()+1);\n+fn with_argv<T>(prog: &CString, args: &[CString],\n+                cb: proc(*const *const libc::c_char) -> T) -> T {\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n     // Convert the CStrings into an array of pointers. Note: the\n     // lifetime of the various CStrings involved is guaranteed to be\n     // larger than the lifetime of our invocation of cb, but this is\n     // technically unsafe as the callback could leak these pointers\n     // out of our scope.\n-    ptrs.push(prog.with_ref(|buf| buf));\n-    ptrs.extend(args.iter().map(|tmp| tmp.with_ref(|buf| buf)));\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n \n     // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());\n@@ -723,7 +729,8 @@ fn with_argv<T>(prog: &CString, args: &[CString], cb: proc(**libc::c_char) -> T)\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: proc(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<&[(CString, CString)]>,\n+                cb: proc(*const c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create\n     // these strings locally, yet expose a raw pointer to them, we\n@@ -742,13 +749,13 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: proc(*c_void) -> T) -> T\n             }\n \n             // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*libc::c_char> =\n+            let mut ptrs: Vec<*const libc::c_char> =\n                 tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *libc::c_char)\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n                     .collect();\n             ptrs.push(ptr::null());\n \n-            cb(ptrs.as_ptr() as *c_void)\n+            cb(ptrs.as_ptr() as *const c_void)\n         }\n         _ => cb(ptr::null())\n     }\n@@ -767,7 +774,7 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T\n                 let kv = format!(\"{}={}\",\n                                  pair.ref0().as_str().unwrap(),\n                                  pair.ref1().as_str().unwrap());\n-                blk.push_all(kv.to_utf16().as_slice());\n+                blk.extend(kv.as_slice().utf16_units());\n                 blk.push(0);\n             }\n \n@@ -780,27 +787,29 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T\n }\n \n #[cfg(windows)]\n-fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n+fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n     match d {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          let dir_str = dir_str.to_utf16().append_one(0);\n+          let dir_str: Vec<u16> = dir_str.utf16_units().collect();\n+          let dir_str = dir_str.append_one(0);\n+\n           cb(dir_str.as_ptr())\n       },\n       None => cb(ptr::null())\n     }\n }\n \n #[cfg(windows)]\n-fn free_handle(handle: *()) {\n+fn free_handle(handle: *mut ()) {\n     assert!(unsafe {\n         libc::CloseHandle(mem::transmute(handle)) != 0\n     })\n }\n \n #[cfg(unix)]\n-fn free_handle(_handle: *()) {\n+fn free_handle(_handle: *mut ()) {\n     // unix has no process handle object, just a pid\n }\n \n@@ -1014,15 +1023,16 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n                     let now = ::io::timer::now();\n                     let ms = if now < deadline {deadline - now} else {0};\n                     tv = util::ms_to_timeval(ms);\n-                    (&tv as *_, idx)\n+                    (&mut tv as *mut _, idx)\n                 }\n-                None => (ptr::null(), -1),\n+                None => (ptr::mut_null(), -1),\n             };\n \n             // Wait for something to happen\n             c::fd_set(&mut set, input);\n             c::fd_set(&mut set, read_fd);\n-            match unsafe { c::select(max, &set, ptr::null(), ptr::null(), p) } {\n+            match unsafe { c::select(max, &mut set, ptr::mut_null(),\n+                                     ptr::mut_null(), p) } {\n                 // interrupted, retry\n                 -1 if os::errno() == libc::EINTR as int => continue,\n \n@@ -1132,9 +1142,9 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     // which will wake up the other end at some point, so we just allow this\n     // signal to be coalesced with the pending signals on the pipe.\n     extern fn sigchld_handler(_signum: libc::c_int) {\n-        let mut msg = 1;\n+        let msg = 1i;\n         match unsafe {\n-            libc::write(WRITE_FD, &mut msg as *mut _ as *libc::c_void, 1)\n+            libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n         } {\n             1 => {}\n             -1 if util::wouldblock() => {} // see above comments"}, {"sha": "8d6563bafad6365c3ed287bda8a31b81731a3918", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -88,7 +88,7 @@ pub enum Req {\n pub fn now() -> u64 {\n     unsafe {\n         let mut now: libc::timeval = mem::zeroed();\n-        assert_eq!(c::gettimeofday(&mut now, ptr::null()), 0);\n+        assert_eq!(c::gettimeofday(&mut now, ptr::mut_null()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n@@ -146,7 +146,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n     'outer: loop {\n         let timeout = if active.len() == 0 {\n             // Empty array? no timeout (wait forever for the next request)\n-            ptr::null()\n+            ptr::mut_null()\n         } else {\n             let now = now();\n             // If this request has already expired, then signal it and go\n@@ -162,12 +162,13 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n             let tm = active.get(0).target - now;\n             timeout.tv_sec = (tm / 1000) as libc::time_t;\n             timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n-            &timeout as *libc::timeval\n+            &mut timeout as *mut libc::timeval\n         };\n \n         c::fd_set(&mut set, input);\n         match unsafe {\n-            c::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n+            c::select(input + 1, &mut set, ptr::mut_null(),\n+                      ptr::mut_null(), timeout)\n         } {\n             // timed out\n             0 => signal(&mut active, &mut dead),"}, {"sha": "1e5594126b10a9739b606b2cb40d2ce96024d4fb", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -141,7 +141,7 @@ impl rtio::RtioTimer for Timer {\n         // 100ns intervals, so we multiply by 10^4.\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n@@ -154,7 +154,7 @@ impl rtio::RtioTimer for Timer {\n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n@@ -169,7 +169,7 @@ impl rtio::RtioTimer for Timer {\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n             imp::SetWaitableTimer(self.obj, &due, msecs as libc::LONG,\n-                                  ptr::null(), ptr::mut_null(), 0)\n+                                  ptr::mut_null(), ptr::mut_null(), 0)\n         }, 1);\n \n         unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }\n@@ -188,20 +188,20 @@ mod imp {\n     use libc::{LPSECURITY_ATTRIBUTES, BOOL, LPCSTR, HANDLE, LARGE_INTEGER,\n                     LONG, LPVOID, DWORD, c_void};\n \n-    pub type PTIMERAPCROUTINE = *c_void;\n+    pub type PTIMERAPCROUTINE = *mut c_void;\n \n     extern \"system\" {\n         pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,\n                                     bManualReset: BOOL,\n                                     lpTimerName: LPCSTR) -> HANDLE;\n         pub fn SetWaitableTimer(hTimer: HANDLE,\n-                                pDueTime: *LARGE_INTEGER,\n+                                pDueTime: *const LARGE_INTEGER,\n                                 lPeriod: LONG,\n                                 pfnCompletionRoutine: PTIMERAPCROUTINE,\n                                 lpArgToCompletionRoutine: LPVOID,\n                                 fResume: BOOL) -> BOOL;\n         pub fn WaitForMultipleObjects(nCount: DWORD,\n-                                      lpHandles: *HANDLE,\n+                                      lpHandles: *const HANDLE,\n                                       bWaitAll: BOOL,\n                                       dwMilliseconds: DWORD) -> DWORD;\n         pub fn WaitForSingleObject(hHandle: HANDLE,"}, {"sha": "31ba2223082d554325d66814aa8869500c566324", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -90,7 +90,7 @@ pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n // derived from.\n pub fn connect_timeout(fd: net::sock_t,\n-                       addrp: *libc::sockaddr,\n+                       addrp: *const libc::sockaddr,\n                        len: libc::socklen_t,\n                        timeout_ms: u64) -> IoResult<()> {\n     use std::os;\n@@ -145,16 +145,16 @@ pub fn connect_timeout(fd: net::sock_t,\n             // Recalculate the timeout each iteration (it is generally\n             // undefined what the value of the 'tv' is after select\n             // returns EINTR).\n-            let tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-            c::select(fd + 1, ptr::null(), set as *mut _ as *_,\n-                      ptr::null(), &tv)\n+            let mut tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n+            c::select(fd + 1, ptr::mut_null(), set as *mut _,\n+                      ptr::mut_null(), &mut tv)\n         })\n     }\n     #[cfg(windows)]\n     fn await(_fd: net::sock_t, set: &mut c::fd_set,\n              timeout: u64) -> libc::c_int {\n-        let tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null(), &*set, ptr::null(), &tv) }\n+        let mut tv = ms_to_timeval(timeout);\n+        unsafe { c::select(1, ptr::mut_null(), set, ptr::mut_null(), &mut tv) }\n     }\n }\n \n@@ -163,25 +163,25 @@ pub fn await(fd: net::sock_t, deadline: Option<u64>,\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n     c::fd_set(&mut set, fd);\n     let (read, write) = match status {\n-        Readable => (&set as *_, ptr::null()),\n-        Writable => (ptr::null(), &set as *_),\n+        Readable => (&mut set as *mut _, ptr::mut_null()),\n+        Writable => (ptr::mut_null(), &mut set as *mut _),\n     };\n     let mut tv: libc::timeval = unsafe { mem::zeroed() };\n \n     match retry(|| {\n         let now = ::io::timer::now();\n         let tvp = match deadline {\n-            None => ptr::null(),\n+            None => ptr::mut_null(),\n             Some(deadline) => {\n                 // If we're past the deadline, then pass a 0 timeout to\n                 // select() so we can poll the status\n                 let ms = if deadline < now {0} else {deadline - now};\n                 tv = ms_to_timeval(ms);\n-                &tv as *_\n+                &mut tv as *mut _\n             }\n         };\n         let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        let r = unsafe { c::select(n, read, write, ptr::null(), tvp) };\n+        let r = unsafe { c::select(n, read, write, ptr::mut_null(), tvp) };\n         r\n     }) {\n         -1 => Err(last_error()),"}, {"sha": "2e43ddba6449ce08bb956b2c14711911472775b5", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -20,7 +20,9 @@\n //! extern crate native;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n+//!     native::start(argc, argv, main)\n+//! }\n //!\n //! fn main() {\n //!     // this code is running on the main OS thread\n@@ -55,7 +57,6 @@\n \n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types, deprecated)]\n-#![allow(unknown_features)] // NOTE: remove after a stage0 snap\n #![feature(default_type_params, lang_items)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n@@ -84,7 +85,7 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n #[lang = \"start\"]\n #[cfg(not(test))]\n-pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+pub fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use std::mem;\n     start(argc, argv, proc() {\n         let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n@@ -101,9 +102,9 @@ pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n ///\n /// This function will only return once *all* native threads in the system have\n /// exited.\n-pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *int;\n+    let addr = &something_around_the_top_of_the_stack as *const int;\n     let my_stack_top = addr as uint;\n \n     // FIXME #11359 we just assume that this thread has a stack of a"}, {"sha": "7ba588ac21c481fc6a6f4c2f654e0e1cdf600f54", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -81,7 +81,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     // which our stack started).\n     Thread::spawn_stack(stack, proc() {\n         let something_around_the_top_of_the_stack = 1;\n-        let addr = &something_around_the_top_of_the_stack as *int;\n+        let addr = &something_around_the_top_of_the_stack as *const int;\n         let my_stack = addr as uint;\n         unsafe {\n             stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n@@ -198,7 +198,7 @@ impl rt::Runtime for Ops {\n         cur_task.put_runtime(self);\n \n         unsafe {\n-            let cur_task_dupe = &*cur_task as *Task;\n+            let cur_task_dupe = &mut *cur_task as *mut Task;\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {"}, {"sha": "cc3753def59f4cc2a6ed98d1080f4a36fc33ae28", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -91,8 +91,8 @@ impl Eq for BigUint {}\n \n impl PartialOrd for BigUint {\n     #[inline]\n-    fn lt(&self, other: &BigUint) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -215,7 +215,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n         let zeros = ZERO_VEC.iter().cycle();\n         let (a, b) = (self.data.iter().chain(zeros.clone()), other.data.iter().chain(zeros));\n \n-        let mut borrow = 0;\n+        let mut borrow = 0i;\n         let diff: Vec<BigDigit> =  a.take(new_len).zip(b).map(|(ai, bi)| {\n             let (hi, lo) = BigDigit::from_doublebigdigit(\n                 BigDigit::base\n@@ -816,8 +816,8 @@ impl Eq for BigInt {}\n \n impl PartialOrd for BigInt {\n     #[inline]\n-    fn lt(&self, other: &BigInt) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "9a455edf2c086e8d034b5c178847fda15b556ae5", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -193,7 +193,8 @@ macro_rules! cmp_impl {\n     };\n }\n cmp_impl!(impl PartialEq, eq, ne)\n-cmp_impl!(impl PartialOrd, lt, gt, le, ge)\n+cmp_impl!(impl PartialOrd, lt -> bool, gt -> bool, le -> bool, ge -> bool,\n+          partial_cmp -> Option<cmp::Ordering>)\n cmp_impl!(impl Eq, )\n cmp_impl!(impl Ord, cmp -> cmp::Ordering)\n "}, {"sha": "134e7af507010db11a2f0980e1951c8b73dd2ab3", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -389,10 +389,10 @@ impl Isaac64Rng {\n                             }\n                         }}\n                     );\n-                rngstepp!(0, 21);\n-                rngstepn!(1, 5);\n-                rngstepp!(2, 12);\n-                rngstepn!(3, 33);\n+                rngstepp!(0u, 21);\n+                rngstepn!(1u, 5);\n+                rngstepp!(2u, 12);\n+                rngstepn!(3u, 33);\n             }\n         }\n "}, {"sha": "593b9785d475abb3f65ae9d3b49982ea7e8c5299", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -111,7 +111,7 @@ pub trait Rng {\n         // (3) adds more `unsafe` that needs to be checked, (4)\n         // probably doesn't give much performance gain if\n         // optimisations are on.\n-        let mut count = 0;\n+        let mut count = 0i;\n         let mut num = 0;\n         for byte in dest.mut_iter() {\n             if count == 0 {"}, {"sha": "77433877ec6687c8729cd684821a6c49bd3d1ffa", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -203,6 +203,8 @@ tuple_impl!{A, B, C, D, E, F, G}\n tuple_impl!{A, B, C, D, E, F, G, H}\n tuple_impl!{A, B, C, D, E, F, G, H, I}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n impl<T:Rand> Rand for Option<T> {\n     #[inline]"}, {"sha": "9cde40c196088648f3192bb11e7f603481b900ca", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -770,7 +770,7 @@ impl<'a> Parser<'a> {\n         }\n         let start = self.chari;\n         let mut flags = self.flags;\n-        let mut sign = 1;\n+        let mut sign = 1i;\n         let mut saw_flag = false;\n         loop {\n             try!(self.noteof(\"expected non-empty set of flags or closing ')'\"))"}, {"sha": "8c7bf3496eef185bc15cc51da3941496efc12fcb", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -27,7 +27,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/0.11.0/\")]\n #![feature(intrinsics)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n \n #![no_std]\n #![experimental]\n@@ -43,31 +42,36 @@\n // implementations below. If pointer arithmetic is done through integers the\n // optimizations start to break down.\n extern \"rust-intrinsic\" {\n-    fn offset<T>(dst: *T, offset: int) -> *T;\n+    fn offset<T>(dst: *const T, offset: int) -> *const T;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n+pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *const u8,\n+                                n: uint) -> *mut u8 {\n     let mut i = 0;\n     while i < n {\n-        *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+        *(offset(dest as *const u8, i as int) as *mut u8) =\n+            *offset(src, i as int);\n         i += 1;\n     }\n     return dest;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n-    if src < dest as *u8 { // copy from end\n+pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *const u8,\n+                                 n: uint) -> *mut u8 {\n+    if src < dest as *const u8 { // copy from end\n         let mut i = n;\n         while i != 0 {\n             i -= 1;\n-            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+            *(offset(dest as *const u8, i as int) as *mut u8) =\n+                *offset(src, i as int);\n         }\n     } else { // copy from beginning\n         let mut i = 0;\n         while i < n {\n-            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+            *(offset(dest as *const u8, i as int) as *mut u8) =\n+                *offset(src, i as int);\n             i += 1;\n         }\n     }\n@@ -78,14 +82,14 @@ pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n pub unsafe extern \"C\" fn memset(s: *mut u8, c: i32, n: uint) -> *mut u8 {\n     let mut i = 0;\n     while i < n {\n-        *(offset(s as *u8, i as int) as *mut u8) = c as u8;\n+        *(offset(s as *const u8, i as int) as *mut u8) = c as u8;\n         i += 1;\n     }\n     return s;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memcmp(s1: *u8, s2: *u8, n: uint) -> i32 {\n+pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n     let mut i = 0;\n     while i < n {\n         let a = *offset(s1, i as int);"}, {"sha": "17f29639601dd72455e0e7e38202970df8f3a298", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -412,7 +412,7 @@ pub mod write {\n         {\n             let add = |arg: &str| {\n                 let s = arg.to_c_str();\n-                llvm_args.push(s.with_ref(|p| p));\n+                llvm_args.push(s.as_ptr());\n                 llvm_c_strs.push(s);\n             };\n             add(\"rustc\"); // fake program name\n@@ -657,8 +657,8 @@ pub fn sanitize(s: &str) -> String {\n \n     // Underscore-qualify anything that didn't start as an ident.\n     if result.len() > 0u &&\n-        result.as_slice()[0] != '_' as u8 &&\n-        ! char::is_XID_start(result.as_slice()[0] as char) {\n+        result.as_bytes()[0] != '_' as u8 &&\n+        ! char::is_XID_start(result.as_bytes()[0] as char) {\n         return format!(\"_{}\", result.as_slice());\n     }\n \n@@ -737,9 +737,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     let extra2 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra3 = id % EXTRA_CHARS.len();\n-    hash.push_char(EXTRA_CHARS[extra1] as char);\n-    hash.push_char(EXTRA_CHARS[extra2] as char);\n-    hash.push_char(EXTRA_CHARS[extra3] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra1] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra2] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n     exported_name(path,\n                   hash.as_slice(),"}, {"sha": "b9ae9530f8e1c3291aa4a15be0393484b844b0e5", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -82,7 +82,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n              (),\n              |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                    ptr as *libc::c_char,\n+                                                    ptr as *const libc::c_char,\n                                                     bc.len() as libc::size_t) {\n                 link::llvm_err(sess,\n                                format!(\"failed to load bc of `{}`\",\n@@ -94,10 +94,11 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<::std::c_str::CString> =\n         reachable.iter().map(|s| s.as_slice().to_c_str()).collect();\n-    let arr: Vec<*i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n+    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n-        llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n+        llvm::LLVMRustRunRestrictionPass(llmod,\n+                                         ptr as *const *const libc::c_char,\n                                          arr.len() as libc::size_t);\n     }\n "}, {"sha": "d07e74493be96dc4b82547a158860d7e68e3442e", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 209, "deletions": 209, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -255,45 +255,45 @@ pub enum CodeGenModel {\n \n // Opaque pointer types\n pub enum Module_opaque {}\n-pub type ModuleRef = *Module_opaque;\n+pub type ModuleRef = *mut Module_opaque;\n pub enum Context_opaque {}\n-pub type ContextRef = *Context_opaque;\n+pub type ContextRef = *mut Context_opaque;\n pub enum Type_opaque {}\n-pub type TypeRef = *Type_opaque;\n+pub type TypeRef = *mut Type_opaque;\n pub enum Value_opaque {}\n-pub type ValueRef = *Value_opaque;\n+pub type ValueRef = *mut Value_opaque;\n pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *BasicBlock_opaque;\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n pub enum Builder_opaque {}\n-pub type BuilderRef = *Builder_opaque;\n+pub type BuilderRef = *mut Builder_opaque;\n pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *ExecutionEngine_opaque;\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *MemoryBuffer_opaque;\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n pub enum PassManager_opaque {}\n-pub type PassManagerRef = *PassManager_opaque;\n+pub type PassManagerRef = *mut PassManager_opaque;\n pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *PassManagerBuilder_opaque;\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n pub enum Use_opaque {}\n-pub type UseRef = *Use_opaque;\n+pub type UseRef = *mut Use_opaque;\n pub enum TargetData_opaque {}\n-pub type TargetDataRef = *TargetData_opaque;\n+pub type TargetDataRef = *mut TargetData_opaque;\n pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *ObjectFile_opaque;\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *SectionIterator_opaque;\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n pub enum Pass_opaque {}\n-pub type PassRef = *Pass_opaque;\n+pub type PassRef = *mut Pass_opaque;\n pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *TargetMachine_opaque;\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n pub enum Archive_opaque {}\n-pub type ArchiveRef = *Archive_opaque;\n+pub type ArchiveRef = *mut Archive_opaque;\n \n pub mod debuginfo {\n     use super::{ValueRef};\n \n     pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *DIBuilder_opaque;\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n \n     pub type DIDescriptor = ValueRef;\n     pub type DIScope = DIDescriptor;\n@@ -354,30 +354,30 @@ pub mod llvm {\n         pub fn LLVMContextCreate() -> ContextRef;\n         pub fn LLVMContextDispose(C: ContextRef);\n         pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                        Name: *c_char,\n+                                        Name: *const c_char,\n                                         SLen: c_uint)\n                                         -> c_uint;\n \n         /* Create and destroy modules. */\n-        pub fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n+        pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n                                                  C: ContextRef)\n                                                  -> ModuleRef;\n         pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n         pub fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n-        pub fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n-        pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n+        pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+        pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n \n         /** Target triple. See Module::getTargetTriple. */\n-        pub fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n-        pub fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n+        pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+        pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n \n         /** See Module::dump. */\n         pub fn LLVMDumpModule(M: ModuleRef);\n \n         /** See Module::setModuleInlineAsm. */\n-        pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n+        pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n \n         /** See llvm::LLVMTypeKind::getTypeID. */\n         pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n@@ -405,18 +405,18 @@ pub mod llvm {\n \n         /* Operations on function types */\n         pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                                ParamTypes: *TypeRef,\n+                                ParamTypes: *const TypeRef,\n                                 ParamCount: c_uint,\n                                 IsVarArg: Bool)\n                                 -> TypeRef;\n         pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n         pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n         pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n+        pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n \n         /* Operations on struct types */\n         pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                       ElementTypes: *TypeRef,\n+                                       ElementTypes: *const TypeRef,\n                                        ElementCount: c_uint,\n                                        Packed: Bool)\n                                        -> TypeRef;\n@@ -436,7 +436,7 @@ pub mod llvm {\n         pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n         pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n         pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                      -> *();\n+                                      -> *const ();\n         pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n@@ -446,8 +446,8 @@ pub mod llvm {\n \n         /* Operations on all values */\n         pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-        pub fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n-        pub fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+        pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+        pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n         pub fn LLVMDumpValue(Val: ValueRef);\n         pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n         pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n@@ -482,32 +482,32 @@ pub mod llvm {\n \n         /* Operations on metadata */\n         pub fn LLVMMDStringInContext(C: ContextRef,\n-                                     Str: *c_char,\n+                                     Str: *const c_char,\n                                      SLen: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMMDNodeInContext(C: ContextRef,\n-                                   Vals: *ValueRef,\n+                                   Vals: *const ValueRef,\n                                    Count: c_uint)\n                                    -> ValueRef;\n         pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                           Str: *c_char,\n+                                           Str: *const c_char,\n                                            Val: ValueRef);\n \n         /* Operations on scalar constants */\n         pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n                             -> ValueRef;\n-        pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *c_char, Radix: u8)\n+        pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n                                     -> ValueRef;\n         pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                           Text: *c_char,\n+                                           Text: *const c_char,\n                                            SLen: c_uint,\n                                            Radix: u8)\n                                            -> ValueRef;\n         pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-        pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *c_char)\n+        pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                            Text: *c_char,\n+                                            Text: *const c_char,\n                                             SLen: c_uint)\n                                             -> ValueRef;\n         pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n@@ -516,21 +516,21 @@ pub mod llvm {\n \n         /* Operations on composite constants */\n         pub fn LLVMConstStringInContext(C: ContextRef,\n-                                        Str: *c_char,\n+                                        Str: *const c_char,\n                                         Length: c_uint,\n                                         DontNullTerminate: Bool)\n                                         -> ValueRef;\n         pub fn LLVMConstStructInContext(C: ContextRef,\n-                                        ConstantVals: *ValueRef,\n+                                        ConstantVals: *const ValueRef,\n                                         Count: c_uint,\n                                         Packed: Bool)\n                                         -> ValueRef;\n \n         pub fn LLVMConstArray(ElementTy: TypeRef,\n-                              ConstantVals: *ValueRef,\n+                              ConstantVals: *const ValueRef,\n                               Length: c_uint)\n                               -> ValueRef;\n-        pub fn LLVMConstVector(ScalarConstantVals: *ValueRef, Size: c_uint)\n+        pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n                                -> ValueRef;\n \n         /* Constant expressions */\n@@ -593,11 +593,11 @@ pub mod llvm {\n         pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n                              -> ValueRef;\n         pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                            ConstantIndices: *ValueRef,\n+                            ConstantIndices: *const ValueRef,\n                             NumIndices: c_uint)\n                             -> ValueRef;\n         pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                    ConstantIndices: *ValueRef,\n+                                    ConstantIndices: *const ValueRef,\n                                     NumIndices: c_uint)\n                                     -> ValueRef;\n         pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n@@ -654,17 +654,17 @@ pub mod llvm {\n                                       MaskConstant: ValueRef)\n                                       -> ValueRef;\n         pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                     IdxList: *c_uint,\n+                                     IdxList: *const c_uint,\n                                      NumIdx: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n                                     ElementValueConstant: ValueRef,\n-                                    IdxList: *c_uint,\n+                                    IdxList: *const c_uint,\n                                     NumIdx: c_uint)\n                                     -> ValueRef;\n         pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                                  AsmString: *c_char,\n-                                  Constraints: *c_char,\n+                                  AsmString: *const c_char,\n+                                  Constraints: *const c_char,\n                                   HasSideEffects: Bool,\n                                   IsAlignStack: Bool)\n                                   -> ValueRef;\n@@ -677,23 +677,23 @@ pub mod llvm {\n         pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n         pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-        pub fn LLVMGetSection(Global: ValueRef) -> *c_char;\n-        pub fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+        pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+        pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n         pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n         pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n         /* Operations on global variables */\n-        pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n                                            Ty: TypeRef,\n-                                           Name: *c_char,\n+                                           Name: *const c_char,\n                                            AddressSpace: c_uint)\n                                            -> ValueRef;\n-        pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n+        pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n         pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n@@ -711,37 +711,37 @@ pub mod llvm {\n         pub fn LLVMAddAlias(M: ModuleRef,\n                             Ty: TypeRef,\n                             Aliasee: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n \n         /* Operations on functions */\n         pub fn LLVMAddFunction(M: ModuleRef,\n-                               Name: *c_char,\n+                               Name: *const c_char,\n                                FunctionTy: TypeRef)\n                                -> ValueRef;\n-        pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n+        pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n         pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n         pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n         pub fn LLVMDeleteFunction(Fn: ValueRef);\n         pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n-                                       Name: *c_char,\n+                                       Name: *const c_char,\n                                        FunctionTy: TypeRef)\n                                        -> ValueRef;\n         pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n         pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n         pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-        pub fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n-        pub fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+        pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+        pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n         pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n-        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n+        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n         pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n \n         /* Operations on parameters */\n         pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+        pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n         pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n         pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n         pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n@@ -759,7 +759,7 @@ pub mod llvm {\n         pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n         pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n+        pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n         pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n@@ -768,11 +768,11 @@ pub mod llvm {\n \n         pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n                                              Fn: ValueRef,\n-                                             Name: *c_char)\n+                                             Name: *const c_char)\n                                              -> BasicBlockRef;\n         pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n                                              BB: BasicBlockRef,\n-                                             Name: *c_char)\n+                                             Name: *const c_char)\n                                              -> BasicBlockRef;\n         pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -816,8 +816,8 @@ pub mod llvm {\n \n         /* Operations on phi nodes */\n         pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                               IncomingValues: *ValueRef,\n-                               IncomingBlocks: *BasicBlockRef,\n+                               IncomingValues: *const ValueRef,\n+                               IncomingBlocks: *const BasicBlockRef,\n                                Count: c_uint);\n         pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n         pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n@@ -839,7 +839,7 @@ pub mod llvm {\n         pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n         pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n                                              Instr: ValueRef,\n-                                             Name: *c_char);\n+                                             Name: *const c_char);\n         pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n         pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n \n@@ -852,7 +852,7 @@ pub mod llvm {\n         pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n         pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n         pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                     RetVals: *ValueRef,\n+                                     RetVals: *const ValueRef,\n                                      N: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n@@ -872,17 +872,17 @@ pub mod llvm {\n                                    -> ValueRef;\n         pub fn LLVMBuildInvoke(B: BuilderRef,\n                                Fn: ValueRef,\n-                               Args: *ValueRef,\n+                               Args: *const ValueRef,\n                                NumArgs: c_uint,\n                                Then: BasicBlockRef,\n                                Catch: BasicBlockRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildLandingPad(B: BuilderRef,\n                                    Ty: TypeRef,\n                                    PersFn: ValueRef,\n                                    NumClauses: c_uint,\n-                                   Name: *c_char)\n+                                   Name: *const c_char)\n                                    -> ValueRef;\n         pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n         pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n@@ -905,369 +905,369 @@ pub mod llvm {\n         pub fn LLVMBuildAdd(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWAdd(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWAdd(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFAdd(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSub(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWSub(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWSub(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFSub(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildMul(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWMul(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWMul(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFMul(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildUDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildExactSDiv(B: BuilderRef,\n                                   LHS: ValueRef,\n                                   RHS: ValueRef,\n-                                  Name: *c_char)\n+                                  Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildFDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildURem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSRem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFRem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildShl(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildLShr(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildAShr(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildAnd(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildOr(B: BuilderRef,\n                            LHS: ValueRef,\n                            RHS: ValueRef,\n-                           Name: *c_char)\n+                           Name: *const c_char)\n                            -> ValueRef;\n         pub fn LLVMBuildXor(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildBinOp(B: BuilderRef,\n                               Op: Opcode,\n                               LHS: ValueRef,\n                               RHS: ValueRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n-        pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                             -> ValueRef;\n-        pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                              -> ValueRef;\n-        pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                             -> ValueRef;\n \n         /* Memory */\n-        pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildArrayMalloc(B: BuilderRef,\n                                     Ty: TypeRef,\n                                     Val: ValueRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n-        pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildArrayAlloca(B: BuilderRef,\n                                     Ty: TypeRef,\n                                     Val: ValueRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n         pub fn LLVMBuildLoad(B: BuilderRef,\n                              PointerVal: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n \n         pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n                               -> ValueRef;\n \n         pub fn LLVMBuildGEP(B: BuilderRef,\n                             Pointer: ValueRef,\n-                            Indices: *ValueRef,\n+                            Indices: *const ValueRef,\n                             NumIndices: c_uint,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n                                     Pointer: ValueRef,\n-                                    Indices: *ValueRef,\n+                                    Indices: *const ValueRef,\n                                     NumIndices: c_uint,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildStructGEP(B: BuilderRef,\n                                   Pointer: ValueRef,\n                                   Idx: c_uint,\n-                                  Name: *c_char)\n+                                  Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                     Str: *c_char,\n-                                     Name: *c_char)\n+                                     Str: *const c_char,\n+                                     Name: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                        Str: *c_char,\n-                                        Name: *c_char)\n+                                        Str: *const c_char,\n+                                        Name: *const c_char)\n                                         -> ValueRef;\n \n         /* Casts */\n         pub fn LLVMBuildTrunc(B: BuilderRef,\n                               Val: ValueRef,\n                               DestTy: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildZExt(B: BuilderRef,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSExt(B: BuilderRef,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFPToUI(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFPToSI(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildUIToFP(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildSIToFP(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFPTrunc(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildFPExt(B: BuilderRef,\n                               Val: ValueRef,\n                               DestTy: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildPtrToInt(B: BuilderRef,\n                                  Val: ValueRef,\n                                  DestTy: TypeRef,\n-                                 Name: *c_char)\n+                                 Name: *const c_char)\n                                  -> ValueRef;\n         pub fn LLVMBuildIntToPtr(B: BuilderRef,\n                                  Val: ValueRef,\n                                  DestTy: TypeRef,\n-                                 Name: *c_char)\n+                                 Name: *const c_char)\n                                  -> ValueRef;\n         pub fn LLVMBuildBitCast(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n-                                       Name: *c_char)\n+                                       Name: *const c_char)\n                                        -> ValueRef;\n         pub fn LLVMBuildCast(B: BuilderRef,\n                              Op: Opcode,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char) -> ValueRef;\n+                             Name: *const c_char) -> ValueRef;\n         pub fn LLVMBuildPointerCast(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildIntCast(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildFPCast(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n \n         /* Comparisons */\n         pub fn LLVMBuildICmp(B: BuilderRef,\n                              Op: c_uint,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFCmp(B: BuilderRef,\n                              Op: c_uint,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n \n         /* Miscellaneous instructions */\n-        pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildCall(B: BuilderRef,\n                              Fn: ValueRef,\n-                             Args: *ValueRef,\n+                             Args: *const ValueRef,\n                              NumArgs: c_uint,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSelect(B: BuilderRef,\n                                If: ValueRef,\n                                Then: ValueRef,\n                                Else: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildVAArg(B: BuilderRef,\n                               list: ValueRef,\n                               Ty: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildExtractElement(B: BuilderRef,\n                                        VecVal: ValueRef,\n                                        Index: ValueRef,\n-                                       Name: *c_char)\n+                                       Name: *const c_char)\n                                        -> ValueRef;\n         pub fn LLVMBuildInsertElement(B: BuilderRef,\n                                       VecVal: ValueRef,\n                                       EltVal: ValueRef,\n                                       Index: ValueRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildShuffleVector(B: BuilderRef,\n                                       V1: ValueRef,\n                                       V2: ValueRef,\n                                       Mask: ValueRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildExtractValue(B: BuilderRef,\n                                      AggVal: ValueRef,\n                                      Index: c_uint,\n-                                     Name: *c_char)\n+                                     Name: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMBuildInsertValue(B: BuilderRef,\n                                     AggVal: ValueRef,\n                                     EltVal: ValueRef,\n                                     Index: c_uint,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n \n-        pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildPtrDiff(B: BuilderRef,\n                                 LHS: ValueRef,\n                                 RHS: ValueRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n \n         /* Atomic Operations */\n         pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n                                    PointerVal: ValueRef,\n-                                   Name: *c_char,\n+                                   Name: *const c_char,\n                                    Order: AtomicOrdering,\n                                    Alignment: c_uint)\n                                    -> ValueRef;\n@@ -1302,10 +1302,10 @@ pub mod llvm {\n         pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n \n         /** Writes a module to the specified path. Returns 0 on success. */\n-        pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n+        pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n \n         /** Creates target data from a target layout string. */\n-        pub fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n+        pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n         /// Adds the target data to the given pass manager. The pass manager\n         /// references the target data only weakly.\n         pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n@@ -1464,42 +1464,42 @@ pub mod llvm {\n         /** Returns the current section size. */\n         pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n         /** Returns the current section contents as a string buffer. */\n-        pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n+        pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n \n         /** Reads the given file and returns it as a memory buffer. Use\n             LLVMDisposeMemoryBuffer() to get rid of it. */\n-        pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char)\n+        pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n             -> MemoryBufferRef;\n         /** Borrows the contents of the memory buffer (doesn't copy it) */\n-        pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *c_char,\n+        pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n                                                      InputDataLength: size_t,\n-                                                     BufferName: *c_char,\n+                                                     BufferName: *const c_char,\n                                                      RequiresNull: Bool)\n             -> MemoryBufferRef;\n-        pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *c_char,\n+        pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n                                                          InputDataLength: size_t,\n-                                                         BufferName: *c_char)\n+                                                         BufferName: *const c_char)\n             -> MemoryBufferRef;\n \n         pub fn LLVMIsMultithreaded() -> Bool;\n         pub fn LLVMStartMultithreaded() -> Bool;\n \n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n-        pub fn LLVMRustGetLastError() -> *c_char;\n+        pub fn LLVMRustGetLastError() -> *const c_char;\n \n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n \n-        pub fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n+        pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n \n         pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                                 ElementTypes: *TypeRef,\n+                                 ElementTypes: *const TypeRef,\n                                  ElementCount: c_uint,\n                                  Packed: Bool);\n \n         pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                    ConstantVals: *ValueRef,\n+                                    ConstantVals: *const ValueRef,\n                                     Count: c_uint)\n                                     -> ValueRef;\n \n@@ -1508,8 +1508,8 @@ pub mod llvm {\n \n         /** Prepares inline assembly. */\n         pub fn LLVMInlineAsm(Ty: TypeRef,\n-                             AsmString: *c_char,\n-                             Constraints: *c_char,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n                              SideEffects: Bool,\n                              AlignStack: Bool,\n                              Dialect: c_uint)\n@@ -1518,7 +1518,7 @@ pub mod llvm {\n         pub static LLVMRustDebugMetadataVersion: u32;\n \n         pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                     name: *c_char,\n+                                     name: *const c_char,\n                                      value: u32);\n \n         pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n@@ -1529,17 +1529,17 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n                                               Lang: c_uint,\n-                                              File: *c_char,\n-                                              Dir: *c_char,\n-                                              Producer: *c_char,\n+                                              File: *const c_char,\n+                                              Dir: *const c_char,\n+                                              Producer: *const c_char,\n                                               isOptimized: bool,\n-                                              Flags: *c_char,\n+                                              Flags: *const c_char,\n                                               RuntimeVer: c_uint,\n-                                              SplitName: *c_char);\n+                                              SplitName: *const c_char);\n \n         pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                       Filename: *c_char,\n-                                       Directory: *c_char)\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n                                        -> DIFile;\n \n         pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n@@ -1549,8 +1549,8 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n                                            Scope: DIDescriptor,\n-                                           Name: *c_char,\n-                                           LinkageName: *c_char,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n                                            File: DIFile,\n                                            LineNo: c_uint,\n                                            Ty: DIType,\n@@ -1565,7 +1565,7 @@ pub mod llvm {\n                                            -> DISubprogram;\n \n         pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             SizeInBits: c_ulonglong,\n                                             AlignInBits: c_ulonglong,\n                                             Encoding: c_uint)\n@@ -1575,12 +1575,12 @@ pub mod llvm {\n                                               PointeeTy: DIType,\n                                               SizeInBits: c_ulonglong,\n                                               AlignInBits: c_ulonglong,\n-                                              Name: *c_char)\n+                                              Name: *const c_char)\n                                               -> DIDerivedType;\n \n         pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n                                              Scope: DIDescriptor,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              File: DIFile,\n                                              LineNumber: c_uint,\n                                              SizeInBits: c_ulonglong,\n@@ -1590,12 +1590,12 @@ pub mod llvm {\n                                              Elements: DIArray,\n                                              RunTimeLang: c_uint,\n                                              VTableHolder: ValueRef,\n-                                             UniqueId: *c_char)\n+                                             UniqueId: *const c_char)\n                                              -> DICompositeType;\n \n         pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n                                              Scope: DIDescriptor,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              File: DIFile,\n                                              LineNo: c_uint,\n                                              SizeInBits: c_ulonglong,\n@@ -1615,8 +1615,8 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n                                                  Context: DIDescriptor,\n-                                                 Name: *c_char,\n-                                                 LinkageName: *c_char,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n                                                  File: DIFile,\n                                                  LineNo: c_uint,\n                                                  Ty: DIType,\n@@ -1628,7 +1628,7 @@ pub mod llvm {\n         pub fn LLVMDIBuilderCreateLocalVariable(Builder: DIBuilderRef,\n                                                 Tag: c_uint,\n                                                 Scope: DIDescriptor,\n-                                                Name: *c_char,\n+                                                Name: *const c_char,\n                                                 File: DIFile,\n                                                 LineNo: c_uint,\n                                                 Ty: DIType,\n@@ -1657,7 +1657,7 @@ pub mod llvm {\n                                                 -> DISubrange;\n \n         pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                             Ptr: *DIDescriptor,\n+                                             Ptr: *const DIDescriptor,\n                                              Count: c_uint)\n                                              -> DIArray;\n \n@@ -1674,13 +1674,13 @@ pub mod llvm {\n                                                 -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              Val: c_ulonglong)\n                                              -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n                                                   Scope: ValueRef,\n-                                                  Name: *c_char,\n+                                                  Name: *const c_char,\n                                                   File: ValueRef,\n                                                   LineNumber: c_uint,\n                                                   SizeInBits: c_ulonglong,\n@@ -1691,22 +1691,22 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n                                             Scope: ValueRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             File: ValueRef,\n                                             LineNumber: c_uint,\n                                             SizeInBits: c_ulonglong,\n                                             AlignInBits: c_ulonglong,\n                                             Flags: c_uint,\n                                             Elements: ValueRef,\n                                             RunTimeLang: c_uint,\n-                                            UniqueId: *c_char)\n+                                            UniqueId: *const c_char)\n                                             -> ValueRef;\n \n         pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n \n         pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n                                                         Scope: ValueRef,\n-                                                        Name: *c_char,\n+                                                        Name: *const c_char,\n                                                         Ty: ValueRef,\n                                                         File: ValueRef,\n                                                         LineNo: c_uint,\n@@ -1720,25 +1720,25 @@ pub mod llvm {\n         pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n             Tag: c_uint,\n             Scope: ValueRef,\n-            Name: *c_char,\n+            Name: *const c_char,\n             File: ValueRef,\n             LineNo: c_uint,\n             Ty: ValueRef,\n-            AddrOps: *ValueRef,\n+            AddrOps: *const ValueRef,\n             AddrOpsCount: c_uint,\n             ArgNo: c_uint)\n             -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n                                             Scope: ValueRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             File: ValueRef,\n                                             LineNo: c_uint)\n                                             -> ValueRef;\n \n         pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n-        pub fn LLVMTypeToString(Type: TypeRef) -> *c_char;\n-        pub fn LLVMValueToString(value_ref: ValueRef) -> *c_char;\n+        pub fn LLVMTypeToString(Type: TypeRef) -> *const c_char;\n+        pub fn LLVMValueToString(value_ref: ValueRef) -> *const c_char;\n \n         pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n@@ -1760,10 +1760,10 @@ pub mod llvm {\n         pub fn LLVMInitializeMipsAsmPrinter();\n         pub fn LLVMInitializeMipsAsmParser();\n \n-        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *c_char) -> bool;\n-        pub fn LLVMRustCreateTargetMachine(Triple: *c_char,\n-                                           CPU: *c_char,\n-                                           Features: *c_char,\n+        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *const c_char) -> bool;\n+        pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                           CPU: *const c_char,\n+                                           Features: *const c_char,\n                                            Model: CodeGenModel,\n                                            Reloc: RelocMode,\n                                            Level: CodeGenOptLevel,\n@@ -1785,35 +1785,35 @@ pub mod llvm {\n         pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n                                        PM: PassManagerRef,\n                                        M: ModuleRef,\n-                                       Output: *c_char,\n+                                       Output: *const c_char,\n                                        FileType: FileType) -> bool;\n         pub fn LLVMRustPrintModule(PM: PassManagerRef,\n                                    M: ModuleRef,\n-                                   Output: *c_char);\n-        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: **c_char);\n+                                   Output: *const c_char);\n+        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n         pub fn LLVMRustPrintPasses();\n-        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n+        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n         pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n                                            AddLifetimes: bool);\n         pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                             bc: *c_char,\n+                                             bc: *const c_char,\n                                              len: size_t) -> bool;\n         pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                          syms: **c_char,\n+                                          syms: *const *const c_char,\n                                           len: size_t);\n         pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n-        pub fn LLVMRustOpenArchive(path: *c_char) -> ArchiveRef;\n-        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *c_char,\n-                                          out_len: *mut size_t) -> *c_char;\n+        pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n+                                          out_len: *mut size_t) -> *const c_char;\n         pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n         pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n         pub fn LLVMVersionMajor() -> c_int;\n         pub fn LLVMVersionMinor() -> c_int;\n \n         pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                      data: *mut *c_char) -> c_int;\n+                                      data: *mut *const c_char) -> c_int;\n     }\n }\n "}, {"sha": "30296cb318617af1fdc0a544374596a44e5a37c8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -30,7 +30,7 @@ use middle::def::*;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n-use middle::{typeck, ty, def, pat_util};\n+use middle::{typeck, ty, def, pat_util, stability};\n use util::ppaux::{ty_to_str};\n use util::nodemap::NodeSet;\n use lint::{Context, LintPass, LintArray};\n@@ -391,8 +391,8 @@ pub struct HeapMemory;\n \n impl HeapMemory {\n     fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n-        let mut n_box = 0;\n-        let mut n_uniq = 0;\n+        let mut n_box = 0i;\n+        let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {\n                 ty::ty_box(_) => {\n@@ -975,14 +975,52 @@ declare_lint!(UNNECESSARY_PARENS, Warn,\n pub struct UnnecessaryParens;\n \n impl UnnecessaryParens {\n-    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n+    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n+                                     struct_lit_needs_parens: bool) {\n         match value.node {\n-            ast::ExprParen(_) => {\n-                cx.span_lint(UNNECESSARY_PARENS, value.span,\n-                    format!(\"unnecessary parentheses around {}\", msg).as_slice())\n+            ast::ExprParen(ref inner) => {\n+                let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+                if !necessary {\n+                    cx.span_lint(UNNECESSARY_PARENS, value.span,\n+                                 format!(\"unnecessary parentheses around {}\",\n+                                         msg).as_slice())\n+                }\n             }\n             _ => {}\n         }\n+\n+        /// Expressions that syntatically contain an \"exterior\" struct\n+        /// literal i.e. not surrounded by any parens or other\n+        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n+        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n+        /// y: 1 }) == foo` does not.\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+            match value.node {\n+                ast::ExprStruct(..) => true,\n+\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                    // X { y: 1 } + X { y: 2 }\n+                    contains_exterior_struct_lit(&**lhs) ||\n+                        contains_exterior_struct_lit(&**rhs)\n+                }\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _, _) |\n+                ast::ExprIndex(ref x, _) => {\n+                    // &X { y: 1 }, X { y: 1 }.y\n+                    contains_exterior_struct_lit(&**x)\n+                }\n+\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n+                    // X { y: 1 }.bar(...)\n+                    contains_exterior_struct_lit(&**exprs.get(0))\n+                }\n+\n+                _ => false\n+            }\n+        }\n     }\n }\n \n@@ -992,16 +1030,16 @@ impl LintPass for UnnecessaryParens {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let (value, msg) = match e.node {\n-            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n-            ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n-            ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n-            ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n-            ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n+        let (value, msg, struct_lit_needs_parens) = match e.node {\n+            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(cond, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(head, _) => (head, \"`match` head expression\", true),\n+            ast::ExprRet(Some(value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\", false),\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg);\n+        self.check_unnecessary_parens_core(cx, &*value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -1015,7 +1053,7 @@ impl LintPass for UnnecessaryParens {\n             },\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg);\n+        self.check_unnecessary_parens_core(cx, &*value, msg, false);\n     }\n }\n \n@@ -1388,11 +1426,7 @@ impl LintPass for Stability {\n                     Some(method) => {\n                         match method.origin {\n                             typeck::MethodStatic(def_id) => {\n-                                // If this implements a trait method, get def_id\n-                                // of the method inside trait definition.\n-                                // Otherwise, use the current def_id (which refers\n-                                // to the method inside impl).\n-                                ty::trait_method_of_method(cx.tcx, def_id).unwrap_or(def_id)\n+                                def_id\n                             }\n                             typeck::MethodParam(typeck::MethodParam {\n                                 trait_id: trait_id,\n@@ -1416,8 +1450,7 @@ impl LintPass for Stability {\n         // check anything for crate-local usage.\n         if ast_util::is_local(id) { return }\n \n-        let stability = cx.tcx.stability.borrow_mut().lookup(&cx.tcx.sess.cstore, id);\n-\n+        let stability = stability::lookup(cx.tcx, id);\n         let (lint, label) = match stability {\n             // no stability attributes == Unstable\n             None => (UNSTABLE, \"unmarked\"),"}, {"sha": "8896a068baa76b992f80bf708cd8d4ab59371f05", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -176,15 +176,15 @@ pub struct LintId {\n \n impl PartialEq for LintId {\n     fn eq(&self, other: &LintId) -> bool {\n-        (self.lint as *Lint) == (other.lint as *Lint)\n+        (self.lint as *const Lint) == (other.lint as *const Lint)\n     }\n }\n \n impl Eq for LintId { }\n \n impl<S: hash::Writer> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n-        let ptr = self.lint as *Lint;\n+        let ptr = self.lint as *const Lint;\n         ptr.hash(state);\n     }\n }"}, {"sha": "78a29b52bdf5bc45974f05b5adf5bfe4ffc7d88b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -181,7 +181,7 @@ fn item_sized(item: ebml::Doc) -> ast::Sized {\n fn item_method_sort(item: ebml::Doc) -> char {\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n-        ret = doc.as_str_slice()[0] as char;\n+        ret = doc.as_str_slice().as_bytes()[0] as char;\n         false\n     });\n     ret\n@@ -757,13 +757,13 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n     let string = explicit_self_doc.as_str_slice();\n \n-    let explicit_self_kind = string[0];\n+    let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n         'v' => ast::SelfValue,\n         '~' => ast::SelfUniq,\n         // FIXME(#4846) expl. region\n-        '&' => ast::SelfRegion(None, get_mutability(string[1])),\n+        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1])),\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }"}, {"sha": "96284f8de261a78254f0faa3ff837c660049cf2b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -24,6 +24,7 @@ use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::astencode;\n use middle::ty;\n use middle::typeck;\n+use middle::stability;\n use middle;\n use util::nodemap::{NodeMap, NodeSet};\n \n@@ -328,7 +329,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_visibility(ebml_w, variant.node.vis);\n         encode_attributes(ebml_w, variant.node.attrs.as_slice());\n \n-        let stab = ecx.tcx.stability.borrow().lookup_local(variant.node.id);\n+        let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(ebml_w, stab);\n \n         match variant.node.kind {\n@@ -592,7 +593,9 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     encode_path(ebml_w, path.clone());\n     encode_visibility(ebml_w, vis);\n-    encode_stability(ebml_w, ecx.tcx.stability.borrow().lookup_local(id));\n+\n+    let stab = stability::lookup(ecx.tcx, ast_util::local_def(id));\n+    encode_stability(ebml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == Public {\n@@ -722,7 +725,8 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n         encode_symbol(ecx, ebml_w, ctor_id);\n     }\n \n-    encode_stability(ebml_w, ecx.tcx.stability.borrow().lookup_local(ctor_id));\n+    let stab = stability::lookup(ecx.tcx, ast_util::local_def(ctor_id));\n+    encode_stability(ebml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n@@ -768,7 +772,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     encode_method_ty_fields(ecx, ebml_w, m);\n     encode_parent_item(ebml_w, local_def(parent_id));\n \n-    let stab = ecx.tcx.stability.borrow().lookup_local(m.def_id.node);\n+    let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(ebml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n@@ -915,10 +919,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n \n     debug!(\"encoding info for item at {}\",\n-           ecx.tcx.sess.codemap().span_to_str(item.span));\n+           tcx.sess.codemap().span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n-    let stab = tcx.stability.borrow().lookup_local(item.id);\n+    let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n \n     match item.node {\n       ItemStatic(_, m, _) => {\n@@ -1206,7 +1210,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n             encode_parent_item(ebml_w, def_id);\n \n-            let stab = tcx.stability.borrow().lookup_local(method_def_id.node);\n+            let stab = stability::lookup(tcx, method_def_id);\n             encode_stability(ebml_w, stab);\n \n             let elem = ast_map::PathName(method_ty.ident.name);\n@@ -1308,7 +1312,7 @@ fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n                  ebml_w: &mut Encoder,\n-                 ecx_ptr: *int,\n+                 ecx_ptr: *const int,\n                  index: &mut Vec<entry<i64>>) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n@@ -1320,7 +1324,7 @@ fn my_visit_item(i: &Item,\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut Encoder,\n-                         ecx_ptr:*int,\n+                         ecx_ptr:*const int,\n                          index: &mut Vec<entry<i64>>) {\n     // See above\n     let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n@@ -1341,7 +1345,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n \n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx_ptr:*int,\n+    ecx_ptr:*const int,\n     index: &'a mut Vec<entry<i64>>,\n }\n \n@@ -1386,7 +1390,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         Public);\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr: *int = unsafe { mem::transmute(ecx) };\n+    let ecx_ptr: *const int = unsafe { mem::transmute(ecx) };\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n         ecx_ptr: ecx_ptr,"}, {"sha": "ccab76ca6f012d641250ceaa8f369e953a793ff1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -545,14 +545,15 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = str::raw::from_buf_len(name_buf as *u8, name_len as uint);\n+            let name = str::raw::from_buf_len(name_buf as *const u8,\n+                                              name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os).as_slice() == name.as_slice() {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found =\n                     Err(format!(\"metadata not found: '{}'\", filename.display()));\n-                let cvbuf: *u8 = mem::transmute(cbuf);\n+                let cvbuf: *const u8 = mem::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "19e7b9329b1ff218a9f25627766706e19732b98a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -943,7 +943,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n }\n \n struct SideTableEncodingIdVisitor<'a,'b> {\n-    ecx_ptr: *libc::c_void,\n+    ecx_ptr: *const libc::c_void,\n     new_ebml_w: &'a mut Encoder<'b>,\n }\n "}, {"sha": "e7457f370d9adea16253276cb4fa5bc0b9224758", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -399,7 +399,7 @@ struct DeadVisitor<'a> {\n impl<'a> DeadVisitor<'a> {\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let (is_named, has_leading_underscore) = match node.ident() {\n-            Some(ref ident) => (true, token::get_ident(*ident).get()[0] == ('_' as u8)),\n+            Some(ref ident) => (true, token::get_ident(*ident).get().as_bytes()[0] == ('_' as u8)),\n             _ => (false, false)\n         };\n         let field_type = ty::node_id_to_type(self.tcx, node.id);"}, {"sha": "5c09466cd96820bdfb686760caf70ba973302ba7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -360,7 +360,8 @@ fn visit_fn(ir: &mut IrMaps,\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n     unsafe {\n-        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n+        debug!(\"creating fn_maps: {}\",\n+               transmute::<&IrMaps, *const IrMaps>(&fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n@@ -1510,7 +1511,7 @@ impl<'a> Liveness<'a> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.len() == 0 || name.as_slice()[0] == ('_' as u8) {\n+        if name.len() == 0 || name.as_bytes()[0] == ('_' as u8) {\n             None\n         } else {\n             Some(name)"}, {"sha": "e1a2a5741fbe1b0d0e03ba62c41dd7666e647f6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -126,7 +126,6 @@ pub enum FieldName {\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum ElementKind {\n     VecElement,\n-    StrElement,\n     OtherElement,\n }\n \n@@ -794,7 +793,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         //! - `derefs`: the deref number to be used for\n         //!   the implicit index deref, if any (see above)\n \n-        let element_ty = match ty::index(base_cmt.ty) {\n+        let element_ty = match ty::array_element_ty(base_cmt.ty) {\n           Some(ref mt) => mt.ty,\n           None => {\n             self.tcx().sess.span_bug(\n@@ -1137,9 +1136,6 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           cat_interior(_, InteriorElement(VecElement)) => {\n               \"vec content\".to_string()\n           }\n-          cat_interior(_, InteriorElement(StrElement)) => {\n-              \"str content\".to_string()\n-          }\n           cat_interior(_, InteriorElement(OtherElement)) => {\n               \"indexed content\".to_string()\n           }\n@@ -1320,7 +1316,6 @@ fn element_kind(t: ty::t) -> ElementKind {\n         ty::ty_rptr(_, ty::mt{ty:ty, ..}) |\n         ty::ty_uniq(ty) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) => VecElement,\n-            ty::ty_str => StrElement,\n             _ => OtherElement\n         },\n         ty::ty_vec(..) => VecElement,"}, {"sha": "57006d5e72b9b632b60e469c1f65ab0af8c16cdf", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -90,7 +90,7 @@ impl<'a> SpanUtils<'a> {\n         let mut result = None;\n \n         let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0u;\n         loop {\n             let ts = toks.next_token();\n             if ts.tok == token::EOF {\n@@ -113,7 +113,7 @@ impl<'a> SpanUtils<'a> {\n     // Return the span for the first identifier in the path.\n     pub fn span_for_first_ident(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0u;\n         loop {\n             let ts = toks.next_token();\n             if ts.tok == token::EOF {\n@@ -139,7 +139,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.next_token();\n         let mut result = None;\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0u;\n         let mut last_span = None;\n         while prev.tok != token::EOF {\n             last_span = None;\n@@ -187,7 +187,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.next_token();\n         let mut result = None;\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0u;\n         loop {\n             let next = toks.next_token();\n \n@@ -232,7 +232,7 @@ impl<'a> SpanUtils<'a> {\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0i;\n         loop {\n             let ts = toks.next_token();\n             if ts.tok == token::EOF {\n@@ -291,7 +291,7 @@ impl<'a> SpanUtils<'a> {\n         let mut next = toks.next_token();\n         let mut stored_val = false;\n         let mut found_val = false;\n-        let mut bracket_count = 0;\n+        let mut bracket_count = 0u;\n         while next.tok != token::EOF {\n             if bracket_count == 1 {\n                 if next.tok == tok2 {"}, {"sha": "ac17bd07503521212b46b40f71055095d86649e3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -20,7 +20,8 @@ use syntax::ast::{Generics, StructDef, Ident};\n use syntax::ast_util::is_local;\n use syntax::attr::Stability;\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use metadata::{cstore, csearch};\n+use middle::ty;\n+use metadata::csearch;\n \n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n@@ -105,21 +106,24 @@ impl Index {\n                           attr::find_stability(krate.attrs.as_slice()));\n         annotator.index\n     }\n+}\n \n-    /// Lookup the stability for a node, loading external crate\n-    /// metadata as necessary.\n-    pub fn lookup(&mut self, cstore: &cstore::CStore, id: DefId) -> Option<Stability> {\n-        if is_local(id) {\n-            self.lookup_local(id.node)\n-        } else {\n-            let stab = csearch::get_stability(cstore, id);\n-            self.extern_cache.insert(id, stab.clone());\n+/// Lookup the stability for a node, loading external crate\n+/// metadata as necessary.\n+pub fn lookup(tcx: &ty::ctxt,  id: DefId) -> Option<Stability> {\n+    // is this definition the implementation of a trait method?\n+    match ty::trait_method_of_method(tcx, id) {\n+        Some(trait_method_id) if trait_method_id != id => {\n+            lookup(tcx, trait_method_id)\n+        }\n+        _ if is_local(id) => {\n+            tcx.stability.borrow().local.find_copy(&id.node)\n+        }\n+        _ => {\n+            let stab = csearch::get_stability(&tcx.sess.cstore, id);\n+            let mut index = tcx.stability.borrow_mut();\n+            (*index).extern_cache.insert(id, stab.clone());\n             stab\n         }\n     }\n-\n-    /// Lookup the stability for a local node without loading any external crates\n-    pub fn lookup_local(&self, id: NodeId) -> Option<Stability> {\n-        self.local.find_copy(&id)\n-    }\n }"}, {"sha": "0cd3b6e7d79184ee8dd9f1f737e278ae0d7cba6e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -44,15 +44,15 @@ impl<T> HomogeneousTuple3<T> for (T, T, T) {\n \n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n-            let ptr: *T = mem::transmute(self);\n+            let ptr: *const T = mem::transmute(self);\n             let slice = raw::Slice { data: ptr, len: 3 };\n             mem::transmute(slice)\n         }\n     }\n \n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            let ptr: *T = mem::transmute(self);\n+            let ptr: *const T = mem::transmute(self);\n             let slice = raw::Slice { data: ptr, len: 3 };\n             mem::transmute(slice)\n         }"}, {"sha": "75271804b7911b32be2380cbfffc9d8015e824dc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -1220,7 +1220,7 @@ pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n+pub fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n     use middle::trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {"}, {"sha": "e1c02f543bf9e7c4ee2046012efeeeb5ce3c69cc", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -453,7 +453,7 @@ pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     }\n }\n \n-pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -462,7 +462,7 @@ pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n     }\n }\n \n-pub fn GlobalStringPtr(cx: &Block, _str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -577,7 +577,8 @@ pub fn TruncOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type, _: *u8)\n+pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n+            _: *const u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n@@ -636,7 +637,8 @@ pub fn EmptyPhi(cx: &Block, ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef],\n+           bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).phi(ty, vals, bbs)\n@@ -672,7 +674,7 @@ pub fn add_comment(cx: &Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n+pub fn InlineAsmCall(cx: &Block, asm: *const c_char, cons: *const c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {"}, {"sha": "a9c1adac3d7cf01e07c3926d4706708e8a087367", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -31,9 +31,9 @@ pub struct Builder<'a> {\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-pub fn noname() -> *c_char {\n+pub fn noname() -> *const c_char {\n     static cnull: c_char = 0;\n-    &cnull as *c_char\n+    &cnull as *const c_char\n }\n \n impl<'a> Builder<'a> {\n@@ -159,6 +159,14 @@ impl<'a> Builder<'a> {\n                   attributes: &[(uint, u64)])\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n+\n+        debug!(\"Invoke {} with args ({})\",\n+               self.ccx.tn.val_to_str(llfn),\n+               args.iter()\n+                   .map(|&v| self.ccx.tn.val_to_str(v))\n+                   .collect::<Vec<String>>()\n+                   .connect(\", \"));\n+\n         unsafe {\n             let v = llvm::LLVMBuildInvoke(self.llbuilder,\n                                           llfn,\n@@ -564,14 +572,14 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn global_string(&self, _str: *c_char) -> ValueRef {\n+    pub fn global_string(&self, _str: *const c_char) -> ValueRef {\n         self.count_insn(\"globalstring\");\n         unsafe {\n             llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n         }\n     }\n \n-    pub fn global_string_ptr(&self, _str: *c_char) -> ValueRef {\n+    pub fn global_string_ptr(&self, _str: *const c_char) -> ValueRef {\n         self.count_insn(\"globalstringptr\");\n         unsafe {\n             llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n@@ -774,7 +782,7 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn inline_asm_call(&self, asm: *c_char, cons: *c_char,\n+    pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n                          inputs: &[ValueRef], output: Type,\n                          volatile: bool, alignstack: bool,\n                          dia: AsmDialect) -> ValueRef {"}, {"sha": "116b2e6b421b81e41e1c5a94064853528c57897a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 134, "deletions": 6, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -16,7 +16,9 @@\n  * closure.\n  */\n \n+use arena::TypedArena;\n use back::abi;\n+use back::link;\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n@@ -33,28 +35,26 @@ use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n-use middle::trans::datum::Datum;\n+use middle::trans::datum::{Datum, KindOps};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::inline;\n+use middle::trans::foreign;\n use middle::trans::meth;\n use middle::trans::monomorphize;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n-use middle::trans::foreign;\n use middle::ty;\n use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n \n-use middle::trans::type_::Type;\n-\n+use std::gc::Gc;\n use syntax::ast;\n use synabi = syntax::abi;\n use syntax::ast_map;\n \n-use std::gc::Gc;\n-\n pub struct MethodData {\n     pub llfn: ValueRef,\n     pub llself: ValueRef,\n@@ -224,6 +224,134 @@ fn resolve_default_method_vtables(bcx: &Block,\n     param_vtables\n }\n \n+/// Translates the adapter that deconstructs a `Box<Trait>` object into\n+/// `Trait` so that a by-value self method can be called.\n+pub fn trans_unboxing_shim(bcx: &Block,\n+                           llshimmedfn: ValueRef,\n+                           method: &ty::Method,\n+                           method_id: ast::DefId,\n+                           substs: subst::Substs)\n+                           -> ValueRef {\n+    let _icx = push_ctxt(\"trans_unboxing_shim\");\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n+\n+    // Transform the self type to `Box<self_type>`.\n+    let self_type = *method.fty.sig.inputs.get(0);\n+    let boxed_self_type = ty::mk_uniq(tcx, self_type);\n+    let boxed_function_type = ty::FnSig {\n+        binder_id: method.fty.sig.binder_id,\n+        inputs: method.fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n+            if i == 0 {\n+                boxed_self_type\n+            } else {\n+                *typ\n+            }\n+        }).collect(),\n+        output: method.fty.sig.output,\n+        variadic: false,\n+    };\n+    let boxed_function_type = ty::BareFnTy {\n+        fn_style: method.fty.fn_style,\n+        abi: method.fty.abi,\n+        sig: boxed_function_type,\n+    };\n+    let boxed_function_type =\n+        ty::mk_bare_fn(tcx, boxed_function_type).subst(tcx, &substs);\n+    let function_type =\n+        ty::mk_bare_fn(tcx, method.fty.clone()).subst(tcx, &substs);\n+\n+    let function_name = tcx.map.with_path(method_id.node, |path| {\n+        link::mangle_internal_name_by_path_and_seq(path, \"unboxing_shim\")\n+    });\n+    let llfn = decl_internal_rust_fn(ccx,\n+                                     boxed_function_type,\n+                                     function_name.as_slice());\n+\n+    let block_arena = TypedArena::new();\n+    let empty_param_substs = param_substs::empty();\n+    let return_type = ty::ty_fn_ret(boxed_function_type);\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          -1,\n+                          false,\n+                          return_type,\n+                          &empty_param_substs,\n+                          None,\n+                          &block_arena);\n+    init_function(&fcx, false, return_type);\n+\n+    // Create the substituted versions of the self type.\n+    let mut bcx = fcx.entry_bcx.borrow().clone().unwrap();\n+    let arg_scope = fcx.push_custom_cleanup_scope();\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n+    let boxed_arg_types = ty::ty_fn_args(boxed_function_type);\n+    let boxed_self_type = *boxed_arg_types.get(0);\n+    let arg_types = ty::ty_fn_args(function_type);\n+    let self_type = *arg_types.get(0);\n+    let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n+\n+    // Create a datum for self.\n+    let llboxedself = unsafe {\n+        llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(0) as u32)\n+    };\n+    let llboxedself = Datum::new(llboxedself,\n+                                 boxed_self_type,\n+                                 boxed_self_kind);\n+    let boxed_self =\n+        unpack_datum!(bcx,\n+                      llboxedself.to_lvalue_datum_in_scope(bcx,\n+                                                           \"boxedself\",\n+                                                           arg_scope_id));\n+\n+    // This `Load` is needed because lvalue data are always by-ref.\n+    let llboxedself = Load(bcx, boxed_self.val);\n+\n+    let llself = if type_is_immediate(ccx, self_type) {\n+        let llboxedself = Load(bcx, llboxedself);\n+        immediate_rvalue(llboxedself, self_type)\n+    } else {\n+        let llself = rvalue_scratch_datum(bcx, self_type, \"self\");\n+        memcpy_ty(bcx, llself.val, llboxedself, self_type);\n+        llself\n+    };\n+\n+    // Make sure we don't free the box twice!\n+    boxed_self.kind.post_store(bcx, boxed_self.val, boxed_self_type);\n+\n+    // Schedule a cleanup to free the box.\n+    fcx.schedule_free_value(arg_scope_id,\n+                            llboxedself,\n+                            cleanup::HeapExchange,\n+                            self_type);\n+\n+    // Now call the function.\n+    let mut llshimmedargs = vec!(llself.val);\n+    for i in range(1, arg_types.len()) {\n+        llshimmedargs.push(unsafe {\n+            llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as u32)\n+        });\n+    }\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           function_type,\n+                           |bcx, _| {\n+                               Callee {\n+                                   bcx: bcx,\n+                                   data: Fn(llshimmedfn),\n+                               }\n+                           },\n+                           ArgVals(llshimmedargs.as_slice()),\n+                           match fcx.llretptr.get() {\n+                               None => None,\n+                               Some(llretptr) => Some(expr::SaveIn(llretptr)),\n+                           }).bcx;\n+\n+    bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n+    finish_fn(&fcx, bcx);\n+\n+    llfn\n+}\n \n pub fn trans_fn_ref_with_vtables(\n     bcx: &Block,                 //"}, {"sha": "b1577a6abfe1452f461a3a59c20ebb388424ad2a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -471,7 +471,7 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn to_str(&self) -> String {\n-        let blk: *Block = self;\n+        let blk: *const Block = self;\n         format!(\"[block {}]\", blk)\n     }\n }\n@@ -568,7 +568,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.get().as_ptr() as *c_char,\n+                                                s.get().as_ptr() as *const c_char,\n                                                 s.get().len() as c_uint,\n                                                 !null_terminated as Bool);\n \n@@ -636,7 +636,7 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n \n pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        let ptr = bytes.as_ptr() as *c_char;\n+        let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n     }\n }"}, {"sha": "6387ec791bab93d6b5f4c5c9698c718ad2db55b3", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -221,8 +221,8 @@ impl CrateContext {\n                     llvm_insns: RefCell::new(HashMap::new()),\n                     fn_stats: RefCell::new(Vec::new()),\n                 },\n-                int_type: Type::from_ref(ptr::null()),\n-                opaque_vec_type: Type::from_ref(ptr::null()),\n+                int_type: Type::from_ref(ptr::mut_null()),\n+                opaque_vec_type: Type::from_ref(ptr::mut_null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,"}, {"sha": "400babb39f82cc12b8dee9be88cee6794947de08", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -805,7 +805,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                         type_metadata,\n                                                         is_local_to_unit,\n                                                         global,\n-                                                        ptr::null());\n+                                                        ptr::mut_null());\n             }\n         })\n     });\n@@ -980,7 +980,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::mut_null() {\n             cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n@@ -1221,7 +1221,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     cx.sess().opts.optimize != config::No,\n                     llfn,\n                     template_parameters,\n-                    ptr::null())\n+                    ptr::mut_null())\n             }\n         })\n     });\n@@ -1257,7 +1257,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n             ast::TyNil => {\n-                signature.push(ptr::null());\n+                signature.push(ptr::mut_null());\n             }\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n@@ -1328,7 +1328,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_self_type_metadata,\n-                            ptr::null(),\n+                            ptr::mut_null(),\n                             0,\n                             0)\n                     }\n@@ -1361,7 +1361,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_type_metadata,\n-                            ptr::null(),\n+                            ptr::mut_null(),\n                             0,\n                             0)\n                     }\n@@ -1433,24 +1433,23 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     let producer = format!(\"rustc version {}\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n-    compile_unit_name.with_ref(|compile_unit_name| {\n-        work_dir.as_vec().with_c_str(|work_dir| {\n-            producer.with_c_str(|producer| {\n-                \"\".with_c_str(|flags| {\n-                    \"\".with_c_str(|split_name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateCompileUnit(\n-                                debug_context(cx).builder,\n-                                DW_LANG_RUST,\n-                                compile_unit_name,\n-                                work_dir,\n-                                producer,\n-                                cx.sess().opts.optimize != config::No,\n-                                flags,\n-                                0,\n-                                split_name);\n-                        }\n-                    })\n+    let compile_unit_name = compile_unit_name.as_ptr();\n+    work_dir.as_vec().with_c_str(|work_dir| {\n+        producer.with_c_str(|producer| {\n+            \"\".with_c_str(|flags| {\n+                \"\".with_c_str(|split_name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateCompileUnit(\n+                            debug_context(cx).builder,\n+                            DW_LANG_RUST,\n+                            compile_unit_name,\n+                            work_dir,\n+                            producer,\n+                            cx.sess().opts.optimize != config::No,\n+                            flags,\n+                            0,\n+                            split_name);\n+                    }\n                 })\n             })\n         })\n@@ -2374,7 +2373,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 bytes_to_bits(enum_type_size),\n                 bytes_to_bits(enum_type_align),\n                 0, // Flags\n-                ptr::null(),\n+                ptr::mut_null(),\n                 0, // RuntimeLang\n                 unique_type_id_str)\n             }\n@@ -2554,10 +2553,10 @@ fn create_struct_stub(cx: &CrateContext,\n                     bytes_to_bits(struct_size),\n                     bytes_to_bits(struct_align),\n                     0,\n-                    ptr::null(),\n+                    ptr::mut_null(),\n                     empty_array,\n                     0,\n-                    ptr::null(),\n+                    ptr::mut_null(),\n                     unique_type_id)\n             })\n         })\n@@ -2855,7 +2854,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n-        ty::ty_nil => ptr::null(),\n+        ty::ty_nil => ptr::mut_null(),\n         _ => type_metadata(cx, signature.output, span)\n     });\n \n@@ -3153,7 +3152,8 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         KnownLocation { scope, line, .. } => {\n             let col = 0u; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n-            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32), scope, ptr::null()];\n+            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32),\n+                            scope, ptr::mut_null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n                                                           elements.as_ptr(),\n@@ -3162,7 +3162,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            metadata_node = ptr::null();\n+            metadata_node = ptr::mut_null();\n         }\n     };\n \n@@ -3771,7 +3771,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                     // create and insert\n                     let parent_scope = match parent_node {\n                         Some(ref node) => node.scope,\n-                        None => ptr::null()\n+                        None => ptr::mut_null()\n                     };\n                     let namespace_name = token::get_name(name);\n                     let scope = namespace_name.get().with_c_str(|namespace_name| {\n@@ -3781,7 +3781,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                                 parent_scope,\n                                 namespace_name,\n                                 // cannot reconstruct file ...\n-                                ptr::null(),\n+                                ptr::mut_null(),\n                                 // ... or line information, but that's not so important.\n                                 0)\n                         }"}, {"sha": "b10190b23c721c87058a0f22bdee69ee53355e17", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -277,15 +277,19 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         auto_ref(bcx, datum, expr)\n     }\n \n-    fn auto_borrow_obj<'a>(bcx: &'a Block<'a>,\n+    fn auto_borrow_obj<'a>(mut bcx: &'a Block<'a>,\n                            expr: &ast::Expr,\n                            source_datum: Datum<Expr>)\n                            -> DatumBlock<'a, Expr> {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"auto_borrow_obj(target={})\", target_obj_ty.repr(tcx));\n \n-        let mut datum = source_datum.to_expr_datum();\n+        // Arrange cleanup, if not already done. This is needed in\n+        // case we are auto-borrowing a Box<Trait> to &Trait\n+        let datum = unpack_datum!(\n+            bcx, source_datum.to_lvalue_datum(bcx, \"autoborrowobj\", expr.id));\n+        let mut datum = datum.to_expr_datum();\n         datum.ty = target_obj_ty;\n         DatumBlock::new(bcx, datum)\n     }"}, {"sha": "488dc6d99e35c7a0d6063d816250a778ccaab540", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -957,7 +957,11 @@ pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n \n fn add_argument_attributes(tys: &ForeignTypes,\n                            llfn: ValueRef) {\n-    let mut i = if tys.fn_ty.ret_ty.is_indirect() { 1 } else { 0 };\n+    let mut i = if tys.fn_ty.ret_ty.is_indirect() {\n+        1i\n+    } else {\n+        0i\n+    };\n \n     match tys.fn_ty.ret_ty.attr {\n         Some(attr) => unsafe {"}, {"sha": "e1d43c5240059ee03fd51e40f451269ec123f17d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -492,14 +492,24 @@ fn emit_vtable_methods(bcx: &Block,\n                m.repr(tcx),\n                substs.repr(tcx));\n         if m.generics.has_type_params(subst::FnSpace) ||\n-           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone()))\n-        {\n+           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n                    token::get_ident(ident));\n             C_null(Type::nil(ccx).ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0),\n-                                      substs.clone(), vtables.clone())\n+            let mut fn_ref = trans_fn_ref_with_vtables(bcx,\n+                                                       m_id,\n+                                                       ExprId(0),\n+                                                       substs.clone(),\n+                                                       vtables.clone());\n+            if m.explicit_self == ast::SelfValue {\n+                fn_ref = trans_unboxing_shim(bcx,\n+                                             fn_ref,\n+                                             &*m,\n+                                             m_id,\n+                                             substs.clone());\n+            }\n+            fn_ref\n         }\n     }).collect()\n }"}, {"sha": "79630be7c5e0840c21dfdf99228ed5bbede7f7ac", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -158,7 +158,7 @@ pub struct creader_cache_key {\n pub type creader_cache = RefCell<HashMap<creader_cache_key, t>>;\n \n pub struct intern_key {\n-    sty: *sty,\n+    sty: *const sty,\n }\n \n // NB: Do not replace this with #[deriving(PartialEq)]. The automatically-derived\n@@ -409,7 +409,7 @@ enum t_opaque {}\n \n #[allow(raw_pointer_deriving)]\n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct t { inner: *t_opaque }\n+pub struct t { inner: *const t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1216,7 +1216,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         flags: flags,\n     };\n \n-    let sty_ptr = &t.sty as *sty;\n+    let sty_ptr = &t.sty as *const sty;\n \n     let key = intern_key {\n         sty: sty_ptr,\n@@ -1227,7 +1227,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     cx.next_id.set(cx.next_id.get() + 1);\n \n     unsafe {\n-        mem::transmute::<*sty, t>(sty_ptr)\n+        mem::transmute::<*const sty, t>(sty_ptr)\n     }\n }\n \n@@ -1533,7 +1533,7 @@ pub fn type_is_self(ty: t) -> bool {\n     }\n }\n \n-fn type_is_slice(ty:t) -> bool {\n+fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             ty_vec(_, None) | ty_str => true,\n@@ -1543,6 +1543,18 @@ fn type_is_slice(ty:t) -> bool {\n     }\n }\n \n+pub fn type_is_vec(ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_vec(..) => true,\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(_, None) => true,\n+            _ => false\n+        },\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n@@ -1560,7 +1572,7 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-        ty_vec(mt, Some(_)) => mt.ty,\n+        ty_vec(mt, _) => mt.ty,\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n         ty_box(t) | ty_uniq(t) => match get(t).sty {\n             ty_vec(mt, None) => mt.ty,\n@@ -2551,6 +2563,21 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n \n // Returns the type of t[i]\n pub fn index(t: t) -> Option<mt> {\n+    match get(t).sty {\n+        ty_vec(mt, Some(_)) => Some(mt),\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(mt, None) => Some(mt),\n+            _ => None,\n+        },\n+        _ => None\n+    }\n+}\n+\n+// Returns the type of elements contained within an 'array-like' type.\n+// This is exactly the same as the above, except it supports strings,\n+// which can't actually be indexed.\n+pub fn array_element_ty(t: t) -> Option<mt> {\n     match get(t).sty {\n         ty_vec(mt, Some(_)) => Some(mt),\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |"}, {"sha": "60ce9508dc46b3422eb7dc34e4c5def15d0b4297", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -318,6 +318,9 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     for field in fields.iter() {\n         match field_map.find_mut(&field.ident.name) {\n             Some(&(_, true)) => {\n+                // Check the pattern anyway, so that attempts to look\n+                // up its type won't fail\n+                check_pat(pcx, &*field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n                     format!(\"field `{}` bound twice in pattern\",\n                             token::get_ident(field.ident)).as_slice());"}, {"sha": "c3b2756bdbff2f7f165af2718ec6a1fe293a7452", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -271,7 +271,9 @@ fn construct_transformed_self_ty_for_object(\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n         ast::SelfValue => {\n-            ty::mk_err() // error reported in `enforce_object_limitations()`\n+            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n+                                  ty::empty_builtin_bounds());\n+            ty::mk_uniq(tcx, tr)\n         }\n         ast::SelfRegion(..) | ast::SelfUniq => {\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n@@ -1225,14 +1227,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfValue => { // reason (a) above\n-                self.tcx().sess.span_err(\n-                    self.span,\n-                    \"cannot call a method with a by-value receiver \\\n-                     through an object\");\n-            }\n-\n-            ast::SelfRegion(..) | ast::SelfUniq => {}\n+            ast::SelfValue | ast::SelfRegion(..) | ast::SelfUniq => {}\n         }\n \n         // reason (a) above\n@@ -1302,7 +1297,26 @@ impl<'a> LookupContext<'a> {\n             }\n \n             SelfValue => {\n-                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                debug!(\"(is relevant?) explicit self is by-value\");\n+                match ty::get(rcvr_ty).sty {\n+                    ty::ty_uniq(typ) => {\n+                        match ty::get(typ).sty {\n+                            ty::ty_trait(box ty::TyTrait {\n+                                def_id: self_did,\n+                                ..\n+                            }) => {\n+                                rcvr_matches_object(self_did, candidate) ||\n+                                    rcvr_matches_ty(self.fcx,\n+                                                    rcvr_ty,\n+                                                    candidate)\n+                            }\n+                            _ => {\n+                                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                            }\n+                        }\n+                    }\n+                    _ => rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                }\n             }\n \n             SelfRegion(_, m) => {"}, {"sha": "5e675242688afc435f02b86f6bbdf33bac92d93d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -1146,24 +1146,9 @@ fn check_cast(fcx: &FnCtxt,\n            .span_err(span,\n                      \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn is_vec(t: ty::t) -> bool {\n-            match ty::get(t).sty {\n-                ty::ty_vec(..) => true,\n-                ty::ty_ptr(ty::mt{ty: t, ..}) |\n-                ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n-                ty::ty_box(t) |\n-                ty::ty_uniq(t) => {\n-                    match ty::get(t).sty {\n-                        ty::ty_vec(_, None) => true,\n-                        _ => false,\n-                    }\n-                }\n-                _ => false\n-            }\n-        }\n         fn types_compatible(fcx: &FnCtxt, sp: Span,\n                             t1: ty::t, t2: ty::t) -> bool {\n-            if !is_vec(t1) {\n+            if !ty::type_is_vec(t1) {\n                 // If the type being casted from is not a vector, this special\n                 // case does not apply.\n                 return false\n@@ -1262,7 +1247,7 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n \n impl<'a> FnCtxt<'a> {\n     pub fn tag(&self) -> String {\n-        format!(\"{}\", self as *FnCtxt)\n+        format!(\"{}\", self as *const FnCtxt)\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n@@ -2779,10 +2764,30 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, enum_type);\n     }\n \n+    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n+\n+    fn check_fn_for_vec_elements_expected(fcx: &FnCtxt,\n+                                          expected: Expectation)\n+                                         -> (ExprCheckerWithTy, ty::t) {\n+        let tcx = fcx.ccx.tcx;\n+        let (coerce, t) = match expected {\n+            // If we're given an expected type, we can try to coerce to it\n+            ExpectHasType(t) if ty::type_is_vec(t) => (true, ty::sequence_element_type(tcx, t)),\n+            // Otherwise we just leave the type to be resolved later\n+            _ => (false, fcx.infcx().next_ty_var())\n+        };\n+        if coerce {\n+            (check_expr_coercable_to_type, t)\n+        } else {\n+            (check_expr_has_type, t)\n+        }\n+    }\n+\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n         ast::ExprVstore(ev, vst) => {\n+            let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n             let typ = match ev.node {\n                 ast::ExprVec(ref args) => {\n                     let mutability = match vst {\n@@ -2791,9 +2796,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     };\n                     let mut any_error = false;\n                     let mut any_bot = false;\n-                    let t: ty::t = fcx.infcx().next_ty_var();\n                     for e in args.iter() {\n-                        check_expr_has_type(fcx, &**e, t);\n+                        check(fcx, &**e, t);\n                         let arg_t = fcx.expr_ty(&**e);\n                         if ty::type_is_error(arg_t) {\n                             any_error = true;\n@@ -2821,8 +2825,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         ast::ExprVstoreMutSlice => ast::MutMutable,\n                         _ => ast::MutImmutable,\n                     };\n-                    let t = fcx.infcx().next_ty_var();\n-                    check_expr_has_type(fcx, &**element, t);\n+                    check(fcx, &**element, t);\n                     let arg_t = fcx.expr_ty(&**element);\n                     if ty::type_is_error(arg_t) {\n                         ty::mk_err()\n@@ -3211,9 +3214,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n-        let t: ty::t = fcx.infcx().next_ty_var();\n+        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n         for e in args.iter() {\n-            check_expr_has_type(fcx, &**e, t);\n+            check(fcx, &**e, t);\n         }\n         let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n                              Some(args.len()));\n@@ -3222,8 +3225,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n-        let t: ty::t = fcx.infcx().next_ty_var();\n-        check_expr_has_type(fcx, &**element, t);\n+        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n+        check(fcx, &**element, t);\n         let element_ty = fcx.expr_ty(&**element);\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n@@ -3805,7 +3808,15 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n-                    let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n+                    let declty = match hint {\n+                        attr::ReprAny | attr::ReprExtern => ty::mk_int(),\n+                        attr::ReprInt(_, attr::SignedInt(ity)) => {\n+                            ty::mk_mach_int(ity)\n+                        }\n+                        attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n+                            ty::mk_mach_uint(ity)\n+                        }\n+                    };\n                     check_const_with_ty(&fcx, e.span, &*e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in a form that eval_const_expr can"}, {"sha": "33e0d0331be6c23d3e0725e161b083f8a74a877a", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -352,17 +352,15 @@ fn search_for_vtable(vcx: &VtableContext,\n         // the next impl.\n         //\n         // FIXME: document a bit more what this means\n-        //\n-        // FIXME(#5781) this should be mk_eqty not mk_subty\n         let TypeAndSubsts {\n             substs: substs,\n             ty: for_ty\n         } = impl_self_ty(vcx, span, impl_did);\n-        match infer::mk_subty(vcx.infcx,\n-                              false,\n-                              infer::RelateSelfType(span),\n-                              ty,\n-                              for_ty) {\n+        match infer::mk_eqty(vcx.infcx,\n+                             false,\n+                             infer::RelateSelfType(span),\n+                             ty,\n+                             for_ty) {\n             Err(_) => continue,\n             Ok(()) => ()\n         }"}, {"sha": "f374f1dc26795104f2fc31ea551a254cbbd27c4a", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -84,41 +84,25 @@ pub trait Combine {\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n \n     fn tps(&self,\n-           space: subst::ParamSpace,\n+           _: subst::ParamSpace,\n            as_: &[ty::t],\n            bs: &[ty::t])\n-           -> cres<Vec<ty::t>>\n-    {\n-        // FIXME(#5781) -- In general, we treat variance a bit wrong\n-        // here. For historical reasons, we treat Self as\n-        // contravariant and other tps as invariant. Both are wrong:\n-        // Self may or may not be contravariant, and other tps do not\n-        // need to be invariant.\n+           -> cres<Vec<ty::t>> {\n+        // FIXME -- In general, we treat variance a bit wrong\n+        // here. For historical reasons, we treat tps and Self\n+        // as invariant. This is overly conservative.\n \n         if as_.len() != bs.len() {\n             return Err(ty::terr_ty_param_size(expected_found(self,\n                                                              as_.len(),\n                                                              bs.len())));\n         }\n \n-        match space {\n-            subst::SelfSpace => {\n-                result::fold(as_\n-                             .iter()\n-                             .zip(bs.iter())\n-                             .map(|(a, b)| self.contratys(*a, *b)),\n-                             Vec::new(),\n-                             |mut v, a| { v.push(a); v })\n-            }\n-\n-            subst::TypeSpace | subst::FnSpace => {\n-                try!(result::fold_(as_\n-                                  .iter()\n-                                  .zip(bs.iter())\n-                                  .map(|(a, b)| eq_tys(self, *a, *b))));\n-                Ok(Vec::from_slice(as_))\n-            }\n-        }\n+        try!(result::fold_(as_\n+                          .iter()\n+                          .zip(bs.iter())\n+                          .map(|(a, b)| eq_tys(self, *a, *b))));\n+        Ok(Vec::from_slice(as_))\n     }\n \n     fn substs(&self,"}, {"sha": "bc02297b5b1f3cd27d89a55b4fb4890ab96cf9c7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -247,9 +247,13 @@ pub enum fixup_err {\n \n pub fn fixup_err_to_str(f: fixup_err) -> String {\n     match f {\n-      unresolved_int_ty(_) => \"unconstrained integral type\".to_string(),\n+      unresolved_int_ty(_) => {\n+          \"cannot determine the type of this integer; add a suffix to \\\n+           specify the type explicitly\".to_string()\n+      }\n       unresolved_float_ty(_) => {\n-          \"unconstrained floating point type\".to_string()\n+          \"cannot determine the type of this number; add a suffix to specify \\\n+           the type explicitly\".to_string()\n       }\n       unresolved_ty(_) => \"unconstrained type\".to_string(),\n       cyclic_ty(_) => \"cyclic type of infinite size\".to_string(),"}, {"sha": "adfbe9de2d5bf8b72769c6784a879a16dd64b702", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 10, "deletions": 43, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -52,14 +52,12 @@ use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n-use middle::typeck::infer::unresolved_ty;\n-use middle::typeck::infer::unify::Root;\n+use middle::typeck::infer::{unresolved_float_ty, unresolved_int_ty};\n+use middle::typeck::infer::{unresolved_ty};\n use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{Repr, ty_to_str};\n \n-use syntax::ast;\n-\n pub static resolve_nested_tvar: uint = 0b0000000001;\n pub static resolve_rvar: uint        = 0b0000000010;\n pub static resolve_ivar: uint        = 0b0000000100;\n@@ -83,21 +81,18 @@ pub struct ResolveState<'a> {\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n     type_depth: uint,\n-    span: Option<Span>,\n }\n \n pub fn resolver<'a>(infcx: &'a InferCtxt,\n                     modes: uint,\n-                    span: Option<Span>)\n-                    -> ResolveState<'a>\n-{\n+                    _: Option<Span>)\n+                    -> ResolveState<'a> {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n         err: None,\n         v_seen: Vec::new(),\n         type_depth: 0,\n-        span: span\n     }\n }\n \n@@ -258,24 +253,10 @@ impl<'a> ResolveState<'a> {\n           Some(UintType(t)) => ty::mk_mach_uint(t),\n           None => {\n             if self.should(force_ivar) {\n-                // As a last resort, default to int and emit an error.\n-                let ty = ty::mk_int();\n-                table.borrow_mut().set(\n-                    tcx, node.key, Root(Some(IntType(ast::TyI)), node.rank));\n-\n-                match self.span {\n-                    Some(sp) => {\n-                        self.infcx.tcx.sess.span_err(\n-                            sp,\n-                            \"cannot determine the type of this integer; add \\\n-                             a suffix to specify the type explicitly\");\n-                    }\n-                    None => { }\n-                }\n-                ty\n-            } else {\n-                ty::mk_int_var(self.infcx.tcx, vid)\n+                // As a last resort, emit an error.\n+                self.err = Some(unresolved_int_ty(vid));\n             }\n+            ty::mk_int_var(self.infcx.tcx, vid)\n           }\n         }\n     }\n@@ -292,24 +273,10 @@ impl<'a> ResolveState<'a> {\n           Some(t) => ty::mk_mach_float(t),\n           None => {\n             if self.should(force_fvar) {\n-                // As a last resort, default to f64 and emit an error.\n-                let ty = ty::mk_f64();\n-                table.borrow_mut().set(\n-                    tcx, node.key, Root(Some(ast::TyF64), node.rank));\n-\n-                match self.span {\n-                    Some(sp) => {\n-                        self.infcx.tcx.sess.span_err(\n-                            sp,\n-                            \"cannot determine the type of this number; add \\\n-                             a suffix to specify the type explicitly\");\n-                    }\n-                    None => { }\n-                }\n-                ty\n-            } else {\n-                ty::mk_float_var(self.infcx.tcx, vid)\n+                // As a last resort, emit an error.\n+                self.err = Some(unresolved_float_ty(vid));\n             }\n+            ty::mk_float_var(self.infcx.tcx, vid)\n           }\n         }\n     }"}, {"sha": "0a60a5ce0e9fa3900a5d8b7d031f189f45e17aa8", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -78,8 +78,8 @@ receiver position from being called via an object.)\n #### Trait variance and vtable resolution\n \n But traits aren't only used with objects. They're also used when\n-deciding whether a given impl satisfies a given trait bound (or should\n-be -- FIXME #5781). To set the scene here, imagine I had a function:\n+deciding whether a given impl satisfies a given trait bound. To set the\n+scene here, imagine I had a function:\n \n     fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n         ..."}, {"sha": "79d0690653faf9d3a6a99d501bea05f3fb947b72", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -129,7 +129,7 @@ impl<'a> PluginLoader<'a> {\n             let registrar =\n                 match lib.symbol(symbol.as_slice()) {\n                     Ok(registrar) => {\n-                        mem::transmute::<*u8,PluginRegistrarFun>(registrar)\n+                        mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => self.sess.span_fatal(vi.span, err.as_slice())"}, {"sha": "fa353652fe1ec21ae311ae6ea866a417df431ade", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -355,7 +355,12 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n       ty_box(typ) => format!(\"Gc<{}>\", ty_to_str(cx, typ)),\n       ty_uniq(typ) => format!(\"Box<{}>\", ty_to_str(cx, typ)),\n-      ty_ptr(ref tm) => format!(\"*{}\", mt_to_str(cx, tm)),\n+      ty_ptr(ref tm) => {\n+          format!(\"*{} {}\", match tm.mutbl {\n+              ast::MutMutable => \"mut\",\n+              ast::MutImmutable => \"const\",\n+          }, ty_to_str(cx, tm.ty))\n+      }\n       ty_rptr(r, ref tm) => {\n           let mut buf = region_ptr_to_str(cx, r);\n           buf.push_str(mt_to_str(cx, tm).as_slice());"}, {"sha": "bfd3deb0f2dcd627fd4b6b3db25ebc2bd78da9ed", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -34,7 +34,7 @@ fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     assert!(dst.len() * 4 == input.len());\n     unsafe {\n         let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        let mut y = input.unsafe_ref(0) as *_ as *u32;\n+        let mut y = input.unsafe_ref(0) as *const _ as *const u32;\n         for _ in range(0, dst.len()) {\n             *x = to_be32(*y);\n             x = x.offset(1);"}, {"sha": "2d498e7f302d3fca3330b0182ea547608eac6c68", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -18,6 +18,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n use rustc::middle::ty;\n+use rustc::middle::stability;\n \n use core;\n use doctree;\n@@ -102,6 +103,7 @@ fn try_inline_def(cx: &core::DocContext,\n         attrs: load_attrs(tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n+        stability: stability::lookup(tcx, did).clean(),\n         def_id: did,\n     });\n     Some(ret)\n@@ -317,6 +319,7 @@ fn build_impl(cx: &core::DocContext,\n         name: None,\n         attrs: attrs,\n         visibility: Some(ast::Inherited),\n+        stability: stability::lookup(tcx, did).clean(),\n         def_id: did,\n     })\n }"}, {"sha": "87151708812e54a5f106291d5a04fd851bf6a0dc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -29,6 +29,7 @@ use rustc::middle::def;\n use rustc::middle::subst;\n use rustc::middle::subst::VecPerParamSpace;\n use rustc::middle::ty;\n+use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n@@ -44,6 +45,17 @@ pub static SCHEMA_VERSION: &'static str = \"0.8.3\";\n \n mod inline;\n \n+// load the current DocContext from TLD\n+fn get_cx() -> Gc<core::DocContext> {\n+    *super::ctxtkey.get().unwrap()\n+}\n+\n+// extract the stability index for a node from TLD, if possible\n+fn get_stability(def_id: ast::DefId) -> Option<Stability> {\n+    get_cx().tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id))\n+            .map(|stab| stab.clean())\n+}\n+\n pub trait Clean<T> {\n     fn clean(&self) -> T;\n }\n@@ -97,7 +109,7 @@ pub struct Crate {\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n \n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n@@ -158,6 +170,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                     name: Some(prim.to_url_str().to_string()),\n                     attrs: Vec::new(),\n                     visibility: None,\n+                    stability: None,\n                     def_id: ast_util::local_def(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n                 };\n@@ -193,25 +206,18 @@ pub struct ExternalCrate {\n impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n         let mut primitives = Vec::new();\n-        let cx = super::ctxtkey.get().unwrap();\n-        match cx.maybe_typed {\n-            core::Typed(ref tcx) => {\n-                csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                                      self.cnum,\n-                                                      |def, _, _| {\n-                    let did = match def {\n-                        decoder::DlDef(def::DefMod(did)) => did,\n-                        _ => return\n-                    };\n-                    let attrs = inline::load_attrs(tcx, did);\n-                    match Primitive::find(attrs.as_slice()) {\n-                        Some(prim) => primitives.push(prim),\n-                        None => {}\n-                    }\n-                });\n-            }\n-            core::NotTyped(..) => {}\n-        }\n+        get_cx().tcx_opt().map(|tcx| {\n+            csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n+                                                  self.cnum,\n+                                                  |def, _, _| {\n+                let did = match def {\n+                    decoder::DlDef(def::DefMod(did)) => did,\n+                    _ => return\n+                };\n+                let attrs = inline::load_attrs(tcx, did);\n+                Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n+            })\n+        });\n         ExternalCrate {\n             name: self.name.to_string(),\n             attrs: decoder::get_crate_attributes(self.data()).clean(),\n@@ -233,6 +239,7 @@ pub struct Item {\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: ast::DefId,\n+    pub stability: Option<Stability>,\n }\n \n impl Item {\n@@ -380,6 +387,7 @@ impl Clean<Item> for doctree::Module {\n             attrs: self.attrs.clean(),\n             source: where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n@@ -465,9 +473,8 @@ impl Clean<TyParam> for ast::TyParam {\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self) -> TyParam {\n-        let cx = super::ctxtkey.get().unwrap();\n-        cx.external_typarams.borrow_mut().get_mut_ref().insert(self.def_id,\n-                                                               self.ident.clean());\n+        get_cx().external_typarams.borrow_mut().get_mut_ref()\n+                .insert(self.def_id, self.ident.clean());\n         TyParam {\n             name: self.ident.clean(),\n             did: self.def_id,\n@@ -515,7 +522,7 @@ fn external_path(name: &str, substs: &subst::Substs) -> Path {\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n     fn clean(&self) -> TyParamBound {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n@@ -550,7 +557,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n \n impl Clean<TyParamBound> for ty::TraitRef {\n     fn clean(&self) -> TyParamBound {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n@@ -709,8 +716,9 @@ impl Clean<Item> for ast::Method {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            def_id: ast_util::local_def(self.id.clone()),\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: get_stability(ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n                 generics: self.generics.clean(),\n                 self_: self.explicit_self.node.clean(),\n@@ -749,6 +757,7 @@ impl Clean<Item> for ast::TypeMethod {\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: None,\n+            stability: get_stability(ast_util::local_def(self.id)),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n@@ -792,6 +801,7 @@ impl Clean<Item> for doctree::Function {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(),\n@@ -854,14 +864,10 @@ impl Clean<FnDecl> for ast::FnDecl {\n \n impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self) -> FnDecl {\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n+        let cx = get_cx();\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n-            csearch::get_method_arg_names(&tcx.sess.cstore, did).move_iter()\n+            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).move_iter()\n         } else {\n             Vec::new().move_iter()\n         }.peekable();\n@@ -932,6 +938,7 @@ impl Clean<Item> for doctree::Trait {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: TraitItem(Trait {\n                 methods: self.methods.clean(),\n                 generics: self.generics.clean(),\n@@ -985,11 +992,7 @@ impl Clean<TraitMethod> for ast::TraitMethod {\n \n impl Clean<Item> for ty::Method {\n     fn clean(&self) -> Item {\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n+        let cx = get_cx();\n         let (self_, sig) = match self.explicit_self {\n             ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n             s => {\n@@ -1015,8 +1018,9 @@ impl Clean<Item> for ty::Method {\n         Item {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n+            stability: get_stability(self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(tcx, self.def_id),\n+            attrs: inline::load_attrs(cx.tcx(), self.def_id),\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n@@ -1261,12 +1265,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n-                let cx = super::ctxtkey.get().unwrap();\n-                let tcx = match cx.maybe_typed {\n-                    core::Typed(ref tycx) => tycx,\n-                    core::NotTyped(_) => unreachable!(),\n-                };\n-                let fqn = csearch::get_item_path(tcx, did);\n+                let fqn = csearch::get_item_path(get_cx().tcx(), did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_str()\n                 }).collect();\n@@ -1277,8 +1276,8 @@ impl Clean<Type> for ty::t {\n                 };\n                 let path = external_path(fqn.last().unwrap().to_str().as_slice(),\n                                          substs);\n-                cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n-                                                                    (fqn, kind));\n+                get_cx().external_paths.borrow_mut().get_mut_ref()\n+                                       .insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n@@ -1318,6 +1317,7 @@ impl Clean<Item> for ast::StructField {\n             attrs: self.node.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             visibility: Some(vis),\n+            stability: get_stability(ast_util::local_def(self.node.id)),\n             def_id: ast_util::local_def(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean())),\n         }\n@@ -1332,17 +1332,14 @@ impl Clean<Item> for ty::field_ty {\n         } else {\n             Some(self.name)\n         };\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tycx) => tycx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n-        let ty = ty::lookup_item_type(tcx, self.id);\n+        let cx = get_cx();\n+        let ty = ty::lookup_item_type(cx.tcx(), self.id);\n         Item {\n             name: name.clean(),\n-            attrs: inline::load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n+            stability: get_stability(self.id),\n             def_id: self.id,\n             inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n         }\n@@ -1373,6 +1370,7 @@ impl Clean<Item> for doctree::Struct {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(),\n@@ -1418,6 +1416,7 @@ impl Clean<Item> for doctree::Enum {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: EnumItem(Enum {\n                 variants: self.variants.clean(),\n                 generics: self.generics.clean(),\n@@ -1439,6 +1438,7 @@ impl Clean<Item> for doctree::Variant {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(),\n@@ -1450,11 +1450,7 @@ impl Clean<Item> for doctree::Variant {\n impl Clean<Item> for ty::VariantInfo {\n     fn clean(&self) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tycx) => tycx,\n-            core::NotTyped(_) => fail!(\"tcx not present\"),\n-        };\n+        let cx = get_cx();\n         let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n             None | Some([]) if self.args.len() == 0 => CLikeVariant,\n             None | Some([]) => {\n@@ -1470,6 +1466,7 @@ impl Clean<Item> for ty::VariantInfo {\n                             name: Some(name.clean()),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n+                            stability: get_stability(self.id),\n                             // FIXME: this is not accurate, we need an id for\n                             //        the specific field but we're using the id\n                             //        for the whole variant. Nothing currently\n@@ -1485,11 +1482,12 @@ impl Clean<Item> for ty::VariantInfo {\n         };\n         Item {\n             name: Some(self.name.clean()),\n-            attrs: inline::load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n             def_id: self.id,\n             inner: VariantItem(Variant { kind: kind }),\n+            stability: None,\n         }\n     }\n }\n@@ -1626,6 +1624,7 @@ impl Clean<Item> for doctree::Typedef {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id.clone()),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: TypedefItem(Typedef {\n                 type_: self.ty.clean(),\n                 generics: self.gen.clean(),\n@@ -1675,6 +1674,7 @@ impl Clean<Item> for doctree::Static {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(),\n                 mutability: self.mutability.clean(),\n@@ -1720,6 +1720,7 @@ impl Clean<Item> for doctree::Impl {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: ImplItem(Impl {\n                 generics: self.generics.clean(),\n                 trait_: self.trait_.clean(),\n@@ -1754,6 +1755,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 source: self.span.clean(),\n                 def_id: ast_util::local_def(0),\n                 visibility: self.vis.clean(),\n+                stability: None,\n                 inner: ViewItemItem(ViewItem { inner: node.clean() }),\n             }\n         };\n@@ -1895,6 +1897,7 @@ impl Clean<Item> for ast::ForeignItem {\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: None,\n             inner: inner,\n         }\n     }\n@@ -1977,7 +1980,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n /// Given a Type, resolve it using the def_map\n fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n                 id: ast::NodeId) -> Type {\n-    let cx = super::ctxtkey.get().unwrap();\n+    let cx = get_cx();\n     let tycx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n@@ -2012,7 +2015,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n         def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n-    let did = register_def(&**cx, def);\n+    let did = register_def(&*cx, def);\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n@@ -2051,13 +2054,9 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n }\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    let cx = super::ctxtkey.get().unwrap();\n-    match cx.maybe_typed {\n-        core::Typed(ref tcx) => {\n-            tcx.def_map.borrow().find(&id).map(|&def| register_def(&**cx, def))\n-        }\n-        core::NotTyped(_) => None\n-    }\n+    get_cx().tcx_opt().and_then(|tcx| {\n+        tcx.def_map.borrow().find(&id).map(|&def| register_def(&*get_cx(), def))\n+    })\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -2072,10 +2071,27 @@ impl Clean<Item> for doctree::Macro {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: ast::Public.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n                 source: self.where.to_src(),\n             }),\n         }\n     }\n }\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Stability {\n+    pub level: attr::StabilityLevel,\n+    pub text: String\n+}\n+\n+impl Clean<Stability> for attr::Stability {\n+    fn clean(&self) -> Stability {\n+        Stability {\n+            level: self.level,\n+            text: self.text.as_ref().map_or(\"\".to_string(),\n+                                            |interned| interned.get().to_string()),\n+        }\n+    }\n+}"}, {"sha": "245b2d162a77b02c76632dd77042628834119b65", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -10,7 +10,7 @@\n \n use rustc;\n use rustc::{driver, middle};\n-use rustc::middle::privacy;\n+use rustc::middle::{privacy, ty};\n use rustc::lint;\n \n use syntax::ast;\n@@ -26,6 +26,7 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+/// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped {\n     Typed(middle::ty::ctxt),\n     NotTyped(driver::session::Session)\n@@ -52,6 +53,18 @@ impl DocContext {\n             NotTyped(ref sess) => sess\n         }\n     }\n+\n+    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt> {\n+        match self.maybe_typed {\n+            Typed(ref tcx) => Some(tcx),\n+            NotTyped(_) => None\n+        }\n+    }\n+\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        let tcx_opt = self.tcx_opt();\n+        tcx_opt.expect(\"tcx not present\")\n+    }\n }\n \n pub struct CrateAnalysis {"}, {"sha": "313f1c81c79e81ba8df55f0d5af5fb24b11cd01a", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -14,6 +14,7 @@\n use syntax;\n use syntax::codemap::Span;\n use syntax::ast;\n+use syntax::attr;\n use syntax::ast::{Ident, NodeId};\n \n use std::gc::Gc;\n@@ -32,6 +33,7 @@ pub struct Module {\n     pub statics: Vec<Static>,\n     pub traits: Vec<Trait>,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n     pub view_items: Vec<ast::ViewItem>,\n@@ -45,6 +47,7 @@ impl Module {\n             name       : name,\n             id: 0,\n             vis: ast::Inherited,\n+            stab: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n@@ -83,6 +86,7 @@ pub enum TypeBound {\n \n pub struct Struct {\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: NodeId,\n     pub struct_type: StructType,\n     pub name: Ident,\n@@ -94,6 +98,7 @@ pub struct Struct {\n \n pub struct Enum {\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub variants: Vec<Variant>,\n     pub generics: ast::Generics,\n     pub attrs: Vec<ast::Attribute>,\n@@ -108,6 +113,7 @@ pub struct Variant {\n     pub kind: ast::VariantKind,\n     pub id: ast::NodeId,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub where: Span,\n }\n \n@@ -117,6 +123,7 @@ pub struct Function {\n     pub id: NodeId,\n     pub name: Ident,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub fn_style: ast::FnStyle,\n     pub where: Span,\n     pub generics: ast::Generics,\n@@ -130,6 +137,7 @@ pub struct Typedef {\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub struct Static {\n@@ -139,6 +147,7 @@ pub struct Static {\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n     pub where: Span,\n }\n@@ -152,6 +161,7 @@ pub struct Trait {\n     pub id: ast::NodeId,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub struct Impl {\n@@ -162,6 +172,7 @@ pub struct Impl {\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n }\n \n@@ -170,6 +181,7 @@ pub struct Macro {\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {"}, {"sha": "0931f132c0214b8a784e931d39145b74ae4cfc1b", "filename": "src/librustdoc/externalfiles.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{io, str};\n+\n+#[deriving(Clone)]\n+pub struct ExternalHtml{\n+    pub in_header: String,\n+    pub before_content: String,\n+    pub after_content: String\n+}\n+\n+impl ExternalHtml {\n+    pub fn load(in_header: &[String], before_content: &[String], after_content: &[String])\n+            -> Option<ExternalHtml> {\n+        match (load_external_files(in_header),\n+               load_external_files(before_content),\n+               load_external_files(after_content)) {\n+            (Some(ih), Some(bc), Some(ac)) => Some(ExternalHtml {\n+                in_header: ih,\n+                before_content: bc,\n+                after_content: ac\n+            }),\n+            _ => None\n+        }\n+    }\n+}\n+\n+pub fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n+    let mut f = try!(io::File::open(input));\n+    let d = try!(f.read_to_end());\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()))\n+}\n+\n+macro_rules! load_or_return {\n+    ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n+        {\n+            let input = Path::new($input);\n+            match ::externalfiles::load_string(&input) {\n+                Err(e) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: {}\", input.display(), e);\n+                    return $cant_read;\n+                }\n+                Ok(None) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: not UTF-8\", input.display());\n+                    return $not_utf8;\n+                }\n+                Ok(Some(s)) => s\n+            }\n+        }\n+    }\n+}\n+\n+pub fn load_external_files(names: &[String]) -> Option<String> {\n+    let mut out = String::new();\n+    for name in names.iter() {\n+        out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n+        out.push_char('\\n');\n+    }\n+    Some(out)\n+}"}, {"sha": "f07c016367634919387f6794fed522fd6a7673f9", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -104,7 +104,7 @@ mod imp {\n                 l_sysid: 0,\n             };\n             let ret = unsafe {\n-                libc::fcntl(fd, os::F_SETLKW, &flock as *os::flock)\n+                libc::fcntl(fd, os::F_SETLKW, &flock as *const os::flock)\n             };\n             if ret == -1 {\n                 unsafe { libc::close(fd); }\n@@ -125,7 +125,7 @@ mod imp {\n                 l_sysid: 0,\n             };\n             unsafe {\n-                libc::fcntl(self.fd, os::F_SETLK, &flock as *os::flock);\n+                libc::fcntl(self.fd, os::F_SETLK, &flock as *const os::flock);\n                 libc::close(self.fd);\n             }\n         }\n@@ -162,7 +162,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let p_16 = p.as_str().unwrap().to_utf16().append_one(0);\n+            let p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n+            let p_16 = p_16.append_one(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),\n                                   libc::FILE_GENERIC_READ |"}, {"sha": "60853f450ab329dcb0a5d3ad5a5bedaf5d33a509", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -19,7 +19,7 @@ pub trait DocFolder {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner } = item;\n+        let Item { attrs, name, source, visibility, def_id, inner, stability } = item;\n         let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n@@ -83,7 +83,7 @@ pub trait DocFolder {\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n-                    visibility: visibility, def_id: def_id })\n+                    visibility: visibility, stability: stability, def_id: def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "9677b9004cdf1a12e015b56191ab3426747f1e1d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -37,6 +37,10 @@ pub struct FnStyleSpace(pub ast::FnStyle);\n pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n /// Similar to VisSpace, but used for mutability\n pub struct MutableSpace(pub clean::Mutability);\n+/// Wrapper struct for properly emitting the stability level.\n+pub struct Stability<'a>(pub &'a Option<clean::Stability>);\n+/// Wrapper struct for emitting the stability level concisely.\n+pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n \n impl VisSpace {\n     pub fn get(&self) -> Option<ast::Visibility> {\n@@ -185,7 +189,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n     let mut generics = String::new();\n     let last = path.segments.last().unwrap();\n     if last.lifetimes.len() > 0 || last.types.len() > 0 {\n-        let mut counter = 0;\n+        let mut counter = 0u;\n         generics.push_str(\"&lt;\");\n         for lifetime in last.lifetimes.iter() {\n             if counter > 0 { generics.push_str(\", \"); }\n@@ -596,3 +600,34 @@ impl fmt::Show for MutableSpace {\n         }\n     }\n }\n+\n+impl<'a> fmt::Show for Stability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let Stability(stab) = *self;\n+        match *stab {\n+            Some(ref stability) => {\n+                write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n+                       lvl = stability.level.to_str(),\n+                       reason = stability.text)\n+            }\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Show for ConciseStability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let ConciseStability(stab) = *self;\n+        match *stab {\n+            Some(ref stability) => {\n+                write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n+                       lvl = stability.level.to_str(),\n+                       colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n+                       reason = stability.text)\n+            }\n+            None => {\n+                write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n+            }\n+        }\n+    }\n+}"}, {"sha": "aa298d07780bfe341da75be01175462e3ba40542", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -11,10 +11,13 @@\n use std::fmt;\n use std::io;\n \n+use externalfiles::ExternalHtml;\n+\n #[deriving(Clone)]\n pub struct Layout {\n     pub logo: String,\n     pub favicon: String,\n+    pub external_html: ExternalHtml,\n     pub krate: String,\n     pub playground_url: String,\n }\n@@ -44,6 +47,7 @@ r##\"<!DOCTYPE html>\n     <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}main.css\">\n \n     {favicon}\n+    {in_header}\n </head>\n <body>\n     <!--[if lte IE 8]>\n@@ -53,6 +57,8 @@ r##\"<!DOCTYPE html>\n     </div>\n     <![endif]-->\n \n+    {before_content}\n+\n     <section class=\"sidebar\">\n         {logo}\n         {sidebar}\n@@ -105,6 +111,8 @@ r##\"<!DOCTYPE html>\n         </div>\n     </div>\n \n+    {after_content}\n+\n     <script>\n         window.rootPath = \"{root_path}\";\n         window.currentCrate = \"{krate}\";\n@@ -133,6 +141,9 @@ r##\"<!DOCTYPE html>\n     } else {\n         format!(r#\"<link rel=\"shortcut icon\" href=\"{}\">\"#, layout.favicon)\n     },\n+    in_header = layout.external_html.in_header,\n+    before_content = layout.external_html.before_content,\n+    after_content = layout.external_html.after_content,\n     sidebar   = *sidebar,\n     krate     = layout.krate,\n     play_url  = layout.playground_url,"}, {"sha": "de4bbeb6e30c8a6439c31d1f46424392796f15cf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -66,13 +66,13 @@ type hoedown_document = libc::c_void;  // this is opaque to us\n \n struct hoedown_renderer {\n     opaque: *mut hoedown_html_renderer_state,\n-    blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n-                                    *hoedown_buffer, *mut libc::c_void)>,\n-    blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                    *const hoedown_buffer, *mut libc::c_void)>,\n+    blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                      *mut libc::c_void)>,\n-    blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                     *mut libc::c_void)>,\n-    header: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    header: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                  libc::c_int, *mut libc::c_void)>,\n     other: [libc::size_t, ..28],\n }\n@@ -81,7 +81,8 @@ struct hoedown_html_renderer_state {\n     opaque: *mut libc::c_void,\n     toc_data: html_toc_data,\n     flags: libc::c_uint,\n-    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer,\n+                                          *const hoedown_buffer,\n                                           *mut libc::c_void)>,\n }\n \n@@ -93,13 +94,13 @@ struct html_toc_data {\n }\n \n struct MyOpaque {\n-    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n-                           *hoedown_buffer, *mut libc::c_void),\n+    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                           *const hoedown_buffer, *mut libc::c_void),\n     toc_builder: Option<TocBuilder>,\n }\n \n struct hoedown_buffer {\n-    data: *u8,\n+    data: *const u8,\n     size: libc::size_t,\n     asize: libc::size_t,\n     unit: libc::size_t,\n@@ -118,12 +119,12 @@ extern {\n                             max_nesting: libc::size_t) -> *mut hoedown_document;\n     fn hoedown_document_render(doc: *mut hoedown_document,\n                                ob: *mut hoedown_buffer,\n-                               document: *u8,\n+                               document: *const u8,\n                                doc_size: libc::size_t);\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *libc::c_char);\n+    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n \n }\n@@ -147,13 +148,13 @@ local_data_key!(test_idx: Cell<uint>)\n local_data_key!(pub playground_krate: Option<String>)\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n-                    lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n+    extern fn block(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n \n             let opaque = opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *MyOpaque);\n+            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let origtext = str::from_utf8(text).unwrap();\n                 debug!(\"docblock: ==============\\n{}\\n=======\", text);\n@@ -205,15 +206,13 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     s.push_str(highlight::highlight(text.as_slice(), None, id)\n                                          .as_slice());\n                     let output = s.to_c_str();\n-                    output.with_ref(|r| {\n-                        hoedown_buffer_puts(ob, r)\n-                    })\n+                    hoedown_buffer_puts(ob, output.as_ptr());\n                 }\n             })\n         }\n     }\n \n-    extern fn header(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n+    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         // hoedown does this, we may as well too\n         \"\\n\".with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n@@ -304,8 +303,10 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n }\n \n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n-    extern fn block(_ob: *mut hoedown_buffer, text: *hoedown_buffer,\n-                    lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n+    extern fn block(_ob: *mut hoedown_buffer,\n+                    text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer,\n+                    opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -333,7 +334,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n         }\n     }\n \n-    extern fn header(_ob: *mut hoedown_buffer, text: *hoedown_buffer,\n+    extern fn header(_ob: *mut hoedown_buffer,\n+                     text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         unsafe {\n             let opaque = opaque as *mut hoedown_html_renderer_state;"}, {"sha": "917eab4eeb9918e547fc2e42f105b85c83c2d516", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -41,17 +41,18 @@ use std::str;\n use std::string::String;\n use std::sync::Arc;\n \n+use externalfiles::ExternalHtml;\n+\n use serialize::json::ToJson;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::attr;\n-use syntax::parse::token::InternedString;\n use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace};\n+use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n+use html::format::{ConciseStability};\n use html::highlight;\n use html::item_type::{ItemType, shortty};\n use html::item_type;\n@@ -78,7 +79,7 @@ pub struct Context {\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: Path,\n     /// This describes the layout of each page, and is not modified after\n-    /// creation of the context (contains info like the favicon)\n+    /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n     /// This map is a list of what should be displayed on the sidebar of the\n     /// current page. The key is the section header (traits, modules,\n@@ -112,6 +113,15 @@ pub struct Implementor {\n     generics: clean::Generics,\n     trait_: clean::Type,\n     for_: clean::Type,\n+    stability: Option<clean::Stability>,\n+}\n+\n+/// Metadata about implementations for a type.\n+#[deriving(Clone)]\n+pub struct Impl {\n+    impl_: clean::Impl,\n+    dox: Option<String>,\n+    stability: Option<clean::Stability>,\n }\n \n /// This cache is used to store information about the `clean::Crate` being\n@@ -135,7 +145,7 @@ pub struct Cache {\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::DefId, Vec<(clean::Impl, Option<String>)>>,\n+    pub impls: HashMap<ast::DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n@@ -220,7 +230,7 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: Vec<String> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n+pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: Vec::new(),\n@@ -229,12 +239,14 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n             favicon: \"\".to_string(),\n+            external_html: external_html.clone(),\n             krate: krate.name.clone(),\n             playground_url: \"\".to_string(),\n         },\n         include_sources: true,\n         render_redirect_pages: false,\n     };\n+\n     try!(mkdir(&cx.dst));\n \n     // Crawl the crate attributes looking for attributes which control how we're\n@@ -546,7 +558,8 @@ fn write_shared(cx: &Context,\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n-            try!(write!(&mut f, r#\"\"impl{} {} for {}\",\"#,\n+            try!(write!(&mut f, r#\"\"{}impl{} {} for {}\",\"#,\n+                        ConciseStability(&imp.stability),\n                         imp.generics, imp.trait_, imp.for_));\n         }\n         try!(writeln!(&mut f, r\"];\"));\n@@ -778,6 +791,7 @@ impl DocFolder for Cache {\n                             generics: i.generics.clone(),\n                             trait_: i.trait_.get_ref().clone(),\n                             for_: i.for_.clone(),\n+                            stability: item.stability.clone(),\n                         });\n                     }\n                     Some(..) | None => {}\n@@ -963,7 +977,11 @@ impl DocFolder for Cache {\n                                 let v = self.impls.find_or_insert_with(did, |_| {\n                                     Vec::new()\n                                 });\n-                                v.push((i, dox));\n+                                v.push(Impl {\n+                                    impl_: i,\n+                                    dox: dox,\n+                                    stability: item.stability.clone(),\n+                                });\n                             }\n                             None => {}\n                         }\n@@ -1244,19 +1262,8 @@ impl<'a> fmt::Show for Item<'a> {\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n                     shortty(self.item), self.item.name.get_ref().as_slice()));\n \n-        // Write stability attributes\n-        match attr::find_stability_generic(self.item.attrs.iter()) {\n-            Some((ref stability, _)) => {\n-                try!(write!(fmt,\n-                       \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = stability.level.to_str(),\n-                       reason = match stability.text {\n-                           Some(ref s) => (*s).clone(),\n-                           None => InternedString::new(\"\"),\n-                       }));\n-            }\n-            None => {}\n-        }\n+        // Write stability level\n+        try!(write!(fmt, \"{}\", Stability(&self.item.stability)));\n \n         // Write `src` tag\n         //\n@@ -1450,10 +1457,11 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n                 try!(write!(w, \"\n                     <tr>\n-                        <td><code>{}static {}{}: {}</code>{}</td>\n+                        <td>{}<code>{}static {}{}: {}</code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n                     </tr>\n                 \",\n+                ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n                 MutableSpace(s.mutability),\n                 *myitem.name.get_ref(),\n@@ -1488,7 +1496,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 if myitem.name.is_none() { continue }\n                 try!(write!(w, \"\n                     <tr>\n-                        <td><a class='{class}' href='{href}'\n+                        <td>{stab}<a class='{class}' href='{href}'\n                                title='{title}'>{}</a></td>\n                         <td class='docblock short'>{}</td>\n                     </tr>\n@@ -1497,7 +1505,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem)));\n+                title = full_path(cx, myitem),\n+                stab = ConciseStability(&myitem.stability)));\n             }\n         }\n     }\n@@ -1561,9 +1570,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(document(w, it));\n \n     fn meth(w: &mut fmt::Formatter, m: &clean::TraitMethod) -> fmt::Result {\n-        try!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n-                      shortty(m.item()),\n-                      *m.item().name.get_ref()));\n+        try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n+                    shortty(m.item()),\n+                    *m.item().name.get_ref(),\n+                    ConciseStability(&m.item().stability)));\n         try!(render_method(w, m.item()));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m.item()));\n@@ -1600,7 +1610,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     match cache.implementors.find(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors.iter() {\n-                try!(writeln!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}</code></li>\",\n+                              ConciseStability(&i.stability),\n                               i.generics, i.trait_, i.for_));\n             }\n         }\n@@ -1673,7 +1684,8 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in fields {\n                 try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                  <code>{name}</code></td><td>\",\n+                                  {stab}<code>{name}</code></td><td>\",\n+                              stab = ConciseStability(&field.stability),\n                               name = field.name.get_ref().as_slice()));\n                 try!(document(w, field));\n                 try!(write!(w, \"</td></tr>\"));\n@@ -1739,7 +1751,8 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     if e.variants.len() > 0 {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in e.variants.iter() {\n-            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+            try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n+                          stab = ConciseStability(&variant.stability),\n                           name = variant.name.get_ref().as_slice()));\n             try!(document(w, variant));\n             match variant.inner {\n@@ -1849,39 +1862,25 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache_key.get().unwrap().impls.find(&it.def_id) {\n         Some(v) => {\n-            let mut non_trait = v.iter().filter(|p| {\n-                p.ref0().trait_.is_none()\n-            });\n-            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<String>)>>();\n-            let mut traits = v.iter().filter(|p| {\n-                p.ref0().trait_.is_some()\n-            });\n-            let traits = traits.collect::<Vec<&(clean::Impl, Option<String>)>>();\n-\n+            let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n-                for &(ref i, ref dox) in non_trait.move_iter() {\n-                    try!(render_impl(w, i, dox));\n+                for i in non_trait.iter() {\n+                    try!(render_impl(w, i));\n                 }\n             }\n             if traits.len() > 0 {\n                 try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                   Implementations</h2>\"));\n-                let mut any_derived = false;\n-                for & &(ref i, ref dox) in traits.iter() {\n-                    if !i.derived {\n-                        try!(render_impl(w, i, dox));\n-                    } else {\n-                        any_derived = true;\n-                    }\n+                let (derived, manual) = traits.partition(|i| i.impl_.derived);\n+                for i in manual.iter() {\n+                    try!(render_impl(w, i));\n                 }\n-                if any_derived {\n+                if derived.len() > 0 {\n                     try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n                                 </h3>\"));\n-                    for &(ref i, ref dox) in traits.move_iter() {\n-                        if i.derived {\n-                            try!(render_impl(w, i, dox));\n-                        }\n+                    for i in derived.iter() {\n+                        try!(render_impl(w, i));\n                     }\n                 }\n             }\n@@ -1891,15 +1890,16 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n-               dox: &Option<String>) -> fmt::Result {\n-    try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n-    match i.trait_ {\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n+    try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n+                ConciseStability(&i.stability),\n+                i.impl_.generics));\n+    match i.impl_.trait_ {\n         Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n         None => {}\n     }\n-    try!(write!(w, \"{}</code></h3>\", i.for_));\n-    match *dox {\n+    try!(write!(w, \"{}</code></h3>\", i.impl_.for_));\n+    match i.dox {\n         Some(ref dox) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\",\n                           Markdown(dox.as_slice())));\n@@ -1909,8 +1909,9 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n \n     fn docmeth(w: &mut fmt::Formatter, item: &clean::Item,\n                dox: bool) -> fmt::Result {\n-        try!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n-                      *item.name.get_ref()));\n+        try!(write!(w, \"<h4 id='method.{}' class='method'>{}<code>\",\n+                    *item.name.get_ref(),\n+                    ConciseStability(&item.stability)));\n         try!(render_method(w, item));\n         try!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n@@ -1922,8 +1923,8 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n         }\n     }\n \n-    try!(write!(w, \"<div class='methods'>\"));\n-    for meth in i.methods.iter() {\n+    try!(write!(w, \"<div class='impl-methods'>\"));\n+    for meth in i.impl_.methods.iter() {\n         try!(docmeth(w, meth, true));\n     }\n \n@@ -1944,11 +1945,11 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n-    match i.trait_ {\n+    match i.impl_.trait_ {\n         Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n                 match cache_key.get().unwrap().traits.find(&did) {\n-                    Some(t) => try!(render_default_methods(w, t, i)),\n+                    Some(t) => try!(render_default_methods(w, t, &i.impl_)),\n                     None => {}\n                 }\n                 Ok(())"}, {"sha": "97048229ac4c1842180a90c6ace19b7c5dff06a0", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -258,8 +258,9 @@ nav.sub {\n .content .multi-column li { width: 100%; display: inline-block; }\n \n .content .method { font-size: 1em; }\n-.content .methods { margin-left: 20px; }\n-.content .methods .docblock { margin-left: 20px; }\n+.content .methods .docblock { margin-left: 40px; }\n+\n+.content .impl-methods .docblock { margin-left: 40px; }\n \n nav {\n     border-bottom: 1px solid #e0e0e0;\n@@ -372,20 +373,29 @@ p a:hover { text-decoration: underline; }\n }\n \n .stability {\n-    border-left: 6px solid #000;\n+    border-left: 6px solid;\n+    padding: 3px 6px;\n     border-radius: 3px;\n-    font-weight: 400;\n-    padding: 4px 10px;\n+}\n+\n+h1 .stability {\n     text-transform: lowercase;\n+    font-weight: 400;\n     margin-left: 14px;\n+    padding: 4px 10px;\n+}\n+\n+.impl-methods .stability {\n+    margin-right: 20px;\n }\n \n-.stability.Deprecated { border-color: #D60027; color: #880017; }\n-.stability.Experimental { border-color: #EC5315; color: #a53c0e; }\n-.stability.Unstable { border-color: #FFD700; color: #b39800; }\n-.stability.Stable { border-color: #AEC516; color: #7c8b10; }\n+.stability.Deprecated { border-color: #A071A8; color: #82478C; }\n+.stability.Experimental { border-color: #D46D6A; color: #AA3C39; }\n+.stability.Unstable { border-color: #D4B16A; color: #AA8439; }\n+.stability.Stable { border-color: #54A759; color: #2D8632; }\n .stability.Frozen { border-color: #009431; color: #007726; }\n .stability.Locked { border-color: #0084B6; color: #00668c; }\n+.stability.Unmarked { border-color: #FFFFFF; }\n \n :target { background: #FDFFD3; }\n "}, {"sha": "d878313ee28995c0e8e2f9507ff7d540ed3ad957", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -32,13 +32,16 @@ use std::io::{File, MemWriter};\n use std::str;\n use std::gc::Gc;\n use serialize::{json, Decodable, Encodable};\n+use externalfiles::ExternalHtml;\n \n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n \n pub mod clean;\n pub mod core;\n pub mod doctree;\n+#[macro_escape]\n+pub mod externalfiles;\n pub mod fold;\n pub mod html {\n     pub mod highlight;\n@@ -113,16 +116,17 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n                  \"ARGS\"),\n         optmulti(\"\", \"markdown-css\", \"CSS files to include via <link> in a rendered Markdown file\",\n                  \"FILES\"),\n-        optmulti(\"\", \"markdown-in-header\",\n-                 \"files to include inline in the <head> section of a rendered Markdown file\",\n+        optmulti(\"\", \"html-in-header\",\n+                 \"files to include inline in the <head> section of a rendered Markdown file \\\n+                 or generated documentation\",\n                  \"FILES\"),\n-        optmulti(\"\", \"markdown-before-content\",\n+        optmulti(\"\", \"html-before-content\",\n                  \"files to include inline between <body> and the content of a rendered \\\n-                 Markdown file\",\n+                 Markdown file or generated documentation\",\n                  \"FILES\"),\n-        optmulti(\"\", \"markdown-after-content\",\n+        optmulti(\"\", \"html-after-content\",\n                  \"files to include inline between the content and </body> of a rendered \\\n-                 Markdown file\",\n+                 Markdown file or generated documentation\",\n                  \"FILES\"),\n         optopt(\"\", \"markdown-playground-url\",\n                \"URL to send code snippets to\", \"URL\")\n@@ -179,6 +183,14 @@ pub fn main_args(args: &[String]) -> int {\n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n+    let external_html = match ExternalHtml::load(\n+            matches.opt_strs(\"html-in-header\").as_slice(),\n+            matches.opt_strs(\"html-before-content\").as_slice(),\n+            matches.opt_strs(\"html-after-content\").as_slice()) {\n+        Some(eh) => eh,\n+        None => return 3\n+    };\n+\n     match (should_test, markdown_input) {\n         (true, true) => {\n             return markdown::test(input, libs, test_args)\n@@ -187,7 +199,7 @@ pub fn main_args(args: &[String]) -> int {\n             return test::run(input, cfgs, libs, test_args)\n         }\n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n-                                                 &matches),\n+                                                 &matches, &external_html),\n         (false, false) => {}\n     }\n \n@@ -215,7 +227,7 @@ pub fn main_args(args: &[String]) -> int {\n     let started = time::precise_time_ns();\n     match matches.opt_str(\"w\").as_ref().map(|s| s.as_slice()) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, output.unwrap_or(Path::new(\"doc\"))) {\n+            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\"))) {\n                 Ok(()) => {}\n                 Err(e) => fail!(\"failed to generate documentation: {}\", e),\n             }\n@@ -396,18 +408,17 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n-    let mut json = box std::collections::TreeMap::new();\n-    json.insert(\"schema\".to_string(),\n-                json::String(SCHEMA_VERSION.to_string()));\n-    let plugins_json = box res.move_iter()\n-                              .filter_map(|opt| {\n-                                  match opt {\n-                                      None => None,\n-                                      Some((string, json)) => {\n-                                          Some((string.to_string(), json))\n-                                      }\n+    let mut json = std::collections::TreeMap::new();\n+    json.insert(\"schema\".to_string(), json::String(SCHEMA_VERSION.to_string()));\n+    let plugins_json = res.move_iter()\n+                          .filter_map(|opt| {\n+                              match opt {\n+                                  None => None,\n+                                  Some((string, json)) => {\n+                                      Some((string.to_string(), json))\n                                   }\n-                              }).collect();\n+                              }\n+                          }).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n@@ -417,7 +428,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n+        str::from_utf8_owned(w.unwrap()).unwrap()\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n@@ -428,6 +439,5 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"plugins\".to_string(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n-    try!(json::Object(json).to_writer(&mut file));\n-    Ok(())\n+    json::Object(json).to_writer(&mut file)\n }"}, {"sha": "da271be4768e3de393d2a22389a4db620cd7a360", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 8, "deletions": 51, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -9,43 +9,19 @@\n // except according to those terms.\n \n use std::collections::HashSet;\n-use std::{str, io};\n+use std::io;\n use std::string::String;\n \n use getopts;\n use testing;\n \n+use externalfiles::ExternalHtml;\n+\n use html::escape::Escape;\n use html::markdown;\n use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n use test::Collector;\n \n-fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n-    let mut f = try!(io::File::open(input));\n-    let d = try!(f.read_to_end());\n-    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()))\n-}\n-macro_rules! load_or_return {\n-    ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n-        {\n-            let input = Path::new($input);\n-            match load_string(&input) {\n-                Err(e) => {\n-                    let _ = writeln!(&mut io::stderr(),\n-                                     \"error reading `{}`: {}\", input.display(), e);\n-                    return $cant_read;\n-                }\n-                Ok(None) => {\n-                    let _ = writeln!(&mut io::stderr(),\n-                                     \"error reading `{}`: not UTF-8\", input.display());\n-                    return $not_utf8;\n-                }\n-                Ok(Some(s)) => s\n-            }\n-        }\n-    }\n-}\n-\n /// Separate any lines at the start of the file that begin with `%`.\n fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     let mut metadata = Vec::new();\n@@ -62,18 +38,10 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     (metadata, \"\")\n }\n \n-fn load_external_files(names: &[String]) -> Option<String> {\n-    let mut out = String::new();\n-    for name in names.iter() {\n-        out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n-        out.push_char('\\n');\n-    }\n-    Some(out)\n-}\n-\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int {\n+pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n+              external_html: &ExternalHtml) -> int {\n     let input_p = Path::new(input);\n     output.push(input_p.filestem().unwrap());\n     output.set_extension(\"html\");\n@@ -91,17 +59,6 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     }\n     let playground = playground.unwrap_or(\"\".to_string());\n \n-    let (in_header, before_content, after_content) =\n-        match (load_external_files(matches.opt_strs(\"markdown-in-header\")\n-                                          .as_slice()),\n-               load_external_files(matches.opt_strs(\"markdown-before-content\")\n-                                          .as_slice()),\n-               load_external_files(matches.opt_strs(\"markdown-after-content\")\n-                                          .as_slice())) {\n-        (Some(a), Some(b), Some(c)) => (a,b,c),\n-        _ => return 3\n-    };\n-\n     let mut out = match io::File::create(&output) {\n         Err(e) => {\n             let _ = writeln!(&mut io::stderr(),\n@@ -153,10 +110,10 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n </html>\"#,\n         title = Escape(title),\n         css = css,\n-        in_header = in_header,\n-        before_content = before_content,\n+        in_header = external_html.in_header,\n+        before_content = external_html.before_content,\n         text = MarkdownWithToc(text),\n-        after_content = after_content,\n+        after_content = external_html.after_content,\n         playground = playground,\n         );\n "}, {"sha": "9ac366655636cca447ce9c4a00895cb99e06521b", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -48,7 +48,7 @@ impl PluginManager {\n         let lib = lib_result.unwrap();\n         unsafe {\n             let plugin = lib.symbol(\"rustdoc_plugin_entrypoint\").unwrap();\n-            self.callbacks.push(mem::transmute::<*u8,PluginCallback>(plugin));\n+            self.callbacks.push(mem::transmute::<*mut u8,PluginCallback>(plugin));\n         }\n         self.dylibs.push(lib);\n     }"}, {"sha": "7e7f10f71783dd9d07171e2512dcfbda8e774b89", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -140,7 +140,14 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let old = io::stdio::set_stderr(box w1);\n     spawn(proc() {\n         let mut p = io::ChanReader::new(rx);\n-        let mut err = old.unwrap_or(box io::stderr() as Box<Writer + Send>);\n+        let mut err = match old {\n+            Some(old) => {\n+                // Chop off the `Send` bound.\n+                let old: Box<Writer> = old;\n+                old\n+            }\n+            None => box io::stderr() as Box<Writer>,\n+        };\n         io::util::copy(&mut p, &mut err).unwrap();\n     });\n     let emitter = diagnostic::EmitterWriter::new(box w2);"}, {"sha": "b7ef0956a7c7640a57593b0fbf133405d1b570cc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -15,9 +15,12 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n+use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n+use rustc::middle::stability;\n+\n use std::gc::{Gc, GC};\n \n use core;\n@@ -41,6 +44,14 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n+    fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n+        let tcx = match self.cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return None\n+        };\n+        stability::lookup(tcx, ast_util::local_def(id))\n+    }\n+\n     pub fn visit(&mut self, krate: &ast::Crate) {\n         self.attrs = krate.attrs.iter().map(|x| (*x).clone()).collect();\n \n@@ -65,6 +76,7 @@ impl<'a> RustdocVisitor<'a> {\n             struct_type: struct_type,\n             name: item.ident,\n             vis: item.vis,\n+            stab: self.stability(item.id),\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             generics: generics.clone(),\n             fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n@@ -81,6 +93,7 @@ impl<'a> RustdocVisitor<'a> {\n                 name: x.node.name,\n                 attrs: x.node.attrs.iter().map(|x| *x).collect(),\n                 vis: x.node.vis,\n+                stab: self.stability(x.node.id),\n                 id: x.node.id,\n                 kind: x.node.kind.clone(),\n                 where: x.span,\n@@ -90,6 +103,7 @@ impl<'a> RustdocVisitor<'a> {\n             name: it.ident,\n             variants: vars,\n             vis: it.vis,\n+            stab: self.stability(it.id),\n             generics: params.clone(),\n             attrs: it.attrs.iter().map(|x| *x).collect(),\n             id: it.id,\n@@ -104,6 +118,7 @@ impl<'a> RustdocVisitor<'a> {\n         Function {\n             id: item.id,\n             vis: item.vis,\n+            stab: self.stability(item.id),\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             decl: fd.clone(),\n             name: item.ident,\n@@ -125,6 +140,7 @@ impl<'a> RustdocVisitor<'a> {\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n         om.vis = vis;\n+        om.stab = self.stability(id);\n         om.id = id;\n         for i in m.items.iter() {\n             self.visit_item(&**i, &mut om);\n@@ -258,6 +274,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.typedefs.push(t);\n             },\n@@ -271,6 +288,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.statics.push(s);\n             },\n@@ -284,6 +302,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.traits.push(t);\n             },\n@@ -297,6 +316,7 @@ impl<'a> RustdocVisitor<'a> {\n                     id: item.id,\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.impls.push(i);\n             },\n@@ -309,6 +329,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     name: item.ident,\n                     where: item.span,\n+                    stab: self.stability(item.id),\n                 })\n             }\n         }"}, {"sha": "3c0a4aae251dbd90506a5af37a829274eec771e1", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b", "patch": "@@ -23,7 +23,7 @@ use core::prelude::*;\n use collections::vec::Vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n \n /// One-time global cleanup.\n pub unsafe fn cleanup() { imp::cleanup() }\n@@ -55,7 +55,7 @@ mod imp {\n     static mut global_args_ptr: uint = 0;\n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n-    pub unsafe fn init(argc: int, argv: **u8) {\n+    pub unsafe fn init(argc: int, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n@@ -99,7 +99,7 @@ mod imp {\n         unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<Vec<u8>> {\n+    unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         Vec::from_fn(argc as uint, |i| {\n             let base = *argv.offset(i as int);\n             let mut len = 0;\n@@ -151,7 +151,7 @@ mod imp {\n     use core::prelude::*;\n     use collections::vec::Vec;\n \n-    pub unsafe fn init(_argc: int, _argv: **u8) {\n+    pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n     }\n \n     pub fn cleanup() {"}, {"sha": "dcba7fb7cb6a6255d51b295c6c9f2d6d3e2d2d17", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "9734ba2d7518ef90995726a20ab5b8cd906037e9", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 174, "deletions": 98, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "fabef24e06ac724f5e7d2f5a0f839dabcafff553", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "6811a62c74f523f7cda3ed8943f2c20accc833e6", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "d4c87e9fc05c14e458ff110237360935b2baa28b", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "273505c416a3ca761d393390865a1f3bb989ef11", "filename": "src/librustrt/local_heap.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "813ea0f30f38b71afbb3655ccc7d82646ca1840c", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "6950d987d2f270d5339160118492e9d84619968b", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "0205f2405f9ce8e1345f214a103e39fad5cde3b3", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8e637207d2209c07879c581112e507c33c68296b", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "891d0d5a8e3592053b8c4ff14c08079a71b6abbb", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "9908e87e86a4727a0230eba1c77c66265bf8c9fd", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "3b9ee31d8e5078ff8170b246562ab2fbbf091abf", "filename": "src/librustrt/thread_local_storage.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "18688cbcc64ca788668db469d231b520b562533d", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "40c3e19576e4fa304467661d73aa8028da28325e", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "6eaab1c0961707347b3ab6070affe7105b3b0a82", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "97f95145b8992e6be43e19e5f2303c29d92ac577", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "76b2c22e86e0f3c1281c1d964220c6374ba231a0", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "91614763ce52f4ed669fe0a7c25dd367ef0f2451", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "7b9a2fcf4446779af43fad88ec92f87217afc9b3", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "4afcc9078ab988d9faaebb4cb5b712b450b7deb9", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "ddcaeccbc190f9927235259a31b0f3fddba16032", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "1c53814ac2441731be8ecdf52b04c7ef1c665fc6", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "61325d0ce948eb5bb6926ec4bcee141f30af0f7a", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "baaf1150ce0859261709abc0af5e99e45abeeb3f", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "49ef4e9a24bccad8f1ce42d507539e1c616b386b", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "f6b9226588ca34572a7ac8e87172f7c77569d989", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "1caaf5e0fc75dd04059388e6949be83be6531e22", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "9d0a56b3c851d69d82f15e3cdf4ab10a0278739b", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "70b17db8dcfdd147a8a4616866bbf41b94f028a4", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "61e52a3abd19cc0e11e2ad50d321c1ad5cc63593", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "863536a4111018c2d6919b96b3b8f64dfa058743", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 201, "deletions": 190, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "fc8aa8ac257a76f2769355979280750791041caa", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "63cfbd6d9aa17b20074716547b7118b8289ffb72", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "dfce1eeb832d574a635e4ac8abf8041513470dfd", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "51fab7b135458ae5e8f06adb03184f438d7c0cb5", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "832bc9c4e10cbb2c8f6085a2303aaaa92900e8d2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 311, "deletions": 523, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "fae1b933210d52a9c2f8f49499583eeb03f49873", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "834d461f20ba1517f85fede4cd68ccdbfaaf264d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "a7d697c8665ef639132dac200953b41e65d885c1", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "7c01a0342edc71b30bbcaf89597f1bfc10240b4c", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "08f11581e838a17a74f5ee8badd66b350e230066", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "ccef1c0fd2adb80331da2b646ff06de772ffba05", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "728875ce2601012f3d25b645de37fddae4212a36", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "47ff85e2806d562caf77f6e81d12dc1255e36e9f", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "5834e576b0814039d6c9c8d8396d052f58c41ea9", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "1ca72bca20bdb5cbec9b983e2e90f7f8e7991262", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "47b7426633c7b0c34e1631d922211cd44ab2397e", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2cc7e70747a794403675e44d28ea6a4b0b8d829d", "filename": "src/libstd/hash.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "cd5887b7add0011d6ebf96cae8caad21019922a6", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "277aca2332d475cb1b42a9852f0f59b793d2d505", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "e7f26c7bd910e5d21d61de30a703734684f9f1a4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "1d339b03af6717d9eb68e4908f3e6e4e7333bbf8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "baf53251fbe082e5e485ac2df70e64d7dc36c72d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "cd78898d46bb82c22c73b54f39f8d3a3bfc3e516", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "26e854d9d999fa1b58eae5e061c878a5472a9c70", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "145e812ff88de4fa2118d81166c1ccde4d93f2f5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8b79af8c9310d27c4ad8f6fa73711417a47dd91d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2b2ffb9f4e281706052a95a1797d3c10b984cf00", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "e156d2ce553240b629b6594429b60ef3eb303725", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "519de85edde65f3c4fa6aa535ce3a9064ee77f99", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "a4200b55a5906f575aa1bc6942f6a7a7f7cc4a47", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "27ee1e3ce3bb31d8c1e42d05b9b9e670261b47cc", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "7f2efe034a24a77b8c4acb8ae83e1abef89eff64", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "6674dd532aeb0b5f76d924b3e8c5a5555a863a00", "filename": "src/libstd/os.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "7d814df8ebf95dd11190f7d00f0db804f31c7fad", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "113b0410875af7ad0d068d0b394554320715de96", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "61e8b63af359ef6d042d511d7b785a049a82f0c3", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "0ffaadef0a1303c876c52d3a4bcd8cc8f68b9659", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "60e2c4c894919eb8266b200c958135d9e7c7d70b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8f51e834c6a024ec0d67b9319908fb0db88cf45d", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "4490977bde619ef833f725c75af39cb9fa8ef796", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "0ffac99775c11a75ceac8651d1083d98b41ba7fc", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "cc32818baa4561df7fd3e75a37440cae33388b38", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "c20cbea0ae7cced97332673d8e1eda74ea934486", "filename": "src/libstd/task.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "e51e2c4d9ce5e5acbff2437c02d9e37d26bc2a2e", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "195efb844a78328fe3bc0535cece16307d057492", "filename": "src/libsync/atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fatomics.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "44dd63cbf6c010cfd63058c9d6700e4b00922fa4", "filename": "src/libsync/comm/duplex.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "6c09a021c4338212efe8056a38efd07f76f6229e", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "230bca624f5a7f61ae80f9c2a4ef0f74f8b6b316", "filename": "src/libsync/comm/select.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8d2192aeb537ed19b823b1ed62eeebb34774fd4d", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "1d119bafea19955e03c2fdaaae0e83c003bedd32", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2b6886ab7f434f25f72cf89ac950b7f4b91383c2", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "ecd37e68880555dba3a43d41d955d4762e71f685", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "26cc0b2c6a23cd772889819cfad701cd48c523e3", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2834d404c1879e7de75b7b45577edbfbfcd01d7e", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "529b460adcd34d862bcb951e8ee00a8f27358d40", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "dfaa9fb5fcb09507f31144396946f7708b588c40", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "59cdec1ea88f07f240ad27aca105053111f6b475", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "b9cedb7a7797a065a9b32a34e137ef12b1310972", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 135, "deletions": 97, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "48895d34022c4c28b9459b2c1b23d48102730073", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "c6177ce31f5f874a8282020d717a6ca2f1c792bf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 93, "deletions": 57, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "530ea013112386f1203d00135452273cc9ad4008", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "0f188fdf18a5a80c06ee94126b1ac47e16198674", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "0fd5a7086b78c897507508137b3d7c410242a6a5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "a93e8270d9866c0b12fe791ab2127411b3a43ffb", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "a9cf4fbd9f0f130855ce8c67d9bc5f0ab6f58a56", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "43367611ab2b9bdade7c409237ccb678bc5db2cb", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "56694e28b666227e1a87c513d83c40c119e3c99e", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "02f7ebc6d21c816d007b4a4f3c1cabb7e8c67172", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "fc191c78eef5e541af24771da637cfea8e182671", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "a60cc8e992b4d58592ee11818f5a4ee84b90e207", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "297afe4aa598e4b21ac30e5c7a55331b1fb6daa5", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "5c694b34193ef981489759aba1b064e90c9fd34d", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "d8f96e5abd44393ce6435a24654734e173a45bc6", "filename": "src/test/auxiliary/issue-8044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-8044.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "c0cb501735da3d8b1c6a1376993f72626c915473", "filename": "src/test/auxiliary/issue-9906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "ee7787d6fccf56bb02d7f7f6a5b2a1fb3830353a", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8065533dd738269766733fe45ec908a17c1deefc", "filename": "src/test/auxiliary/xcrate_static_addresses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2b9abfbc350a64b9ef94fbe174f1cd4eaf9eb71b", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "afed753f455beb2f3184dedc0466b0dfed0ae080", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2737c6df533fec71f3b77fe47b0120c06f34fa36", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "195c146c12fe719f26927bef8016837b91852345", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "2d98668496cdb52e08c17a2a7d201ce41914106a", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "e13c53407e457f53d55aa68be1bd7610c4e85a08", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}, {"sha": "8cec135944fd847a377633a4a198915777b1048e", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1dd44b40a7243f43a8d32ba8bd6026197c320b/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=ff1dd44b40a7243f43a8d32ba8bd6026197c320b"}]}