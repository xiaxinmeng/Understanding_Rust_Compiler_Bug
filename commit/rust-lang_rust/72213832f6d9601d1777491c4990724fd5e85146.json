{"sha": "72213832f6d9601d1777491c4990724fd5e85146", "node_id": "C_kwDOAAsO6NoAKDcyMjEzODMyZjZkOTYwMWQxNzc3NDkxYzQ5OTA3MjRmZDVlODUxNDY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-03T17:34:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-03T17:34:49Z"}, "message": "Rollup merge of #107082 - dtolnay:autotraits, r=lcnr\n\nAutotrait bounds on dyn-safe trait methods\n\nThis PR is a successor to #106604 implementing the approach encouraged by https://github.com/rust-lang/rust/pull/106604#issuecomment-1387353737.\n\n**I propose making it legal to use autotraits as trait bounds on the `Self` type of trait methods in a trait object.** https://github.com/rust-lang/rust/issues/51443#issuecomment-1374847313 justifies why this use case is particularly important in the context of the async-trait crate.\n\n```rust\n#![feature(auto_traits)]\n#![deny(where_clauses_object_safety)]\n\nauto trait AutoTrait {}\n\ntrait MyTrait {\n    fn f(&self) where Self: AutoTrait;\n}\n\nfn main() {\n    let _: &dyn MyTrait;\n}\n```\n\nPreviously this would fail with:\n\n```console\nerror: the trait `MyTrait` cannot be made into an object\n --> src/main.rs:7:8\n  |\n7 |     fn f(&self) where Self: AutoTrait;\n  |        ^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #51443 <https://github.com/rust-lang/rust/issues/51443>\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n --> src/main.rs:7:8\n  |\n6 | trait MyTrait {\n  |       ------- this trait cannot be made into an object...\n7 |     fn f(&self) where Self: AutoTrait;\n  |        ^ ...because method `f` references the `Self` type in its `where` clause\n  = help: consider moving `f` to another trait\n```\n\nIn order for this to be sound without hitting #50781, **I further propose that we disallow handwritten autotrait impls that apply to trait objects.** Both of the following were previously allowed (_on nightly_) and no longer allowed in my proposal:\n\n```rust\nauto trait AutoTrait {}\n\ntrait MyTrait {}\nimpl AutoTrait for dyn MyTrait {}  // NOT ALLOWED\n\nimpl<T: ?Sized> AutoTrait for T {}  // NOT ALLOWED\n```\n\n(`impl<T> AutoTrait for T {}` remains allowed.)\n\nAfter this change, traits with a default impl are implemented for a trait object **if and only if** the autotrait is one of the trait object's trait bounds (or a supertrait of a bound). In other words `dyn Trait + AutoTrait` always implements AutoTrait while `dyn Trait` never implements AutoTrait.\n\nFixes https://github.com/dtolnay/async-trait/issues/228.\n\nr? `@lcnr`", "tree": {"sha": "94a053116f1036348d12e5f91e8e32e26f1c48b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94a053116f1036348d12e5f91e8e32e26f1c48b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72213832f6d9601d1777491c4990724fd5e85146", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj3UW5CRBK7hj4Ov3rIwAAn84IAATKwu3Mvgn8rPUjsk/WDG/V\nomxv/0V2ePfT/lUxNYS8VW+TrDbzgk6O795LjLdO9Uaom6wqLrORBT967UPjLw9G\nhZfka0f+oqO1Dz/et1T607dGuzwilR/e0TauHreD+nX9tw6WVk2ZkuIIseXI9zL1\nMbRix1sbeC2U0XNl2uULrf/pPJdevpyzxdBJyU8MYKLX2VFZX34LnM/N8u+6vQa8\nImNheyfhvhFss4a37vogUEdCaxdCG7tmKapwm0vHUGGWqV6nYcuWEWsOtEbcVxwH\nnGWQI7+flA6kZsKff6zWfTwoBM9IWqeeGPTftKA+v6b7H+b9gdOcPQixtBvm2TU=\n=wDMi\n-----END PGP SIGNATURE-----\n", "payload": "tree 94a053116f1036348d12e5f91e8e32e26f1c48b9\nparent a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92\nparent 4501d3abe17a3dc10f0dffcb38be04b58a33bafb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1675445689 +0530\ncommitter GitHub <noreply@github.com> 1675445689 +0530\n\nRollup merge of #107082 - dtolnay:autotraits, r=lcnr\n\nAutotrait bounds on dyn-safe trait methods\n\nThis PR is a successor to #106604 implementing the approach encouraged by https://github.com/rust-lang/rust/pull/106604#issuecomment-1387353737.\n\n**I propose making it legal to use autotraits as trait bounds on the `Self` type of trait methods in a trait object.** https://github.com/rust-lang/rust/issues/51443#issuecomment-1374847313 justifies why this use case is particularly important in the context of the async-trait crate.\n\n```rust\n#![feature(auto_traits)]\n#![deny(where_clauses_object_safety)]\n\nauto trait AutoTrait {}\n\ntrait MyTrait {\n    fn f(&self) where Self: AutoTrait;\n}\n\nfn main() {\n    let _: &dyn MyTrait;\n}\n```\n\nPreviously this would fail with:\n\n```console\nerror: the trait `MyTrait` cannot be made into an object\n --> src/main.rs:7:8\n  |\n7 |     fn f(&self) where Self: AutoTrait;\n  |        ^\n  |\n  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n  = note: for more information, see issue #51443 <https://github.com/rust-lang/rust/issues/51443>\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n --> src/main.rs:7:8\n  |\n6 | trait MyTrait {\n  |       ------- this trait cannot be made into an object...\n7 |     fn f(&self) where Self: AutoTrait;\n  |        ^ ...because method `f` references the `Self` type in its `where` clause\n  = help: consider moving `f` to another trait\n```\n\nIn order for this to be sound without hitting #50781, **I further propose that we disallow handwritten autotrait impls that apply to trait objects.** Both of the following were previously allowed (_on nightly_) and no longer allowed in my proposal:\n\n```rust\nauto trait AutoTrait {}\n\ntrait MyTrait {}\nimpl AutoTrait for dyn MyTrait {}  // NOT ALLOWED\n\nimpl<T: ?Sized> AutoTrait for T {}  // NOT ALLOWED\n```\n\n(`impl<T> AutoTrait for T {}` remains allowed.)\n\nAfter this change, traits with a default impl are implemented for a trait object **if and only if** the autotrait is one of the trait object's trait bounds (or a supertrait of a bound). In other words `dyn Trait + AutoTrait` always implements AutoTrait while `dyn Trait` never implements AutoTrait.\n\nFixes https://github.com/dtolnay/async-trait/issues/228.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72213832f6d9601d1777491c4990724fd5e85146", "html_url": "https://github.com/rust-lang/rust/commit/72213832f6d9601d1777491c4990724fd5e85146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72213832f6d9601d1777491c4990724fd5e85146/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92", "html_url": "https://github.com/rust-lang/rust/commit/a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92"}, {"sha": "4501d3abe17a3dc10f0dffcb38be04b58a33bafb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4501d3abe17a3dc10f0dffcb38be04b58a33bafb", "html_url": "https://github.com/rust-lang/rust/commit/4501d3abe17a3dc10f0dffcb38be04b58a33bafb"}], "stats": {"total": 455, "additions": 377, "deletions": 78}, "files": [{"sha": "ad71dcdf9d95384421a94cf71d35277e8dde8b03", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -31,8 +31,8 @@ cfg_if! {\n         pub auto trait Send {}\n         pub auto trait Sync {}\n \n-        impl<T: ?Sized> Send for T {}\n-        impl<T: ?Sized> Sync for T {}\n+        impl<T> Send for T {}\n+        impl<T> Sync for T {}\n \n         #[macro_export]\n         macro_rules! rustc_erase_owner {"}, {"sha": "7d381d8902ac2f10ee913ac96fe7c98ec0d01613", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 183, "deletions": 40, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n-    self, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -86,7 +86,7 @@ fn do_orphan_check_impl<'tcx>(\n     // struct B { }\n     // impl Foo for A { }\n     // impl Foo for B { }\n-    // impl !Send for (A, B) { }\n+    // impl !Foo for (A, B) { }\n     // ```\n     //\n     // This final impl is legal according to the orphan\n@@ -99,50 +99,193 @@ fn do_orphan_check_impl<'tcx>(\n         tcx.trait_is_auto(trait_def_id)\n     );\n \n-    if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n+    if tcx.trait_is_auto(trait_def_id) {\n         let self_ty = trait_ref.self_ty();\n-        let opt_self_def_id = match *self_ty.kind() {\n-            ty::Adt(self_def, _) => Some(self_def.did()),\n-            ty::Foreign(did) => Some(did),\n-            _ => None,\n-        };\n \n-        let msg = match opt_self_def_id {\n-            // We only want to permit nominal types, but not *all* nominal types.\n-            // They must be local to the current crate, so that people\n-            // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-            // `impl !Send for Box<SomethingLocalAndSend>`.\n-            Some(self_def_id) => {\n-                if self_def_id.is_local() {\n-                    None\n+        // If the impl is in the same crate as the auto-trait, almost anything\n+        // goes.\n+        //\n+        //     impl MyAuto for Rc<Something> {}  // okay\n+        //     impl<T> !MyAuto for *const T {}   // okay\n+        //     impl<T> MyAuto for T {}           // okay\n+        //\n+        // But there is one important exception: implementing for a trait object\n+        // is not allowed.\n+        //\n+        //     impl MyAuto for dyn Trait {}      // NOT OKAY\n+        //     impl<T: ?Sized> MyAuto for T {}   // NOT OKAY\n+        //\n+        // With this restriction, it's guaranteed that an auto-trait is\n+        // implemented for a trait object if and only if the auto-trait is one\n+        // of the trait object's trait bounds (or a supertrait of a bound). In\n+        // other words `dyn Trait + AutoTrait` always implements AutoTrait,\n+        // while `dyn Trait` never implements AutoTrait.\n+        //\n+        // This is necessary in order for autotrait bounds on methods of trait\n+        // objects to be sound.\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait ObjectSafeTrait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // We can allow f to be called on `dyn ObjectSafeTrait + AutoTrait`.\n+        //\n+        // If we didn't deny `impl AutoTrait for dyn Trait`, it would be unsound\n+        // for the ObjectSafeTrait shown above to be object safe because someone\n+        // could take some type implementing ObjectSafeTrait but not AutoTrait,\n+        // unsize it to `dyn ObjectSafeTrait`, and call .f() which has no\n+        // concrete implementation (issue #50781).\n+        enum LocalImpl {\n+            Allow,\n+            Disallow { problematic_kind: &'static str },\n+        }\n+\n+        // If the auto-trait is from a dependency, it must only be getting\n+        // implemented for a nominal type, and specifically one local to the\n+        // current crate.\n+        //\n+        //     impl<T> Sync for MyStruct<T> {}   // okay\n+        //\n+        //     impl Sync for Rc<MyStruct> {}     // NOT OKAY\n+        enum NonlocalImpl {\n+            Allow,\n+            DisallowBecauseNonlocal,\n+            DisallowOther,\n+        }\n+\n+        // Exhaustive match considering that this logic is essential for\n+        // soundness.\n+        let (local_impl, nonlocal_impl) = match self_ty.kind() {\n+            // struct Struct<T>;\n+            // impl AutoTrait for Struct<Foo> {}\n+            ty::Adt(self_def, _) => (\n+                LocalImpl::Allow,\n+                if self_def.did().is_local() {\n+                    NonlocalImpl::Allow\n+                } else {\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // extern { type OpaqueType; }\n+            // impl AutoTrait for OpaqueType {}\n+            ty::Foreign(did) => (\n+                LocalImpl::Allow,\n+                if did.is_local() {\n+                    NonlocalImpl::Allow\n                 } else {\n-                    Some((\n-                        format!(\n-                            \"cross-crate traits with a default impl, like `{}`, \\\n-                                    can only be implemented for a struct/enum type \\\n-                                    defined in the current crate\",\n-                            tcx.def_path_str(trait_def_id)\n-                        ),\n-                        \"can't implement cross-crate trait for type in another crate\",\n-                    ))\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // impl AutoTrait for dyn Trait {}\n+            ty::Dynamic(..) => (\n+                LocalImpl::Disallow { problematic_kind: \"trait object\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // impl<T> AutoTrait for T {}\n+            // impl<T: ?Sized> AutoTrait for T {}\n+            ty::Param(..) => (\n+                if self_ty.is_sized(tcx, tcx.param_env(def_id)) {\n+                    LocalImpl::Allow\n+                } else {\n+                    LocalImpl::Disallow { problematic_kind: \"generic type\" }\n+                },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // trait Id { type This: ?Sized; }\n+            // impl<T: ?Sized> Id for T {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for <T as Id>::This {}\n+            ty::Alias(AliasKind::Projection, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // type Opaque = impl Trait;\n+            // impl AutoTrait for Opaque {}\n+            ty::Alias(AliasKind::Opaque, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"opaque type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..) => (LocalImpl::Allow, NonlocalImpl::DisallowOther),\n+\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(..)\n+            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+\n+            ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n+        };\n+\n+        if trait_def_id.is_local() {\n+            match local_impl {\n+                LocalImpl::Allow => {}\n+                LocalImpl::Disallow { problematic_kind } => {\n+                    let msg = format!(\n+                        \"traits with a default impl, like `{trait}`, \\\n+                                cannot be implemented for {problematic_kind} `{self_ty}`\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let label = format!(\n+                        \"a trait object implements `{trait}` if and only if `{trait}` \\\n+                                is one of the trait object's trait bounds\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let reported =\n+                        struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n+                    return Err(reported);\n                 }\n             }\n-            _ => Some((\n-                format!(\n-                    \"cross-crate traits with a default impl, like `{}`, can \\\n+        } else {\n+            if let Some((msg, label)) = match nonlocal_impl {\n+                NonlocalImpl::Allow => None,\n+                NonlocalImpl::DisallowBecauseNonlocal => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, \\\n+                                can only be implemented for a struct/enum type \\\n+                                defined in the current crate\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    \"can't implement cross-crate trait for type in another crate\",\n+                )),\n+                NonlocalImpl::DisallowOther => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, can \\\n                                 only be implemented for a struct/enum type, not `{}`\",\n-                    tcx.def_path_str(trait_def_id),\n-                    self_ty\n-                ),\n-                \"can't implement cross-crate trait with a default impl for \\\n-                        non-struct/enum type\",\n-            )),\n-        };\n-\n-        if let Some((msg, label)) = msg {\n-            let reported =\n-                struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n-            return Err(reported);\n+                        tcx.def_path_str(trait_def_id),\n+                        self_ty\n+                    ),\n+                    \"can't implement cross-crate trait with a default impl for \\\n+                            non-struct/enum type\",\n+                )),\n+            } {\n+                let reported =\n+                    struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n+                return Err(reported);\n+            }\n         }\n     }\n "}, {"sha": "8f548acfd2eaccc8834f326f04cb201dcefd8e6d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -547,16 +547,56 @@ fn virtual_call_violation_for_method<'tcx>(\n \n     // NOTE: This check happens last, because it results in a lint, and not a\n     // hard error.\n-    if tcx\n-        .predicates_of(method.def_id)\n-        .predicates\n-        .iter()\n-        // A trait object can't claim to live more than the concrete type,\n-        // so outlives predicates will always hold.\n-        .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n-    {\n+    if tcx.predicates_of(method.def_id).predicates.iter().any(|&(pred, span)| {\n+        // dyn Trait is okay:\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: 'static;\n+        //     }\n+        //\n+        // because a trait object can't claim to live longer than the concrete\n+        // type. If the lifetime bound holds on dyn Trait then it's guaranteed\n+        // to hold as well on the concrete type.\n+        if pred.to_opt_type_outlives().is_some() {\n+            return false;\n+        }\n+\n+        // dyn Trait is okay:\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // because `impl AutoTrait for dyn Trait` is disallowed by coherence.\n+        // Traits with a default impl are implemented for a trait object if and\n+        // only if the autotrait is one of the trait object's trait bounds, like\n+        // in `dyn Trait + AutoTrait`. This guarantees that trait objects only\n+        // implement auto traits if the underlying type does as well.\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref: pred_trait_ref,\n+            constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n+        })) = pred.kind().skip_binder()\n+            && pred_trait_ref.self_ty() == tcx.types.self_param\n+            && tcx.trait_is_auto(pred_trait_ref.def_id)\n+        {\n+            // Consider bounds like `Self: Bound<Self>`. Auto traits are not\n+            // allowed to have generic parameters so `auto trait Bound<T> {}`\n+            // would already have reported an error at the definition of the\n+            // auto trait.\n+            if pred_trait_ref.substs.len() != 1 {\n+                tcx.sess.diagnostic().delay_span_bug(\n+                    span,\n+                    \"auto traits cannot have generic parameters\",\n+                );\n+            }\n+            return false;\n+        }\n+\n+        contains_illegal_self_type_reference(tcx, trait_def_id, pred.clone())\n+    }) {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n "}, {"sha": "98f1558b7ffe18d5493f4628ac97cd3738feb44a", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl !Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl !Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n // ...and also a direct component.\n-impl !Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl !Marker2 for dyn Object {} // OK\n+impl !Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n \n // A non-principal trait-object type is orphan even in its crate.\n impl !Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl !Marker2 for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> !Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> !Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "ea38afc40ce80bf82ad8bf5702984152899b02e5", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n    |\n-LL | impl !Marker1 for dyn Object + Marker2 { }\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n+   |\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n    |\n-LL | impl !Marker2 for dyn Object + Marker2 { }\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n+   |\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:26:1\n+   |\n+LL | impl !Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:22:1\n    |\n LL | impl !Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | impl !Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:32:1\n+   |\n+LL | impl<T: ?Sized> !Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "db2e2b4509a2af6f5c85d77d5722d8cae7355792", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n // ...and also a direct component.\n-impl Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl Marker2 for dyn Object {} // OK\n+impl Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n \n // A non-principal trait-object type is orphan even in its crate.\n unsafe impl Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl Marker2 for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "2a8713bc327942496550e57aa390781c10a741c2", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n    |\n-LL | impl Marker1 for dyn Object + Marker2 { }\n+LL | impl Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n+   |\n+LL | impl Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n    |\n-LL | impl Marker2 for dyn Object + Marker2 { }\n+LL | impl Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n+   |\n+LL | impl Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:26:1\n+   |\n+LL | impl Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:22:1\n    |\n LL | unsafe impl Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | unsafe impl Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:32:1\n+   |\n+LL | impl<T: ?Sized> Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "6cf5ed2e46aecbe526d158afa903146d8e92bd82", "filename": "tests/ui/where-clauses/self-in-where-clause-allowed.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -0,0 +1,23 @@\n+// check-fail\n+\n+#![feature(auto_traits)]\n+#![deny(where_clauses_object_safety)]\n+\n+auto trait AutoTrait {}\n+\n+trait Trait {\n+    fn static_lifetime_bound(&self) where Self: 'static {}\n+\n+    fn arg_lifetime_bound<'a>(&self, _arg: &'a ()) where Self: 'a {}\n+\n+    fn autotrait_bound(&self) where Self: AutoTrait {}\n+}\n+\n+impl Trait for () {}\n+\n+fn main() {\n+    let trait_object = &() as &dyn Trait;\n+    trait_object.static_lifetime_bound();\n+    trait_object.arg_lifetime_bound(&());\n+    trait_object.autotrait_bound(); //~ ERROR: the trait bound `dyn Trait: AutoTrait` is not satisfied\n+}"}, {"sha": "ea51f5084f8755e59cee5dcd91dbfcd15623797e", "filename": "tests/ui/where-clauses/self-in-where-clause-allowed.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72213832f6d9601d1777491c4990724fd5e85146/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr?ref=72213832f6d9601d1777491c4990724fd5e85146", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `dyn Trait: AutoTrait` is not satisfied\n+  --> $DIR/self-in-where-clause-allowed.rs:22:18\n+   |\n+LL |     trait_object.autotrait_bound();\n+   |                  ^^^^^^^^^^^^^^^ the trait `AutoTrait` is not implemented for `dyn Trait`\n+   |\n+note: required by a bound in `Trait::autotrait_bound`\n+  --> $DIR/self-in-where-clause-allowed.rs:13:43\n+   |\n+LL |     fn autotrait_bound(&self) where Self: AutoTrait {}\n+   |                                           ^^^^^^^^^ required by this bound in `Trait::autotrait_bound`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}