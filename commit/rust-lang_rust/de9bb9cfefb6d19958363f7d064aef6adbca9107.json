{"sha": "de9bb9cfefb6d19958363f7d064aef6adbca9107", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOWJiOWNmZWZiNmQxOTk1ODM2M2Y3ZDA2NGFlZjZhZGJjYTkxMDc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-05T11:12:04Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-05T11:12:04Z"}, "message": "Merge #193\n\n193: Inline modules r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7b332c6db6e662ca31aafded143476d81a60453f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b332c6db6e662ca31aafded143476d81a60453f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de9bb9cfefb6d19958363f7d064aef6adbca9107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de9bb9cfefb6d19958363f7d064aef6adbca9107", "html_url": "https://github.com/rust-lang/rust/commit/de9bb9cfefb6d19958363f7d064aef6adbca9107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de9bb9cfefb6d19958363f7d064aef6adbca9107/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "6502bd2c966d57bdb8fbba7f43da9ddd004d87d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6502bd2c966d57bdb8fbba7f43da9ddd004d87d3", "html_url": "https://github.com/rust-lang/rust/commit/6502bd2c966d57bdb8fbba7f43da9ddd004d87d3"}, {"sha": "6bbcfca7aec6408cf27415ae6f965adc472d6f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbcfca7aec6408cf27415ae6f965adc472d6f18", "html_url": "https://github.com/rust-lang/rust/commit/6bbcfca7aec6408cf27415ae6f965adc472d6f18"}], "stats": {"total": 285, "additions": 198, "deletions": 87}, "files": [{"sha": "766df1d962eda870ce86793280edc504f9bad384", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -11,7 +11,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use crate::{\n     db::{self, SyntaxDatabase},\n     descriptors::function::FnScopes,\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree},\n+    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n     descriptors::DescriptorDatabase,\n     input::FilesDatabase,\n     Cancelable, FileId,\n@@ -35,7 +35,7 @@ pub(crate) fn resolve_based_completion(\n     let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n     let module_tree = db.module_tree(source_root_id)?;\n-    let module_id = match module_tree.any_module_for_file(file_id) {\n+    let module_id = match module_tree.any_module_for_source(ModuleSource::File(file_id)) {\n         None => return Ok(None),\n         Some(it) => it,\n     };"}, {"sha": "56bde38492cf67bfe4572897aa292cd09f9b2a9b", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -5,16 +5,16 @@ use std::sync::Arc;\n \n use ra_syntax::{\n     ast::{self, AstNode, FnDefNode},\n-    SmolStr, TextRange,\n+    TextRange,\n };\n \n use crate::{\n     db::SyntaxDatabase,\n     descriptors::function::{resolve_local_name, FnId, FnScopes},\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree},\n+    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n     input::SourceRootId,\n     syntax_ptr::LocalSyntaxPtr,\n-    Cancelable, FileId,\n+    Cancelable,\n };\n \n salsa::query_group! {\n@@ -23,7 +23,7 @@ salsa::query_group! {\n             type ModuleTreeQuery;\n             use fn module::imp::module_tree;\n         }\n-        fn submodules(file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n+        fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<module::imp::Submodule>>> {\n             type SubmodulesQuery;\n             use fn module::imp::submodules;\n         }"}, {"sha": "b3b1f1f216664806caac030ffbc8a63ac08347e9", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 110, "deletions": 39, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -19,25 +19,66 @@ use super::{\n     ModuleTree, Problem,\n };\n \n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub(crate) enum Submodule {\n+    Declaration(SmolStr),\n+    Definition(SmolStr, ModuleSource),\n+}\n+\n+impl Submodule {\n+    fn name(&self) -> &SmolStr {\n+        match self {\n+            Submodule::Declaration(name) => name,\n+            Submodule::Definition(name, _) => name,\n+        }\n+    }\n+}\n+\n pub(crate) fn submodules(\n     db: &impl DescriptorDatabase,\n-    file_id: FileId,\n-) -> Cancelable<Arc<Vec<SmolStr>>> {\n+    source: ModuleSource,\n+) -> Cancelable<Arc<Vec<Submodule>>> {\n     db::check_canceled(db)?;\n-    let file = db.file_syntax(file_id);\n-    let root = file.ast();\n-    let submodules = modules(root).map(|(name, _)| name).collect();\n-    Ok(Arc::new(submodules))\n+    let file_id = source.file_id();\n+    let submodules = match source.resolve(db) {\n+        ModuleSourceNode::Root(it) => collect_submodules(file_id, it.ast()),\n+        ModuleSourceNode::Inline(it) => it\n+            .ast()\n+            .item_list()\n+            .map(|it| collect_submodules(file_id, it))\n+            .unwrap_or_else(Vec::new),\n+    };\n+    return Ok(Arc::new(submodules));\n+\n+    fn collect_submodules<'a>(\n+        file_id: FileId,\n+        root: impl ast::ModuleItemOwner<'a>,\n+    ) -> Vec<Submodule> {\n+        modules(root)\n+            .map(|(name, m)| {\n+                if m.has_semi() {\n+                    Submodule::Declaration(name)\n+                } else {\n+                    let src = ModuleSource::new_inline(file_id, m);\n+                    Submodule::Definition(name, src)\n+                }\n+            })\n+            .collect()\n+    }\n }\n \n-pub(crate) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast::Module<'_>)> {\n-    root.modules().filter_map(|module| {\n-        let name = module.name()?.text();\n-        if !module.has_semi() {\n-            return None;\n-        }\n-        Some((name, module))\n-    })\n+pub(crate) fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            Some((name, module))\n+        })\n }\n \n pub(crate) fn module_scope(\n@@ -66,11 +107,6 @@ pub(crate) fn module_tree(\n     Ok(Arc::new(res))\n }\n \n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub struct Submodule {\n-    pub name: SmolStr,\n-}\n-\n fn create_module_tree<'a>(\n     db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n@@ -85,7 +121,8 @@ fn create_module_tree<'a>(\n \n     let source_root = db.source_root(source_root);\n     for &file_id in source_root.files.iter() {\n-        if visited.contains(&file_id) {\n+        let source = ModuleSource::File(file_id);\n+        if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n         }\n         assert!(!roots.contains_key(&file_id));\n@@ -96,7 +133,7 @@ fn create_module_tree<'a>(\n             &mut visited,\n             &mut roots,\n             None,\n-            file_id,\n+            source,\n         )?;\n         roots.insert(file_id, module_id);\n     }\n@@ -107,47 +144,81 @@ fn build_subtree(\n     db: &impl DescriptorDatabase,\n     source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<FileId>,\n+    visited: &mut FxHashSet<ModuleSource>,\n     roots: &mut FxHashMap<FileId, ModuleId>,\n     parent: Option<LinkId>,\n-    file_id: FileId,\n+    source: ModuleSource,\n ) -> Cancelable<ModuleId> {\n-    visited.insert(file_id);\n+    visited.insert(source);\n     let id = tree.push_mod(ModuleData {\n-        source: ModuleSource::File(file_id),\n+        source,\n         parent,\n         children: Vec::new(),\n     });\n-    for name in db.submodules(file_id)?.iter() {\n-        let (points_to, problem) = resolve_submodule(file_id, name, &source_root.file_resolver);\n+    for sub in db.submodules(source)?.iter() {\n         let link = tree.push_link(LinkData {\n-            name: name.clone(),\n+            name: sub.name().clone(),\n             owner: id,\n             points_to: Vec::new(),\n             problem: None,\n         });\n \n-        let points_to = points_to\n-            .into_iter()\n-            .map(|file_id| match roots.remove(&file_id) {\n-                Some(module_id) => {\n-                    tree.module_mut(module_id).parent = Some(link);\n-                    Ok(module_id)\n-                }\n-                None => build_subtree(db, source_root, tree, visited, roots, Some(link), file_id),\n-            })\n-            .collect::<Cancelable<Vec<_>>>()?;\n+        let (points_to, problem) = match sub {\n+            Submodule::Declaration(name) => {\n+                let (points_to, problem) =\n+                    resolve_submodule(source, &name, &source_root.file_resolver);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            tree.module_mut(module_id).parent = Some(link);\n+                            Ok(module_id)\n+                        }\n+                        None => build_subtree(\n+                            db,\n+                            source_root,\n+                            tree,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            ModuleSource::File(file_id),\n+                        ),\n+                    })\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                (points_to, problem)\n+            }\n+            Submodule::Definition(_name, submodule_source) => {\n+                let points_to = build_subtree(\n+                    db,\n+                    source_root,\n+                    tree,\n+                    visited,\n+                    roots,\n+                    Some(link),\n+                    *submodule_source,\n+                )?;\n+                (vec![points_to], None)\n+            }\n+        };\n+\n         tree.link_mut(link).points_to = points_to;\n         tree.link_mut(link).problem = problem;\n     }\n     Ok(id)\n }\n \n fn resolve_submodule(\n-    file_id: FileId,\n+    source: ModuleSource,\n     name: &SmolStr,\n     file_resolver: &FileResolverImp,\n ) -> (Vec<FileId>, Option<Problem>) {\n+    let file_id = match source {\n+        ModuleSource::File(it) => it,\n+        ModuleSource::Inline(..) => {\n+            // TODO\n+            return (Vec::new(), None);\n+        }\n+    };\n     let mod_name = file_resolver.file_stem(file_id);\n     let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n "}, {"sha": "3d799ba05d2727c7ffadea75a85afb591a8b28b3", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -25,17 +25,17 @@ pub(crate) struct ModuleTree {\n }\n \n impl ModuleTree {\n-    pub(crate) fn modules_for_file(&self, file_id: FileId) -> Vec<ModuleId> {\n+    pub(crate) fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n         self.mods\n             .iter()\n             .enumerate()\n-            .filter(|(_idx, it)| it.source.is_file(file_id))\n+            .filter(|(_idx, it)| it.source == source)\n             .map(|(idx, _)| ModuleId(idx as u32))\n             .collect()\n     }\n \n-    pub(crate) fn any_module_for_file(&self, file_id: FileId) -> Option<ModuleId> {\n-        self.modules_for_file(file_id).pop()\n+    pub(crate) fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n+        self.modules_for_source(source).pop()\n     }\n }\n \n@@ -142,9 +142,7 @@ impl LinkId {\n                     .1;\n                 ast.into()\n             }\n-            ModuleSourceNode::Inline(..) => {\n-                unimplemented!(\"https://github.com/rust-analyzer/rust-analyzer/issues/181\")\n-            }\n+            ModuleSourceNode::Inline(it) => it,\n         }\n     }\n }\n@@ -157,13 +155,26 @@ struct ModuleData {\n }\n \n impl ModuleSource {\n+    pub(crate) fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n+        assert!(!module.has_semi());\n+        let ptr = SyntaxPtr::new(file_id, module.syntax());\n+        ModuleSource::Inline(ptr)\n+    }\n+\n     pub(crate) fn as_file(self) -> Option<FileId> {\n         match self {\n             ModuleSource::File(f) => Some(f),\n             ModuleSource::Inline(..) => None,\n         }\n     }\n \n+    pub(crate) fn file_id(self) -> FileId {\n+        match self {\n+            ModuleSource::File(f) => f,\n+            ModuleSource::Inline(ptr) => ptr.file_id(),\n+        }\n+    }\n+\n     fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n         match self {\n             ModuleSource::File(file_id) => {\n@@ -178,10 +189,6 @@ impl ModuleSource {\n             }\n         }\n     }\n-\n-    fn is_file(self, file_id: FileId) -> bool {\n-        self.as_file() == Some(file_id)\n-    }\n }\n \n #[derive(Hash, Debug, PartialEq, Eq)]"}, {"sha": "704648b595c7bfa0ec1691405afda8ebfdbf3cd7", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -220,27 +220,32 @@ impl AnalysisImpl {\n         let source_root = self.db.file_source_root(file_id);\n         self.db.module_tree(source_root)\n     }\n-    pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+    pub fn parent_module(\n+        &self,\n+        file_id: FileId,\n+        offset: TextUnit,\n+    ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let module_tree = self.module_tree(file_id)?;\n+        let file = self.db.file_syntax(file_id);\n+        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), offset) {\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(file_id, m),\n+            _ => ModuleSource::File(file_id),\n+        };\n \n         let res = module_tree\n-            .modules_for_file(file_id)\n+            .modules_for_source(module_source)\n             .into_iter()\n             .filter_map(|module_id| {\n                 let link = module_id.parent_link(&module_tree)?;\n-                let file_id = match link.owner(&module_tree).source(&module_tree) {\n-                    ModuleSource::File(file_id) => file_id,\n-                    ModuleSource::Inline(..) => {\n-                        //TODO: https://github.com/rust-analyzer/rust-analyzer/issues/181\n-                        return None;\n-                    }\n-                };\n+                let file_id = link.owner(&module_tree).source(&module_tree).file_id();\n                 let decl = link.bind_source(&module_tree, &*self.db);\n                 let decl = decl.ast();\n \n+                let decl_name = decl.name().unwrap();\n+\n                 let sym = FileSymbol {\n-                    name: decl.name().unwrap().text(),\n-                    node_range: decl.syntax().range(),\n+                    name: decl_name.text(),\n+                    node_range: decl_name.syntax().range(),\n                     kind: MODULE,\n                 };\n                 Some((file_id, sym))\n@@ -252,7 +257,7 @@ impl AnalysisImpl {\n         let module_tree = self.module_tree(file_id)?;\n         let crate_graph = self.db.crate_graph();\n         let res = module_tree\n-            .modules_for_file(file_id)\n+            .modules_for_source(ModuleSource::File(file_id))\n             .into_iter()\n             .map(|it| it.root(&module_tree))\n             .filter_map(|it| it.source(&module_tree).as_file())\n@@ -376,7 +381,7 @@ impl AnalysisImpl {\n                 fix: None,\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = module_tree.any_module_for_file(file_id) {\n+        if let Some(m) = module_tree.any_module_for_source(ModuleSource::File(file_id)) {\n             for (name_node, problem) in m.problems(&module_tree, &*self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n@@ -539,7 +544,7 @@ impl AnalysisImpl {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let module_id = match module_tree.any_module_for_file(file_id) {\n+        let module_id = match module_tree.any_module_for_source(ModuleSource::File(file_id)) {\n             Some(id) => id,\n             None => return Vec::new(),\n         };"}, {"sha": "fee382151addb046e43cf41547750e702f1d54bb", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -263,8 +263,12 @@ impl Analysis {\n     ) -> Cancelable<Vec<(FileId, TextRange)>> {\n         Ok(self.imp.find_all_refs(file_id, offset))\n     }\n-    pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        self.imp.parent_module(file_id)\n+    pub fn parent_module(\n+        &self,\n+        file_id: FileId,\n+        offset: TextUnit,\n+    ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+        self.imp.parent_module(file_id, offset)\n     }\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         self.imp.crate_for(file_id)"}, {"sha": "4afb1fc93032a2711c4a164f917fa0361b4e7343", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -22,6 +22,10 @@ impl SyntaxPtr {\n         let local = LocalSyntaxPtr::new(node);\n         SyntaxPtr { file_id, local }\n     }\n+\n+    pub(crate) fn file_id(self) -> FileId {\n+        self.file_id\n+    }\n }\n \n /// A pionter to a syntax node inside a file."}, {"sha": "7f7bb8e6bd97c1e3e4253365602e84af471ffd8e", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -92,9 +92,28 @@ fn test_resolve_parent_module() {\n         <|>// empty\n     \",\n     );\n-    let symbols = analysis.parent_module(pos.file_id).unwrap();\n+    let symbols = analysis.parent_module(pos.file_id, pos.offset).unwrap();\n     assert_eq_dbg(\n-        r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,\n+        r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [4; 7), kind: MODULE })]\"#,\n+        &symbols,\n+    );\n+}\n+\n+#[test]\n+fn test_resolve_parent_module_for_inline() {\n+    let (analysis, pos) = analysis_and_position(\n+        \"\n+        //- /lib.rs\n+        mod foo {\n+            mod bar {\n+                mod baz { <|> }\n+            }\n+        }\n+    \",\n+    );\n+    let symbols = analysis.parent_module(pos.file_id, pos.offset).unwrap();\n+    assert_eq_dbg(\n+        r#\"[(FileId(1), FileSymbol { name: \"bar\", node_range: [18; 21), kind: MODULE })]\"#,\n         &symbols,\n     );\n }"}, {"sha": "2219a0036547f56b683802ab0a3e4ac80f34b002", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -218,11 +218,13 @@ pub fn handle_goto_definition(\n \n pub fn handle_parent_module(\n     world: ServerWorld,\n-    params: TextDocumentIdentifier,\n+    params: req::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n-    let file_id = params.try_conv_with(&world)?;\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let offset = params.position.conv_with(&line_index);\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world.analysis().parent_module(file_id)? {\n+    for (file_id, symbol) in world.analysis().parent_module(file_id, offset)? {\n         let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n         res.push(location);"}, {"sha": "fcb7e94e16a31610db5359a12d83dc757e7c58f3", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -93,7 +93,7 @@ pub struct Decoration {\n pub enum ParentModule {}\n \n impl Request for ParentModule {\n-    type Params = TextDocumentIdentifier;\n+    type Params = TextDocumentPositionParams;\n     type Result = Vec<Location>;\n     const METHOD: &'static str = \"m/parentModule\";\n }"}, {"sha": "64401b68401da21cd2882b157a87e02ce6b9f8f8", "filename": "editors/code/src/commands/on_enter.ts", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -6,10 +6,6 @@ import {\n     SourceChange\n } from './apply_source_change';\n \n-interface OnEnterParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    position: lc.Position;\n-}\n \n export async function handle(event: { text: string }): Promise<boolean> {\n     const editor = vscode.window.activeTextEditor;\n@@ -20,7 +16,7 @@ export async function handle(event: { text: string }): Promise<boolean> {\n     ) {\n         return false;\n     }\n-    const request: OnEnterParams = {\n+    const request: lc.TextDocumentPositionParams = {\n         textDocument: { uri: editor.document.uri.toString() },\n         position: Server.client.code2ProtocolConverter.asPosition(\n             editor.selection.active"}, {"sha": "806c3d34c1289b4c50053e48c641d41ac1872e2c", "filename": "editors/code/src/commands/parent_module.ts", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de9bb9cfefb6d19958363f7d064aef6adbca9107/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "raw_url": "https://github.com/rust-lang/rust/raw/de9bb9cfefb6d19958363f7d064aef6adbca9107/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts?ref=de9bb9cfefb6d19958363f7d064aef6adbca9107", "patch": "@@ -1,17 +1,20 @@\n import * as vscode from 'vscode';\n \n-import { Location, TextDocumentIdentifier } from 'vscode-languageclient';\n+import * as lc from 'vscode-languageclient';\n import { Server } from '../server';\n \n export async function handle() {\n     const editor = vscode.window.activeTextEditor;\n     if (editor == null || editor.document.languageId !== 'rust') {\n         return;\n     }\n-    const request: TextDocumentIdentifier = {\n-        uri: editor.document.uri.toString()\n+    const request: lc.TextDocumentPositionParams = {\n+        textDocument: { uri: editor.document.uri.toString() },\n+        position: Server.client.code2ProtocolConverter.asPosition(\n+            editor.selection.active\n+        )\n     };\n-    const response = await Server.client.sendRequest<Location[]>(\n+    const response = await Server.client.sendRequest<lc.Location[]>(\n         'm/parentModule',\n         request\n     );"}]}