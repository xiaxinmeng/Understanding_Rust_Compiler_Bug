{"sha": "52b16230891be1548ffe9aa2a57388aac6dba204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjE2MjMwODkxYmUxNTQ4ZmZlOWFhMmE1NzM4OGFhYzZkYmEyMDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-21T21:51:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-21T21:51:54Z"}, "message": "std: Remove extfmt. Has been moved to core. Closes #1600", "tree": {"sha": "e1987fab5be496519bddf33f61e415baf76ffdb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1987fab5be496519bddf33f61e415baf76ffdb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b16230891be1548ffe9aa2a57388aac6dba204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b16230891be1548ffe9aa2a57388aac6dba204", "html_url": "https://github.com/rust-lang/rust/commit/52b16230891be1548ffe9aa2a57388aac6dba204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b16230891be1548ffe9aa2a57388aac6dba204/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4", "html_url": "https://github.com/rust-lang/rust/commit/fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4"}], "stats": {"total": 456, "additions": 1, "deletions": 455}, "files": [{"sha": "16a5cca4c94bc27613d3c7bf6afa59c6657414e7", "filename": "src/libstd/extfmt.rs", "status": "removed", "additions": 0, "deletions": 453, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4/src%2Flibstd%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4/src%2Flibstd%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fextfmt.rs?ref=fc2ae08b9ca0c783ad505b34706bf6e9f8dc0fc4", "patch": "@@ -1,453 +0,0 @@\n-/*\n-Syntax Extension: fmt\n-\n-Format a string\n-\n-The 'fmt' extension is modeled on the posix printf system.\n-\n-A posix conversion ostensibly looks like this\n-\n-> %[parameter][flags][width][.precision][length]type\n-\n-Given the different numeric type bestiary we have, we omit the 'length'\n-parameter and support slightly different conversions for 'type'\n-\n-> %[parameter][flags][width][.precision]type\n-\n-we also only support translating-to-rust a tiny subset of the possible\n-combinations at the moment.\n-\n-Example:\n-\n-#debug(\"hello, %s!\", \"world\");\n-\n-*/\n-\n-import option::{some, none};\n-\n-\n-/*\n- * We have a 'ct' (compile-time) module that parses format strings into a\n- * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the 'rt' (run-time) module.\n- * Each of those run-time conversion functions accepts another conversion\n- * description that specifies how to format its output.\n- *\n- * The building of the AST is currently done in a module inside the compiler,\n- * but should migrate over here as the plugin interface is defined.\n- */\n-\n-// Functions used by the fmt extension at compile time\n-mod ct {\n-    enum signedness { signed, unsigned }\n-    enum caseness { case_upper, case_lower }\n-    enum ty {\n-        ty_bool,\n-        ty_str,\n-        ty_char,\n-        ty_int(signedness),\n-        ty_bits,\n-        ty_hex(caseness),\n-        ty_octal,\n-        ty_float,\n-        // FIXME: More types\n-    }\n-    enum flag {\n-        flag_left_justify,\n-        flag_left_zero_pad,\n-        flag_space_for_sign,\n-        flag_sign_always,\n-        flag_alternate,\n-    }\n-    enum count {\n-        count_is(int),\n-        count_is_param(int),\n-        count_is_next_param,\n-        count_implied,\n-    }\n-\n-    // A formatted conversion from an expression to a string\n-    type conv =\n-        {param: option::t<int>,\n-         flags: [flag],\n-         width: count,\n-         precision: count,\n-         ty: ty};\n-\n-\n-    // A fragment of the output sequence\n-    enum piece { piece_string(str), piece_conv(conv), }\n-    type error_fn = fn@(str) -> ! ;\n-\n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n-        let pieces: [piece] = [];\n-        let lim = str::byte_len(s);\n-        let buf = \"\";\n-        fn flush_buf(buf: str, &pieces: [piece]) -> str {\n-            if str::byte_len(buf) > 0u {\n-                let piece = piece_string(buf);\n-                pieces += [piece];\n-            }\n-            ret \"\";\n-        }\n-        let i = 0u;\n-        while i < lim {\n-            let curr = str::substr(s, i, 1u);\n-            if str::eq(curr, \"%\") {\n-                i += 1u;\n-                if i >= lim {\n-                    error(\"unterminated conversion at end of string\");\n-                }\n-                let curr2 = str::substr(s, i, 1u);\n-                if str::eq(curr2, \"%\") {\n-                    i += 1u;\n-                } else {\n-                    buf = flush_buf(buf, pieces);\n-                    let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece];\n-                    i = rs.next;\n-                }\n-            } else { buf += curr; i += 1u; }\n-        }\n-        buf = flush_buf(buf, pieces);\n-        ret pieces;\n-    }\n-    fn peek_num(s: str, i: uint, lim: uint) ->\n-       option::t<{num: uint, next: uint}> {\n-        if i >= lim { ret none; }\n-        let c = s[i];\n-        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n-        let n = c - ('0' as u8) as uint;\n-        ret alt peek_num(s, i + 1u, lim) {\n-              none { some({num: n, next: i + 1u}) }\n-              some(next) {\n-                let m = next.num;\n-                let j = next.next;\n-                some({num: n * 10u + m, next: j})\n-              }\n-            };\n-    }\n-    fn parse_conversion(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {piece: piece, next: uint} {\n-        let parm = parse_parameter(s, i, lim);\n-        let flags = parse_flags(s, parm.next, lim);\n-        let width = parse_count(s, flags.next, lim);\n-        let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, error);\n-        ret {piece:\n-                 piece_conv({param: parm.param,\n-                             flags: flags.flags,\n-                             width: width.count,\n-                             precision: prec.count,\n-                             ty: ty.ty}),\n-             next: ty.next};\n-    }\n-    fn parse_parameter(s: str, i: uint, lim: uint) ->\n-       {param: option::t<int>, next: uint} {\n-        if i >= lim { ret {param: none, next: i}; }\n-        let num = peek_num(s, i, lim);\n-        ret alt num {\n-              none { {param: none, next: i} }\n-              some(t) {\n-                let n = t.num;\n-                let j = t.next;\n-                if j < lim && s[j] == '$' as u8 {\n-                    {param: some(n as int), next: j + 1u}\n-                } else { {param: none, next: i} }\n-              }\n-            };\n-    }\n-    fn parse_flags(s: str, i: uint, lim: uint) ->\n-       {flags: [flag], next: uint} {\n-        let noflags: [flag] = [];\n-        if i >= lim { ret {flags: noflags, next: i}; }\n-\n-        // FIXME: This recursion generates illegal instructions if the return\n-        // value isn't boxed. Only started happening after the ivec conversion\n-        fn more_(f: flag, s: str, i: uint, lim: uint) ->\n-           @{flags: [flag], next: uint} {\n-            let next = parse_flags(s, i + 1u, lim);\n-            let rest = next.flags;\n-            let j = next.next;\n-            let curr: [flag] = [f];\n-            ret @{flags: curr + rest, next: j};\n-        }\n-        let more = bind more_(_, s, i, lim);\n-        let f = s[i];\n-        ret if f == '-' as u8 {\n-                *more(flag_left_justify)\n-            } else if f == '0' as u8 {\n-                *more(flag_left_zero_pad)\n-            } else if f == ' ' as u8 {\n-                *more(flag_space_for_sign)\n-            } else if f == '+' as u8 {\n-                *more(flag_sign_always)\n-            } else if f == '#' as u8 {\n-                *more(flag_alternate)\n-            } else { {flags: noflags, next: i} };\n-    }\n-    fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1u, lim);\n-                let j = param.next;\n-                alt param.param {\n-                  none { {count: count_is_next_param, next: j} }\n-                  some(n) { {count: count_is_param(n), next: j} }\n-                }\n-            } else {\n-                let num = peek_num(s, i, lim);\n-                alt num {\n-                  none { {count: count_implied, next: i} }\n-                  some(num) {\n-                    {count: count_is(num.num as int), next: num.next}\n-                  }\n-                }\n-            };\n-    }\n-    fn parse_precision(s: str, i: uint, lim: uint) ->\n-       {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '.' as u8 {\n-                let count = parse_count(s, i + 1u, lim);\n-\n-\n-                // If there were no digits specified, i.e. the precision\n-                // was \".\", then the precision is 0\n-                alt count.count {\n-                  count_implied { {count: count_is(0), next: count.next} }\n-                  _ { count }\n-                }\n-            } else { {count: count_implied, next: i} };\n-    }\n-    fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} {\n-        if i >= lim { error(\"missing type in conversion\"); }\n-        let tstr = str::substr(s, i, 1u);\n-        // TODO: Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        let t =\n-            if str::eq(tstr, \"b\") {\n-                ty_bool\n-            } else if str::eq(tstr, \"s\") {\n-                ty_str\n-            } else if str::eq(tstr, \"c\") {\n-                ty_char\n-            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n-                ty_int(signed)\n-            } else if str::eq(tstr, \"u\") {\n-                ty_int(unsigned)\n-            } else if str::eq(tstr, \"x\") {\n-                ty_hex(case_lower)\n-            } else if str::eq(tstr, \"X\") {\n-                ty_hex(case_upper)\n-            } else if str::eq(tstr, \"t\") {\n-                ty_bits\n-            } else if str::eq(tstr, \"o\") {\n-                ty_octal\n-            } else if str::eq(tstr, \"f\") {\n-                ty_float\n-            } else { error(\"unknown type in conversion: \" + tstr) };\n-        ret {ty: t, next: i + 1u};\n-    }\n-}\n-\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n-mod rt {\n-    enum flag {\n-        flag_left_justify,\n-        flag_left_zero_pad,\n-        flag_space_for_sign,\n-        flag_sign_always,\n-        flag_alternate,\n-\n-\n-        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n-        // which have some difficulty typechecking currently. See\n-        // comments in front::extfmt::make_flags\n-        flag_none,\n-    }\n-    enum count { count_is(int), count_implied, }\n-    enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n-\n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag\n-    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n-\n-    fn conv_int(cv: conv, i: int) -> str {\n-        let radix = 10u;\n-        let prec = get_int_precision(cv);\n-        let s = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = \"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = \" \" + s;\n-            }\n-        }\n-        ret pad(cv, s, pad_signed);\n-    }\n-    fn conv_uint(cv: conv, u: uint) -> str {\n-        let prec = get_int_precision(cv);\n-        let rs =\n-            alt cv.ty {\n-              ty_default { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal { uint_to_str_prec(u, 8u, prec) }\n-            };\n-        ret pad(cv, rs, pad_unsigned);\n-    }\n-    fn conv_bool(cv: conv, b: bool) -> str {\n-        let s = if b { \"true\" } else { \"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-\n-        ret conv_str(cv, s);\n-    }\n-    fn conv_char(cv: conv, c: char) -> str {\n-        ret pad(cv, str::from_char(c), pad_nozero);\n-    }\n-    fn conv_str(cv: conv, s: str) -> str {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-\n-        // FIXME: substr works on bytes, not chars!\n-        let unpadded =\n-            alt cv.precision {\n-              count_implied { s }\n-              count_is(max) {\n-                if max as uint < str::char_len(s) {\n-                    str::substr(s, 0u, max as uint)\n-                } else { s }\n-              }\n-            };\n-        ret pad(cv, unpadded, pad_nozero);\n-    }\n-    fn conv_float(cv: conv, f: float) -> str {\n-        let (to_str, digits) = alt cv.precision {\n-              count_is(c) { (float::to_str_exact, c as uint) }\n-              count_implied { (float::to_str, 6u) }\n-        };\n-        let s = to_str(f, digits);\n-        if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = \"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = \" \" + s;\n-            }\n-        }\n-        ret pad(cv, s, pad_signed);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> str {\n-        ret if num < 0 {\n-                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> str {\n-        ret if prec == 0u && num == 0u {\n-                \"\"\n-            } else {\n-                let s = uint::to_str(num, radix);\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str_init_elt(diff, '0');\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    fn get_int_precision(cv: conv) -> uint {\n-        ret alt cv.precision {\n-              count_is(c) { c as uint }\n-              count_implied { 1u }\n-            };\n-    }\n-\n-    // FIXME: This might be useful in str: but needs to be utf8 safe first\n-    fn str_init_elt(n_elts: uint, c: char) -> str {\n-        let svec = vec::init_elt::<u8>(n_elts, c as u8);\n-\n-        ret str::unsafe_from_bytes(svec);\n-    }\n-    enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n-    fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n-        let uwidth;\n-        alt cv.width {\n-          count_implied { ret s; }\n-          count_is(width) {\n-            // FIXME: Maybe width should be uint\n-\n-            uwidth = width as uint;\n-          }\n-        }\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { ret s; }\n-        let padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str_init_elt(diff, padchar);\n-            ret s + padstr;\n-        }\n-        let might_zero_pad = false;\n-        let signed = false;\n-        alt mode {\n-          pad_nozero {\n-            // fallthrough\n-\n-          }\n-          pad_signed { might_zero_pad = true; signed = true; }\n-          pad_unsigned { might_zero_pad = true; }\n-        }\n-        fn have_precision(cv: conv) -> bool {\n-            ret alt cv.precision { count_implied { false } _ { true } };\n-        }\n-        let zero_padding = false;\n-        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-               !have_precision(cv) {\n-            padchar = '0';\n-            zero_padding = true;\n-        }\n-        let padstr = str_init_elt(diff, padchar);\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && str::byte_len(s) > 0u {\n-            let head = s[0];\n-            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes([head]);\n-                let bytelen = str::byte_len(s);\n-                let numpart = str::substr(s, 1u, bytelen - 1u);\n-                ret headstr + padstr + numpart;\n-            }\n-        }\n-        ret padstr + s;\n-    }\n-    fn have_flag(flags: [flag], f: flag) -> bool {\n-        for candidate: flag in flags { if candidate == f { ret true; } }\n-        ret false;\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "f8d105ef77edb5d7a60e1b48b9e35dc91f8ae1b3", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52b16230891be1548ffe9aa2a57388aac6dba204/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/52b16230891be1548ffe9aa2a57388aac6dba204/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=52b16230891be1548ffe9aa2a57388aac6dba204", "patch": "@@ -12,7 +12,7 @@ export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n export ebml, dbg, getopts, json, rand, sha1, term, time;\n-export extfmt, test, tempfile;\n+export test, tempfile;\n // FIXME: generic_os and os_fs shouldn't be exported\n export generic_os, os, os_fs;\n \n@@ -68,7 +68,6 @@ mod unicode;\n \n // Compiler support modules\n \n-mod extfmt;\n mod test;\n \n "}]}