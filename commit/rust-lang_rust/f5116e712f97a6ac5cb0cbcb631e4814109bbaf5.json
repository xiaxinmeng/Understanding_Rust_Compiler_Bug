{"sha": "f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTE2ZTcxMmY5N2E2YWM1Y2IwY2JjYjYzMWU0ODE0MTA5YmJhZjU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-25T07:54:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-25T07:54:38Z"}, "message": "Rollup merge of #47964 - jcowgill:mips64-abi, r=eddyb\n\nrustc_trans: rewrite mips64 ABI code\n\nThis PR rewrites the ABI handling code for 64-bit MIPS and should fix various FFI issues including #47290.\n\nTo accomodate the 64-bit ABI I have had to add a new `CastTarget` variant which I've called `Chunked` (though maybe this isn't the best name). This allows an ABI to cast to some arbitrary structure of `Reg` types. This is required on MIPS which might need to cast to a structure containing a mixture of `i64` and `f64` types.", "tree": {"sha": "e3c56488227c75fc6b2c40e716d384b26b8e8aba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3c56488227c75fc6b2c40e716d384b26b8e8aba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakmu+CRBK7hj4Ov3rIwAAdHIIAJmNT6HQl3zu3YzxlvJqmEms\n6lvtM2Pn+FqWlS9NBQzmJ5dOq526rHRTe30hhut9nCcGAK8W8vGSHKka+78HxbFP\nRo6VdZSm0EiIVhj11/z0VCogKKORHvNQmCv7c34vJdq0KCi03vgUjZHxyLEn+GaD\n3DgTFClvn6HK57JsupZhzX3fpjzcUBAEIeNTAYUvZBgbqRXT1sFSTmOmlmuyow76\n3fj0H1dtRaQIm0jBtgA5ewmtHZwzqABzbs1IHBrc9+ODVu8tijsyn0JHFb3xIyP1\ndnKO5Up6zbU3sZ2BGmmZG8n2jzgBQ/RC9r/dn4yWZ3lFgvnUuY3NL+YF7/kH4cw=\n=RJvL\n-----END PGP SIGNATURE-----\n", "payload": "tree e3c56488227c75fc6b2c40e716d384b26b8e8aba\nparent 026339e42ba11a559767029d933d1197aefb877a\nparent 47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5\nauthor kennytm <kennytm@gmail.com> 1519545278 +0800\ncommitter GitHub <noreply@github.com> 1519545278 +0800\n\nRollup merge of #47964 - jcowgill:mips64-abi, r=eddyb\n\nrustc_trans: rewrite mips64 ABI code\n\nThis PR rewrites the ABI handling code for 64-bit MIPS and should fix various FFI issues including #47290.\n\nTo accomodate the 64-bit ABI I have had to add a new `CastTarget` variant which I've called `Chunked` (though maybe this isn't the best name). This allows an ABI to cast to some arbitrary structure of `Reg` types. This is required on MIPS which might need to cast to a structure containing a mixture of `i64` and `f64` types.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "html_url": "https://github.com/rust-lang/rust/commit/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026339e42ba11a559767029d933d1197aefb877a", "url": "https://api.github.com/repos/rust-lang/rust/commits/026339e42ba11a559767029d933d1197aefb877a", "html_url": "https://github.com/rust-lang/rust/commit/026339e42ba11a559767029d933d1197aefb877a"}, {"sha": "47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5", "html_url": "https://github.com/rust-lang/rust/commit/47c33f7bd0535fe6e47e38700ac1c8bf33e3f0d5"}], "stats": {"total": 264, "additions": 188, "deletions": 76}, "files": [{"sha": "ee0f2415bd80861626584d3e61bb92b7b76eb15c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "patch": "@@ -40,7 +40,7 @@ use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n \n use libc::c_uint;\n-use std::{cmp, iter};\n+use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -279,30 +279,6 @@ impl Uniform {\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n         self.unit.align(cx)\n     }\n-\n-    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        let llunit = self.unit.llvm_type(cx);\n-\n-        if self.total <= self.unit.size {\n-            return llunit;\n-        }\n-\n-        let count = self.total.bytes() / self.unit.size.bytes();\n-        let rem_bytes = self.total.bytes() % self.unit.size.bytes();\n-\n-        if rem_bytes == 0 {\n-            return Type::array(&llunit, count);\n-        }\n-\n-        // Only integers can be really split further.\n-        assert_eq!(self.unit.kind, RegKind::Integer);\n-\n-        let args: Vec<_> = (0..count).map(|_| llunit)\n-            .chain(iter::once(Type::ix(cx, rem_bytes * 8)))\n-            .collect();\n-\n-        Type::struct_(cx, &args, false)\n-    }\n }\n \n pub trait LayoutExt<'tcx> {\n@@ -405,55 +381,81 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum CastTarget {\n-    Uniform(Uniform),\n-    Pair(Reg, Reg)\n+pub struct CastTarget {\n+    pub prefix: [Option<RegKind>; 8],\n+    pub prefix_chunk: Size,\n+    pub rest: Uniform,\n }\n \n impl From<Reg> for CastTarget {\n     fn from(unit: Reg) -> CastTarget {\n-        CastTarget::Uniform(Uniform::from(unit))\n+        CastTarget::from(Uniform::from(unit))\n     }\n }\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget::Uniform(uniform)\n+        CastTarget {\n+            prefix: [None; 8],\n+            prefix_chunk: Size::from_bytes(0),\n+            rest: uniform\n+        }\n     }\n }\n \n impl CastTarget {\n-    pub fn size(&self, cx: &CodegenCx) -> Size {\n-        match *self {\n-            CastTarget::Uniform(u) => u.total,\n-            CastTarget::Pair(a, b) => {\n-                (a.size.abi_align(a.align(cx)) + b.size)\n-                    .abi_align(self.align(cx))\n-            }\n+    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n+        CastTarget {\n+            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n+            prefix_chunk: a.size,\n+            rest: Uniform::from(b)\n         }\n     }\n \n+    pub fn size(&self, cx: &CodegenCx) -> Size {\n+        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+            .abi_align(self.rest.align(cx)) + self.rest.total\n+    }\n+\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n-        match *self {\n-            CastTarget::Uniform(u) => u.align(cx),\n-            CastTarget::Pair(a, b) => {\n-                cx.data_layout().aggregate_align\n-                    .max(a.align(cx))\n-                    .max(b.align(cx))\n-            }\n-        }\n+        self.prefix.iter()\n+            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+                |acc, align| acc.max(align))\n     }\n \n     pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        match *self {\n-            CastTarget::Uniform(u) => u.llvm_type(cx),\n-            CastTarget::Pair(a, b) => {\n-                Type::struct_(cx, &[\n-                    a.llvm_type(cx),\n-                    b.llvm_type(cx)\n-                ], false)\n+        let rest_ll_unit = self.rest.unit.llvm_type(cx);\n+        let rest_count = self.rest.total.bytes() / self.rest.unit.size.bytes();\n+        let rem_bytes = self.rest.total.bytes() % self.rest.unit.size.bytes();\n+\n+        if self.prefix.iter().all(|x| x.is_none()) {\n+            // Simplify to a single unit when there is no prefix and size <= unit size\n+            if self.rest.total <= self.rest.unit.size {\n+                return rest_ll_unit;\n+            }\n+\n+            // Simplify to array when all chunks are the same size and type\n+            if rem_bytes == 0 {\n+                return Type::array(&rest_ll_unit, rest_count);\n             }\n         }\n+\n+        // Create list of fields in the main structure\n+        let mut args: Vec<_> =\n+            self.prefix.iter().flat_map(|option_kind| option_kind.map(\n+                    |kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx)))\n+            .chain((0..rest_count).map(|_| rest_ll_unit))\n+            .collect();\n+\n+        // Append final integer\n+        if rem_bytes != 0 {\n+            // Only integers can be really split further.\n+            assert_eq!(self.rest.unit.kind, RegKind::Integer);\n+            args.push(Type::ix(cx, rem_bytes * 8));\n+        }\n+\n+        Type::struct_(cx, &args, false)\n     }\n }\n "}, {"sha": "94bf53cee1edbd67b90885dccc28d44ecb482268", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 133, "deletions": 23, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "patch": "@@ -8,50 +8,160 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgAttribute, ArgType, CastTarget, FnType, LayoutExt, PassMode, Reg, RegKind, Uniform};\n use context::CodegenCx;\n+use rustc::ty::layout::{self, Size};\n \n-use rustc::ty::layout::Size;\n+fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n+    // Always sign extend u32 values on 64-bit mips\n+    if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+        if let layout::Int(i, signed) = scalar.value {\n+            if !signed && i.size().bits() == 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.set(ArgAttribute::SExt);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(bits);\n+}\n+\n+fn bits_to_int_reg(bits: u64) -> Reg {\n+    if bits <= 8 {\n+        Reg::i8()\n+    } else if bits <= 16 {\n+        Reg::i16()\n+    } else if bits <= 32 {\n+        Reg::i32()\n+    } else {\n+        Reg::i64()\n+    }\n+}\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn float_reg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &ArgType<'tcx>, i: usize) -> Option<Reg> {\n+    match ret.layout.field(cx, i).abi {\n+        layout::Abi::Scalar(ref scalar) => match scalar.value {\n+            layout::F32 => Some(Reg::f32()),\n+            layout::F64 => Some(Reg::f64()),\n+            _ => None\n+        },\n+        _ => None\n+    }\n+}\n+\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(64);\n+        extend_integer_width_mips(ret, 64);\n+        return;\n+    }\n+\n+    let size = ret.layout.size;\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        // Unlike other architectures which return aggregates in registers, MIPS n64 limits the\n+        // use of float registers to structures (not unions) containing exactly one or two\n+        // float fields.\n+\n+        if let layout::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+            if ret.layout.fields.count() == 1 {\n+                if let Some(reg) = float_reg(cx, ret, 0) {\n+                    ret.cast_to(reg);\n+                    return;\n+                }\n+            } else if ret.layout.fields.count() == 2 {\n+                if let Some(reg0) = float_reg(cx, ret, 0) {\n+                    if let Some(reg1) = float_reg(cx, ret, 1) {\n+                        ret.cast_to(CastTarget::pair(reg0, reg1));\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Cast to a uniform int structure\n+        ret.cast_to(Uniform {\n+            unit: bits_to_int_reg(bits),\n+            total: size\n+        });\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n+        extend_integer_width_mips(arg, 64);\n+        return;\n+    }\n+\n     let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let mut prefix = [None; 8];\n+    let mut prefix_index = 0;\n \n-    if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i64(),\n-            total: size\n-        });\n-        if !offset.is_abi_aligned(align) {\n-            arg.pad_with(Reg::i64());\n+    match arg.layout.fields {\n+        layout::FieldPlacement::Array { .. } => {\n+            // Arrays are passed indirectly\n+            arg.make_indirect();\n+            return;\n         }\n-    } else {\n-        arg.extend_integer_width_to(64);\n-    }\n+        layout::FieldPlacement::Union(_) => {\n+            // Unions and are always treated as a series of 64-bit integer chunks\n+        },\n+        layout::FieldPlacement::Arbitrary { .. } => {\n+            // Structures are split up into a series of 64-bit integer chunks, but any aligned\n+            // doubles not part of another aggregate are passed as floats.\n+            let mut last_offset = Size::from_bytes(0);\n+\n+            for i in 0..arg.layout.fields.count() {\n+                let field = arg.layout.field(cx, i);\n+                let offset = arg.layout.fields.offset(i);\n+\n+                // We only care about aligned doubles\n+                if let layout::Abi::Scalar(ref scalar) = field.abi {\n+                    if let layout::F64 = scalar.value {\n+                        if offset.is_abi_aligned(dl.f64_align) {\n+                            // Insert enough integers to cover [last_offset, offset)\n+                            assert!(last_offset.is_abi_aligned(dl.f64_align));\n+                            for _ in 0..((offset - last_offset).bits() / 64)\n+                                .min((prefix.len() - prefix_index) as u64) {\n+\n+                                prefix[prefix_index] = Some(RegKind::Integer);\n+                                prefix_index += 1;\n+                            }\n+\n+                            if prefix_index == prefix.len() {\n+                                break;\n+                            }\n+\n+                            prefix[prefix_index] = Some(RegKind::Float);\n+                            prefix_index += 1;\n+                            last_offset = offset + Reg::f64().size;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    // Extract first 8 chunks as the prefix\n+    let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n+    arg.cast_to(CastTarget {\n+        prefix: prefix,\n+        prefix_chunk: Size::from_bytes(8),\n+        rest: Uniform { unit: Reg::i64(), total: rest_size }\n+    });\n }\n \n pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "7eadaa7f493a3f52b63c9699123f5e08c478b097", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5116e712f97a6ac5cb0cbcb631e4814109bbaf5/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=f5116e712f97a6ac5cb0cbcb631e4814109bbaf5", "patch": "@@ -171,7 +171,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     let mut target = CastTarget::from(lo);\n     if size > offset {\n         if let Some(hi) = reg_component(cls, &mut i, size - offset) {\n-            target = CastTarget::Pair(lo, hi);\n+            target = CastTarget::pair(lo, hi);\n         }\n     }\n     assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);"}]}