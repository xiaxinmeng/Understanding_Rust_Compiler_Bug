{"sha": "a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "node_id": "C_kwDOAAsO6NoAKGE0YTVlNzk4MTRmYjRkMTU2OGZiMGVhNWNhNTBmODEwYjA3MWFlMTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-22T21:46:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-22T21:46:57Z"}, "message": "Auto merge of #95159 - nnethercote:TtParser, r=petrochenkov\n\nIntroduce `TtParser`\n\nThese commits make a number of changes to declarative macro expansion, resulting in code that is shorter, simpler, and faster.\n\nBest reviewed one commit at a time.\n\nr? `@petrochenkov`", "tree": {"sha": "6e4216d00956405a053a6e3b744c58ba04afe6a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e4216d00956405a053a6e3b744c58ba04afe6a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "html_url": "https://github.com/rust-lang/rust/commit/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f37001055c29982f4c27ee9edd90449c8e07774", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f37001055c29982f4c27ee9edd90449c8e07774", "html_url": "https://github.com/rust-lang/rust/commit/5f37001055c29982f4c27ee9edd90449c8e07774"}, {"sha": "31df6807893bd9c66cba57ff0f4de89ab9d8460e", "url": "https://api.github.com/repos/rust-lang/rust/commits/31df6807893bd9c66cba57ff0f4de89ab9d8460e", "html_url": "https://github.com/rust-lang/rust/commit/31df6807893bd9c66cba57ff0f4de89ab9d8460e"}], "stats": {"total": 932, "additions": 421, "deletions": 511}, "files": [{"sha": "14b3f720f83a14b35d6e6a8b0e85342323e9e9af", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -1,5 +1,6 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n+#![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]"}, {"sha": "0f7a8a9ed75506b05491927798da8f06d34d9fe2", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -17,23 +17,48 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n-/// that the delimiter itself might be `NoDelim`.\n+/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiter itself\n+/// might be `NoDelim`.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n-    tts: Vec<TokenTree>,\n+    /// Note: This contains the opening and closing delimiters tokens (e.g. `(` and `)`). Note that\n+    /// these could be `NoDelim`. These token kinds must match `delim`, and the methods below\n+    /// debug_assert this.\n+    all_tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n-    fn open_tt(&self, span: DelimSpan) -> TokenTree {\n-        TokenTree::token(token::OpenDelim(self.delim), span.open)\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter. Panics if\n+    /// the delimiter is `NoDelim`.\n+    fn open_tt(&self) -> &TokenTree {\n+        let tt = self.all_tts.first().unwrap();\n+        debug_assert!(matches!(\n+            tt,\n+            &TokenTree::Token(token::Token { kind: token::OpenDelim(d), .. }) if d == self.delim\n+        ));\n+        tt\n+    }\n+\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter. Panics if\n+    /// the delimeter is `NoDelim`.\n+    fn close_tt(&self) -> &TokenTree {\n+        let tt = self.all_tts.last().unwrap();\n+        debug_assert!(matches!(\n+            tt,\n+            &TokenTree::Token(token::Token { kind: token::CloseDelim(d), .. }) if d == self.delim\n+        ));\n+        tt\n     }\n \n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n-    fn close_tt(&self, span: DelimSpan) -> TokenTree {\n-        TokenTree::token(token::CloseDelim(self.delim), span.close)\n+    /// Returns the tts excluding the outer delimiters.\n+    ///\n+    /// FIXME: #67062 has details about why this is sub-optimal.\n+    fn inner_tts(&self) -> &[TokenTree] {\n+        // These functions are called for the assertions within them.\n+        let _open_tt = self.open_tt();\n+        let _close_tt = self.close_tt();\n+        &self.all_tts[1..self.all_tts.len() - 1]\n     }\n }\n \n@@ -73,35 +98,24 @@ enum KleeneOp {\n     ZeroOrOne,\n }\n \n-/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, `$(...)`,\n-/// and `${...}` are \"first-class\" token trees. Useful for parsing macros.\n+/// Similar to `tokenstream::TokenTree`, except that `Sequence`, `MetaVar`, `MetaVarDecl`, and\n+/// `MetaVarExpr` are \"first-class\" token trees. Useful for parsing macros.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n enum TokenTree {\n     Token(Token),\n+    /// A delimited sequence, e.g. `($e:expr)` (RHS) or `{ $e }` (LHS).\n     Delimited(DelimSpan, Lrc<Delimited>),\n-    /// A kleene-style repetition sequence\n+    /// A kleene-style repetition sequence, e.g. `$($e:expr)*` (RHS) or `$($e),*` (LHS).\n     Sequence(DelimSpan, Lrc<SequenceRepetition>),\n-    /// e.g., `$var`\n+    /// e.g., `$var`.\n     MetaVar(Span, Ident),\n-    /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n+    /// e.g., `$var:expr`. Only appears on the LHS.\n     MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n-    /// A meta-variable expression inside `${...}`\n+    /// A meta-variable expression inside `${...}`.\n     MetaVarExpr(DelimSpan, MetaVarExpr),\n }\n \n impl TokenTree {\n-    /// Return the number of tokens in the tree.\n-    fn len(&self) -> usize {\n-        match *self {\n-            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n-                token::NoDelim => delimed.tts.len(),\n-                _ => delimed.tts.len() + 2,\n-            },\n-            TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n-            _ => 0,\n-        }\n-    }\n-\n     /// Returns `true` if the given token tree is delimited.\n     fn is_delimited(&self) -> bool {\n         matches!(*self, TokenTree::Delimited(..))\n@@ -115,26 +129,6 @@ impl TokenTree {\n         }\n     }\n \n-    /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n-    fn get_tt(&self, index: usize) -> TokenTree {\n-        match (self, index) {\n-            (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n-                delimed.tts[index].clone()\n-            }\n-            (&TokenTree::Delimited(span, ref delimed), _) => {\n-                if index == 0 {\n-                    return delimed.open_tt(span);\n-                }\n-                if index == delimed.tts.len() + 1 {\n-                    return delimed.close_tt(span);\n-                }\n-                delimed.tts[index - 1].clone()\n-            }\n-            (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n-            _ => panic!(\"Cannot expand a token tree\"),\n-        }\n-    }\n-\n     /// Retrieves the `TokenTree`'s span.\n     fn span(&self) -> Span {\n         match *self {"}, {"sha": "b55a40c5b2c4b6ad09965e90cb69fb905c58414e", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -281,7 +281,7 @@ fn check_binders(\n         // `MetaVarExpr` can not appear in the LHS of a macro arm\n         TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n-            for tt in &del.tts {\n+            for tt in del.inner_tts() {\n                 check_binders(sess, node_id, tt, macros, binders, ops, valid);\n             }\n         }\n@@ -344,7 +344,7 @@ fn check_occurrences(\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, dl.entire(), name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n-            check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n+            check_nested_occurrences(sess, node_id, del.inner_tts(), macros, binders, ops, valid);\n         }\n         TokenTree::Sequence(_, ref seq) => {\n             let ops = ops.push(seq.kleene);\n@@ -431,14 +431,20 @@ fn check_nested_occurrences(\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n-                let rest =\n-                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n+                let rest = check_nested_macro(\n+                    sess,\n+                    node_id,\n+                    macro_rules,\n+                    del.inner_tts(),\n+                    &nested_macros,\n+                    valid,\n+                );\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n                     sess,\n                     node_id,\n-                    &del.tts[rest..],\n+                    &del.inner_tts()[rest..],\n                     macros,\n                     binders,\n                     ops,"}, {"sha": "d8071bf159a743cf7a173dfb654b031845487817", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 296, "deletions": 393, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -72,9 +72,8 @@\n \n crate use NamedMatch::*;\n crate use ParseResult::*;\n-use TokenTreeOrTokenTreeSlice::*;\n \n-use crate::mbe::{self, DelimSpan, SequenceRepetition, TokenTree};\n+use crate::mbe::{self, SequenceRepetition, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_parse::parser::Parser;\n@@ -89,36 +88,6 @@ use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n-use std::ops::{Deref, DerefMut};\n-\n-// To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n-\n-/// Either a slice of token trees or a single one. This is used as the representation of the\n-/// token trees that make up a matcher.\n-#[derive(Clone)]\n-enum TokenTreeOrTokenTreeSlice<'tt> {\n-    Tt(TokenTree),\n-    TtSlice(&'tt [TokenTree]),\n-}\n-\n-impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n-    /// Returns the number of constituent top-level token trees of `self` (top-level in that it\n-    /// will not recursively descend into subtrees).\n-    fn len(&self) -> usize {\n-        match *self {\n-            TtSlice(ref v) => v.len(),\n-            Tt(ref tt) => tt.len(),\n-        }\n-    }\n-\n-    /// The `index`-th token tree of `self`.\n-    fn get_tt(&self, index: usize) -> TokenTree {\n-        match *self {\n-            TtSlice(ref v) => v[index].clone(),\n-            Tt(ref tt) => tt.get_tt(index),\n-        }\n-    }\n-}\n \n /// An unzipping of `TokenTree`s... see the `stack` field of `MatcherPos`.\n ///\n@@ -127,7 +96,7 @@ impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n #[derive(Clone)]\n struct MatcherTtFrame<'tt> {\n     /// The \"parent\" matcher that we are descending into.\n-    elts: TokenTreeOrTokenTreeSlice<'tt>,\n+    elts: &'tt [TokenTree],\n     /// The position of the \"dot\" in `elts` at the time we descended.\n     idx: usize,\n }\n@@ -136,26 +105,10 @@ type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n \n /// Represents a single \"position\" (aka \"matcher position\", aka \"item\"), as\n /// described in the module documentation.\n-///\n-/// Here:\n-///\n-/// - `'root` represents the lifetime of the stack slot that holds the root\n-///   `MatcherPos`. As described in `MatcherPosHandle`, the root `MatcherPos`\n-///   structure is stored on the stack, but subsequent instances are put into\n-///   the heap.\n-/// - `'tt` represents the lifetime of the token trees that this matcher\n-///   position refers to.\n-///\n-/// It is important to distinguish these two lifetimes because we have a\n-/// `SmallVec<TokenTreeOrTokenTreeSlice<'tt>>` below, and the destructor of\n-/// that is considered to possibly access the data from its elements (it lacks\n-/// a `#[may_dangle]` attribute). As a result, the compiler needs to know that\n-/// all the elements in that `SmallVec` strictly outlive the root stack slot\n-/// lifetime. By separating `'tt` from `'root`, we can show that.\n #[derive(Clone)]\n-struct MatcherPos<'root, 'tt> {\n+struct MatcherPos<'tt> {\n     /// The token or slice of tokens that make up the matcher. `elts` is short for \"elements\".\n-    top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n+    top_elts: &'tt [TokenTree],\n \n     /// The position of the \"dot\" in this matcher\n     idx: usize,\n@@ -185,7 +138,7 @@ struct MatcherPos<'root, 'tt> {\n     match_hi: usize,\n \n     /// This field is only used if we are matching a repetition.\n-    repetition: Option<MatcherPosRepetition<'root, 'tt>>,\n+    repetition: Option<MatcherPosRepetition<'tt>>,\n \n     /// Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     /// a delimited token tree (e.g., something wrapped in `(` `)`) or to get the contents of a doc\n@@ -200,9 +153,9 @@ struct MatcherPos<'root, 'tt> {\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_, '_>, 240);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 136);\n \n-impl<'root, 'tt> MatcherPos<'root, 'tt> {\n+impl<'tt> MatcherPos<'tt> {\n     /// `len` `Vec`s (initially shared and empty) that will store matches of metavars.\n     fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n         if len == 0 {\n@@ -220,7 +173,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n         let match_idx_hi = count_names(ms);\n         MatcherPos {\n             // Start with the top level matcher given to us.\n-            top_elts: TtSlice(ms),\n+            top_elts: ms,\n \n             // The \"dot\" is before the first token of the matcher.\n             idx: 0,\n@@ -241,13 +194,9 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n         }\n     }\n \n-    fn repetition(\n-        up: MatcherPosHandle<'root, 'tt>,\n-        sp: DelimSpan,\n-        seq: Lrc<SequenceRepetition>,\n-    ) -> Self {\n+    fn repetition(up: Box<MatcherPos<'tt>>, seq: &'tt SequenceRepetition) -> Self {\n         MatcherPos {\n-            stack: smallvec![],\n+            top_elts: &seq.tts,\n             idx: 0,\n             matches: Self::create_matches(up.matches.len()),\n             match_lo: up.match_cur,\n@@ -258,7 +207,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n                 sep: seq.separator.clone(),\n                 seq_op: seq.kleene.op,\n             }),\n-            top_elts: Tt(TokenTree::Sequence(sp, seq)),\n+            stack: smallvec![],\n         }\n     }\n \n@@ -270,7 +219,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n }\n \n #[derive(Clone)]\n-struct MatcherPosRepetition<'root, 'tt> {\n+struct MatcherPosRepetition<'tt> {\n     /// The KleeneOp of this sequence.\n     seq_op: mbe::KleeneOp,\n \n@@ -279,55 +228,12 @@ struct MatcherPosRepetition<'root, 'tt> {\n \n     /// The \"parent\" matcher position. That is, the matcher position just before we enter the\n     /// sequence.\n-    up: MatcherPosHandle<'root, 'tt>,\n-}\n-\n-// Lots of MatcherPos instances are created at runtime. Allocating them on the\n-// heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all\n-// on the stack is also slow, because MatcherPos is quite a large type and\n-// instances get moved around a lot between vectors, which requires lots of\n-// slow memcpy calls.\n-//\n-// Therefore, the initial MatcherPos is always allocated on the stack,\n-// subsequent ones (of which there aren't that many) are allocated on the heap,\n-// and this type is used to encapsulate both cases.\n-enum MatcherPosHandle<'root, 'tt> {\n-    Ref(&'root mut MatcherPos<'root, 'tt>),\n-    Box(Box<MatcherPos<'root, 'tt>>),\n-}\n-\n-impl<'root, 'tt> Clone for MatcherPosHandle<'root, 'tt> {\n-    // This always produces a new Box.\n-    fn clone(&self) -> Self {\n-        MatcherPosHandle::Box(match *self {\n-            MatcherPosHandle::Ref(ref r) => Box::new((**r).clone()),\n-            MatcherPosHandle::Box(ref b) => b.clone(),\n-        })\n-    }\n-}\n-\n-impl<'root, 'tt> Deref for MatcherPosHandle<'root, 'tt> {\n-    type Target = MatcherPos<'root, 'tt>;\n-    fn deref(&self) -> &Self::Target {\n-        match *self {\n-            MatcherPosHandle::Ref(ref r) => r,\n-            MatcherPosHandle::Box(ref b) => b,\n-        }\n-    }\n-}\n-\n-impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n-    fn deref_mut(&mut self) -> &mut MatcherPos<'root, 'tt> {\n-        match *self {\n-            MatcherPosHandle::Ref(ref mut r) => r,\n-            MatcherPosHandle::Box(ref mut b) => b,\n-        }\n-    }\n+    up: Box<MatcherPos<'tt>>,\n }\n \n-enum EofItems<'root, 'tt> {\n+enum EofItems<'tt> {\n     None,\n-    One(MatcherPosHandle<'root, 'tt>),\n+    One(Box<MatcherPos<'tt>>),\n     Multiple,\n }\n \n@@ -352,8 +258,8 @@ crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, N\n pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count\n-            + match *elt {\n-                TokenTree::Delimited(_, ref delim) => count_names(&delim.tts),\n+            + match elt {\n+                TokenTree::Delimited(_, delim) => count_names(delim.inner_tts()),\n                 TokenTree::MetaVar(..) => 0,\n                 TokenTree::MetaVarDecl(..) => 1,\n                 // Panicking here would abort execution because `parse_tree` makes use of this\n@@ -362,7 +268,7 @@ pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n                 // `0` is still returned to inform that no meta-variable was found. `Meta-variables\n                 // != Meta-variable expressions`\n                 TokenTree::MetaVarExpr(..) => 0,\n-                TokenTree::Sequence(_, ref seq) => seq.num_captures,\n+                TokenTree::Sequence(_, seq) => seq.num_captures,\n                 TokenTree::Token(..) => 0,\n             }\n     })\n@@ -446,7 +352,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n             }\n             TokenTree::Delimited(_, ref delim) => {\n-                for next_m in &delim.tts {\n+                for next_m in delim.inner_tts() {\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n@@ -492,319 +398,316 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n-/// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n-/// produce more items in `next_items` and `bb_items`.\n-///\n-/// For more info about the how this happens, see the module-level doc comments and the inline\n-/// comments of this function.\n-///\n-/// # Parameters\n-///\n-/// - `cur_items`: the set of current items to be processed. This should be empty by the end of a\n-///   successful execution of this function.\n-/// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n-///   the function `parse`.\n-/// - `bb_items`: the set of items that are waiting for the black-box parser.\n-/// - `token`: the current token of the parser.\n-///\n-/// # Returns\n-///\n-/// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept track of\n-/// through the items generated.\n-fn parse_tt_inner<'root, 'tt>(\n-    sess: &ParseSess,\n-    ms: &[TokenTree],\n-    cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    next_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    token: &Token,\n-) -> Option<NamedParseResult> {\n-    // Matcher positions that would be valid if the macro invocation was over now. Only modified if\n-    // `token == Eof`.\n-    let mut eof_items = EofItems::None;\n-\n-    while let Some(mut item) = cur_items.pop() {\n-        // When unzipped trees end, remove them. This corresponds to backtracking out of a\n-        // delimited submatcher into which we already descended. When backtracking out again, we\n-        // need to advance the \"dot\" past the delimiters in the outer matcher.\n-        while item.idx >= item.top_elts.len() {\n-            match item.stack.pop() {\n-                Some(MatcherTtFrame { elts, idx }) => {\n-                    item.top_elts = elts;\n-                    item.idx = idx + 1;\n+// Note: the item vectors could be created and dropped within `parse_tt`, but to avoid excess\n+// allocations we have a single vector fo each kind that is cleared and reused repeatedly.\n+pub struct TtParser<'tt> {\n+    macro_name: Ident,\n+\n+    /// The set of current items to be processed. This should be empty by the end of a successful\n+    /// execution of `parse_tt_inner`.\n+    cur_items: Vec<Box<MatcherPos<'tt>>>,\n+\n+    /// The set of newly generated items. These are used to replenish `cur_items` in the function\n+    /// `parse_tt`.\n+    next_items: Vec<Box<MatcherPos<'tt>>>,\n+\n+    /// The set of items that are waiting for the black-box parser.\n+    bb_items: Vec<Box<MatcherPos<'tt>>>,\n+}\n+\n+impl<'tt> TtParser<'tt> {\n+    pub(super) fn new(macro_name: Ident) -> TtParser<'tt> {\n+        TtParser { macro_name, cur_items: vec![], next_items: vec![], bb_items: vec![] }\n+    }\n+\n+    /// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n+    /// produce more items in `next_items` and `bb_items`.\n+    ///\n+    /// For more info about the how this happens, see the module-level doc comments and the inline\n+    /// comments of this function.\n+    ///\n+    /// # Returns\n+    ///\n+    /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept\n+    /// track of through the items generated.\n+    fn parse_tt_inner(\n+        &mut self,\n+        sess: &ParseSess,\n+        ms: &[TokenTree],\n+        token: &Token,\n+    ) -> Option<NamedParseResult> {\n+        // Matcher positions that would be valid if the macro invocation was over now. Only\n+        // modified if `token == Eof`.\n+        let mut eof_items = EofItems::None;\n+\n+        while let Some(mut item) = self.cur_items.pop() {\n+            // When unzipped trees end, remove them. This corresponds to backtracking out of a\n+            // delimited submatcher into which we already descended. When backtracking out again, we\n+            // need to advance the \"dot\" past the delimiters in the outer matcher.\n+            while item.idx >= item.top_elts.len() {\n+                match item.stack.pop() {\n+                    Some(MatcherTtFrame { elts, idx }) => {\n+                        item.top_elts = elts;\n+                        item.idx = idx + 1;\n+                    }\n+                    None => break,\n                 }\n-                None => break,\n             }\n-        }\n \n-        // Get the current position of the \"dot\" (`idx`) in `item` and the number of token trees in\n-        // the matcher (`len`).\n-        let idx = item.idx;\n-        let len = item.top_elts.len();\n-\n-        if idx < len {\n-            // We are in the middle of a matcher. Compare the matcher's current tt against `token`.\n-            match item.top_elts.get_tt(idx) {\n-                TokenTree::Sequence(sp, seq) => {\n-                    let op = seq.kleene.op;\n-                    if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n-                        // Allow for the possibility of zero matches of this sequence.\n-                        let mut new_item = item.clone();\n-                        new_item.match_cur += seq.num_captures;\n-                        new_item.idx += 1;\n-                        for idx in item.match_cur..item.match_cur + seq.num_captures {\n-                            new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n+            // Get the current position of the \"dot\" (`idx`) in `item` and the number of token\n+            // trees in the matcher (`len`).\n+            let idx = item.idx;\n+            let len = item.top_elts.len();\n+\n+            if idx < len {\n+                // We are in the middle of a matcher. Compare the matcher's current tt against\n+                // `token`.\n+                match &item.top_elts[idx] {\n+                    TokenTree::Sequence(_sp, seq) => {\n+                        let op = seq.kleene.op;\n+                        if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n+                            // Allow for the possibility of zero matches of this sequence.\n+                            let mut new_item = item.clone();\n+                            new_item.match_cur += seq.num_captures;\n+                            new_item.idx += 1;\n+                            for idx in item.match_cur..item.match_cur + seq.num_captures {\n+                                new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n+                            }\n+                            self.cur_items.push(new_item);\n                         }\n-                        cur_items.push(new_item);\n+\n+                        // Allow for the possibility of one or more matches of this sequence.\n+                        self.cur_items.push(box MatcherPos::repetition(item, &seq));\n                     }\n \n-                    // Allow for the possibility of one or more matches of this sequence.\n-                    cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos::repetition(\n-                        item, sp, seq,\n-                    ))));\n-                }\n+                    &TokenTree::MetaVarDecl(span, _, None) => {\n+                        // E.g. `$e` instead of `$e:expr`.\n+                        if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n+                            return Some(Error(span, \"missing fragment specifier\".to_string()));\n+                        }\n+                    }\n \n-                TokenTree::MetaVarDecl(span, _, None) => {\n-                    // E.g. `$e` instead of `$e:expr`.\n-                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        return Some(Error(span, \"missing fragment specifier\".to_string()));\n+                    &TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n+                        // Built-in nonterminals never start with these tokens, so we can eliminate\n+                        // them from consideration.\n+                        //\n+                        // We use the span of the metavariable declaration to determine any\n+                        // edition-specific matching behavior for non-terminals.\n+                        if Parser::nonterminal_may_begin_with(kind, token) {\n+                            self.bb_items.push(item);\n+                        }\n                     }\n-                }\n \n-                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n-                    // Built-in nonterminals never start with these tokens, so we can eliminate\n-                    // them from consideration.\n-                    //\n-                    // We use the span of the metavariable declaration to determine any\n-                    // edition-specific matching behavior for non-terminals.\n-                    if Parser::nonterminal_may_begin_with(kind, token) {\n-                        bb_items.push(item);\n+                    TokenTree::Delimited(_, delimited) => {\n+                        // To descend into a delimited submatcher, we push the current matcher onto\n+                        // a stack and push a new item containing the submatcher onto `cur_items`.\n+                        //\n+                        // At the beginning of the loop, if we reach the end of the delimited\n+                        // submatcher, we pop the stack to backtrack out of the descent. Note that\n+                        // we use `all_tts` to include the open and close delimiter tokens.\n+                        let lower_elts = mem::replace(&mut item.top_elts, &delimited.all_tts);\n+                        let idx = item.idx;\n+                        item.stack.push(MatcherTtFrame { elts: lower_elts, idx });\n+                        item.idx = 0;\n+                        self.cur_items.push(item);\n                     }\n-                }\n \n-                seq @ (TokenTree::Delimited(..)\n-                | TokenTree::Token(Token { kind: DocComment(..), .. })) => {\n-                    // To descend into a delimited submatcher or a doc comment, we push the current\n-                    // matcher onto a stack and push a new item containing the submatcher onto\n-                    // `cur_items`.\n-                    //\n-                    // At the beginning of the loop, if we reach the end of the delimited\n-                    // submatcher, we pop the stack to backtrack out of the descent.\n-                    let lower_elts = mem::replace(&mut item.top_elts, Tt(seq));\n-                    let idx = item.idx;\n-                    item.stack.push(MatcherTtFrame { elts: lower_elts, idx });\n-                    item.idx = 0;\n-                    cur_items.push(item);\n+                    TokenTree::Token(t) => {\n+                        // Doc comments cannot appear in a matcher.\n+                        debug_assert!(!matches!(t, Token { kind: DocComment(..), .. }));\n+\n+                        // If the token matches, we can just advance the parser. Otherwise, this\n+                        // match hash failed, there is nothing to do, and hopefully another item in\n+                        // `cur_items` will match.\n+                        if token_name_eq(&t, token) {\n+                            item.idx += 1;\n+                            self.next_items.push(item);\n+                        }\n+                    }\n+\n+                    // These cannot appear in a matcher.\n+                    TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n+                }\n+            } else if let Some(repetition) = &item.repetition {\n+                // We are past the end of a repetition.\n+                debug_assert!(idx <= len + 1);\n+\n+                if idx == len {\n+                    // Add all matches from the sequence to `up`, and move the \"dot\" past the\n+                    // repetition in `up`. This allows for the case where the sequence matching is\n+                    // finished.\n+                    let mut new_pos = repetition.up.clone();\n+                    for idx in item.match_lo..item.match_hi {\n+                        let sub = item.matches[idx].clone();\n+                        new_pos.push_match(idx, MatchedSeq(sub));\n+                    }\n+                    new_pos.match_cur = item.match_hi;\n+                    new_pos.idx += 1;\n+                    self.cur_items.push(new_pos);\n                 }\n \n-                TokenTree::Token(t) => {\n-                    // If the token matches, we can just advance the parser. Otherwise, this match\n-                    // hash failed, there is nothing to do, and hopefully another item in\n-                    // `cur_items` will match.\n-                    if token_name_eq(&t, token) {\n+                if idx == len && repetition.sep.is_some() {\n+                    if repetition.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n+                        // The matcher has a separator, and it matches the current token. We can\n+                        // advance past the separator token.\n                         item.idx += 1;\n-                        next_items.push(item);\n+                        self.next_items.push(item);\n                     }\n+                } else if repetition.seq_op != mbe::KleeneOp::ZeroOrOne {\n+                    // We don't need a separator. Move the \"dot\" back to the beginning of the\n+                    // matcher and try to match again UNLESS we are only allowed to have _one_\n+                    // repetition.\n+                    item.match_cur = item.match_lo;\n+                    item.idx = 0;\n+                    self.cur_items.push(item);\n                 }\n-\n-                // These cannot appear in a matcher.\n-                TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n-            }\n-        } else if let Some(repetition) = &item.repetition {\n-            // We are past the end of a repetition.\n-            debug_assert!(idx <= len + 1);\n-            debug_assert!(matches!(item.top_elts, Tt(TokenTree::Sequence(..))));\n-\n-            if idx == len {\n-                // Add all matches from the sequence to `up`, and move the \"dot\" past the\n-                // repetition in `up`. This allows for the case where the sequence matching is\n-                // finished.\n-                let mut new_pos = repetition.up.clone();\n-                for idx in item.match_lo..item.match_hi {\n-                    let sub = item.matches[idx].clone();\n-                    new_pos.push_match(idx, MatchedSeq(sub));\n+            } else {\n+                // We are past the end of the matcher, and not in a repetition. Look for end of\n+                // input.\n+                debug_assert_eq!(idx, len);\n+                if *token == token::Eof {\n+                    eof_items = match eof_items {\n+                        EofItems::None => EofItems::One(item),\n+                        EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n+                    }\n                 }\n-                new_pos.match_cur = item.match_hi;\n-                new_pos.idx += 1;\n-                cur_items.push(new_pos);\n             }\n+        }\n \n-            if idx == len && repetition.sep.is_some() {\n-                if repetition.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n-                    // The matcher has a separator, and it matches the current token. We can\n-                    // advance past the separator token.\n-                    item.idx += 1;\n-                    next_items.push(item);\n+        // If we reached the end of input, check that there is EXACTLY ONE possible matcher.\n+        // Otherwise, either the parse is ambiguous (which is an error) or there is a syntax error.\n+        if *token == token::Eof {\n+            Some(match eof_items {\n+                EofItems::One(mut eof_item) => {\n+                    let matches =\n+                        eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n+                    nameize(sess, ms, matches)\n                 }\n-            } else if repetition.seq_op != mbe::KleeneOp::ZeroOrOne {\n-                // We don't need a separator. Move the \"dot\" back to the beginning of the\n-                // matcher and try to match again UNLESS we are only allowed to have _one_\n-                // repetition.\n-                item.match_cur = item.match_lo;\n-                item.idx = 0;\n-                cur_items.push(item);\n-            }\n-        } else {\n-            // We are past the end of the matcher, and not in a repetition. Look for end of input.\n-            debug_assert_eq!(idx, len);\n-            if *token == token::Eof {\n-                eof_items = match eof_items {\n-                    EofItems::None => EofItems::One(item),\n-                    EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n+                EofItems::Multiple => {\n+                    Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n                 }\n-            }\n+                EofItems::None => Failure(\n+                    Token::new(\n+                        token::Eof,\n+                        if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n+                    ),\n+                    \"missing tokens in macro arguments\",\n+                ),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n-    // If we reached the end of input, check that there is EXACTLY ONE possible matcher. Otherwise,\n-    // either the parse is ambiguous (which is an error) or there is a syntax error.\n-    if *token == token::Eof {\n-        Some(match eof_items {\n-            EofItems::One(mut eof_item) => {\n-                let matches =\n-                    eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                nameize(sess, ms, matches)\n-            }\n-            EofItems::Multiple => {\n-                Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n+    /// Use the given slice of token trees (`ms`) as a matcher. Match the token stream from the\n+    /// given `parser` against it and return the match.\n+    pub(super) fn parse_tt(\n+        &mut self,\n+        parser: &mut Cow<'_, Parser<'_>>,\n+        ms: &'tt [TokenTree],\n+    ) -> NamedParseResult {\n+        // A queue of possible matcher positions. We initialize it with the matcher position in\n+        // which the \"dot\" is before the first token of the first token tree in `ms`.\n+        // `parse_tt_inner` then processes all of these possible matcher positions and produces\n+        // possible next positions into `next_items`. After some post-processing, the contents of\n+        // `next_items` replenish `cur_items` and we start over again.\n+        self.cur_items.clear();\n+        self.cur_items.push(box MatcherPos::new(ms));\n+\n+        loop {\n+            self.next_items.clear();\n+            self.bb_items.clear();\n+\n+            // Process `cur_items` until either we have finished the input or we need to get some\n+            // parsing from the black-box parser done.\n+            if let Some(result) = self.parse_tt_inner(parser.sess, ms, &parser.token) {\n+                return result;\n             }\n-            EofItems::None => Failure(\n-                Token::new(\n-                    token::Eof,\n-                    if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n-                ),\n-                \"missing tokens in macro arguments\",\n-            ),\n-        })\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Use the given slice of token trees (`ms`) as a matcher. Match the token stream from the given\n-/// `parser` against it and return the match.\n-pub(super) fn parse_tt(\n-    parser: &mut Cow<'_, Parser<'_>>,\n-    ms: &[TokenTree],\n-    macro_name: Ident,\n-) -> NamedParseResult {\n-    // A queue of possible matcher positions. We initialize it with the matcher position in which\n-    // the \"dot\" is before the first token of the first token tree in `ms`. `parse_tt_inner` then\n-    // processes all of these possible matcher positions and produces possible next positions into\n-    // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`\n-    // and we start over again.\n-    //\n-    // This MatcherPos instance is allocated on the stack. All others -- and there are frequently\n-    // *no* others! -- are allocated on the heap.\n-    let mut initial = MatcherPos::new(ms);\n-    let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n-\n-    loop {\n-        let mut next_items = SmallVec::new();\n-\n-        // Matcher positions black-box parsed by `Parser`.\n-        let mut bb_items = SmallVec::new();\n-\n-        // Process `cur_items` until either we have finished the input or we need to get some\n-        // parsing from the black-box parser done.\n-        if let Some(result) = parse_tt_inner(\n-            parser.sess,\n-            ms,\n-            &mut cur_items,\n-            &mut next_items,\n-            &mut bb_items,\n-            &parser.token,\n-        ) {\n-            return result;\n-        }\n \n-        // `parse_tt_inner` handled all cur_items, so it's empty.\n-        assert!(cur_items.is_empty());\n+            // `parse_tt_inner` handled all cur_items, so it's empty.\n+            assert!(self.cur_items.is_empty());\n+\n+            // Error messages here could be improved with links to original rules.\n+            match (self.next_items.len(), self.bb_items.len()) {\n+                (0, 0) => {\n+                    // There are no possible next positions AND we aren't waiting for the black-box\n+                    // parser: syntax error.\n+                    return Failure(\n+                        parser.token.clone(),\n+                        \"no rules expected this token in macro call\",\n+                    );\n+                }\n \n-        // Error messages here could be improved with links to original rules.\n-        match (next_items.len(), bb_items.len()) {\n-            (0, 0) => {\n-                // There are no possible next positions AND we aren't waiting for the black-box\n-                // parser: syntax error.\n-                return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n-            }\n+                (_, 0) => {\n+                    // Dump all possible `next_items` into `cur_items` for the next iteration. Then\n+                    // process the next token.\n+                    self.cur_items.extend(self.next_items.drain(..));\n+                    parser.to_mut().bump();\n+                }\n \n-            (_, 0) => {\n-                // Dump all possible `next_items` into `cur_items` for the next iteration. Then\n-                // process the next token.\n-                cur_items.extend(next_items.drain(..));\n-                parser.to_mut().bump();\n-            }\n+                (0, 1) => {\n+                    // We need to call the black-box parser to get some nonterminal.\n+                    let mut item = self.bb_items.pop().unwrap();\n+                    if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts[item.idx] {\n+                        let match_cur = item.match_cur;\n+                        // We use the span of the metavariable declaration to determine any\n+                        // edition-specific matching behavior for non-terminals.\n+                        let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                            Err(mut err) => {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\n+                                        \"while parsing argument for this `{kind}` macro fragment\"\n+                                    ),\n+                                )\n+                                .emit();\n+                                return ErrorReported;\n+                            }\n+                            Ok(nt) => nt,\n+                        };\n+                        item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n+                        item.idx += 1;\n+                        item.match_cur += 1;\n+                    } else {\n+                        unreachable!()\n+                    }\n+                    self.cur_items.push(item);\n+                }\n \n-            (0, 1) => {\n-                // We need to call the black-box parser to get some nonterminal.\n-                let mut item = bb_items.pop().unwrap();\n-                if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx)\n-                {\n-                    let match_cur = item.match_cur;\n-                    // We use the span of the metavariable declaration to determine any\n-                    // edition-specific matching behavior for non-terminals.\n-                    let nt = match parser.to_mut().parse_nonterminal(kind) {\n-                        Err(mut err) => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"while parsing argument for this `{kind}` macro fragment\"),\n-                            )\n-                            .emit();\n-                            return ErrorReported;\n-                        }\n-                        Ok(nt) => nt,\n-                    };\n-                    item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n-                    item.idx += 1;\n-                    item.match_cur += 1;\n-                } else {\n-                    unreachable!()\n+                (_, _) => {\n+                    // Too many possibilities!\n+                    return self.ambiguity_error(parser.token.span);\n                 }\n-                cur_items.push(item);\n             }\n \n-            (_, _) => {\n-                // Too many possibilities!\n-                return bb_items_ambiguity_error(\n-                    macro_name,\n-                    next_items,\n-                    bb_items,\n-                    parser.token.span,\n-                );\n-            }\n+            assert!(!self.cur_items.is_empty());\n         }\n-\n-        assert!(!cur_items.is_empty());\n     }\n-}\n \n-fn bb_items_ambiguity_error<'root, 'tt>(\n-    macro_name: Ident,\n-    next_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    bb_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    token_span: rustc_span::Span,\n-) -> NamedParseResult {\n-    let nts = bb_items\n-        .iter()\n-        .map(|item| match item.top_elts.get_tt(item.idx) {\n-            TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n-                format!(\"{} ('{}')\", kind, bind)\n-            }\n-            _ => panic!(),\n-        })\n-        .collect::<Vec<String>>()\n-        .join(\" or \");\n-\n-    Error(\n-        token_span,\n-        format!(\n-            \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n-            match next_items.len() {\n-                0 => format!(\"built-in NTs {}.\", nts),\n-                1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n-                n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n-            }\n-        ),\n-    )\n+    fn ambiguity_error(&self, token_span: rustc_span::Span) -> NamedParseResult {\n+        let nts = self\n+            .bb_items\n+            .iter()\n+            .map(|item| match item.top_elts[item.idx] {\n+                TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n+                    format!(\"{} ('{}')\", kind, bind)\n+                }\n+                _ => panic!(),\n+            })\n+            .collect::<Vec<String>>()\n+            .join(\" or \");\n+\n+        Error(\n+            token_span,\n+            format!(\n+                \"local ambiguity when calling macro `{}`: multiple parsing options: {}\",\n+                self.macro_name,\n+                match self.next_items.len() {\n+                    0 => format!(\"built-in NTs {}.\", nts),\n+                    1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n+                    n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n+                }\n+            ),\n+        )\n+    }\n }"}, {"sha": "f13b97251d21035a71b340f81ee72814f3b47cb3", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -3,8 +3,7 @@ use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n use crate::mbe::macro_check;\n-use crate::mbe::macro_parser::parse_tt;\n-use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success};\n+use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n@@ -204,15 +203,15 @@ fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span,\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension<'cx>(\n+fn generic_extension<'cx, 'tt>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     def_span: Span,\n     name: Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n-    lhses: &[mbe::TokenTree],\n-    rhses: &[mbe::TokenTree],\n+    lhses: &'tt [mbe::TokenTree],\n+    rhses: &'tt [mbe::TokenTree],\n     is_local: bool,\n ) -> Box<dyn MacResult + 'cx> {\n     let sess = &cx.sess.parse_sess;\n@@ -246,30 +245,30 @@ fn generic_extension<'cx>(\n     // this situation.)\n     let parser = parser_from_cx(sess, arg.clone());\n \n-    for (i, lhs) in lhses.iter().enumerate() {\n-        // try each arm's matchers\n-        let lhs_tt = match *lhs {\n-            mbe::TokenTree::Delimited(_, ref delim) => &delim.tts,\n+    // A matcher is always delimited, but the delimiters are ignored.\n+    let delimited_inner_tts = |tt: &'tt mbe::TokenTree| -> &'tt [mbe::TokenTree] {\n+        match tt {\n+            mbe::TokenTree::Delimited(_, delimited) => delimited.inner_tts(),\n             _ => cx.span_bug(sp, \"malformed macro lhs\"),\n-        };\n+        }\n+    };\n \n+    // Try each arm's matchers.\n+    let mut tt_parser = TtParser::new(name);\n+    for (i, lhs) in lhses.iter().enumerate() {\n         // Take a snapshot of the state of pre-expansion gating at this point.\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt, name) {\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), delimited_inner_tts(lhs)) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let rhs = match rhses[i] {\n-                    // ignore delimiters\n-                    mbe::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n-                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n-                };\n+                let rhs = delimited_inner_tts(&rhses[i]).to_vec().clone();\n                 let arm_span = rhses[i].span();\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n@@ -347,14 +346,10 @@ fn generic_extension<'cx>(\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n-            // try each arm's matchers\n-            let lhs_tt = match *lhs {\n-                mbe::TokenTree::Delimited(_, ref delim) => &delim.tts,\n-                _ => continue,\n-            };\n-            if let Success(_) =\n-                parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt, name)\n-            {\n+            if let Success(_) = tt_parser.parse_tt(\n+                &mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())),\n+                delimited_inner_tts(lhs),\n+            ) {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n                 } else {\n@@ -447,7 +442,8 @@ pub fn compile_declarative_macro(\n     ];\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n-    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, def.ident) {\n+    let mut tt_parser = TtParser::new(def.ident);\n+    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -476,16 +472,17 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(\n+                        let mut tts = vec![];\n+                        mbe::quoted::parse(\n                             tt.clone().into(),\n                             true,\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n                             edition,\n-                        )\n-                        .pop()\n-                        .unwrap();\n+                            &mut tts,\n+                        );\n+                        let tt = tts.pop().unwrap();\n                         valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n                         return tt;\n                     }\n@@ -502,16 +499,17 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(\n+                        let mut tts = vec![];\n+                        mbe::quoted::parse(\n                             tt.clone().into(),\n                             false,\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n                             edition,\n-                        )\n-                        .pop()\n-                        .unwrap();\n+                            &mut tts,\n+                        );\n+                        return tts.pop().unwrap();\n                     }\n                 }\n                 sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -563,8 +561,8 @@ fn check_lhs_nt_follows(\n ) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n-    if let mbe::TokenTree::Delimited(_, ref tts) = *lhs {\n-        check_matcher(sess, features, def, &tts.tts)\n+    if let mbe::TokenTree::Delimited(_, delimited) = lhs {\n+        check_matcher(sess, features, def, delimited.inner_tts())\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -585,7 +583,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n             TokenTree::Delimited(_, ref del) => {\n-                if !check_lhs_no_empty_seq(sess, &del.tts) {\n+                if !check_lhs_no_empty_seq(sess, del.inner_tts()) {\n                     return false;\n                 }\n             }\n@@ -680,9 +678,9 @@ impl FirstSets {\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(tt.clone());\n                     }\n-                    TokenTree::Delimited(span, ref delimited) => {\n-                        build_recur(sets, &delimited.tts);\n-                        first.replace_with(delimited.open_tt(span));\n+                    TokenTree::Delimited(_span, ref delimited) => {\n+                        build_recur(sets, delimited.inner_tts());\n+                        first.replace_with(delimited.open_tt().clone());\n                     }\n                     TokenTree::Sequence(sp, ref seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n@@ -746,8 +744,8 @@ impl FirstSets {\n                     first.add_one(tt.clone());\n                     return first;\n                 }\n-                TokenTree::Delimited(span, ref delimited) => {\n-                    first.add_one(delimited.open_tt(span));\n+                TokenTree::Delimited(_span, ref delimited) => {\n+                    first.add_one(delimited.open_tt().clone());\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n@@ -933,9 +931,9 @@ fn check_matcher_core(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(span, ref d) => {\n-                let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n+            TokenTree::Delimited(_span, ref d) => {\n+                let my_suffix = TokenSet::singleton(d.close_tt().clone());\n+                check_matcher_core(sess, features, def, first_sets, d.inner_tts(), &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n "}, {"sha": "b3ed6b8e4db2423c7b446d0d05675be776a8199b", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -45,10 +45,8 @@ pub(super) fn parse(\n     node_id: NodeId,\n     features: &Features,\n     edition: Edition,\n-) -> Vec<TokenTree> {\n-    // Will contain the final collection of `self::TokenTree`\n-    let mut result = Vec::new();\n-\n+    result: &mut Vec<TokenTree>,\n+) {\n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n     let mut trees = input.trees();\n@@ -115,7 +113,6 @@ pub(super) fn parse(\n             _ => result.push(tree),\n         }\n     }\n-    result\n }\n \n /// Asks for the `macro_metavar_expr` feature if it is not already declared\n@@ -208,7 +205,8 @@ fn parse_tree(\n                     // If we didn't find a metavar expression above, then we must have a\n                     // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n                     // contents of the sequence itself\n-                    let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n+                    let mut sequence = vec![];\n+                    parse(tts, parsing_patterns, sess, node_id, features, edition, &mut sequence);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, delim_span.entire(), sess);\n@@ -225,8 +223,8 @@ fn parse_tree(\n                     )\n                 }\n \n-                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n-                // metavariable that names the crate of the invocation.\n+                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate`\n+                // special metavariable that names the crate of the invocation.\n                 Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n                     let (ident, is_raw) = token.ident().unwrap();\n                     let span = ident.span.with_lo(span.lo());\n@@ -270,13 +268,15 @@ fn parse_tree(\n \n         // `tree` is the beginning of a delimited set of tokens (e.g., `(` or `{`). We need to\n         // descend into the delimited set and further parse it.\n-        tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n-            span,\n-            Lrc::new(Delimited {\n-                delim,\n-                tts: parse(tts, parsing_patterns, sess, node_id, features, edition),\n-            }),\n-        ),\n+        tokenstream::TokenTree::Delimited(span, delim, tts) => {\n+            let mut all_tts = vec![];\n+            // Add the explicit open and close delimiters, which\n+            // `tokenstream::TokenTree::Delimited` lacks.\n+            all_tts.push(TokenTree::token(token::OpenDelim(delim), span.open));\n+            parse(tts, parsing_patterns, sess, node_id, features, edition, &mut all_tts);\n+            all_tts.push(TokenTree::token(token::CloseDelim(delim), span.close));\n+            TokenTree::Delimited(span, Lrc::new(Delimited { delim, all_tts }))\n+        }\n     }\n }\n "}, {"sha": "e097f9d9c02edf052f604df5bf800ded7096a428", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a5e79814fb4d1568fb0ea5ca50f810b071ae12/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=a4a5e79814fb4d1568fb0ea5ca50f810b071ae12", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::{pluralize, PResult};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_span::hygiene::{LocalExpnId, Transparency};\n use rustc_span::symbol::{sym, Ident, MacroRulesNormalizedIdent};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n use std::mem;\n@@ -34,8 +34,14 @@ enum Frame {\n \n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(tts: Vec<mbe::TokenTree>) -> Frame {\n-        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, tts });\n+    fn new(mut tts: Vec<mbe::TokenTree>) -> Frame {\n+        // Need to add empty delimeters.\n+        let open_tt = mbe::TokenTree::token(token::OpenDelim(token::NoDelim), DUMMY_SP);\n+        let close_tt = mbe::TokenTree::token(token::CloseDelim(token::NoDelim), DUMMY_SP);\n+        tts.insert(0, open_tt);\n+        tts.push(close_tt);\n+\n+        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, all_tts: tts });\n         Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n@@ -46,12 +52,14 @@ impl Iterator for Frame {\n     fn next(&mut self) -> Option<mbe::TokenTree> {\n         match *self {\n             Frame::Delimited { ref forest, ref mut idx, .. } => {\n+                let res = forest.inner_tts().get(*idx).cloned();\n                 *idx += 1;\n-                forest.tts.get(*idx - 1).cloned()\n+                res\n             }\n             Frame::Sequence { ref forest, ref mut idx, .. } => {\n+                let res = forest.tts.get(*idx).cloned();\n                 *idx += 1;\n-                forest.tts.get(*idx - 1).cloned()\n+                res\n             }\n         }\n     }\n@@ -376,8 +384,8 @@ fn lockstep_iter_size(\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n     match *tree {\n-        TokenTree::Delimited(_, ref delimed) => {\n-            delimed.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n+        TokenTree::Delimited(_, ref delimited) => {\n+            delimited.inner_tts().iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }"}]}