{"sha": "2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZTM3YzViZDFjYzdkNmNmYTE3NmY0MDhjMmI4MzRlMWIyNjE3YmY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-27T08:38:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-17T17:41:07Z"}, "message": "Choose encoding format in caller code.", "tree": {"sha": "6fbc2c6730e434a7c31dc915f8e18dbf1664c9f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fbc2c6730e434a7c31dc915f8e18dbf1664c9f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "html_url": "https://github.com/rust-lang/rust/commit/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "078dd37f882a59d4277d80b829d729bfd2b5a5c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/078dd37f882a59d4277d80b829d729bfd2b5a5c2", "html_url": "https://github.com/rust-lang/rust/commit/078dd37f882a59d4277d80b829d729bfd2b5a5c2"}], "stats": {"total": 140, "additions": 55, "deletions": 85}, "files": [{"sha": "8b8ca987b380d1538b8e60beb9f9ea06fd5aa726", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "patch": "@@ -377,7 +377,11 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n         let local_cdata = decoder.cdata();\n         let sess = decoder.sess.unwrap();\n \n-        rustc_span::hygiene::decode_expn_id(decoder, |cnum, index| {\n+        let cnum = CrateNum::decode(decoder)?;\n+        let index = u32::decode(decoder)?;\n+\n+        let expn_id = rustc_span::hygiene::decode_expn_id(cnum, index, |expn_id| {\n+            let ExpnId { krate: cnum, local_id: index } = expn_id;\n             // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n             // are stored in the owning crate, to avoid duplication.\n             debug_assert_ne!(cnum, LOCAL_CRATE);\n@@ -399,7 +403,8 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n                 .unwrap()\n                 .decode((&crate_data, sess));\n             (expn_data, expn_hash)\n-        })\n+        });\n+        Ok(expn_id)\n     }\n }\n "}, {"sha": "6877d6ef542c7fe76348a17206d1aaf8ea437f4f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "patch": "@@ -182,7 +182,15 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        rustc_span::hygiene::raw_encode_expn_id(*self, &s.hygiene_ctxt, s)\n+        if self.krate == LOCAL_CRATE {\n+            // We will only write details for local expansions.  Non-local expansions will fetch\n+            // data from the corresponding crate's metadata.\n+            // FIXME(#43047) FIXME(#74731) We may eventually want to avoid relying on external\n+            // metadata from proc-macro crates.\n+            s.hygiene_ctxt.schedule_expn_data_for_encoding(*self);\n+        }\n+        self.krate.encode(s)?;\n+        self.local_id.encode(s)\n     }\n }\n "}, {"sha": "685cb3a61ecabe8531978718e21b1d8b44504762", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "patch": "@@ -794,25 +794,26 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let krate = CrateNum::decode(decoder)?;\n+        let index = u32::decode(decoder)?;\n+\n         let expn_data = decoder.expn_data;\n+        let tcx = decoder.tcx;\n         rustc_span::hygiene::decode_expn_id_incrcomp(\n-            decoder,\n+            krate,\n+            index,\n             decoder.hygiene_context,\n-            |this, index| {\n+            |index| -> Result<(ExpnData, ExpnHash), _> {\n                 // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n                 // We look up the position of the associated `ExpnData` and decode it.\n                 let pos = expn_data\n                     .get(&index)\n                     .unwrap_or_else(|| panic!(\"Bad index {:?} (map {:?})\", index, expn_data));\n \n-                this.with_position(pos.to_usize(), |decoder| {\n-                    let data: (ExpnData, ExpnHash) = decode_tagged(decoder, TAG_EXPN_DATA)?;\n-                    Ok(data)\n-                })\n-            },\n-            |this, expn_id| {\n-                Ok(this.tcx.untracked_resolutions.cstore.decode_expn_data(this.tcx.sess, expn_id))\n+                decoder\n+                    .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA))\n             },\n+            |expn_id| tcx.untracked_resolutions.cstore.decode_expn_data(tcx.sess, expn_id),\n         )\n     }\n }\n@@ -988,7 +989,9 @@ where\n     E: 'a + OpaqueEncoder,\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        rustc_span::hygiene::raw_encode_expn_id_incrcomp(*self, s.hygiene_context, s)\n+        s.hygiene_context.schedule_expn_data_for_encoding(*self);\n+        self.krate.encode(s)?;\n+        self.local_id.as_u32().encode(s)\n     }\n }\n "}, {"sha": "198bb5881422fc719b157ddfabcce5af607204a7", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 26, "deletions": 72, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=2fe37c5bd1cc7d6cfa176f408c2b834e1b2617bf", "patch": "@@ -261,6 +261,8 @@ pub struct HygieneData {\n     /// first and then resolved later), so we use an `Option` here.\n     local_expn_data: IndexVec<LocalExpnId, Option<ExpnData>>,\n     local_expn_hashes: IndexVec<LocalExpnId, ExpnHash>,\n+    /// Data and hash information from external crates.  We may eventually want to remove these\n+    /// maps, and fetch the information directly from the other crate's metadata like DefIds do.\n     foreign_expn_data: FxHashMap<ExpnId, ExpnData>,\n     foreign_expn_hashes: FxHashMap<ExpnId, ExpnHash>,\n     expn_hash_to_expn_id: UnhashMap<ExpnHash, ExpnId>,\n@@ -1130,6 +1132,13 @@ pub struct HygieneEncodeContext {\n }\n \n impl HygieneEncodeContext {\n+    /// Record the fact that we need to serialize the corresponding `ExpnData`.\n+    pub fn schedule_expn_data_for_encoding(&self, expn: ExpnId) {\n+        if !self.serialized_expns.lock().contains(&expn) {\n+            self.latest_expns.lock().insert(expn);\n+        }\n+    }\n+\n     pub fn encode<T, R>(\n         &self,\n         encoder: &mut T,\n@@ -1186,15 +1195,13 @@ pub struct HygieneDecodeContext {\n     remapped_expns: Lock<Vec<Option<LocalExpnId>>>,\n }\n \n-pub fn decode_expn_id_incrcomp<D: Decoder>(\n-    d: &mut D,\n+pub fn decode_expn_id_incrcomp<E>(\n+    krate: CrateNum,\n+    index: u32,\n     context: &HygieneDecodeContext,\n-    decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n-    decode_foreign: impl FnOnce(&mut D, ExpnId) -> Result<(ExpnData, ExpnHash), D::Error>,\n-) -> Result<ExpnId, D::Error> {\n-    let krate = CrateNum::decode(d)?;\n-    let index = u32::decode(d)?;\n-\n+    decode_data: impl FnOnce(u32) -> Result<(ExpnData, ExpnHash), E>,\n+    decode_foreign: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n+) -> Result<ExpnId, E> {\n     // Do this after decoding, so that we decode a `CrateNum`\n     // if necessary\n     if index == 0 {\n@@ -1203,23 +1210,7 @@ pub fn decode_expn_id_incrcomp<D: Decoder>(\n     }\n \n     if krate != LOCAL_CRATE {\n-        let expn_id = ExpnId { krate, local_id: ExpnIndex::from_u32(index) };\n-        if HygieneData::with(|hygiene_data| hygiene_data.foreign_expn_data.contains_key(&expn_id)) {\n-            return Ok(expn_id);\n-        }\n-        let (expn_data, hash) = decode_foreign(d, expn_id)?;\n-        debug_assert_eq!(krate, expn_data.krate);\n-        debug_assert_eq!(expn_data.orig_id, Some(index));\n-        let expn_id = HygieneData::with(|hygiene_data| {\n-            debug_assert_eq!(expn_data.orig_id, Some(index));\n-            let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, expn_data);\n-            debug_assert!(_old_data.is_none());\n-            let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n-            debug_assert!(_old_hash.is_none());\n-            let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n-            debug_assert!(_old_id.is_none());\n-            expn_id\n-        });\n+        let expn_id = decode_expn_id(krate, index, decode_foreign);\n         return Ok(expn_id);\n     }\n \n@@ -1234,7 +1225,7 @@ pub fn decode_expn_id_incrcomp<D: Decoder>(\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n-    let (mut expn_data, hash) = decode_data(d, index)?;\n+    let (mut expn_data, hash) = decode_data(index)?;\n     debug_assert_eq!(krate, expn_data.krate);\n \n     let expn_id = HygieneData::with(|hygiene_data| {\n@@ -1269,18 +1260,14 @@ pub fn decode_expn_id_incrcomp<D: Decoder>(\n     Ok(expn_id)\n }\n \n-pub fn decode_expn_id<D: Decoder>(\n-    d: &mut D,\n-    decode_data: impl FnOnce(CrateNum, ExpnIndex) -> (ExpnData, ExpnHash),\n-) -> Result<ExpnId, D::Error> {\n-    let krate = CrateNum::decode(d)?;\n-    let index = u32::decode(d)?;\n-\n-    // Do this after decoding, so that we decode a `CrateNum`\n-    // if necessary\n+pub fn decode_expn_id(\n+    krate: CrateNum,\n+    index: u32,\n+    decode_data: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n+) -> ExpnId {\n     if index == 0 {\n         debug!(\"decode_expn_id: deserialized root\");\n-        return Ok(ExpnId::root());\n+        return ExpnId::root();\n     }\n \n     let index = ExpnIndex::from_u32(index);\n@@ -1291,12 +1278,12 @@ pub fn decode_expn_id<D: Decoder>(\n \n     // Fast path if the expansion has already been decoded.\n     if HygieneData::with(|hygiene_data| hygiene_data.foreign_expn_data.contains_key(&expn_id)) {\n-        return Ok(expn_id);\n+        return expn_id;\n     }\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n-    let (expn_data, hash) = decode_data(krate, index);\n+    let (expn_data, hash) = decode_data(expn_id);\n     debug_assert_eq!(krate, expn_data.krate);\n     debug_assert_eq!(Some(index.as_u32()), expn_data.orig_id);\n \n@@ -1309,7 +1296,7 @@ pub fn decode_expn_id<D: Decoder>(\n         debug_assert!(_old_id.is_none());\n     });\n \n-    Ok(expn_id)\n+    expn_id\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1448,39 +1435,6 @@ pub fn raw_encode_syntax_context<E: Encoder>(\n     ctxt.0.encode(e)\n }\n \n-pub fn raw_encode_expn_id_incrcomp<E: Encoder>(\n-    expn: ExpnId,\n-    context: &HygieneEncodeContext,\n-    e: &mut E,\n-) -> Result<(), E::Error> {\n-    // Record the fact that we need to serialize the corresponding `ExpnData`\n-    if !context.serialized_expns.lock().contains(&expn) {\n-        context.latest_expns.lock().insert(expn);\n-    }\n-    expn.krate.encode(e)?;\n-    expn.local_id.as_u32().encode(e)\n-}\n-\n-pub fn raw_encode_expn_id<E: Encoder>(\n-    expn: ExpnId,\n-    context: &HygieneEncodeContext,\n-    e: &mut E,\n-) -> Result<(), E::Error> {\n-    // We only need to serialize the ExpnData\n-    // if it comes from this crate.\n-    // We currently don't serialize any hygiene information data for\n-    // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n-    // for crate metadata.\n-    // Record the fact that we need to serialize the corresponding `ExpnData`\n-    if expn.krate == LOCAL_CRATE {\n-        if !context.serialized_expns.lock().contains(&expn) {\n-            context.latest_expns.lock().insert(expn);\n-        }\n-    }\n-    expn.krate.encode(e)?;\n-    expn.local_id.as_u32().encode(e)\n-}\n-\n impl<E: Encoder> Encodable<E> for SyntaxContext {\n     default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n         panic!(\"cannot encode `SyntaxContext` with `{}`\", std::any::type_name::<E>());"}]}