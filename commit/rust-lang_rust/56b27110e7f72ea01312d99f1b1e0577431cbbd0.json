{"sha": "56b27110e7f72ea01312d99f1b1e0577431cbbd0", "node_id": "C_kwDOAAsO6NoAKDU2YjI3MTEwZTdmNzJlYTAxMzEyZDk5ZjFiMWUwNTc3NDMxY2JiZDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T00:23:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T00:23:01Z"}, "message": "Auto merge of #101464 - JohnTitor:rollup-unsjgm6, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #99291 (Add let else drop order tests)\n - #101402 (Add a Machine hook for inline assembly)\n - #101404 (Fix cleanup for uninitialized stdout)\n - #101418 (Revert \"Mention rust-analyzer maintainers when `proc_macro` bridge is changed\")\n - #101425 (Point at type parameter in plain path expr)\n - #101426 (Don't duplicate file descriptors into stdio fds)\n - #101447 (Remove generics_def_id_map from the resolver.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0f4b4c28ee4f9f11a39211a506d4489e44e08c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f4b4c28ee4f9f11a39211a506d4489e44e08c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56b27110e7f72ea01312d99f1b1e0577431cbbd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56b27110e7f72ea01312d99f1b1e0577431cbbd0", "html_url": "https://github.com/rust-lang/rust/commit/56b27110e7f72ea01312d99f1b1e0577431cbbd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56b27110e7f72ea01312d99f1b1e0577431cbbd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "676afc514944aa618977bacf8fe28cefc443a13a", "url": "https://api.github.com/repos/rust-lang/rust/commits/676afc514944aa618977bacf8fe28cefc443a13a", "html_url": "https://github.com/rust-lang/rust/commit/676afc514944aa618977bacf8fe28cefc443a13a"}, {"sha": "0d8a1f4cbf0fd6acb6e81946aa3da2c7f15ee431", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8a1f4cbf0fd6acb6e81946aa3da2c7f15ee431", "html_url": "https://github.com/rust-lang/rust/commit/0d8a1f4cbf0fd6acb6e81946aa3da2c7f15ee431"}], "stats": {"total": 515, "additions": 433, "deletions": 82}, "files": [{"sha": "d3e5bfaaa125587019810565471b8bc83702d98e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -85,6 +85,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n             allow_into_future: Some([sym::into_future][..].into()),\n+            generics_def_id_map: Default::default(),\n         };\n         lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n "}, {"sha": "ef83add24bf601a4925f545fae6e1268baedd3b0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -132,6 +132,12 @@ struct LoweringContext<'a, 'hir> {\n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n     allow_into_future: Option<Lrc<[Symbol]>>,\n+\n+    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n+    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n+    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n+    /// field from the original parameter 'a to the new parameter 'a1.\n+    generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n }\n \n trait ResolverAstLoweringExt {\n@@ -142,12 +148,6 @@ trait ResolverAstLoweringExt {\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n-    /// Record the map from `from` local def id to `to` local def id, on `generics_def_id_map`\n-    /// field.\n-    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId);\n-    /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n-    /// `generics_def_id_map` field.\n-    fn get_remapped_def_id(&self, local_def_id: LocalDefId) -> LocalDefId;\n }\n \n impl ResolverAstLoweringExt for ResolverAstLowering {\n@@ -215,41 +215,6 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n         self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n     }\n-\n-    /// Push a remapping into the top-most map.\n-    /// Panics if no map has been pushed.\n-    /// Remapping is used when creating lowering `-> impl Trait` return\n-    /// types to create the resulting opaque type.\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId) {\n-        self.generics_def_id_map.last_mut().expect(\"no map pushed\").insert(from, to);\n-    }\n-\n-    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n-        // `generics_def_id_map` is a stack of mappings. As we go deeper in impl traits nesting we\n-        // push new mappings so we need to try first the latest mappings, hence `iter().rev()`.\n-        //\n-        // Consider:\n-        //\n-        // `fn test<'a, 'b>() -> impl Trait<&'a u8, Ty = impl Sized + 'b> {}`\n-        //\n-        // We would end with a generics_def_id_map like:\n-        //\n-        // `[[fn#'b -> impl_trait#'b], [fn#'b -> impl_sized#'b]]`\n-        //\n-        // for the opaque type generated on `impl Sized + 'b`, We want the result to be:\n-        // impl_sized#'b, so iterating forward is the wrong thing to do.\n-        for map in self.generics_def_id_map.iter().rev() {\n-            if let Some(r) = map.get(&local_def_id) {\n-                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n-                local_def_id = *r;\n-            } else {\n-                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n-            }\n-        }\n-\n-        local_def_id\n-    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -522,13 +487,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.resolver\n             .node_id_to_def_id\n             .get(&node)\n-            .map(|local_def_id| self.resolver.get_remapped_def_id(*local_def_id))\n+            .map(|local_def_id| self.get_remapped_def_id(*local_def_id))\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n+    /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n+    /// `generics_def_id_map` field.\n+    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n+        // `generics_def_id_map` is a stack of mappings. As we go deeper in impl traits nesting we\n+        // push new mappings so we need to try first the latest mappings, hence `iter().rev()`.\n+        //\n+        // Consider:\n+        //\n+        // `fn test<'a, 'b>() -> impl Trait<&'a u8, Ty = impl Sized + 'b> {}`\n+        //\n+        // We would end with a generics_def_id_map like:\n+        //\n+        // `[[fn#'b -> impl_trait#'b], [fn#'b -> impl_sized#'b]]`\n+        //\n+        // for the opaque type generated on `impl Sized + 'b`, We want the result to be:\n+        // impl_sized#'b, so iterating forward is the wrong thing to do.\n+        for map in self.generics_def_id_map.iter().rev() {\n+            if let Some(r) = map.get(&local_def_id) {\n+                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n+                local_def_id = *r;\n+            } else {\n+                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n+            }\n+        }\n+\n+        local_def_id\n+    }\n+\n     /// Freshen the `LoweringContext` and ready it to lower a nested item.\n     /// The lowered item is registered into `self.children`.\n     ///\n@@ -597,9 +590,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         remap: FxHashMap<LocalDefId, LocalDefId>,\n         f: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n-        self.resolver.generics_def_id_map.push(remap);\n+        self.generics_def_id_map.push(remap);\n         let res = f(self);\n-        self.resolver.generics_def_id_map.pop();\n+        self.generics_def_id_map.pop();\n         res\n     }\n \n@@ -2027,7 +2020,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let name = match res {\n             LifetimeRes::Param { param, .. } => {\n                 let p_name = ParamName::Plain(ident);\n-                let param = self.resolver.get_remapped_def_id(param);\n+                let param = self.get_remapped_def_id(param);\n \n                 hir::LifetimeName::Param(param, p_name)\n             }"}, {"sha": "530e252b7c077ed0a0f4d0cfdb2c0d5c3357a62b", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -6,6 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::fmt::Debug;\n use std::hash::Hash;\n \n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n@@ -323,6 +324,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n \n+    fn eval_inline_asm(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _template: &'tcx [InlineAsmTemplatePiece],\n+        _operands: &[mir::InlineAsmOperand<'tcx>],\n+        _options: InlineAsmOptions,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"inline assembly is not supported\")\n+    }\n+\n     /// Hook for performing extra checks on a memory read access.\n     ///\n     /// Takes read-only access to the allocation so we can keep all the memory read"}, {"sha": "50a82aa0e72c9c7fe55013f4f6e73cae8e55ba70", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -1,5 +1,6 @@\n use std::borrow::Cow;\n \n+use rustc_ast::ast::InlineAsmOptions;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n@@ -166,8 +167,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 terminator.kind\n             ),\n \n-            // Inline assembly can't be interpreted.\n-            InlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n+            InlineAsm { template, ref operands, options, destination, .. } => {\n+                M::eval_inline_asm(self, template, operands, options)?;\n+                if options.contains(InlineAsmOptions::NORETURN) {\n+                    throw_ub_format!(\"returned from noreturn inline assembly\");\n+                }\n+                self.go_to_block(\n+                    destination\n+                        .expect(\"InlineAsm terminators without noreturn must have a destination\"),\n+                )\n+            }\n         }\n \n         Ok(())"}, {"sha": "8235a05fb53f1e0bd41a6e0420c304b8d80f1b10", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -178,11 +178,6 @@ pub struct ResolverAstLowering {\n     pub label_res_map: NodeMap<ast::NodeId>,\n     /// Resolutions for lifetimes.\n     pub lifetimes_res_map: NodeMap<LifetimeRes>,\n-    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n-    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n-    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n-    /// field from the original parameter 'a to the new parameter 'a1.\n-    pub generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     pub extra_lifetime_params_map: NodeMap<Vec<(Ident, ast::NodeId, LifetimeRes)>>,\n "}, {"sha": "aaa9ae6f32513cc639378f7a704d04e27d25ec46", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -911,11 +911,6 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n     /// Resolutions for lifetimes.\n     lifetimes_res_map: NodeMap<LifetimeRes>,\n-    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n-    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n-    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n-    /// field from the original parameter 'a to the new parameter 'a1.\n-    generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     extra_lifetime_params_map: NodeMap<Vec<(Ident, NodeId, LifetimeRes)>>,\n \n@@ -1278,7 +1273,6 @@ impl<'a> Resolver<'a> {\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n             lifetimes_res_map: Default::default(),\n-            generics_def_id_map: Vec::new(),\n             extra_lifetime_params_map: Default::default(),\n             extern_crate_map: Default::default(),\n             reexport_map: FxHashMap::default(),\n@@ -1445,7 +1439,6 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map,\n             label_res_map: self.label_res_map,\n             lifetimes_res_map: self.lifetimes_res_map,\n-            generics_def_id_map: self.generics_def_id_map,\n             extra_lifetime_params_map: self.extra_lifetime_params_map,\n             next_node_id: self.next_node_id,\n             node_id_to_def_id: self.node_id_to_def_id,\n@@ -1490,7 +1483,6 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map.clone(),\n             label_res_map: self.label_res_map.clone(),\n             lifetimes_res_map: self.lifetimes_res_map.clone(),\n-            generics_def_id_map: self.generics_def_id_map.clone(),\n             extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n             next_node_id: self.next_node_id.clone(),\n             node_id_to_def_id: self.node_id_to_def_id.clone(),"}, {"sha": "311fcaadaa98b3b7bc815f879660f627efc6aaea", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -1812,16 +1812,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             return true;\n                         }\n                     }\n-                    // Notably, we only point to params that are local to the\n-                    // item we're checking, since those are the ones we are able\n-                    // to look in the final `hir::PathSegment` for. Everything else\n-                    // would require a deeper search into the `qpath` than I think\n-                    // is worthwhile.\n-                    if let Some(param_to_point_at) = param_to_point_at\n-                        && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                    {\n-                        return true;\n-                    }\n+                }\n+                // Notably, we only point to params that are local to the\n+                // item we're checking, since those are the ones we are able\n+                // to look in the final `hir::PathSegment` for. Everything else\n+                // would require a deeper search into the `qpath` than I think\n+                // is worthwhile.\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n                 }\n             }\n             hir::ExprKind::MethodCall(segment, receiver, args, ..) => {"}, {"sha": "91cff3217d21bce19ad24ebdd7632d66729a91e5", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -607,15 +607,24 @@ pub fn stdout() -> Stdout {\n     }\n }\n \n+// Flush the data and disable buffering during shutdown\n+// by replacing the line writer by one with zero\n+// buffering capacity.\n pub fn cleanup() {\n-    // Flush the data and disable buffering during shutdown\n-    // by replacing the line writer by one with zero\n-    // buffering capacity.\n-    // We use try_lock() instead of lock(), because someone\n-    // might have leaked a StdoutLock, which would\n-    // otherwise cause a deadlock here.\n-    if let Some(lock) = STDOUT.get().and_then(ReentrantMutex::try_lock) {\n-        *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+    let mut initialized = false;\n+    let stdout = STDOUT.get_or_init(|| {\n+        initialized = true;\n+        ReentrantMutex::new(RefCell::new(LineWriter::with_capacity(0, stdout_raw())))\n+    });\n+\n+    if !initialized {\n+        // The buffer was previously initialized, overwrite it here.\n+        // We use try_lock() instead of lock(), because someone\n+        // might have leaked a StdoutLock, which would\n+        // otherwise cause a deadlock here.\n+        if let Some(lock) = stdout.try_lock() {\n+            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+        }\n     }\n }\n "}, {"sha": "71e33fb9ed86442b0797a3ce52ebf8c794007615", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -104,7 +104,8 @@ impl BorrowedFd<'_> {\n         #[cfg(target_os = \"espidf\")]\n         let cmd = libc::F_DUPFD;\n \n-        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n+        // Avoid using file descriptors below 3 as they are used for stdio\n+        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 3) })?;\n         Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n     }\n "}, {"sha": "0054f3d4182ec12a32ebf6d19f0ea43ea454754f", "filename": "src/test/ui/let-else/let-else-drop-order.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -0,0 +1,270 @@\n+// run-pass\n+// edition:2021\n+// check-run-results\n+//\n+// Drop order tests for let else\n+//\n+// Mostly this ensures two things:\n+// 1. That let and let else temporary drop order is the same.\n+//    This is a specific design request: https://github.com/rust-lang/rust/pull/93628#issuecomment-1047140316\n+// 2. That the else block truly only runs after the\n+//    temporaries have dropped.\n+//\n+// We also print some nice tables for an overview by humans.\n+// Changes in those tables are considered breakages, but the\n+// important properties 1 and 2 are also enforced by the code.\n+// This is important as it's easy to update the stdout file\n+// with a --bless and miss the impact of that change.\n+\n+#![feature(let_else)]\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+struct DropAccountant(Rc<RefCell<Vec<Vec<String>>>>);\n+\n+impl DropAccountant {\n+    fn new() -> Self {\n+        Self(Default::default())\n+    }\n+    fn build_droppy(&self, v: u32) -> Droppy<u32> {\n+        Droppy(self.clone(), v)\n+    }\n+    fn build_droppy_enum_none(&self, _v: u32) -> ((), DroppyEnum<u32>) {\n+        ((), DroppyEnum::None(self.clone()))\n+    }\n+    fn new_list(&self, s: impl ToString) {\n+        self.0.borrow_mut().push(vec![s.to_string()]);\n+    }\n+    fn push(&self, s: impl ToString) {\n+        let s = s.to_string();\n+        let mut accounts = self.0.borrow_mut();\n+        accounts.last_mut().unwrap().push(s);\n+    }\n+    fn print_table(&self) {\n+        println!();\n+\n+        let accounts = self.0.borrow();\n+        let before_last = &accounts[accounts.len() - 2];\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = get_comma_list(before_last);\n+        let last = get_comma_list(last);\n+        const LINES: &[&str] = &[\n+            \"vanilla\",\n+            \"&\",\n+            \"&mut\",\n+            \"move\",\n+            \"fn(this)\",\n+            \"tuple\",\n+            \"array\",\n+            \"ref &\",\n+            \"ref mut &mut\",\n+        ];\n+        let max_len = LINES.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_before = before_last.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_last = last.iter().map(|v| v.len()).max().unwrap();\n+\n+        println!(\n+            \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+            \"construct\", before_last[0], last[0]\n+        );\n+        println!(\"| {:-<max_len$} | {:-<max_len_before$} | {:-<max_len_last$} |\", \"\", \"\", \"\");\n+\n+        for ((l, l_before), l_last) in\n+            LINES.iter().zip(before_last[1..].iter()).zip(last[1..].iter())\n+        {\n+            println!(\n+                \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+                l, l_before, l_last,\n+            );\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_all_equal_to(&self, st: &str) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let last = get_comma_list(last);\n+        for line in last[1..].iter() {\n+            assert_eq!(line.trim(), st.trim());\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_equality_last_two_lists(&self) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = &accounts[accounts.len() - 2];\n+        for (l, b) in last[1..].iter().zip(before_last[1..].iter()) {\n+            if !(l == b || l == \"n/a\" || b == \"n/a\") {\n+                panic!(\"not equal: '{last:?}' != '{before_last:?}'\");\n+            }\n+        }\n+    }\n+}\n+\n+fn get_comma_list(sl: &[String]) -> Vec<String> {\n+    std::iter::once(sl[0].clone())\n+        .chain(sl[1..].chunks(2).map(|c| c.join(\",\")))\n+        .collect::<Vec<String>>()\n+}\n+\n+struct Droppy<T>(DropAccountant, T);\n+\n+impl<T> Drop for Droppy<T> {\n+    fn drop(&mut self) {\n+        self.0.push(\"drop\");\n+    }\n+}\n+\n+#[allow(dead_code)]\n+enum DroppyEnum<T> {\n+    Some(DropAccountant, T),\n+    None(DropAccountant),\n+}\n+\n+impl<T> Drop for DroppyEnum<T> {\n+    fn drop(&mut self) {\n+        match self {\n+            DroppyEnum::Some(acc, _inner) => acc,\n+            DroppyEnum::None(acc) => acc,\n+        }\n+        .push(\"drop\");\n+    }\n+}\n+\n+macro_rules! nestings_with {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        // vanilla:\n+        $construct!($binding, $exp.1);\n+\n+        // &:\n+        $construct!(&$binding, &$exp.1);\n+\n+        // &mut:\n+        $construct!(&mut $binding, &mut ($exp.1));\n+\n+        {\n+            // move:\n+            let w = $exp;\n+            $construct!(\n+                $binding,\n+                {\n+                    let w = w;\n+                    w\n+                }\n+                .1\n+            );\n+        }\n+\n+        // fn(this):\n+        $construct!($binding, std::convert::identity($exp).1);\n+    };\n+}\n+\n+macro_rules! nestings {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        nestings_with!($construct, $binding, $exp);\n+\n+        // tuple:\n+        $construct!(($binding, 77), ($exp.1, 77));\n+\n+        // array:\n+        $construct!([$binding], [$exp.1]);\n+    };\n+}\n+\n+macro_rules! let_else {\n+    ($acc:expr, $v:expr, $binding:pat, $build:ident) => {\n+        let acc = $acc;\n+        let v = $v;\n+\n+        macro_rules! let_else_construct {\n+            ($arg:pat, $exp:expr) => {\n+                loop {\n+                    let $arg = $exp else {\n+                        acc.push(\"else\");\n+                        break;\n+                    };\n+                    acc.push(\"body\");\n+                    break;\n+                }\n+            };\n+        }\n+        nestings!(let_else_construct, $binding, acc.$build(v));\n+        // ref &:\n+        let_else_construct!($binding, &acc.$build(v).1);\n+\n+        // ref mut &mut:\n+        let_else_construct!($binding, &mut acc.$build(v).1);\n+    };\n+}\n+\n+macro_rules! let_ {\n+    ($acc:expr, $binding:tt) => {\n+        let acc = $acc;\n+\n+        macro_rules! let_construct {\n+            ($arg:pat, $exp:expr) => {{\n+                let $arg = $exp;\n+                acc.push(\"body\");\n+            }};\n+        }\n+        let v = 0;\n+        {\n+            nestings_with!(let_construct, $binding, acc.build_droppy(v));\n+        }\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+\n+        // ref &:\n+        let_construct!($binding, &acc.build_droppy(v).1);\n+\n+        // ref mut &mut:\n+        let_construct!($binding, &mut acc.build_droppy(v).1);\n+    };\n+}\n+\n+fn main() {\n+    let acc = DropAccountant::new();\n+\n+    println!(\" --- matching cases ---\");\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _\");\n+    let_!(&acc, _);\n+    acc.new_list(\"let else _\");\n+    let_else!(&acc, 0, _, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _v\");\n+    let_!(&acc, _v);\n+    acc.new_list(\"let else _v\");\n+    let_else!(&acc, 0, _v, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    println!();\n+\n+    println!(\" --- mismatching cases ---\");\n+\n+    acc.new_list(\"let else _ mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _), build_droppy_enum_none);\n+    acc.new_list(\"let else _v mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _v), build_droppy_enum_none);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+}"}, {"sha": "01cf2f73e17c9e466508fa538169d64c510dd6c5", "filename": "src/test/ui/let-else/let-else-drop-order.run.stdout", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -0,0 +1,51 @@\n+ --- matching cases ---\n+\n+| construct    | let _     | let else _ |\n+| ------------ | --------- | ---------- |\n+| vanilla      | drop,body | drop,body  |\n+| &            | body,drop | body,drop  |\n+| &mut         | body,drop | body,drop  |\n+| move         | drop,body | drop,body  |\n+| fn(this)     | drop,body | drop,body  |\n+| tuple        | n/a,n/a   | drop,body  |\n+| array        | n/a,n/a   | drop,body  |\n+| ref &        | body,drop | body,drop  |\n+| ref mut &mut | body,drop | body,drop  |\n+\n+| construct    | let _v    | let else _v |\n+| ------------ | --------- | ----------- |\n+| vanilla      | drop,body | drop,body   |\n+| &            | body,drop | body,drop   |\n+| &mut         | body,drop | body,drop   |\n+| move         | drop,body | drop,body   |\n+| fn(this)     | drop,body | drop,body   |\n+| tuple        | n/a,n/a   | drop,body   |\n+| array        | n/a,n/a   | drop,body   |\n+| ref &        | body,drop | body,drop   |\n+| ref mut &mut | body,drop | body,drop   |\n+\n+ --- mismatching cases ---\n+\n+| construct    | let else _ mismatch | let else _v mismatch |\n+| ------------ | ------------------- | -------------------- |\n+| vanilla      | drop,else           | drop,else            |\n+| &            | drop,else           | drop,else            |\n+| &mut         | drop,else           | drop,else            |\n+| move         | drop,else           | drop,else            |\n+| fn(this)     | drop,else           | drop,else            |\n+| tuple        | drop,else           | drop,else            |\n+| array        | drop,else           | drop,else            |\n+| ref &        | drop,else           | drop,else            |\n+| ref mut &mut | drop,else           | drop,else            |\n+\n+| construct    | let else 0 mismatch | let else 0 mismatch |\n+| ------------ | ------------------- | ------------------- |\n+| vanilla      | drop,else           | drop,else           |\n+| &            | drop,else           | drop,else           |\n+| &mut         | drop,else           | drop,else           |\n+| move         | drop,else           | drop,else           |\n+| fn(this)     | drop,else           | drop,else           |\n+| tuple        | drop,else           | drop,else           |\n+| array        | drop,else           | drop,else           |\n+| ref &        | drop,else           | drop,else           |\n+| ref mut &mut | drop,else           | drop,else           |"}, {"sha": "9a21536f9b12bf39f558bb6ab1a0899916b9a3cd", "filename": "src/test/ui/typeck/point-at-type-param-in-path-expr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.rs?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -0,0 +1,6 @@\n+fn foo<T: std::fmt::Display>() {}\n+\n+fn main() {\n+    let x = foo::<()>;\n+    //~^ ERROR `()` doesn't implement `std::fmt::Display`\n+}"}, {"sha": "1feaa0508bfa74017351da64b6aa00b4fc015377", "filename": "src/test/ui/typeck/point-at-type-param-in-path-expr.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fpoint-at-type-param-in-path-expr.stderr?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/point-at-type-param-in-path-expr.rs:4:19\n+   |\n+LL |     let x = foo::<()>;\n+   |                   ^^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+note: required by a bound in `foo`\n+  --> $DIR/point-at-type-param-in-path-expr.rs:1:11\n+   |\n+LL | fn foo<T: std::fmt::Display>() {}\n+   |           ^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "89edab91fcd701a29107e03d6886b273bcca7122", "filename": "triagebot.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56b27110e7f72ea01312d99f1b1e0577431cbbd0/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56b27110e7f72ea01312d99f1b1e0577431cbbd0/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=56b27110e7f72ea01312d99f1b1e0577431cbbd0", "patch": "@@ -316,9 +316,6 @@ Examples of `T-libs-api` changes:\n * Changing observable runtime behavior of library APIs\n \"\"\"\n \n-[mentions.\"library/proc_macro/src/bridge\"]\n-cc = [\"@rust-lang/wg-rls-2\"]\n-\n [mentions.\"src/librustdoc/clean/types.rs\"]\n cc = [\"@camelid\"]\n "}]}