{"sha": "30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwY2Q0ZDVhY2I3ZGZkNDBjZWEyNjRhOTI2ZDFjODlmMGMzNTIyYzM=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-11T19:41:43Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-11T19:41:43Z"}, "message": "Validate byte string literals", "tree": {"sha": "d71024919de98d74bf1a6bedc8a755c8810f1723", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d71024919de98d74bf1a6bedc8a755c8810f1723"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "html_url": "https://github.com/rust-lang/rust/commit/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c258b4fdb0e421813330c2428985c4537c787582", "url": "https://api.github.com/repos/rust-lang/rust/commits/c258b4fdb0e421813330c2428985c4537c787582", "html_url": "https://github.com/rust-lang/rust/commit/c258b4fdb0e421813330c2428985c4537c787582"}], "stats": {"total": 329, "additions": 305, "deletions": 24}, "files": [{"sha": "bf056131efc4409ffc3880ba1e923f3b5caba1c3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -409,6 +409,43 @@ impl<R: TreeRoot<RaTypes>> ByteNode<R> {\n \n impl<'a> Byte<'a> {}\n \n+// ByteString\n+#[derive(Debug, Clone, Copy,)]\n+pub struct ByteStringNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type ByteString<'a> = ByteStringNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ByteStringNode<R1>> for ByteStringNode<R2> {\n+    fn eq(&self, other: &ByteStringNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ByteStringNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ByteStringNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for ByteString<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BYTE_STRING => Some(ByteString { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> ByteStringNode<R> {\n+    pub fn borrowed(&self) -> ByteString {\n+        ByteStringNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> ByteStringNode {\n+        ByteStringNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> ByteString<'a> {}\n+\n // CallExpr\n #[derive(Debug, Clone, Copy,)]\n pub struct CallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {"}, {"sha": "7077e349223006fb9d3f98d1bf30126a24716412", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -140,6 +140,12 @@ impl<'a> Byte<'a> {\n     }\n }\n \n+impl<'a> ByteString<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n impl<'a> String<'a> {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()"}, {"sha": "53cd2118f3d4478ff9fecee9da5241745165230c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -413,6 +413,7 @@ Grammar(\n         \"BinExpr\": (),\n         \"String\": (),\n         \"Byte\": (),\n+        \"ByteString\": (),\n         \"Char\": (),\n         \"Literal\": (),\n "}, {"sha": "d253c97e7736e3f7f2dd8e10cbb6de680401dbc2", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -1,6 +1,55 @@\n use self::CharComponentKind::*;\n use rowan::{TextRange, TextUnit};\n \n+pub fn parse_byte_string_literal(src: &str) -> ByteStringComponentIterator {\n+    ByteStringComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct ByteStringComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for ByteStringComponentIterator<'a> {\n+    type Item = StringComponent;\n+    fn next(&mut self) -> Option<StringComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == 'b',\n+                \"byte string literal should start with a `b`\"\n+            );\n+\n+            assert!(\n+                self.parser.advance() == '\"',\n+                \"byte string literal should start with a `b`, followed by double quotes\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_string_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\"') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"byte string literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n     StringComponentIterator {\n         parser: Parser::new(src),\n@@ -81,12 +130,12 @@ impl<'a> Iterator for ByteComponentIterator<'a> {\n         if self.parser.pos == 0 {\n             assert!(\n                 self.parser.advance() == 'b',\n-                \"Byte literal should start with a b\"\n+                \"Byte literal should start with a `b`\"\n             );\n \n             assert!(\n                 self.parser.advance() == '\\'',\n-                \"Byte literal should start with a b, followed by a quote\"\n+                \"Byte literal should start with a `b`, followed by a quote\"\n             );\n         }\n "}, {"sha": "7baf3c1d7bfbf0f7651b6ae68c211b6d58c3f7b2", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -20,26 +20,7 @@ pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>)\n         len += 1;\n         let text = &literal_text[component.range];\n         let range = component.range + literal_range.start();\n-\n-        use self::CharComponentKind::*;\n-        match component.kind {\n-            AsciiEscape => validate_byte_escape(text, range, errors),\n-            AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n-            UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n-            CodePoint => {\n-                let c = text.chars().next().expect(\"Code points should be one character long\");\n-\n-                // These bytes must always be escaped\n-                if c == '\\t' || c == '\\r' || c == '\\n' {\n-                    errors.push(SyntaxError::new(UnescapedByte, range));\n-                }\n-\n-                // Only ASCII bytes are allowed\n-                if c > 0x7F as char {\n-                    errors.push(SyntaxError::new(ByteOutOfRange, range));\n-                }\n-            }\n-        }\n+        validate_byte_component(text, component.kind, range, errors);\n     }\n \n     if !components.has_closing_quote {\n@@ -55,6 +36,33 @@ pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>)\n     }\n }\n \n+pub(super) fn validate_byte_component(\n+    text: &str,\n+    kind: CharComponentKind,\n+    range: TextRange,\n+    errors: &mut Vec<SyntaxError>,\n+) {\n+    use self::CharComponentKind::*;\n+    match kind {\n+        AsciiEscape => validate_byte_escape(text, range, errors),\n+        AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n+        UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n+        CodePoint => {\n+            let c = text.chars().next().expect(\"Code points should be one character long\");\n+\n+            // These bytes must always be escaped\n+            if c == '\\t' || c == '\\r' || c == '\\n' {\n+                errors.push(SyntaxError::new(UnescapedByte, range));\n+            }\n+\n+            // Only ASCII bytes are allowed\n+            if c > 0x7F as char {\n+                errors.push(SyntaxError::new(ByteOutOfRange, range));\n+            }\n+        }\n+    }\n+}\n+\n fn validate_byte_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n     if text.len() == 1 {\n         // Escape sequence consists only of leading `\\`\n@@ -141,7 +149,7 @@ mod test {\n     #[test]\n     fn test_valid_byte_escape() {\n         let valid = [\n-            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n+            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\",\n         ];\n         for c in &valid {\n             assert_valid_byte(c);"}, {"sha": "7b830e97cde1945fb42624b8524f096efab807b4", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -0,0 +1,178 @@\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, StringComponentKind},\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+use super::byte;\n+\n+pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_byte_string_literal(literal_text);\n+    for component in &mut components {\n+        let range = component.range + literal_range.start();\n+\n+        match component.kind {\n+            StringComponentKind::Char(kind) => {\n+                // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n+                let text = &literal_text[component.range];\n+                match text {\n+                    \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n+                    _ => byte::validate_byte_component(text, kind, range, errors),\n+                }\n+            }\n+            StringComponentKind::IgnoreNewline => { /* always valid */ }\n+        }\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedString, literal_range));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(r#\"const S: &'static [u8] = b\"{}\";\"#, literal);\n+        println!(\"Source: {}\", src);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..128 {\n+            match byte {\n+                b'\\\"' | b'\\\\' => { /* Ignore string close and backslash */ }\n+                _ => assert_valid_str(&(byte as char).to_string()),\n+            }\n+        }\n+\n+        for byte in 128..=255u8 {\n+            assert_invalid_str(&(byte as char).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [r\"\\'\", r#\"\\\"\"#, r\"\\\\\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let well_formed = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &well_formed {\n+            assert_invalid_str(c);\n+        }\n+\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mixed_invalid() {\n+        assert_invalid_str(\n+            r\"This is the tale of a string\n+with a newline in between, some emoji (\ud83d\udc68\u200d\ud83d\udc68\u200d) here and there,\n+unicode escapes like this: \\u{1FFBB} and weird stuff like\n+this \ufdfd\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_mixed_valid() {\n+        assert_valid_str(\n+            r\"This is the tale of a string\n+with a newline in between, no emoji at all,\n+nor unicode escapes or weird stuff\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_ignore_newline() {\n+        assert_valid_str(\n+            \"Hello \\\n+             World\",\n+        );\n+    }\n+}"}, {"sha": "622b2efdcd74550d0b917547deefae915fa10bae", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -214,7 +214,7 @@ mod test {\n     #[test]\n     fn test_valid_ascii_escape() {\n         let valid = [\n-            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n+            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\",\n         ];\n         for c in &valid {\n             assert_valid_char(c);"}, {"sha": "bdee8120c91cec63c794ee364027559ed52fe60f", "filename": "crates/ra_syntax/src/validation/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cd4d5acb7dfd40cea264a926d1c89f0c3522c3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs?ref=30cd4d5acb7dfd40cea264a926d1c89f0c3522c3", "patch": "@@ -6,6 +6,7 @@ use crate::{\n };\n \n mod byte;\n+mod byte_string;\n mod char;\n mod string;\n \n@@ -14,6 +15,7 @@ pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)\n             .visit::<ast::Byte, _>(self::byte::validate_byte_node)\n+            .visit::<ast::ByteString, _>(self::byte_string::validate_byte_string_node)\n             .visit::<ast::Char, _>(self::char::validate_char_node)\n             .visit::<ast::String, _>(self::string::validate_string_node)\n             .accept(node);"}]}