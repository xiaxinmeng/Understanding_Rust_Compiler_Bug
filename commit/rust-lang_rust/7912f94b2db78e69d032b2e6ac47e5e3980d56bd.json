{"sha": "7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MTJmOTRiMmRiNzhlNjlkMDMyYjJlNmFjNDdlNWUzOTgwZDU2YmQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-10T00:04:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T20:48:07Z"}, "message": "const_eval: Take just one set of substitutions in lookup_const_by_id.", "tree": {"sha": "5923a57a71db66ae251c316257e063158279a93c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5923a57a71db66ae251c316257e063158279a93c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "html_url": "https://github.com/rust-lang/rust/commit/7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eeda543dfd4b471bc88a4fb33bdb0d8d77f7a10", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eeda543dfd4b471bc88a4fb33bdb0d8d77f7a10", "html_url": "https://github.com/rust-lang/rust/commit/5eeda543dfd4b471bc88a4fb33bdb0d8d77f7a10"}], "stats": {"total": 121, "additions": 49, "deletions": 72}, "files": [{"sha": "16e0a334440ff0f3570e2bde57c64eb69aebbe4b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -475,9 +475,9 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(Def::AssociatedConst(did)) |\n-                    Some(Def::Const(did)) => match lookup_const_by_id(self.tcx, did,\n-                                                                    Some(pat.id), None) {\n-                        Some((const_expr, _const_ty)) => {\n+                    Some(Def::Const(did)) => {\n+                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n+                        if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n                                 if let Some(ref mut renaming_map) = self.renaming_map {\n@@ -487,14 +487,13 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n \n                                 new_pat\n                             })\n-                        }\n-                        None => {\n+                        } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n                                 \"statics cannot be referenced in patterns\");\n                             pat\n                         }\n-                    },\n+                    }\n                     _ => noop_fold_pat(pat, self)\n                 }\n             }"}, {"sha": "47b6c49fddb6d69d5b0ad87876aea789d0c8f767", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 25, "deletions": 42, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -19,7 +19,6 @@ use front::map::blocks::FnLikeNode;\n use middle::cstore::{self, CrateStore, InlinedItem};\n use middle::{infer, subst, traits};\n use middle::def::Def;\n-use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n@@ -89,16 +88,13 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n }\n \n /// * `def_id` is the id of the constant.\n-/// * `maybe_ref_id` is the id of the expr referencing the constant.\n-/// * `param_substs` is the monomorphization substitution for the expression.\n+/// * `substs` is the monomorphized substitutions for the expression.\n ///\n-/// `maybe_ref_id` and `param_substs` are optional and are used for\n-/// finding substitutions in associated constants. This generally\n-/// happens in late/trans const evaluation.\n+/// `substs` is optional and is used for associated constants.\n+/// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                         def_id: DefId,\n-                                        maybe_ref_id: Option<ast::NodeId>,\n-                                        param_substs: Option<&'tcx subst::Substs<'tcx>>)\n+                                        substs: Option<subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -111,28 +107,20 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n-                    match maybe_ref_id {\n-                        // If we have a trait item, and we know the expression\n-                        // that's the source of the obligation to resolve it,\n+                    if let Some(substs) = substs {\n+                        // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n-                        Some(ref_id) => {\n-                            let trait_id = tcx.trait_of_item(def_id)\n-                                              .unwrap();\n-                            let mut substs = tcx.node_id_item_substs(ref_id)\n-                                                .substs;\n-                            if let Some(param_substs) = param_substs {\n-                                substs = substs.subst(tcx, param_substs);\n-                            }\n-                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n-                        }\n+                        let trait_id = tcx.trait_of_item(def_id).unwrap();\n+                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                    } else {\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n                         // still return the default if there is one. However,\n                         // it's safer to return `None` than to return some value\n                         // that may differ from what you would get from\n                         // correctly selecting an impl.\n-                        None => None\n+                        None\n                     }\n                 }\n                 _ => None\n@@ -153,7 +141,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             }\n             None => {}\n         }\n-        let mut used_ref_id = false;\n+        let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n@@ -163,21 +151,15 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n-                    used_ref_id = true;\n-                    match maybe_ref_id {\n+                    used_substs = true;\n+                    if let Some(substs) = substs {\n                         // As mentioned in the comments above for in-crate\n                         // constants, we only try to find the expression for\n                         // a trait-associated const if the caller gives us\n-                        // the expression that refers to it.\n-                        Some(ref_id) => {\n-                            let mut substs = tcx.node_id_item_substs(ref_id)\n-                                                .substs;\n-                            if let Some(param_substs) = param_substs {\n-                                substs = substs.subst(tcx, param_substs);\n-                            }\n-                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n-                        }\n-                        None => None\n+                        // the substitutions for the reference to it.\n+                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                    } else {\n+                        None\n                     }\n                 }\n                 _ => None\n@@ -190,10 +172,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             _ => None\n         };\n-        // If we used the reference expression, particularly to choose an impl\n+        // If we used the substitutions, particularly to choose an impl\n         // of a trait-associated const, don't cache that, because the next\n         // lookup with the same def_id may yield a different result.\n-        if !used_ref_id {\n+        if !used_substs {\n             tcx.extern_const_statics\n                .borrow_mut()\n                .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n@@ -389,7 +371,8 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                     PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n-                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n+                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, span);\n                 },\n                 _ => unreachable!(),\n@@ -788,12 +771,12 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           match opt_def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  let maybe_ref_id = if let ExprTypeChecked = ty_hint {\n-                      Some(e.id)\n+                  let substs = if let ExprTypeChecked = ty_hint {\n+                      Some(tcx.node_id_item_substs(e.id).substs)\n                   } else {\n                       None\n                   };\n-                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, maybe_ref_id, None) {\n+                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n                       let item_hint = match ty {\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n@@ -1077,7 +1060,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.name) {\n-                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None, None),\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n                         Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))"}, {"sha": "4d87d926e40551a5fa77ccc224b70dbd4b21e346", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -672,7 +672,8 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         },\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n-            if let Some(e) = const_eval::lookup_const_by_id(cx.tcx, def_id, Some(expr.id), None) {\n+            let substs = Some(cx.tcx.node_id_item_substs(expr.id).substs);\n+            if let Some((e, _)) = const_eval::lookup_const_by_id(cx.tcx, def_id, substs) {\n                 // FIXME ConstVal can't be yet used with adjustments, as they would be lost.\n                 if !cx.tcx.tables.borrow().adjustments.contains_key(&e.id) {\n                     if let Some(v) = cx.try_const_eval_literal(e) {"}, {"sha": "a98737783741710a32c8ce253e8e2e1d28131602", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -86,9 +86,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n-                    Def::Const(def_id) | Def::AssociatedConst(def_id) =>\n-                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n-                                                             Some(pat.id), None) {\n+                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                        let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n+                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);\n@@ -99,7 +99,8 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                     pat.span,\n                                     &format!(\"cannot eval constant: {:?}\", def_id))\n                             }\n-                        },\n+                        }\n+                    }\n                     _ =>\n                         self.cx.tcx.sess.span_bug(\n                             pat.span,"}, {"sha": "c964179d4076a2a87d707e2faa4b518b79b47f4b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -610,9 +610,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n                 Some(Def::Const(did)) |\n                 Some(Def::AssociatedConst(did)) => {\n-                    if let Some((expr, _ty)) = const_eval::lookup_const_by_id(v.tcx, did,\n-                                                                       Some(e.id),\n-                                                                       None) {\n+                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    if let Some((expr, _)) = const_eval::lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }"}, {"sha": "82cd6aace0a35063c0825baf34c05c6f0cd96cb4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -13,12 +13,11 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n-use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstEvalErr};\n use middle::def::Def;\n use middle::def_id::DefId;\n use rustc::front::map as hir_map;\n-use trans::{abi, adt, closure, debuginfo, expr, inline, machine};\n+use trans::{abi, adt, closure, debuginfo, expr, machine};\n use trans::base::{self, exported_name, imported_name, push_ctxt};\n use trans::callee::Callee;\n use trans::collector::{self, TransItem};\n@@ -225,14 +224,11 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 ref_expr: &hir::Expr,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n-    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n-\n-    if def_id.krate != LOCAL_CRATE {\n-        ccx.sess().span_bug(ref_expr.span,\n-                            \"cross crate constant could not be inlined\");\n-    }\n-\n-    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id), Some(param_substs)) {\n+    let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n+    let substs = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                  param_substs,\n+                                                  &substs.erase_regions());\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")"}, {"sha": "d4934718d75ed7f671e2843319bebaa208255f4b", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -19,7 +19,6 @@ use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_in\n use trans::consts;\n use trans::datum;\n use trans::expr;\n-use trans::inline;\n use trans::type_of;\n use trans::type_::Type;\n \n@@ -114,9 +113,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     };\n                 }\n \n-                let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n+                let substs = Some(bcx.monomorphize(substs));\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, substs)\n                             .expect(\"def was const, but lookup_const_by_id failed\").0;\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR."}, {"sha": "49091a6c2bcfc9ea87d1686a3bcc6bc2791240ef", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7912f94b2db78e69d032b2e6ac47e5e3980d56bd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7912f94b2db78e69d032b2e6ac47e5e3980d56bd", "patch": "@@ -336,7 +336,7 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(const_eval::lookup_const_by_id(tcx, did, None, None)\n+                    Some(const_eval::lookup_const_by_id(tcx, did, None)\n                          .unwrap().0.span.to_src(cx))\n                 } else {\n                     None\n@@ -479,7 +479,7 @@ fn build_const(cx: &DocContext, tcx: &TyCtxt,\n     use rustc::middle::const_eval;\n     use rustc_front::print::pprust;\n \n-    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None, None).unwrap_or_else(|| {\n+    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}]}