{"sha": "ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOWUwZmM5NGY0YTc0NTk0ZTdiMzQyZDEyOGIzNzEzYjUzZWYwZDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-10-05T00:05:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-10-05T00:05:27Z"}, "message": "Revert \"Get rid of 'overwrite' destination kind\"\n\nThis reverts commit 6e652588bfb3edea298026f56648057677b0fa3f.", "tree": {"sha": "2a18b619fdfc18d7b6d95926a5bc086f7f5ecdb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a18b619fdfc18d7b6d95926a5bc086f7f5ecdb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "html_url": "https://github.com/rust-lang/rust/commit/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e407aaa917dbd646f80aaff2457942481877c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e407aaa917dbd646f80aaff2457942481877c8", "html_url": "https://github.com/rust-lang/rust/commit/11e407aaa917dbd646f80aaff2457942481877c8"}], "stats": {"total": 164, "additions": 102, "deletions": 62}, "files": [{"sha": "09b0a8a77f225b98d3366f8a872420f558b8fbcd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 82, "deletions": 56, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "patch": "@@ -2112,7 +2112,6 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                              ty_to_str(tcx, t));\n }\n \n-// FIXME[DPS] rename to store_temp_expr\n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                     src: lval_result, t: ty::t) -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n@@ -2214,7 +2213,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n             let llety = T_ptr(type_of(ccx, e_sp, e_ty));\n             body = PointerCast(bcx, body, llety);\n         }\n-        bcx = trans_expr_save_in(bcx, e, body);\n+        bcx = trans_expr_save_in(bcx, e, body, INIT);\n         revoke_clean(bcx, box);\n         ret store_in_dest(bcx, box, dest);\n       }\n@@ -2256,7 +2255,8 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n       }\n     };\n-    fill_fn_pair(bcx, get_dest_addr(dest), llfn, env);\n+    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n+    fill_fn_pair(bcx, addr, llfn, env);\n     ret bcx;\n }\n \n@@ -2357,18 +2357,19 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n       }\n       _ { }\n     }\n-    let {bcx, val: rhs_val} = trans_expr(lhs_res.bcx, src);\n+    let rhs_res = trans_expr(lhs_res.bcx, src);\n     if ty::type_is_sequence(tcx, t) {\n         alt op {\n           ast::add. {\n-            ret tvec::trans_append(bcx, t, lhs_res.val, rhs_val);\n+            ret tvec::trans_append(rhs_res.bcx, t, lhs_res.val,\n+                                   rhs_res.val);\n           }\n           _ { }\n         }\n     }\n-    \n-    ret trans_eager_binop(bcx, op, Load(bcx, lhs_res.val), t, rhs_val, t,\n-                          save_in(lhs_res.val));\n+    let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n+    ret trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t,\n+                          overwrite(lhs_res.val, t));\n }\n \n fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n@@ -2484,6 +2485,7 @@ tag dest {\n     by_val(@mutable ValueRef);\n     by_ref(@mutable ValueRef);\n     save_in(ValueRef);\n+    overwrite(ValueRef, ty::t);\n     ignore;\n }\n \n@@ -2536,12 +2538,19 @@ fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n       ignore. {}\n       by_val(cell) { *cell = val; }\n       save_in(addr) { Store(bcx, val, addr); }\n+      overwrite(addr, tp) {\n+        bcx = drop_ty(bcx, addr, tp);\n+        Store(bcx, val, addr);\n+      }\n     }\n     ret bcx;\n }\n \n-fn get_dest_addr(dest: dest) -> ValueRef {\n-    alt dest { save_in(a) { a } }\n+fn get_dest_addr(bcx: @block_ctxt, dest: dest) -> result {\n+    alt dest {\n+      save_in(a) { rslt(bcx, a) }\n+      overwrite(a, t) { rslt(drop_ty(bcx, a, t), a) }\n+    }\n }\n \n // Wrapper through which legacy non-DPS code can use DPS functions\n@@ -2724,7 +2733,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         bcx = bound.bcx;\n         alt bv {\n           env_expr(e) {\n-            bcx = trans_expr_save_in(bcx, e, bound.val);\n+            bcx = trans_expr_save_in(bcx, e, bound.val, INIT);\n             add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n             temp_cleanups += [bound.val];\n           }\n@@ -3689,7 +3698,8 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n         // FIXME[DPS] factor this out\n-        ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n+        let {bcx, val: addr} = get_dest_addr(bcx, dest);\n+        ret memmove_ty(bcx, addr, lv.val, pair_ty);\n     }\n     let closure = alt f_res.env {\n       null_env. { none }\n@@ -3726,7 +3736,8 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                          closure.ptrty, ty_param_count, target_res);\n \n     // Fill the function pair\n-    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, closure.ptr);\n+    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n+    fill_fn_pair(bcx, addr, llthunk.val, closure.ptr);\n     ret bcx;\n }\n \n@@ -3834,7 +3845,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n         } else { alloca(cx, llretty) }\n       }\n       save_in(dst) { dst }\n-      by_val(_) { alloca(cx, llretty) }\n+      overwrite(_, _) | by_val(_) { alloca(cx, llretty) }\n       by_ref(_) { dest_ref = true; alloca(cx, T_ptr(llretty)) }\n     };\n     // FIXME[DSP] does this always hold?\n@@ -3959,6 +3970,10 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         }\n       }\n       save_in(_) { } // Already saved by callee\n+      overwrite(a, t) {\n+        bcx = drop_ty(bcx, a, t);\n+        bcx = memmove_ty(bcx, a, llretslot, ret_ty);\n+      }\n       by_ref(cell) | by_val(cell) {\n         *cell = Load(bcx, llretslot);\n       }\n@@ -4152,38 +4167,55 @@ fn trans_landing_pad(bcx: @block_ctxt,\n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n-    let addr = alt dest {\n+    let (addr, overwrite) = alt dest {\n       ignore. {\n         for ex in elts { bcx = trans_expr_dps(bcx, ex, ignore); }\n         ret bcx;\n       }\n-      save_in(pos) { pos }\n+      save_in(pos) { (pos, none) }\n+      overwrite(pos, _) {\n+        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n+        (scratch, some(pos))\n+      }\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n         let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n-        bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n+        bcx = trans_expr_save_in(dst.bcx, e, dst.val, INIT);\n         add_clean_temp_mem(bcx, dst.val, e_ty);\n         temp_cleanups += [dst.val];\n         i += 1;\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    alt overwrite {\n+      some(pos) {\n+        bcx = drop_ty(bcx, pos, t);\n+        bcx = memmove_ty(bcx, pos, addr, t);\n+      }\n+      none. {}\n+    }\n     ret bcx;\n }\n \n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option::t<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n-    let addr = alt dest {\n+    let (addr, overwrite) = alt dest {\n       ignore. {\n         for fld in fields {\n             bcx = trans_expr_dps(bcx, fld.node.expr, ignore);\n         }\n         ret bcx;\n       }\n-      save_in(pos) { pos }\n+      save_in(pos) { (pos, none) }\n+      // The expressions that populate the fields might still use the old\n+      // record, so we build the new on in a scratch area\n+      overwrite(pos, _) {\n+        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n+        (scratch, some(pos))\n+      }\n     };\n \n     let base_val = alt base {\n@@ -4202,7 +4234,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         bcx = dst.bcx;\n         alt vec::find({|f| str::eq(f.node.ident, tf.ident)}, fields) {\n           some(f) {\n-            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val);\n+            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val, INIT);\n           }\n           none. {\n             let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n@@ -4217,6 +4249,13 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    alt overwrite {\n+      some(pos) {\n+        bcx = drop_ty(bcx, pos, t);\n+        bcx = memmove_ty(bcx, pos, addr, t);\n+      }\n+      none. {}\n+    }\n     ret bcx;\n }\n \n@@ -4235,37 +4274,19 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     }\n }\n \n-fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n-    -> @block_ctxt {\n+fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef,\n+                      kind: copy_action) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n     let dst = if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n         ignore\n-    } else { save_in(dest) };\n-    ret trans_expr_dps(bcx, e, dst);\n-}\n-\n-fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n-    if expr_is_lval(bcx_tcx(bcx), e) {\n-        ret trans_lval(bcx, e);\n+    } else if kind == INIT {\n+        save_in(dest)\n     } else {\n-        let tcx = bcx_tcx(bcx);\n-        let ty = ty::expr_ty(tcx, e);\n-        if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n-            bcx = trans_expr_dps(bcx, e, ignore);\n-            ret {bcx: bcx, val: C_nil(), is_mem: false};\n-        } else if type_is_immediate(bcx_ccx(bcx), ty) {\n-            let cell = empty_dest_cell();\n-            bcx = trans_expr_dps(bcx, e, by_val(cell));\n-            ret {bcx: bcx, val: *cell, is_mem: false};\n-        } else {\n-            let {bcx, val: scratch} = alloc_ty(bcx, ty);\n-            bcx = trans_expr_dps(bcx, e, save_in(scratch));\n-            ret {bcx: bcx, val: scratch, is_mem: false};\n-        }\n-    }\n+        overwrite(dest, t)\n+    };\n+    ret trans_expr_dps(bcx, e, dst);\n }\n \n-// FIXME[DPS] supersede by trans_temp_expr, get rid of by_ref dests\n fn trans_expr_by_ref(bcx: @block_ctxt, e: @ast::expr) -> result {\n     let cell = empty_dest_cell();\n     bcx = trans_expr_dps(bcx, e, by_ref(cell));\n@@ -4409,20 +4430,22 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       }\n       ast::expr_assign(dst, src) {\n         assert dest == ignore;\n-        let src_r = trans_temp_expr(bcx, src);\n-        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n+        let {bcx, val: lhs_addr, is_mem} = trans_lval(bcx, dst);\n         assert is_mem;\n-        ret move_val_if_temp(bcx, DROP_EXISTING, addr, src_r,\n-                             ty::expr_ty(bcx_tcx(bcx), src));\n+        ret trans_expr_save_in(bcx, src, lhs_addr, DROP_EXISTING);\n       }\n       ast::expr_move(dst, src) {\n-        // FIXME: calculate copy init-ness in typestate.\n         assert dest == ignore;\n-        let src_r = trans_temp_expr(bcx, src);\n-        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n+        let {bcx, val: addr, is_mem} = trans_lval(bcx, dst);\n         assert is_mem;\n-        ret move_val(bcx, DROP_EXISTING, addr, src_r,\n-                     ty::expr_ty(bcx_tcx(bcx), src));\n+        // FIXME: calculate copy init-ness in typestate.\n+        if expr_is_lval(tcx, src) {\n+            ret trans_expr_save_in(bcx, src, addr, DROP_EXISTING);\n+        } else {\n+            let srclv = trans_lval(bcx, src);\n+            let t = ty::expr_ty(tcx, src);\n+            ret move_val(srclv.bcx, DROP_EXISTING, addr, srclv, t);\n+        }\n       }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n@@ -4469,6 +4492,9 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         *cell = val;\n       }\n       save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n+      overwrite(loc, _) {\n+        bcx = move_val_if_temp(bcx, DROP_EXISTING, loc, lv, ty);\n+      }\n       ignore. {}\n     }\n     ret bcx;\n@@ -4720,7 +4746,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n             Store(cx, val, bcx.fcx.llretptr);\n             bcx = cx;\n         } else {\n-            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr);\n+            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr, INIT);\n         }\n       }\n       _ {}\n@@ -4758,7 +4784,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       some(init) {\n         if init.op == ast::init_assign ||\n            !expr_is_lval(bcx_tcx(bcx), init.expr) {\n-            bcx = trans_expr_save_in(bcx, init.expr, llptr);\n+            bcx = trans_expr_save_in(bcx, init.expr, llptr, INIT);\n         } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);\n             bcx = move_val(sub.bcx, INIT, llptr, sub, ty);"}, {"sha": "0e4b529282937762fada100008f3360af593046e", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "patch": "@@ -378,7 +378,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         revoke_clean(bcx, box);\n         box = PointerCast(bcx, box, llbox_ty);\n     }\n-    let pair = trans::get_dest_addr(dest);\n+    let {bcx, val: pair} = trans::get_dest_addr(bcx, dest);\n     let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     Store(bcx, vtbl, pair_vtbl);\n     let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);"}, {"sha": "cf5b3a8504e1a37c3710804881b4859e8af89998", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "patch": "@@ -29,7 +29,7 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n     check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = trans::trans_expr_save_in(bcx, contents, llptr);\n+    bcx = trans::trans_expr_save_in(bcx, contents, llptr, INIT);\n     revoke_clean(bcx, llptr);\n     ret trans::store_in_dest(bcx, llptr, dest);\n }"}, {"sha": "2439505242b49a18d726ac8357c6fad52bb57dc8", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9e0fc94f4a74594e7b342d128b3713b53ef0d7/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=ce9e0fc94f4a74594e7b342d128b3713b53ef0d7", "patch": "@@ -124,13 +124,17 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n         } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n-        bcx = trans::trans_expr_save_in(bcx, e, lleltptr);\n+        bcx = trans::trans_expr_save_in(bcx, e, lleltptr, INIT);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n     for clean in temp_cleanups { revoke_clean(bcx, clean); }\n-    Store(bcx, vptr, trans::get_dest_addr(dest));\n+    let vptrptr = alt dest {\n+      trans::save_in(a) { a }\n+      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n+    };\n+    Store(bcx, vptr, vptrptr);\n     ret bcx;\n }\n \n@@ -143,7 +147,11 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     let bcx =\n         call_memmove(bcx, get_dataptr_simple(bcx, sptr, T_i8()), llcstr,\n                      C_uint(veclen)).bcx;\n-    Store(bcx, sptr, trans::get_dest_addr(dest));\n+    let sptrptr = alt dest {\n+      trans::save_in(a) { a }\n+      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n+    };\n+    Store(bcx, sptr, sptrptr);\n     ret bcx;\n }\n \n@@ -258,7 +266,13 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n     bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n-    Store(bcx, new_vec_ptr, trans::get_dest_addr(dest));\n+    alt dest {\n+      trans::save_in(a) { Store(bcx, new_vec_ptr, a); }\n+      trans::overwrite(a, t) {\n+        bcx = trans::drop_ty(bcx, a, t);\n+        Store(bcx, new_vec_ptr, a);\n+      }\n+    }\n     ret bcx;\n }\n "}]}