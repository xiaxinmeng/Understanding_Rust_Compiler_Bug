{"sha": "f110c5e6f51eea87e37503819addbd1bd054416a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTBjNWU2ZjUxZWVhODdlMzc1MDM4MTlhZGRiZDFiZDA1NDQxNmE=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-12T03:09:36Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-08T15:46:28Z"}, "message": "Move rc_buffer to its own module", "tree": {"sha": "e5251d63e3c83f1775084c08ab9959810a1d0472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5251d63e3c83f1775084c08ab9959810a1d0472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f110c5e6f51eea87e37503819addbd1bd054416a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f110c5e6f51eea87e37503819addbd1bd054416a", "html_url": "https://github.com/rust-lang/rust/commit/f110c5e6f51eea87e37503819addbd1bd054416a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f110c5e6f51eea87e37503819addbd1bd054416a/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "url": "https://api.github.com/repos/rust-lang/rust/commits/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "html_url": "https://github.com/rust-lang/rust/commit/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20"}], "stats": {"total": 194, "additions": 102, "deletions": 92}, "files": [{"sha": "6c6e204257f626032365a93d651718ddd44dc516", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 8, "deletions": 92, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f110c5e6f51eea87e37503819addbd1bd054416a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110c5e6f51eea87e37503819addbd1bd054416a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f110c5e6f51eea87e37503819addbd1bd054416a", "patch": "@@ -1,6 +1,7 @@\n #![allow(rustc::default_hash_types)]\n \n mod box_vec;\n+mod rc_buffer;\n mod redundant_allocation;\n mod utils;\n \n@@ -36,11 +37,11 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, get_qpath_generic_tys, higher, in_constant, indent_of, int_bits,\n-    is_hir_ty_cfg_dependant, is_ty_param_diagnostic_item, is_type_diagnostic_item, last_path_segment, match_def_path,\n-    match_path, meets_msrv, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline,\n-    sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, unsext,\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n+    is_ty_param_diagnostic_item, is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv,\n+    method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -291,18 +292,6 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n }\n \n-fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n-        Some(\"str\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n-        Some(\"std::ffi::OsStr\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n-        Some(\"std::path::Path\")\n-    } else {\n-        None\n-    }\n-}\n-\n impl Types {\n     pub fn new(vec_box_size_threshold: u64) -> Self {\n         Self { vec_box_size_threshold }\n@@ -335,81 +324,8 @@ impl Types {\n                 if let Some(def_id) = res.opt_def_id() {\n                     box_vec::check(cx, hir_ty, qpath, def_id);\n                     redundant_allocation::check(cx, hir_ty, qpath, def_id);\n-                    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Rc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Arc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Arc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n+                    rc_buffer::check(cx, hir_ty, qpath, def_id);\n+                    if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n                         if_chain! {\n                             // Get the _ part of Vec<_>\n                             if let Some(ref last) = last_path_segment(qpath).args;"}, {"sha": "11e25c8bdcb0d11c08b564c7408a46fe12c5d88c", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f110c5e6f51eea87e37503819addbd1bd054416a/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110c5e6f51eea87e37503819addbd1bd054416a/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=f110c5e6f51eea87e37503819addbd1bd054416a", "patch": "@@ -0,0 +1,94 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, snippet_with_applicability, span_lint_and_sugg,\n+};\n+\n+use super::RC_BUFFER;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) {\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Rc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Rc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Arc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Arc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n+    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n+        Some(\"str\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n+        Some(\"std::ffi::OsStr\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n+        Some(\"std::path::Path\")\n+    } else {\n+        None\n+    }\n+}"}]}