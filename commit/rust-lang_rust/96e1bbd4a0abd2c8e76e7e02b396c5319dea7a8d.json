{"sha": "96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZTFiYmQ0YTBhYmQyYzhlNzZlN2UwMmIzOTZjNTMxOWRlYTdhOGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T23:26:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T23:28:15Z"}, "message": "rustc: Add node IDs to AST types so we can associate them with region environments", "tree": {"sha": "c3e9d89041687caeb4f0fd337a9e62ca0e774003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3e9d89041687caeb4f0fd337a9e62ca0e774003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "html_url": "https://github.com/rust-lang/rust/commit/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "772028acdb229d1aaa5ac9ad670b276a218469a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/772028acdb229d1aaa5ac9ad670b276a218469a8", "html_url": "https://github.com/rust-lang/rust/commit/772028acdb229d1aaa5ac9ad670b276a218469a8"}], "stats": {"total": 109, "additions": 75, "deletions": 34}, "files": [{"sha": "ecc4f678fba7e94414d43530ea9ca68622be6b9a", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -254,11 +254,15 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n                  types: []});\n \n     let test_desc_ty: ast::ty =\n-        nospan(ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()));\n+        {id: cx.sess.next_node_id(),\n+         node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n+         span: dummy_sp()};\n \n     let vec_mt: ast::mt = {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n-    ret @nospan(ast::ty_vec(vec_mt));\n+    ret @{id: cx.sess.next_node_id(),\n+          node: ast::ty_vec(vec_mt),\n+          span: dummy_sp()};\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n@@ -346,7 +350,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n     let wrapper_decl: ast::fn_decl = {\n         inputs: [],\n-        output: @nospan(ast::ty_nil),\n+        output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n         purity: ast::impure_fn,\n         cf: ast::return_val,\n         constraints: []\n@@ -377,17 +381,23 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n     let str_pt = @nospan({global: false, idents: [\"str\"], types: []});\n-    let str_ty = @nospan(ast::ty_path(str_pt, cx.sess.next_node_id()));\n+    let str_ty = @{id: cx.sess.next_node_id(),\n+                   node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n+                   span: dummy_sp()};\n     let args_mt: ast::mt = {ty: str_ty, mutbl: ast::m_imm};\n-    let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n+    let args_ty: ast::ty = {id: cx.sess.next_node_id(),\n+                            node: ast::ty_vec(args_mt),\n+                            span: dummy_sp()};\n \n     let args_arg: ast::arg =\n         {mode: ast::expl(ast::by_val),\n          ty: @args_ty,\n          ident: \"args\",\n          id: cx.sess.next_node_id()};\n \n-    let ret_ty = nospan(ast::ty_nil);\n+    let ret_ty = {id: cx.sess.next_node_id(),\n+                  node: ast::ty_nil,\n+                  span: dummy_sp()};\n \n     let decl: ast::fn_decl =\n         {inputs: [args_arg],"}, {"sha": "7e7915262babc1ebca1a867a616709b9feaa2233", "filename": "src/rustc/metadata/astencode_gen.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode_gen.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -3463,12 +3463,15 @@ fn serialize_31<S: std::serialization::serializer>(s: S,\n /*syntax::ast::ty*/\n fn serialize_30<S: std::serialization::serializer>(s: S, v: syntax::ast::ty) {\n \n-    s.emit_rec(/*syntax::ast::ty_*//*syntax::codemap::span*/\n+    s.emit_rec(/*syntax::ast::node_id*//*syntax::ast::ty_*/\n+               /*syntax::codemap::span*/\n                {||\n                    {\n-                       s.emit_rec_field(\"node\", 0u,\n+                       s.emit_rec_field(\"id\", 0u,\n+                                        {|| serialize_27(s, v.id) });\n+                       s.emit_rec_field(\"node\", 1u,\n                                         {|| serialize_31(s, v.node) });\n-                       s.emit_rec_field(\"span\", 1u,\n+                       s.emit_rec_field(\"span\", 2u,\n                                         {|| serialize_19(s, v.span) })\n                    }\n                });\n@@ -7325,15 +7328,18 @@ fn deserialize_30<S: std::serialization::deserializer>(s: S) ->\n     s.read_rec(\n \n \n+               /*syntax::ast::node_id*/\n+\n                /*syntax::ast::ty_*/\n \n                /*syntax::codemap::span*/\n \n                {||\n-                   {node:\n-                        s.read_rec_field(\"node\", 0u, {|| deserialize_31(s) }),\n+                   {id: s.read_rec_field(\"id\", 0u, {|| deserialize_27(s) }),\n+                    node:\n+                        s.read_rec_field(\"node\", 1u, {|| deserialize_31(s) }),\n                     span:\n-                        s.read_rec_field(\"span\", 1u,\n+                        s.read_rec_field(\"span\", 2u,\n                                          {|| deserialize_19(s) }),}\n                })\n "}, {"sha": "b975c4396d11a0052c341818a12d071cfe71084d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -4419,7 +4419,8 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n               node: ast::pat_ident(rslt_path, none),\n               span: ctor.node.body.span};\n         // Set up obj's type\n-        let rslt_ast_ty : @ast::ty = @{node: ast::ty_infer,\n+        let rslt_ast_ty : @ast::ty = @{id: ccx.sess.next_node_id(),\n+                                       node: ast::ty_infer,\n                                        span: ctor.node.body.span};\n         // kludgy\n         let ty_args = [], i = 0u;"}, {"sha": "46e317992320401ca3fe6bc78baeb2ad2758c3b2", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -334,7 +334,7 @@ enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-type ty = spanned<ty_>;\n+type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n enum prim_ty {"}, {"sha": "f24f339590d31cc009244fe5a6a706afc87e6072", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -699,7 +699,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     }\n     fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n         let (n, s) = afp.fold_ty(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+        ret @{id: x.id, node: n, span: afp.new_span(s)};\n     }\n     fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n        @ast::constr {"}, {"sha": "1e60ef1fb8adacafcb470b8b1cd3dfc525408f47", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "patch": "@@ -385,19 +385,24 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n         expect(p, token::LT);\n     } else if !colons_before_params && p.token == token::LT {\n         p.bump();\n-    } else { ret @spanned(lo, p.last_span.hi, orig_t); }\n+    } else {\n+        ret @{id: p.get_id(),\n+              node: orig_t,\n+              span: ast_util::mk_sp(lo, p.last_span.hi)};\n+    }\n \n     // If we're here, we have explicit type parameter instantiation.\n     let seq = parse_seq_to_gt(some(token::COMMA), {|p| parse_ty(p, false)},\n                               p);\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n-        ret @spanned(lo, p.last_span.hi,\n-                     ast::ty_path(@spanned(lo, p.last_span.hi,\n-                                           {global: pth.node.global,\n-                                            idents: pth.node.idents,\n-                                            types: seq}), ann));\n+        ret @{id: p.get_id(),\n+              node: ast::ty_path(@spanned(lo, p.last_span.hi,\n+                                          {global: pth.node.global,\n+                                           idents: pth.node.idents,\n+                                           types: seq}), ann),\n+              span: ast_util::mk_sp(lo, p.last_span.hi)};\n       }\n       _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n     }\n@@ -407,11 +412,17 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.span.lo;\n         if eat(p, token::NOT) {\n-            (ast::noreturn, @spanned(lo, p.last_span.hi, ast::ty_bot))\n-        } else { (ast::return_val, parse_ty(p, false)) }\n+            (ast::noreturn, @{id: p.get_id(),\n+                              node: ast::ty_bot,\n+                              span: ast_util::mk_sp(lo, p.last_span.hi)})\n+        } else {\n+            (ast::return_val, parse_ty(p, false))\n+        }\n     } else {\n         let pos = p.span.lo;\n-        (ast::return_val, @spanned(pos, pos, ast::ty_nil))\n+        (ast::return_val, @{id: p.get_id(),\n+                            node: ast::ty_nil,\n+                            span: ast_util::mk_sp(pos, pos)})\n     }\n }\n \n@@ -435,8 +446,11 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     let lo = p.span.lo;\n \n     alt have_dollar(p) {\n-      some(e) {ret @spanned(lo, p.span.hi,\n-                            ast::ty_mac(spanned(lo, p.span.hi, e)))}\n+      some(e) {\n+        ret @{id: p.get_id(),\n+              node: ast::ty_mac(spanned(lo, p.span.hi, e)),\n+              span: ast_util::mk_sp(lo, p.span.hi)};\n+      }\n       none {}\n     }\n \n@@ -475,7 +489,10 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         let t = ast::ty_rec(elems.node);\n         if p.token == token::COLON {\n             p.bump();\n-            ast::ty_constr(@spanned(lo, hi, t), parse_type_constraints(p))\n+            ast::ty_constr(@{id: p.get_id(),\n+                             node: t,\n+                             span: ast_util::mk_sp(lo, hi)},\n+                           parse_type_constraints(p))\n         } else { t }\n     } else if p.token == token::LBRACKET {\n         expect(p, token::LBRACKET);\n@@ -534,7 +551,9 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     let t = if eat(p, token::COLON) {\n                 parse_ty(p, false)\n             } else {\n-                @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n+                @{id: p.get_id(),\n+                  node: ast::ty_infer,\n+                  span: ast_util::mk_sp(p.span.lo, p.span.hi)}\n             };\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n@@ -1606,7 +1625,9 @@ fn parse_local(p: parser, is_mutbl: bool,\n                allow_init: bool) -> @ast::local {\n     let lo = p.span.lo;\n     let pat = parse_pat(p);\n-    let ty = @spanned(lo, lo, ast::ty_infer);\n+    let ty = @{id: p.get_id(),\n+               node: ast::ty_infer,\n+               span: ast_util::mk_sp(lo, lo)};\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.last_span.hi,\n@@ -1882,7 +1903,7 @@ fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n     let output = if eat(p, token::RARROW) {\n                      parse_ty(p, false)\n                  } else {\n-                     @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n+                     @{id: p.get_id(), node: ast::ty_infer, span: p.span}\n                  };\n     ret {inputs: inputs,\n          output: output,\n@@ -1957,7 +1978,7 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n-        @{node: ast::ty_path(pt, p.get_id()), span: pt.span}\n+        @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n     let (ident, tps) = if !is_word(p, \"of\") {\n         if p.token == token::LT { (none, parse_ty_params(p)) }\n@@ -1996,7 +2017,9 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         {inputs:\n              [{mode: ast::expl(ast::by_ref), ty: t,\n                ident: arg_ident, id: p.get_id()}],\n-         output: @spanned(lo, lo, ast::ty_nil),\n+         output: @{id: p.get_id(),\n+                   node: ast::ty_nil,\n+                   span: ast_util::mk_sp(lo, lo)},\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n          constraints: []};\n@@ -2066,8 +2089,9 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n         // Can ctors have attrs?\n             // result type is always the type of the class\n         let decl_ = parse_fn_decl(p, ast::impure_fn);\n-        let decl = {output: @{node: ast::ty_path(class_name, p.get_id()),\n-                                  span: decl_.output.span}\n+        let decl = {output: @{id: p.get_id(),\n+                              node: ast::ty_path(class_name, p.get_id()),\n+                              span: decl_.output.span}\n                     with decl_};\n         let body = parse_block(p);\n         ret ctor_decl(decl, body, ast_util::mk_sp(lo, p.last_span.hi));"}]}