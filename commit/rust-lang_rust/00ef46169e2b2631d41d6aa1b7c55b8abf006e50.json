{"sha": "00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZWY0NjE2OWUyYjI2MzFkNDFkNmFhMWI3YzU1YjhhYmYwMDZlNTA=", "commit": {"author": {"name": "Tyler Ruckinger", "email": "t.ruckinger@gmail.com", "date": "2020-06-26T04:37:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-26T04:37:12Z"}, "message": "Merge pull request #2 from rust-lang/master\n\nupdate master", "tree": {"sha": "de82ec4b5eefbef6f58767a7ac5c823fbf8776be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de82ec4b5eefbef6f58767a7ac5c823fbf8776be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9Xt4CRBK7hj4Ov3rIwAAdHIIAINAkbrRg+9yFizoHy16HSKj\niBfdJP3n2z2tWD6IQEmjQAKHA2/3ZaXepYDro5GyiY/W1CpV3kDTqi2CUv/jaSbn\ng3APBoaxS4yZdT9WesZqT60qPbh+NOWPs8KECpVTxVX6JQ6po78lJ/J3h97AbFr9\nsi81o20qs9yjTzGbJOYgI1cfJFJJmvJpdZ7ZMR+hS3MQlxiQoDjp7NHCsUfswsE/\ncdU/ZOuXQcLu5E2/1oteJ5YeZ52dv8eJFqXh34T/2RNJpwHsBfJgojYVZ9W9ThNn\n7uesJDlHVdGwyzpAy0GMBg7NuHxE0jmhZ05PBo2UQbi/37DG7iK1rE3skr5DN8s=\n=OXpJ\n-----END PGP SIGNATURE-----\n", "payload": "tree de82ec4b5eefbef6f58767a7ac5c823fbf8776be\nparent 8e6de3244cd62cbde367c206bc9972daded5281d\nparent 1033351a51dd3ca342a83d4be13f7554f0b4fb1e\nauthor Tyler Ruckinger <t.ruckinger@gmail.com> 1593146232 -0400\ncommitter GitHub <noreply@github.com> 1593146232 -0400\n\nMerge pull request #2 from rust-lang/master\n\nupdate master"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "html_url": "https://github.com/rust-lang/rust/commit/00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/comments", "author": {"login": "TyPR124", "id": 29851190, "node_id": "MDQ6VXNlcjI5ODUxMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/29851190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TyPR124", "html_url": "https://github.com/TyPR124", "followers_url": "https://api.github.com/users/TyPR124/followers", "following_url": "https://api.github.com/users/TyPR124/following{/other_user}", "gists_url": "https://api.github.com/users/TyPR124/gists{/gist_id}", "starred_url": "https://api.github.com/users/TyPR124/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TyPR124/subscriptions", "organizations_url": "https://api.github.com/users/TyPR124/orgs", "repos_url": "https://api.github.com/users/TyPR124/repos", "events_url": "https://api.github.com/users/TyPR124/events{/privacy}", "received_events_url": "https://api.github.com/users/TyPR124/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6de3244cd62cbde367c206bc9972daded5281d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6de3244cd62cbde367c206bc9972daded5281d", "html_url": "https://github.com/rust-lang/rust/commit/8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "1033351a51dd3ca342a83d4be13f7554f0b4fb1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1033351a51dd3ca342a83d4be13f7554f0b4fb1e", "html_url": "https://github.com/rust-lang/rust/commit/1033351a51dd3ca342a83d4be13f7554f0b4fb1e"}], "stats": {"total": 427073, "additions": 314622, "deletions": 112451}, "files": [{"sha": "03bc4bab45137c76d85bdd644f76d8640a614ab3", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -14,7 +14,7 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Code\n \n-```\n+```Rust\n <code>\n ```\n "}, {"sha": "51bf0c3ee673652e64d8770d189b2454f38277d3", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,6 +1,6 @@\n ---\n name: Tracking Issue\n-about: A tracking issue for a feature in Rust.\n+about: A tracking issue for an accepted feature or RFC in Rust.\n title: Tracking Issue for XXX\n labels: C-tracking-issue\n ---"}, {"sha": "7b9f87c079e3a4070f3afe71a695d47417d8710f", "filename": ".github/workflows/ci.yml", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,745 @@\n+#############################################################\n+#   WARNING: automatically generated file, DO NOT CHANGE!   #\n+#############################################################\n+\n+# This file was automatically generated by the expand-yaml-anchors tool. The\n+# source file that generated this one is:\n+#\n+#   src/ci/github-actions/ci.yml\n+#\n+# Once you make changes to that file you need to run:\n+#\n+#   ./x.py run src/tools/expand-yaml-anchors/\n+#\n+# The CI build will fail if the tool is not run after changes to this file.\n+\n+---\n+name: CI\n+\"on\":\n+  push:\n+    branches:\n+      - auto\n+      - try\n+      - master\n+  pull_request:\n+    branches:\n+      - \"**\"\n+defaults:\n+  run:\n+    shell: \"python src/ci/exec-with-shell.py {0}\"\n+jobs:\n+  pr:\n+    name: PR\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'pull_request'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: mingw-check\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-llvm-8\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-tools\n+            env:\n+              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n+            os: ubuntu-latest-xl\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  try:\n+    name: try\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  auto:\n+    name: auto\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: arm-android\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: armhf-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-aarch64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-android\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-arm-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-armhf-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-armv7-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i586-gnu-i586-i686-musl\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i686-freebsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i686-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips64el-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mipsel-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc64le-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-s390x-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-various-1\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-various-2\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-freebsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+          - name: dist-x86_64-musl\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-netbsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: i686-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: i686-gnu-nopt\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: mingw-check\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: test-various\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: wasm32\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-aux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-debug\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-distcheck\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-full-bootstrap\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-llvm-8\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-latest-xl\n+          - name: x86_64-gnu-nopt\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-tools\n+            env:\n+              DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n+            os: ubuntu-latest-xl\n+          - name: x86_64-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n+              SCRIPT: make ci-subset-1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n+              SCRIPT: make ci-subset-2\n+            os: windows-latest-xl\n+          - name: i686-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n+              SCRIPT: make ci-subset-1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: i686-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n+              SCRIPT: make ci-subset-2\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-cargo\n+            env:\n+              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n+              VCVARS_BAT: vcvars64.bat\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-tools\n+            env:\n+              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n+            os: windows-latest-xl\n+          - name: i686-mingw-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n+              SCRIPT: make ci-mingw-subset-1\n+              CUSTOM_MINGW: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: i686-mingw-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n+              SCRIPT: make ci-mingw-subset-2\n+              CUSTOM_MINGW: 1\n+            os: windows-latest-xl\n+          - name: x86_64-mingw-1\n+            env:\n+              SCRIPT: make ci-mingw-subset-1\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              CUSTOM_MINGW: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-mingw-2\n+            env:\n+              SCRIPT: make ci-mingw-subset-2\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              CUSTOM_MINGW: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-i686-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --target=i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-i686-mingw\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-mingw\n+            env:\n+              SCRIPT: python x.py dist\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-msvc-alt\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n+              SCRIPT: python x.py dist\n+            os: windows-latest-xl\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  auto-fallible:\n+    name: auto-fallible\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: macos-latest\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  master:\n+    name: master\n+    runs-on: ubuntu-latest\n+    env:\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: publish toolstate\n+        run: src/ci/publish_toolstate.sh\n+        env:\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+  try-success:\n+    needs:\n+      - try\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  try-failure:\n+    needs:\n+      - try\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  auto-success:\n+    needs:\n+      - auto\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  auto-failure:\n+    needs:\n+      - auto\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest"}, {"sha": "856ff7dbb0f33cef38a9a680945d1eb27f5cc370", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -35,7 +35,7 @@ __pycache__/\n /obj/\n /rustllvm/\n /unicode-downloads\n-/target/\n+/target\n # Generated by compiletest for incremental:\n /tmp/\n tags"}, {"sha": "a9210cfc69ec5f9fab0650dc3354d626335bb8c6", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -16,9 +16,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang/rls.git\n-[submodule \"src/tools/clippy\"]\n-\tpath = src/tools/clippy\n-\turl = https://github.com/rust-lang/rust-clippy.git\n [submodule \"src/tools/rustfmt\"]\n \tpath = src/tools/rustfmt\n \turl = https://github.com/rust-lang/rustfmt.git\n@@ -31,16 +28,16 @@\n [submodule \"src/stdarch\"]\n \tpath = src/stdarch\n \turl = https://github.com/rust-lang/stdarch.git\n-[submodule \"src/doc/rustc-guide\"]\n-\tpath = src/doc/rustc-guide\n-\turl = https://github.com/rust-lang/rustc-guide.git\n+[submodule \"src/doc/rustc-dev-guide\"]\n+\tpath = src/doc/rustc-dev-guide\n+\turl = https://github.com/rust-lang/rustc-dev-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n \turl = https://github.com/rust-lang/edition-guide.git\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-12-19\n+\tbranch = rustc/10.0-2020-05-05\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "15ca403456a4ede8efd866b41fc16f2a1b104ad3", "filename": ".mailmap", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -44,11 +44,13 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n+Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n+Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n@@ -69,6 +71,8 @@ David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n+Donough Liu <ldm2993593805@163.com> <donoughliu@gmail.com>\n+Donough Liu <ldm2993593805@163.com> DingMing Liu <liudingming@bupt.edu.cn>\n Dustin Bensing <dustin.bensing@googlemail.com>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n@@ -133,7 +137,7 @@ Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n-John Ka\u030are Alsaker <john.kare.alsaker@gmail.com>\n+John K\u00e5re Alsaker <john.kare.alsaker@gmail.com>\n John Talling <inrustwetrust@users.noreply.github.com>\n Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n@@ -149,11 +153,15 @@ Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Kyle J Strand <batmanaod@gmail.com> <BatmanAoD@users.noreply.github.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.j.strand@gmail.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@pieinsurance.com>\n+Kyle J Strand <batmanaod@gmail.com> <kyle.strand@rms.com>\n Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n-Le\u0301o Testard <leo.testard@gmail.com>\n+L\u00e9o Testard <leo.testard@gmail.com>\n Lindsey Kuper <lindsey@composition.al> <lindsey@rockstargirl.org>\n Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>\n@@ -258,6 +266,7 @@ Tim Chevalier <chevalier@alum.wellesley.edu> <catamorphism@gmail.com>\n Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n+Trevor Spiteri <tspiteri@ieee.org> <trevor.spiteri@um.edu.mt>\n Ty Overby <ty@pre-alpha.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>"}, {"sha": "9c4afcefa1f220a1754cddcc82d838e6102bff83", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -188,11 +188,73 @@ with one another are rolled up.\n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found [here][rctd].\n \n-### External Dependencies\n+### External Dependencies (subtree)\n+\n+As a developer to this repository, you don't have to treat the following external projects\n+differently from other crates that are directly in this repo:\n+\n+* Clippy\n+\n+They are just regular files and directories. This is in contrast to `submodule` dependencies\n+(see below for those). Only tool authors will actually use any operations here.\n+\n+#### Synchronizing a subtree\n+\n+There are two synchronization directions: `subtree push` and `subtree pull`.\n+\n+```\n+git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n+```\n+\n+takes all the changes that\n+happened to the copy in this repo and creates commits on the remote repo that match the local\n+changes. Every local commit that touched the subtree causes a commit on the remote repo, but is\n+modified to move the files from the specified directory to the tool repo root.\n+\n+Make sure to not pick the `master` branch on the tool repo, so you can open a normal PR to the tool\n+to merge that subrepo push.\n+\n+```\n+git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n+```\n+\n+takes all changes since the last `subtree pull` from the tool repo\n+repo and adds these commits to the rustc repo + a merge commit that moves the tool changes into\n+the specified directory in the rust repository.\n+\n+It is recommended that you always do a push first and get that merged to the tool master branch.\n+Then, when you do a pull, the merge works without conflicts.\n+While it's definitely possible to resolve conflicts during a pull, you may have to redo the conflict\n+resolution if your PR doesn't get merged fast enough and there are new conflicts. Do not try to\n+rebase the result of a `git subtree pull`, rebasing merge commits is a bad idea in general.\n+\n+You always need to specify the `-P` prefix to the subtree directory and the corresponding remote\n+repository. If you specify the wrong directory or repository\n+you'll get very fun merges that try to push the wrong directory to the wrong remote repository.\n+Luckily you can just abort this without any consequences by throwing away either the pulled commits\n+in rustc or the pushed branch on the remote and try again. It is usually fairly obvious\n+that this is happening because you suddenly get thousands of commits that want to be synchronized.\n+\n+#### Creating a new subtree dependency\n+\n+If you want to create a new subtree dependency from an existing repository, call (from this\n+repository's root directory!)\n+\n+```\n+git subtree add -P src/tools/clippy https://github.com/rust-lang/rust-clippy.git master\n+```\n+\n+This will create a new commit, which you may not rebase under any circumstances! Delete the commit\n+and redo the operation if you need to rebase.\n+\n+Now you're done, the `src/tools/clippy` directory behaves as if Clippy were part of the rustc\n+monorepo, so no one but you (or others that synchronize subtrees) actually needs to use `git subtree`.\n+\n+\n+### External Dependencies (submodules)\n \n Currently building Rust will also build the following external projects:\n \n-* [clippy](https://github.com/rust-lang/rust-clippy)\n * [miri](https://github.com/rust-lang/miri)\n * [rustfmt](https://github.com/rust-lang/rustfmt)\n * [rls](https://github.com/rust-lang/rls/)\n@@ -221,7 +283,6 @@ before the PR is merged.\n \n Rust's build system builds a number of tools that make use of the\n internals of the compiler. This includes\n-[Clippy](https://github.com/rust-lang/rust-clippy),\n [RLS](https://github.com/rust-lang/rls) and\n [rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n break because of your changes, you may run into a sort of \"chicken and egg\"\n@@ -331,10 +392,18 @@ You can find documentation style guidelines in [RFC 1574][rfc1574].\n \n [rfc1574]: https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text\n \n-In many cases, you don't need a full `./x.py doc`. You can use `rustdoc` directly\n-to check small fixes. For example, `rustdoc src/doc/reference.md` will render\n-reference to `doc/reference.html`. The CSS might be messed up, but you can\n-verify that the HTML is right.\n+In many cases, you don't need a full `./x.py doc`, which will build the entire\n+stage 2 compiler and compile the various books published on\n+[doc.rust-lang.org]. When updating documentation for the standard library,\n+first try `./x.py doc --stage 0 src/libstd`. If that fails, or if you need to\n+see the output from the latest version of `rustdoc`, use `--stage 1` instead of\n+`--stage 0`. Results should appear in `build/$TARGET/crate-docs`.\n+\n+[doc.rust-lang.org]: htts://doc.rust-lang.org\n+\n+You can also use `rustdoc` directly to check small fixes. For example,\n+`rustdoc src/doc/reference.md` will render reference to `doc/reference.html`.\n+The CSS might be messed up, but you can verify that the HTML is right.\n \n Additionally, contributions to the [rustc-dev-guide] are always welcome. Contributions\n can be made directly at [the\n@@ -449,7 +518,7 @@ are:\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[gdfrustc]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[gdfrustc]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org\n [rr]: https://doc.rust-lang.org/book/README.html"}, {"sha": "b54566e7176b0db24feae34fda0f743323ecd4ea", "filename": "Cargo.lock", "status": "modified", "additions": 776, "deletions": 591, "changes": 1367, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "f10d539d8296ba9cabffdf88cee33f47fecf1118", "filename": "Cargo.toml", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -22,8 +22,10 @@ members = [\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\",\n   \"src/tools/miri\",\n+  \"src/tools/miri/cargo-miri\",\n   \"src/tools/rustdoc-themes\",\n   \"src/tools/unicode-table-generator\",\n+  \"src/tools/expand-yaml-anchors\",\n ]\n exclude = [\n   \"build\",\n@@ -40,6 +42,19 @@ debug-assertions = false\n debug = false\n debug-assertions = false\n \n+[profile.release.package.compiler_builtins]\n+# For compiler-builtins we always use a high number of codegen units.\n+# The goal here is to place every single intrinsic into its own object\n+# file to avoid symbol clashes with the system libgcc if possible. Note\n+# that this number doesn't actually produce this many object files, we\n+# just don't create more than this number of object files.\n+#\n+# It's a bit of a bummer that we have to pass this here, unfortunately.\n+# Ideally this would be specified through an env var to Cargo so Cargo\n+# knows how many CGUs are for this specific crate, but for now\n+# per-crate configuration isn't specifiable in the environment.\n+codegen-units = 10000\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository"}, {"sha": "42fc0a63c0ffbd9f87699a9f3fbddbd5341baa0d", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -23,11 +23,11 @@ or reading the [rustc dev guide][rustcguidebuild].\n \n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n-### Building on *nix\n+### Building on a Unix-like system\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 5.1 or later or `clang++` 3.5 or later\n-   * `python` 2.7 (but not 3.x)\n+   * `python` 3 or 2.7\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n    * `curl`\n@@ -113,7 +113,7 @@ build.\n                make \\\n                diffutils \\\n                tar \\\n-               mingw-w64-x86_64-python2 \\\n+               mingw-w64-x86_64-python \\\n                mingw-w64-x86_64-cmake \\\n                mingw-w64-x86_64-gcc\n    ```\n@@ -256,7 +256,7 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n [rust-discord]: https://discord.gg/rust-lang\n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n \n ## License\n "}, {"sha": "006682f50593662b5cef199b4ec7f4beece47062", "filename": "RELEASES.md", "status": "modified", "additions": 326, "deletions": 6, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,326 @@\n+Version 1.44.0 (2020-06-04)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `async/.await` with `#[no_std]` enabled.][69033]\n+- [Added the `unused_braces` lint.][70081]\n+\n+**Syntax-only changes**\n+\n+- [Expansion-driven outline module parsing][69838]\n+```rust\n+#[cfg(FALSE)]\n+mod foo {\n+    mod bar {\n+        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n+    }\n+}\n+```\n+\n+These are still rejected semantically, so you will likely receive an error but\n+these changes can be seen and parsed by macros and conditional compilation.\n+\n+Compiler\n+--------\n+- [Rustc now respects the `-C codegen-units` flag in incremental mode.][70156]\n+  Additionally when in incremental mode rustc defaults to 256 codegen units.\n+- [Refactored `catch_unwind` to have zero-cost, unless unwinding is enabled and\n+  a panic is thrown.][67502]\n+- [Added tier 3\\* support for the `aarch64-unknown-none` and\n+  `aarch64-unknown-none-softfloat` targets.][68334]\n+- [Added tier 3 support for `arm64-apple-tvos` and\n+  `x86_64-apple-tvos` targets.][68191]\n+\n+\n+Libraries\n+---------\n+- [Special cased `vec![]` to map directly to `Vec::new()`.][70632] This allows\n+  `vec![]` to be able to be used in `const` contexts.\n+- [`convert::Infallible` now implements `Hash`.][70281]\n+- [`OsString` now implements `DerefMut` and `IndexMut` returning\n+  a `&mut OsStr`.][70048]\n+- [Unicode 13 is now supported.][69929]\n+- [`String` now implements `From<&mut str>`.][69661]\n+- [`IoSlice` now implements `Copy`.][69403]\n+- [`Vec<T>` now implements `From<[T; N]>`.][68692] Where `N` is at most 32.\n+- [`proc_macro::LexError` now implements `fmt::Display` and `Error`.][68899]\n+- [`from_le_bytes`, `to_le_bytes`, `from_be_bytes`, `to_be_bytes`,\n+  `from_ne_bytes`, and `to_ne_bytes` methods are now `const` for all\n+  integer types.][69373]\n+\n+Stabilized APIs\n+---------------\n+- [`PathBuf::with_capacity`]\n+- [`PathBuf::capacity`]\n+- [`PathBuf::clear`]\n+- [`PathBuf::reserve`]\n+- [`PathBuf::reserve_exact`]\n+- [`PathBuf::shrink_to_fit`]\n+- [`f32::to_int_unchecked`]\n+- [`f64::to_int_unchecked`]\n+- [`Layout::align_to`]\n+- [`Layout::pad_to_align`]\n+- [`Layout::array`]\n+- [`Layout::extend`]\n+\n+Cargo\n+-----\n+- [Added the `cargo tree` command which will print a tree graph of\n+  your dependencies.][cargo/8062] E.g.\n+  ```\n+    mdbook v0.3.2 (/Users/src/rust/mdbook)\n+  \u251c\u2500\u2500 ammonia v3.0.0\n+  \u2502   \u251c\u2500\u2500 html5ever v0.24.0\n+  \u2502   \u2502   \u251c\u2500\u2500 log v0.4.8\n+  \u2502   \u2502   \u2502   \u2514\u2500\u2500 cfg-if v0.1.9\n+  \u2502   \u2502   \u251c\u2500\u2500 mac v0.1.1\n+  \u2502   \u2502   \u2514\u2500\u2500 markup5ever v0.9.0\n+  \u2502   \u2502       \u251c\u2500\u2500 log v0.4.8 (*)\n+  \u2502   \u2502       \u251c\u2500\u2500 phf v0.7.24\n+  \u2502   \u2502       \u2502   \u2514\u2500\u2500 phf_shared v0.7.24\n+  \u2502   \u2502       \u2502       \u251c\u2500\u2500 siphasher v0.2.3\n+  \u2502   \u2502       \u2502       \u2514\u2500\u2500 unicase v1.4.2\n+  \u2502   \u2502       \u2502           [build-dependencies]\n+  \u2502   \u2502       \u2502           \u2514\u2500\u2500 version_check v0.1.5\n+  ...\n+  ```\n+  You can also display dependencies on multiple versions of the same crate with\n+  `cargo tree -d` (short for `cargo tree --duplicates`).\n+\n+Misc\n+----\n+- [Rustdoc now allows you to specify `--crate-version` to have rustdoc include\n+  the version in the sidebar.][69494]\n+\n+Compatibility Notes\n+-------------------\n+- [Rustc now correctly generates static libraries on Windows GNU targets with\n+  the `.a` extension, rather than the previous `.lib`.][70937]\n+- [Removed the `-C no_integrated_as` flag from rustc.][70345]\n+- [The `file_name` property in JSON output of macro errors now points the actual\n+  source file rather than the previous format of `<NAME macros>`.][70969]\n+  **Note:** this may not point to a file that actually exists on the user's system.\n+- [The minimum required external LLVM version has been bumped to LLVM 8.][71147]\n+- [`mem::{zeroed, uninitialised}` will now panic when used with types that do\n+  not allow zero initialization such as `NonZeroU8`.][66059] This was\n+  previously a warning.\n+- [In 1.45.0 (the next release) converting a `f64` to `u32` using the `as`\n+  operator has been defined as a saturating operation.][71269] This was previously\n+  undefined behaviour, but you can use the `{f64, f32}::to_int_unchecked` methods to\n+  continue using the current behaviour, which may be desirable in rare performance\n+  sensitive situations.\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [dep_graph Avoid allocating a set on when the number reads are small.][69778]\n+- [Replace big JS dict with JSON parsing.][71250]\n+\n+[69373]: https://github.com/rust-lang/rust/pull/69373/\n+[66059]: https://github.com/rust-lang/rust/pull/66059/\n+[68191]: https://github.com/rust-lang/rust/pull/68191/\n+[68899]: https://github.com/rust-lang/rust/pull/68899/\n+[71147]: https://github.com/rust-lang/rust/pull/71147/\n+[71250]: https://github.com/rust-lang/rust/pull/71250/\n+[70937]: https://github.com/rust-lang/rust/pull/70937/\n+[70969]: https://github.com/rust-lang/rust/pull/70969/\n+[70632]: https://github.com/rust-lang/rust/pull/70632/\n+[70281]: https://github.com/rust-lang/rust/pull/70281/\n+[70345]: https://github.com/rust-lang/rust/pull/70345/\n+[70048]: https://github.com/rust-lang/rust/pull/70048/\n+[70081]: https://github.com/rust-lang/rust/pull/70081/\n+[70156]: https://github.com/rust-lang/rust/pull/70156/\n+[71269]: https://github.com/rust-lang/rust/pull/71269/\n+[69838]: https://github.com/rust-lang/rust/pull/69838/\n+[69929]: https://github.com/rust-lang/rust/pull/69929/\n+[69661]: https://github.com/rust-lang/rust/pull/69661/\n+[69778]: https://github.com/rust-lang/rust/pull/69778/\n+[69494]: https://github.com/rust-lang/rust/pull/69494/\n+[69403]: https://github.com/rust-lang/rust/pull/69403/\n+[69033]: https://github.com/rust-lang/rust/pull/69033/\n+[68692]: https://github.com/rust-lang/rust/pull/68692/\n+[68334]: https://github.com/rust-lang/rust/pull/68334/\n+[67502]: https://github.com/rust-lang/rust/pull/67502/\n+[cargo/8062]: https://github.com/rust-lang/cargo/pull/8062/\n+[`PathBuf::with_capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.with_capacity\n+[`PathBuf::capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.capacity\n+[`PathBuf::clear`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.clear\n+[`PathBuf::reserve`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve\n+[`PathBuf::reserve_exact`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve_exact\n+[`PathBuf::shrink_to_fit`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.shrink_to_fit\n+[`f32::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked\n+[`f64::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_int_unchecked\n+[`Layout::align_to`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.align_to\n+[`Layout::pad_to_align`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.pad_to_align\n+[`Layout::array`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.array\n+[`Layout::extend`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.extend\n+\n+\n+Version 1.43.1 (2020-05-07)\n+===========================\n+\n+* [Updated openssl-src to 1.1.1g for CVE-2020-1967.][71430]\n+* [Fixed the stabilization of AVX-512 features.][71473]\n+* [Fixed `cargo package --list` not working with unpublished dependencies.][cargo/8151]\n+\n+[71430]: https://github.com/rust-lang/rust/pull/71430\n+[71473]: https://github.com/rust-lang/rust/issues/71473\n+[cargo/8151]: https://github.com/rust-lang/cargo/issues/8151\n+\n+\n+Version 1.43.0 (2020-04-23)\n+==========================\n+\n+Language\n+--------\n+- [Fixed using binary operations with `&{number}` (e.g. `&1.0`) not having\n+  the type inferred correctly.][68129]\n+- [Attributes such as `#[cfg()]` can now be used on `if` expressions.][69201]\n+\n+**Syntax only changes**\n+- [Allow `type Foo: Ord` syntactically.][69361]\n+- [Fuse associated and extern items up to defaultness.][69194]\n+- [Syntactically allow `self` in all `fn` contexts.][68764]\n+- [Merge `fn` syntax + cleanup item parsing.][68728]\n+- [`item` macro fragments can be interpolated into `trait`s, `impl`s, and `extern` blocks.][69366]\n+  For example, you may now write:\n+  ```rust\n+  macro_rules! mac_trait {\n+      ($i:item) => {\n+          trait T { $i }\n+      }\n+  }\n+  mac_trait! {\n+      fn foo() {}\n+  }\n+  ```\n+\n+These are still rejected *semantically*, so you will likely receive an error but\n+these changes can be seen and parsed by macros and\n+conditional compilation.\n+\n+\n+Compiler\n+--------\n+- [You can now pass multiple lint flags to rustc to override the previous\n+  flags.][67885] For example; `rustc -D unused -A unused-variables` denies\n+  everything in the `unused` lint group except `unused-variables` which\n+  is explicitly allowed. However, passing `rustc -A unused-variables -D unused` denies\n+  everything in the `unused` lint group **including** `unused-variables` since\n+  the allow flag is specified before the deny flag (and therefore overridden).\n+- [rustc will now prefer your system MinGW libraries over its bundled libraries\n+  if they are available on `windows-gnu`.][67429]\n+- [rustc now buffers errors/warnings printed in JSON.][69227]\n+\n+Libraries\n+---------\n+- [`Arc<[T; N]>`, `Box<[T; N]>`, and `Rc<[T; N]>`, now implement\n+  `TryFrom<Arc<[T]>>`,`TryFrom<Box<[T]>>`, and `TryFrom<Rc<[T]>>`\n+  respectively.][69538] **Note** These conversions are only available when `N`\n+  is `0..=32`.\n+- [You can now use associated constants on floats and integers directly, rather\n+  than having to import the module.][68952] e.g. You can now write `u32::MAX` or\n+  `f32::NAN` with no imports.\n+- [`u8::is_ascii` is now `const`.][68984]\n+- [`String` now implements `AsMut<str>`.][68742]\n+- [Added the `primitive` module to `std` and `core`.][67637] This module\n+  reexports Rust's primitive types. This is mainly useful in macros\n+  where you want avoid these types being shadowed.\n+- [Relaxed some of the trait bounds on `HashMap` and `HashSet`.][67642]\n+- [`string::FromUtf8Error` now implements `Clone + Eq`.][68738]\n+\n+Stabilized APIs\n+---------------\n+- [`Once::is_completed`]\n+- [`f32::LOG10_2`]\n+- [`f32::LOG2_10`]\n+- [`f64::LOG10_2`]\n+- [`f64::LOG2_10`]\n+- [`iter::once_with`]\n+\n+Cargo\n+-----\n+- [You can now set config `[profile]`s in your `.cargo/config`, or through\n+  your environment.][cargo/7823]\n+- [Cargo will now set `CARGO_BIN_EXE_<name>` pointing to a binary's\n+  executable path when running integration tests or benchmarks.][cargo/7697]\n+  `<name>` is the name of your binary as-is e.g. If you wanted the executable\n+  path for a binary named `my-program`you would use `env!(\"CARGO_BIN_EXE_my-program\")`.\n+\n+Misc\n+----\n+- [Certain checks in the `const_err` lint were deemed unrelated to const\n+  evaluation][69185], and have been moved to the `unconditional_panic` and\n+  `arithmetic_overflow` lints.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Having trailing syntax in the `assert!` macro is now a hard error.][69548] This\n+  has been a warning since 1.36.0.\n+- [Fixed `Self` not having the correctly inferred type.][69340] This incorrectly\n+  led to some instances being accepted, and now correctly emits a hard error.\n+\n+[69340]: https://github.com/rust-lang/rust/pull/69340\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of `rustc` and\n+related tools.\n+\n+- [All components are now built with `opt-level=3` instead of `2`.][67878]\n+- [Improved how rustc generates drop code.][67332]\n+- [Improved performance from `#[inline]`-ing certain hot functions.][69256]\n+- [traits: preallocate 2 Vecs of known initial size][69022]\n+- [Avoid exponential behaviour when relating types][68772]\n+- [Skip `Drop` terminators for enum variants without drop glue][68943]\n+- [Improve performance of coherence checks][68966]\n+- [Deduplicate types in the generator witness][68672]\n+- [Invert control in struct_lint_level.][68725]\n+\n+[67332]: https://github.com/rust-lang/rust/pull/67332/\n+[67429]: https://github.com/rust-lang/rust/pull/67429/\n+[67637]: https://github.com/rust-lang/rust/pull/67637/\n+[67642]: https://github.com/rust-lang/rust/pull/67642/\n+[67878]: https://github.com/rust-lang/rust/pull/67878/\n+[67885]: https://github.com/rust-lang/rust/pull/67885/\n+[68129]: https://github.com/rust-lang/rust/pull/68129/\n+[68672]: https://github.com/rust-lang/rust/pull/68672/\n+[68725]: https://github.com/rust-lang/rust/pull/68725/\n+[68728]: https://github.com/rust-lang/rust/pull/68728/\n+[68738]: https://github.com/rust-lang/rust/pull/68738/\n+[68742]: https://github.com/rust-lang/rust/pull/68742/\n+[68764]: https://github.com/rust-lang/rust/pull/68764/\n+[68772]: https://github.com/rust-lang/rust/pull/68772/\n+[68943]: https://github.com/rust-lang/rust/pull/68943/\n+[68952]: https://github.com/rust-lang/rust/pull/68952/\n+[68966]: https://github.com/rust-lang/rust/pull/68966/\n+[68984]: https://github.com/rust-lang/rust/pull/68984/\n+[69022]: https://github.com/rust-lang/rust/pull/69022/\n+[69185]: https://github.com/rust-lang/rust/pull/69185/\n+[69194]: https://github.com/rust-lang/rust/pull/69194/\n+[69201]: https://github.com/rust-lang/rust/pull/69201/\n+[69227]: https://github.com/rust-lang/rust/pull/69227/\n+[69548]: https://github.com/rust-lang/rust/pull/69548/\n+[69256]: https://github.com/rust-lang/rust/pull/69256/\n+[69361]: https://github.com/rust-lang/rust/pull/69361/\n+[69366]: https://github.com/rust-lang/rust/pull/69366/\n+[69538]: https://github.com/rust-lang/rust/pull/69538/\n+[cargo/7823]: https://github.com/rust-lang/cargo/pull/7823\n+[cargo/7697]: https://github.com/rust-lang/cargo/pull/7697\n+[`Once::is_completed`]: https://doc.rust-lang.org/std/sync/struct.Once.html#method.is_completed\n+[`f32::LOG10_2`]: https://doc.rust-lang.org/std/f32/consts/constant.LOG10_2.html\n+[`f32::LOG2_10`]: https://doc.rust-lang.org/std/f32/consts/constant.LOG2_10.html\n+[`f64::LOG10_2`]: https://doc.rust-lang.org/std/f64/consts/constant.LOG10_2.html\n+[`f64::LOG2_10`]: https://doc.rust-lang.org/std/f64/consts/constant.LOG2_10.html\n+[`iter::once_with`]: https://doc.rust-lang.org/std/iter/fn.once_with.html\n+\n+\n Version 1.42.0 (2020-03-12)\n ==========================\n \n@@ -24,7 +347,7 @@ Language\n      (e.g. `type Foo: Ord;`).\n    - `...` (the C-variadic type) may occur syntactically directly as the type of\n       any function parameter.\n-  \n+\n   These are still rejected *semantically*, so you will likely receive an error\n   but these changes can be seen and parsed by procedural macros and\n   conditional compilation.\n@@ -316,7 +639,7 @@ Compatibility Notes\n - [Using `#[inline]` on function prototypes and consts now emits a warning under\n   `unused_attribute` lint.][65294] Using `#[inline]` anywhere else inside traits\n   or `extern` blocks now correctly emits a hard error.\n-  \n+\n [65294]: https://github.com/rust-lang/rust/pull/65294/\n [66103]: https://github.com/rust-lang/rust/pull/66103/\n [65843]: https://github.com/rust-lang/rust/pull/65843/\n@@ -589,7 +912,7 @@ Compatibility Notes\n [`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n [`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n [`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n-[forge-platform-support]: https://forge.rust-lang.org/platform-support.html\n+[forge-platform-support]: https://forge.rust-lang.org/release/platform-support.html\n [pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n \n Version 1.37.0 (2019-08-15)\n@@ -4838,7 +5161,6 @@ Version 1.11.0 (2016-08-18)\n Language\n --------\n \n-* [`cfg_attr` works on `path` attributes](https://github.com/rust-lang/rust/pull/34546)\n * [Support nested `cfg_attr` attributes](https://github.com/rust-lang/rust/pull/34216)\n * [Allow statement-generating braced macro invocations at the end of blocks](https://github.com/rust-lang/rust/pull/34436)\n * [Macros can be expanded inside of trait definitions](https://github.com/rust-lang/rust/pull/34213)\n@@ -4957,8 +5279,6 @@ Version 1.10.0 (2016-07-07)\n Language\n --------\n \n-* [Allow `concat_idents!` in type positions as well as in expression\n-  positions](https://github.com/rust-lang/rust/pull/33735).\n * [`Copy` types are required to have a trivial implementation of `Clone`](https://github.com/rust-lang/rust/pull/33420).\n   [RFC 1521](https://github.com/rust-lang/rfcs/blob/master/text/1521-copy-clone-semantics.md).\n * [Single-variant enums support the `#[repr(..)]` attribute](https://github.com/rust-lang/rust/pull/33355)."}, {"sha": "bc6760334170b5bd1bc63cdb1f507e2ab1acb5bb", "filename": "config.toml.example", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -69,7 +69,7 @@\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n # on them will not work unless the user opts in to building them.\n-#experimental-targets = \"\"\n+#experimental-targets = \"AVR\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -84,8 +84,9 @@\n #link-shared = false\n \n # When building llvm, this configures what is being appended to the version.\n-# If absent, we let the version as-is.\n-#version-suffix = \"-rust\"\n+# The default is \"-rust-$version-$channel\", except for dev channel where rustc\n+# version number is omitted. To use LLVM version as is, provide an empty string.\n+#version-suffix = \"-rust-dev\"\n \n # On MSVC you can compile LLVM with clang-cl, but the test suite doesn't pass\n # with clang-cl, so this is special in that it only compiles LLVM with clang-cl\n@@ -130,6 +131,10 @@\n # for each target triple.\n #target = [\"x86_64-unknown-linux-gnu\"] # defaults to just the build triple\n \n+# Use this directory to store build artifacts.\n+# You can use \"$ROOT\" to indicate the root of the git repository.\n+#build-dir = \"build\"\n+\n # Instead of downloading the src/stage0.txt version of Cargo specified, use\n # this Cargo binary instead to build all Rust code\n #cargo = \"/path/to/bin/cargo\"\n@@ -168,11 +173,9 @@\n \n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n-# Note that Python 2 is currently required.\n #\n-# Defaults to python2.7, then python2. If neither executable can be found, then\n-# it defaults to the Python interpreter used to execute x.py.\n-#python = \"python2.7\"\n+# Defaults to the Python interpreter used to execute x.py.\n+#python = \"python\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency\n # set that all the Cargo.toml files create, instead of updating it.\n@@ -206,7 +209,8 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n-# Build the profiler runtime\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n #profiler = false\n \n # Indicates whether the native libraries linked into Cargo will be statically\n@@ -309,7 +313,11 @@\n \n # Whether or not debug assertions are enabled for the compiler and standard\n # library.\n-#debug-assertions = false\n+#debug-assertions = debug\n+\n+# Whether or not debug assertions are enabled for the standard library.\n+# Overrides the `debug-assertions` option, if defined.\n+#debug-assertions-std = debug-assertions\n \n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info\n@@ -408,10 +416,6 @@\n # sysroot.\n #llvm-tools = false\n \n-# Indicates whether LLDB will be made available in the sysroot.\n-# This is only built if LLVM is also being built.\n-#lldb = false\n-\n # Whether to deny warnings in crates\n #deny-warnings = true\n "}, {"sha": "81e2001e4a583ef1f117a46593acd1705995ed85", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/configure", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -11,6 +11,7 @@ try() {\n     fi\n }\n \n+try python3 \"$@\"\n try python2.7 \"$@\"\n try python27 \"$@\"\n try python2 \"$@\""}, {"sha": "9b2c08200362effffe481cc9b8afc1a12e925428", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -20,7 +20,7 @@ ignore = [\n     \"src/doc/nomicon\",\n     \"src/doc/reference\",\n     \"src/doc/rust-by-example\",\n-    \"src/doc/rustc-guide\",\n+    \"src/doc/rustc-dev-guide\",\n     \"src/llvm-project\",\n     \"src/stdarch\",\n     \"src/tools/cargo\","}, {"sha": "c4918d7f2e7146795f0d5fdf5ea485dc2d6386bc", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -48,10 +48,11 @@ toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n+opener = \"0.4\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\"\n features = [\"fileapi\", \"ioapiset\", \"jobapi2\", \"handleapi\", \"winioctl\"]\n \n [dev-dependencies]\n-pretty_assertions = \"0.5\"\n+pretty_assertions = \"0.6\""}, {"sha": "89984bb55dfd82380ade435c25e362176592a593", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -10,7 +10,14 @@ fn main() {\n     let mut cmd = Command::new(real_llvm_config);\n     cmd.args(env::args().skip(1)).stderr(Stdio::piped());\n     let output = cmd.output().expect(\"failed to spawn llvm-config\");\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let mut stdout = String::from_utf8_lossy(&output.stdout);\n+\n+    if let Ok(to_replace) = env::var(\"LLVM_CONFIG_SHIM_REPLACE\") {\n+        if let Ok(replace_with) = env::var(\"LLVM_CONFIG_SHIM_REPLACE_WITH\") {\n+            stdout = stdout.replace(&to_replace, &replace_with).into();\n+        }\n+    }\n+\n     print!(\"{}\", stdout.replace(\"\\\\\", \"/\"));\n     io::stdout().flush().unwrap();\n     process::exit(output.status.code().unwrap_or(1));"}, {"sha": "a8c00c8c3ca88368764e4d5cb22068f9057671fc", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -134,11 +134,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n \n-        // Override linker flavor if necessary.\n-        if let Ok(host_linker_flavor) = env::var(\"RUSTC_HOST_LINKER_FLAVOR\") {\n-            cmd.arg(format!(\"-Clinker-flavor={}\", host_linker_flavor));\n-        }\n-\n         if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n             if s == \"true\" {\n                 cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");"}, {"sha": "ba644e611182779520548a59fd96ee7e2febb735", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -52,12 +52,7 @@ fn main() {\n     // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick\n     // it up so we can make rustdoc print this into the docs\n     if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n-        // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n-        if !has_unstable {\n-            cmd.arg(\"-Z\").arg(\"unstable-options\");\n-        }\n         cmd.arg(\"--crate-version\").arg(version);\n-        has_unstable = true;\n     }\n \n     // Needed to be able to run all rustdoc tests."}, {"sha": "82a755c7892b13d1652de7c616a298499230a444", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -2,6 +2,7 @@\n import argparse\n import contextlib\n import datetime\n+import distutils.version\n import hashlib\n import os\n import re\n@@ -78,6 +79,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n+        require([\"curl\", \"--version\"])\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n              \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n@@ -142,6 +144,21 @@ def run(args, verbose=False, exception=False, **kwargs):\n         sys.exit(err)\n \n \n+def require(cmd, exit=True):\n+    '''Run a command, returning its output.\n+    On error,\n+        If `exit` is `True`, exit the process.\n+        Otherwise, return None.'''\n+    try:\n+        return subprocess.check_output(cmd).strip()\n+    except (subprocess.CalledProcessError, OSError) as exc:\n+        if not exit:\n+            return None\n+        print(\"error: unable to run `{}`: {}\".format(' '.join(cmd), exc))\n+        print(\"Please make sure it's installed and in the path.\")\n+        sys.exit(1)\n+\n+\n def stage0_data(rust_root):\n     \"\"\"Build a dictionary from stage0.txt\"\"\"\n     nightlies = os.path.join(rust_root, \"src/stage0.txt\")\n@@ -163,16 +180,15 @@ def format_build_time(duration):\n def default_build_triple():\n     \"\"\"Build triple as in LLVM\"\"\"\n     default_encoding = sys.getdefaultencoding()\n-    try:\n-        ostype = subprocess.check_output(\n-            ['uname', '-s']).strip().decode(default_encoding)\n-        cputype = subprocess.check_output(\n-            ['uname', '-m']).strip().decode(default_encoding)\n-    except (subprocess.CalledProcessError, OSError):\n-        if sys.platform == 'win32':\n-            return 'x86_64-pc-windows-msvc'\n-        err = \"uname not found\"\n-        sys.exit(err)\n+    required = sys.platform != 'win32'\n+    ostype = require([\"uname\", \"-s\"], exit=required)\n+    cputype = require(['uname', '-m'], exit=required)\n+\n+    if ostype is None or cputype is None:\n+        return 'x86_64-pc-windows-msvc'\n+\n+    ostype = ostype.decode(default_encoding)\n+    cputype = cputype.decode(default_encoding)\n \n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n@@ -202,12 +218,7 @@ def default_build_triple():\n         # output from that option is too generic for our purposes (it will\n         # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n         # must be used instead.\n-        try:\n-            cputype = subprocess.check_output(\n-                ['isainfo', '-k']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, OSError):\n-            err = \"isainfo not found\"\n-            sys.exit(err)\n+        cputype = require(['isainfo', '-k']).decode(default_encoding)\n     elif ostype.startswith('MINGW'):\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n@@ -324,13 +335,14 @@ def __init__(self):\n         self.rustc_channel = ''\n         self.rustfmt_channel = ''\n         self.build = ''\n-        self.build_dir = os.path.join(os.getcwd(), \"build\")\n+        self.build_dir = ''\n         self.clean = False\n         self.config_toml = ''\n         self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n+        self.git_version = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -664,6 +676,10 @@ def build_bootstrap(self):\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n         env = os.environ.copy()\n+        # `CARGO_BUILD_TARGET` breaks bootstrap build.\n+        # See also: <https://github.com/rust-lang/rust/issues/70208>.\n+        if \"CARGO_BUILD_TARGET\" in env:\n+            del env[\"CARGO_BUILD_TARGET\"]\n         env[\"RUSTC_BOOTSTRAP\"] = '1'\n         env[\"CARGO_TARGET_DIR\"] = build_dir\n         env[\"RUSTC\"] = self.rustc()\n@@ -739,15 +755,13 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n-        try:\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", \"--progress\", module],\n-                cwd=self.rust_root, verbose=self.verbose, exception=True)\n-        except RuntimeError:\n-            # Some versions of git don't support --progress.\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", module],\n-                cwd=self.rust_root, verbose=self.verbose)\n+\n+        update_args = [\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"]\n+        if self.git_version >= distutils.version.LooseVersion(\"2.11.0\"):\n+            update_args.append(\"--progress\")\n+        update_args.append(module)\n+        run(update_args, cwd=self.rust_root, verbose=self.verbose, exception=True)\n+\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)\n         run([\"git\", \"clean\", \"-qdfx\"],\n@@ -759,12 +773,11 @@ def update_submodules(self):\n                 self.get_toml('submodules') == \"false\":\n             return\n \n-        # check the existence of 'git' command\n-        try:\n-            subprocess.check_output(['git', '--version'])\n-        except (subprocess.CalledProcessError, OSError):\n-            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n-            sys.exit(1)\n+        default_encoding = sys.getdefaultencoding()\n+\n+        # check the existence and version of 'git' command\n+        git_version_str = require(['git', '--version']).split()[2].decode(default_encoding)\n+        self.git_version = distutils.version.LooseVersion(git_version_str)\n \n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n@@ -880,11 +893,18 @@ def bootstrap(help_triggered):\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n-    try:\n-        with open(args.config or 'config.toml') as config:\n+    # Read from `RUST_BOOTSTRAP_CONFIG`, then `--config`, then fallback to `config.toml` (if it\n+    # exists).\n+    toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config\n+    if not toml_path and os.path.exists('config.toml'):\n+        toml_path = 'config.toml'\n+\n+    if toml_path:\n+        if not os.path.exists(toml_path):\n+            toml_path = os.path.join(build.rust_root, toml_path)\n+\n+        with open(toml_path) as config:\n             build.config_toml = config.read()\n-    except (OSError, IOError):\n-        pass\n \n     config_verbose = build.get_toml('verbose', 'build')\n     if config_verbose is not None:\n@@ -896,6 +916,9 @@ def bootstrap(help_triggered):\n \n     build.check_vendored_status()\n \n+    build_dir = build.get_toml('build-dir', 'build') or 'build'\n+    build.build_dir = os.path.abspath(build_dir.replace(\"$ROOT\", build.rust_root))\n+\n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n     build.rustc_channel = data['rustc']\n@@ -931,6 +954,8 @@ def bootstrap(help_triggered):\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n     env[\"CARGO\"] = build.cargo()\n     env[\"RUSTC\"] = build.rustc()\n+    if toml_path:\n+        env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     if build.rustfmt():\n         env[\"RUSTFMT\"] = build.rustfmt()\n     run(args, env=env, verbose=build.verbose)"}, {"sha": "8f0a245a5658a5f3ea7b2d0438e9d2b045ca9536", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 134, "deletions": 53, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -11,7 +11,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n-use build_helper::t;\n+use build_helper::{output, t};\n \n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n@@ -21,9 +21,10 @@ use crate::doc;\n use crate::flags::Subcommand;\n use crate::install;\n use crate::native;\n+use crate::run;\n use crate::test;\n use crate::tool;\n-use crate::util::{self, add_lib_path, exe, libdir};\n+use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n use crate::{Build, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n@@ -51,6 +52,8 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// it's been assembled.\n     type Output: Clone;\n \n+    /// Whether this step is run by default as part of its respective phase.\n+    /// `true` here can still be overwritten by `should_run` calling `default_condition`.\n     const DEFAULT: bool = false;\n \n     /// If true, then this rule should be skipped if --target was specified, but --host was not\n@@ -96,9 +99,21 @@ struct StepDescription {\n     name: &'static str,\n }\n \n+/// Collection of paths used to match a task rule.\n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n+    /// A collection of individual paths.\n+    ///\n+    /// These are generally matched as a path suffix. For example, a\n+    /// command-line value of `libstd` will match if `src/libstd` is in the\n+    /// set.\n     Set(BTreeSet<PathBuf>),\n+    /// A \"suite\" of paths.\n+    ///\n+    /// These can match as a path suffix (like `Set`), or as a prefix. For\n+    /// example, a command-line value of `src/test/ui/abi/variadic-ffi.rs`\n+    /// will match `src/test/ui`. A command-line value of `ui` would also\n+    /// match `src/test/ui`.\n     Suite(PathBuf),\n }\n \n@@ -248,21 +263,33 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n-    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n-    // actually doing something different for every crate passed.\n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// Compared to `krate`, this treats the dependencies as aliases for the\n+    /// same job. Generally it is preferred to use `krate`, and treat each\n+    /// individual path separately. For example `./x.py test src/liballoc`\n+    /// (which uses `krate`) will test just `liballoc`. However, `./x.py check\n+    /// src/liballoc` (which uses `all_krates`) will check all of `libtest`.\n+    /// `all_krates` should probably be removed at some point.\n     pub fn all_krates(mut self, name: &str) -> Self {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name) {\n-            set.insert(PathBuf::from(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            set.insert(path);\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n     }\n \n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// `make_run` will be called separately for each matching command-line path.\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name) {\n-            self.paths.insert(PathSet::one(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            self.paths.insert(PathSet::one(path));\n         }\n         self\n     }\n@@ -313,6 +340,7 @@ pub enum Kind {\n     Dist,\n     Doc,\n     Install,\n+    Run,\n }\n \n impl<'a> Builder<'a> {\n@@ -342,21 +370,23 @@ impl<'a> Builder<'a> {\n                 tool::Rls,\n                 tool::Rustdoc,\n                 tool::Clippy,\n+                tool::CargoClippy,\n                 native::Llvm,\n                 native::Sanitizers,\n                 tool::Rustfmt,\n                 tool::Miri,\n+                tool::CargoMiri,\n                 native::Lld\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n-                describe!(check::Std, check::Rustc, check::Rustdoc)\n+                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy)\n             }\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,\n+                test::ExpandYamlAnchors,\n                 test::Tidy,\n                 test::Ui,\n                 test::CompileFail,\n-                test::RunFail,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n                 test::Codegen,\n@@ -367,8 +397,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunFailPretty,\n-                test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n@@ -438,7 +466,6 @@ impl<'a> Builder<'a> {\n                 dist::Clippy,\n                 dist::Miri,\n                 dist::LlvmTools,\n-                dist::Lldb,\n                 dist::Extended,\n                 dist::HashSign\n             ),\n@@ -454,6 +481,7 @@ impl<'a> Builder<'a> {\n                 install::Src,\n                 install::Rustc\n             ),\n+            Kind::Run => describe!(run::ExpandYamlAnchors,),\n         }\n     }\n \n@@ -484,13 +512,19 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n+        let mut add_path = |path: &Path| {\n+            help.push_str(&format!(\"    ./x.py {} {}\\n\", subcommand, path.display()));\n+        };\n         for pathset in should_run.paths {\n-            if let PathSet::Set(set) = pathset {\n-                set.iter().for_each(|path| {\n-                    help.push_str(\n-                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n-                    )\n-                })\n+            match pathset {\n+                PathSet::Set(set) => {\n+                    for path in set {\n+                        add_path(&path);\n+                    }\n+                }\n+                PathSet::Suite(path) => {\n+                    add_path(&path.join(\"...\"));\n+                }\n             }\n         }\n         Some(help)\n@@ -502,11 +536,12 @@ impl<'a> Builder<'a> {\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Clippy { ref paths } => (Kind::Clippy, &paths[..]),\n             Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n-            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Doc { ref paths, .. } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n+            Subcommand::Run { ref paths } => (Kind::Run, &paths[..]),\n             Subcommand::Format { .. } | Subcommand::Clean { .. } => panic!(),\n         };\n \n@@ -646,6 +681,7 @@ impl<'a> Builder<'a> {\n     pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n         match self.config.libdir_relative() {\n             Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+            _ if compiler.stage == 0 => &self.build.initial_libdir,\n             _ => Path::new(\"lib\"),\n         }\n     }\n@@ -660,7 +696,7 @@ impl<'a> Builder<'a> {\n             return;\n         }\n \n-        add_lib_path(vec![self.rustc_libdir(compiler)], &mut cmd.command);\n+        add_dylib_path(vec![self.rustc_libdir(compiler)], &mut cmd.command);\n     }\n \n     /// Gets a path to the compiler specified.\n@@ -698,6 +734,20 @@ impl<'a> Builder<'a> {\n         cmd\n     }\n \n+    /// Return the path to `llvm-config` for the target, if it exists.\n+    ///\n+    /// Note that this returns `None` if LLVM is disabled, or if we're in a\n+    /// check build or dry-run, where there's no need to build all of LLVM.\n+    fn llvm_config(&self, target: Interned<String>) -> Option<PathBuf> {\n+        if self.config.llvm_enabled() && self.kind != Kind::Check && !self.config.dry_run {\n+            let llvm_config = self.ensure(native::Llvm { target });\n+            if llvm_config.is_file() {\n+                return Some(llvm_config);\n+            }\n+        }\n+        None\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of\n@@ -725,7 +775,7 @@ impl<'a> Builder<'a> {\n             self.clear_if_dirty(&my_out, &rustdoc);\n         }\n \n-        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd).arg(\"-Zconfig-profile\");\n+        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd);\n \n         let profile_var = |name: &str| {\n             let profile = if self.config.rust_optimize { \"RELEASE\" } else { \"DEV\" };\n@@ -746,9 +796,17 @@ impl<'a> Builder<'a> {\n         }\n \n         // Set a flag for `check`/`clippy`/`fix`, so that certain build\n-        // scripts can do less work (e.g. not building/requiring LLVM).\n+        // scripts can do less work (i.e. not building/requiring LLVM).\n         if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n-            cargo.env(\"RUST_CHECK\", \"1\");\n+            // If we've not yet built LLVM, or it's stale, then bust\n+            // the librustc_llvm cache. That will always work, even though it\n+            // may mean that on the next non-check build we'll need to rebuild\n+            // librustc_llvm. But if LLVM is stale, that'll be a tiny amount\n+            // of work comparitively, and we'd likely need to rebuild it anyway,\n+            // so that's okay.\n+            if crate::native::prebuilt_llvm_config(self, target).is_err() {\n+                cargo.env(\"RUST_CHECK\", \"1\");\n+            }\n         }\n \n         let stage = if compiler.stage == 0 && self.local_rebuild {\n@@ -772,6 +830,11 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"--cfg=bootstrap\");\n         }\n \n+        // FIXME: It might be better to use the same value for both `RUSTFLAGS` and `RUSTDOCFLAGS`,\n+        // but this breaks CI. At the very least, stage0 `rustdoc` needs `--cfg bootstrap`. See\n+        // #71458.\n+        let rustdocflags = rustflags.clone();\n+\n         if let Ok(s) = env::var(\"CARGOFLAGS\") {\n             cargo.args(s.split_whitespace());\n         }\n@@ -847,13 +910,7 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"-Zforce-unstable-if-unmarked\");\n         }\n \n-        // cfg(bootstrap): the flag was renamed from `-Zexternal-macro-backtrace`\n-        // to `-Zmacro-backtrace`, keep only the latter after beta promotion.\n-        if stage == 0 {\n-            rustflags.arg(\"-Zexternal-macro-backtrace\");\n-        } else {\n-            rustflags.arg(\"-Zmacro-backtrace\");\n-        }\n+        rustflags.arg(\"-Zmacro-backtrace\");\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n \n@@ -892,7 +949,14 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n             .env(\"RUSTC_REAL\", self.rustc(compiler))\n             .env(\"RUSTC_STAGE\", stage.to_string())\n-            .env(\"RUSTC_DEBUG_ASSERTIONS\", self.config.rust_debug_assertions.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                if mode == Mode::Std {\n+                    self.config.rust_debug_assertions_std.to_string()\n+                } else {\n+                    self.config.rust_debug_assertions.to_string()\n+                },\n+            )\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n@@ -956,27 +1020,11 @@ impl<'a> Builder<'a> {\n         // See https://github.com/rust-lang/rust/issues/68647.\n         let can_use_lld = mode != Mode::Std;\n \n-        // FIXME: The beta compiler doesn't pick the `lld-link` flavor for `*-pc-windows-msvc`\n-        // Remove `RUSTC_HOST_LINKER_FLAVOR` when this is fixed\n-        let lld_linker_flavor = |linker: &Path, target: Interned<String>| {\n-            compiler.stage == 0\n-                && linker.file_name() == Some(OsStr::new(\"rust-lld\"))\n-                && target.contains(\"pc-windows-msvc\")\n-        };\n-\n         if let Some(host_linker) = self.linker(compiler.host, can_use_lld) {\n-            if lld_linker_flavor(host_linker, compiler.host) {\n-                cargo.env(\"RUSTC_HOST_LINKER_FLAVOR\", \"lld-link\");\n-            }\n-\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n \n         if let Some(target_linker) = self.linker(target, can_use_lld) {\n-            if lld_linker_flavor(target_linker, target) {\n-                rustflags.arg(\"-Clinker-flavor=lld-link\");\n-            }\n-\n             let target = crate::envify(&target);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n@@ -1009,8 +1057,13 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n         }\n \n-        if let Some(map) = self.build.debuginfo_map(GitRepo::Rustc) {\n+        if let Some(map_to) = self.build.debuginfo_map_to(GitRepo::Rustc) {\n+            let map = format!(\"{}={}\", self.build.src.display(), map_to);\n             cargo.env(\"RUSTC_DEBUGINFO_MAP\", map);\n+\n+            // `rustc` needs to know the virtual `/rustc/$hash` we're mapping to,\n+            // in order to opportunistically reverse it later.\n+            cargo.env(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\", map_to);\n         }\n \n         // Enable usage of unstable features\n@@ -1040,6 +1093,17 @@ impl<'a> Builder<'a> {\n                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n+        // Tools that use compiler libraries may inherit the `-lLLVM` link\n+        // requirement, but the `-L` library path is not propagated across\n+        // separate Cargo projects. We can add LLVM's library path to the\n+        // platform-specific environment variable as a workaround.\n+        if mode == Mode::ToolRustc {\n+            if let Some(llvm_config) = self.llvm_config(target) {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cargo);\n+            }\n+        }\n+\n         if self.config.incremental {\n             cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         } else {\n@@ -1071,6 +1135,13 @@ impl<'a> Builder<'a> {\n             if self.config.deny_warnings {\n                 rustflags.arg(\"-Dwarnings\");\n             }\n+\n+            // FIXME(#58633) hide \"unused attribute\" errors in incremental\n+            // builds of the standard library, as the underlying checks are\n+            // not yet properly integrated with incremental recompilation.\n+            if mode == Mode::Std && compiler.stage == 0 && self.config.incremental {\n+                rustflags.arg(\"-Aunused-attributes\");\n+            }\n         }\n \n         if let Mode::Rustc | Mode::Codegen = mode {\n@@ -1135,7 +1206,7 @@ impl<'a> Builder<'a> {\n             );\n         }\n \n-        // If Control Flow Guard is enabled, pass the `control_flow_guard=checks` flag to rustc\n+        // If Control Flow Guard is enabled, pass the `control-flow-guard` flag to rustc\n         // when compiling the standard library, since this might be linked into the final outputs\n         // produced by rustc. Since this mitigation is only available on Windows, only enable it\n         // for the standard library in case the compiler is run on a non-Windows platform.\n@@ -1146,7 +1217,7 @@ impl<'a> Builder<'a> {\n             && self.config.control_flow_guard\n             && compiler.stage >= 1\n         {\n-            rustflags.arg(\"-Zcontrol_flow_guard=checks\");\n+            rustflags.arg(\"-Zcontrol-flow-guard\");\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n@@ -1249,7 +1320,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        Cargo { command: cargo, rustflags }\n+        Cargo { command: cargo, rustflags, rustdocflags }\n     }\n \n     /// Ensure that a given step is built, returning its output. This will\n@@ -1307,7 +1378,7 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Rustflags(String);\n \n impl Rustflags {\n@@ -1347,6 +1418,7 @@ impl Rustflags {\n pub struct Cargo {\n     command: Command,\n     rustflags: Rustflags,\n+    rustdocflags: Rustflags,\n }\n \n impl Cargo {\n@@ -1379,7 +1451,16 @@ impl Cargo {\n \n impl From<Cargo> for Command {\n     fn from(mut cargo: Cargo) -> Command {\n-        cargo.command.env(\"RUSTFLAGS\", &cargo.rustflags.0);\n+        let rustflags = &cargo.rustflags.0;\n+        if !rustflags.is_empty() {\n+            cargo.command.env(\"RUSTFLAGS\", rustflags);\n+        }\n+\n+        let rustdocflags = &cargo.rustdocflags.0;\n+        if !rustdocflags.is_empty() {\n+            cargo.command.env(\"RUSTDOCFLAGS\", rustdocflags);\n+        }\n+\n         cargo.command\n     }\n }"}, {"sha": "ab16ca3732c1fc93a81d4ed8ac20855052155c5f", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -37,7 +37,9 @@ use crate::{Build, GitRepo};\n // try to infer the archiver path from the C compiler path.\n // In the future this logic should be replaced by calling into the `cc` crate.\n fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if let Some(ar) = env::var_os(\"AR\") {\n+    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.replace(\"-\", \"_\"))) {\n+        Some(PathBuf::from(ar))\n+    } else if let Some(ar) = env::var_os(\"AR\") {\n         Some(PathBuf::from(ar))\n     } else if target.contains(\"msvc\") {\n         None"}, {"sha": "a4115904ac76f16500d5c6fd6eb834a683041ec9", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.43.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.46.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "7a8bfb2d5d877190661a8a83973a679e3e94709c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -45,7 +45,7 @@ impl Step for Std {\n         let compiler = builder.compiler(0, builder.config.build);\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n-        std_cargo(builder, target, &mut cargo);\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(\n@@ -112,83 +112,89 @@ impl Step for Rustc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n-    pub target: Interned<String>,\n+macro_rules! tool_check_step {\n+    ($name:ident, $path:expr) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub target: Interned<String>,\n+        }\n+\n+        impl Step for $name {\n+            type Output = ();\n+            const ONLY_HOSTS: bool = true;\n+            const DEFAULT: bool = true;\n+\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+                run.path($path)\n+            }\n+\n+            fn make_run(run: RunConfig<'_>) {\n+                run.builder.ensure($name { target: run.target });\n+            }\n+\n+            fn run(self, builder: &Builder<'_>) {\n+                let compiler = builder.compiler(0, builder.config.build);\n+                let target = self.target;\n+\n+                builder.ensure(Rustc { target });\n+\n+                let cargo = prepare_tool_cargo(\n+                    builder,\n+                    compiler,\n+                    Mode::ToolRustc,\n+                    target,\n+                    cargo_subcommand(builder.kind),\n+                    $path,\n+                    SourceType::InTree,\n+                    &[],\n+                );\n+\n+                println!(\n+                    \"Checking {} artifacts ({} -> {})\",\n+                    stringify!($name).to_lowercase(),\n+                    &compiler.host,\n+                    target\n+                );\n+                run_cargo(\n+                    builder,\n+                    cargo,\n+                    args(builder.kind),\n+                    &stamp(builder, compiler, target),\n+                    vec![],\n+                    true,\n+                );\n+\n+                let libdir = builder.sysroot_libdir(compiler, target);\n+                let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+                add_to_sysroot(&builder, &libdir, &hostdir, &stamp(builder, compiler, target));\n+\n+                /// Cargo's output path in a given stage, compiled by a particular\n+                /// compiler for the specified target.\n+                fn stamp(\n+                    builder: &Builder<'_>,\n+                    compiler: Compiler,\n+                    target: Interned<String>,\n+                ) -> PathBuf {\n+                    builder\n+                        .cargo_out(compiler, Mode::ToolRustc, target)\n+                        .join(format!(\".{}-check.stamp\", stringify!($name).to_lowercase()))\n+                }\n+            }\n+        }\n+    };\n }\n \n-impl Step for Rustdoc {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/rustdoc\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Rustc { target });\n-\n-        let cargo = prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolRustc,\n-            target,\n-            cargo_subcommand(builder.kind),\n-            \"src/tools/rustdoc\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-\n-        println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder.kind),\n-            &rustdoc_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-    }\n-}\n+tool_check_step!(Rustdoc, \"src/tools/rustdoc\");\n+tool_check_step!(Clippy, \"src/tools/clippy\");\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n-\n-/// Cargo's output path for rustdoc in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn rustdoc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::ToolRustc, target).join(\".rustdoc-check.stamp\")\n-}"}, {"sha": "afcf0dcac7e55341e4764ce8a8ba513dd92a855b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 188, "deletions": 99, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -22,8 +22,8 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n-use crate::util::{exe, is_dylib};\n-use crate::{Compiler, GitRepo, Mode};\n+use crate::util::{exe, is_dylib, symlink_dir};\n+use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -74,6 +74,7 @@ impl Step for Std {\n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n+            copy_self_contained_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n                 compiler: compiler_to_use,\n@@ -83,10 +84,11 @@ impl Step for Std {\n             return;\n         }\n \n-        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target));\n+        target_deps.extend(copy_self_contained_objects(builder, &compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n-        std_cargo(builder, target, &mut cargo);\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\n             \"Building stage{} std artifacts ({} -> {})\",\n@@ -109,38 +111,29 @@ impl Step for Std {\n     }\n }\n \n+fn copy_and_stamp(\n+    builder: &Builder<'_>,\n+    libdir: &Path,\n+    sourcedir: &Path,\n+    name: &str,\n+    target_deps: &mut Vec<(PathBuf, DependencyType)>,\n+    dependency_type: DependencyType,\n+) {\n+    let target = libdir.join(name);\n+    builder.copy(&sourcedir.join(name), &target);\n+\n+    target_deps.push((target, dependency_type));\n+}\n+\n /// Copies third party objects needed by various targets.\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n     target: Interned<String>,\n-) -> Vec<PathBuf> {\n+) -> Vec<(PathBuf, DependencyType)> {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n-\n     let mut target_deps = vec![];\n \n-    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n-        let target = libdir.join(name);\n-        builder.copy(&sourcedir.join(name), &target);\n-        target_deps.push(target);\n-    };\n-\n-    // Copies the crt(1,i,n).o startup objects\n-    //\n-    // Since musl supports fully static linking, we can cross link for it even\n-    // with a glibc-targeting toolchain, given we have the appropriate startup\n-    // files. As those shipped with glibc won't work, copy the ones provided by\n-    // musl so we have them on linux-gnu hosts.\n-    if target.contains(\"musl\") {\n-        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n-        for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-            copy_and_stamp(&srcdir, obj);\n-        }\n-    } else if target.ends_with(\"-wasi\") {\n-        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n-        copy_and_stamp(&srcdir, \"crt1.o\");\n-    }\n-\n     // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n     //\n     // This target needs to be linked to Fortanix's port of llvm's libunwind.\n@@ -150,21 +143,89 @@ fn copy_third_party_objects(\n         let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n         let src =\n             env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n-        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n+        copy_and_stamp(\n+            builder,\n+            &*libdir,\n+            Path::new(&src),\n+            \"libunwind.a\",\n+            &mut target_deps,\n+            DependencyType::Target,\n+        );\n     }\n \n     if builder.config.sanitizers && compiler.stage != 0 {\n         // The sanitizers are only copied in stage1 or above,\n         // to avoid creating dependency on LLVM.\n-        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+        target_deps.extend(\n+            copy_sanitizers(builder, &compiler, target)\n+                .into_iter()\n+                .map(|d| (d, DependencyType::Target)),\n+        );\n+    }\n+\n+    target_deps\n+}\n+\n+/// Copies third party objects needed by various targets for self-contained linkage.\n+fn copy_self_contained_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<(PathBuf, DependencyType)> {\n+    // cfg(bootstrap)\n+    // Remove when upgrading bootstrap compiler.\n+    let libdir_self_contained = if compiler.stage == 0 {\n+        builder.sysroot_libdir(*compiler, target).to_path_buf()\n+    } else {\n+        builder.sysroot_libdir(*compiler, target).join(\"self-contained\")\n+    };\n+    t!(fs::create_dir_all(&libdir_self_contained));\n+    let mut target_deps = vec![];\n+\n+    // Copies the CRT objects.\n+    //\n+    // rustc historically provides a more self-contained installation for musl targets\n+    // not requiring the presence of a native musl toolchain. For example, it can fall back\n+    // to using gcc from a glibc-targeting toolchain for linking.\n+    // To do that we have to distribute musl startup objects as a part of Rust toolchain\n+    // and link with them manually in the self-contained mode.\n+    if target.contains(\"musl\") {\n+        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n+        for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n+            copy_and_stamp(\n+                builder,\n+                &libdir_self_contained,\n+                &srcdir,\n+                obj,\n+                &mut target_deps,\n+                DependencyType::TargetSelfContained,\n+            );\n+        }\n+    } else if target.ends_with(\"-wasi\") {\n+        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n+        copy_and_stamp(\n+            builder,\n+            &libdir_self_contained,\n+            &srcdir,\n+            \"crt1.o\",\n+            &mut target_deps,\n+            DependencyType::TargetSelfContained,\n+        );\n+    } else if target.contains(\"windows-gnu\") {\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let target = libdir_self_contained.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push((target, DependencyType::TargetSelfContained));\n+        }\n     }\n \n     target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Cargo) {\n+pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -186,6 +247,8 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n     // `compiler-rt` is located.\n     let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n     let compiler_builtins_c_feature = if compiler_builtins_root.exists() {\n+        // Note that `libprofiler_builtins/build.rs` also computes this so if\n+        // you're changing something here please also change that.\n         cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);\n         \" compiler-builtins-c\".to_string()\n     } else {\n@@ -229,6 +292,28 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n             }\n         }\n     }\n+\n+    // By default, rustc uses `-Cembed-bitcode=yes`, and Cargo overrides that\n+    // with `-Cembed-bitcode=no` for non-LTO builds. However, libstd must be\n+    // built with bitcode so that the produced rlibs can be used for both LTO\n+    // builds (which use bitcode) and non-LTO builds (which use object code).\n+    // So we override the override here!\n+    //\n+    // But we don't bother for the stage 0 compiler because it's never used\n+    // with LTO.\n+    if stage >= 1 {\n+        cargo.rustflag(\"-Cembed-bitcode=yes\");\n+    }\n+\n+    // By default, rustc does not include unwind tables unless they are required\n+    // for a particular target. They are not required by RISC-V targets, but\n+    // compiling the standard library with them means that users can get\n+    // backtraces without having to recompile the standard library themselves.\n+    //\n+    // This choice was discussed in https://github.com/rust-lang/rust/pull/69890\n+    if target.contains(\"riscv\") {\n+        cargo.rustflag(\"-Cforce-unwind-tables=yes\");\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -310,7 +395,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = Vec<PathBuf>;\n+    type Output = Vec<(PathBuf, DependencyType)>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -329,7 +414,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Vec<(PathBuf, DependencyType)> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n@@ -363,14 +448,7 @@ impl Step for StartupObjects {\n \n             let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n-            target_deps.push(target);\n-        }\n-\n-        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n-            let target = sysroot_dir.join(obj);\n-            builder.copy(&src, &target);\n-            target_deps.push(target);\n+            target_deps.push((target, DependencyType::Target));\n         }\n \n         target_deps\n@@ -451,44 +529,6 @@ impl Step for Rustc {\n             false,\n         );\n \n-        // We used to build librustc_codegen_llvm as a separate step,\n-        // which produced a dylib that the compiler would dlopen() at runtime.\n-        // This meant that we only needed to make sure that libLLVM.so was\n-        // installed by the time we went to run a tool using it - since\n-        // librustc_codegen_llvm was effectively a standalone artifact,\n-        // other crates were completely oblivious to its dependency\n-        // on `libLLVM.so` during build time.\n-        //\n-        // However, librustc_codegen_llvm is now built as an ordinary\n-        // crate during the same step as the rest of the compiler crates.\n-        // This means that any crates depending on it will see the fact\n-        // that it uses `libLLVM.so` as a native library, and will\n-        // cause us to pass `-llibLLVM.so` to the linker when we link\n-        // a binary.\n-        //\n-        // For `rustc` itself, this works out fine.\n-        // During the `Assemble` step, we call `dist::maybe_install_llvm_dylib`\n-        // to copy libLLVM.so into the `stage` directory. We then link\n-        // the compiler binary, which will find `libLLVM.so` in the correct place.\n-        //\n-        // However, this is insufficient for tools that are build against stage0\n-        // (e.g. stage1 rustdoc). Since `Assemble` for stage0 doesn't actually do anything,\n-        // we won't have `libLLVM.so` in the stage0 sysroot. In the past, this wasn't\n-        // a problem - we would copy the tool binary into its correct stage directory\n-        // (e.g. stage1 for a stage1 rustdoc built against a stage0 compiler).\n-        // Since libLLVM.so wasn't resolved until runtime, it was fine for it to\n-        // not exist while we were building it.\n-        //\n-        // To ensure that we can still build stage1 tools against a stage0 compiler,\n-        // we explicitly copy libLLVM.so into the stage0 sysroot when building\n-        // the stage0 compiler. This ensures that tools built against stage0\n-        // will see libLLVM.so at build time, making the linker happy.\n-        if compiler.stage == 0 {\n-            builder.info(&format!(\"Installing libLLVM.so to stage 0 ({})\", compiler.host));\n-            let sysroot = builder.sysroot(compiler);\n-            dist::maybe_install_llvm_dylib(builder, compiler.host, &sysroot);\n-        }\n-\n         builder.ensure(RustcLink {\n             compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n@@ -541,9 +581,13 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n     // librustc_llvm and librustc_codegen_llvm.\n     //\n     // Note that this is disabled if LLVM itself is disabled or we're in a check\n-    // build, where if we're in a check build there's no need to build all of\n-    // LLVM and such.\n-    if builder.config.llvm_enabled() && builder.kind != Kind::Check {\n+    // build. If we are in a check build we still go ahead here presuming we've\n+    // detected that LLVM is alreay built and good to go which helps prevent\n+    // busting caches (e.g. like #71152).\n+    if builder.config.llvm_enabled()\n+        && (builder.kind != Kind::Check\n+            || crate::native::prebuilt_llvm_config(builder, target).is_ok())\n+    {\n         if builder.is_rust_llvm(target) {\n             cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n         }\n@@ -671,6 +715,30 @@ impl Step for Sysroot {\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n+\n+        // Symlink the source root into the same location inside the sysroot,\n+        // where `rust-src` component would go (`$sysroot/lib/rustlib/src/rust`),\n+        // so that any tools relying on `rust-src` also work for local builds,\n+        // and also for translating the virtual `/rustc/$hash` back to the real\n+        // directory (for running tests with `rust.remap-debuginfo = true`).\n+        let sysroot_lib_rustlib_src = sysroot.join(\"lib/rustlib/src\");\n+        t!(fs::create_dir_all(&sysroot_lib_rustlib_src));\n+        let sysroot_lib_rustlib_src_rust = sysroot_lib_rustlib_src.join(\"rust\");\n+        if let Err(e) = symlink_dir(&builder.config, &builder.src, &sysroot_lib_rustlib_src_rust) {\n+            eprintln!(\n+                \"warning: creating symbolic link `{}` to `{}` failed with {}\",\n+                sysroot_lib_rustlib_src_rust.display(),\n+                builder.src.display(),\n+                e,\n+            );\n+            if builder.config.rust_remap_debuginfo {\n+                eprintln!(\n+                    \"warning: some `src/test/ui` tests will fail when lacking `{}`\",\n+                    sysroot_lib_rustlib_src_rust.display(),\n+                );\n+            }\n+        }\n+\n         INTERNER.intern_path(sysroot)\n     }\n }\n@@ -768,7 +836,8 @@ impl Step for Assemble {\n \n         // Ensure that `libLLVM.so` ends up in the newly build compiler directory,\n         // so that it can be found when the newly built `rustc` is run.\n-        dist::maybe_install_llvm_dylib(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_runtime(builder, target_compiler.host, &sysroot);\n+        dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);\n \n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n@@ -792,14 +861,17 @@ pub fn add_to_sysroot(\n     sysroot_host_dst: &Path,\n     stamp: &Path,\n ) {\n+    let self_contained_dst = &sysroot_dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if host {\n-            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n-        } else {\n-            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n-        }\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        let dst = match dependency_type {\n+            DependencyType::Host => sysroot_host_dst,\n+            DependencyType::Target => sysroot_dst,\n+            DependencyType::TargetSelfContained => self_contained_dst,\n+        };\n+        builder.copy(&path, &dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -808,7 +880,7 @@ pub fn run_cargo(\n     cargo: Cargo,\n     tail_args: Vec<String>,\n     stamp: &Path,\n-    additional_target_deps: Vec<PathBuf>,\n+    additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n@@ -859,15 +931,15 @@ pub fn run_cargo(\n             if filename.starts_with(&host_root_dir) {\n                 // Unless it's a proc macro used in the compiler\n                 if crate_types.iter().any(|t| t == \"proc-macro\") {\n-                    deps.push((filename.to_path_buf(), true));\n+                    deps.push((filename.to_path_buf(), DependencyType::Host));\n                 }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push((filename.to_path_buf(), false));\n+                deps.push((filename.to_path_buf(), DependencyType::Target));\n                 continue;\n             }\n \n@@ -919,17 +991,21 @@ pub fn run_cargo(\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push((candidate, false));\n+                deps.push((candidate, DependencyType::Target));\n             }\n         }\n-        deps.push((path_to_add.into(), false));\n+        deps.push((path_to_add.into(), DependencyType::Target));\n     }\n \n-    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n+    deps.extend(additional_target_deps);\n     deps.sort();\n     let mut new_contents = Vec::new();\n-    for (dep, proc_macro) in deps.iter() {\n-        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n+    for (dep, dependency_type) in deps.iter() {\n+        new_contents.extend(match *dependency_type {\n+            DependencyType::Host => b\"h\",\n+            DependencyType::Target => b\"t\",\n+            DependencyType::TargetSelfContained => b\"s\",\n+        });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n@@ -949,7 +1025,11 @@ pub fn stream_cargo(\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    let mut message_format = String::from(\"json-render-diagnostics\");\n+    let mut message_format = if builder.config.json_output {\n+        String::from(\"json\")\n+    } else {\n+        String::from(\"json-render-diagnostics\")\n+    };\n     if let Some(s) = &builder.config.rustc_error_format {\n         message_format.push_str(\",json-diagnostic-\");\n         message_format.push_str(s);\n@@ -973,7 +1053,13 @@ pub fn stream_cargo(\n     for line in stdout.lines() {\n         let line = t!(line);\n         match serde_json::from_str::<CargoMessage<'_>>(&line) {\n-            Ok(msg) => cb(msg),\n+            Ok(msg) => {\n+                if builder.config.json_output {\n+                    // Forward JSON to stdout.\n+                    println!(\"{}\", line);\n+                }\n+                cb(msg)\n+            }\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line),\n         }\n@@ -1008,4 +1094,7 @@ pub enum CargoMessage<'a> {\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n     },\n+    BuildFinished {\n+        success: bool,\n+    },\n }"}, {"sha": "771f952abc013b4827ce51c25241e5eb159a19c2", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -48,6 +48,7 @@ pub struct Config {\n     pub ignore_git: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: bool,\n \n@@ -84,7 +85,6 @@ pub struct Config {\n \n     pub use_lld: bool,\n     pub lld_enabled: bool,\n-    pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n \n     pub llvm_cflags: Option<String>,\n@@ -97,6 +97,7 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n+    pub rust_debug_assertions_std: bool,\n     pub rust_debuginfo_level_rustc: u32,\n     pub rust_debuginfo_level_std: u32,\n     pub rust_debuginfo_level_tools: u32,\n@@ -211,6 +212,8 @@ struct Build {\n     host: Vec<String>,\n     #[serde(default)]\n     target: Vec<String>,\n+    // This is ignored, the rust code always gets the build directory from the `BUILD_DIR` env variable\n+    build_dir: Option<String>,\n     cargo: Option<String>,\n     rustc: Option<String>,\n     rustfmt: Option<String>, /* allow bootstrap.py to use rustfmt key */\n@@ -312,6 +315,7 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n+    debug_assertions_std: Option<bool>,\n     debuginfo_level: Option<u32>,\n     debuginfo_level_rustc: Option<u32>,\n     debuginfo_level_std: Option<u32>,\n@@ -334,7 +338,6 @@ struct Rust {\n     lld: Option<bool>,\n     use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n-    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -415,6 +418,7 @@ impl Config {\n         let mut config = Config::default_opts();\n         config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n+        config.json_output = flags.json_output;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n         config.jobs = flags.jobs.map(threads_from_config);\n@@ -516,6 +520,7 @@ impl Config {\n         let mut llvm_assertions = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n+        let mut debug_assertions_std = None;\n         let mut debuginfo_level = None;\n         let mut debuginfo_level_rustc = None;\n         let mut debuginfo_level_std = None;\n@@ -558,6 +563,7 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n             debuginfo_level = rust.debuginfo_level;\n             debuginfo_level_rustc = rust.debuginfo_level_rustc;\n             debuginfo_level_std = rust.debuginfo_level_std;\n@@ -581,7 +587,6 @@ impl Config {\n             }\n             set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n@@ -657,6 +662,8 @@ impl Config {\n \n         let default = debug == Some(true);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_debug_assertions_std =\n+            debug_assertions_std.unwrap_or(config.rust_debug_assertions);\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n             debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {"}, {"sha": "47673ce1e870304894f260e5d33925db20cf2f45", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -57,7 +57,6 @@ def v(*args):\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n-o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")\n@@ -142,6 +141,8 @@ def v(*args):\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"qemu-riscv64-rootfs\", \"target.riscv64gc-unknown-linux-gnu.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"experimental-targets\", \"llvm.experimental-targets\",\n   \"experimental LLVM targets to build\")\n v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")"}, {"sha": "8a2463d378fdb8642cea130e3bd1c10fb5bbd3ba", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 80, "deletions": 197, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -22,7 +22,7 @@ use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n-use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n@@ -38,8 +38,6 @@ pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n         format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n     } else if component == \"llvm-tools\" {\n         format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n-    } else if component == \"lldb\" {\n-        format!(\"{}-{}\", component, builder.lldb_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, builder.rust_package_vers())\n@@ -308,7 +306,12 @@ fn make_win_dist(\n     }\n \n     //Copy platform tools to platform-specific bin directory\n-    let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n+    let target_bin_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"bin\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n         builder.copy_to_folder(&src, &target_bin_dir);\n@@ -323,7 +326,12 @@ fn make_win_dist(\n     );\n \n     //Copy platform libs to platform-specific lib directory\n-    let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n+    let target_lib_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"lib\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n         builder.copy_to_folder(&src, &target_lib_dir);\n@@ -516,7 +524,7 @@ impl Step for Rustc {\n             // components like the llvm tools and LLD. LLD is included below and\n             // tools/LLDB come later, so let's just throw it in the rustc\n             // component for now.\n-            maybe_install_llvm_dylib(builder, host, image);\n+            maybe_install_llvm_runtime(builder, host, image);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -621,19 +629,21 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"natvis/libcore.natvis\");\n             cp_debugger_script(\"natvis/libstd.natvis\");\n         } else {\n-            cp_debugger_script(\"debugger_pretty_printers_common.py\");\n+            cp_debugger_script(\"rust_types.py\");\n \n             // gdb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"), 0o755);\n             builder.install(&builder.src.join(\"src/etc/rust-gdbgui\"), &sysroot.join(\"bin\"), 0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n-            cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n+            cp_debugger_script(\"gdb_lookup.py\");\n+            cp_debugger_script(\"gdb_providers.py\");\n \n             // lldb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"), 0o755);\n \n-            cp_debugger_script(\"lldb_rust_formatters.py\");\n+            cp_debugger_script(\"lldb_lookup.py\");\n+            cp_debugger_script(\"lldb_providers.py\");\n         }\n     }\n }\n@@ -652,9 +662,13 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if !host || builder.config.build == target {\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        if dependency_type == DependencyType::TargetSelfContained {\n+            builder.copy(&path, &self_contained_dst.join(path.file_name().unwrap()));\n+        } else if dependency_type == DependencyType::Target || builder.config.build == target {\n             builder.copy(&path, &dst.join(path.file_name().unwrap()));\n         }\n     }\n@@ -1330,7 +1344,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1348,7 +1362,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1368,16 +1382,10 @@ impl Step for Clippy {\n         // state for clippy isn't testing.\n         let clippy = builder\n             .ensure(tool::Clippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n         let cargoclippy = builder\n             .ensure(tool::CargoClippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"cargo clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n \n         builder.install(&clippy, &image.join(\"bin\"), 0o755);\n         builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n@@ -1416,7 +1424,7 @@ impl Step for Clippy {\n         builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1651,7 +1659,6 @@ impl Step for Extended {\n         let llvm_tools_installer = builder.ensure(LlvmTools { target });\n         let clippy_installer = builder.ensure(Clippy { compiler, target });\n         let miri_installer = builder.ensure(Miri { compiler, target });\n-        let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n@@ -1683,11 +1690,10 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n-        tarballs.extend(clippy_installer.clone());\n+        tarballs.push(clippy_installer);\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.extend(llvm_tools_installer);\n-        tarballs.extend(lldb_installer);\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n         if builder.config.docs {\n@@ -1761,9 +1767,6 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n-            if clippy_installer.is_none() {\n-                contents = filter(&contents, \"clippy\");\n-            }\n             if miri_installer.is_none() {\n                 contents = filter(&contents, \"miri\");\n             }\n@@ -1805,13 +1808,11 @@ impl Step for Extended {\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"rust-analysis\");\n+            prepare(\"clippy\");\n \n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1863,12 +1864,10 @@ impl Step for Extended {\n             prepare(\"rust-analysis\");\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n+            prepare(\"clippy\");\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1989,25 +1988,23 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            if clippy_installer.is_some() {\n-                builder.run(\n-                    Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"clippy\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\")\n-                        .arg(\"ClippyGroup\")\n-                        .arg(\"-dr\")\n-                        .arg(\"Clippy\")\n-                        .arg(\"-var\")\n-                        .arg(\"var.ClippyDir\")\n-                        .arg(\"-out\")\n-                        .arg(exe.join(\"ClippyGroup.wxs\"))\n-                        .arg(\"-t\")\n-                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n-                );\n-            }\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"clippy\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"ClippyGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Clippy\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.ClippyDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"ClippyGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n             if miri_installer.is_some() {\n                 builder.run(\n                     Command::new(&heat)\n@@ -2073,6 +2070,7 @@ impl Step for Extended {\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n+                    .arg(\"-dClippyDir=clippy\")\n                     .arg(\"-arch\")\n                     .arg(&arch)\n                     .arg(\"-out\")\n@@ -2083,9 +2081,6 @@ impl Step for Extended {\n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n-                if clippy_installer.is_some() {\n-                    cmd.arg(\"-dClippyDir=clippy\");\n-                }\n                 if miri_installer.is_some() {\n                     cmd.arg(\"-dMiriDir=miri\");\n                 }\n@@ -2101,12 +2096,10 @@ impl Step for Extended {\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n+            candle(\"ClippyGroup.wxs\".as_ref());\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n-            if clippy_installer.is_some() {\n-                candle(\"ClippyGroup.wxs\".as_ref());\n-            }\n             if miri_installer.is_some() {\n                 candle(\"MiriGroup.wxs\".as_ref());\n             }\n@@ -2138,14 +2131,12 @@ impl Step for Extended {\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n+                .arg(\"ClippyGroup.wixobj\")\n                 .current_dir(&exe);\n \n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n-            if clippy_installer.is_some() {\n-                cmd.arg(\"ClippyGroup.wixobj\");\n-            }\n             if miri_installer.is_some() {\n                 cmd.arg(\"MiriGroup.wixobj\");\n             }\n@@ -2243,7 +2234,6 @@ impl Step for HashSign {\n         cmd.arg(builder.package_vers(&builder.release_num(\"miri\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n         cmd.arg(builder.llvm_tools_package_vers());\n-        cmd.arg(builder.lldb_package_vers());\n \n         builder.create_dir(&distdir(builder));\n \n@@ -2254,27 +2244,18 @@ impl Step for HashSign {\n     }\n }\n \n-// Maybe add libLLVM.so to the lib-dir. It will only have been built if\n-// LLVM tools are linked dynamically.\n-//\n-// We add this to both the libdir of the rustc binary itself (for it to load at\n-// runtime) and also to the target directory so it can find it at link-time.\n-//\n-// Note: This function does no yet support Windows but we also don't support\n-//       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+/// Maybe add libLLVM.so to the given destination lib-dir. It will only have\n+/// been built if LLVM tools are linked dynamically.\n+///\n+/// Note: This function does not yet support Windows, but we also don't support\n+///       linking LLVM tools dynamically on Windows yet.\n+fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdir: &Path) {\n     let src_libdir = builder.llvm_out(target).join(\"lib\");\n-    let dst_libdir1 = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n-    let dst_libdir2 =\n-        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n-    t!(fs::create_dir_all(&dst_libdir1));\n-    t!(fs::create_dir_all(&dst_libdir2));\n \n     if target.contains(\"apple-darwin\") {\n         let llvm_dylib_path = src_libdir.join(\"libLLVM.dylib\");\n         if llvm_dylib_path.exists() {\n-            builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-            builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+            builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n         }\n         return;\n     }\n@@ -2288,11 +2269,23 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>, target: Interned<String>,\n             panic!(\"dist: Error calling canonicalize path `{}`: {}\", llvm_dylib_path.display(), e);\n         });\n \n-        builder.install(&llvm_dylib_path, &dst_libdir1, 0o644);\n-        builder.install(&llvm_dylib_path, &dst_libdir2, 0o644);\n+        builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n     }\n }\n \n+/// Maybe add libLLVM.so to the target lib-dir for linking.\n+pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n+/// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n+pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+    let dst_libdir =\n+        sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n+    maybe_install_llvm(builder, target, &dst_libdir);\n+}\n+\n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n     pub target: Interned<String>,\n@@ -2340,6 +2333,12 @@ impl Step for LlvmTools {\n             builder.install(&exe, &dst_bindir, 0o755);\n         }\n \n+        // Copy libLLVM.so to the target lib dir as well, so the RPATH like\n+        // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n+        // of `rustc-dev` to support the inherited `-lLLVM` when using the\n+        // compiler libraries.\n+        maybe_install_llvm_target(builder, target, &image);\n+\n         // Prepare the overlay\n         let overlay = tmp.join(\"llvm-tools-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n@@ -2370,119 +2369,3 @@ impl Step for LlvmTools {\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n-\n-#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n-pub struct Lldb {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Lldb {\n-    type Output = Option<PathBuf>;\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Lldb { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let target = self.target;\n-\n-        if builder.config.dry_run {\n-            return None;\n-        }\n-\n-        let bindir = builder.llvm_out(target).join(\"bin\");\n-        let lldb_exe = bindir.join(exe(\"lldb\", &target));\n-        if !lldb_exe.exists() {\n-            return None;\n-        }\n-\n-        builder.info(&format!(\"Dist Lldb ({})\", target));\n-        let src = builder.src.join(\"src/llvm-project/lldb\");\n-        let name = pkgname(builder, \"lldb\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"lldb-image\");\n-        drop(fs::remove_dir_all(&image));\n-\n-        // Prepare the image directory\n-        let root = image.join(\"lib/rustlib\").join(&*target);\n-        let dst = root.join(\"bin\");\n-        t!(fs::create_dir_all(&dst));\n-        for program in &[\"lldb\", \"lldb-argdumper\", \"lldb-mi\", \"lldb-server\"] {\n-            let exe = bindir.join(exe(program, &target));\n-            builder.install(&exe, &dst, 0o755);\n-        }\n-\n-        // The libraries.\n-        let libdir = builder.llvm_out(target).join(\"lib\");\n-        let dst = root.join(\"lib\");\n-        t!(fs::create_dir_all(&dst));\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = entry.unwrap();\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"liblldb.\") && !name.ends_with(\".a\") {\n-                    if t!(entry.file_type()).is_symlink() {\n-                        builder.copy_to_folder(&entry.path(), &dst);\n-                    } else {\n-                        builder.install(&entry.path(), &dst, 0o755);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The lldb scripts might be installed in lib/python$version\n-        // or in lib64/python$version.  If lib64 exists, use it;\n-        // otherwise lib.\n-        let libdir = builder.llvm_out(target).join(\"lib64\");\n-        let (libdir, libdir_name) = if libdir.exists() {\n-            (libdir, \"lib64\")\n-        } else {\n-            (builder.llvm_out(target).join(\"lib\"), \"lib\")\n-        };\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = t!(entry);\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"python\") {\n-                    let dst = root.join(libdir_name).join(entry.file_name());\n-                    t!(fs::create_dir_all(&dst));\n-                    builder.cp_r(&entry.path(), &dst);\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"lldb-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.lldb_vers());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=lldb-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=lldb-preview\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n-    }\n-}"}, {"sha": "6d7fb7acfcb04defd4be6336b5cb44839804d29f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -70,6 +70,35 @@ book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n+fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {\n+    if builder.config.dry_run || !builder.config.cmd.open() {\n+        return;\n+    }\n+\n+    let path = path.as_ref();\n+    builder.info(&format!(\"Opening doc {}\", path.display()));\n+    if let Err(err) = opener::open(path) {\n+        builder.info(&format!(\"{}\\n\", err));\n+    }\n+}\n+\n+// \"src/libstd\" -> [\"src\", \"libstd\"]\n+//\n+// Used for deciding whether a particular step is one requested by the user on\n+// the `x.py doc` command line, which determines whether `--open` will open that\n+// page.\n+fn components_simplified(path: &PathBuf) -> Vec<&str> {\n+    path.iter().map(|component| component.to_str().unwrap_or(\"???\")).collect()\n+}\n+\n+fn is_explicit_request(builder: &Builder<'_>, path: &str) -> bool {\n+    builder\n+        .paths\n+        .iter()\n+        .map(components_simplified)\n+        .any(|requested| requested.iter().copied().eq(path.split(\"/\")))\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n     target: Interned<String>,\n@@ -200,6 +229,12 @@ impl Step for TheBook {\n \n             invoke_rustdoc(builder, compiler, target, path);\n         }\n+\n+        if is_explicit_request(builder, \"src/doc/book\") {\n+            let out = builder.doc_out(target);\n+            let index = out.join(\"book\").join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -313,6 +348,9 @@ impl Step for Standalone {\n             }\n \n             let mut cmd = builder.rustdoc_cmd(compiler);\n+            // Needed for --index-page flag\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n+\n             cmd.arg(\"--html-after-content\")\n                 .arg(&footer)\n                 .arg(\"--html-before-content\")\n@@ -335,6 +373,13 @@ impl Step for Standalone {\n             }\n             builder.run(&mut cmd);\n         }\n+\n+        // We open doc/index.html as the default if invoked as `x.py doc --open`\n+        // with no particular explicit doc requested (e.g. src/libcore).\n+        if builder.paths.is_empty() || is_explicit_request(builder, \"src/doc\") {\n+            let index = out.join(\"index.html\");\n+            open(builder, &index);\n+        }\n     }\n }\n \n@@ -391,11 +436,11 @@ impl Step for Std {\n \n         let run_cargo_rustdoc_for = |package: &str| {\n             let mut cargo = builder.cargo(compiler, Mode::Std, target, \"rustdoc\");\n-            compile::std_cargo(builder, target, &mut cargo);\n+            compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n \n             // Keep a whitelist so we do not build internal stdlib crates, these will be\n             // build by the rustc step later if enabled.\n-            cargo.arg(\"-Z\").arg(\"unstable-options\").arg(\"-p\").arg(package);\n+            cargo.arg(\"-p\").arg(package);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links.\n             // FIXME: Cargo should probably do this itself.\n@@ -406,17 +451,34 @@ impl Step for Std {\n                 .arg(\"rust.css\")\n                 .arg(\"--markdown-no-toc\")\n                 .arg(\"--generate-redirect-pages\")\n+                .arg(\"-Z\")\n+                .arg(\"unstable-options\")\n                 .arg(\"--resource-suffix\")\n                 .arg(crate::channel::CFG_RELEASE_NUM)\n                 .arg(\"--index-page\")\n                 .arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo.into());\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n+        let krates = [\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"];\n+        for krate in &krates {\n             run_cargo_rustdoc_for(krate);\n         }\n         builder.cp_r(&my_out, &out);\n+\n+        // Look for src/libstd, src/libcore etc in the `x.py doc` arguments and\n+        // open the corresponding rendered docs.\n+        for path in builder.paths.iter().map(components_simplified) {\n+            if path.get(0) == Some(&\"src\")\n+                && path.get(1).map_or(false, |dir| dir.starts_with(\"lib\"))\n+            {\n+                let requested_crate = &path[1][3..];\n+                if krates.contains(&requested_crate) {\n+                    let index = out.join(requested_crate).join(\"index.html\");\n+                    open(builder, &index);\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -473,7 +535,11 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\n+            \"RUSTDOCFLAGS\",\n+            \"--document-private-items \\\n+            --enable-index-page -Zunstable-options\",\n+        );\n         compile::rustc_cargo(builder, &mut cargo, target);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -482,8 +548,8 @@ impl Step for Rustc {\n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n-            let interned_root_crate = INTERNER.intern_str(root_crate);\n-            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n+            compiler_crates\n+                .extend(builder.in_tree_crates(root_crate).into_iter().map(|krate| krate.name));\n         }\n \n         for krate in &compiler_crates {\n@@ -498,22 +564,6 @@ impl Step for Rustc {\n     }\n }\n \n-fn find_compiler_crates(\n-    builder: &Builder<'_>,\n-    name: &Interned<String>,\n-    crates: &mut HashSet<Interned<String>>,\n-) {\n-    // Add current crate.\n-    crates.insert(*name);\n-\n-    // Look for dependencies.\n-    for dep in builder.crates.get(name).unwrap().deps.iter() {\n-        if builder.crates.get(dep).unwrap().is_local(builder) {\n-            find_compiler_crates(builder, dep, crates);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,"}, {"sha": "f477c752933856e0ffd07747f963dcf20fff026c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 78, "deletions": 25, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -3,19 +3,17 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::fs;\n+use std::env;\n use std::path::PathBuf;\n use std::process;\n \n use getopts::Options;\n \n use crate::builder::Builder;\n+use crate::cache::{Interned, INTERNER};\n use crate::config::Config;\n-use crate::metadata;\n use crate::{Build, DocTests};\n \n-use crate::cache::{Interned, INTERNER};\n-\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n@@ -31,6 +29,7 @@ pub struct Flags {\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub dry_run: bool,\n \n     // This overrides the deny-warnings configuration option,\n@@ -60,6 +59,7 @@ pub enum Subcommand {\n     },\n     Doc {\n         paths: Vec<PathBuf>,\n+        open: bool,\n     },\n     Test {\n         paths: Vec<PathBuf>,\n@@ -86,6 +86,9 @@ pub enum Subcommand {\n     Install {\n         paths: Vec<PathBuf>,\n     },\n+    Run {\n+        paths: Vec<PathBuf>,\n+    },\n }\n \n impl Default for Subcommand {\n@@ -102,17 +105,18 @@ impl Flags {\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n-    build       Compile either the compiler or libraries\n-    check       Compile either the compiler or libraries, using cargo check\n+    build, b    Compile either the compiler or libraries\n+    check, c    Compile either the compiler or libraries, using cargo check\n     clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n     fix         Run cargo fix\n     fmt         Run rustfmt\n-    test        Build and run some test suites\n+    test, t     Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n+    run, r      Run tools contained in this repository\n \n To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n@@ -143,7 +147,12 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"N\",\n         );\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n-        opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n+        let j_msg = format!(\n+            \"number of jobs to run in parallel; \\\n+             defaults to {} (this host's logical CPU count)\",\n+            num_cpus::get()\n+        );\n+        opts.optopt(\"j\", \"jobs\", &j_msg, \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n         opts.optopt(\n             \"\",\n@@ -152,6 +161,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n+        opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n         opts.optopt(\n             \"\",\n             \"llvm-skip-rebuild\",\n@@ -178,16 +188,21 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         // there on out.\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n+                || (s == \"b\")\n                 || (s == \"check\")\n+                || (s == \"c\")\n                 || (s == \"clippy\")\n                 || (s == \"fix\")\n                 || (s == \"fmt\")\n                 || (s == \"test\")\n+                || (s == \"t\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n                 || (s == \"clean\")\n                 || (s == \"dist\")\n                 || (s == \"install\")\n+                || (s == \"run\")\n+                || (s == \"r\")\n         });\n         let subcommand = match subcommand {\n             Some(s) => s,\n@@ -203,7 +218,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -237,6 +252,9 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"bench\" => {\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             }\n+            \"doc\" => {\n+                opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n+            }\n             \"clean\" => {\n                 opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n             }\n@@ -278,7 +296,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n-            \"build\" => {\n+            \"build\" | \"b\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -305,7 +323,7 @@ Arguments:\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n                 );\n             }\n-            \"check\" => {\n+            \"check\" | \"c\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -355,7 +373,7 @@ Arguments:\n         ./x.py fmt --check\",\n                 );\n             }\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -393,31 +411,37 @@ Arguments:\n         ./x.py doc src/doc/book\n         ./x.py doc src/doc/nomicon\n         ./x.py doc src/doc/book src/libstd\n+        ./x.py doc src/libstd --open\n \n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n         ./x.py doc --stage 1\",\n                 );\n             }\n+            \"run\" | \"r\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to tools to build and run. For\n+    example:\n+\n+        ./x.py run src/tool/expand-yaml-anchors\n+\n+    At least a tool needs to be called.\",\n+                );\n+            }\n             _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n-        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n-            if fs::metadata(\"config.toml\").is_ok() {\n-                Some(PathBuf::from(\"config.toml\"))\n-            } else {\n-                None\n-            }\n-        });\n+        let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n \n         // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n-            let mut build = Build::new(config);\n-            metadata::build(&mut build);\n+            let build = Build::new(config);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n@@ -434,11 +458,11 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => Subcommand::Build { paths },\n-            \"check\" => Subcommand::Check { paths },\n+            \"build\" | \"b\" => Subcommand::Build { paths },\n+            \"check\" | \"c\" => Subcommand::Check { paths },\n             \"clippy\" => Subcommand::Clippy { paths },\n             \"fix\" => Subcommand::Fix { paths },\n-            \"test\" => Subcommand::Test {\n+            \"test\" | \"t\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n@@ -456,7 +480,7 @@ Arguments:\n                 },\n             },\n             \"bench\" => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            \"doc\" => Subcommand::Doc { paths },\n+            \"doc\" => Subcommand::Doc { paths, open: matches.opt_present(\"open\") },\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -468,17 +492,39 @@ Arguments:\n             \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\") },\n             \"dist\" => Subcommand::Dist { paths },\n             \"install\" => Subcommand::Install { paths },\n+            \"run\" | \"r\" => {\n+                if paths.is_empty() {\n+                    println!(\"\\nrun requires at least a path!\\n\");\n+                    usage(1, &opts, &subcommand_help, &extra_help);\n+                }\n+                Subcommand::Run { paths }\n+            }\n             _ => {\n                 usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n+        if let Subcommand::Check { .. } = &cmd {\n+            if matches.opt_str(\"stage\").is_some() {\n+                println!(\"{}\", \"--stage not supported for x.py check, always treated as stage 0\");\n+                process::exit(1);\n+            }\n+            if matches.opt_str(\"keep-stage\").is_some() {\n+                println!(\n+                    \"{}\",\n+                    \"--keep-stage not supported for x.py check, only one stage available\"\n+                );\n+                process::exit(1);\n+            }\n+        }\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n+            json_output: matches.opt_present(\"json-output\"),\n             keep_stage: matches\n                 .opt_strs(\"keep-stage\")\n                 .into_iter()\n@@ -568,6 +614,13 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn open(&self) -> bool {\n+        match *self {\n+            Subcommand::Doc { open, .. } => open,\n+            _ => false,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {"}, {"sha": "390b7e96b9a543cecdd806fe2369b10469bd9f50", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -4,7 +4,7 @@ use crate::Build;\n use build_helper::{output, t};\n use ignore::WalkBuilder;\n use std::path::Path;\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     let mut cmd = Command::new(&rustfmt);\n@@ -23,7 +23,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     if !status.success() {\n         eprintln!(\n             \"Running `{}` failed.\\nIf you're running `tidy`, \\\n-            try again with `--bless` flag. Or, you just want to format \\\n+            try again with `--bless`. Or, if you just want to format \\\n             code, run `./x.py fmt` instead.\",\n             cmd_debug,\n         );\n@@ -37,6 +37,9 @@ struct RustfmtConfig {\n }\n \n pub fn format(build: &Build, check: bool) {\n+    if build.config.dry_run {\n+        return;\n+    }\n     let mut builder = ignore::types::TypesBuilder::new();\n     builder.add_defaults();\n     builder.select(\"rust\");\n@@ -53,16 +56,48 @@ pub fn format(build: &Build, check: bool) {\n     for ignore in rustfmt_config.ignore {\n         ignore_fmt.add(&format!(\"!{}\", ignore)).expect(&ignore);\n     }\n-    let untracked_paths_output = output(\n-        Command::new(\"git\").arg(\"status\").arg(\"--porcelain\").arg(\"--untracked-files=normal\"),\n-    );\n-    let untracked_paths = untracked_paths_output\n-        .lines()\n-        .filter(|entry| entry.starts_with(\"??\"))\n-        .map(|entry| entry.split(\" \").nth(1).expect(\"every git status entry should list a path\"));\n-    for untracked_path in untracked_paths {\n-        eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n-        ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+    let git_available = match Command::new(\"git\")\n+        .arg(\"--version\")\n+        .stdout(Stdio::null())\n+        .stderr(Stdio::null())\n+        .status()\n+    {\n+        Ok(status) => status.success(),\n+        Err(_) => false,\n+    };\n+    if git_available {\n+        let in_working_tree = match Command::new(\"git\")\n+            .arg(\"rev-parse\")\n+            .arg(\"--is-inside-work-tree\")\n+            .stdout(Stdio::null())\n+            .stderr(Stdio::null())\n+            .status()\n+        {\n+            Ok(status) => status.success(),\n+            Err(_) => false,\n+        };\n+        if in_working_tree {\n+            let untracked_paths_output = output(\n+                Command::new(\"git\")\n+                    .arg(\"status\")\n+                    .arg(\"--porcelain\")\n+                    .arg(\"--untracked-files=normal\"),\n+            );\n+            let untracked_paths = untracked_paths_output\n+                .lines()\n+                .filter(|entry| entry.starts_with(\"??\"))\n+                .map(|entry| {\n+                    entry.split(\" \").nth(1).expect(\"every git status entry should list a path\")\n+                });\n+            for untracked_path in untracked_paths {\n+                eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n+                ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+            }\n+        } else {\n+            eprintln!(\"Not in git tree. Skipping git-aware format checks\");\n+        }\n+    } else {\n+        eprintln!(\"Could not find usable git. Skipping git-aware format checks\");\n     }\n     let ignore_fmt = ignore_fmt.build().unwrap();\n "}, {"sha": "fbdef9d8272f7686f61187dbed6330896eedbf6b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -70,7 +70,10 @@ fn install_sh(\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n+        fs::create_dir_all(p)\n+            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n+        fs::canonicalize(p)\n+            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n     });\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n@@ -214,10 +217,8 @@ install!((self, builder, _config),\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy {\n-            compiler: self.compiler,\n-            target: self.target,\n-        }).is_some() || Self::should_install(builder) {\n+        builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        if Self::should_install(builder) {\n             install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info("}, {"sha": "2fe9b06e42643916d84a2c59f52f34b28cae789a", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -103,7 +103,12 @@ pub unsafe fn setup(build: &mut Build) {\n     };\n \n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-    assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n+    assert!(\n+        !parent.is_null(),\n+        \"PID `{}` doesn't seem to exist: {}\",\n+        pid,\n+        io::Error::last_os_error()\n+    );\n     let mut parent_handle = ptr::null_mut();\n     let r = DuplicateHandle(\n         GetCurrentProcess(),"}, {"sha": "e7aeb08643c297c4c89d8b6c5ed2bb6f0abe5215", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -140,6 +140,7 @@ mod format;\n mod install;\n mod metadata;\n mod native;\n+mod run;\n mod sanity;\n mod test;\n mod tool;\n@@ -242,6 +243,7 @@ pub struct Build {\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n     initial_lld: PathBuf,\n+    initial_libdir: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -268,16 +270,22 @@ struct Crate {\n }\n \n impl Crate {\n-    fn is_local(&self, build: &Build) -> bool {\n-        self.path.starts_with(&build.config.src) && !self.path.to_string_lossy().ends_with(\"_shim\")\n-    }\n-\n     fn local_path(&self, build: &Build) -> PathBuf {\n-        assert!(self.is_local(build));\n         self.path.strip_prefix(&build.config.src).unwrap().into()\n     }\n }\n \n+/// When building Rust various objects are handled differently.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DependencyType {\n+    /// Libraries originating from proc-macros.\n+    Host,\n+    /// Typical Rust libraries.\n+    Target,\n+    /// Non Rust libraries and objects shipped to ease usage of certain targets.\n+    TargetSelfContained,\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -343,18 +351,39 @@ impl Build {\n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n-        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n-        let initial_lld = initial_sysroot\n-            .join(\"lib\")\n-            .join(\"rustlib\")\n-            .join(config.build)\n-            .join(\"bin\")\n-            .join(\"rust-lld\");\n+        let initial_target_libdir_str = if config.dry_run {\n+            \"/dummy/lib/path/to/lib/\".to_string()\n+        } else {\n+            output(\n+                Command::new(&config.initial_rustc)\n+                    .arg(\"--target\")\n+                    .arg(config.build)\n+                    .arg(\"--print\")\n+                    .arg(\"target-libdir\"),\n+            )\n+        };\n+        let initial_target_dir = Path::new(&initial_target_libdir_str).parent().unwrap();\n+        let initial_lld = initial_target_dir.join(\"bin\").join(\"rust-lld\");\n+\n+        let initial_sysroot = if config.dry_run {\n+            \"/dummy\".to_string()\n+        } else {\n+            output(Command::new(&config.initial_rustc).arg(\"--print\").arg(\"sysroot\"))\n+        };\n+        let initial_libdir = initial_target_dir\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap()\n+            .strip_prefix(initial_sysroot.trim())\n+            .unwrap()\n+            .to_path_buf();\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             initial_lld,\n+            initial_libdir,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),\n@@ -739,19 +768,18 @@ impl Build {\n         self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n-    fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n+    fn debuginfo_map_to(&self, which: GitRepo) -> Option<String> {\n         if !self.config.rust_remap_debuginfo {\n             return None;\n         }\n \n-        let path = match which {\n+        match which {\n             GitRepo::Rustc => {\n                 let sha = self.rust_sha().unwrap_or(channel::CFG_RELEASE_NUM);\n-                format!(\"/rustc/{}\", sha)\n+                Some(format!(\"/rustc/{}\", sha))\n             }\n-            GitRepo::Llvm => String::from(\"/rustc/llvm\"),\n-        };\n-        Some(format!(\"{}={}\", self.src.display(), path))\n+            GitRepo::Llvm => Some(String::from(\"/rustc/llvm\")),\n+        }\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -786,7 +814,8 @@ impl Build {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n-        if let Some(map) = self.debuginfo_map(which) {\n+        if let Some(map_to) = self.debuginfo_map_to(which) {\n+            let map = format!(\"{}={}\", self.src.display(), map_to);\n             let cc = self.cc(target);\n             if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n                 base.push(format!(\"-fdebug-prefix-map={}\", map));\n@@ -940,29 +969,15 @@ impl Build {\n             return s;\n         }\n \n-        let beta = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"beta\").current_dir(&self.src),\n-        );\n-        let beta = beta.trim().split_whitespace().next().unwrap();\n-        let master = output(\n-            Command::new(\"git\").arg(\"ls-remote\").arg(\"origin\").arg(\"master\").current_dir(&self.src),\n-        );\n-        let master = master.trim().split_whitespace().next().unwrap();\n-\n-        // Figure out where the current beta branch started.\n-        let base = output(\n-            Command::new(\"git\").arg(\"merge-base\").arg(beta).arg(master).current_dir(&self.src),\n-        );\n-        let base = base.trim();\n-\n-        // Next figure out how many merge commits happened since we branched off\n-        // beta. That's our beta number!\n+        // Figure out how many merge commits happened since we branched off master.\n+        // That's our beta number!\n+        // (Note that we use a `..` range, not the `...` symmetric difference.)\n         let count = output(\n             Command::new(\"git\")\n                 .arg(\"rev-list\")\n                 .arg(\"--count\")\n                 .arg(\"--merges\")\n-                .arg(format!(\"{}...HEAD\", base))\n+                .arg(\"refs/remotes/origin/master..HEAD\")\n                 .current_dir(&self.src),\n         );\n         let n = count.trim().parse().unwrap();\n@@ -1028,14 +1043,6 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn lldb_package_vers(&self) -> String {\n-        self.package_vers(channel::CFG_RELEASE_NUM)\n-    }\n-\n-    fn lldb_vers(&self) -> String {\n-        self.rust_version()\n-    }\n-\n     fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }\n@@ -1078,25 +1085,37 @@ impl Build {\n         }\n     }\n \n+    /// Returns a Vec of all the dependencies of the given root crate,\n+    /// including transitive dependencies and the root itself. Only includes\n+    /// \"local\" crates (those in the local source tree, not from a registry).\n     fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            if krate.is_local(self) {\n-                ret.push(krate);\n-            }\n+            ret.push(krate);\n             for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n+                // Don't include optional deps if their features are not\n+                // enabled. Ideally this would be computed from `cargo\n+                // metadata --features \u2026`, but that is somewhat slow. Just\n+                // skip `build_helper` since there aren't any operations we\n+                // want to perform on it. In the future, we may want to\n+                // consider just filtering all build and dev dependencies in\n+                // metadata::build.\n+                if visited.insert(dep)\n+                    && dep != \"build_helper\"\n+                    && (dep != \"profiler_builtins\" || self.config.profiler)\n+                    && (dep != \"rustc_codegen_llvm\" || self.config.llvm_enabled())\n+                {\n                     list.push(*dep);\n                 }\n             }\n         }\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, DependencyType)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1109,9 +1128,14 @@ impl Build {\n             if part.is_empty() {\n                 continue;\n             }\n-            let host = part[0] as char == 'h';\n+            let dependency_type = match part[0] as char {\n+                'h' => DependencyType::Host,\n+                's' => DependencyType::TargetSelfContained,\n+                't' => DependencyType::Target,\n+                _ => unreachable!(),\n+            };\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n-            paths.push((path, host));\n+            paths.push((path, dependency_type));\n         }\n         paths\n     }"}, {"sha": "a38391c7b88f28f31125681682e41bc4441e1d76", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,5 +1,3 @@\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n use std::path::PathBuf;\n use std::process::Command;\n \n@@ -12,7 +10,6 @@ use crate::{Build, Crate};\n #[derive(Deserialize)]\n struct Output {\n     packages: Vec<Package>,\n-    resolve: Resolve,\n }\n \n #[derive(Deserialize)]\n@@ -21,72 +18,39 @@ struct Package {\n     name: String,\n     source: Option<String>,\n     manifest_path: String,\n+    dependencies: Vec<Dependency>,\n }\n \n #[derive(Deserialize)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(Deserialize)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n+struct Dependency {\n+    name: String,\n+    source: Option<String>,\n }\n \n pub fn build(build: &mut Build) {\n-    let mut resolves = Vec::new();\n-    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n-    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n-    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n-\n-    let mut id2name = HashMap::with_capacity(build.crates.len());\n-    for (name, krate) in build.crates.iter() {\n-        id2name.insert(krate.id.clone(), name.clone());\n-    }\n-\n-    for node in resolves {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.insert(*dep);\n-        }\n-    }\n-}\n-\n-fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo\n         .arg(\"metadata\")\n         .arg(\"--format-version\")\n         .arg(\"1\")\n-        .arg(\"--features\")\n-        .arg(features)\n+        .arg(\"--no-deps\")\n         .arg(\"--manifest-path\")\n-        .arg(build.src.join(krate).join(\"Cargo.toml\"));\n+        .arg(build.src.join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(name, Crate { name, id: package.id, deps: HashSet::new(), path });\n+            let deps = package\n+                .dependencies\n+                .into_iter()\n+                .filter(|dep| dep.source.is_none())\n+                .map(|dep| INTERNER.intern_string(dep.name))\n+                .collect();\n+            build.crates.insert(name, Crate { name, id: package.id, deps, path });\n         }\n     }\n-    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "12a1734e21c7e165eea70f8ff3742cac2fe55889", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,12 +6,6 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n-ifdef EXCLUDE_CARGO\n-AUX_ARGS :=\n-else\n-AUX_ARGS := src/tools/cargo src/tools/cargotest\n-endif\n-\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -48,9 +42,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-fail/pretty \\\n-\t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\t$(AUX_ARGS) \\\n+\t\tsrc/tools/cargo \\\n+\t\tsrc/tools/cargotest \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "106db90b2d0f0c95fccb0922be22bf0563f287cf", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 196, "deletions": 115, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -11,6 +11,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -23,6 +24,72 @@ use crate::util::{self, exe};\n use crate::GitRepo;\n use build_helper::up_to_date;\n \n+pub struct Meta {\n+    stamp: HashStamp,\n+    build_llvm_config: PathBuf,\n+    out_dir: PathBuf,\n+    root: String,\n+}\n+\n+// This returns whether we've already previously built LLVM.\n+//\n+// It's used to avoid busting caches during x.py check -- if we've already built\n+// LLVM, it's fine for us to not try to avoid doing so.\n+//\n+// This will return the llvm-config if it can get it (but it will not build it\n+// if not).\n+pub fn prebuilt_llvm_config(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+) -> Result<PathBuf, Meta> {\n+    // If we're using a custom LLVM bail out here, but we can only use a\n+    // custom LLVM for the build triple.\n+    if let Some(config) = builder.config.target_config.get(&target) {\n+        if let Some(ref s) = config.llvm_config {\n+            check_llvm_version(builder, s);\n+            return Ok(s.to_path_buf());\n+        }\n+    }\n+\n+    let root = \"src/llvm-project/llvm\";\n+    let out_dir = builder.llvm_out(target);\n+    let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n+    if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+        llvm_config_ret_dir.push(\"build\");\n+    }\n+    llvm_config_ret_dir.push(\"bin\");\n+\n+    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n+\n+    let stamp = out_dir.join(\"llvm-finished-building\");\n+    let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+    if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n+        builder.info(\n+            \"Warning: \\\n+                Using a potentially stale build of LLVM; \\\n+                This may not behave well.\",\n+        );\n+        return Ok(build_llvm_config);\n+    }\n+\n+    if stamp.is_done() {\n+        if stamp.hash.is_none() {\n+            builder.info(\n+                \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+            );\n+            builder.info(&format!(\n+                \"To force LLVM to rebuild, remove the file `{}`\",\n+                stamp.path.display()\n+            ));\n+        }\n+        return Ok(build_llvm_config);\n+    }\n+\n+    Err(Meta { stamp, build_llvm_config, out_dir, root: root.into() })\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n@@ -45,60 +112,14 @@ impl Step for Llvm {\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n \n-        // If we're using a custom LLVM bail out here, but we can only use a\n-        // custom LLVM for the build triple.\n-        if let Some(config) = builder.config.target_config.get(&target) {\n-            if let Some(ref s) = config.llvm_config {\n-                check_llvm_version(builder, s);\n-                return s.to_path_buf();\n-            }\n-        }\n-\n-        let llvm_info = &builder.in_tree_llvm_info;\n-        let root = \"src/llvm-project/llvm\";\n-        let out_dir = builder.llvm_out(target);\n-        let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n-        if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n-            llvm_config_ret_dir.push(\"build\");\n-        }\n-        llvm_config_ret_dir.push(\"bin\");\n-\n-        let build_llvm_config =\n-            llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n-        let done_stamp = out_dir.join(\"llvm-finished-building\");\n-\n-        if done_stamp.exists() {\n-            if builder.config.llvm_skip_rebuild {\n-                builder.info(\n-                    \"Warning: \\\n-                    Using a potentially stale build of LLVM; \\\n-                    This may not behave well.\",\n-                );\n-                return build_llvm_config;\n-            }\n-\n-            if let Some(llvm_commit) = llvm_info.sha() {\n-                let done_contents = t!(fs::read(&done_stamp));\n-\n-                // If LLVM was already built previously and the submodule's commit didn't change\n-                // from the previous build, then no action is required.\n-                if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config;\n-                }\n-            } else {\n-                builder.info(\n-                    \"Could not determine the LLVM submodule commit hash. \\\n-                     Assuming that an LLVM rebuild is not necessary.\",\n-                );\n-                builder.info(&format!(\n-                    \"To force LLVM to rebuild, remove the file `{}`\",\n-                    done_stamp.display()\n-                ));\n-                return build_llvm_config;\n-            }\n-        }\n+        let Meta { stamp, build_llvm_config, out_dir, root } =\n+            match prebuilt_llvm_config(builder, target) {\n+                Ok(p) => return p,\n+                Err(m) => m,\n+            };\n \n         builder.info(&format!(\"Building LLVM for {}\", target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -123,7 +144,7 @@ impl Step for Llvm {\n \n         let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n             Some(ref s) => s,\n-            None => \"\",\n+            None => \"AVR\",\n         };\n \n         let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };\n@@ -137,7 +158,6 @@ impl Step for Llvm {\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n-            .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n             .define(\"WITH_POLLY\", \"OFF\")\n             .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n             .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n@@ -147,6 +167,14 @@ impl Step for Llvm {\n             .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n             .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+        if !target.contains(\"netbsd\") {\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"ON\");\n+        } else {\n+            // FIXME: Enable zlib on NetBSD too\n+            // https://github.com/rust-lang/rust/pull/72696#issuecomment-641517185\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n+        }\n+\n         if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n@@ -163,7 +191,7 @@ impl Step for Llvm {\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n+        if builder.config.llvm_tools_enabled {\n             if !target.contains(\"msvc\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -191,17 +219,9 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if builder.config.lldb_enabled {\n-            enabled_llvm_projects.push(\"clang\");\n-            enabled_llvm_projects.push(\"lldb\");\n-            // For the time being, disable code signing.\n-            cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n-            cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n-        } else {\n-            // LLDB requires libxml2; but otherwise we want it to be disabled.\n-            // See https://github.com/rust-lang/rust/pull/50104\n-            cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n-        }\n+        // We want libxml to be disabled.\n+        // See https://github.com/rust-lang/rust/pull/50104\n+        cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n \n         if !enabled_llvm_projects.is_empty() {\n             enabled_llvm_projects.sort();\n@@ -240,10 +260,14 @@ impl Step for Llvm {\n             if !suffix.is_empty() {\n                 cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n             }\n+        } else if builder.config.channel == \"dev\" {\n+            // Changes to a version suffix require a complete rebuild of the LLVM.\n+            // To avoid rebuilds during a time of version bump, don't include rustc\n+            // release number on the dev channel.\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", \"-rust-dev\");\n         } else {\n-            let default_suffix =\n-                format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel);\n-            cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n+            let suffix = format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel);\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n         }\n \n         if let Some(ref linker) = builder.config.llvm_use_linker {\n@@ -271,7 +295,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n+        t!(stamp.write());\n \n         build_llvm_config\n     }\n@@ -290,11 +314,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2).filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 7 {\n+        if major >= 8 {\n             return;\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=8.0\\n\\n\", version)\n }\n \n fn configure_cmake(\n@@ -480,10 +504,33 @@ impl Step for Lld {\n         let llvm_config_shim = env::current_exe().unwrap().with_file_name(\"llvm-config-wrapper\");\n         cfg.out_dir(&out_dir)\n             .profile(\"Release\")\n-            .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+            .env(\"LLVM_CONFIG_REAL\", &llvm_config)\n             .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n+        // While we're using this horrible workaround to shim the execution of\n+        // llvm-config, let's just pile on more. I can't seem to figure out how\n+        // to build LLD as a standalone project and also cross-compile it at the\n+        // same time. It wants a natively executable `llvm-config` to learn\n+        // about LLVM, but then it learns about all the host configuration of\n+        // LLVM and tries to link to host LLVM libraries.\n+        //\n+        // To work around that we tell our shim to replace anything with the\n+        // build target with the actual target instead. This'll break parts of\n+        // LLD though which try to execute host tools, such as llvm-tblgen, so\n+        // we specifically tell it where to find those. This is likely super\n+        // brittle and will break over time. If anyone knows better how to\n+        // cross-compile LLD it would be much appreciated to fix this!\n+        if target != builder.config.build {\n+            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build)\n+                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target)\n+                .define(\"LLVM_TABLEGEN_EXE\", llvm_config.with_file_name(\"llvm-tblgen\"));\n+        }\n+\n+        // Explicitly set C++ standard, because upstream doesn't do so\n+        // for standalone builds.\n+        cfg.define(\"CMAKE_CXX_STANDARD\", \"14\");\n+\n         cfg.build();\n \n         t!(File::create(&done_stamp));\n@@ -584,17 +631,21 @@ impl Step for Sanitizers {\n             return runtimes;\n         }\n \n-        let done_stamp = out_dir.join(\"sanitizers-finished-building\");\n-        if done_stamp.exists() {\n-            builder.info(&format!(\n-                \"Assuming that sanitizers rebuild is not necessary. \\\n-                To force a rebuild, remove the file `{}`\",\n-                done_stamp.display()\n-            ));\n+        let stamp = out_dir.join(\"sanitizers-finished-building\");\n+        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+        if stamp.is_done() {\n+            if stamp.hash.is_none() {\n+                builder.info(&format!(\n+                    \"Rebuild sanitizers by removing the file `{}`\",\n+                    stamp.path.display()\n+                ));\n+            }\n             return runtimes;\n         }\n \n         builder.info(&format!(\"Building sanitizers for {}\", self.target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n@@ -623,8 +674,7 @@ impl Step for Sanitizers {\n             cfg.build_target(&runtime.cmake_target);\n             cfg.build();\n         }\n-\n-        t!(fs::write(&done_stamp, b\"\"));\n+        t!(stamp.write());\n \n         runtimes\n     }\n@@ -646,46 +696,77 @@ fn supported_sanitizers(\n     target: Interned<String>,\n     channel: &str,\n ) -> Vec<SanitizerRuntime> {\n-    let mut result = Vec::new();\n+    let darwin_libs = |os: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n+        components\n+            .into_iter()\n+            .map(move |c| SanitizerRuntime {\n+                cmake_target: format!(\"clang_rt.{}_{}_dynamic\", c, os),\n+                path: out_dir\n+                    .join(&format!(\"build/lib/darwin/libclang_rt.{}_{}_dynamic.dylib\", c, os)),\n+                name: format!(\"librustc-{}_rt.{}.dylib\", channel, c),\n+            })\n+            .collect()\n+    };\n+\n+    let common_libs = |os: &str, arch: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n+        components\n+            .into_iter()\n+            .map(move |c| SanitizerRuntime {\n+                cmake_target: format!(\"clang_rt.{}-{}\", c, arch),\n+                path: out_dir.join(&format!(\"build/lib/{}/libclang_rt.{}-{}.a\", os, c, arch)),\n+                name: format!(\"librustc-{}_rt.{}.a\", channel, c),\n+            })\n+            .collect()\n+    };\n+\n     match &*target {\n-        \"x86_64-apple-darwin\" => {\n-            for s in &[\"asan\", \"lsan\", \"tsan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}_osx_dynamic\", s),\n-                    path: out_dir\n-                        .join(&format!(\"build/lib/darwin/libclang_rt.{}_osx_dynamic.dylib\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.dylib\", channel, s),\n-                });\n-            }\n+        \"aarch64-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n+        \"aarch64-unknown-linux-gnu\" => {\n+            common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n         }\n+        \"x86_64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n+        \"x86_64-fuchsia\" => common_libs(\"fuchsia\", \"x86_64\", &[\"asan\"]),\n         \"x86_64-unknown-linux-gnu\" => {\n-            for s in &[\"asan\", \"lsan\", \"msan\", \"tsan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/linux/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n-            }\n+            common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n         }\n-        \"x86_64-fuchsia\" => {\n-            for s in &[\"asan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n+        _ => Vec::new(),\n+    }\n+}\n+\n+struct HashStamp {\n+    path: PathBuf,\n+    hash: Option<Vec<u8>>,\n+}\n+\n+impl HashStamp {\n+    fn new(path: PathBuf, hash: Option<&str>) -> Self {\n+        HashStamp { path, hash: hash.map(|s| s.as_bytes().to_owned()) }\n+    }\n+\n+    fn is_done(&self) -> bool {\n+        match fs::read(&self.path) {\n+            Ok(h) => self.hash.as_deref().unwrap_or(b\"\") == h.as_slice(),\n+            Err(e) if e.kind() == io::ErrorKind::NotFound => false,\n+            Err(e) => {\n+                panic!(\"failed to read stamp file `{}`: {}\", self.path.display(), e);\n             }\n         }\n-        \"aarch64-fuchsia\" => {\n-            for s in &[\"asan\"] {\n-                result.push(SanitizerRuntime {\n-                    cmake_target: format!(\"clang_rt.{}-aarch64\", s),\n-                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-aarch64.a\", s)),\n-                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n-                });\n+    }\n+\n+    fn remove(&self) -> io::Result<()> {\n+        match fs::remove_file(&self.path) {\n+            Ok(()) => Ok(()),\n+            Err(e) => {\n+                if e.kind() == io::ErrorKind::NotFound {\n+                    Ok(())\n+                } else {\n+                    Err(e)\n+                }\n             }\n         }\n-        _ => {}\n     }\n-    result\n+\n+    fn write(&self) -> io::Result<()> {\n+        fs::write(&self.path, self.hash.as_deref().unwrap_or(b\"\"))\n+    }\n }"}, {"sha": "900534714277cb83ef2296b9f2ba82c8f9992e8d", "filename": "src/bootstrap/run.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,43 @@\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::tool::Tool;\n+use std::process::Command;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExpandYamlAnchors;\n+\n+impl Step for ExpandYamlAnchors {\n+    type Output = ();\n+\n+    /// Runs the `expand-yaml_anchors` tool.\n+    ///\n+    /// This tool in `src/tools` read the CI configuration files written in YAML and expands the\n+    /// anchors in them, since GitHub Actions doesn't support them.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.info(\"Expanding YAML anchors in the GitHub Actions configuration\");\n+        try_run(\n+            builder,\n+            &mut builder.tool_cmd(Tool::ExpandYamlAnchors).arg(\"generate\").arg(&builder.src),\n+        );\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/expand-yaml-anchors\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(ExpandYamlAnchors);\n+    }\n+}\n+\n+fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        builder.run(cmd);\n+    }\n+    true\n+}"}, {"sha": "74b47d0772837a5c57f562a6ce5ef0eae97fe48b", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -117,23 +117,13 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n-\n-        if build.config.lldb_enabled {\n-            cmd_finder.must_have(\"swig\");\n-            let out = output(Command::new(\"swig\").arg(\"-version\"));\n-            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n-                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n-            }\n-        }\n     }\n \n     build.config.python = build\n         .config\n         .python\n         .take()\n         .map(|p| cmd_finder.must_have(p))\n-        .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n-        .or_else(|| cmd_finder.maybe_have(\"python2\"))\n         .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| Some(cmd_finder.must_have(\"python\")));\n "}, {"sha": "bb35203c82604f6dd62ec893bc07376cae4806a7", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 100, "deletions": 83, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -21,7 +21,7 @@ use crate::flags::Subcommand;\n use crate::native;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n-use crate::util::{self, dylib_path, dylib_path_var};\n+use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n use crate::{envify, DocTests, GitRepo, Mode};\n \n@@ -154,6 +154,7 @@ impl Step for Cargotest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -165,7 +166,7 @@ impl Step for Cargotest {\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(\n             builder,\n-            cmd.arg(&builder.initial_cargo)\n+            cmd.arg(&cargo)\n                 .arg(&out_dir)\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n@@ -360,7 +361,12 @@ impl Step for Miri {\n \n         let miri =\n             builder.ensure(tool::Miri { compiler, target: self.host, extra_features: Vec::new() });\n-        if let Some(miri) = miri {\n+        let cargo_miri = builder.ensure(tool::CargoMiri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let (Some(miri), Some(_cargo_miri)) = (miri, cargo_miri) {\n             let mut cargo = builder.cargo(compiler, Mode::ToolRustc, host, \"install\");\n             cargo.arg(\"xargo\");\n             // Configure `cargo install` path. cargo adds a `bin/`.\n@@ -378,14 +384,16 @@ impl Step for Miri {\n                 Mode::ToolRustc,\n                 host,\n                 \"run\",\n-                \"src/tools/miri\",\n+                \"src/tools/miri/cargo-miri\",\n                 SourceType::Submodule,\n                 &[],\n             );\n-            cargo.arg(\"--bin\").arg(\"cargo-miri\").arg(\"--\").arg(\"miri\").arg(\"setup\");\n+            cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n             // Tell `cargo miri setup` where to find the sources.\n             cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            // Tell it where to find Miri.\n+            cargo.env(\"MIRI\", &miri);\n             // Debug things.\n             cargo.env(\"RUST_BACKTRACE\", \"1\");\n             // Overwrite bootstrap's `rustc` wrapper overwriting our flags.\n@@ -436,9 +444,10 @@ impl Step for Miri {\n \n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n+            cargo.env(\"MIRI\", miri);\n+\n+            cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -515,45 +524,37 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let clippy = builder.ensure(tool::Clippy {\n+        let clippy = builder\n+            .ensure(tool::Clippy { compiler, target: self.host, extra_features: Vec::new() })\n+            .expect(\"in-tree tool\");\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n             compiler,\n-            target: self.host,\n-            extra_features: Vec::new(),\n-        });\n-        if let Some(clippy) = clippy {\n-            let mut cargo = tool::prepare_tool_cargo(\n-                builder,\n-                compiler,\n-                Mode::ToolRustc,\n-                host,\n-                \"test\",\n-                \"src/tools/clippy\",\n-                SourceType::Submodule,\n-                &[],\n-            );\n+            Mode::ToolRustc,\n+            host,\n+            \"test\",\n+            \"src/tools/clippy\",\n+            SourceType::InTree,\n+            &[],\n+        );\n \n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n-            let target_libs = builder\n-                .stage_out(compiler, Mode::ToolRustc)\n-                .join(&self.host)\n-                .join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            cargo.env(\"TARGET_LIBS\", target_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+        // clippy tests need to know about the stage sysroot\n+        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+        let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n+        let target_libs =\n+            builder.stage_out(compiler, Mode::ToolRustc).join(&self.host).join(builder.cargo_dir());\n+        cargo.env(\"HOST_LIBS\", host_libs);\n+        cargo.env(\"TARGET_LIBS\", target_libs);\n+        // clippy tests need to find the driver\n+        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-            if try_run(builder, &mut cargo.into()) {\n-                builder.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        builder.run(&mut cargo.into());\n     }\n }\n \n@@ -627,8 +628,14 @@ impl Step for RustdocJSStd {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command\n-                .arg(builder.src.join(\"src/tools/rustdoc-js-std/tester.js\"))\n+                .arg(builder.src.join(\"src/tools/rustdoc-js/tester.js\"))\n+                .arg(\"--crate-name\")\n+                .arg(\"std\")\n+                .arg(\"--resource-suffix\")\n+                .arg(crate::channel::CFG_RELEASE_NUM)\n+                .arg(\"--doc-folder\")\n                 .arg(builder.doc_out(self.target))\n+                .arg(\"--test-folder\")\n                 .arg(builder.src.join(\"src/test/rustdoc-js-std\"));\n             builder.ensure(crate::doc::Std { target: self.target, stage: builder.top_stage });\n             builder.run(&mut command);\n@@ -728,9 +735,6 @@ impl Step for Tidy {\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(&builder.initial_cargo);\n-        if !builder.config.vendor {\n-            cmd.arg(\"--no-vendor\");\n-        }\n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }\n@@ -753,6 +757,35 @@ impl Step for Tidy {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExpandYamlAnchors;\n+\n+impl Step for ExpandYamlAnchors {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    /// Ensure the `generate-ci-config` tool was run locally.\n+    ///\n+    /// The tool in `src/tools` reads the CI definition in `src/ci/builders.yml` and generates the\n+    /// appropriate configuration for all our CI providers. This step ensures the tool was called\n+    /// by the user before committing CI changes.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.info(\"Ensuring the YAML anchors in the GitHub Actions config were expanded\");\n+        try_run(\n+            builder,\n+            &mut builder.tool_cmd(Tool::ExpandYamlAnchors).arg(\"check\").arg(&builder.src),\n+        );\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/expand-yaml-anchors\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(ExpandYamlAnchors);\n+    }\n+}\n+\n fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n     builder.out.join(host).join(\"test\")\n }\n@@ -868,8 +901,6 @@ default_test!(CompileFail {\n     suite: \"compile-fail\"\n });\n \n-default_test!(RunFail { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" });\n-\n default_test!(RunPassValgrind {\n     path: \"src/test/run-pass-valgrind\",\n     mode: \"run-pass-valgrind\",\n@@ -899,20 +930,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunFailPretty {\n-    path: \"src/test/run-fail/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-fail\",\n-    default: false,\n-    host: true\n-});\n-test!(RunPassValgrindPretty {\n-    path: \"src/test/run-pass-valgrind/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass-valgrind\",\n-    default: false,\n-    host: true\n-});\n \n default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n \n@@ -1076,20 +1093,15 @@ impl Step for Compiletest {\n                     .to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled {\n-            // Test against the lldb that was just built.\n-            builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n-        } else {\n-            PathBuf::from(\"lldb\")\n-        };\n-        let lldb_version = Command::new(&lldb_exe)\n+        let lldb_exe = \"lldb\";\n+        let lldb_version = Command::new(lldb_exe)\n             .arg(\"--version\")\n             .output()\n             .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n             .ok();\n         if let Some(ref vers) = lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n-            let lldb_python_dir = run(Command::new(&lldb_exe).arg(\"-P\")).ok();\n+            let lldb_python_dir = run(Command::new(lldb_exe).arg(\"-P\")).ok();\n             if let Some(ref dir) = lldb_python_dir {\n                 cmd.arg(\"--lldb-python-dir\").arg(dir);\n             }\n@@ -1144,12 +1156,23 @@ impl Step for Compiletest {\n             let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                // Remove trailing newline from llvm-config output.\n+                let llvm_version = llvm_version.trim_end();\n                 cmd.arg(\"--llvm-version\").arg(llvm_version);\n             }\n             if !builder.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n+            // Tests that use compiler libraries may inherit the `-lLLVM` link\n+            // requirement, but the `-L` library path is not propagated across\n+            // separate compilations. We can add LLVM's library path to the\n+            // platform-specific environment variable as a workaround.\n+            if !builder.config.dry_run && suite.ends_with(\"fulldeps\") {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cmd);\n+            }\n+\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n@@ -1495,22 +1518,22 @@ impl Step for RustcGuide {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/doc/rustc-guide\")\n+        run.path(\"src/doc/rustc-dev-guide\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcGuide);\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let src = builder.src.join(\"src/doc/rustc-guide\");\n+        let src = builder.src.join(\"src/doc/rustc-dev-guide\");\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         let toolstate = if try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src)) {\n             ToolState::TestPass\n         } else {\n             ToolState::TestFail\n         };\n-        builder.save_toolstate(\"rustc-guide\", toolstate);\n+        builder.save_toolstate(\"rustc-dev-guide\", toolstate);\n     }\n }\n \n@@ -1622,14 +1645,8 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        for krate in run.builder.in_tree_crates(\"test\") {\n-            if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n-                run = run.path(krate.local_path(&builder).to_str().unwrap());\n-            }\n-        }\n-        run\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1682,7 +1699,7 @@ impl Step for Crate {\n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n             Mode::Std => {\n-                compile::std_cargo(builder, target, &mut cargo);\n+                compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n             }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n@@ -1740,7 +1757,7 @@ impl Step for Crate {\n         } else if builder.remote_tested(target) {\n             cargo.env(\n                 format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+                format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n             );\n         }\n "}, {"sha": "c92082a9423163e4ebf8ad4ea06df4cb131e198d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -12,7 +12,7 @@ use crate::channel;\n use crate::channel::GitInfo;\n use crate::compile;\n use crate::toolstate::ToolState;\n-use crate::util::{add_lib_path, exe, CiEnv};\n+use crate::util::{add_dylib_path, exe, CiEnv};\n use crate::Compiler;\n use crate::Mode;\n \n@@ -252,6 +252,10 @@ pub fn prepare_tool_cargo(\n     // own copy\n     cargo.env(\"LZMA_API_STATIC\", \"1\");\n \n+    // CFG_RELEASE is needed by rustfmt (and possibly other tools) which\n+    // import rustc-ap-rustc_attr which requires this to be set for the\n+    // `#[cfg(version(...))]` attribute.\n+    cargo.env(\"CFG_RELEASE\", builder.rust_release());\n     cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n     cargo.env(\"CFG_VERSION\", builder.rust_version());\n     cargo.env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM);\n@@ -378,6 +382,7 @@ bootstrap_tool!(\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n+    ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -388,7 +393,7 @@ pub struct ErrorIndex {\n impl ErrorIndex {\n     pub fn command(builder: &Builder<'_>, compiler: Compiler) -> Command {\n         let mut cmd = Command::new(builder.ensure(ErrorIndex { compiler }));\n-        add_lib_path(\n+        add_dylib_path(\n             vec![PathBuf::from(&builder.sysroot_libdir(compiler, compiler.host))],\n             &mut cmd,\n         );\n@@ -476,7 +481,7 @@ impl Step for Rustdoc {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/rustdoc\")\n+        run.path(\"src/tools/rustdoc\").path(\"src/librustdoc\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -590,6 +595,7 @@ macro_rules! tool_extended {\n        $toolstate:ident,\n        $path:expr,\n        $tool_name:expr,\n+       stable = $stable:expr,\n        $extra_deps:block;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -601,12 +607,25 @@ macro_rules! tool_extended {\n \n         impl Step for $name {\n             type Output = Option<PathBuf>;\n-            const DEFAULT: bool = true;\n+            const DEFAULT: bool = true; // Overwritten below\n             const ONLY_HOSTS: bool = true;\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.config.extended)\n+                run.path($path).default_condition(\n+                    builder.config.extended\n+                        && builder.config.tools.as_ref().map_or(\n+                            // By default, on nightly/dev enable all tools, else only\n+                            // build stable tools.\n+                            $stable || builder.build.unstable_features(),\n+                            // If `tools` is set, search list for this tool.\n+                            |tools| {\n+                                tools.iter().any(|tool| match tool.as_ref() {\n+                                    \"clippy\" => $tool_name == \"clippy-driver\",\n+                                    x => $tool_name == x,\n+                            })\n+                        }),\n+                )\n             }\n \n             fn make_run(run: RunConfig<'_>) {\n@@ -636,23 +655,23 @@ macro_rules! tool_extended {\n     }\n }\n \n+// Note: tools need to be also added to `Builder::get_step_descriptions` in `build.rs`\n+// to make `./x.py build <tool>` work.\n tool_extended!((self, builder),\n-    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n-    Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n-    Rls, rls, \"src/tools/rls\", \"rls\", {\n-        let clippy = builder.ensure(Clippy {\n+    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, {};\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, {};\n+    Miri, miri, \"src/tools/miri\", \"miri\", stable=false, {};\n+    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", stable=true, {\n+        builder.ensure(Clippy {\n             compiler: self.compiler,\n             target: self.target,\n             extra_features: Vec::new(),\n         });\n-        if clippy.is_some() {\n-            self.extra_features.push(\"clippy\".to_owned());\n-        }\n+        self.extra_features.push(\"clippy\".to_owned());\n     };\n-    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, {};\n );\n \n impl<'a> Builder<'a> {\n@@ -689,7 +708,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        add_lib_path(lib_paths, &mut cmd);\n+        add_dylib_path(lib_paths, &mut cmd);\n         cmd\n     }\n }"}, {"sha": "8740393288c48021800631de542eec2b15064587", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -78,7 +78,6 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n     (\"edition-guide\", \"src/doc/edition-guide\"),\n     (\"rls\", \"src/tools/rls\"),\n     (\"rustfmt\", \"src/tools/rustfmt\"),\n-    (\"clippy-driver\", \"src/tools/clippy\"),\n ];\n \n // These tools are permitted to not build on the beta/stable channels.\n@@ -89,16 +88,16 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n     (\"miri\", \"src/tools/miri\"),\n     (\"embedded-book\", \"src/doc/embedded-book\"),\n-    (\"rustc-guide\", \"src/doc/rustc-guide\"),\n+    // (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n ];\n \n fn print_error(tool: &str, submodule: &str) {\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"We detected that this PR updated '{}', but its tests failed.\", tool);\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do intend to update '{}', please check the error messages above and\", tool);\n     eprintln!(\"commit another update.\");\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");\n@@ -273,6 +272,18 @@ impl Builder<'_> {\n     /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n     /// done. The file is updated immediately after this function completes.\n     pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n+        // If we're in a dry run setting we don't want to save toolstates as\n+        // that means if we e.g. panic down the line it'll look like we tested\n+        // everything (but we actually haven't).\n+        if self.config.dry_run {\n+            return;\n+        }\n+        // Toolstate isn't tracked for clippy, but since most tools do, we avoid\n+        // checking in all the places we could save toolstate and just do so\n+        // here.\n+        if tool == \"clippy-driver\" {\n+            return;\n+        }\n         if let Some(ref path) = self.config.save_toolstates {\n             if let Some(parent) = path.parent() {\n                 // Ensure the parent directory always exists"}, {"sha": "2bc6f1939d97b5cc53b420e95e20f37710b27fd3", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -40,7 +40,7 @@ pub fn libdir(target: &str) -> &'static str {\n }\n \n /// Adds a list of lookup paths to `cmd`'s dynamic library lookup path.\n-pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+pub fn add_dylib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n     let mut list = dylib_path();\n     for path in path {\n         list.insert(0, path);\n@@ -72,6 +72,31 @@ pub fn dylib_path() -> Vec<PathBuf> {\n     env::split_paths(&var).collect()\n }\n \n+/// Adds a list of lookup paths to `cmd`'s link library lookup path.\n+pub fn add_link_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+    let mut list = link_lib_path();\n+    for path in path {\n+        list.insert(0, path);\n+    }\n+    cmd.env(link_lib_path_var(), t!(env::join_paths(list)));\n+}\n+\n+/// Returns the environment variable which the link library lookup path\n+/// resides in for this platform.\n+fn link_lib_path_var() -> &'static str {\n+    if cfg!(target_env = \"msvc\") { \"LIB\" } else { \"LIBRARY_PATH\" }\n+}\n+\n+/// Parses the `link_lib_path_var()` environment variable, returning a list of\n+/// paths that are members of this lookup path.\n+fn link_lib_path() -> Vec<PathBuf> {\n+    let var = match env::var_os(link_lib_path_var()) {\n+        Some(v) => v,\n+        None => return vec![],\n+    };\n+    env::split_paths(&var).collect()\n+}\n+\n /// `push` all components to `buf`. On windows, append `.exe` to the last component.\n pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n     let (&file, components) = components.split_last().expect(\"at least one component required\");"}, {"sha": "3de27bc54c5c0b08b113b0587df78c5c851590da", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines \"auto\" branch build for Rust on Linux, macOS, and Windows.\n #\n@@ -18,7 +29,7 @@ jobs:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-7:\n+      x86_64-gnu-llvm-8:\n         RUST_BACKTRACE: 1\n       dist-x86_64-linux: {}\n       dist-x86_64-linux-alt:\n@@ -76,7 +87,7 @@ jobs:\n       # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n       x86_64-apple:\n         SCRIPT: ./x.py test\n-        RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.8\n         MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n@@ -85,7 +96,7 @@ jobs:\n \n       dist-x86_64-apple:\n         SCRIPT: ./x.py dist\n-        RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        INITIAL_RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.7\n         NO_LLVM_ASSERTIONS: 1\n@@ -94,7 +105,7 @@ jobs:\n \n       dist-x86_64-apple-alt:\n         SCRIPT: ./x.py dist\n-        RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+        INITIAL_RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.7\n         NO_LLVM_ASSERTIONS: 1\n@@ -111,41 +122,37 @@ jobs:\n     matrix:\n       # 32/64 bit MSVC tests\n       x86_64-msvc-1:\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n         SCRIPT: make ci-subset-1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-msvc-2:\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n         SCRIPT: make ci-subset-2\n       i686-msvc-1:\n-        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       i686-msvc-2:\n-        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-2\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n-      # MSVC aux tests\n-      x86_64-msvc-aux:\n-        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n         VCVARS_BAT: vcvars64.bat\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       # MSVC tools tests\n       x86_64-msvc-tools:\n         SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n \n       # 32/64-bit MinGW builds.\n       #\n@@ -161,57 +168,57 @@ jobs:\n       # came from the mingw-w64 SourceForge download site. Unfortunately\n       # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n       i686-mingw-1:\n-        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-mingw-subset-1\n         CUSTOM_MINGW: 1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       i686-mingw-2:\n-        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-mingw-subset-2\n         CUSTOM_MINGW: 1\n       x86_64-mingw-1:\n         SCRIPT: make ci-mingw-subset-1\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n         CUSTOM_MINGW: 1\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-mingw-2:\n         SCRIPT: make ci-mingw-subset-2\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n         CUSTOM_MINGW: 1\n \n       # 32/64 bit MSVC and GNU deployment\n       dist-x86_64-msvc:\n-        RUST_CONFIGURE_ARGS: >-\n+        INITIAL_RUST_CONFIGURE_ARGS: >-\n           --build=x86_64-pc-windows-msvc\n           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n           --enable-full-tools\n           --enable-profiler\n         SCRIPT: python x.py dist\n         DIST_REQUIRE_ALL_TOOLS: 1\n       dist-i686-msvc:\n-        RUST_CONFIGURE_ARGS: >-\n+        INITIAL_RUST_CONFIGURE_ARGS: >-\n           --build=i686-pc-windows-msvc\n           --target=i586-pc-windows-msvc\n           --enable-full-tools\n           --enable-profiler\n         SCRIPT: python x.py dist\n         DIST_REQUIRE_ALL_TOOLS: 1\n       dist-i686-mingw:\n-        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n         SCRIPT: python x.py dist\n         CUSTOM_MINGW: 1\n         DIST_REQUIRE_ALL_TOOLS: 1\n       dist-x86_64-mingw:\n         SCRIPT: python x.py dist\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n         CUSTOM_MINGW: 1\n         DIST_REQUIRE_ALL_TOOLS: 1\n \n       # \"alternate\" deployment, see .travis.yml for more info\n       dist-x86_64-msvc-alt:\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n         SCRIPT: python x.py dist"}, {"sha": "485b80398c8e4dead48155ba49d55004c2c8ba26", "filename": "src/ci/azure-pipelines/master.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines job to publish toolstate. Only triggers on pushes to master.\n #"}, {"sha": "1fc8d187242f8cacc16df7c7c6f170e83cb7b733", "filename": "src/ci/azure-pipelines/pr.yml", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines pull request build for Rust\n #\n@@ -18,7 +29,7 @@ jobs:\n     - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-7: {}\n+      x86_64-gnu-llvm-8: {}\n       mingw-check: {}\n       x86_64-gnu-tools:\n         CI_ONLY_WHEN_SUBMODULES_CHANGED: 1"}, {"sha": "e43116c06b6b7f3718abd2c1348617f0f59c367c", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n # FIXME(linux): need to configure core dumps, enable them, and then dump\n # backtraces on failure from all core dumps:\n #\n@@ -59,8 +70,8 @@ steps:\n   displayName: Install InnoSetup\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/windows-symlink-build-dir.sh\n-  displayName: Ensure the build happens on C:\\ instead of D:\\\n+- bash: src/ci/scripts/symlink-build-dir.sh\n+  displayName: Ensure the build happens on a partition with enough space\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/disable-git-crlf-conversion.sh\n@@ -71,10 +82,6 @@ steps:\n   displayName: Install msys2\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/install-msys2-packages.sh\n-  displayName: Install msys2 packages\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/install-mingw.sh\n   displayName: Install MinGW\n   condition: and(succeeded(), not(variables.SKIP_JOB))"}, {"sha": "818306a00922986ab4fe3c3f8ceb079b574a3acd", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n pr: none\n trigger:\n - try\n@@ -15,8 +26,6 @@ jobs:\n   strategy:\n     matrix:\n       dist-x86_64-linux: {}\n-      dist-x86_64-linux-alt:\n-        IMAGE: dist-x86_64-linux\n \n # The macOS and Windows builds here are currently disabled due to them not being\n # overly necessary on `try` builds. We also don't actually have anything that\n@@ -32,7 +41,7 @@ jobs:\n #     matrix:\n #       dist-x86_64-apple:\n #         SCRIPT: ./x.py dist\n-#         RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+#         INITIAL_RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n #         DEPLOY: 1\n #         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n #         MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -42,7 +51,7 @@ jobs:\n #\n #       dist-x86_64-apple-alt:\n #         SCRIPT: ./x.py dist\n-#         RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+#         INITIAL_RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n #         DEPLOY_ALT: 1\n #         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n #         MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -58,7 +67,7 @@ jobs:\n #   strategy:\n #     matrix:\n #       dist-x86_64-msvc:\n-#         RUST_CONFIGURE_ARGS: >\n+#         INITIAL_RUST_CONFIGURE_ARGS: >\n #           --build=x86_64-pc-windows-msvc\n #           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n #           --enable-full-tools\n@@ -68,6 +77,6 @@ jobs:\n #         DEPLOY: 1\n #\n #       dist-x86_64-msvc-alt:\n-#         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+#         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n #         SCRIPT: python x.py dist\n #         DEPLOY_ALT: 1"}, {"sha": "95936d65432fabfaaed0d3a050977db75ea10cbf", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -138,33 +138,31 @@ $category > $option = $value -- $comment\n For targets: `arm-unknown-linux-gnueabi`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Floating point = software (no FPU) -- (\\*)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `arm-linux-gnueabihf.config`\n \n For targets: `arm-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Use specific FPU = vfp -- (+)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = arm -- (+)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `armv7-linux-gnueabihf.config`"}, {"sha": "77514848167067b2187f680130f2584d9278b13a", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -31,7 +31,7 @@ ENV TARGETS=arm-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py test --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "d1bc70689e1e7bb97ce2c99f531d37f4f11f8985", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n       libc6-dev \\\n       libc6-dev-armhf-cross \\\n       make \\\n-      python2.7 \\\n+      python3 \\\n       qemu-system-arm \\\n       xz-utils\n \n@@ -78,6 +78,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n-ENV SCRIPT python2.7 ../x.py test --target arm-unknown-linux-gnueabihf\n+ENV SCRIPT python3 ../x.py test --target arm-unknown-linux-gnueabihf\n \n ENV NO_CHANGE_USER=1"}, {"sha": "9dd0435ac4f0c9727988c71d401d9303ac2ae456", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n       libc6-dev \\\n       libc6-dev-arm64-cross \\\n       make \\\n-      python2.7 \\\n+      python3 \\\n       qemu-system-aarch64 \\\n       xz-utils\n \n@@ -75,5 +75,5 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n       --qemu-aarch64-rootfs=/tmp/rootfs\n-ENV SCRIPT python2.7 ../x.py test --target aarch64-unknown-linux-gnu\n+ENV SCRIPT python3 ../x.py test --target aarch64-unknown-linux-gnu\n ENV NO_CHANGE_USER=1"}, {"sha": "3fa65511e94f783912f52b7f7d2619b9a7e41cce", "filename": "src/ci/docker/disabled/asmjs/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -33,7 +33,7 @@ ENV EMCC_CFLAGS=-O1\n # Emscripten installation is user-specific\n ENV NO_CHANGE_USER=1\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py test --target $TARGETS\n \n # This is almost identical to the wasm32-unknown-emscripten target, so\n # running with assertions again is not useful"}, {"sha": "dea445c295c994263ef8ce7886a8b76b84adbaec", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,7 +19,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+ENV SCRIPT python3 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "7227c41ccca9a7dda4f54bcac161c7163a50384a", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -33,11 +33,11 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/arm && \\\n     ln -s /android/ndk/arm-14 /android/ndk/arm && \\\n-    python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+    python3 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "b74dcefa3516c5566262896a62b18f781cf10b9a", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -33,11 +33,11 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/x86 && \\\n     ln -s /android/ndk/x86-14 /android/ndk/x86 && \\\n-    python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+    python3 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "19df9d6cf6231e4712b79422c22cdf93d295340c", "filename": "src/ci/docker/disabled/dist-powerpcspe-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=powerpc-unknown-linux-gnuspe\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "62d0bfc71b2fa76a0cdf5cb635b9aa366804c703", "filename": "src/ci/docker/disabled/dist-sparc64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=sparc64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "d44779763e5443901234b12dc213594a4def7222", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,7 +19,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+ENV SCRIPT python3 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "5b7196c573c8b278cb58c9284c548d64b4fb25bb", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -33,4 +33,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-dragonfly\n \n ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5b65335bfe4e4f635ba58febbe0d6274a1c9ed27", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -18,7 +18,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   make \\\n   nasm \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   texinfo \\\n   wget \\\n@@ -46,4 +46,4 @@ ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n   --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n   --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n   --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV SCRIPT python2.7 ../x.py dist --host=$HOST --target=$HOST\n+ENV SCRIPT python3 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "7b53e73d700ba4cc418efb6b0356a59e70042c6f", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,4 +19,4 @@ ENV \\\n     CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n \n ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --target x86_64-unknown-redox\n+ENV SCRIPT python3 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "08d0c5b2cac1e70e8b87dbd49348ad32c889c364", "filename": "src/ci/docker/disabled/riscv64gc-linux/0001-Remove-stime-function-calls.patch", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2F0001-Remove-stime-function-calls.patch?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,96 @@\n+From c820da85c65c7f3aa9e9cb3ed71ada69bf9b783e Mon Sep 17 00:00:00 2001\n+From: Alistair Francis <alistair.francis@wdc.com>\n+Date: Tue, 19 Nov 2019 13:06:40 +0100\n+Subject: [PATCH] Remove stime() function calls\n+\n+stime() has been deprecated in glibc 2.31 and replaced with\n+clock_settime(). Let's replace the stime() function calls with\n+clock_settime() in preperation.\n+\n+function                                             old     new   delta\n+rdate_main                                           197     224     +27\n+clock_settime                                          -      27     +27\n+date_main                                            926     941     +15\n+stime                                                 37       -     -37\n+------------------------------------------------------------------------------\n+(add/remove: 2/2 grow/shrink: 2/0 up/down: 69/-37)             Total: 32 bytes\n+\n+Signed-off-by: Alistair Francis <alistair.francis@wdc.com>\n+Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n+\n+[Tom Eccles: adjust patch context to apply on top of 1.31.1-stable]\n+Signed-off-by: Tom Eccles <tom.eccles@codethink.co.uk>\n+---\n+ coreutils/date.c         | 6 +++++-\n+ libbb/missing_syscalls.c | 8 --------\n+ util-linux/rdate.c       | 8 ++++++--\n+ 3 files changed, 11 insertions(+), 11 deletions(-)\n+\n+diff --git a/coreutils/date.c b/coreutils/date.c\n+index 3414d38ae..4ade6abb4 100644\n+--- a/coreutils/date.c\n++++ b/coreutils/date.c\n+@@ -279,6 +279,9 @@ int date_main(int argc UNUSED_PARAM, char **argv)\n+ \t\ttime(&ts.tv_sec);\n+ #endif\n+ \t}\n++#if !ENABLE_FEATURE_DATE_NANO\n++\tts.tv_nsec = 0;\n++#endif\n+ \tlocaltime_r(&ts.tv_sec, &tm_time);\n+ \n+ \t/* If date string is given, update tm_time, and maybe set date */\n+@@ -301,9 +304,10 @@ int date_main(int argc UNUSED_PARAM, char **argv)\n+ \t\tif (date_str[0] != '@')\n+ \t\t\ttm_time.tm_isdst = -1;\n+ \t\tts.tv_sec = validate_tm_time(date_str, &tm_time);\n++\t\tts.tv_nsec = 0;\n+ \n+ \t\t/* if setting time, set it */\n+-\t\tif ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {\n++\t\tif ((opt & OPT_SET) && clock_settime(CLOCK_REALTIME, &ts) < 0) {\n+ \t\t\tbb_perror_msg(\"can't set date\");\n+ \t\t}\n+ \t}\n+diff --git a/libbb/missing_syscalls.c b/libbb/missing_syscalls.c\n+index 87cf59b3d..dc40d9155 100644\n+--- a/libbb/missing_syscalls.c\n++++ b/libbb/missing_syscalls.c\n+@@ -15,14 +15,6 @@ pid_t getsid(pid_t pid)\n+ \treturn syscall(__NR_getsid, pid);\n+ }\n+ \n+-int stime(const time_t *t)\n+-{\n+-\tstruct timeval tv;\n+-\ttv.tv_sec = *t;\n+-\ttv.tv_usec = 0;\n+-\treturn settimeofday(&tv, NULL);\n+-}\n+-\n+ int sethostname(const char *name, size_t len)\n+ {\n+ \treturn syscall(__NR_sethostname, name, len);\n+diff --git a/util-linux/rdate.c b/util-linux/rdate.c\n+index 70f829e7f..878375d78 100644\n+--- a/util-linux/rdate.c\n++++ b/util-linux/rdate.c\n+@@ -95,9 +95,13 @@ int rdate_main(int argc UNUSED_PARAM, char **argv)\n+ \tif (!(flags & 2)) { /* no -p (-s may be present) */\n+ \t\tif (time(NULL) == remote_time)\n+ \t\t\tbb_error_msg(\"current time matches remote time\");\n+-\t\telse\n+-\t\t\tif (stime(&remote_time) < 0)\n++\t\telse {\n++\t\t\tstruct timespec ts;\n++\t\t\tts.tv_sec = remote_time;\n++\t\t\tts.tv_nsec = 0;\n++\t\t\tif (clock_settime(CLOCK_REALTIME, &ts) < 0)\n+ \t\t\t\tbb_perror_msg_and_die(\"can't set time of day\");\n++\t\t}\n+ \t}\n+ \n+ \tif (flags != 1) /* not lone -s */\n+-- \n+2.25.1\n+"}, {"sha": "f21dc2ba309b8218effbb0305cf8d1c5afefbafa", "filename": "src/ci/docker/disabled/riscv64gc-linux/Dockerfile", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,102 @@\n+# based on armhf-gnu/Dockerfile\n+FROM ubuntu:20.04\n+\n+RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections\n+RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n+    bc \\\n+    bison \\\n+    ca-certificates \\\n+    cmake \\\n+    cpio \\\n+    curl \\\n+    debian-ports-archive-keyring \\\n+    debootstrap \\\n+    flex \\\n+    gcc \\\n+    gcc-riscv64-linux-gnu \\\n+    git \\\n+    g++-riscv64-linux-gnu \\\n+    g++ \\\n+    libc6-dev \\\n+    libc6-dev-riscv64-cross \\\n+    make \\\n+    patch \\\n+    python3 \\\n+    qemu-system-misc \\\n+    xz-utils\n+\n+ENV ARCH=riscv\n+ENV CROSS_COMPILE=riscv64-linux-gnu-\n+\n+WORKDIR /build\n+\n+# From https://github.com/michaeljclark/busybear-linux/blob/master/conf/linux.config\n+COPY riscv64gc-linux/linux.config /build\n+\n+# Compile the kernel that we're going to be emulating with. This is\n+# basically just done to be compatible with the QEMU target that we're going\n+# to be using when running tests.\n+RUN curl https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.6.16.tar.xz | tar xJf - && \\\n+    cp linux.config linux-5.6.16/.config && \\\n+    cd /build/linux-5.6.16 && \\\n+    make olddefconfig && \\\n+    make -j$(nproc) vmlinux\n+RUN cp linux-5.6.16/vmlinux /tmp\n+RUN rm -rf linux-5.6.16\n+\n+# Compile an instance of busybox as this provides a lightweight system and init\n+# binary which we will boot into. Only trick here is configuring busybox to\n+# build static binaries.\n+RUN curl https://busybox.net/downloads/busybox-1.31.1.tar.bz2 | tar xjf -\n+COPY riscv64gc-linux/0001-Remove-stime-function-calls.patch /build/busybox-1.31.1/\n+RUN cd /build/busybox-1.31.1 && \\\n+    patch -p1 -i 0001-Remove-stime-function-calls.patch && \\\n+    make defconfig && \\\n+    sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \\\n+    make -j$(nproc) && \\\n+    make install && \\\n+    mv _install /tmp/rootfs && \\\n+    cd /build && \\\n+    rm -rf busybox-1.31.1\n+\n+# Download the ubuntu rootfs, which we'll use as a chroot for all our tests\n+# This is only needed to provide /lib/* and /usr/lib/*\n+WORKDIR /tmp\n+RUN debootstrap --variant=minbase --arch=riscv64 --foreign focal /tmp/rootfs/ubuntu\n+RUN cd rootfs && mkdir proc sys dev etc etc/init.d\n+# rootfs/ubuntu/proc is in a weird state (access fails with ELOOP) until\n+# rootfs/ubuntu/debootstrap/debootstrap --second-stage is run (under emulation),\n+# but this takes ages. Instead hack it into a good enough state.\n+# /proc is used by std::env::current_exe() (which is roughly\n+# `readlink /proc/self/exe`)\n+RUN cd rootfs/ubuntu && rm -rf proc && mkdir proc\n+\n+# Copy over our init script, which starts up our test server and also a few other\n+# misc tasks\n+COPY scripts/qemu-bare-bones-rcS rootfs/etc/init.d/rcS\n+RUN chmod +x rootfs/etc/init.d/rcS\n+\n+# Helper to quickly fill the entropy pool in the kernel\n+COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n+RUN riscv64-linux-gnu-gcc addentropy.c -o rootfs/addentropy -static\n+\n+# download and build the riscv bootloader\n+RUN git clone https://github.com/riscv/riscv-pk\n+WORKDIR /tmp/riscv-pk\n+# nothing special about this revision: it is just master at the time of writing\n+# v1.0.0 doesn't build\n+RUN git checkout 5d9ed238e1cabfbca3c47f50d32894ce94bfc304\n+RUN mkdir build && cd build && \\\n+    ../configure --with-payload=/tmp/vmlinux --host=riscv64-linux-gnu && \\\n+    make -j$(nproc) && \\\n+    cp bbl /tmp\n+WORKDIR /tmp\n+RUN rm -rf /tmp/riscv-pk\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUST_CONFIGURE_ARGS --qemu-riscv64-rootfs=/tmp/rootfs\n+ENV SCRIPT python3 ../x.py test --target riscv64gc-unknown-linux-gnu\n+\n+ENV NO_CHANGE_USER=1"}, {"sha": "5142664742f20248d66d550dfdbf64e94167adf5", "filename": "src/ci/docker/disabled/riscv64gc-linux/linux.config", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2Flinux.config", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2Flinux.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Friscv64gc-linux%2Flinux.config?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,51 @@\n+CONFIG_DEFAULT_HOSTNAME=\"busybear\"\n+CONFIG_SYSVIPC=y\n+CONFIG_POSIX_MQUEUE=y\n+CONFIG_IKCONFIG=y\n+CONFIG_IKCONFIG_PROC=y\n+CONFIG_CGROUPS=y\n+CONFIG_CGROUP_SCHED=y\n+CONFIG_CFS_BANDWIDTH=y\n+CONFIG_CGROUP_BPF=y\n+CONFIG_NAMESPACES=y\n+CONFIG_USER_NS=y\n+CONFIG_CHECKPOINT_RESTORE=y\n+CONFIG_BLK_DEV_INITRD=y\n+CONFIG_EXPERT=y\n+CONFIG_BPF_SYSCALL=y\n+CONFIG_SMP=y\n+CONFIG_MODULES=y\n+CONFIG_NET=y\n+CONFIG_PACKET=y\n+CONFIG_PACKET_DIAG=y\n+CONFIG_UNIX=y\n+CONFIG_INET=y\n+CONFIG_NETLINK_DIAG=y\n+# CONFIG_WIRELESS is not set\n+CONFIG_PCI=y\n+CONFIG_DEVTMPFS=y\n+CONFIG_BLK_DEV_LOOP=y\n+CONFIG_VIRTIO_BLK=y\n+CONFIG_NETDEVICES=y\n+CONFIG_VIRTIO_NET=y\n+# CONFIG_ETHERNET is not set\n+# CONFIG_WLAN is not set\n+CONFIG_SERIAL_8250=y\n+CONFIG_SERIAL_8250_CONSOLE=y\n+CONFIG_SERIAL_OF_PLATFORM=y\n+CONFIG_HVC_RISCV_SBI=y\n+# CONFIG_HW_RANDOM is not set\n+# CONFIG_USB_SUPPORT is not set\n+CONFIG_VIRTIO_MMIO=y\n+CONFIG_SIFIVE_PLIC=y\n+CONFIG_RAS=y\n+CONFIG_EXT2_FS=y\n+CONFIG_EXT3_FS=y\n+CONFIG_EXT4_FS_POSIX_ACL=y\n+CONFIG_AUTOFS4_FS=y\n+CONFIG_MSDOS_FS=y\n+CONFIG_VFAT_FS=y\n+CONFIG_TMPFS=y\n+# CONFIG_CRYPTO_ECHAINIV is not set\n+# CONFIG_CRYPTO_HW is not set\n+CONFIG_PRINTK_TIME=y"}, {"sha": "fd764965ef21b1d85e50c9d3008b75219e5ad866", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -33,7 +33,8 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n ENV HOSTS=aarch64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-profiler \\\n+      --enable-sanitizers \\\n       --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "6d38e199564b1d3de503864bbd36847f72031260", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -23,6 +23,7 @@ ENV TARGETS=$TARGETS,x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n+      --enable-profiler \\\n       --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --thumbv7neon-linux-androideabi-ndk=/android/ndk/arm-14 \\\n@@ -31,7 +32,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n       --disable-docs\n \n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT python3 ../x.py dist --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "06870a8a982f3ab40e9c24a7c730770ac7405d12", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-arm-linux/patches/ /tmp/patches/\n COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n@@ -33,5 +27,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "1dcdbd1a9008be2eb76c7f5f8c781e8e234e953c", "filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabi.config", "status": "modified", "additions": 510, "deletions": 309, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,85 +117,86 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-# CT_ARCH_FLOAT_HW is not set\n-CT_ARCH_FLOAT_SW=y\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"\"\n # CT_ARCH_FLOAT_AUTO is not set\n+# CT_ARCH_FLOAT_HW is not set\n # CT_ARCH_FLOAT_SOFTFP is not set\n+CT_ARCH_FLOAT_SW=y\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"soft\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-\n #\n # Toolchain options\n #\n@@ -181,7 +209,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -215,227 +245,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -464,97 +554,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-arm-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "155dd84891435e5ed4bb7ce4f2ed375d9b137049", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-armhf-linux/patches/ /tmp/patches/\n COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n@@ -33,5 +27,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a3dcff1c9363538d11ca2ad8967d948405d998eb", "filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "modified", "additions": 511, "deletions": 310, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,86 +117,87 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"vfp\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-CT_ARCH_FLOAT_HW=y\n-# CT_ARCH_FLOAT_SW is not set\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"vfp\"\n # CT_ARCH_FLOAT_AUTO is not set\n+CT_ARCH_FLOAT_HW=y\n # CT_ARCH_FLOAT_SOFTFP is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"hard\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n-\n #\n # Toolchain options\n #\n@@ -182,7 +210,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -216,227 +246,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -465,97 +555,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armhf-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "649049da5dfe314719af3cfd920eb0ad9d83def6", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -3,8 +3,8 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY dist-armv7-linux/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n@@ -27,5 +27,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "996fffeb871cfc9f7f6fe23e08f7ac33cc7b11ae", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   xz-utils \\\n@@ -46,5 +46,5 @@ ENV CFLAGS_i586_unknown_linux_musl=-Wa,-mrelax-relocations=no\n ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n \n ENV SCRIPT \\\n-      python2.7 ../x.py test --target $TARGETS && \\\n-      python2.7 ../x.py dist --target $TARGETS,i586-unknown-linux-musl\n+      python3 ../x.py test --target $TARGETS && \\\n+      python3 ../x.py dist --target $TARGETS,i586-unknown-linux-musl"}, {"sha": "7978bb70869652f8e5c39ad66f2bff6a27a9ee5f", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -30,4 +30,4 @@ ENV \\\n ENV HOSTS=i686-unknown-freebsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "57a7fc25b5c13ead0cf11168a452b053c94dd58c", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "63f1028e2be593db9db9c0e533f9ae6c2f0a5f6c", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,4 +22,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a51edbc9c7923a49d0684efe54e5df4d0096f595", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "908cef90cef6900c801a8fab567b0a1f5e8587c5", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,4 +22,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mipsel-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "b8792b0c7fa92711f9fe339b0293dda51751860c", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -35,4 +35,4 @@ ENV \\\n ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a790a143ac5e73918269a35c5e147a7aee13d765", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -36,4 +36,4 @@ ENV \\\n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5c17bc321c1712d8eb4b5cc7baedb3dd4503c851", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -33,4 +33,4 @@ ENV \\\n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "76d29a471c3967e14451c71495299bb3857ff65f", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -35,4 +35,4 @@ ENV \\\n ENV HOSTS=s390x-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "35b598e20f09932d3fc683f8406e90b8bdf60396", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -18,7 +18,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n   python3 \\\n   git \\\n   cmake \\\n@@ -72,6 +71,9 @@ RUN ./install-mips-musl.sh\n COPY dist-various-1/install-mipsel-musl.sh /build\n RUN ./install-mipsel-musl.sh\n \n+COPY dist-various-1/install-aarch64-none-elf.sh /build\n+RUN ./install-aarch64-none-elf.sh\n+\n # Suppress some warnings in the openwrt toolchains we downloaded\n ENV STAGING_DIR=/tmp\n \n@@ -140,6 +142,8 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n+ENV TARGETS=$TARGETS,aarch64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-none-softfloat\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n@@ -178,6 +182,10 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n     CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n     CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n+    CC_aarch64_unknown_none_softfloat=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none_softfloat=-mstrict-align -march=armv8-a+nofp+nosimd \\\n+    CC_aarch64_unknown_none=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none=-mstrict-align -march=armv8-a+fp+simd \\\n     CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n     AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n     CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n@@ -200,8 +208,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --disable-docs\n \n ENV SCRIPT \\\n-      python2.7 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n-      python2.7 ../x.py dist --target $TARGETS\n+      python3 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python3 ../x.py dist --target $TARGETS\n \n # sccache\n COPY scripts/sccache.sh /scripts/"}, {"sha": "d72976c28584225902eeed7ede849610ce3ee586", "filename": "src/ci/docker/dist-various-1/install-aarch64-none-elf.sh", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,6 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+curl -L https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf.tar.xz \\\n+| tar --extract --xz --strip 1 --directory /usr/local"}, {"sha": "43f5581f996ea437b6fd32bcb5651407d858dadc", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n   libmpfr-dev \\\n   ninja-build \\\n   nodejs \\\n-  python2.7-dev \\\n+  python3-dev \\\n   software-properties-common \\\n   unzip \\\n   # Needed for apt-key to work:\n@@ -28,6 +28,29 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n \n+ENV \\\n+    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n+    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n+    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n+    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n+    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n+    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    AR_x86_64_fortanix_unknown_sgx=ar \\\n+    CC_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang-11 \\\n+    CFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CXX_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang++-11 \\\n+    CXXFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n+\n WORKDIR /build\n COPY scripts/musl.sh /build\n RUN env \\\n@@ -46,34 +69,18 @@ COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n+COPY dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh /usr/bin/x86_64-fortanix-unknown-sgx-clang-11\n+RUN ln -s /usr/bin/x86_64-fortanix-unknown-sgx-clang-11 /usr/bin/x86_64-fortanix-unknown-sgx-clang++-11\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"5125c169b30837208a842f85f7ae44a83533bd0e\"\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"800f95131fe6acd20b96b6f4723ca3c820f3d379\"\n \n COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n RUN /tmp/build-wasi-toolchain.sh\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV \\\n-    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n-    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n-    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n-    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n-    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n-    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n-    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n-    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n-    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n-    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n-    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n-    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n-    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n-    CC=gcc-7 \\\n-    CXX=g++-7\n-\n ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n -C link-arg=--sysroot=/usr/local/x86_64-fuchsia \\\n@@ -110,4 +117,4 @@ ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n   --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n   --musl-root-armv7=/musl-armv7\n \n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT python3 ../x.py dist --target $TARGETS"}, {"sha": "c82031690ab6a81b1bcdbaab7311ce515501ba09", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-libc\n \n cd wasi-libc\n-git reset --hard 1fad33890a5e299027ce0eab7b6ad5260585e347\n+git reset --hard 9efc2f428358564fe64c374d762d0bfce1d92507\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "4294b1ef93dd825226241d9dbe2236a46c752944", "filename": "src/ci/docker/dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-x86_64-fortanix-unknown-sgx-toolchain.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -13,12 +13,15 @@ url=\"https://github.com/fortanix/llvm-project/archive/${1}.tar.gz\"\n repo_name=\"llvm-project\"\n \n install_prereq() {\n+    curl https://apt.llvm.org/llvm-snapshot.gpg.key|apt-key add -\n+    add-apt-repository -y 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main'\n     apt-get update\n     apt-get install -y --no-install-recommends \\\n             build-essential \\\n             ca-certificates \\\n             cmake \\\n-            git\n+            git \\\n+            clang-11\n }\n \n build_unwind() {\n@@ -35,7 +38,14 @@ build_unwind() {\n     # Build libunwind\n     mkdir -p build\n     cd build\n+    target_CC=\"CC_${target//-/_}\"\n+    target_CXX=\"CXX_${target//-/_}\"\n+    target_CFLAGS=\"CFLAGS_${target//-/_}\"\n+    target_CXXFLAGS=\"CXXFLAGS_${target//-/_}\"\n     cmake -DCMAKE_BUILD_TYPE=\"RELEASE\" -DRUST_SGX=1 -G \"Unix Makefiles\" \\\n+        -DCMAKE_C_COMPILER=\"${!target_CC}\" -DCMAKE_CXX_COMPILER=\"${!target_CXX}\" \\\n+        -DCMAKE_C_FLAGS=\"${!target_CFLAGS}\" -DCMAKE_CXX_FLAGS=\"${!target_CXXFLAGS}\" \\\n+        -DCMAKE_C_COMPILER_TARGET=$target -DCMAKE_CXX_COMPILER_TARGET=$target \\\n         -DLLVM_ENABLE_WARNINGS=1 -DLIBUNWIND_ENABLE_WERROR=1 -DLIBUNWIND_ENABLE_PEDANTIC=0 \\\n         -DLLVM_PATH=../../llvm/ ../\n     make unwind_static"}, {"sha": "c4ff44c37b1e35aa6e1a2d441d8fcfbaaaa305eb", "filename": "src/ci/docker/dist-various-2/x86_64-fortanix-unknown-sgx-clang-wrap.sh", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fx86_64-fortanix-unknown-sgx-clang-wrap.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,14 @@\n+#!/bin/bash\n+\n+args=(\"$@\")\n+\n+for i in \"${!args[@]}\"; do\n+    # x86_64-fortanix-unknown-sgx doesn't have a C sysroot for things like\n+    # stdint.h and the C++ STL. Unlike GCC, clang will not use the host's\n+    # sysroot instead. Force it.\n+    if [ \"${args[$i]}\" = \"--target=x86_64-fortanix-unknown-sgx\" ]; then\n+        args[$i]=\"--target=x86_64-unknown-linux-gnu\"\n+    fi\n+done\n+\n+exec \"${0/x86_64-fortanix-unknown-sgx-clang/clang}\" \"${args[@]}\""}, {"sha": "12170a366148755d884b97eb93cfaeb29e82cc2b", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -30,4 +30,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-freebsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "c026506b106618709844c4d7daa534eb9440cb99", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -7,7 +7,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   wget \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   xz-utils \\\n@@ -34,6 +34,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n       --disable-docs \\\n+      --enable-lld \\\n       --set target.x86_64-unknown-linux-musl.crt-static=false \\\n       --build $HOSTS\n \n@@ -47,4 +48,4 @@ ENV CFLAGS_x86_64_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wa,--compress-\n     -Wl,--compress-debug-sections=none\"\n \n # To run native tests replace `dist` below with `test`\n-ENV SCRIPT python2.7 ../x.py dist --build $HOSTS\n+ENV SCRIPT python3 ../x.py dist --build $HOSTS"}, {"sha": "135bb33cef71728f24cbc1bffc2956ed8e4e4f57", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,4 +19,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-netbsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "c15b437e6d3157dea376b816c82172a449564a41", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -18,7 +18,7 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test\n \n # FIXME(#59637) takes too long on CI right now\n ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "377f07cef4e46e7444e7a21eea56d742e2eafa56", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -20,7 +20,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n # Exclude some tests that are unlikely to be platform specific, to speed up\n # this slow job.\n-ENV SCRIPT python2.7 ../x.py test \\\n+ENV SCRIPT python3 ../x.py test \\\n   --exclude src/bootstrap \\\n   --exclude src/test/rustdoc-js \\\n   --exclude src/tools/error_index_generator \\"}, {"sha": "97e4d3fd7499e92ad4fbbc63a0f8efc52756c4f5", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,7 +22,10 @@ RUN sh /scripts/sccache.sh\n COPY mingw-check/validate-toolstate.sh /scripts/\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n-           python2.7 ../x.py build --stage 0 src/tools/build-manifest && \\\n-           python2.7 ../x.py test --stage 0 src/tools/compiletest && \\\n+ENV SCRIPT python3 ../x.py test src/tools/expand-yaml-anchors && \\\n+           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n+           python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n+           python3 ../x.py test --stage 0 src/tools/compiletest && \\\n+           python3 ../x.py test src/tools/tidy && \\\n+           python3 ../x.py doc --stage 0 src/libstd && \\\n            /scripts/validate-toolstate.sh"}, {"sha": "c6d728eb80dd080377bf0a575b30cd828b49ab26", "filename": "src/ci/docker/mingw-check/validate-toolstate.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -7,12 +7,12 @@ IFS=$'\\n\\t'\n rm -rf rust-toolstate\n git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n cd rust-toolstate\n-python2.7 \"../../src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \\\n+python3 \"../../src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \\\n     \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n # Only check maintainers if this build is supposed to publish toolstate.\n # Builds that are not supposed to publish don't have the access token.\n if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n-  TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \\\n+  TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python3 \\\n       \"../../src/tools/publish_toolstate.py\"\n fi\n cd .."}, {"sha": "d891ad1b6680e622323b7bbd21632d21a3e81fb2", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -17,6 +17,8 @@ dist=$objdir/build/dist\n \n source \"$ci_dir/shared.sh\"\n \n+CACHE_DOMAIN=\"${CACHE_DOMAIN:-ci-caches.rust-lang.org}\"\n+\n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n@@ -38,9 +40,7 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n \n-      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n-      upload=\"aws s3 cp - $s3url\"\n+      url=\"https://$CACHE_DOMAIN/docker/$cksum\"\n \n       echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n@@ -65,7 +65,9 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$upload\" != \"\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then"}, {"sha": "391b68ea637b0e4f4d1162fae217203a7a7ec4cc", "filename": "src/ci/docker/scripts/android-base-apt-get.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -11,7 +11,7 @@ apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   make \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   unzip \\\n   xz-utils"}, {"sha": "dafcb3cb7a719a1a11a69bdc86f333a588c03551", "filename": "src/ci/docker/scripts/android-ndk.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -13,7 +13,7 @@ download_ndk() {\n \n make_standalone_toolchain() {\n     # See https://developer.android.com/ndk/guides/standalone_toolchain.htm\n-    python2.7 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n+    python3 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n         --install-dir /android/ndk/$1-$2 \\\n         --arch $1 \\\n         --api $2"}, {"sha": "7030cd74cae232c5e4a2aec35ae8d13ec0261b45", "filename": "src/ci/docker/scripts/cross-apt-packages.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,7 +19,7 @@ apt-get update && apt-get install -y --no-install-recommends \\\n   make \\\n   patch \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   texinfo \\\n   unzip \\"}, {"sha": "fb067a79a5c85c93691cdf5244394982d465289f", "filename": "src/ci/docker/scripts/crosstool-ng-1.24.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "previous_filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh"}, {"sha": "1ae412340cb114e09c675b2ad92521d108a0526e", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -3,7 +3,7 @@\n #\n # Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n # musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n-# Right now we have: Binutils 2.27, GCC 6.4.0, musl 1.1.22.\n+# Right now we have: Binutils 2.31.1, GCC 9.2.0, musl 1.1.24.\n set -ex\n \n hide_output() {\n@@ -33,11 +33,13 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-git clone https://github.com/richfelker/musl-cross-make -b v0.9.8\n+git clone https://github.com/richfelker/musl-cross-make # -b v0.9.9\n cd musl-cross-make\n+# A few commits ahead of v0.9.9 to include the cowpatch fix:\n+git checkout a54eb56f33f255dfca60be045f12a5cfaf5a72a9\n \n-hide_output make -j$(nproc) TARGET=$TARGET\n-hide_output make install TARGET=$TARGET OUTPUT=$OUTPUT\n+hide_output make -j$(nproc) TARGET=$TARGET MUSL_VER=1.1.24\n+hide_output make install TARGET=$TARGET MUSL_VER=1.1.24 OUTPUT=$OUTPUT\n \n cd -\n "}, {"sha": "58393a5719a10d4854eaf7ce5aa151c3608df13a", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -24,7 +24,7 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.22\n+MUSL=musl-1.1.24\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "9276e4ed82d78b2c886980927830b1310b25f4d3", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -40,7 +40,7 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV NO_DEBUG_ASSERTIONS=1\n \n ENV WASM_TARGETS=wasm32-unknown-unknown\n-ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n+ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\\n   src/test/compile-fail \\\n@@ -49,13 +49,13 @@ ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n   src/libcore\n \n ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n-ENV NVPTX_SCRIPT python2.7 /checkout/x.py test --target $NVPTX_TARGETS \\\n+ENV NVPTX_SCRIPT python3 /checkout/x.py test --target $NVPTX_TARGETS \\\n   src/test/run-make \\\n   src/test/assembly\n \n ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n     CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n     CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n-ENV MUSL_SCRIPT python2.7 /checkout/x.py test --target $MUSL_TARGETS\n+ENV MUSL_SCRIPT python3 /checkout/x.py test --target $MUSL_TARGETS\n \n ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "8232539edda7743d7a929f30830cbe0abee9d1f2", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -20,10 +20,16 @@ RUN bash /scripts/emscripten.sh\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+# emcc seems to need python to specifically be \"python\" and not \"python3\"\n+RUN ln `which python3` /usr/bin/python\n+\n ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n+ENV EMSDK=/emsdk-portable\n+ENV EM_CONFIG=/emsdk-portable/.emscripten\n+ENV EM_CACHE=/emsdk-portable/upstream/emscripten/cache\n \n ENV TARGETS=wasm32-unknown-emscripten\n \n@@ -35,7 +41,7 @@ ENV NO_CHANGE_USER=1\n \n # FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n # is picked up by CI\n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+ENV SCRIPT python3 ../x.py test --target $TARGETS \\\n     --exclude src/libcore \\\n     --exclude src/liballoc \\\n     --exclude src/libproc_macro \\"}, {"sha": "86ac0256d28201cd90cf9977171adf8e7fc9365f", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   libssl-dev \\"}, {"sha": "c5e41b8a75afe506048fa18eba18a27da91ae2d0", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,8 +6,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n-  python2.7-dev \\\n+  python3 \\\n+  python3-dev \\\n   libxml2-dev \\\n   libncurses-dev \\\n   libedit-dev \\\n@@ -40,5 +40,5 @@ ENV RUST_CONFIGURE_ARGS \\\n       --set target.x86_64-unknown-linux-gnu.cxx=clang++\n \n ENV SCRIPT \\\n-  python2.7 ../x.py build && \\\n-  python2.7 ../x.py test src/test/run-make-fulldeps --test-args clang\n+  python3 ../x.py build && \\\n+  python3 ../x.py test src/test/run-make-fulldeps --test-args clang"}, {"sha": "cc07a591cc17bec1c7d1d853f8216f75165aa98f", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -19,7 +19,7 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --set rust.ignore-git=false\n-ENV SCRIPT python2.7 ../x.py test distcheck\n+ENV SCRIPT python3 ../x.py test distcheck\n ENV DIST_SRC 1\n \n # The purpose of this builder is to test that we can `./x.py test` successfully"}, {"sha": "de7ee6950b51b26ca00c06b2c32af0bf8b2c51f0", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -21,7 +21,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n-ENV SCRIPT python2.7 ../x.py build\n+ENV SCRIPT python3 ../x.py build\n \n # In general this just slows down the build and we're just a smoke test that\n # a full bootstrap works in general, so there's not much need to take this"}, {"sha": "4cd9e164558c0213015b5530fa68565c442b61aa", "filename": "src/ci/docker/x86_64-gnu-llvm-7/Dockerfile", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,38 +0,0 @@\n-FROM ubuntu:18.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  llvm-7-tools \\\n-  libedit-dev \\\n-  libssl-dev \\\n-  pkg-config \\\n-  zlib1g-dev \\\n-  xz-utils \\\n-  nodejs\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# using llvm-link-shared due to libffi issues -- see #34486\n-ENV RUST_CONFIGURE_ARGS \\\n-      --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-7 \\\n-      --enable-llvm-link-shared \\\n-      --set rust.thin-lto-import-instr-limit=10\n-\n-ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n-\n-# The purpose of this container isn't to test with debug assertions and\n-# this is run on all PRs, so let's get speedier builds by disabling these extra\n-# checks.\n-ENV NO_DEBUG_ASSERTIONS=1\n-ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "58fdc6f262376c8cc26a2484653be4672df7ffe4", "filename": "src/ci/docker/x86_64-gnu-llvm-8/Dockerfile", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,55 @@\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  g++-arm-linux-gnueabi \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-8-tools \\\n+  libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n+  zlib1g-dev \\\n+  xz-utils \\\n+  nodejs\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-8 \\\n+      --enable-llvm-link-shared \\\n+      --set rust.thin-lto-import-instr-limit=10\n+\n+ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n+           # Run the `mir-opt` tests again but this time for a 32-bit target.\n+           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n+           # both 32-bit and 64-bit outputs updated by the PR author, before\n+           # the PR is approved and tested for merging.\n+           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n+           # despite having different output on 32-bit vs 64-bit targets.\n+           #\n+           # HACK(eddyb) `armv5te` is used (not `i686`) to support older LLVM than LLVM 9:\n+           # https://github.com/rust-lang/compiler-builtins/pull/311#issuecomment-612270089.\n+           # This also requires `--pass=build` because we can't execute the tests\n+           # on the `x86_64` host when they're built as `armv5te` binaries.\n+           # (we're only interested in the MIR output, so this doesn't matter)\n+           python2.7 ../x.py test src/test/mir-opt --pass=build \\\n+                                  --target=armv5te-unknown-linux-gnueabi && \\\n+           # Run tidy at the very end, after all the other tests.\n+           python2.7 ../x.py test src/tools/tidy\n+\n+# The purpose of this container isn't to test with debug assertions and\n+# this is run on all PRs, so let's get speedier builds by disabling these extra\n+# checks.\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "096f67e13d1e679c0414ca8445c63abece65cb49", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -21,4 +21,4 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test"}, {"sha": "148e09f6ad104c17177b126fcbb9339db907ffc1", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   libssl-dev \\"}, {"sha": "b4b23a245e0aa928b0d7689e9ba8b07ba953f25c", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -7,19 +7,20 @@ X_PY=\"$1\"\n # Try to test all the tools and store the build/test success in the TOOLSTATE_FILE\n \n set +e\n-python2.7 \"$X_PY\" test --no-fail-fast \\\n+python3 \"$X_PY\" test --no-fail-fast \\\n     src/doc/book \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n     src/doc/edition-guide \\\n-    src/doc/rustc-guide \\\n-    src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n \n set -e\n \n-python2.7 \"$X_PY\" test check-tools\n+# debugging: print out the saved toolstates\n+cat /tmp/toolstate/toolstates.json\n+python3 \"$X_PY\" test check-tools\n+python3 \"$X_PY\" test src/tools/clippy"}, {"sha": "af6e13180627688b881fc9cc49b7bd3715a5ca01", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ ENV RUST_CONFIGURE_ARGS \\\n  --enable-sanitizers \\\n  --enable-profiler \\\n  --enable-compiler-docs\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test"}, {"sha": "26ce69e33d9c3ea14450b82061ac05a0a88874b6", "filename": "src/ci/exec-with-shell.py", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fexec-with-shell.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fexec-with-shell.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fexec-with-shell.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,16 @@\n+#!/usr/bin/env python\n+# A simple wrapper that forwards the arguments to bash, unless the\n+# CI_OVERRIDE_SHELL environment variable is present: in that case the content\n+# of that environment variable is used as the shell path.\n+\n+import os\n+import sys\n+import subprocess\n+\n+try:\n+    shell = os.environ[\"CI_OVERRIDE_SHELL\"]\n+except KeyError:\n+    shell = \"bash\"\n+\n+res = subprocess.call([shell] + sys.argv[1:])\n+sys.exit(res)"}, {"sha": "5e67567c76b4ff0e9ac797112a4739e3d7cfcf56", "filename": "src/ci/github-actions/ci.yml", "status": "added", "additions": 643, "deletions": 0, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,643 @@\n+######################################################\n+#   WARNING! Action needed when changing this file   #\n+######################################################\n+\n+# Due to GitHub Actions limitations, we can't use YAML Anchors directly in the\n+# CI configuration stored on the repository. To work around that this file is\n+# expanded by a tool in the repository, and the expansion is committed as well.\n+#\n+# After you make any change to the file you'll need to run this command:\n+#\n+#   ./x.py run src/tools/expand-yaml-anchors\n+#\n+# ...and commit the file it updated in addition to this one. If you forget this\n+# step CI will fail.\n+\n+---\n+\n+###############################\n+#   YAML Anchors Definition   #\n+###############################\n+\n+# This key contains most of the YAML anchors that will be used later in the\n+# document. YAML anchors allows us to greatly reduce duplication inside the CI\n+# configuration by reusing parts of the configuration.\n+#\n+# YAML anchors work by defining an anchor with `&anchor-name` and reusing its\n+# content in another place with `*anchor-name`. The special `<<` map key merges\n+# the content of the map with the content of the anchor (or list of anchors).\n+#\n+# The expand-yaml-anchors tool will automatically remove this block from the\n+# output YAML file.\n+x--expand-yaml-anchors--remove:\n+\n+  - &shared-ci-variables\n+    CI_JOB_NAME: ${{ matrix.name }}\n+\n+  - &public-variables\n+    SCCACHE_BUCKET: rust-lang-gha-caches\n+    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+\n+  - &prod-variables\n+    SCCACHE_BUCKET: rust-lang-gha-caches\n+    DEPLOY_BUCKET: rust-lang-gha\n+    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    TOOLSTATE_ISSUES_API_URL: https://api.github.com/repos/pietroalbini/rust-toolstate/issues\n+    TOOLSTATE_PUBLISH: 1\n+    # AWS_SECRET_ACCESS_KEYs are stored in GitHub's secrets storage, named\n+    # AWS_SECRET_ACCESS_KEY_<keyid>. Including the key id in the name allows to\n+    # rotate them in a single branch while keeping the old key in another\n+    # branch, which wouldn't be possible if the key was named with the kind\n+    # (caches, artifacts...).\n+    CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+    ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+\n+  - &base-job\n+    env: {}\n+\n+  - &job-linux-xl\n+    os: ubuntu-latest-xl\n+    <<: *base-job\n+\n+  - &job-macos-xl\n+    os: macos-latest  # We don't have an XL builder for this\n+    <<: *base-job\n+\n+  - &job-windows-xl\n+    os: windows-latest-xl\n+    <<: *base-job\n+\n+  - &step\n+    if: success() && !env.SKIP_JOB\n+\n+  - &base-ci-job\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    env: *shared-ci-variables\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\n+        <<: *step\n+\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          # Since it's not possible to merge `${{ matrix.env }}` with the other\n+          # variables in `job.<name>.env`, the variables defined in the matrix\n+          # are passed to the `setup-environment.sh` script encoded in JSON,\n+          # which then uses log commands to actually set them.\n+          EXTRA_VARIABLES: ${{ toJson(matrix.env) }}\n+        <<: *step\n+\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        <<: *step\n+\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        <<: *step\n+\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        <<: *step\n+\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        <<: *step\n+\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        <<: *step\n+\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        <<: *step\n+\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        <<: *step\n+\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        <<: *step\n+\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        <<: *step\n+\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        <<: *step\n+\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        <<: *step\n+\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        <<: *step\n+\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        <<: *step\n+\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        <<: *step\n+\n+      # Disable automatic line ending conversion (again). On Windows, when we're\n+      # installing dependencies, something switches the git configuration directory or\n+      # re-enables autocrlf. We've not tracked down the exact cause -- and there may\n+      # be multiple -- but this should ensure submodules are checked out with the\n+      # appropriate line endings.\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        <<: *step\n+\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        <<: *step\n+\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        <<: *step\n+\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: ${{ env.CACHES_AWS_ACCESS_KEY_ID }}\n+          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\n+          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n+        <<: *step\n+\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: ${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\n+          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\n+        # Adding a condition on DEPLOY=1 or DEPLOY_ALT=1 is not needed as all deploy\n+        # builders *should* have the AWS credentials available. Still, explicitly\n+        # adding the condition is helpful as this way CI will not silently skip\n+        # deploying artifacts from a dist builder if the variables are misconfigured,\n+        # erroring about invalid credentials instead.\n+        if: success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\n+        <<: *step\n+\n+  # These snippets are used by the try-success, try-failure, auto-success and auto-failure jobs.\n+  # Check out their documentation for more information on why they're needed.\n+\n+  - &base-outcome-job\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+\n+  - &base-success-job\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    <<: *base-outcome-job\n+\n+  - &base-failure-job\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    <<: *base-outcome-job\n+\n+###########################\n+#   Builders definition   #\n+###########################\n+\n+name: CI\n+on:\n+  push:\n+    branches:\n+      - auto\n+      - try\n+      - master\n+  pull_request:\n+    branches:\n+      - \"**\"\n+\n+defaults:\n+  run:\n+    # While on Linux and macOS builders it just forwards the arguments to the\n+    # system bash, this wrapper allows switching from the host's bash.exe to\n+    # the one we install along with MSYS2 mid-build on Windows.\n+    #\n+    # Once the step to install MSYS2 is executed, the CI_OVERRIDE_SHELL\n+    # environment variable is set pointing to our MSYS2's bash.exe. From that\n+    # moment the host's bash.exe will not be called anymore.\n+    #\n+    # This is needed because we can't launch our own bash.exe from the host\n+    # bash.exe, as that would load two different cygwin1.dll in memory, causing\n+    # \"cygwin heap mismatch\" errors.\n+    shell: python src/ci/exec-with-shell.py {0}\n+\n+jobs:\n+  pr:\n+    <<: *base-ci-job\n+    name: PR\n+    env:\n+      <<: [*shared-ci-variables, *public-variables]\n+    if: github.event_name == 'pull_request'\n+    strategy:\n+      matrix:\n+        include:\n+          - name: mingw-check\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-llvm-8\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-tools\n+            env:\n+              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n+            <<: *job-linux-xl\n+\n+  try:\n+    <<: *base-ci-job\n+    name: try\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+  auto:\n+    <<: *base-ci-job\n+    name: auto\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          #############################\n+          #   Linux/Docker builders   #\n+          #############################\n+\n+          - name: arm-android\n+            <<: *job-linux-xl\n+\n+          - name: armhf-gnu\n+            <<: *job-linux-xl\n+\n+          - name: dist-aarch64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-android\n+            <<: *job-linux-xl\n+\n+          - name: dist-arm-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-armhf-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-armv7-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-i586-gnu-i586-i686-musl\n+            <<: *job-linux-xl\n+\n+          - name: dist-i686-freebsd\n+            <<: *job-linux-xl\n+\n+          - name: dist-i686-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips64el-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mipsel-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc64le-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-s390x-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-various-1\n+            <<: *job-linux-xl\n+\n+          - name: dist-various-2\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-freebsd\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-musl\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-netbsd\n+            <<: *job-linux-xl\n+\n+          - name: i686-gnu\n+            <<: *job-linux-xl\n+\n+          - name: i686-gnu-nopt\n+            <<: *job-linux-xl\n+\n+          - name: mingw-check\n+            <<: *job-linux-xl\n+\n+          - name: test-various\n+            <<: *job-linux-xl\n+\n+          - name: wasm32\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-aux\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-debug\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-distcheck\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-full-bootstrap\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-llvm-8\n+            env:\n+              RUST_BACKTRACE: 1\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-nopt\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-tools\n+            env:\n+              DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n+            <<: *job-linux-xl\n+\n+          ######################\n+          #  Windows Builders  #\n+          ######################\n+\n+          - name: x86_64-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+              SCRIPT: make ci-subset-1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+              SCRIPT: make ci-subset-2\n+            <<: *job-windows-xl\n+\n+          - name: i686-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+              SCRIPT: make ci-subset-1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: i686-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+              SCRIPT: make ci-subset-2\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-cargo\n+            env:\n+              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n+              VCVARS_BAT: vcvars64.bat\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-tools\n+            env:\n+              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n+            <<: *job-windows-xl\n+\n+          # 32/64-bit MinGW builds.\n+          #\n+          # We are using MinGW with posix threads since LLVM does not compile with\n+          # the win32 threads version due to missing support for C++'s std::thread.\n+          #\n+          # Instead of relying on the MinGW version installed on appveryor we download\n+          # and install one ourselves so we won't be surprised by changes to appveyor's\n+          # build image.\n+          #\n+          # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+          # bucket, but they cleraly didn't originate there! The downloads originally\n+          # came from the mingw-w64 SourceForge download site. Unfortunately\n+          # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+\n+          - name: i686-mingw-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+              SCRIPT: make ci-mingw-subset-1\n+              CUSTOM_MINGW: 1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: i686-mingw-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+              SCRIPT: make ci-mingw-subset-2\n+              CUSTOM_MINGW: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-mingw-1\n+            env:\n+              SCRIPT: make ci-mingw-subset-1\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+              CUSTOM_MINGW: 1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-mingw-2\n+            env:\n+              SCRIPT: make ci-mingw-subset-2\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+              CUSTOM_MINGW: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: >-\n+                --build=x86_64-pc-windows-msvc\n+                --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+                --enable-full-tools\n+                --enable-profiler\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-i686-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: >-\n+                --build=i686-pc-windows-msvc\n+                --target=i586-pc-windows-msvc\n+                --enable-full-tools\n+                --enable-profiler\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-i686-mingw\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n+              SCRIPT: python x.py dist\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-mingw\n+            env:\n+              SCRIPT: python x.py dist\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-msvc-alt\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+              SCRIPT: python x.py dist\n+            <<: *job-windows-xl\n+\n+  auto-fallible:\n+    <<: *base-ci-job\n+    name: auto-fallible\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          ####################\n+          #  macOS Builders  #\n+          ####################\n+\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-macos-xl\n+\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: ./x.py test\n+              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+  master:\n+    name: master\n+    runs-on: ubuntu-latest\n+    env:\n+      <<: [*prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\n+    steps:\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+\n+      - name: publish toolstate\n+        run: src/ci/publish_toolstate.sh\n+        env:\n+          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n+        <<: *step\n+\n+  # These jobs don't actually test anything, but they're used to tell bors the\n+  # build completed, as there is no practical way to detect when a workflow is\n+  # successful listening to webhooks only.\n+  try-success:\n+    needs: [try]\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-success-job\n+  try-failure:\n+    needs: [try]\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-failure-job\n+  auto-success:\n+    needs: [auto]\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-success-job\n+  auto-failure:\n+    needs: [auto]\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-failure-job"}, {"sha": "59f2736cbd406b05e11bfebd35e97dd66218258e", "filename": "src/ci/run.sh", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -23,6 +23,14 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n+if command -v python > /dev/null; then\n+    PYTHON=\"python\"\n+elif command -v python3 > /dev/null; then\n+    PYTHON=\"python3\"\n+else\n+    PYTHON=\"python2\"\n+fi\n+\n if ! isCI || isCiBranch auto || isCiBranch beta; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n@@ -107,7 +115,7 @@ SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   $SRC/configure --enable-parallel-compiler\n-  CARGO_INCREMENTAL=0 python2.7 ../x.py check\n+  CARGO_INCREMENTAL=0 $PYTHON ../x.py check\n   rm -f config.toml\n   rm -rf build\n fi"}, {"sha": "f9b759fe343f007e2ade76ba16e2c51b4b2b6ee1", "filename": "src/ci/scripts/install-awscli.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-awscli.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -28,7 +28,7 @@ if isLinux; then\n     pipflags=\"--user\"\n \n     sudo apt-get install -y python3-setuptools\n-    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n+    ciCommandAddPath \"${HOME}/.local/bin\"\n fi\n \n mkdir -p \"${DEPS_DIR}\""}, {"sha": "ae85d5cab0122f7fdca22d44c76bf73b03313d6e", "filename": "src/ci/scripts/install-mingw.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-mingw.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-mingw.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-mingw.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -51,7 +51,8 @@ if isWindows; then\n \n     if [[ \"${CUSTOM_MINGW-0}\" -ne 1 ]]; then\n         pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake \\\n-            mingw-w64-$arch-gcc mingw-w64-$arch-python2\n+            mingw-w64-$arch-gcc \\\n+            mingw-w64-$arch-python # the python package is actually for python3\n         ciCommandAddPath \"$(ciCheckoutPath)/msys2/mingw${bits}/bin\"\n     else\n         mingw_dir=\"mingw${bits}\""}, {"sha": "843a2bf2d5e55a488e8c97ca952bb1ae0e9edc71", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,18 +0,0 @@\n-#!/bin/bash\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar \\\n-        binutils\n-\n-    # Make sure we use the native python interpreter instead of some msys equivalent\n-    # one way or another. The msys interpreters seem to have weird path conversions\n-    # baked in which break LLVM's build system one way or another, so let's use the\n-    # native version which keeps everything as native as possible.\n-    cp C:/Python27amd64/python.exe C:/Python27amd64/python2.7.exe\n-    ciCommandAddPath \"C:\\\\Python27amd64\"\n-fi"}, {"sha": "3a0c965a67710ba45d3e66b5553b50ab83df5c2a", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,25 +1,33 @@\n #!/bin/bash\n # Download and install MSYS2, needed primarily for the test suite (run-make) but\n # also used by the MinGW toolchain for assembling things.\n-#\n-# FIXME: we should probe the default azure image and see if we can use the MSYS2\n-# toolchain there. (if there's even one there). For now though this gets the job\n-# done.\n \n set -euo pipefail\n IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n-    # Pre-followed the api/v2 URL to the CDN since the API can be a bit flakey\n-    curl -sSL https://packages.chocolatey.org/msys2.20190524.0.0.20191030.nupkg > \\\n-        msys2.nupkg\n-    curl -sSL https://packages.chocolatey.org/chocolatey-core.extension.1.3.5.1.nupkg > \\\n-        chocolatey-core.extension.nupkg\n-    choco install -s . msys2 \\\n-        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n-    rm msys2.nupkg chocolatey-core.extension.nupkg\n-    mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n-    ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\"\n+    msys2Path=\"c:/msys64\"\n+    mkdir -p \"${msys2Path}/home/${USERNAME}\"\n+    ciCommandAddPath \"${msys2Path}/usr/bin\"\n+\n+    echo \"switching shell to use our own bash\"\n+    ciCommandSetEnv CI_OVERRIDE_SHELL \"${msys2Path}/usr/bin/bash.exe\"\n+\n+    # Detect the native Python version installed on the agent. On GitHub\n+    # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n+    # subdirectory for each installed Python version.\n+    #\n+    # The -V flag of the sort command sorts the input by version number.\n+    native_python_version=\"$(ls /c/hostedtoolcache/windows/Python | sort -Vr | head -n 1)\"\n+\n+    # Make sure we use the native python interpreter instead of some msys equivalent\n+    # one way or another. The msys interpreters seem to have weird path conversions\n+    # baked in which break LLVM's build system one way or another, so let's use the\n+    # native version which keeps everything as native as possible.\n+    python_home=\"/c/hostedtoolcache/windows/Python/${native_python_version}/x64\"\n+    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\\\\Scripts\"\n fi"}, {"sha": "411ef6f9b2822de63d2bd621db865e68565161e4", "filename": "src/ci/scripts/setup-environment.sh", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Fsetup-environment.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Fsetup-environment.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsetup-environment.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -8,6 +8,37 @@ IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n+# Since matrix variables are readonly in Azure Pipelines, we take\n+# INITIAL_RUST_CONFIGURE_ARGS and establish RUST_CONFIGURE_ARGS\n+# which downstream steps can alter\n+if isAzurePipelines; then\n+    # macOS ships with Bash 3.16, so we cannot use [[ -v FOO ]],\n+    # which was introduced in Bash 4.2\n+    if [[ -z \"${INITIAL_RUST_CONFIGURE_ARGS+x}\" ]]; then\n+        INITIAL_RUST_CONFIG=\"\"\n+        echo \"No initial Rust configure args set\"\n+    else\n+        INITIAL_RUST_CONFIG=\"${INITIAL_RUST_CONFIGURE_ARGS}\"\n+        ciCommandSetEnv RUST_CONFIGURE_ARGS \"${INITIAL_RUST_CONFIG}\"\n+    fi\n+fi\n+\n+# Load extra environment variables\n+vars=\"${EXTRA_VARIABLES-}\"\n+echo \"${vars}\" | jq '' >/dev/null  # Validate JSON and exit on errors\n+for key in $(echo \"${vars}\" | jq \"keys[]\" -r); do\n+    # On Windows, for whatever reason, $key contains the BOM character in it,\n+    # and that messes up `jq \".${key}\"`. This line strips the BOM from the key.\n+    #\n+    # https://unix.stackexchange.com/a/381263\n+    key=\"$(echo \"${key}\" | sed '1s/^\\xEF\\xBB\\xBF//')\"\n+\n+    echo \"adding extra environment variable ${key}\"\n+    value=\"$(echo \"${vars}\" | jq \".${key}\" -r)\"\n+    export \"${key}\"=\"${value}\"\n+    ciCommandSetEnv \"${key}\" \"${value}\"\n+done\n+\n # Builders starting with `dist-` are dist builders, but if they also end with\n # `-alt` they are alternate dist builders.\n if [[ \"${CI_JOB_NAME}\" = dist-* ]]; then"}, {"sha": "50178b9c33ed46eb783c2fd788ec92aba1a84bf6", "filename": "src/ci/scripts/symlink-build-dir.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/bash\n+# We've had multiple issues with the default disk running out of disk space\n+# during builds, and it looks like other disks mounted in the VMs have more\n+# space available. This script synlinks the build directory to those other\n+# disks, in the CI providers and OSes affected by this.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows && isAzurePipelines; then\n+    cmd //c \"mkdir c:\\\\MORE_SPACE\"\n+    cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n+elif isLinux && isGitHubActions; then\n+    sudo mkdir -p /mnt/more-space\n+    sudo chown -R \"$(whoami):\" /mnt/more-space\n+\n+    # Switch the whole workspace to the /mnt partition, which has more space.\n+    # We don't just symlink the `obj` directory as doing that creates problems\n+    # with the docker container.\n+    current_dir=\"$(readlink -f \"$(pwd)\")\"\n+    cd /tmp\n+    mv \"${current_dir}\" /mnt/more-space/workspace\n+    ln -s /mnt/more-space/workspace \"${current_dir}\"\n+    cd \"${current_dir}\"\n+\n+    # Move the Docker data directory to /mnt\n+    sudo systemctl stop docker.service\n+    sudo mv /var/lib/docker /mnt/docker\n+    sudo ln -s /mnt/docker /var/lib/docker\n+    sudo systemctl start docker.service\n+fi"}, {"sha": "e57128c70f5f194e533adfbc15c1f3cde35220b0", "filename": "src/ci/scripts/windows-symlink-build-dir.sh", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,15 +0,0 @@\n-#!/bin/bash\n-# We've had issues with the default drive in use running out of space during a\n-# build, and it looks like the `C:` drive has more space than the default `D:`\n-# drive. We should probably confirm this with the azure pipelines team at some\n-# point, but this seems to fix our \"disk space full\" problems.\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    cmd //c \"mkdir c:\\\\MORE_SPACE\"\n-    cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n-fi"}, {"sha": "4e7c00bece1544d409312ec93467beb62b5bd0cb", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit 6fb3705e5230311b096d47f7e2c91f9ce24393d0\n+Subproject commit 4e7c00bece1544d409312ec93467beb62b5bd0cb"}, {"sha": "82bec5877c77cfad530ca11095db4456d757f668", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit 37f9e6848411188a1062ead1bd8ebe4b8aa16899\n+Subproject commit 82bec5877c77cfad530ca11095db4456d757f668"}, {"sha": "616962ad0dd80f34d8b802da038d0aed9dd691bb", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit b81ffb7a6f4c5aaed92786e770e99db116aa4ebd\n+Subproject commit 616962ad0dd80f34d8b802da038d0aed9dd691bb"}, {"sha": "bfe1ab96d717d1dda50e499b360f2e2f57e1750a", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit 9f797e65e6bcc79419975b17aff8e21c9adc039f\n+Subproject commit bfe1ab96d717d1dda50e499b360f2e2f57e1750a"}, {"sha": "04d5d5d7ba624b6f5016298451f3a63d557f3260", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit 559e09caa9661043744cf7af7bd88432d966f743\n+Subproject commit 04d5d5d7ba624b6f5016298451f3a63d557f3260"}, {"sha": "6f94ccb48da6fa4ed0031290f21411cf789f7d5e", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1 +1 @@\n-Subproject commit db57f899ea2a56a544c8d280cbf033438666273d\n+Subproject commit 6f94ccb48da6fa4ed0031290f21411cf789f7d5e"}, {"sha": "7adfab42bab045a848126895c2f1e09927c1331a", "filename": "src/doc/rustc-dev-guide", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1 @@\n+Subproject commit 7adfab42bab045a848126895c2f1e09927c1331a"}, {"sha": "5bd60bc51efaec04e69e2e18b59678e2af066433", "filename": "src/doc/rustc-guide", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1 +0,0 @@\n-Subproject commit 5bd60bc51efaec04e69e2e18b59678e2af066433"}, {"sha": "b626923bcb59cfd8ae48872f0bd7cc758a9b8e8a", "filename": "src/doc/rustc-ux-guidelines.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,90 +0,0 @@\n-% Rustc UX guidelines\n-\n-Don't forget the user. Whether human or another program, such as an IDE, a\n-good user experience with the compiler goes a long way toward making developers'\n-lives better. We do not want users to be baffled by compiler output or\n-learn arcane patterns to compile their program.\n-\n-## Error, Warning, Help, Note Messages\n-\n-When the compiler detects a problem, it can emit one of the following: an error, a warning,\n-a note, or a help message.\n-\n-An `error` is emitted when the compiler detects a problem that makes it unable\n- to compile the program, either because the program is invalid or the\n- programmer has decided to make a specific `warning` into an error.\n-\n-A `warning` is emitted when the compiler detects something odd about a\n-program. For instance, dead code and unused `Result` values.\n-\n-A `help` message is emitted following an `error` or `warning` to give additional\n-information to the user about how to solve their problem.\n-\n-A `note` is emitted to identify additional circumstances and parts of the code\n-that caused the warning or error. For example, the borrow checker will note any\n-previous conflicting borrows.\n-\n-* Write in plain simple English. If your message, when shown on a \u2013 possibly\n-small \u2013 screen (which hasn't been cleaned for a while), cannot be understood\n-by a normal programmer, who just came out of bed after a night partying, it's\n-too complex.\n-* `Errors` and `Warnings` should not suggest how to fix the problem. A `Help`\n-message should be emitted instead.\n-* `Error`, `Warning`, `Note`, and `Help` messages start with a lowercase\n-letter and do not end with punctuation.\n-* Error messages should be succinct. Users will see these error messages many\n-times, and more verbose descriptions can be viewed with the `--explain` flag.\n-That said, don't make it so terse that it's hard to understand.\n-* The word \"illegal\" is illegal. Prefer \"invalid\" or a more specific word\n-instead.\n-* Errors should document the span of code where they occur \u2013 the `span_..`\n-methods allow to easily do this. Also `note` other spans that have contributed\n-to the error if the span isn't too large.\n-* When emitting a message with span, try to reduce the span to the smallest\n-amount possible that still signifies the issue\n-* Try not to emit multiple error messages for the same error. This may require\n-detecting duplicates.\n-* When the compiler has too little information for a specific error message,\n-lobby for annotations for library code that allow adding more. For example see\n-`#[on_unimplemented]`. Use these annotations when available!\n-* Keep in mind that Rust's learning curve is rather steep, and that the\n-compiler messages are an important learning tool.\n-\n-## Error Explanations\n-\n-Error explanations are long form descriptions of error messages provided with\n-the compiler. They are accessible via the `--explain` flag. Each explanation\n-comes with an example of how to trigger it and advice on how to fix it.\n-\n-Please read [RFC 1567](https://github.com/rust-lang/rfcs/blob/master/text/1567-long-error-codes-explanation-normalization.md)\n-for details on how to format and write long error codes.\n-\n-* All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n-  which are auto-generated from rustc source code in different places:\n-  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/error_codes.rs),\n-  [librustc_ast](https://github.com/rust-lang/rust/blob/master/src/librustc_ast/error_codes.rs),\n-  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/error_codes.rs),\n-  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/error_codes.rs),\n-  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/error_codes.rs),\n-  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/error_codes.rs),\n-  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n-  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n-  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n-  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n-* Explanations have full markdown support. Use it, especially to highlight\n-code with backticks.\n-* When talking about the compiler, call it `the compiler`, not `Rust` or\n-`rustc`.\n-\n-## Compiler Flags\n-\n-* Flags should be orthogonal to each other. For example, if we'd have a\n-json-emitting variant of multiple actions `foo` and `bar`, an additional\n---json flag is better than adding `--foo-json` and `--bar-json`.\n-* Always give options a long descriptive name, if only for more\n-understandable compiler scripts.\n-* The `--verbose` flag is for adding verbose information to `rustc` output\n-when not compiling a program. For example, using it with the `--version` flag\n-gives information about the hashes of the code.\n-* Experimental flags and options must be guarded behind the `-Z unstable-options` flag."}, {"sha": "0b4bb05c1db23e66ead131d085b9ced6d7bf9141", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 358, "deletions": 234, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -7,12 +7,164 @@ a version of this list for your exact compiler by running `rustc -C help`.\n \n This option is deprecated and does nothing.\n \n-## linker\n+## code-model\n+\n+This option lets you choose which code model to use. \\\n+Code models put constraints on address ranges that the program and its symbols may use. \\\n+With smaller address ranges machine instructions\n+may be able to use use more compact addressing modes.\n+\n+The specific ranges depend on target architectures and addressing modes available to them. \\\n+For x86 more detailed description of its code models can be found in\n+[System V Application Binary Interface](https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf)\n+specification.\n+\n+Supported values for this option are:\n+\n+- `tiny` - Tiny code model.\n+- `small` - Small code model. This is the default model for majority of supported targets.\n+- `kernel` - Kernel code model.\n+- `medium` - Medium code model.\n+- `large` - Large code model.\n+\n+Supported values can also be discovered by running `rustc --print code-models`.\n+\n+## codegen-units\n+\n+This flag controls how many code generation units the crate is split into. It\n+takes an integer greater than 0.\n+\n+When a crate is split into multiple codegen units, LLVM is able to process\n+them in parallel. Increasing parallelism may speed up compile times, but may\n+also produce slower code. Setting this to 1 may improve the performance of\n+generated code, but may be slower to compile.\n+\n+The default value, if not specified, is 16 for non-incremental builds. For\n+incremental builds the default is 256 which allows caching to be more granular.\n+\n+## debug-assertions\n+\n+This flag lets you turn `cfg(debug_assertions)` [conditional\n+compilation](../../reference/conditional-compilation.md#debug_assertions) on\n+or off. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: enable debug-assertions.\n+* `n`, `no`, or `off`: disable debug-assertions.\n+\n+If not specified, debug assertions are automatically enabled only if the\n+[opt-level](#opt-level) is 0.\n+\n+## debuginfo\n+\n+This flag controls the generation of debug information. It takes one of the\n+following values:\n+\n+* `0`: no debug info at all (the default).\n+* `1`: line tables only.\n+* `2`: full debug info.\n+\n+Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n+\n+## default-linker-libraries\n+\n+This flag controls whether or not the linker includes its default libraries.\n+It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: include default libraries (the default).\n+* `n`, `no`, or `off`: exclude default libraries.\n \n-This flag lets you control which linker `rustc` invokes to link your code. It\n-takes a path to the linker executable. If this flag is not specified, the\n-linker will be inferred based on the target. See also the\n-[linker-flavor](#linker-flavor) flag for another way to specify the linker.\n+For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n+the linker.\n+\n+## embed-bitcode\n+\n+This flag controls whether or not the compiler embeds LLVM bitcode into object\n+files. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: put bitcode in rlibs (the default).\n+* `n`, `no`, or `off`: omit bitcode from rlibs.\n+\n+LLVM bitcode is required when rustc is performing link-time optimization (LTO).\n+It is also required on some targets like iOS ones where vendors look for LLVM\n+bitcode. Embedded bitcode will appear in rustc-generated object files inside of\n+a section whose name is defined by the target platform. Most of the time this is\n+`.llvmbc`.\n+\n+The use of `-C embed-bitcode=no` can significantly improve compile times and\n+reduce generated file sizes if your compilation does not actually need bitcode\n+(e.g. if you're not compiling for iOS or you're not performing LTO). For these\n+reasons, Cargo uses `-C embed-bitcode=no` whenever possible. Likewise, if you\n+are building directly with `rustc` we recommend using `-C embed-bitcode=no`\n+whenever you are not using LTO.\n+\n+If combined with `-C lto`, `-C embed-bitcode=no` will cause `rustc` to abort\n+at start-up, because the combination is invalid.\n+\n+> **Note**: if you're building Rust code with LTO then you probably don't even\n+> need the `embed-bitcode` option turned on. You'll likely want to use\n+> `-Clinker-plugin-lto` instead which skips generating object files entirely and\n+> simply replaces object files with LLVM bitcode. The only purpose for\n+> `-Cembed-bitcode` is when you're generating an rlib that is both being used\n+> with and without LTO. For example Rust's standard library ships with embedded\n+> bitcode since users link to it both with and without LTO.\n+>\n+> This also may make you wonder why the default is `yes` for this option. The\n+> reason for that is that it's how it was for rustc 1.44 and prior. In 1.45 this\n+> option was added to turn off what had always been the default.\n+\n+## extra-filename\n+\n+This option allows you to put extra data in each output filename. It takes a\n+string to add as a suffix to the filename. See the [`--emit`\n+flag][option-emit] for more information.\n+\n+## force-frame-pointers\n+\n+This flag forces the use of frame pointers. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: force-enable frame pointers.\n+* `n`, `no`, or `off`: do not force-enable frame pointers. This does\n+  not necessarily mean frame pointers will be removed.\n+\n+The default behaviour, if frame pointers are not force-enabled, depends on the\n+target.\n+\n+## force-unwind-tables\n+\n+This flag forces the generation of unwind tables. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: Unwind tables are forced to be generated.\n+* `n`, `no`, or `off`: Unwind tables are not forced to be generated. If unwind\n+  tables are required by the target or `-C panic=unwind`, an error will be\n+  emitted.\n+\n+The default if not specified depends on the target.\n+\n+## incremental\n+\n+This flag allows you to enable incremental compilation, which allows `rustc`\n+to save information after compiling a crate to be reused when recompiling the\n+crate, improving re-compile times. This takes a path to a directory where\n+incremental files will be stored.\n+\n+## inline-threshold\n+\n+This option lets you set the default threshold for inlining a function. It\n+takes an unsigned integer as a value. Inlining is based on a cost model, where\n+a higher threshold will allow more inlining.\n+\n+The default depends on the [opt-level](#opt-level):\n+\n+| opt-level | Threshold |\n+|-----------|-----------|\n+| 0         | N/A, only inlines always-inline functions |\n+| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n+| 2         | 225 |\n+| 3         | 275 |\n+| s         | 75 |\n+| z         | 25 |\n \n ## link-arg\n \n@@ -25,51 +177,91 @@ This flag lets you append a single extra argument to the linker invocation.\n This flag lets you append multiple extra arguments to the linker invocation. The\n options should be separated by spaces.\n \n-## linker-flavor\n+## link-dead-code\n+\n+This flag controls whether the linker will keep dead code. It takes one of\n+the following values:\n+\n+* `y`, `yes`, `on`, or no value: keep dead code.\n+* `n`, `no`, or `off`: remove dead code (the default).\n+\n+An example of when this flag might be useful is when trying to construct code coverage\n+metrics.\n \n-This flag lets you control the linker flavor used by `rustc`. If a linker is given with the\n-[`-C linker` flag](#linker), then the linker flavor is inferred from the value provided. If no\n-linker is given then the linker flavor is used to determine the linker to use. Every `rustc` target\n-defaults to some linker flavor. Valid options are:\n+## linker\n+\n+This flag controls which linker `rustc` invokes to link your code. It takes a\n+path to the linker executable. If this flag is not specified, the linker will\n+be inferred based on the target. See also the [linker-flavor](#linker-flavor)\n+flag for another way to specify the linker.\n \n-* `em`: Uses [Emscripten `emcc`](https://emscripten.org/docs/tools_reference/emcc.html).\n-* `gcc`: Uses the `cc` executable, which is typically gcc or clang on many systems.\n-* `ld`: Uses the `ld` executable.\n-* `msvc`: Uses the `link.exe` executable from Microsoft Visual Studio MSVC.\n-* `ptx-linker`: Uses\n+## linker-flavor\n+\n+This flag controls the linker flavor used by `rustc`. If a linker is given with\n+the [`-C linker` flag](#linker), then the linker flavor is inferred from the\n+value provided. If no linker is given then the linker flavor is used to\n+determine the linker to use. Every `rustc` target defaults to some linker\n+flavor. Valid options are:\n+\n+* `em`: use [Emscripten `emcc`](https://emscripten.org/docs/tools_reference/emcc.html).\n+* `gcc`: use the `cc` executable, which is typically gcc or clang on many systems.\n+* `ld`: use the `ld` executable.\n+* `msvc`: use the `link.exe` executable from Microsoft Visual Studio MSVC.\n+* `ptx-linker`: use\n   [`rust-ptx-linker`](https://github.com/denzp/rust-ptx-linker) for Nvidia\n   NVPTX GPGPU support.\n-* `wasm-ld`: Uses the [`wasm-ld`](https://lld.llvm.org/WebAssembly.html)\n+* `wasm-ld`: use the [`wasm-ld`](https://lld.llvm.org/WebAssembly.html)\n   executable, a port of LLVM `lld` for WebAssembly.\n-* `ld64.lld`: Uses the LLVM `lld` executable with the [`-flavor darwin`\n+* `ld64.lld`: use the LLVM `lld` executable with the [`-flavor darwin`\n   flag][lld-flavor] for Apple's `ld`.\n-* `ld.lld`: Uses the LLVM `lld` executable with the [`-flavor gnu`\n+* `ld.lld`: use the LLVM `lld` executable with the [`-flavor gnu`\n   flag][lld-flavor] for GNU binutils' `ld`.\n-* `lld-link`: Uses the LLVM `lld` executable with the [`-flavor link`\n+* `lld-link`: use the LLVM `lld` executable with the [`-flavor link`\n   flag][lld-flavor] for Microsoft's `link.exe`.\n \n [lld-flavor]: https://lld.llvm.org/Driver.html\n \n-## link-dead-code\n+## linker-plugin-lto\n \n-Normally, the linker will remove dead code. This flag disables this behavior.\n+This flag defers LTO optimizations to the linker. See\n+[linker-plugin-LTO](../linker-plugin-lto.md) for more details. It takes one of\n+the following values:\n \n-An example of when this flag might be useful is when trying to construct code coverage\n-metrics.\n+* `y`, `yes`, `on`, or no value: enable linker plugin LTO.\n+* `n`, `no`, or `off`: disable linker plugin LTO (the default).\n+* A path to the linker plugin.\n+\n+More specifically this flag will cause the compiler to replace its typical\n+object file output with LLVM bitcode files. For example an rlib produced with\n+`-Clinker-plugin-lto` will still have `*.o` files in it, but they'll all be LLVM\n+bitcode instead of actual machine code. It is expected that the native platform\n+linker is capable of loading these LLVM bitcode files and generating code at\n+link time (typically after performing optimizations).\n+\n+Note that rustc can also read its own object files produced with\n+`-Clinker-plugin-lto`. If an rlib is only ever going to get used later with a\n+`-Clto` compilation then you can pass `-Clinker-plugin-lto` to speed up\n+compilation and avoid generating object files that aren't used.\n+\n+## llvm-args\n+\n+This flag can be used to pass a list of arguments directly to LLVM.\n+\n+The list must be separated by spaces.\n+\n+Pass `--help` to see a list of options.\n \n ## lto\n \n-This flag instructs LLVM to use [link time\n+This flag controls whether LLVM uses [link time\n optimizations](https://llvm.org/docs/LinkTimeOptimization.html) to produce\n better optimized code, using whole-program analysis, at the cost of longer\n-linking time.\n+linking time. It takes one of the following values:\n \n-This flag may take one of the following values:\n-\n-* `y`, `yes`, `on`, `fat`, or no value: Performs \"fat\" LTO which attempts to\n+* `y`, `yes`, `on`, `fat`, or no value: perform \"fat\" LTO which attempts to\n   perform optimizations across all crates within the dependency graph.\n-* `n`, `no`, `off`: Disables LTO.\n-* `thin`: Performs [\"thin\"\n+* `n`, `no`, `off`: disables LTO.\n+* `thin`: perform [\"thin\"\n   LTO](http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html).\n   This is similar to \"fat\", but takes substantially less time to run while\n   still achieving performance gains similar to \"fat\".\n@@ -81,81 +273,67 @@ disabled if codegen units is 1 or optimizations are disabled ([`-C\n opt-level=0`](#opt-level)). That is:\n \n * When `-C lto` is not specified:\n-  * `codegen-units=1`: Disables LTO.\n-  * `opt-level=0`: Disables LTO.\n+  * `codegen-units=1`: disable LTO.\n+  * `opt-level=0`: disable LTO.\n * When `-C lto=true`:\n-  * `lto=true`: 16 codegen units, performs fat LTO across crates.\n+  * `lto=true`: 16 codegen units, perform fat LTO across crates.\n   * `codegen-units=1` + `lto=true`: 1 codegen unit, fat LTO across crates.\n \n See also [linker-plugin-lto](#linker-plugin-lto) for cross-language LTO.\n \n-## linker-plugin-lto\n-\n-Defers LTO optimizations to the linker. See\n-[linkger-plugin-LTO](../linker-plugin-lto.md) for more details. Takes one of\n-the following values:\n-\n-* `y`, `yes`, `on`, or no value: Enabled.\n-* `n`, `no`, or `off`: Disabled (default).\n-* A path to the linker plugin.\n-\n-## target-cpu\n-\n-This instructs `rustc` to generate code specifically for a particular processor.\n-\n-You can run `rustc --print target-cpus` to see the valid options to pass\n-here. Additionally, `native` can be passed to use the processor of the host\n-machine. Each target has a default base CPU.\n-\n-## target-feature\n+## metadata\n \n-Individual targets will support different features; this flag lets you control\n-enabling or disabling a feature. Each feature should be prefixed with a `+` to\n-enable it or `-` to disable it. Separate multiple features with commas.\n+This option allows you to control the metadata used for symbol mangling. This\n+takes a space-separated list of strings. Mangled symbols will incorporate a\n+hash of the metadata. This may be used, for example, to differentiate symbols\n+between two different versions of the same crate being linked.\n \n-To see the valid options and an example of use, run `rustc --print\n-target-features`.\n+## no-prepopulate-passes\n \n-Using this flag is unsafe and might result in [undefined runtime\n-behavior](../targets/known-issues.md).\n+This flag tells the pass manager to use an empty list of passes, instead of the\n+usual pre-populated list of passes.\n \n-See also the [`target_feature`\n-attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n-for controlling features per-function.\n+## no-redzone\n \n-This also supports the feature `+crt-static` and `-crt-static` to control\n-[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n+This flag allows you to disable [the\n+red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). It takes one\n+of the following values:\n \n-Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n-features.\n+* `y`, `yes`, `on`, or no value: disable the red zone.\n+* `n`, `no`, or `off`: enable the red zone.\n \n-## passes\n+The default behaviour, if the flag is not specified, depends on the target.\n \n-This flag can be used to add extra [LLVM\n-passes](http://llvm.org/docs/Passes.html) to the compilation.\n+## no-stack-check\n \n-The list must be separated by spaces.\n+This option is deprecated and does nothing.\n \n-See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n+## no-vectorize-loops\n \n-## llvm-args\n+This flag disables [loop\n+vectorization](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer).\n \n-This flag can be used to pass a list of arguments directly to LLVM.\n+## no-vectorize-slp\n \n-The list must be separated by spaces.\n+This flag disables vectorization using\n+[superword-level\n+parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer).\n \n-Pass `--help` to see a list of options.\n+## opt-level\n \n-## save-temps\n+This flag controls the optimization level.\n \n-`rustc` will generate temporary files during compilation; normally it will\n-delete them after it's done with its work. This option will cause them to be\n-preserved instead of removed.\n+* `0`: no optimizations, also turns on\n+  [`cfg(debug_assertions)`](#debug-assertions) (the default).\n+* `1`: basic optimizations.\n+* `2`: some optimizations.\n+* `3`: all optimizations.\n+* `s`: optimize for binary size.\n+* `z`: optimize for binary size, but also turn off loop vectorization.\n \n-## rpath\n+Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n \n-This option allows you to enable\n-[`rpath`](https://en.wikipedia.org/wiki/Rpath).\n+The default is `0`.\n \n ## overflow-checks\n \n@@ -164,35 +342,29 @@ overflow](../../reference/expressions/operator-expr.md#overflow). When\n overflow-checks are enabled, a panic will occur on overflow. This flag takes\n one of the following values:\n \n-* `y`, `yes`, `on`, or no value: Enable overflow checks.\n-* `n`, `no`, or `off`: Disable overflow checks.\n+* `y`, `yes`, `on`, or no value: enable overflow checks.\n+* `n`, `no`, or `off`: disable overflow checks.\n \n If not specified, overflow checks are enabled if\n [debug-assertions](#debug-assertions) are enabled, disabled otherwise.\n \n-## no-prepopulate-passes\n+## panic\n \n-The pass manager comes pre-populated with a list of passes; this flag\n-ensures that list is empty.\n+This option lets you control what happens when the code panics.\n \n-## no-vectorize-loops\n+* `abort`: terminate the process upon panic\n+* `unwind`: unwind the stack upon panic\n \n-By default, `rustc` will attempt to [vectorize\n-loops](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer). This\n-flag will turn that behavior off.\n+If not specified, the default depends on the target.\n \n-## no-vectorize-slp\n+## passes\n \n-By default, `rustc` will attempt to vectorize code using [superword-level\n-parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n-flag will turn that behavior off.\n+This flag can be used to add extra [LLVM\n+passes](http://llvm.org/docs/Passes.html) to the compilation.\n \n-## soft-float\n+The list must be separated by spaces.\n \n-This option will make `rustc` generate code using \"soft floats.\" By default,\n-a lot of hardware supports floating point instructions, and so the code generated\n-will take advantage of this. \"soft floats\" emulate floating point instructions\n-in software.\n+See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n \n ## prefer-dynamic\n \n@@ -201,65 +373,68 @@ indicate that dynamic linking should be used if possible if both a static and\n dynamic versions of a library are available. There is an internal algorithm\n for determining whether or not it is possible to statically or dynamically\n link with a dependency. For example, `cdylib` crate types may only use static\n-linkage.\n-\n-## no-integrated-as\n+linkage. This flag takes one of the following values:\n \n-`rustc` normally uses the LLVM internal assembler to create object code. This\n-flag will disable the internal assembler and emit assembly code to be\n-translated using an external assembler, currently the linker such as `cc`.\n+* `y`, `yes`, `on`, or no value: use dynamic linking.\n+* `n`, `no`, or `off`: use static linking (the default).\n \n-## no-redzone\n+## profile-generate\n \n-This flag allows you to disable [the\n-red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). This flag can\n-be passed one of the following options:\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization] for more information.\n \n-* `y`, `yes`, `on`, or no value: Disables the red zone.\n-* `n`, `no`, or `off`: Enables the red zone.\n+## profile-use\n \n-The default if not specified depends on the target.\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization] for more information.\n \n ## relocation-model\n \n-This option lets you choose which\n-[relocation](https://en.wikipedia.org/wiki/Relocation_\\(computing\\)) model to\n-use.\n-\n-To find the valid options for this flag, run `rustc --print relocation-models`.\n+This option controls generation of\n+[position-independent code (PIC)](https://en.wikipedia.org/wiki/Position-independent_code).\n \n-## code-model\n+Supported values for this option are:\n \n-This option lets you choose which code model to use.\n+#### Primary relocation models\n \n-To find the valid options for this flag, run `rustc --print code-models`.\n-\n-## metadata\n+- `static` - non-relocatable code, machine instructions may use absolute addressing modes.\n \n-This option allows you to control the metadata used for symbol mangling. This\n-takes a space-separated list of strings. Mangled symbols will incorporate a\n-hash of the metadata. This may be used, for example, to differentiate symbols\n-between two different versions of the same crate being linked.\n+- `pic` - fully relocatable position independent code,\n+machine instructions need to use relative addressing modes.  \\\n+Equivalent to the \"uppercase\" `-fPIC` or `-fPIE` options in other compilers,\n+depending on the produced crate types.  \\\n+This is the default model for majority of supported targets.\n \n-## extra-filename\n+#### Special relocation models\n \n-This option allows you to put extra data in each output filename. It takes a\n-string to add as a suffix to the filename. See the [`--emit`\n-flag][option-emit] for more information.\n+- `dynamic-no-pic` - relocatable external references, non-relocatable code.  \\\n+Only makes sense on Darwin and is rarely used.  \\\n+If StackOverflow tells you to use this as an opt-out of PIC or PIE, don't believe it,\n+use `-C relocation-model=static` instead.\n+- `ropi`, `rwpi` and `ropi-rwpi` - relocatable code and read-only data, relocatable read-write data,\n+and combination of both, respectively.  \\\n+Only makes sense for certain embedded ARM targets.\n+- `default` - relocation model default to the current target.  \\\n+Only makes sense as an override for some other explicitly specified relocation model\n+previously set on the command line.\n \n-## codegen-units\n+Supported values can also be discovered by running `rustc --print relocation-models`.\n \n-This flag controls how many code generation units the crate is split into. It\n-takes an integer greater than 0.\n+#### Linking effects\n \n-When a crate is split into multiple codegen units, LLVM is able to process\n-them in parallel. Increasing parallelism may speed up compile times, but may\n-also produce slower code. Setting this to 1 may improve the performance of\n-generated code, but may be slower to compile.\n+In addition to codegen effects, `relocation-model` has effects during linking.\n \n-The default, if not specified, is 16. This flag is ignored if\n-[incremental](#incremental) is enabled, in which case an internal heuristic is\n-used to split the crate.\n+If the relocation model is `pic` and the current target supports position-independent executables\n+(PIE), the linker will be instructed (`-pie`) to produce one.  \\\n+If the target doesn't support both position-independent and statically linked executables,\n+then `-C target-feature=+crt-static` \"wins\" over `-C relocation-model=pic`,\n+and the linker is instructed (`-static`) to produce a statically linked\n+but not position-independent executable.\n \n ## remark\n \n@@ -269,118 +444,67 @@ The list of passes should be separated by spaces.\n \n `all` will remark on every pass.\n \n-## no-stack-check\n-\n-This option is deprecated and does nothing.\n-\n-## debuginfo\n-\n-This flag lets you control debug information:\n-\n-* `0`: no debug info at all (default)\n-* `1`: line tables only\n-* `2`: full debug info\n-\n-Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n-\n-## opt-level\n-\n-This flag lets you control the optimization level.\n-\n-* `0`: no optimizations, also turns on [`cfg(debug_assertions)`](#debug-assertions).\n-* `1`: basic optimizations\n-* `2`: some optimizations\n-* `3`: all optimizations\n-* `s`: optimize for binary size\n-* `z`: optimize for binary size, but also turn off loop vectorization.\n-\n-Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n-\n-The default is `0`.\n-\n-## debug-assertions\n-\n-This flag lets you turn `cfg(debug_assertions)` [conditional\n-compilation](../../reference/conditional-compilation.md#debug_assertions) on\n-or off. It takes one of the following values:\n-\n-* `y`, `yes`, `on`, or no value: Enable debug-assertions.\n-* `n`, `no`, or `off`: Disable debug-assertions.\n-\n-If not specified, debug assertions are automatically enabled only if the\n-[opt-level](#opt-level) is 0.\n-\n-## inline-threshold\n-\n-This option lets you set the default threshold for inlining a function. It\n-takes an unsigned integer as a value. Inlining is based on a cost model, where\n-a higher threshold will allow more inlining.\n-\n-The default depends on the [opt-level](#opt-level):\n+## rpath\n \n-| opt-level | Threshold |\n-|-----------|-----------|\n-| 0         | N/A, only inlines always-inline functions |\n-| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n-| 2         | 225 |\n-| 3         | 275 |\n-| s         | 75 |\n-| z         | 25 |\n+This flag controls whether [`rpath`](https://en.wikipedia.org/wiki/Rpath) is\n+enabled. It takes one of the following values:\n \n-## panic\n+* `y`, `yes`, `on`, or no value: enable rpath.\n+* `n`, `no`, or `off`: disable rpath (the default).\n \n-This option lets you control what happens when the code panics.\n+## save-temps\n \n-* `abort`: terminate the process upon panic\n-* `unwind`: unwind the stack upon panic\n+This flag controls whether temporary files generated during compilation are\n+deleted once compilation finishes. It takes one of the following values:\n \n-If not specified, the default depends on the target.\n+* `y`, `yes`, `on`, or no value: save temporary files.\n+* `n`, `no`, or `off`: delete temporary files (the default).\n \n-## incremental\n+## soft-float\n \n-This flag allows you to enable incremental compilation, which allows `rustc`\n-to save information after compiling a crate to be reused when recompiling the\n-crate, improving re-compile times. This takes a path to a directory where\n-incremental files will be stored.\n+This option controls whether `rustc` generates code that emulates floating\n+point instructions in software. It takes one of the following values:\n \n-## profile-generate\n+* `y`, `yes`, `on`, or no value: use soft floats.\n+* `n`, `no`, or `off`: use hardware floats (the default).\n \n-This flag allows for creating instrumented binaries that will collect\n-profiling data for use with profile-guided optimization (PGO). The flag takes\n-an optional argument which is the path to a directory into which the\n-instrumented binary will emit the collected data. See the chapter on\n-[profile-guided optimization] for more information.\n-\n-## profile-use\n+## target-cpu\n \n-This flag specifies the profiling data file to be used for profile-guided\n-optimization (PGO). The flag takes a mandatory argument which is the path\n-to a valid `.profdata` file. See the chapter on\n-[profile-guided optimization] for more information.\n+This instructs `rustc` to generate code specifically for a particular processor.\n \n-## force-frame-pointers\n+You can run `rustc --print target-cpus` to see the valid options to pass\n+here. Additionally, `native` can be passed to use the processor of the host\n+machine. Each target has a default base CPU.\n \n-This flag forces the use of frame pointers. It takes one of the following\n-values:\n+## target-feature\n \n-* `y`, `yes`, `on`, or no value: Frame pointers are forced to be enabled.\n-* `n`, `no`, or `off`: Frame pointers are not forced to be enabled. This does\n-  not necessarily mean frame pointers will be removed.\n+Individual targets will support different features; this flag lets you control\n+enabling or disabling a feature. Each feature should be prefixed with a `+` to\n+enable it or `-` to disable it.\n \n-The default if not specified depends on the target.\n+Features from multiple `-C target-feature` options are combined. \\\n+Multiple features can be specified in a single option by separating them\n+with commas - `-C target-feature=+x,-y`. \\\n+If some feature is specified more than once with both `+` and `-`,\n+then values passed later override values passed earlier. \\\n+For example, `-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y`\n+is equivalent to `-C target-feature=-x,+y,+z`.\n \n-## default-linker-libraries\n+To see the valid options and an example of use, run `rustc --print\n+target-features`.\n \n-This flag controls whether or not the linker includes its default libraries.\n-It takes one of the following values:\n+Using this flag is unsafe and might result in [undefined runtime\n+behavior](../targets/known-issues.md).\n \n-* `y`, `yes`, `on`, or no value: Default libraries are included.\n-* `n`, `no`, or `off`: Default libraries are **not** included.\n+See also the [`target_feature`\n+attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n+for controlling features per-function.\n \n-For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n-the linker.\n+This also supports the feature `+crt-static` and `-crt-static` to control\n+[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n \n-The default is `yes` if not specified.\n+Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n+features.\n \n [option-emit]: ../command-line-arguments.md#option-emit\n [option-o-optimize]: ../command-line-arguments.md#option-o-optimize"}, {"sha": "30b18eb56a1256c0d011ce58c7f0a200e8985014", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -273,10 +273,18 @@ This flag, when combined with other flags, makes them produce extra output.\n This flag allows you to pass the name and location for an external crate of a\n direct dependency. Indirect dependencies (dependencies of dependencies) are\n located using the [`-L` flag](#option-l-search-path). The given crate name is\n-added to the [extern prelude], which is the same as specifying `extern crate`\n-within the root module. The given crate name does not need to match the name\n+added to the [extern prelude], similar to specifying `extern crate` within the\n+root module. The given crate name does not need to match the name\n the library was built with.\n \n+Specifying `--extern` has one behavior difference from `extern crate`:\n+`--extern` merely makes the crate a _candidate_ for being linked; it does not\n+actually link it unless it's actively used. In rare occasions you may wish\n+to ensure a crate is linked even if you don't actively use it from your\n+code: for example, if it changes the global allocator or if it contains\n+`#[no_mangle]` symbols for use by other programming languages. In such\n+cases you'll need to use `extern crate`.\n+\n This flag may be specified multiple times. This flag takes an argument with\n either of the following formats:\n "}, {"sha": "5dee603142dcd006067653828627192ac6023f52", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -59,8 +59,11 @@ Diagnostics have the following format:\n     \"spans\": [\n         {\n             /* The file where the span is located.\n-               For spans located within a macro expansion, this will be the\n-               name of the expanded macro in the format \"<MACRONAME macros>\".\n+               Note that this path may not exist. For example, if the path\n+               points to the standard library, and the rust src is not\n+               available in the sysroot, then it may point to a non-existent\n+               file. Beware that this may also point to the source of an\n+               external crate.\n             */\n             \"file_name\": \"lib.rs\",\n             /* The byte offset where the span starts (0-based, inclusive). */\n@@ -168,7 +171,7 @@ Diagnostics have the following format:\n             \"rendered\": null\n         },\n         {\n-            \"message\": \"consider prefixing with an underscore\",\n+            \"message\": \"if this is intentional, prefix it with an underscore\",\n             \"code\": null,\n             \"level\": \"help\",\n             \"spans\": [\n@@ -201,7 +204,7 @@ Diagnostics have the following format:\n     /* Optional string of the rendered version of the diagnostic as displayed\n        by rustc. Note that this may be influenced by the `--json` flag.\n     */\n-    \"rendered\": \"warning: unused variable: `x`\\n --> lib.rs:2:9\\n  |\\n2 |     let x = 123;\\n  |         ^ help: consider prefixing with an underscore: `_x`\\n  |\\n  = note: `#[warn(unused_variables)]` on by default\\n\\n\"\n+    \"rendered\": \"warning: unused variable: `x`\\n --> lib.rs:2:9\\n  |\\n2 |     let x = 123;\\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\\n  |\\n  = note: `#[warn(unused_variables)]` on by default\\n\\n\"\n }\n ```\n "}, {"sha": "c0b14352b7d1a6be4dacb64f0c05188db98d0b4a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -100,11 +100,17 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           |  Clang 7  |  Clang 8  |\n-|-----------|-----------|-----------|\n-| Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |     \u2713     |\n-| Rust 1.36 |     \u2717     |     \u2713     |\n-| Rust 1.37 |     \u2717     |     \u2713     |\n+|           |  Clang 7  |  Clang 8  |  Clang 9  |\n+|-----------|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.35 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.36 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.37 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.38 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.39 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.40 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.41 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.42 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.43 |     \u2717     |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "64cbbbb003585fee465012f1115e831bb775d26c", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -170,7 +170,7 @@ The order of these command line arguments is taken into account. The following a\n $ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables\n ```\n \n-You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group:\n+You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group (forbid still trumps everything regardless of ordering):\n \n ```bash\n $ rustc lib.rs --crate-type=lib -D unused -A unused-variables"}, {"sha": "31e002810ce4b9f46a2c7186101da02c162da79b", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -390,3 +390,15 @@ the same CSS rules as the official `light` theme.\n `--check-theme` is a separate mode in `rustdoc`. When `rustdoc` sees the\n `--check-theme` flag, it discards all other flags and only performs the CSS rule\n comparison operation.\n+\n+### `--crate-version`: control the crate version\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs --crate-version 1.3.37\n+```\n+\n+When `rustdoc` receives this flag, it will print an extra \"Version (version)\" into the sidebar of\n+the crate root's docs. You can use this flag to differentiate between different versions of your\n+library's documentation."}, {"sha": "18010bebcf0e773315655165328e48cd1be793d9", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -352,9 +352,9 @@ are added.\n /// ```\n ```\n \n-`edition2018` tells `rustdoc` that the code sample should be compiled the 2018\n-edition of Rust. Similarly, you can specify `edition2015` to compile the code\n-with the 2015 edition.\n+`edition2018` tells `rustdoc` that the code sample should be compiled using\n+the 2018 edition of Rust. Similarly, you can specify `edition2015` to compile\n+the code with the 2015 edition.\n \n ## Syntax reference\n \n@@ -416,7 +416,7 @@ without including it in your main documentation. For example, you could write th\n `lib.rs` to test your README as part of your doctests:\n \n ```rust,ignore\n-#![feature(extern_doc)]\n+#![feature(external_doc)]\n \n #[doc(include=\"../README.md\")]\n #[cfg(doctest)]"}, {"sha": "081e477de8010ce0db928b68d7fec560c4a1bba9", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -17,7 +17,7 @@ By default, rustdoc will run some passes, namely:\n * `collapse-docs`\n * `unindent-comments`\n \n-However, `strip-private` implies `strip-private-imports`, and so effectively,\n+However, `strip-private` implies `strip-priv-imports`, and so effectively,\n all passes are run by default.\n \n ## `strip-hidden`"}, {"sha": "84e1ebe5e01f581523a3f6eec83a4db8155f103d", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -248,18 +248,6 @@ Markdown file, the URL given to `--markdown-playground-url` will take precedence\n `--playground-url` and `#![doc(html_playground_url = \"url\")]` are present when rendering crate docs,\n the attribute will take precedence.\n \n-### `--crate-version`: control the crate version\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc src/lib.rs -Z unstable-options --crate-version 1.3.37\n-```\n-\n-When `rustdoc` receives this flag, it will print an extra \"Version (version)\" into the sidebar of\n-the crate root's docs. You can use this flag to differentiate between different versions of your\n-library's documentation.\n-\n ### `--sort-modules-by-appearance`: control how items on module pages are sorted\n \n Using this flag looks like this:"}, {"sha": "0cd56d0940451ab40a0391c193c685e7b333342c", "filename": "src/doc/unstable-book/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fbook.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,6 @@\n [book]\n title = \"The Rust Unstable Book\"\n author = \"The Rust Community\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book\""}, {"sha": "4115825e920838947ab4dee93124a1811980daaf", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,33 +1,57 @@\n-# `control_flow_guard`\n+# `control-flow-guard`\n \n The tracking issue for this feature is: [#68793](https://github.com/rust-lang/rust/issues/68793).\n \n ------------------------\n \n-The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+The rustc flag `-Z control-flow-guard` enables the Windows [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) (CFG) platform security feature.\n \n-[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported Windows platforms (Windows 8.1 onwards). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n \n-For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.\n \n-It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+In terms of interoperability:\n+- Code compiled with CFG enabled can be linked with libraries and object files that are not compiled with CFG. In this case, a CFG-aware linker can identify address-taken functions in the non-CFG libraries.\n+- Libraries compiled with CFG can linked into non-CFG programs. In this case, the CFG runtime checks in the libraries are not used (i.e. the mitigation is completely disabled).\n \n-To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+CFG functionality is completely implemented in the LLVM backend and is supported for X86 (32-bit and 64-bit), ARM, and Aarch64 targets. The rustc flag adds the relevant LLVM module flags to enable the feature. This flag will be ignored for all non-Windows targets.\n+\n+\n+## When to use Control Flow Guard\n+\n+The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword\n+\n+\n+## Overhead of Control Flow Guard\n+\n+The CFG checks and metadata can potentially increase binary size and runtime overhead. The magnitude of any increase depends on the number and frequency of indirect calls. For example, enabling CFG for the Rust standard library increases binary size by approximately 0.14%. Enabling CFG in the SPEC CPU 2017 Integer Speed benchmark suite (compiled with Clang/LLVM) incurs approximate runtime overheads of between 0% and 8%, with a geometric mean of 2.9%.\n+\n+\n+## Testing Control Flow Guard\n+\n+The rustc flag `-Z control-flow-guard=nochecks` instructs LLVM to emit the list of valid call targets without inserting runtime checks. This flag should only be used for testing purposes as it does not provide security enforcement.\n+\n+\n+## Control Flow Guard in libraries\n+\n+It is strongly recommended to also enable CFG checks for all linked libraries, including the standard library. \n+\n+To enable CFG in the standard library, use the [cargo `-Z build-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program.\n \n [build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n \n For example:\n ```cmd\n rustup toolchain install --force nightly\n rustup component add rust-src\n-SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+SET RUSTFLAGS=-Z control-flow-guard\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n \n ```PowerShell\n rustup toolchain install --force nightly\n rustup component add rust-src\n-$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+$Env:RUSTFLAGS = \"-Z control-flow-guard\"\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n "}, {"sha": "7973b3e4f2f322ad40bd1bcea87f85742de9e193", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -12,10 +12,16 @@ For example:\n ```Bash\n cargo new testgcov --bin\n cd testgcov\n-export RUSTFLAGS=\"-Zprofile\"\n+export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\"\n+export CARGO_INCREMENTAL=0\n cargo build\n cargo run\n ```\n \n Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n You can parse them with [llvm-cov gcov](https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/mozilla/grcov).\n+\n+Please note that `RUSTFLAGS` by default applies to everything that cargo builds and runs during a build!\n+When the `--target` flag is explicitly passed to cargo, the `RUSTFLAGS` no longer apply to build scripts and procedural macros. \n+For more fine-grained control consider passing a `RUSTC_WRAPPER` program to cargo that only adds the profiling flags to \n+rustc for the specific crates you want to profile."}, {"sha": "68265d8a9e8108562776d0319f30fa2aadb79d14", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -22,7 +22,7 @@ Available options:\n \n ```sh\n --report-time [plain|colored]\n-                Show execution time of each test. Awailable values:\n+                Show execution time of each test. Available values:\n                 plain = do not colorize the execution time (default);\n                 colored = colorize output according to the `color`\n                 parameter value;"}, {"sha": "5e2e04c063bc483abff4700462958c6791e9573a", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 149, "deletions": 86, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -6,73 +6,77 @@ The tracking issue for this feature is: [#39699](https://github.com/rust-lang/ru\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n-  detect out-of-bounds access to heap, stack, and globals, use after free, use\n-  after return, double free, invalid free, memory leaks.\n+* [AddressSanitizer][clang-asan] a fast memory error detector.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n-of `address`, `leak`, `memory` or `thread`.\n+To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`.\n \n-# Examples\n+# AddressSanitizer\n \n-This sections show various issues that can be detected with sanitizers.  For\n-simplicity, the examples are prepared under assumption that optimization level\n-used is zero.\n+AddressSanitizer is a memory error detector. It can detect the following types\n+of bugs:\n \n-## AddressSanitizer\n+* Out of bound accesses to heap, stack and globals\n+* Use after free\n+* Use after return (runtime flag `ASAN_OPTIONS=detect_stack_use_after_return=1`)\n+* Use after scope\n+* Double-free, invalid free\n+* Memory leaks\n+\n+AddressSanitizer is supported on the following targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+AddressSanitizer works with non-instrumented code although it will impede its\n+ability to detect some bugs.  It is not expected to produce false positive\n+reports.\n+\n+## Examples\n \n Stack buffer overflow:\n \n-```shell\n-$ cat a.rs\n+```rust\n fn main() {\n     let xs = [0, 1, 2, 3];\n     let _y = unsafe { *xs.as_ptr().offset(4) };\n }\n-$ rustc -Zsanitizer=address a.rs\n-$ ./a\n-=================================================================\n-==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n-READ of size 4 at 0x7ffcc15f43d0 thread T0\n-    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n-    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n-    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n-    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n-    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n-    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n-    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n-    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n-    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n-    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n-    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n-\n-Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n-    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\n+READ of size 4 at 0x7ffe400e6250 thread T0\n+    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n+    ...\n+\n+Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n \n   This frame has 1 object(s):\n-    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\n Shadow bytes around the buggy address:\n-  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n-  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n+  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n-  Partially addressable: 01 02 03 04 05 06 07 \n+  Partially addressable: 01 02 03 04 05 06 07\n   Heap left redzone:       fa\n   Freed heap region:       fd\n   Stack left redzone:      f1\n@@ -90,13 +94,12 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==10029==ABORTING\n+==37882==ABORTING\n ```\n \n Use of a stack object after its scope has already ended:\n \n-```shell\n-$ cat b.rs\n+```rust\n static mut P: *mut usize = std::ptr::null_mut();\n \n fn main() {\n@@ -108,42 +111,38 @@ fn main() {\n         std::ptr::write_volatile(P, 123);\n     }\n }\n-$ rustc -Zsanitizer=address b.rs\n-$./b\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n =================================================================\n-==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n-WRITE of size 8 at 0x7fff67be6be0 thread T0\n-    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n-    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n-    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n-    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n-    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n-    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n-    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n-    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n-    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n-\n-Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n-    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\n+WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n+    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n+    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n+    ...\n+\n+Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n \n   This frame has 1 object(s):\n-    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\n Shadow bytes around the buggy address:\n-  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n-  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n+  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n   Partially addressable: 01 02 03 04 05 06 07\n@@ -164,17 +163,26 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==424427==ABORTING\n+==39249==ABORTING\n ```\n \n-## MemorySanitizer\n+# MemorySanitizer\n+\n+MemorySanitizer is detector of uninitialized reads. It is only supported on the\n+`x86_64-unknown-linux-gnu` target.\n+\n+MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n+need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n+achieve that will result in false positive reports.\n+\n+## Example\n \n-Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n-the standard library, and passing `-Zsanitizer-track-origins` to track the\n+Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n+instruments the standard library, and is strictly necessary for the correct\n+operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n origins of uninitialized memory:\n \n-```shell\n-$ cat src/main.rs\n+```rust\n use std::mem::MaybeUninit;\n \n fn main() {\n@@ -184,7 +192,9 @@ fn main() {\n         println!(\"{}\", a[2]);\n     }\n }\n+```\n \n+```shell\n $ export \\\n   CC=clang \\\n   CXX=clang++ \\\n@@ -193,7 +203,7 @@ $ export \\\n   RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n   RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n $ cargo clean\n-$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n ==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n     #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n ...\n@@ -205,6 +215,55 @@ $ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n     #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n ```\n \n+# ThreadSanitizer\n+\n+ThreadSanitizer is a data race detection tool. It is supported on the following\n+targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+To work correctly ThreadSanitizer needs to be \"aware\" of all synchronization\n+operations in a program. It generally achieves that through combination of\n+library interception (for example synchronization performed through\n+`pthread_mutex_lock` / `pthread_mutex_unlock`) and compile time instrumentation\n+(e.g. atomic operations). Using it without instrumenting all the program code\n+can lead to false positive reports.\n+\n+ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n+nor synchronization performed using inline assembly code.\n+\n+## Example\n+\n+```rust\n+static mut A: usize = 0;\n+\n+fn main() {\n+    let t = std::thread::spawn(|| {\n+        unsafe { A += 1 };\n+    });\n+    unsafe { A += 1 };\n+\n+    t.join().unwrap();\n+}\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==================\n+WARNING: ThreadSanitizer: data race (pid=10574)\n+  Read of size 8 at 0x5632dfe3d030 by thread T1:\n+    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)\n+    ...\n+\n+  Previous write of size 8 at 0x5632dfe3d030 by main thread:\n+    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)\n+    ...\n+    #11 main <null> (example+0x86a1a)\n+\n+  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)\n+```\n \n # Instrumentation of external dependencies and std\n \n@@ -231,6 +290,10 @@ In more practical terms when using cargo always remember to pass `--target`\n flag, so that rustflags will not be applied to build scripts and procedural\n macros.\n \n+# Symbolizing the Reports\n+\n+Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PATH`.\n+\n # Additional Information\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)"}, {"sha": "5a7d0655a440aec788bee1d2c6565ed2797c2e00", "filename": "src/doc/unstable-book/src/compiler-flags/src-hash-algorithm.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,11 @@\n+# `src-hash-algorithm`\n+\n+The tracking issue for this feature is: [#70401](https://github.com/rust-lang/rust/issues/70401).\n+\n+------------------------\n+\n+The `-Z src-hash-algorithm` compiler flag controls which algorithm is used when hashing each source file. The hash is stored in the debug info and can be used by a debugger to verify the source code matches the executable.\n+\n+Supported hash algorithms are: `md5`, and `sha1`. Note that not all hash algorithms are supported by all debug info formats.\n+\n+By default, the compiler chooses the hash algorithm based on the target specification."}, {"sha": "52cb98113c0c13296221f34d0daa6bfee04231cf", "filename": "src/doc/unstable-book/src/compiler-flags/strip.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,17 @@\n+# `strip`\n+\n+The tracking issue for this feature is: [#72110](https://github.com/rust-lang/rust/issues/72110).\n+\n+------------------------\n+\n+Option `-Z strip=val` controls stripping of debuginfo and similar auxiliary data from binaries\n+during linking.\n+\n+Supported values for this option are:\n+\n+- `none` - debuginfo and symbols (if they exist) are copied to the produced binary or separate files\n+depending on the target (e.g. `.pdb` files in case of MSVC).\n+- `debuginfo` - debuginfo sections and debuginfo symbols from the symbol table section\n+are stripped at link time and are not copied to the produced binary or separate files.\n+- `symbols` - same as `debuginfo`, but the rest of the symbol table section is stripped as well\n+if the linker supports it."}, {"sha": "0aefaa7fb01773794d5ca522ab18952ea8bc79cb", "filename": "src/doc/unstable-book/src/compiler-flags/tls-model.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,25 @@\n+# `tls_model`\n+\n+The tracking issue for this feature is: None.\n+\n+------------------------\n+\n+Option `-Z tls-model` controls [TLS model](https://www.akkadia.org/drepper/tls.pdf) used to\n+generate code for accessing `#[thread_local]` `static` items.\n+\n+Supported values for this option are:\n+\n+- `global-dynamic` - General Dynamic TLS Model (alternatively called Global Dynamic) is the most\n+general option usable in all circumstances, even if the TLS data is defined in a shared library\n+loaded at runtime and is accessed from code outside of that library.  \n+This is the default for most targets.\n+- `local-dynamic` - model usable if the TLS data is only accessed from the shared library or\n+executable it is defined in. The TLS data may be in a library loaded after startup (via `dlopen`).\n+- `initial-exec` - model usable if the TLS data is defined in the executable or in a shared library\n+loaded at program startup.\n+The TLS data must not be in a library loaded after startup (via `dlopen`).\n+- `local-exec` - model usable only if the TLS data is defined directly in the executable,\n+but not in a shared library, and is accessed only from that executable.\n+\n+`rustc` and LLVM may use a more optimized model than specified if they know that we are producing\n+and executable rather than a library, or that the `static` item is private enough."}, {"sha": "3442abf46df86cae98e4a85482b84b5d37caa2c9", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -11,26 +11,24 @@ depending on whether a particular sanitizer is enabled or not.\n \n ## Examples\n \n-``` rust\n+```rust\n #![feature(cfg_sanitize)]\n \n #[cfg(sanitize = \"thread\")]\n fn a() {\n-  // ...\n+    // ...\n }\n \n #[cfg(not(sanitize = \"thread\"))]\n fn a() {\n-  // ...\n+    // ...\n }\n \n fn b() {\n-  if cfg!(sanitize = \"leak\") {\n-    // ...\n-  } else {\n-    // ...\n-  }\n+    if cfg!(sanitize = \"leak\") {\n+        // ...\n+    } else {\n+        // ...\n+    }\n }\n-\n ```\n-"}, {"sha": "2b1e50835b7676ace00a28da09b1fdf041113f07", "filename": "src/doc/unstable-book/src/language-features/cfg-version.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,34 @@\n+# `cfg_version`\n+\n+The tracking issue for this feature is: [#64796]\n+\n+[#64796]: https://github.com/rust-lang/rust/issues/64796\n+\n+------------------------\n+\n+The `cfg_version` feature makes it possible to execute different code\n+depending on the compiler version.\n+\n+## Examples\n+\n+```rust\n+#![feature(cfg_version)]\n+\n+#[cfg(version(\"1.42\"))]\n+fn a() {\n+    // ...\n+}\n+\n+#[cfg(not(version(\"1.42\")))]\n+fn a() {\n+    // ...\n+}\n+\n+fn b() {\n+    if cfg!(version(\"1.42\")) {\n+        // ...\n+    } else {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "9a1ced4033b2201772943a47a642d854bc04e8e2", "filename": "src/doc/unstable-book/src/language-features/ffi-const.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,47 @@\n+# `ffi_const`\n+\n+The `#[ffi_const]` attribute applies clang's `const` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_const]` functions shall have no effects except for its return\n+value, which can only depend on the values of the function parameters, and is\n+not affected by changes to the observable state of the program.\n+\n+Applying the `#[ffi_const]` attribute to a function that violates these\n+requirements is undefined behaviour.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination, and it can avoid emitting some calls in repeated invocations of the\n+function with the same argument values regardless of other operations being\n+performed in between these functions calls (as opposed to `#[ffi_pure]`\n+functions).\n+\n+## Pitfalls\n+\n+A `#[ffi_const]` function can only read global memory that would not affect\n+its return value for the whole execution of the program (e.g. immutable global\n+memory). `#[ffi_const]` functions are referentially-transparent and therefore\n+more strict than `#[ffi_pure]` functions.\n+\n+A common pitfall involves applying the `#[ffi_const]` attribute to a\n+function that reads memory through pointer arguments which do not necessarily\n+point to immutable global memory.\n+\n+A `#[ffi_const]` function that returns unit has no effect on the abstract\n+machine's state, and a `#[ffi_const]` function cannot be `#[ffi_pure]`.\n+\n+A `#[ffi_const]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `const` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`const` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_const]`.\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacgigch.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_const.htm"}, {"sha": "7bfd7a378f00bff14f17c2e6cd5a9b7bf55deea2", "filename": "src/doc/unstable-book/src/language-features/ffi-pure.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,51 @@\n+# `ffi_pure`\n+\n+The `#[ffi_pure]` attribute applies clang's `pure` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_pure]` functions shall have no effects except for its return\n+value, which shall not change across two consecutive function calls with\n+the same parameters.\n+\n+Applying the `#[ffi_pure]` attribute to a function that violates these\n+requirements is undefined behavior.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination and loop optimizations. Some common examples of pure functions are\n+`strlen` or `memcmp`.\n+\n+These optimizations are only applicable when the compiler can prove that no\n+program state observable by the `#[ffi_pure]` function has changed between calls\n+of the function, which could alter the result. See also the `#[ffi_const]`\n+attribute, which provides stronger guarantees regarding the allowable behavior\n+of a function, enabling further optimization.\n+\n+## Pitfalls\n+\n+A `#[ffi_pure]` function can read global memory through the function\n+parameters (e.g. pointers), globals, etc. `#[ffi_pure]` functions are not\n+referentially-transparent, and are therefore more relaxed than `#[ffi_const]`\n+functions.\n+\n+However, accesing global memory through volatile or atomic reads can violate the\n+requirement that two consecutive function calls shall return the same value.\n+\n+A `pure` function that returns unit has no effect on the abstract machine's\n+state.\n+\n+A `#[ffi_pure]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `pure` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`pure` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_pure]`.\n+\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacigdac.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-pure-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_pure.htm"}, {"sha": "7b865c9c679bc0f27d2de2d04eb5380f7365a937", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -87,7 +87,7 @@ Feedback on the design and usage is always appreciated!\n \n The `Generator` trait in `std::ops` currently looks like:\n \n-```\n+```rust\n # #![feature(arbitrary_self_types, generator_trait)]\n # use std::ops::GeneratorState;\n # use std::pin::Pin;\n@@ -107,7 +107,7 @@ point for executing the `Generator` itself.\n \n The return value of `resume`, `GeneratorState`, looks like:\n \n-```\n+```rust\n pub enum GeneratorState<Y, R> {\n     Yielded(Y),\n     Complete(R),"}, {"sha": "20c7d7dcec8d6a512f668a03ac55b65b391ee047", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -287,6 +287,7 @@ the source code.\n   - `unsize`: `libcore/marker.rs`\n   - `sync`: `libcore/marker.rs`\n   - `phantom_data`: `libcore/marker.rs`\n+  - `discriminant_kind`: `libcore/marker.rs`\n   - `freeze`: `libcore/marker.rs`\n   - `debug_trait`: `libcore/fmt/mod.rs`\n   - `non_zero`: `libcore/nonzero.rs`"}, {"sha": "151520f0e4abc4a5328c8f6105a4c25686ddba81", "filename": "src/doc/unstable-book/src/language-features/negative-impls.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,57 @@\n+# `negative_impls`\n+\n+The tracking issue for this feature is [#68318].\n+\n+[#68318]: https://github.com/rust-lang/rust/issues/68318\n+\n+----\n+\n+With the feature gate `negative_impls`, you can write negative impls as well as positive ones:\n+\n+```rust\n+#![feature(negative_impls)]\n+trait DerefMut { }\n+impl<T: ?Sized> !DerefMut for &T { }\n+```\n+\n+Negative impls indicate a semver guarantee that the given trait will not be implemented for the given types. Negative impls play an additional purpose for auto traits, described below.\n+\n+Negative impls have the following characteristics:\n+\n+* They do not have any items.\n+* They must obey the orphan rules as if they were a positive impl.\n+* They cannot \"overlap\" with any positive impls.\n+\n+## Semver interaction\n+\n+It is a breaking change to remove a negative impl. Negative impls are a commitment not to implement the given trait for the named types.\n+\n+## Orphan and overlap rules\n+\n+Negative impls must obey the same orphan rules as a positive impl. This implies you cannot add a negative impl for types defined in upstream crates and so forth.\n+\n+Similarly, negative impls cannot overlap with positive impls, again using the same \"overlap\" check that we ordinarily use to determine if two impls overlap. (Note that positive impls typically cannot overlap with one another either, except as permitted by specialization.)\n+\n+## Interaction with auto traits\n+\n+Declaring a negative impl `impl !SomeAutoTrait for SomeType` for an\n+auto-trait serves two purposes:\n+\n+* as with any trait, it declares that `SomeType` will never implement `SomeAutoTrait`;\n+* it disables the automatic `SomeType: SomeAutoTrait` impl that would otherwise have been generated.\n+\n+Note that, at present, there is no way to indicate that a given type\n+does not implement an auto trait *but that it may do so in the\n+future*. For ordinary types, this is done by simply not declaring any\n+impl at all, but that is not an option for auto traits. A workaround\n+is that one could embed a marker type as one of the fields, where the\n+marker type is `!AutoTrait`.\n+\n+## Immediate uses\n+\n+Negative impls are used to declare that `&T: !DerefMut`  and `&mut T: !Clone`, as required to fix the soundness of `Pin` described in [#66544](https://github.com/rust-lang/rust/issues/66544).\n+\n+This serves two purposes:\n+\n+* For proving the correctness of unsafe code, we can use that impl as evidence that no `DerefMut` or `Clone` impl exists.\n+* It prevents downstream crates from creating such impls."}, {"sha": "6f0f0cfd33e4dad6f788336f392be53259a22e61", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -10,18 +10,20 @@ The `optin_builtin_traits` feature gate allows you to define auto traits.\n \n Auto traits, like [`Send`] or [`Sync`] in the standard library, are marker traits\n that are automatically implemented for every type, unless the type, or a type it contains, \n-has explicitly opted out via a negative impl. \n+has explicitly opted out via a negative impl. (Negative impls are separately controlled\n+by the `negative_impls` feature.)\n \n [`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html\n [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n \n ```rust,ignore\n-impl !Type for Trait\n+impl !Trait for Type\n ```\n \n Example:\n \n ```rust\n+#![feature(negative_impls)]\n #![feature(optin_builtin_traits)]\n \n auto trait Valid {}\n@@ -43,3 +45,63 @@ fn main() {\n     // must_be_valid( MaybeValid(False) );\n }\n ```\n+\n+## Automatic trait implementations\n+\n+When a type is declared as an `auto trait`, we will automatically\n+create impls for every struct/enum/union, unless an explicit impl is\n+provided. These automatic impls contain a where clause for each field\n+of the form `T: AutoTrait`, where `T` is the type of the field and\n+`AutoTrait` is the auto trait in question. As an example, consider the\n+struct `List` and the auto trait `Send`:\n+\n+```rust\n+struct List<T> {\n+  data: T,\n+  next: Option<Box<List<T>>>,\n+}\n+```\n+\n+Presuming that there is no explicit impl of `Send` for `List`, the\n+compiler will supply an automatic impl of the form:\n+\n+```rust\n+struct List<T> {\n+  data: T,\n+  next: Option<Box<List<T>>>,\n+}\n+\n+unsafe impl<T> Send for List<T>\n+where\n+  T: Send, // from the field `data`\n+  Option<Box<List<T>>>: Send, // from the field `next`\n+{ }\n+```\n+\n+Explicit impls may be either positive or negative. They take the form:\n+\n+```rust,ignore\n+impl<...> AutoTrait for StructName<..> { }\n+impl<...> !AutoTrait for StructName<..> { }\n+```\n+\n+## Coinduction: Auto traits permit cyclic matching\n+\n+Unlike ordinary trait matching, auto traits are **coinductive**. This\n+means, in short, that cycles which occur in trait matching are\n+considered ok. As an example, consider the recursive struct `List`\n+introduced in the previous section. In attempting to determine whether\n+`List: Send`, we would wind up in a cycle: to apply the impl, we must\n+show that `Option<Box<List>>: Send`, which will in turn require\n+`Box<List>: Send` and then finally `List: Send` again. Under ordinary\n+trait matching, this cycle would be an error, but for an auto trait it\n+is considered a successful match.\n+\n+## Items\n+\n+Auto traits cannot have any trait items, such as methods or associated types. This ensures that we can generate default implementations.\n+\n+## Supertraits\n+\n+Auto traits cannot have supertraits. This is for soundness reasons, as the interaction of coinduction with implied bounds is difficult to reconcile.\n+"}, {"sha": "a941bc9348f2cde0765ae2feb9d9628904882f25", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 669, "deletions": 128, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,193 +1,734 @@\n # `asm`\n \n-The tracking issue for this feature is: [#29722]\n+The tracking issue for this feature is: [#72016]\n \n-[#29722]: https://github.com/rust-lang/rust/issues/29722\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n \n ------------------------\n \n For extremely low-level manipulations and performance reasons, one\n might wish to control the CPU directly. Rust supports using inline\n assembly to do this via the `asm!` macro.\n \n-```rust,ignore\n-asm!(assembly template\n-   : output operands\n-   : input operands\n-   : clobbers\n-   : options\n-   );\n+# Guide-level explanation\n+[guide-level-explanation]: #guide-level-explanation\n+\n+Rust provides support for inline assembly via the `asm!` macro.\n+It can be used to embed handwritten assembly in the assembly output generated by the compiler.\n+Generally this should not be necessary, but might be where the required performance or timing\n+cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.\n+\n+## Basic usage\n+\n+Let us start with the simplest possible example:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+unsafe {\n+    asm!(\"nop\");\n+}\n ```\n \n-Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n-crate to allow) and of course requires an `unsafe` block.\n+This will insert a NOP (no operation) instruction into the assembly generated by the compiler.\n+Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert\n+arbitrary instructions and break various invariants. The instructions to be inserted are listed\n+in the first argument of the `asm!` macro as a string literal.\n \n-> **Note**: the examples here are given in x86/x86-64 assembly, but\n-> all platforms are supported.\n+## Inputs and outputs\n \n-## Assembly template\n+Now inserting an instruction that does nothing is rather boring. Let us do something that\n+actually acts on data:\n \n-The `assembly template` is the only required parameter and must be a\n-literal string (i.e. `\"\"`)\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64;\n+unsafe {\n+    asm!(\"mov {}, 5\", out(reg) x);\n+}\n+assert_eq!(x, 5);\n+```\n \n-```rust\n-#![feature(asm)]\n+This will write the value `5` into the `u64` variable `x`.\n+You can see that the string literal we use to specify instructions is actually a template string.\n+It is governed by the same rules as Rust [format strings][format-syntax].\n+The arguments that are inserted into the template however look a bit different then you may\n+be familiar with. First we need to specify if the variable is an input or an output of the\n+inline assembly. In this case it is an output. We declared this by writing `out`.\n+We also need to specify in what kind of register the assembly expects the variable.\n+In this case we put it in an arbitrary general purpose register by specifying `reg`.\n+The compiler will choose an appropriate register to insert into\n+the template and will read the variable from there after the inline assembly finishes executing.\n \n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn foo() {\n-    unsafe {\n-        asm!(\"NOP\");\n-    }\n+Let us see another example that also uses an input:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let i: u64 = 3;\n+let o: u64;\n+unsafe {\n+    asm!(\n+        \"mov {0}, {1}\",\n+        \"add {0}, {number}\",\n+        out(reg) o,\n+        in(reg) i,\n+        number = const 5,\n+    );\n }\n+assert_eq!(o, 8);\n+```\n+\n+This will add `5` to the input in variable `i` and write the result to variable `o`.\n+The particular way this assembly does this is first copying the value from `i` to the output,\n+and then adding `5` to it.\n+\n+The example shows a few things:\n+\n+First, we can see that `asm!` allows multiple template string arguments; each\n+one is treated as a separate line of assembly code, as if they were all joined\n+together with newlines between them. This makes it easy to format assembly\n+code.\n+\n+Second, we can see that inputs are declared by writing `in` instead of `out`.\n+\n+Third, one of our operands has a type we haven't seen yet, `const`.\n+This tells the compiler to expand this argument to value directly inside the assembly template.\n+This is only possible for constants and literals.\n \n-// Other platforms:\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn foo() { /* ... */ }\n+Fourth, we can see that we can specify an argument number, or name as in any format string.\n+For inline assembly templates this is particularly useful as arguments are often used more than once.\n+For more complex inline assembly using this facility is generally recommended, as it improves\n+readability, and allows reordering instructions without changing the argument order.\n \n-fn main() {\n-    // ...\n-    foo();\n-    // ...\n+We can further refine the above example to avoid the `mov` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u64 = 3;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n }\n+assert_eq!(x, 8);\n ```\n \n-(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n+We can see that `inout` is used to specify an argument that is both input and output.\n+This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.\n+\n+It is also possible to specify different variables for the input and output parts of an `inout` operand:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64 = 3;\n+let y: u64;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x => y, number = const 5);\n+}\n+assert_eq!(y, 8);\n+```\n+\n+## Late output operands\n+\n+The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`\n+can be written at any time, and can therefore not share its location with any other argument.\n+However, to guarantee optimal performance it is important to use as few registers as possible,\n+so they won't have to be saved and reloaded around the inline assembly block.\n+To achieve this Rust provides a `lateout` specifier. This can be used on any output that is\n+written only after all inputs have been consumed.\n+There is also a `inlateout` variant of this specifier.\n \n-Output operands, input operands, clobbers and options are all optional\n-but you must add the right number of `:` if you skip them:\n+Here is an example where `inlateout` *cannot* be used:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\"\n-    :\n-    :\n-    : \"eax\"\n-   );\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+let c: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"add {0}, {1}\",\n+        \"add {0}, {2}\",\n+        inout(reg) a,\n+        in(reg) b,\n+        in(reg) c,\n+    );\n+}\n+assert_eq!(a, 12);\n ```\n \n-Whitespace also doesn't matter:\n+Here the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`. If `inlateout` was used, then `a` and `c` could be allocated to the same register, in which case the first instruction to overwrite the value of `c` and cause the assembly code to produce the wrong result.\n+\n+However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\"add {0}, {1}\", inlateout(reg) a, in(reg) b);\n+}\n+assert_eq!(a, 8);\n ```\n \n-## Operands\n+As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.\n+\n+## Explicit register operands\n \n-Input and output operands follow the same format: `:\n-\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues, or not yet assigned:\n+Some instructions require that the operands be in a specific register.\n+Therefore, Rust inline assembly provides some more specific constraint specifiers.\n+While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n+among others can be addressed by their name.\n \n-```rust\n+```rust,allow_fail,no_run\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: i32, b: i32) -> i32 {\n-    let c: i32;\n+let cmd = 0xd1;\n+unsafe {\n+    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n+}\n+```\n+\n+In this example we call the `out` instruction to output the content of the `cmd` variable\n+to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n+we had to use the `eax` constraint specifier.\n+\n+Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n+\n+Consider this example which uses the x86 `mul` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+fn mul(a: u64, b: u64) -> u128 {\n+    let lo: u64;\n+    let hi: u64;\n+\n     unsafe {\n-        asm!(\"add $2, $0\"\n-             : \"=r\"(c)\n-             : \"0\"(a), \"r\"(b)\n-             );\n+        asm!(\n+            // The x86 mul instruction takes rax as an implicit input and writes\n+            // the 128-bit result of the multiplication to rax:rdx.\n+            \"mul {}\",\n+            in(reg) a,\n+            inlateout(\"rax\") b => lo,\n+            lateout(\"rdx\") hi\n+        );\n     }\n-    c\n+\n+    ((hi as u128) << 64) + lo as u128\n+}\n+```\n+\n+This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit result.\n+The only explicit operand is a register, that we fill from the variable `a`.\n+The second operand is implicit, and must be the `rax` register, which we fill from the variable `b`.\n+The lower 64 bits of the result are stored in `rax` from which we fill the variable `lo`.\n+The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n+\n+## Clobbered registers\n+\n+In many cases inline assembly will modify state that is not needed as an output.\n+Usually this is either because we have to use a scratch register in the assembly,\n+or instructions modify state that we don't need to further examine.\n+This state is generally referred to as being \"clobbered\".\n+We need to tell the compiler about this since it may need to save and restore this state\n+around the inline assembly block.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let ebx: u32;\n+let ecx: u32;\n+\n+unsafe {\n+    asm!(\n+        \"cpuid\",\n+        // EAX 4 selects the \"Deterministic Cache Parameters\" CPUID leaf\n+        inout(\"eax\") 4 => _,\n+        // ECX 0 selects the L0 cache information.\n+        inout(\"ecx\") 0 => ecx,\n+        lateout(\"ebx\") ebx,\n+        lateout(\"edx\") _,\n+    );\n }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: i32, b: i32) -> i32 { a + b }\n \n-fn main() {\n-    assert_eq!(add(3, 14159), 14162)\n+println!(\n+    \"L1 Cache: {}\",\n+    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1) * ((ebx & 0xfff) + 1) * (ecx + 1)\n+);\n+```\n+\n+In the example above we use the `cpuid` instruction to get the L1 cache size.\n+This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the cache size we only care about the contents of `ebx` and `ecx`.\n+\n+However we still need to tell the compiler that `eax` and `edx` have been modified so that it can save any values that were in these registers before the asm. This is done by declaring these as outputs but with `_` instead of a variable name, which indicates that the output value is to be discarded.\n+\n+This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+// Multiply x by 6 using shifts and adds\n+let mut x: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"mov {tmp}, {x}\",\n+        \"shl {tmp}, 1\",\n+        \"shl {x}, 2\",\n+        \"add {x}, {tmp}\",\n+        x = inout(reg) x,\n+        tmp = out(reg) _,\n+    );\n }\n+assert_eq!(x, 4 * 6);\n ```\n \n-If you would like to use real operands in this position, however,\n-you are required to put curly braces `{}` around the register that\n-you want, and you are required to put the specific size of the\n-operand. This is useful for very low level programming, where\n-which register you use is important:\n+## Symbol operands\n+\n+A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n+This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# unsafe fn read_byte_in(port: u16) -> u8 {\n-let result: u8;\n-asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(port));\n-result\n-# }\n+extern \"C\" fn foo(arg: i32) {\n+    println!(\"arg = {}\", arg);\n+}\n+\n+fn call_foo(arg: i32) {\n+    unsafe {\n+        asm!(\n+            \"call {}\",\n+            sym foo,\n+            // 1st argument in rdi, which is caller-saved\n+            inout(\"rdi\") arg => _,\n+            // All caller-saved registers must be marked as clobberred\n+            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n+            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n+            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n+            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n+            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n+            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n+        )\n+    }\n+}\n ```\n \n-## Clobbers\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n+the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+\n+## Register template modifiers\n \n-Some instructions modify registers which might otherwise have held\n-different values so we use the clobbers list to indicate to the\n-compiler not to assume any values loaded into those registers will\n-stay valid.\n+In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a \"view\" over a subset of the register (e.g. the low 32 bits of a 64-bit register).\n \n-```rust\n+By default the compiler will always choose the name that refers to the full register size (e.g. `rax` on x86-64, `eax` on x86, etc).\n+\n+This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n+\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-// Put the value 0x200 in eax:\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let mut x: u16 = 0xab;\n+\n+unsafe {\n+    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n+}\n+\n+assert_eq!(x, 0xabab);\n ```\n \n-Input and output registers need not be listed since that information\n-is already communicated by the given constraints. Otherwise, any other\n-registers used either implicitly or explicitly should be listed.\n+In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.\n \n-If the assembly changes the condition code register `cc` should be\n-specified as one of the clobbers. Similarly, if the assembly modifies\n-memory, `memory` should also be specified.\n+Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.\n+The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n \n-## Options\n+If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n \n-The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n-specify some extra info about the inline assembly:\n+## Options\n \n-Current valid options are:\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n \n-1. *volatile* - specifying this is analogous to\n-   `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e. SSE) and specifying this indicates to\n-   the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n+Let's take our previous example of an `add` instruction:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() {\n-let result: i32;\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n unsafe {\n-   asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")\n+    asm!(\n+        \"add {0}, {1}\",\n+        inlateout(reg) a, in(reg) b,\n+        options(pure, nomem, nostack),\n+    );\n }\n-println!(\"eax is currently {}\", result);\n-# }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+assert_eq!(a, 8);\n ```\n \n-## More Information\n+Options can be provided as an optional final argument to the `asm!` macro. We specified three options here:\n+- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.\n+- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).\n+- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.\n+\n+These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.\n+\n+See the reference for the full list of available options and their effects.\n+\n+# Reference-level explanation\n+[reference-level-explanation]: #reference-level-explanation\n \n-The current implementation of the `asm!` macro is a direct binding to [LLVM's\n-inline assembler expressions][llvm-docs], so be sure to check out [their\n-documentation as well][llvm-docs] for more information about clobbers,\n-constraints, etc.\n+Inline assembler is implemented as an unsafe macro `asm!()`.\n+The first argument to this macro is a template string literal used to build the final assembly.\n+The following arguments specify input and output operands.\n+When required, options are specified as the final argument.\n \n-[llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n+The following ABNF specifies the general syntax:\n+\n+```ignore\n+dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n+reg_spec := <register class> / \"<explicit register>\"\n+operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n+reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n+operand := reg_operand / \"const\" const_expr / \"sym\" path\n+option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n+options := \"options(\" option *[\",\" option] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+```\n+\n+The macro will initially be supported only on ARM, AArch64, Hexagon, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+\n+[format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n+\n+## Template string arguments\n+\n+The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n+\n+An `asm!` invocation may have one or more template string arguments; an `asm!` with multiple template string arguments is treated as if all the strings were concatenated with a `\\n` between them. The expected usage is for each template string argument to correspond to a line of assembly code. All template string arguments must appear before any other arguments.\n+\n+As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after named arguments if any.\n+\n+Explicit register operands cannot be used by placeholders in the template string. All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.\n+\n+The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n+\n+The 5 targets specified in this RFC (x86, ARM, AArch64, RISC-V, Hexagon) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+\n+[rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n+\n+## Operand type\n+\n+Several types of operands are supported:\n+\n+* `in(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - The allocated register must contain the same value at the end of the asm code (except if a `lateout` is allocated to the same register).\n+* `out(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain an undefined value at the start of the asm code.\n+  - `<expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+* `lateout(<reg>) <expr>`\n+  - Identical to `out` except that the register allocator can reuse a register allocated to an `in`.\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `inout(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - `<expr>` must be a mutable initialized place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+* `inout(<reg>) <in expr> => <out expr>`\n+  - Same as `inout` except that the initial value of the register is taken from the value of `<in expr>`.\n+  - `<out expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression for `<out expr>`, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+  - `<in expr>` and `<out expr>` may have different types.\n+* `inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`\n+  - Identical to `inout` except that the register allocator can reuse a register allocated to an `in` (this can happen if the compiler knows the `in` has the same initial value as the `inlateout`).\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `const <expr>`\n+  - `<expr>` must be an integer or floating-point constant expression.\n+  - The value of the expression is formatted as a string and substituted directly into the asm template string.\n+* `sym <path>`\n+  - `<path>` must refer to a `fn` or `static`.\n+  - A mangled symbol name referring to the item is substituted into the asm template string.\n+  - The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).\n+  - `<path>` is allowed to point to a `#[thread_local]` static, in which case the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) to read from thread-local data.\n+\n+Operand expressions are evaluated from left to right, just like function call arguments. After the `asm!` has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.\n+\n+## Register operands\n+\n+Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. `\"eax\"`) while register classes are specified as identifiers (e.g. `reg`). Using string literals for register names enables support for architectures that use special characters in register names, such as MIPS (`$0`, `$1`, etc).\n+\n+Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to the base register. It is a compile-time error to use the same explicit register for two input operands or two output operands. Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.\n+\n+Only the following types are allowed as operands for inline assembly:\n+- Integers (signed and unsigned)\n+- Floating-point numbers\n+- Pointers (thin only)\n+- Function pointers\n+- SIMD vectors (structs defined with `#[repr(simd)]` and which implement `Copy`). This includes architecture-specific vector types defined in `std::arch` such as `__m128` (x86) or `int8x16_t` (ARM).\n+\n+Here is the list of currently supported register classes:\n+\n+| Architecture | Register class | Registers | LLVM constraint code |\n+| ------------ | -------------- | --------- | -------------------- |\n+| x86 | `reg` | `ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only) | `r` |\n+| x86 | `reg_abcd` | `ax`, `bx`, `cx`, `dx` | `Q` |\n+| x86-32 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh` | `q` |\n+| x86-64 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `sil`, `dil`, `r[8-15]b`, `ah`\\*, `bh`\\*, `ch`\\*, `dh`\\* | `q` |\n+| x86 | `xmm_reg` | `xmm[0-7]` (x86) `xmm[0-15]` (x86-64) | `x` |\n+| x86 | `ymm_reg` | `ymm[0-7]` (x86) `ymm[0-15]` (x86-64) | `x` |\n+| x86 | `zmm_reg` | `zmm[0-7]` (x86) `zmm[0-31]` (x86-64) | `v` |\n+| x86 | `kreg` | `k[1-7]` | `Yk` |\n+| AArch64 | `reg` | `x[0-28]`, `x30` | `r` |\n+| AArch64 | `vreg` | `v[0-31]` | `w` |\n+| AArch64 | `vreg_low16` | `v[0-15]` | `x` |\n+| ARM | `reg` | `r[0-r10]`, `r12`, `r14` | `r` |\n+| ARM (Thumb) | `reg_thumb` | `r[0-r7]` | `l` |\n+| ARM (ARM) | `reg_thumb` | `r[0-r10]`, `r12`, `r14` | `l` |\n+| ARM | `sreg` | `s[0-31]` | `t` |\n+| ARM | `sreg_low16` | `s[0-15]` | `x` |\n+| ARM | `dreg` | `d[0-31]` | `w` |\n+| ARM | `dreg_low16` | `d[0-15]` | `t` |\n+| ARM | `dreg_low8` | `d[0-8]` | `x` |\n+| ARM | `qreg` | `q[0-15]` | `w` |\n+| ARM | `qreg_low8` | `q[0-7]` | `t` |\n+| ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| NVPTX | `reg16` | None\\* | `h` |\n+| NVPTX | `reg32` | None\\* | `r` |\n+| NVPTX | `reg64` | None\\* | `l` |\n+| RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n+| RISC-V | `freg` | `f[0-31]` | `f` |\n+| Hexagon | `reg` | `r[0-28]` | `r` |\n+\n+> **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n+>\n+> Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+>\n+> Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n+\n+Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n+\n+Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a `i32x4` and a `i8x16` into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.\n+\n+| Architecture | Register class | Target feature | Allowed types |\n+| ------------ | -------------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `i16`, `i32`, `f32` |\n+| x86-64 | `reg` | None | `i16`, `i32`, `f32`, `i64`, `f64` |\n+| x86 | `reg_byte` | None | `i8` |\n+| x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n+| x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n+| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n+| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| AArch64 | `vreg` | `fp` | `i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| ARM | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| ARM | `sreg` | `vfp2` | `i32`, `f32` |\n+| ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n+| ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| NVPTX | `reg16` | None | `i8`, `i16` |\n+| NVPTX | `reg32` | None | `i8`, `i16`, `i32`, `f32` |\n+| NVPTX | `reg64` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V | `freg` | `f` | `f32` |\n+| RISC-V | `freg` | `d` | `f64` |\n+| Hexagon | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+\n+> **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n+\n+If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the `freg` register class on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the RISC-V architecture.\n+\n+When separate input and output expressions are specified for an `inout` operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.\n+\n+## Register names\n+\n+Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:\n+\n+| Architecture | Base register | Aliases |\n+| ------------ | ------------- | ------- |\n+| x86 | `ax` | `eax`, `rax` |\n+| x86 | `bx` | `ebx`, `rbx` |\n+| x86 | `cx` | `ecx`, `rcx` |\n+| x86 | `dx` | `edx`, `rdx` |\n+| x86 | `si` | `esi`, `rsi` |\n+| x86 | `di` | `edi`, `rdi` |\n+| x86 | `bp` | `bpl`, `ebp`, `rbp` |\n+| x86 | `sp` | `spl`, `esp`, `rsp` |\n+| x86 | `ip` | `eip`, `rip` |\n+| x86 | `st(0)` | `st` |\n+| x86 | `r[8-15]` | `r[8-15]b`, `r[8-15]w`, `r[8-15]d` |\n+| x86 | `xmm[0-31]` | `ymm[0-31]`, `zmm[0-31]` |\n+| AArch64 | `x[0-30]` | `w[0-30]` |\n+| AArch64 | `x29` | `fp` |\n+| AArch64 | `x30` | `lr` |\n+| AArch64 | `sp` | `wsp` |\n+| AArch64 | `xzr` | `wzr` |\n+| AArch64 | `v[0-31]` | `b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]` |\n+| ARM | `r[0-3]` | `a[1-4]` |\n+| ARM | `r[4-9]` | `v[1-6]` |\n+| ARM | `r9` | `rfp` |\n+| ARM | `r10` | `sl` |\n+| ARM | `r11` | `fp` |\n+| ARM | `r12` | `ip` |\n+| ARM | `r13` | `sp` |\n+| ARM | `r14` | `lr` |\n+| ARM | `r15` | `pc` |\n+| RISC-V | `x0` | `zero` |\n+| RISC-V | `x1` | `ra` |\n+| RISC-V | `x2` | `sp` |\n+| RISC-V | `x3` | `gp` |\n+| RISC-V | `x4` | `tp` |\n+| RISC-V | `x[5-7]` | `t[0-2]` |\n+| RISC-V | `x8` | `fp`, `s0` |\n+| RISC-V | `x9` | `s1` |\n+| RISC-V | `x[10-17]` | `a[0-7]` |\n+| RISC-V | `x[18-27]` | `s[2-11]` |\n+| RISC-V | `x[28-31]` | `t[3-6]` |\n+| RISC-V | `f[0-7]` | `ft[0-7]` |\n+| RISC-V | `f[8-9]` | `fs[0-1]` |\n+| RISC-V | `f[10-17]` | `fa[0-7]` |\n+| RISC-V | `f[18-27]` | `fs[2-11]` |\n+| RISC-V | `f[28-31]` | `ft[8-11]` |\n+| Hexagon | `r29` | `sp` |\n+| Hexagon | `r30` | `fr` |\n+| Hexagon | `r31` | `lr` |\n+\n+Some registers cannot be used for input or output operands:\n+\n+| Architecture | Unsupported register | Reason |\n+| ------------ | -------------------- | ------ |\n+| All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n+| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon) | The frame pointer cannot be used as an input or output. |\n+| x86 | `k0` | This is a constant zero register which can't be modified. |\n+| x86 | `ip` | This is the program counter, not a real register. |\n+| x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n+| x86 | `st([0-7])` | x87 registers are not currently supported (but may be in the future). |\n+| AArch64 | `xzr` | This is a constant zero register which can't be modified. |\n+| ARM | `pc` | This is the program counter, not a real register. |\n+| RISC-V | `x0` | This is a constant zero register which can't be modified. |\n+| RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+| Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n+\n+## Template modifiers\n+\n+The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder.\n+\n+The supported modifiers are a subset of LLVM's (and GCC's) [asm template argument modifiers][llvm-argmod], but do not use the same letter codes.\n+\n+| Architecture | Register class | Modifier | Example output | LLVM modifier |\n+| ------------ | -------------- | -------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `eax` | `k` |\n+| x86-64 | `reg` | None | `rax` | `q` |\n+| x86-32 | `reg_abcd` | `l` | `al` | `b` |\n+| x86-64 | `reg` | `l` | `al` | `b` |\n+| x86 | `reg_abcd` | `h` | `ah` | `h` |\n+| x86 | `reg` | `x` | `ax` | `w` |\n+| x86 | `reg` | `e` | `eax` | `k` |\n+| x86-64 | `reg` | `r` | `rax` | `q` |\n+| x86 | `reg_byte` | None | `al` / `ah` | None |\n+| x86 | `xmm_reg` | None | `xmm0` | `x` |\n+| x86 | `ymm_reg` | None | `ymm0` | `t` |\n+| x86 | `zmm_reg` | None | `zmm0` | `g` |\n+| x86 | `*mm_reg` | `x` | `xmm0` | `x` |\n+| x86 | `*mm_reg` | `y` | `ymm0` | `t` |\n+| x86 | `*mm_reg` | `z` | `zmm0` | `g` |\n+| x86 | `kreg` | None | `k1` | None |\n+| AArch64 | `reg` | None | `x0` | `x` |\n+| AArch64 | `reg` | `w` | `w0` | `w` |\n+| AArch64 | `reg` | `x` | `x0` | `x` |\n+| AArch64 | `vreg` | None | `v0` | None |\n+| AArch64 | `vreg` | `v` | `v0` | None |\n+| AArch64 | `vreg` | `b` | `b0` | `b` |\n+| AArch64 | `vreg` | `h` | `h0` | `h` |\n+| AArch64 | `vreg` | `s` | `s0` | `s` |\n+| AArch64 | `vreg` | `d` | `d0` | `d` |\n+| AArch64 | `vreg` | `q` | `q0` | `q` |\n+| ARM | `reg` | None | `r0` | None |\n+| ARM | `sreg` | None | `s0` | None |\n+| ARM | `dreg` | None | `d0` | `P` |\n+| ARM | `qreg` | None | `q0` | `q` |\n+| ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| NVPTX | `reg16` | None | `rs0` | None |\n+| NVPTX | `reg32` | None | `r0` | None |\n+| NVPTX | `reg64` | None | `rd0` | None |\n+| RISC-V | `reg` | None | `x1` | None |\n+| RISC-V | `freg` | None | `f0` | None |\n+| Hexagon | `reg` | None | `r0` | None |\n+\n+> Notes:\n+> - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register.\n+> - on x86: our behavior for `reg` with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.\n+> - on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.\n+\n+As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the asm code (e.g. `ax` instead of `rax`). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.\n+\n+[llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n+\n+## Options\n \n-If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](global-asm.md).\n+Flags are used to further influence the behavior of the inline assembly block.\n+Currently the following options are defined:\n+- `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the `nomem` options is also set). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used.\n+- `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.\n+- `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.\n+- `preserves_flags`: The `asm` block does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n+- `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code. A `noreturn` asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\n+- `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+- `att_syntax`: This option is only valid on x86, and causes the assembler to use the `.att_syntax prefix` mode of the GNU assembler. Register operands are substituted in with a leading `%`.\n+\n+The compiler performs some additional checks on options:\n+- The `nomem` and `readonly` options are mutually exclusive: it is a compile-time error to specify both.\n+- The `pure` option must be combined with either the `nomem` or `readonly` options, otherwise a compile-time error is emitted.\n+- It is a compile-time error to specify `pure` on an asm block with no outputs or only discarded outputs (`_`).\n+- It is a compile-time error to specify `noreturn` on an asm block with outputs.\n+\n+## Rules for inline assembly\n+\n+- Any registers not specified as inputs will contain an undefined value on entry to the asm block.\n+  - An \"undefined value\" in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM `undef` which can have a different value every time you read it (since such a concept does not exist in assembly code).\n+- Any registers not specified as outputs must have the same value upon exiting the asm block as they had on entry, otherwise behavior is undefined.\n+  - This only applies to registers which can be specified as an input or output. Other registers follow target-specific rules.\n+  - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n+- Behavior is undefined if execution unwinds out of an asm block.\n+  - This also applies if the assembly code calls a function which then unwinds.\n+- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+  - Refer to the unsafe code guidelines for the exact rules.\n+  - If the `readonly` option is set, then only memory reads are allowed.\n+  - If the `nomem` option is set then no reads or writes to memory are allowed.\n+  - These rules do not apply to memory which is private to the asm code, such as stack space allocated within the asm block.\n+- The compiler cannot assume that the instructions in the asm are the ones that will actually end up executed.\n+  - This effectively means that the compiler must treat the `asm!` as a black box and only take the interface specification into account, not the instructions themselves.\n+  - Runtime code patching is allowed, via target-specific mechanisms (outside the scope of this RFC).\n+- Unless the `nostack` option is set, asm code is allowed to use stack space below the stack pointer.\n+  - On entry to the asm block the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+  - You are responsible for making sure you don't overflow the stack (e.g. use stack probing to ensure you hit a guard page).\n+  - You should adjust the stack pointer when allocating stack memory as required by the target ABI.\n+  - The stack pointer must be restored to its original value before leaving the asm block.\n+- If the `noreturn` option is set then behavior is undefined if execution falls through to the end of the asm block.\n+- If the `pure` option is set then behavior is undefined if the `asm` has side-effects other than its direct outputs. Behavior is also undefined if two executions of the `asm` code with the same inputs result in different outputs.\n+  - When used with the `nomem` option, \"inputs\" are just the direct inputs of the `asm!`.\n+  - When used with the `readonly` option, \"inputs\" comprise the direct inputs of the `asm!` and any memory that the `asm!` block is allowed to read.\n+- These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n+  - x86\n+    - Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF).\n+    - Floating-point status word (all).\n+    - Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE).\n+  - ARM\n+    - Condition flags in `CPSR` (N, Z, C, V)\n+    - Saturation flag in `CPSR` (Q)\n+    - Greater than or equal flags in `CPSR` (GE).\n+    - Condition flags in `FPSCR` (N, Z, C, V)\n+    - Saturation flag in `FPSCR` (QC)\n+    - Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC).\n+  - AArch64\n+    - Condition flags (`NZCV` register).\n+    - Floating-point status (`FPSR` register).\n+  - RISC-V\n+    - Floating-point exception flags in `fcsr` (`fflags`).\n+- On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n+  - Behavior is undefined if the direction flag is set on exiting an asm block.\n+- The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block.\n+  - This means that `asm!` blocks that never return (even if not marked `noreturn`) don't need to preserve these registers.\n+  - When returning to a different `asm!` block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the `asm!` block that you are *exiting*.\n+    - You cannot exit an `asm!` block that has not been entered. Neither can you exit an `asm!` block that has already been exited.\n+    - You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).\n+    - The set of memory locations that you may access is the intersection of those allowed by the `asm!` blocks you entered and exited.\n+- You cannot assume that an `asm!` block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the `asm!` block, for example when the function containing it is inlined in multiple places.\n+  - As a consequence, you should only use [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+> **Note**: As a general rule, the flags covered by `preserves_flags` are those which are *not* preserved when performing a function call.\n+\n+[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels"}, {"sha": "5dff73a94dd872c956aa1c231719290d5791271a", "filename": "src/doc/unstable-book/src/library-features/default-free-fn.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,45 @@\n+# `default_free_fn`\n+\n+The tracking issue for this feature is: [#73014]\n+\n+[#73014]: https://github.com/rust-lang/rust/issues/73014\n+\n+------------------------\n+\n+Adds a free `default()` function to the `std::default` module.  This function\n+just forwards to [`Default::default()`], but may remove repetition of the word\n+\"default\" from the call site.\n+\n+Here is an example:\n+\n+```rust\n+#![feature(default_free_fn)]\n+use std::default::default;\n+\n+#[derive(Default)]\n+struct AppConfig {\n+    foo: FooConfig,\n+    bar: BarConfig,\n+}\n+\n+#[derive(Default)]\n+struct FooConfig {\n+    foo: i32,\n+}\n+\n+#[derive(Default)]\n+struct BarConfig {\n+    bar: f32,\n+    baz: u8,\n+}\n+\n+fn main() {\n+    let options = AppConfig {\n+        foo: default(),\n+        bar: BarConfig {\n+            bar: 10.1,\n+            ..default()\n+        },\n+    };\n+}\n+```"}, {"sha": "da01d9228f14e0ff12177e7694205a4f9a6ed095", "filename": "src/doc/unstable-book/src/library-features/llvm-asm.md", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,193 @@\n+# `llvm_asm`\n+\n+The tracking issue for this feature is: [#70173]\n+\n+[#70173]: https://github.com/rust-lang/rust/issues/70173\n+\n+------------------------\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `llvm_asm!` macro.\n+\n+```rust,ignore\n+llvm_asm!(assembly template\n+   : output operands\n+   : input operands\n+   : clobbers\n+   : options\n+   );\n+```\n+\n+Any use of `llvm_asm` is feature gated (requires `#![feature(llvm_asm)]` on the\n+crate to allow) and of course requires an `unsafe` block.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but\n+> all platforms are supported.\n+\n+## Assembly template\n+\n+The `assembly template` is the only required parameter and must be a\n+literal string (i.e. `\"\"`)\n+\n+```rust\n+#![feature(llvm_asm)]\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn foo() {\n+    unsafe {\n+        llvm_asm!(\"NOP\");\n+    }\n+}\n+\n+// Other platforms:\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+fn foo() { /* ... */ }\n+\n+fn main() {\n+    // ...\n+    foo();\n+    // ...\n+}\n+```\n+\n+(The `feature(llvm_asm)` and `#[cfg]`s are omitted from now on.)\n+\n+Output operands, input operands, clobbers and options are all optional\n+but you must add the right number of `:` if you skip them:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+llvm_asm!(\"xor %eax, %eax\"\n+    :\n+    :\n+    : \"eax\"\n+   );\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+Whitespace also doesn't matter:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+llvm_asm!(\"xor %eax, %eax\" ::: \"eax\");\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+## Operands\n+\n+Input and output operands follow the same format: `:\n+\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n+expressions must be mutable place, or not yet assigned:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn add(a: i32, b: i32) -> i32 {\n+    let c: i32;\n+    unsafe {\n+        llvm_asm!(\"add $2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a), \"r\"(b)\n+             );\n+    }\n+    c\n+}\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n+\n+fn main() {\n+    assert_eq!(add(3, 14159), 14162)\n+}\n+```\n+\n+If you would like to use real operands in this position, however,\n+you are required to put curly braces `{}` around the register that\n+you want, and you are required to put the specific size of the\n+operand. This is useful for very low level programming, where\n+which register you use is important:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# unsafe fn read_byte_in(port: u16) -> u8 {\n+let result: u8;\n+llvm_asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(port));\n+result\n+# }\n+```\n+\n+## Clobbers\n+\n+Some instructions modify registers which might otherwise have held\n+different values so we use the clobbers list to indicate to the\n+compiler not to assume any values loaded into those registers will\n+stay valid.\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+// Put the value 0x200 in eax:\n+llvm_asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+Input and output registers need not be listed since that information\n+is already communicated by the given constraints. Otherwise, any other\n+registers used either implicitly or explicitly should be listed.\n+\n+If the assembly changes the condition code register `cc` should be\n+specified as one of the clobbers. Similarly, if the assembly modifies\n+memory, `memory` should also be specified.\n+\n+## Options\n+\n+The last section, `options` is specific to Rust. The format is comma\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n+specify some extra info about the inline assembly:\n+\n+Current valid options are:\n+\n+1. *volatile* - specifying this is analogous to\n+   `__asm__ __volatile__ (...)` in gcc/clang.\n+2. *alignstack* - certain instructions expect the stack to be\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n+   the compiler to insert its usual stack alignment code\n+3. *intel* - use intel syntax instead of the default AT&T.\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() {\n+let result: i32;\n+unsafe {\n+   llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")\n+}\n+println!(\"eax is currently {}\", result);\n+# }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+## More Information\n+\n+The current implementation of the `llvm_asm!` macro is a direct binding to [LLVM's\n+inline assembler expressions][llvm-docs], so be sure to check out [their\n+documentation as well][llvm-docs] for more information about clobbers,\n+constraints, etc.\n+\n+[llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n+\n+If you need more power and don't mind losing some of the niceties of\n+`llvm_asm!`, check out [global_asm](global-asm.md)."}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,401 +0,0 @@\n-\"\"\"\n-This module provides an abstraction layer over common Rust pretty printing\n-functionality needed by both GDB and LLDB.\n-\"\"\"\n-\n-import re\n-\n-# Type codes that indicate the kind of type as it appears in DWARF debug\n-# information. This code alone is not sufficient to determine the Rust type.\n-# For example structs, tuples, fat pointers, or enum variants will all have\n-# DWARF_TYPE_CODE_STRUCT.\n-DWARF_TYPE_CODE_STRUCT = 1\n-DWARF_TYPE_CODE_UNION  = 2\n-DWARF_TYPE_CODE_PTR    = 3\n-DWARF_TYPE_CODE_ARRAY  = 4\n-DWARF_TYPE_CODE_ENUM   = 5\n-\n-# These constants specify the most specific kind of type that could be\n-# determined for a given value.\n-TYPE_KIND_UNKNOWN           = -1\n-TYPE_KIND_EMPTY             = 0\n-TYPE_KIND_SLICE             = 1\n-TYPE_KIND_REGULAR_STRUCT    = 2\n-TYPE_KIND_TUPLE             = 3\n-TYPE_KIND_TUPLE_STRUCT      = 4\n-TYPE_KIND_CSTYLE_VARIANT    = 5\n-TYPE_KIND_TUPLE_VARIANT     = 6\n-TYPE_KIND_STRUCT_VARIANT    = 7\n-TYPE_KIND_STR_SLICE         = 8\n-TYPE_KIND_STD_VEC           = 9\n-TYPE_KIND_STD_STRING        = 10\n-TYPE_KIND_REGULAR_ENUM      = 11\n-TYPE_KIND_COMPRESSED_ENUM   = 12\n-TYPE_KIND_SINGLETON_ENUM    = 13\n-TYPE_KIND_CSTYLE_ENUM       = 14\n-TYPE_KIND_PTR               = 15\n-TYPE_KIND_FIXED_SIZE_VEC    = 16\n-TYPE_KIND_REGULAR_UNION     = 17\n-TYPE_KIND_OS_STRING         = 18\n-TYPE_KIND_STD_VECDEQUE      = 19\n-TYPE_KIND_STD_BTREESET      = 20\n-TYPE_KIND_STD_BTREEMAP      = 21\n-\n-ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n-ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n-\n-# Slice related constants\n-SLICE_FIELD_NAME_DATA_PTR = \"data_ptr\"\n-SLICE_FIELD_NAME_LENGTH = \"length\"\n-SLICE_FIELD_NAMES = [SLICE_FIELD_NAME_DATA_PTR, SLICE_FIELD_NAME_LENGTH]\n-\n-# std::Vec<> related constants\n-STD_VEC_FIELD_NAME_LENGTH = \"len\"\n-STD_VEC_FIELD_NAME_BUF = \"buf\"\n-STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_BUF,\n-                       STD_VEC_FIELD_NAME_LENGTH]\n-\n-# std::collections::VecDeque<> related constants\n-STD_VECDEQUE_FIELD_NAME_TAIL = \"tail\"\n-STD_VECDEQUE_FIELD_NAME_HEAD = \"head\"\n-STD_VECDEQUE_FIELD_NAME_BUF = \"buf\"\n-STD_VECDEQUE_FIELD_NAMES = [STD_VECDEQUE_FIELD_NAME_TAIL,\n-                            STD_VECDEQUE_FIELD_NAME_HEAD,\n-                            STD_VECDEQUE_FIELD_NAME_BUF]\n-\n-# std::collections::BTreeSet<> related constants\n-STD_BTREESET_FIELD_NAMES = [\"map\"]\n-\n-# std::collections::BTreeMap<> related constants\n-STD_BTREEMAP_FIELD_NAMES = [\"root\", \"length\"]\n-\n-# std::String related constants\n-STD_STRING_FIELD_NAMES = [\"vec\"]\n-\n-# std::ffi::OsString related constants\n-OS_STRING_FIELD_NAMES = [\"inner\"]\n-\n-\n-class Type(object):\n-    \"\"\"\n-    This class provides a common interface for type-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific type-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.__type_kind = None\n-\n-    def get_unqualified_type_name(self):\n-        \"\"\"\n-        Implementations of this method should return the unqualified name of the\n-        type-object they are wrapping. Some examples:\n-\n-        'int' -> 'int'\n-        'std::vec::Vec<std::string::String>' -> 'Vec<std::string::String>'\n-        '&std::option::Option<std::string::String>' -> '&std::option::Option<std::string::String>'\n-\n-        As you can see, type arguments stay fully qualified.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_dwarf_type_kind(self):\n-        \"\"\"\n-        Implementations of this method should return the correct\n-        DWARF_TYPE_CODE_* value for the wrapped type-object.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_fields(self):\n-        \"\"\"\n-        Implementations of this method should return a list of field-objects of\n-        this type. For Rust-enums (i.e. with DWARF_TYPE_CODE_UNION) these field-\n-        objects represent the variants of the enum. Field-objects must have a\n-        `name` attribute that gives their name as specified in DWARF.\n-        \"\"\"\n-        assert ((self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION))\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific type-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_type_kind(self):\n-        \"\"\"This method returns the TYPE_KIND_* value for this type-object.\"\"\"\n-        if self.__type_kind is None:\n-            dwarf_type_code = self.get_dwarf_type_kind()\n-\n-            if dwarf_type_code == DWARF_TYPE_CODE_STRUCT:\n-                self.__type_kind = self.__classify_struct()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_UNION:\n-                self.__type_kind = self.__classify_union()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_PTR:\n-                self.__type_kind = TYPE_KIND_PTR\n-            elif dwarf_type_code == DWARF_TYPE_CODE_ARRAY:\n-                self.__type_kind = TYPE_KIND_FIXED_SIZE_VEC\n-            else:\n-                self.__type_kind = TYPE_KIND_UNKNOWN\n-        return self.__type_kind\n-\n-    def __classify_struct(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT\n-\n-        unqualified_type_name = self.get_unqualified_type_name()\n-\n-        # STR SLICE\n-        if unqualified_type_name == \"&str\":\n-            return TYPE_KIND_STR_SLICE\n-\n-        # REGULAR SLICE\n-        if (unqualified_type_name.startswith((\"&[\", \"&mut [\")) and\n-            unqualified_type_name.endswith(\"]\") and\n-            self.__conforms_to_field_layout(SLICE_FIELD_NAMES)):\n-            return TYPE_KIND_SLICE\n-\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        # EMPTY STRUCT\n-        if field_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        # STD VEC\n-        if (unqualified_type_name.startswith(\"Vec<\") and\n-            self.__conforms_to_field_layout(STD_VEC_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VEC\n-\n-        # STD COLLECTION VECDEQUE\n-        if (unqualified_type_name.startswith(\"VecDeque<\") and\n-            self.__conforms_to_field_layout(STD_VECDEQUE_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VECDEQUE\n-\n-        # STD COLLECTION BTREESET\n-        if (unqualified_type_name.startswith(\"BTreeSet<\") and\n-                self.__conforms_to_field_layout(STD_BTREESET_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREESET\n-\n-        # STD COLLECTION BTREEMAP\n-        if (unqualified_type_name.startswith(\"BTreeMap<\") and\n-                self.__conforms_to_field_layout(STD_BTREEMAP_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREEMAP\n-\n-        # STD STRING\n-        if (unqualified_type_name.startswith(\"String\") and\n-            self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_STD_STRING\n-\n-        # OS STRING\n-        if (unqualified_type_name == \"OsString\" and\n-            self.__conforms_to_field_layout(OS_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_OS_STRING\n-\n-        # ENUM VARIANTS\n-        if fields[0].name == ENUM_DISR_FIELD_NAME:\n-            if field_count == 1:\n-                return TYPE_KIND_CSTYLE_VARIANT\n-            elif self.__all_fields_conform_to_tuple_field_naming(1):\n-                return TYPE_KIND_TUPLE_VARIANT\n-            else:\n-                return TYPE_KIND_STRUCT_VARIANT\n-\n-        # TUPLE\n-        if self.__all_fields_conform_to_tuple_field_naming(0):\n-            if unqualified_type_name.startswith(\"(\"):\n-                return TYPE_KIND_TUPLE\n-            else:\n-                return TYPE_KIND_TUPLE_STRUCT\n-\n-        # REGULAR STRUCT\n-        return TYPE_KIND_REGULAR_STRUCT\n-\n-    def __classify_union(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-\n-        union_members = self.get_fields()\n-        union_member_count = len(union_members)\n-        if union_member_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        first_variant_name = union_members[0].name\n-        if first_variant_name is None:\n-            if union_member_count == 1:\n-                return TYPE_KIND_SINGLETON_ENUM\n-            else:\n-                return TYPE_KIND_REGULAR_ENUM\n-        elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n-            assert union_member_count == 1\n-            return TYPE_KIND_COMPRESSED_ENUM\n-        else:\n-            return TYPE_KIND_REGULAR_UNION\n-\n-    def __conforms_to_field_layout(self, expected_fields):\n-        actual_fields = self.get_fields()\n-        actual_field_count = len(actual_fields)\n-\n-        if actual_field_count != len(expected_fields):\n-            return False\n-\n-        for i in range(0, actual_field_count):\n-            if actual_fields[i].name != expected_fields[i]:\n-                return False\n-\n-        return True\n-\n-    def __all_fields_conform_to_tuple_field_naming(self, start_index):\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        for i in range(start_index, field_count):\n-            field_name = fields[i].name\n-            if (field_name is None) or (re.match(r\"__\\d+$\", field_name) is None):\n-                return False\n-        return True\n-\n-\n-class Value(object):\n-    \"\"\"\n-    This class provides a common interface for value-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific value-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-    def __init__(self, ty):\n-        self.type = ty\n-\n-    def get_child_at_index(self, index):\n-        \"\"\"Returns the value of the field, array element or variant at the given index\"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def as_integer(self):\n-        \"\"\"\n-        Try to convert the wrapped value into a Python integer. This should\n-        always succeed for values that are pointers or actual integers.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific value-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-\n-class EncodedEnumInfo(object):\n-    \"\"\"\n-    This class provides facilities for handling enum values with compressed\n-    encoding where a non-null field in one variant doubles as the discriminant.\n-    \"\"\"\n-\n-    def __init__(self, enum_val):\n-        assert enum_val.type.get_type_kind() == TYPE_KIND_COMPRESSED_ENUM\n-        variant_name = enum_val.type.get_fields()[0].name\n-        last_separator_index = variant_name.rfind(\"$\")\n-        start_index = len(ENCODED_ENUM_PREFIX)\n-        indices_substring = variant_name[start_index:last_separator_index].split(\"$\")\n-        self.__enum_val = enum_val\n-        self.__disr_field_indices = [int(index) for index in indices_substring]\n-        self.__null_variant_name = variant_name[last_separator_index + 1:]\n-\n-    def is_null_variant(self):\n-        ty = self.__enum_val.type\n-        sole_variant_val = self.__enum_val.get_child_at_index(0)\n-        discriminant_val = sole_variant_val\n-        for disr_field_index in self.__disr_field_indices:\n-            discriminant_val = discriminant_val.get_child_at_index(disr_field_index)\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT:\n-            discriminant_val = discriminant_val.get_child_at_index(0)\n-\n-        return discriminant_val.as_integer() == 0\n-\n-    def get_non_null_variant_val(self):\n-        return self.__enum_val.get_child_at_index(0)\n-\n-    def get_null_variant_name(self):\n-        return self.__null_variant_name\n-\n-\n-def get_discriminant_value_as_integer(enum_val):\n-    assert enum_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-    # we can take any variant here because the discriminant has to be the same\n-    # for all of them.\n-    variant_val = enum_val.get_child_at_index(0)\n-    disr_val = variant_val.get_child_at_index(0)\n-    return disr_val.as_integer()\n-\n-\n-def extract_length_ptr_and_cap_from_std_vec(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VEC\n-    length_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_LENGTH)\n-    buf_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_BUF)\n-\n-    length = vec_val.get_child_at_index(length_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr, capacity)\n-\n-\n-def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VECDEQUE\n-    tail_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_TAIL)\n-    head_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_HEAD)\n-    buf_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_BUF)\n-\n-    tail = vec_val.get_child_at_index(tail_field_index).as_integer()\n-    head = vec_val.get_child_at_index(head_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (tail, head, data_ptr, capacity)\n-\n-\n-def extract_length_and_ptr_from_slice(slice_val):\n-    assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n-            slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n-\n-    length_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_LENGTH)\n-    ptr_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_DATA_PTR)\n-\n-    length = slice_val.get_child_at_index(length_field_index).as_integer()\n-    data_ptr = slice_val.get_child_at_index(ptr_field_index)\n-\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr)\n-\n-\n-UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n-\n-\n-def extract_type_name(qualified_type_name):\n-    \"\"\"Extracts the type name from a fully qualified path\"\"\"\n-    if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n-        return qualified_type_name\n-\n-    end_of_search = qualified_type_name.find(\"<\")\n-    if end_of_search < 0:\n-        end_of_search = len(qualified_type_name)\n-\n-    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-    if index < 0:\n-        return qualified_type_name\n-    else:\n-        return qualified_type_name[index + 2:]\n-\n-\n-try:\n-    compat_str = unicode  # Python 2\n-except NameError:\n-    compat_str = str"}, {"sha": "9bbcaf7c4cc49fc413c795706b8671007e8ce809", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2.7\n+#!/usr/bin/env python3\n \n \"\"\"\n Generate powers of ten using William Clinger's ``AlgorithmM`` for use in"}, {"sha": "856b5df2de70bff896d5b89e61f9a296b1fd0a8c", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,3 @@\n import gdb\n-import gdb_rust_pretty_printing\n-gdb_rust_pretty_printing.register_printers(gdb.current_objfile())\n+import gdb_lookup\n+gdb_lookup.register_printers(gdb.current_objfile())"}, {"sha": "2a46eaadad6f9a1b121b706e77d45882e4690959", "filename": "src/etc/gdb_lookup.py", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,92 @@\n+import gdb\n+import re\n+\n+from gdb_providers import *\n+from rust_types import *\n+\n+\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n+_gdb_version_matched = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n+gdb_version = [int(num) for num in _gdb_version_matched.groups()] if _gdb_version_matched else []\n+\n+def register_printers(objfile):\n+    objfile.pretty_printers.append(lookup)\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields()) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.code\n+    if type_class == gdb.TYPE_CODE_STRUCT:\n+        return classify_struct(type.tag, type.fields())\n+    if type_class == gdb.TYPE_CODE_UNION:\n+        return classify_union(type.fields())\n+\n+    return RustType.OTHER\n+\n+\n+def check_enum_discriminant(valobj):\n+    content = valobj[valobj.type.fields()[0]]\n+    fields = content.type.fields()\n+    if len(fields) > 1:\n+        discriminant = int(content[fields[0]]) + 1\n+        if discriminant > len(fields):\n+            # invalid discriminant\n+            return False\n+    return True\n+\n+\n+def lookup(valobj):\n+    rust_type = classify_rust_type(valobj.type)\n+\n+    if rust_type == RustType.ENUM:\n+        # use enum provider only for GDB <7.12\n+        if gdb_version[0] < 7 or (gdb_version[0] == 7 and gdb_version[1] < 12):\n+            if check_enum_discriminant(valobj):\n+                return EnumProvider(valobj)\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringProvider(valobj)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringProvider(valobj)\n+    if rust_type == RustType.STD_STR and not rust_enabled:\n+        return StdStrProvider(valobj)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecProvider(valobj)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_SET:\n+        return StdBTreeSetProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_MAP:\n+        return StdBTreeMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapProvider(valobj)\n+        else:\n+            return StdOldHashMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj[\"map\"]\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapProvider(hash_map, show_values=False)\n+        else:\n+            return StdOldHashMapProvider(hash_map, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcProvider(valobj)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcProvider(valobj, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellProvider(valobj)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefCellProvider(valobj)\n+\n+    return None"}, {"sha": "cec9c56a23522b3ee2dd3feb694ce6c35afa4752", "filename": "src/etc/gdb_providers.py", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,385 @@\n+from sys import version_info\n+\n+import gdb\n+from gdb import lookup_type\n+\n+if version_info[0] >= 3:\n+    xrange = range\n+\n+ZERO_FIELD = \"__0\"\n+FIRST_FIELD = \"__1\"\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull[\"pointer\"]\n+    return ptr if ptr.type.code == gdb.TYPE_CODE_PTR else ptr[ZERO_FIELD]\n+\n+\n+class EnumProvider:\n+    def __init__(self, valobj):\n+        content = valobj[valobj.type.fields()[0]]\n+        fields = content.type.fields()\n+        self.empty = len(fields) == 0\n+        if not self.empty:\n+            if len(fields) == 1:\n+                discriminant = 0\n+            else:\n+                discriminant = int(content[fields[0]]) + 1\n+            self.active_variant = content[fields[discriminant]]\n+            self.name = fields[discriminant].name\n+            self.full_name = \"{}::{}\".format(valobj.type.name, self.name)\n+        else:\n+            self.full_name = valobj.type.name\n+\n+    def to_string(self):\n+        return self.full_name\n+\n+    def children(self):\n+        if not self.empty:\n+            yield self.name, self.active_variant\n+\n+\n+class StdStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        vec = valobj[\"vec\"]\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdOsStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        buf = self.valobj[\"inner\"][\"inner\"]\n+        is_windows = \"Wtf8Buf\" in buf.type.name\n+        vec = buf[ZERO_FIELD] if is_windows else buf\n+\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    def display_hint(self):\n+        return \"string\"\n+\n+\n+class StdStrProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"length\"])\n+        self.data_ptr = valobj[\"data_ptr\"]\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdVecProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return \"Vec(size={})\".format(self.length)\n+\n+    def children(self):\n+        saw_inaccessible = False\n+        for index in xrange(self.length):\n+            element_ptr = self.data_ptr + index\n+            if saw_inaccessible:\n+                return\n+            try:\n+                # rust-lang/rust#64343: passing deref expr to `str` allows\n+                # catching exception on garbage pointer\n+                str(element_ptr.dereference())\n+                yield \"[{}]\".format(index), element_ptr.dereference()\n+            except RuntimeError:\n+                saw_inaccessible = True\n+                yield str(index), \"inaccessible\"\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdVecDequeProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.head = int(valobj[\"head\"])\n+        self.tail = int(valobj[\"tail\"])\n+        self.cap = int(valobj[\"buf\"][\"cap\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+    def to_string(self):\n+        return \"VecDeque(size={})\".format(self.size)\n+\n+    def children(self):\n+        for index in xrange(0, self.size):\n+            value = (self.data_ptr + ((self.tail + index) % self.cap)).dereference()\n+            yield \"[{}]\".format(index), value\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdRcProvider:\n+    def __init__(self, valobj, is_atomic=False):\n+        self.valobj = valobj\n+        self.is_atomic = is_atomic\n+        self.ptr = unwrap_unique_or_non_null(valobj[\"ptr\"])\n+        self.value = self.ptr[\"data\" if is_atomic else \"value\"]\n+        self.strong = self.ptr[\"strong\"][\"v\" if is_atomic else \"value\"][\"value\"]\n+        self.weak = self.ptr[\"weak\"][\"v\" if is_atomic else \"value\"][\"value\"] - 1\n+\n+    def to_string(self):\n+        if self.is_atomic:\n+            return \"Arc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+        else:\n+            return \"Rc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"strong\", self.strong\n+        yield \"weak\", self.weak\n+\n+\n+class StdCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        return \"Cell\"\n+\n+    def children(self):\n+        yield \"value\", self.value\n+\n+\n+class StdRefProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"].dereference()\n+        self.borrow = valobj[\"borrow\"][\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"Ref(borrow={})\".format(borrow)\n+        else:\n+            return \"Ref(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"*value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+class StdRefCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+        self.borrow = valobj[\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"RefCell(borrow={})\".format(borrow)\n+        else:\n+            return \"RefCell(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+# Yield each key (and optionally value) from a BoxedNode.\n+def children_of_node(boxed_node, height, want_values):\n+    def cast_to_internal(node):\n+        internal_type_name = str(node.type.target()).replace(\"LeafNode\", \"InternalNode\", 1)\n+        internal_type = lookup_type(internal_type_name)\n+        return node.cast(internal_type.pointer())\n+\n+    node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n+    node_ptr = cast_to_internal(node_ptr) if height > 0 else node_ptr\n+    leaf = node_ptr[\"data\"] if height > 0 else node_ptr.dereference()\n+    keys = leaf[\"keys\"]\n+    values = leaf[\"vals\"]\n+    length = int(leaf[\"len\"])\n+\n+    for i in xrange(0, length + 1):\n+        if height > 0:\n+            child_ptr = node_ptr[\"edges\"][i][\"value\"][\"value\"]\n+            for child in children_of_node(child_ptr, height - 1, want_values):\n+                yield child\n+        if i < length:\n+            if want_values:\n+                yield keys[i][\"value\"][\"value\"], values[i][\"value\"][\"value\"]\n+            else:\n+                yield keys[i][\"value\"][\"value\"]\n+\n+\n+class StdBTreeSetProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeSet(size={})\".format(self.valobj[\"map\"][\"length\"])\n+\n+    def children(self):\n+        inner_map = self.valobj[\"map\"]\n+        if inner_map[\"length\"] > 0:\n+            root = inner_map[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], False)):\n+                yield \"[{}]\".format(i), child\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdBTreeMapProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n+\n+    def children(self):\n+        if self.valobj[\"length\"] > 0:\n+            root = self.valobj[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], True)):\n+                yield \"key{}\".format(i), child[0]\n+                yield \"val{}\".format(i), child[1]\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"map\"\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        self.table = self.valobj[\"table\"]\n+        self.size = int(self.table[\"size\"])\n+        self.hashes = self.table[\"hashes\"]\n+        self.hash_uint_type = self.hashes.type\n+        self.hash_uint_size = self.hashes.type.sizeof\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes[ZERO_FIELD][\"pointer\"]\n+\n+        self.capacity_mask = int(self.table[\"capacity_mask\"])\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table[\"marker\"].type\n+        self.pair_type = marker.template_argument(0)\n+        self.pair_type_size = self.pair_type.sizeof\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            data_ptr = self.data_ptr.cast(self.hash_uint_type.pointer())\n+            address = data_ptr + idx\n+            hash_uint = address.dereference()\n+            hash_ptr = hash_uint[ZERO_FIELD][\"pointer\"]\n+            if int(hash_ptr) != 0:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        start = int(self.data_ptr) & ~1\n+\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = gdb.Value(start + pairs_offset).cast(self.pair_type.pointer())\n+\n+        for index in range(self.size):\n+            table_index = self.valid_indices[index]\n+            idx = table_index & self.capacity_mask\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\"\n+\n+\n+class StdHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        table = self.valobj[\"base\"][\"table\"]\n+        capacity = int(table[\"bucket_mask\"]) + 1\n+        ctrl = table[\"ctrl\"][\"pointer\"]\n+\n+        self.size = int(table[\"items\"])\n+        self.data_ptr = table[\"data\"][\"pointer\"]\n+        self.pair_type = self.data_ptr.dereference().type\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl + idx\n+            value = address.dereference()\n+            is_presented = value & 128 == 0\n+            if is_presented:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        pairs_start = self.data_ptr\n+\n+        for index in range(self.size):\n+            idx = self.valid_indices[index]\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\""}, {"sha": "0914c22eb13f03d0b9d0c94474ac7e5b57795195", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,458 +0,0 @@\n-import gdb\n-import re\n-import sys\n-import debugger_pretty_printers_common as rustpp\n-\n-# We want a version of `range` which doesn't allocate an intermediate list,\n-# specifically it should use a lazy iterator. In Python 2 this was `xrange`, but\n-# if we're running with Python 3 then we need to use `range` instead.\n-if sys.version_info[0] >= 3:\n-    xrange = range\n-\n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n-\n-# The btree pretty-printers fail in a confusing way unless\n-# https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n-# This fix went in 8.1, so check for that.\n-# See https://github.com/rust-lang/rust/issues/56730\n-gdb_81 = False\n-_match = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n-if _match:\n-    if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n-        gdb_81 = True\n-\n-# ===============================================================================\n-# GDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class GdbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(GdbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        tag = self.ty.tag\n-\n-        if tag is None:\n-            return tag\n-\n-        return rustpp.extract_type_name(tag).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        if self.ty.code == gdb.TYPE_CODE_STRUCT:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if self.ty.code == gdb.TYPE_CODE_UNION:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if self.ty.code == gdb.TYPE_CODE_PTR:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if self.ty.code == gdb.TYPE_CODE_ENUM:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields())\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class GdbValue(rustpp.Value):\n-    def __init__(self, gdb_val):\n-        super(GdbValue, self).__init__(GdbType(gdb_val.type))\n-        self.gdb_val = gdb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            gdb_field = get_field_at_index(self.gdb_val, index)\n-            child = GdbValue(self.gdb_val[gdb_field])\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        if self.gdb_val.type.code == gdb.TYPE_CODE_PTR:\n-            as_str = rustpp.compat_str(self.gdb_val).split()[0]\n-            return int(as_str, 0)\n-        return int(self.gdb_val)\n-\n-    def get_wrapped_value(self):\n-        return self.gdb_val\n-\n-\n-def register_printers(objfile):\n-    \"\"\"Registers Rust pretty printers for the given objfile\"\"\"\n-    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n-\n-\n-def rust_pretty_printer_lookup_function(gdb_val):\n-    \"\"\"\n-    Returns the correct Rust pretty printer for the given value\n-    if there is one\n-    \"\"\"\n-\n-    val = GdbValue(gdb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return RustSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return RustStdVecPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n-        return RustStdVecDequePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREESET and gdb_81:\n-        return RustStdBTreeSetPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP and gdb_81:\n-        return RustStdBTreeMapPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return RustStdStringPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_OS_STRING:\n-        return RustOsStringPrinter(val)\n-\n-    # Checks after this point should only be for \"compiler\" types --\n-    # things that gdb's Rust language support knows about.\n-    if rust_enabled:\n-        return None\n-\n-    if type_kind == rustpp.TYPE_KIND_EMPTY:\n-        return RustEmptyPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return RustStringSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=True,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return RustCStyleVariantPrinter(val.get_child_at_index(0))\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        variant = get_field_at_index(gdb_val, 0)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        variant = get_field_at_index(gdb_val, discriminant_val)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return IdentityPrinter(encoded_enum_info.get_null_variant_name())\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return rust_pretty_printer_lookup_function(non_null_val.get_wrapped_value())\n-\n-    # No pretty printer has been found\n-    return None\n-\n-\n-# =------------------------------------------------------------------------------\n-# Pretty Printer Classes\n-# =------------------------------------------------------------------------------\n-class RustEmptyPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        return self.__val.type.get_unqualified_type_name()\n-\n-\n-class RustStructPrinter(object):\n-    def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n-        self.__val = val\n-        self.__omit_first_field = omit_first_field\n-        self.__omit_type_name = omit_type_name\n-        self.__is_tuple_like = is_tuple_like\n-\n-    def to_string(self):\n-        if self.__omit_type_name:\n-            return None\n-        return self.__val.type.get_unqualified_type_name()\n-\n-    def children(self):\n-        cs = []\n-        wrapped_value = self.__val.get_wrapped_value()\n-\n-        for number, field in enumerate(self.__val.type.get_fields()):\n-            field_value = wrapped_value[field.name]\n-            if self.__is_tuple_like:\n-                cs.append((str(number), field_value))\n-            else:\n-                cs.append((field.name, field_value))\n-\n-        if self.__omit_first_field:\n-            cs = cs[1:]\n-\n-        return cs\n-\n-    def display_hint(self):\n-        if self.__is_tuple_like:\n-            return \"array\"\n-        else:\n-            return \"\"\n-\n-\n-class RustSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % length))\n-\n-    def children(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        assert data_ptr.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-        raw_ptr = data_ptr.get_wrapped_value()\n-\n-        for index in xrange(0, length):\n-            yield (str(index), (raw_ptr + index).dereference())\n-\n-\n-class RustStringSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        raw_ptr = data_ptr.get_wrapped_value()\n-        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustStdVecPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (length, cap)))\n-\n-    def children(self):\n-        saw_inaccessible = False\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        for index in xrange(0, length):\n-            if saw_inaccessible:\n-                return\n-            try:\n-                # rust-lang/rust#64343: passing deref expr to `str` allows\n-                # catching exception on garbage pointer\n-                str((gdb_ptr + index).dereference())\n-                yield (str(index), (gdb_ptr + index).dereference())\n-            except RuntimeError:\n-                saw_inaccessible = True\n-                yield (str(index), \"inaccessible\")\n-\n-\n-class RustStdVecDequePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (size, cap)))\n-\n-    def children(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        for index in xrange(0, size):\n-            yield (str(index), (gdb_ptr + ((tail + index) % cap)).dereference())\n-\n-\n-# Yield each key (and optionally value) from a BoxedNode.\n-def children_of_node(boxed_node, height, want_values):\n-    node_ptr = boxed_node['ptr']['pointer']\n-    if height > 0:\n-        type_name = str(node_ptr.type.target()).replace('LeafNode', 'InternalNode')\n-        node_type = gdb.lookup_type(type_name)\n-        node_ptr = node_ptr.cast(node_type.pointer())\n-        leaf = node_ptr['data']\n-    else:\n-        leaf = node_ptr.dereference()\n-    keys = leaf['keys']\n-    if want_values:\n-        values = leaf['vals']\n-    length = int(leaf['len'])\n-    for i in xrange(0, length + 1):\n-        if height > 0:\n-            child_ptr = node_ptr['edges'][i]['value']['value']\n-            for child in children_of_node(child_ptr, height - 1, want_values):\n-                yield child\n-        if i < length:\n-            if want_values:\n-                yield (keys[i]['value']['value'], values[i]['value']['value'])\n-            else:\n-                yield keys[i]['value']['value']\n-\n-\n-class RustStdBTreeSetPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n-\n-    def children(self):\n-        root = self.__val.get_wrapped_value()['map']['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], False):\n-            yield (str(i), child)\n-            i = i + 1\n-\n-\n-class RustStdBTreeMapPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"map\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n-\n-    def children(self):\n-        root = self.__val.get_wrapped_value()['root']\n-        node_ptr = root['node']\n-        i = 0\n-        for child in children_of_node(node_ptr, root['height'], True):\n-            yield (str(i), child[0])\n-            yield (str(i), child[1])\n-            i = i + 1\n-\n-\n-class RustStdStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        vec = self.__val.get_child_at_index(0)\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n-                                                        length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustOsStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        buf = self.__val.get_child_at_index(0)\n-        vec = buf.get_child_at_index(0)\n-        if vec.type.get_unqualified_type_name() == \"Wtf8Buf\":\n-            vec = vec.get_child_at_index(0)\n-\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n-            vec)\n-        return data_ptr.get_wrapped_value().lazy_string(length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustCStyleVariantPrinter(object):\n-    def __init__(self, val):\n-        assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM\n-        self.__val = val\n-\n-    def to_string(self):\n-        return str(self.__val.get_wrapped_value())\n-\n-\n-class IdentityPrinter(object):\n-    def __init__(self, string):\n-        self.string = string\n-\n-    def to_string(self):\n-        return self.string\n-\n-\n-def get_field_at_index(gdb_val, index):\n-    i = 0\n-    for field in gdb_val.type.fields():\n-        if i == index:\n-            return field\n-        i += 1\n-    return None"}, {"sha": "a0ba47e1dbe313d1fd7683c4d73766d0dcce0b6a", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -15,9 +15,6 @@\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n TEMPLATE = \"\"\"\\\n-// FIXME: missing sysroot spans (#53081)\n-// ignore-i586-unknown-linux-gnu\n-// ignore-i586-unknown-linux-musl\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}"}, {"sha": "629c8e04ec533b0fc66f923b63794080c0dbc966", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -139,11 +139,17 @@ def listen():\n def start_watchdog():\n     \"\"\"Starts a watchdog thread that will terminate the process after a certain\n     period of time\"\"\"\n-    watchdog_start_time = time.clock()\n+\n+    try:\n+        from time import clock\n+    except ImportError:\n+        from time import perf_counter as clock\n+\n+    watchdog_start_time = clock()\n     watchdog_max_time = watchdog_start_time + 30\n \n     def watchdog():\n-        while time.clock() < watchdog_max_time:\n+        while clock() < watchdog_max_time:\n             time.sleep(1)\n         print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n         thread.interrupt_main()"}, {"sha": "f470c62d8992730b88bdfbba617d411f88a5fb19", "filename": "src/etc/lldb_commands", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_commands", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_commands", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_commands?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,19 @@\n+command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_lookup.py\\\"\n+type synthetic add -l lldb_lookup.synthetic_lookup -x \\\".*\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)String$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&str$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&\\\\[.+\\\\]$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::ffi::([a-z_]+::)+)OsString$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Vec<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)VecDeque<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Rc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Arc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Cell<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Ref<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefMut<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefCell<.+>$\\\" --category Rust\n+type category enable Rust"}, {"sha": "13420fbaf0a759fa2aa0973b85d01ccc58fb8de9", "filename": "src/etc/lldb_lookup.py", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,115 @@\n+import lldb\n+\n+from lldb_providers import *\n+from rust_types import RustType, classify_struct, classify_union\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.GetTypeClass()\n+    if type_class == lldb.eTypeClassStruct:\n+        return classify_struct(type.name, type.fields)\n+    if type_class == lldb.eTypeClassUnion:\n+        return classify_union(type.fields)\n+\n+    return RustType.OTHER\n+\n+\n+def summary_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    \"\"\"Returns the summary provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_STR:\n+        return StdStrSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSummaryProvider(valobj, dict)\n+\n+    return \"\"\n+\n+\n+def synthetic_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> object\n+    \"\"\"Returns the synthetic provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STRUCT:\n+        return StructSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STRUCT_VARIANT:\n+        return StructSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.TUPLE:\n+        return TupleSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.TUPLE_VARIANT:\n+        return TupleSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.EMPTY:\n+        return EmptySyntheticProvider(valobj, dict)\n+    if rust_type == RustType.REGULAR_ENUM:\n+        discriminant = valobj.GetChildAtIndex(0).GetChildAtIndex(0).GetValueAsUnsigned()\n+        return synthetic_lookup(valobj.GetChildAtIndex(discriminant), dict)\n+    if rust_type == RustType.SINGLETON_ENUM:\n+        return synthetic_lookup(valobj.GetChildAtIndex(0), dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return StdSliceSyntheticProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapSyntheticProvider(valobj, dict)\n+        else:\n+            return StdOldHashMapSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj.GetChildAtIndex(0)\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+        else:\n+            return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSyntheticProvider(valobj, dict, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSyntheticProvider(valobj, dict, is_cell=True)\n+\n+    return DefaultSynthteticProvider(valobj, dict)"}, {"sha": "3c7817b3a618d6d33c468d1dbfdd0fd07e308253", "filename": "src/etc/lldb_providers.py", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,715 @@\n+import sys\n+\n+from lldb import SBValue, SBData, SBError, eBasicTypeLong, eBasicTypeUnsignedLong, \\\n+    eBasicTypeUnsignedChar\n+\n+# from lldb.formatters import Logger\n+\n+####################################################################################################\n+# This file contains two kinds of pretty-printers: summary and synthetic.\n+#\n+# Important classes from LLDB module:\n+#   SBValue: the value of a variable, a register, or an expression\n+#   SBType:  the data type; each SBValue has a corresponding SBType\n+#\n+# Summary provider is a function with the type `(SBValue, dict) -> str`.\n+#   The first parameter is the object encapsulating the actual variable being displayed;\n+#   The second parameter is an internal support parameter used by LLDB, and you should not touch it.\n+#\n+# Synthetic children is the way to provide a children-based representation of the object's value.\n+# Synthetic provider is a class that implements the following interface:\n+#\n+#     class SyntheticChildrenProvider:\n+#         def __init__(self, SBValue, dict)\n+#         def num_children(self)\n+#         def get_child_index(self, str)\n+#         def get_child_at_index(self, int)\n+#         def update(self)\n+#         def has_children(self)\n+#         def get_value(self)\n+#\n+#\n+# You can find more information and examples here:\n+#   1. https://lldb.llvm.org/varformats.html\n+#   2. https://lldb.llvm.org/python-reference.html\n+#   3. https://lldb.llvm.org/python_reference/lldb.formatters.cpp.libcxx-pysrc.html\n+#   4. https://github.com/llvm-mirror/lldb/tree/master/examples/summaries/cocoa\n+####################################################################################################\n+\n+PY3 = sys.version_info[0] == 3\n+\n+\n+class ValueBuilder:\n+    def __init__(self, valobj):\n+        # type: (SBValue) -> ValueBuilder\n+        self.valobj = valobj\n+        process = valobj.GetProcess()\n+        self.endianness = process.GetByteOrder()\n+        self.pointer_size = process.GetAddressByteSize()\n+\n+    def from_int(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeLong)\n+        data = SBData.CreateDataFromSInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+    def from_uint(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeUnsignedLong)\n+        data = SBData.CreateDataFromUInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull.GetChildMemberWithName(\"pointer\")\n+    return ptr if ptr.TypeIsPointerType() else ptr.GetChildAtIndex(0)\n+\n+\n+class DefaultSynthteticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> DefaultSynthteticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"Default synthetic provider for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.valobj.GetNumChildren()\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.valobj.GetIndexOfChildWithName(name)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return self.valobj.GetChildAtIndex(index)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return self.valobj.MightHaveChildren()\n+\n+\n+class EmptySyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> EmptySyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[EmptySyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 0\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return None\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return False\n+\n+\n+def SizeSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    return 'size=' + str(valobj.GetNumChildren())\n+\n+\n+def vec_to_string(vec):\n+    length = vec.GetNumChildren()\n+    chars = [vec.GetChildAtIndex(i).GetValueAsUnsigned() for i in range(length)]\n+    return bytes(chars).decode(errors='replace') if PY3 else \"\".join(chr(char) for char in chars)\n+\n+\n+def StdStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStringSummaryProvider] for \" + str(valobj.GetName())\n+    vec = valobj.GetChildAtIndex(0)\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdOsStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdOsStringSummaryProvider] for \" + str(valobj.GetName())\n+    buf = valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+    is_windows = \"Wtf8Buf\" in buf.type.name\n+    vec = buf.GetChildAtIndex(0) if is_windows else buf\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdStrSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStrSummaryProvider] for \" + str(valobj.GetName())\n+\n+    length = valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+    if length == 0:\n+        return '\"\"'\n+\n+    data_ptr = valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+    start = data_ptr.GetValueAsUnsigned()\n+    error = SBError()\n+    process = data_ptr.GetProcess()\n+    data = process.ReadMemory(start, length, error)\n+    data = data.decode(encoding='UTF-8') if PY3 else data\n+    return '\"%s\"' % data\n+\n+\n+class StructSyntheticProvider:\n+    \"\"\"Pretty-printer for structs and struct enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> StructSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+        self.fields = {}\n+\n+        if is_variant:\n+            self.fields_count = self.type.GetNumberOfFields() - 1\n+            real_fields = self.type.fields[1:]\n+        else:\n+            self.fields_count = self.type.GetNumberOfFields()\n+            real_fields = self.type.fields\n+\n+        for number, field in enumerate(real_fields):\n+            self.fields[field.name] = number\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.fields_count\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.fields.get(name, -1)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        return self.valobj.GetChildMemberWithName(field.name)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class TupleSyntheticProvider:\n+    \"\"\"Pretty-printer for tuples and tuple enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> TupleSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+\n+        if is_variant:\n+            self.size = self.type.GetNumberOfFields() - 1\n+        else:\n+            self.size = self.type.GetNumberOfFields()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name.isdigit():\n+            return int(name)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        element = self.valobj.GetChildMemberWithName(field.name)\n+        return self.valobj.CreateValueFromData(str(index), element.GetData(), element.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::vec::Vec<T>\n+\n+    struct Vec<T> { buf: RawVec<T>, len: usize }\n+    struct RawVec<T> { ptr: Unique<T>, cap: usize, ... }\n+    rust 1.31.1: struct Unique<T: ?Sized> { pointer: NonZero<*const T>, ... }\n+    rust 1.33.0: struct Unique<T: ?Sized> { pointer: *const T, ... }\n+    struct NonZero<T>(T)\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"len\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdSliceSyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+        self.data_ptr = self.valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecDequeSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::collections::vec_deque::VecDeque<T>\n+\n+    struct VecDeque<T> { tail: usize, head: usize, buf: RawVec<T> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecDequeSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecDequeSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit() and self.tail <= index and (self.tail + index) % self.cap < self.head:\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + ((index + self.tail) % self.cap) * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.head = self.valobj.GetChildMemberWithName(\"head\").GetValueAsUnsigned()\n+        self.tail = self.valobj.GetChildMemberWithName(\"tail\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+        self.cap = self.buf.GetChildMemberWithName(\"cap\").GetValueAsUnsigned()\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for std::collections::hash::map::HashMap<K, V, S>\n+\n+    struct HashMap<K, V, S> {..., table: RawTable<K, V>, ... }\n+    struct RawTable<K, V> { capacity_mask: usize, size: usize, hashes: TaggedHashUintPtr, ... }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdOldHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        # logger = Logger.Logger()\n+        start = self.data_ptr.GetValueAsUnsigned() & ~1\n+\n+        # See `libstd/collections/hash/table.rs:raw_bucket_at\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        # See `libcore/alloc.rs:padding_needed_for`\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+        # len_rounded_up = ((hashes + align - 1) & ~(align - 1)) - hashes\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = start + pairs_offset\n+\n+        table_index = self.valid_indices[index]\n+        idx = table_index & self.capacity_mask\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        # logger = Logger.Logger()\n+\n+        self.table = self.valobj.GetChildMemberWithName(\"table\")  # type: SBValue\n+        self.size = self.table.GetChildMemberWithName(\"size\").GetValueAsUnsigned()\n+        self.hashes = self.table.GetChildMemberWithName(\"hashes\")\n+        self.hash_uint_type = self.hashes.GetType()\n+        self.hash_uint_size = self.hashes.GetType().GetByteSize()\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes.GetChildAtIndex(0).GetChildAtIndex(0)\n+\n+        self.capacity_mask = self.table.GetChildMemberWithName(\"capacity_mask\").GetValueAsUnsigned()\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table.GetChildMemberWithName(\"marker\").GetType()  # type: SBType\n+        self.pair_type = marker.template_args[0]\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            address = self.data_ptr.GetValueAsUnsigned() + idx * self.hash_uint_size\n+            hash_uint = self.data_ptr.CreateValueFromAddress(\"[%s]\" % idx, address,\n+                                                             self.hash_uint_type)\n+            hash_ptr = hash_uint.GetChildAtIndex(0).GetChildAtIndex(0)\n+            if hash_ptr.GetValueAsUnsigned() != 0:\n+                self.valid_indices.append(idx)\n+\n+        # logger >> \"Valid indices: {}\".format(str(self.valid_indices))\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for hashbrown's HashMap\"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        pairs_start = self.data_ptr.GetValueAsUnsigned()\n+        idx = self.valid_indices[index]\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n+        ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n+\n+        self.size = table.GetChildMemberWithName(\"items\").GetValueAsUnsigned()\n+        self.data_ptr = table.GetChildMemberWithName(\"data\").GetChildAtIndex(0)\n+        self.pair_type = self.data_ptr.Dereference().GetType()\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        u8_type = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar)\n+        u8_type_size = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar).GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl.GetValueAsUnsigned() + idx * u8_type_size\n+            value = ctrl.CreateValueFromAddress(\"ctrl[%s]\" % idx, address,\n+                                                u8_type).GetValueAsUnsigned()\n+            is_present = value & 128 == 0\n+            if is_present:\n+                self.valid_indices.append(idx)\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRcSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    strong = valobj.GetChildMemberWithName(\"strong\").GetValueAsUnsigned()\n+    weak = valobj.GetChildMemberWithName(\"weak\").GetValueAsUnsigned()\n+    return \"strong={}, weak={}\".format(strong, weak)\n+\n+\n+class StdRcSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::rc::Rc<T> and alloc::sync::Arc<T>\n+\n+    struct Rc<T> { ptr: NonNull<RcBox<T>>, ... }\n+    rust 1.31.1: struct NonNull<T> { pointer: NonZero<*const T> }\n+    rust 1.33.0: struct NonNull<T> { pointer: *const T }\n+    struct NonZero<T>(T)\n+    struct RcBox<T> { strong: Cell<usize>, weak: Cell<usize>, value: T }\n+    struct Cell<T> { value: UnsafeCell<T> }\n+    struct UnsafeCell<T> { value: T }\n+\n+    struct Arc<T> { ptr: NonNull<ArcInner<T>>, ... }\n+    struct ArcInner<T> { strong: atomic::AtomicUsize, weak: atomic::AtomicUsize, data: T }\n+    struct AtomicUsize { v: UnsafeCell<usize> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, is_atomic=False):\n+        # type: (SBValue, dict, bool) -> StdRcSyntheticProvider\n+        self.valobj = valobj\n+\n+        self.ptr = unwrap_unique_or_non_null(self.valobj.GetChildMemberWithName(\"ptr\"))\n+\n+        self.value = self.ptr.GetChildMemberWithName(\"data\" if is_atomic else \"value\")\n+\n+        self.strong = self.ptr.GetChildMemberWithName(\"strong\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+        self.weak = self.ptr.GetChildMemberWithName(\"weak\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 3 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        if name == \"strong\":\n+            return 1\n+        if name == \"weak\":\n+            return 2\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_uint(\"strong\", self.strong_count)\n+        if index == 2:\n+            return self.value_builder.from_uint(\"weak\", self.weak_count)\n+\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.strong_count = self.strong.GetValueAsUnsigned()\n+        self.weak_count = self.weak.GetValueAsUnsigned() - 1\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdCellSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Cell\"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdCellSyntheticProvider\n+        self.valobj = valobj\n+        self.value = valobj.GetChildMemberWithName(\"value\").GetChildAtIndex(0)\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRefSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    borrow = valobj.GetChildMemberWithName(\"borrow\").GetValueAsSigned()\n+    return \"borrow={}\".format(borrow) if borrow >= 0 else \"borrow_mut={}\".format(-borrow)\n+\n+\n+class StdRefSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Ref, std::cell::RefMut, and std::cell::RefCell\"\"\"\n+\n+    def __init__(self, valobj, dict, is_cell=False):\n+        # type: (SBValue, dict, bool) -> StdRefSyntheticProvider\n+        self.valobj = valobj\n+\n+        borrow = valobj.GetChildMemberWithName(\"borrow\")\n+        value = valobj.GetChildMemberWithName(\"value\")\n+        if is_cell:\n+            self.borrow = borrow.GetChildMemberWithName(\"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.GetChildMemberWithName(\"value\")\n+        else:\n+            self.borrow = borrow.GetChildMemberWithName(\"borrow\").GetChildMemberWithName(\n+                \"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.Dereference()\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 2 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        if name == \"value\":\n+            return 0\n+        if name == \"borrow\":\n+            return 1\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_int(\"borrow\", self.borrow_count)\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.borrow_count = self.borrow.GetValueAsSigned()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=8e6de3244cd62cbde367c206bc9972daded5281d", "patch": "@@ -1,305 +0,0 @@\n-import lldb\n-import debugger_pretty_printers_common as rustpp\n-\n-# ===============================================================================\n-# LLDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class LldbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(LldbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        qualified_name = self.ty.GetName()\n-\n-        if qualified_name is None:\n-            return qualified_name\n-\n-        return rustpp.extract_type_name(qualified_name).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        type_class = self.ty.GetTypeClass()\n-\n-        if type_class == lldb.eTypeClassStruct:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if type_class == lldb.eTypeClassUnion:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if type_class == lldb.eTypeClassPointer:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if type_class == lldb.eTypeClassArray:\n-            return rustpp.DWARF_TYPE_CODE_ARRAY\n-\n-        if type_class == lldb.eTypeClassEnumeration:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-        return None\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields)\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class LldbValue(rustpp.Value):\n-    def __init__(self, lldb_val):\n-        ty = lldb_val.type\n-        wty = LldbType(ty)\n-        super(LldbValue, self).__init__(wty)\n-        self.lldb_val = lldb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            lldb_field = self.lldb_val.GetChildAtIndex(index)\n-            child = LldbValue(lldb_field)\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        return self.lldb_val.GetValueAsUnsigned()\n-\n-    def get_wrapped_value(self):\n-        return self.lldb_val\n-\n-\n-def print_val(lldb_val, internal_dict):\n-    val = LldbValue(lldb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n-        type_kind == rustpp.TYPE_KIND_REGULAR_UNION or\n-        type_kind == rustpp.TYPE_KIND_EMPTY):\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return print_vec_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return print_str_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return print_std_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return print_std_string_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=True,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return val.type.get_unqualified_type_name()\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_PTR:\n-        return print_pointer_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_FIXED_SIZE_VEC:\n-        return print_fixed_size_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        return print_val(lldb_val.GetChildAtIndex(discriminant_val), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return encoded_enum_info.get_null_variant_name()\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return print_val(non_null_val.get_wrapped_value(), internal_dict)\n-\n-    # No pretty printer has been found\n-    return lldb_val.GetValue()\n-\n-\n-# =---------------------------------------------------------------------------------------\n-# Type-Specialized Printing Functions\n-# =---------------------------------------------------------------------------------------\n-\n-def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n-    \"\"\"\n-    Prints a struct, tuple, or tuple struct value with Rust syntax.\n-    Ignores any fields before field_start_index.\n-    \"\"\"\n-    assert (val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT or\n-            val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION)\n-\n-    if omit_type_name:\n-        type_name = \"\"\n-    else:\n-        type_name = val.type.get_unqualified_type_name()\n-\n-    if is_tuple_like:\n-        template = \"%(type_name)s(%(body)s)\"\n-        separator = \", \"\n-    else:\n-        template = \"%(type_name)s {\\n%(body)s\\n}\"\n-        separator = \", \\n\"\n-\n-    fields = val.type.get_fields()\n-\n-    def render_child(child_index):\n-        this = \"\"\n-        if not is_tuple_like:\n-            field_name = fields[child_index].name\n-            this += field_name + \": \"\n-\n-        field_val = val.get_child_at_index(child_index)\n-\n-        if not field_val.get_wrapped_value().IsValid():\n-            field = fields[child_index]\n-            # LLDB is not good at handling zero-sized values, so we have to help\n-            # it a little\n-            if field.GetType().GetByteSize() == 0:\n-                return this + rustpp.extract_type_name(field.GetType().GetName())\n-            else:\n-                return this + \"<invalid value>\"\n-\n-        return this + print_val(field_val.get_wrapped_value(), internal_dict)\n-\n-    if omit_first_field:\n-        field_start_index = 1\n-    else:\n-        field_start_index = 0\n-\n-    body = separator.join([render_child(idx) for idx in range(field_start_index, len(fields))])\n-\n-    return template % {\"type_name\": type_name,\n-                       \"body\": body}\n-\n-\n-def print_pointer_val(val, internal_dict):\n-    \"\"\"Prints a pointer value with Rust syntax\"\"\"\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-    sigil = \"&\"\n-    type_name = val.type.get_unqualified_type_name()\n-    if type_name and type_name[0:1] in [\"&\", \"*\"]:\n-        sigil = type_name[0:1]\n-\n-    return sigil + hex(val.as_integer())\n-\n-\n-def print_fixed_size_vec_val(val, internal_dict):\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ARRAY\n-    lldb_val = val.get_wrapped_value()\n-\n-    output = \"[\"\n-\n-    for i in range(lldb_val.num_children):\n-        output += print_val(lldb_val.GetChildAtIndex(i), internal_dict)\n-        if i != lldb_val.num_children - 1:\n-            output += \", \"\n-\n-    output += \"]\"\n-    return output\n-\n-\n-def print_vec_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return \"&[%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                           data_ptr,\n-                                           length,\n-                                           internal_dict)\n-\n-\n-def print_std_vec_val(val, internal_dict):\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(val)\n-    return \"vec![%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                              data_ptr,\n-                                              length,\n-                                              internal_dict)\n-\n-\n-def print_str_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return read_utf8_string(data_ptr, length)\n-\n-\n-def print_std_string_val(val, internal_dict):\n-    vec = val.get_child_at_index(0)\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-    return read_utf8_string(data_ptr, length)\n-\n-# =-----------------------------------------------------------------------\n-# Helper Functions\n-# =-----------------------------------------------------------------------\n-\n-\n-def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n-    \"\"\"Prints a contiguous memory range, interpreting it as values of the\n-       pointee-type of data_ptr_val.\"\"\"\n-\n-    data_ptr_type = data_ptr_val.type\n-    assert data_ptr_type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-\n-    element_type = data_ptr_type.get_wrapped_value().GetPointeeType()\n-    element_type_size = element_type.GetByteSize()\n-\n-    start_address = data_ptr_val.as_integer()\n-    raw_value = data_ptr_val.get_wrapped_value()\n-\n-    def render_element(i):\n-        address = start_address + i * element_type_size\n-        element_val = raw_value.CreateValueFromAddress(array_name + (\"[%s]\" % i),\n-                                                       address,\n-                                                       element_type)\n-        return print_val(element_val, internal_dict)\n-\n-    return ', '.join([render_element(i) for i in range(length)])\n-\n-\n-def read_utf8_string(ptr_val, byte_count):\n-    if byte_count == 0:\n-        return '\"\"'\n-    error = lldb.SBError()\n-    process = ptr_val.get_wrapped_value().GetProcess()\n-    data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)\n-    if error.Success():\n-        return '\"%s\"' % data.decode(encoding='UTF-8')\n-    else:\n-        return '<error: %s>' % error.GetCString()"}, {"sha": "b950cea79edfeaef99761ae1ab76d5cee09cf974", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -2,8 +2,16 @@\n # Exit if anything fails\n set -e\n \n+# Prefer rustc in the same directory as this script\n+DIR=\"$(dirname \"$0\")\"\n+if [ -x \"$DIR/rustc\" ]; then\n+  RUSTC=\"$DIR/rustc\"\n+else\n+  RUSTC=\"rustc\"\n+fi\n+\n # Find out where the pretty printer Python module is\n-RUSTC_SYSROOT=`rustc --print=sysroot`\n+RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n \n # Run GDB with the additional arguments that load the pretty printers"}, {"sha": "9744913b686501d83f864bd1c5b2d8674f9cd913", "filename": "src/etc/rust-gdbgui", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-gdbgui", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-gdbgui", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdbgui?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -31,8 +31,16 @@ icon to start your program running.\n     exit 0\n fi\n \n+# Prefer rustc in the same directory as this script\n+DIR=\"$(dirname \"$0\")\"\n+if [ -x \"$DIR/rustc\" ]; then\n+  RUSTC=\"$DIR/rustc\"\n+else\n+  RUSTC=\"rustc\"\n+fi\n+\n # Find out where the pretty printer Python module is\n-RUSTC_SYSROOT=`rustc --print=sysroot`\n+RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n \n # Set the environment variable `RUST_GDB` to overwrite the call to a"}, {"sha": "28b32ef1ad5328cbef7f3dbc70131d8bbd89906d", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -30,13 +30,5 @@ EOF\n     fi\n fi\n \n-# Prepare commands that will be loaded before any file on the command line has been loaded\n-script_import=\"command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_rust_formatters.py\\\"\"\n-category_definition=\"type summary add --no-value --python-function lldb_rust_formatters.print_val -x \\\".*\\\" --category Rust\"\n-category_enable=\"type category enable Rust\"\n-\n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n-    --one-line-before-file \"$category_definition\" \\\n-    --one-line-before-file \"$category_enable\" \\\n-    \"$@\"\n+exec \"$lldb\" --source-before-file ./lldb_commands \"$@\""}, {"sha": "b49fd19ed4cbbbe40ba49458037bb4c2fff5e64b", "filename": "src/etc/rust_types.py", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust_types.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Frust_types.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust_types.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -0,0 +1,113 @@\n+import re\n+\n+\n+class RustType(object):\n+    OTHER = \"Other\"\n+    STRUCT = \"Struct\"\n+    TUPLE = \"Tuple\"\n+    CSTYLE_VARIANT = \"CStyleVariant\"\n+    TUPLE_VARIANT = \"TupleVariant\"\n+    STRUCT_VARIANT = \"StructVariant\"\n+    ENUM = \"Enum\"\n+    EMPTY = \"Empty\"\n+    SINGLETON_ENUM = \"SingletonEnum\"\n+    REGULAR_ENUM = \"RegularEnum\"\n+    COMPRESSED_ENUM = \"CompressedEnum\"\n+    REGULAR_UNION = \"RegularUnion\"\n+\n+    STD_STRING = \"StdString\"\n+    STD_OS_STRING = \"StdOsString\"\n+    STD_STR = \"StdStr\"\n+    STD_SLICE = \"StdSlice\"\n+    STD_VEC = \"StdVec\"\n+    STD_VEC_DEQUE = \"StdVecDeque\"\n+    STD_BTREE_SET = \"StdBTreeSet\"\n+    STD_BTREE_MAP = \"StdBTreeMap\"\n+    STD_HASH_MAP = \"StdHashMap\"\n+    STD_HASH_SET = \"StdHashSet\"\n+    STD_RC = \"StdRc\"\n+    STD_ARC = \"StdArc\"\n+    STD_CELL = \"StdCell\"\n+    STD_REF = \"StdRef\"\n+    STD_REF_MUT = \"StdRefMut\"\n+    STD_REF_CELL = \"StdRefCell\"\n+\n+\n+STD_STRING_REGEX = re.compile(r\"^(alloc::(\\w+::)+)String$\")\n+STD_STR_REGEX = re.compile(r\"^&str$\")\n+STD_SLICE_REGEX = re.compile(r\"^&\\[.+\\]$\")\n+STD_OS_STRING_REGEX = re.compile(r\"^(std::ffi::(\\w+::)+)OsString$\")\n+STD_VEC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Vec<.+>$\")\n+STD_VEC_DEQUE_REGEX = re.compile(r\"^(alloc::(\\w+::)+)VecDeque<.+>$\")\n+STD_BTREE_SET_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeSet<.+>$\")\n+STD_BTREE_MAP_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeMap<.+>$\")\n+STD_HASH_MAP_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashMap<.+>$\")\n+STD_HASH_SET_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashSet<.+>$\")\n+STD_RC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Rc<.+>$\")\n+STD_ARC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Arc<.+>$\")\n+STD_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)Cell<.+>$\")\n+STD_REF_REGEX = re.compile(r\"^(core::(\\w+::)+)Ref<.+>$\")\n+STD_REF_MUT_REGEX = re.compile(r\"^(core::(\\w+::)+)RefMut<.+>$\")\n+STD_REF_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)RefCell<.+>$\")\n+\n+TUPLE_ITEM_REGEX = re.compile(r\"__\\d+$\")\n+\n+ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n+ENUM_DISR_FIELD_NAME = \"<<variant>>\"\n+\n+STD_TYPE_TO_REGEX = {\n+    RustType.STD_STRING: STD_STRING_REGEX,\n+    RustType.STD_OS_STRING: STD_OS_STRING_REGEX,\n+    RustType.STD_STR: STD_STR_REGEX,\n+    RustType.STD_SLICE: STD_SLICE_REGEX,\n+    RustType.STD_VEC: STD_VEC_REGEX,\n+    RustType.STD_VEC_DEQUE: STD_VEC_DEQUE_REGEX,\n+    RustType.STD_HASH_MAP: STD_HASH_MAP_REGEX,\n+    RustType.STD_HASH_SET: STD_HASH_SET_REGEX,\n+    RustType.STD_BTREE_SET: STD_BTREE_SET_REGEX,\n+    RustType.STD_BTREE_MAP: STD_BTREE_MAP_REGEX,\n+    RustType.STD_RC: STD_RC_REGEX,\n+    RustType.STD_ARC: STD_ARC_REGEX,\n+    RustType.STD_REF: STD_REF_REGEX,\n+    RustType.STD_REF_MUT: STD_REF_MUT_REGEX,\n+    RustType.STD_REF_CELL: STD_REF_CELL_REGEX,\n+    RustType.STD_CELL: STD_CELL_REGEX,\n+}\n+\n+def is_tuple_fields(fields):\n+    # type: (list) -> bool\n+    return all(TUPLE_ITEM_REGEX.match(str(field.name)) for field in fields)\n+\n+\n+def classify_struct(name, fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    for ty, regex in STD_TYPE_TO_REGEX.items():\n+        if regex.match(name):\n+            return ty\n+\n+    if fields[0].name == ENUM_DISR_FIELD_NAME:\n+        return RustType.ENUM\n+\n+    if is_tuple_fields(fields):\n+        return RustType.TUPLE\n+\n+    return RustType.STRUCT\n+\n+\n+def classify_union(fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    first_variant_name = fields[0].name\n+    if first_variant_name is None:\n+        if len(fields) == 1:\n+            return RustType.SINGLETON_ENUM\n+        else:\n+            return RustType.REGULAR_ENUM\n+    elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n+        assert len(fields) == 1\n+        return RustType.COMPRESSED_ENUM\n+    else:\n+        return RustType.REGULAR_UNION"}, {"sha": "fe6fd45f9a5f8f824f73b340bac489330b4ed172", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2.7\n+#!/usr/bin/env python3\n \n \"\"\"\n Testing dec2flt"}, {"sha": "7e67e2b1246ef2f4798fcb374c6cec67b1a31edc", "filename": "src/etc/test-float-parse/u64-pow2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,7 +1,6 @@\n mod _common;\n \n use _common::validate;\n-use std::u64;\n \n fn main() {\n     for exp in 19..64 {"}, {"sha": "914195f015b5a83daf9325285aa6074c61c79dec", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -25,6 +25,7 @@ path = \"../liballoc/tests/lib.rs\"\n [[bench]]\n name = \"collectionsbenches\"\n path = \"../liballoc/benches/lib.rs\"\n+test = true\n \n [[bench]]\n name = \"vec_deque_append_bench\""}, {"sha": "98c7ac3f2ef17cde30f163dfd658c70a0bfeae45", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 92, "deletions": 42, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -2,9 +2,8 @@\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n-use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::intrinsics::{self, min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n-use core::usize;\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -78,7 +77,7 @@ pub struct Global;\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n-    __rust_alloc(layout.size(), layout.align())\n+    unsafe { __rust_alloc(layout.size(), layout.align()) }\n }\n \n /// Deallocate memory with the global allocator.\n@@ -100,7 +99,7 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n-    __rust_dealloc(ptr, layout.size(), layout.align())\n+    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n }\n \n /// Reallocate memory with the global allocator.\n@@ -122,7 +121,7 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-    __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n+    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }\n }\n \n /// Allocate zero-initialized memory with the global allocator.\n@@ -159,54 +158,110 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n-    __rust_alloc_zeroed(layout.size(), layout.align())\n+    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size())) }\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        unsafe {\n+            let size = layout.size();\n+            if size == 0 {\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            } else {\n+                let raw_ptr = match init {\n+                    AllocInit::Uninitialized => alloc(layout),\n+                    AllocInit::Zeroed => alloc_zeroed(layout),\n+                };\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(MemoryBlock { ptr, size })\n+            }\n         }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            dealloc(ptr.as_ptr(), layout)\n+            unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n \n     #[inline]\n-    unsafe fn realloc(\n+    unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        match (layout.size(), new_size) {\n-            (0, 0) => Ok((layout.dangling(), 0)),\n-            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n-            (_, 0) => {\n-                self.dealloc(ptr, layout);\n-                Ok((layout.dangling(), 0))\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if layout.size() == 0 => {\n+                let new_layout =\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+                self.alloc(new_layout, init)\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size > size` or something similar.\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n+                let memory =\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                unsafe {\n+                    init.init_offset(memory, size);\n+                }\n+                Ok(memory)\n             }\n-            (_, _) => NonNull::new(realloc(ptr.as_ptr(), layout, new_size))\n-                .ok_or(AllocErr)\n-                .map(|p| (p, new_size)),\n         }\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe {\n-                NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    unsafe fn shrink(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size <= size,\n+            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if new_size == 0 => {\n+                unsafe {\n+                    self.dealloc(ptr, layout);\n+                }\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size < size` or something similar.\n+                let ptr = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    realloc(ptr.as_ptr(), layout, new_size)\n+                };\n+                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n     }\n@@ -218,14 +273,10 @@ unsafe impl AllocRef for Global {\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    if size == 0 {\n-        align as *mut u8\n-    } else {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match Global.alloc(layout) {\n-            Ok((ptr, _)) => ptr.as_ptr(),\n-            Err(_) => handle_alloc_error(layout),\n-        }\n+    let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n+    match Global.alloc(layout, AllocInit::Uninitialized) {\n+        Ok(memory) => memory.ptr.as_ptr(),\n+        Err(_) => handle_alloc_error(layout),\n     }\n }\n \n@@ -237,12 +288,11 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let size = size_of_val(ptr.as_ref());\n-    let align = min_align_of_val(ptr.as_ref());\n-    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n-    if size != 0 {\n+    unsafe {\n+        let size = size_of_val(ptr.as_ref());\n+        let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr.cast().into(), layout);\n+        Global.dealloc(ptr.cast().into(), layout)\n     }\n }\n "}, {"sha": "1c003983df9892a1c13aef1d7796a9ad36594559", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -8,21 +8,22 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let (ptr, _) =\n-            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory = Global\n+            .alloc(layout.clone(), AllocInit::Zeroed)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = ptr.cast::<u8>().as_ptr();\n+        let mut i = memory.ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(ptr, layout);\n+        Global.dealloc(memory.ptr, layout);\n     }\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = box 10;"}, {"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}, {"sha": "2518506b9b5f3915996f9bc84fbc0f688c1e05af", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -62,6 +62,22 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_100_and_drain_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_100_and_drain_half(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.len(), 100 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n     let src = pos(100);\n@@ -115,6 +131,22 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.len(), 10_000 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n     let src = pos(10_000);"}, {"sha": "f31717d9fd517e76b860364f430e7170d2194822", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,3 +1,4 @@\n+#![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]"}, {"sha": "f1b560b9b968550dea1950fd4bba412e18190f5c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 112, "deletions": 67, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -92,11 +92,13 @@\n //! pub struct Foo;\n //!\n //! #[no_mangle]\n+//! #[allow(improper_ctypes_definitions)]\n //! pub extern \"C\" fn foo_new() -> Box<Foo> {\n //!     Box::new(Foo)\n //! }\n //!\n //! #[no_mangle]\n+//! #[allow(improper_ctypes_definitions)]\n //! pub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n //! ```\n //!\n@@ -143,10 +145,10 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocRef, Global};\n+use crate::alloc::{self, AllocInit, AllocRef, Global};\n+use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;\n@@ -196,14 +198,12 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(ptr.as_ptr())\n-        }\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -226,11 +226,13 @@ impl<T> Box<T> {\n     /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n-        unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(uninit.as_mut_ptr(), 0, 1);\n-            uninit\n-        }\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Zeroed)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n@@ -240,6 +242,16 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+\n+    /// Converts a `Box<T>` into a `Box<[T]>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n+    pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n+        // *mut T and *mut [T; 1] have the same size and alignment\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1]) }\n+    }\n }\n \n impl<T> Box<[T]> {\n@@ -265,15 +277,7 @@ impl<T> Box<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n-        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n-        }\n+        unsafe { RawVec::with_capacity(len).into_box(len) }\n     }\n }\n \n@@ -309,7 +313,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box::from_raw(Box::into_raw(self) as *mut T)\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut T) }\n     }\n }\n \n@@ -347,7 +351,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box::from_raw(Box::into_raw(self) as *mut [T])\n+        unsafe { Box::from_raw(Box::into_raw(self) as *mut [T]) }\n     }\n }\n \n@@ -391,7 +395,7 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        Box(Unique::new_unchecked(raw))\n+        Box(unsafe { Unique::new_unchecked(raw) })\n     }\n \n     /// Consumes the `Box`, returning a wrapped raw pointer.\n@@ -437,7 +441,12 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        Box::into_raw_non_null(b).as_ptr()\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b) as *mut T\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n@@ -460,6 +469,7 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw_non_null(x);\n@@ -469,24 +479,34 @@ impl<T: ?Sized> Box<T> {\n     /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(\n+        since = \"1.44.0\",\n+        reason = \"use `Box::leak(b).into()` or `NonNull::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n-        Box::into_unique(b).into()\n-    }\n-\n-    #[unstable(feature = \"ptr_internals\", issue = \"none\", reason = \"use into_raw_non_null instead\")]\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n+    }\n+\n+    #[unstable(\n+        feature = \"ptr_internals\",\n+        issue = \"none\",\n+        reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     #[doc(hidden)]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        let mut unique = b.0;\n-        mem::forget(b);\n-        // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n-        // Stacked Borrows.  This function here corresponds to \"reborrowing to\n-        // a raw pointer\", but there is no actual reborrow here -- so\n-        // without some care, the pointer we are returning here still carries\n-        // the tag of `b`, with `Unique` permission.\n-        // We round-trip through a mutable reference to avoid that.\n-        unsafe { Unique::new_unchecked(unique.as_mut() as *mut T) }\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -532,7 +552,7 @@ impl<T: ?Sized> Box<T> {\n     where\n         T: 'a, // Technically not needed, but kept to be explicit.\n     {\n-        unsafe { &mut *Box::into_raw(b) }\n+        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n     }\n \n     /// Converts a `Box<T>` into a `Pin<Box<T>>`\n@@ -778,7 +798,18 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n         let buf = RawVec::with_capacity(len);\n         unsafe {\n             ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n-            buf.into_box()\n+            buf.into_box(slice.len()).assume_init()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl<T: Copy> From<Cow<'_, [T]>> for Box<[T]> {\n+    #[inline]\n+    fn from(cow: Cow<'_, [T]>) -> Box<[T]> {\n+        match cow {\n+            Cow::Borrowed(slice) => Box::from(slice),\n+            Cow::Owned(slice) => Box::from(slice),\n         }\n     }\n }\n@@ -801,6 +832,17 @@ impl From<&str> for Box<str> {\n     }\n }\n \n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl From<Cow<'_, str>> for Box<str> {\n+    #[inline]\n+    fn from(cow: Cow<'_, str>) -> Box<str> {\n+        match cow {\n+            Cow::Borrowed(s) => Box::from(s),\n+            Cow::Owned(s) => Box::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n impl From<Box<str>> for Box<[u8]> {\n     /// Converts a `Box<str>>` into a `Box<[u8]>`\n@@ -825,6 +867,25 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[stable(feature = \"box_from_array\", since = \"1.45.0\")]\n+impl<T, const N: usize> From<[T; N]> for Box<[T]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Converts a `[T; N]` into a `Box<[T]>`\n+    ///\n+    /// This conversion moves the array to newly heap-allocated memory.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let boxed: Box<[u8]> = Box::from([4, 2]);\n+    /// println!(\"{:?}\", boxed);\n+    /// ```\n+    fn from(array: [T; N]) -> Box<[T]> {\n+        box array\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n where\n@@ -1050,6 +1111,14 @@ impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n         self.to_vec().into_boxed_slice()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        if self.len() == other.len() {\n+            self.clone_from_slice(&other);\n+        } else {\n+            *self = other.clone();\n+        }\n+    }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]\n@@ -1105,29 +1174,6 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Box<T> {}\n \n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume(Pin::new(&mut *self))\n-    }\n-}\n-\n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume((*self).as_mut())\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n     type Yield = G::Yield;\n@@ -1138,7 +1184,6 @@ impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n     }\n }\n \n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n     type Yield = G::Yield;"}, {"sha": "15313e333ce732a876646d5fe533b77a58f4d0bf", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 70, "deletions": 22, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -1,10 +1,10 @@\n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Insertion and popping the largest element have `O(log(n))` time complexity.\n //! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n //! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n-//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n-//! log n)` in-place heapsort.\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n * log(n))`\n+//! in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -20,7 +20,6 @@\n //! ```\n //! use std::cmp::Ordering;\n //! use std::collections::BinaryHeap;\n-//! use std::usize;\n //!\n //! #[derive(Copy, Clone, Eq, PartialEq)]\n //! struct State {\n@@ -234,9 +233,9 @@ use super::SpecExtend;\n ///\n /// # Time complexity\n ///\n-/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n-/// |--------|----------|--------------------|\n-/// | O(1)~  | O(log n) | O(1)               |\n+/// | [push] | [pop]     | [peek]/[peek\\_mut] |\n+/// |--------|-----------|--------------------|\n+/// | O(1)~  | O(log(n)) | O(1)               |\n ///\n /// The value for `push` is an expected cost; the method documentation gives a\n /// more detailed analysis.\n@@ -399,7 +398,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n@@ -423,8 +422,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n-    /// n).\n+    /// The worst case cost of `pop` on a heap containing *n* elements is `O(log(n))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -457,15 +455,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The expected cost of `push`, averaged over every possible ordering of\n     /// the elements being pushed, and over a sufficiently large number of\n-    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// pushes, is `O(1)`. This is the most meaningful cost metric when pushing\n     /// elements that are *not* already in any sorted pattern.\n     ///\n     /// The time complexity degrades if elements are pushed in predominantly\n     /// ascending order. In the worst case, elements are pushed in ascending\n-    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// sorted order and the amortized cost per push is `O(log(n))` against a heap\n     /// containing *n* elements.\n     ///\n-    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// The worst case cost of a *single* call to `push` is `O(n)`. The worst case\n     /// occurs when capacity is exhausted and needs a resize. The resize cost\n     /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -624,7 +622,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         // `rebuild` takes O(len1 + len2) operations\n         // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // while `extend` takes O(len2 * log(len1)) operations\n         // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n         // assuming len1 >= len2.\n         #[inline]\n@@ -645,7 +643,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// The remaining elements will be removed on drop in heap order.\n     ///\n     /// Note:\n-    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    /// * `.drain_sorted()` is `O(n * log(n))`; much slower than `.drain()`.\n     ///   You should use the latter for most cases.\n     ///\n     /// # Examples\n@@ -667,6 +665,34 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n         DrainSorted { inner: self }\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns\n+    /// `false`. The elements are visited in unsorted (and unspecified) order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_retain)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    ///\n+    /// heap.retain(|x| x % 2 == 0); // only keep even numbers\n+    ///\n+    /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n+    /// ```\n+    #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n+    pub fn retain<F>(&mut self, f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.data.retain(f);\n+        self.rebuild();\n+    }\n }\n \n impl<T> BinaryHeap<T> {\n@@ -730,7 +756,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -977,7 +1003,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n         debug_assert!(pos < data.len());\n         // SAFE: pos should be inside the slice\n-        let elt = ptr::read(data.get_unchecked(pos));\n+        let elt = unsafe { ptr::read(data.get_unchecked(pos)) };\n         Hole { data, elt: ManuallyDrop::new(elt), pos }\n     }\n \n@@ -999,7 +1025,7 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        self.data.get_unchecked(index)\n+        unsafe { self.data.get_unchecked(index) }\n     }\n \n     /// Move hole to new location\n@@ -1009,9 +1035,11 @@ impl<'a, T> Hole<'a, T> {\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n         debug_assert!(index < self.data.len());\n-        let index_ptr: *const _ = self.data.get_unchecked(index);\n-        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n-        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        unsafe {\n+            let index_ptr: *const _ = self.data.get_unchecked(index);\n+            let hole_ptr = self.data.get_unchecked_mut(self.pos);\n+            ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        }\n         self.pos = index;\n     }\n }\n@@ -1243,7 +1271,7 @@ impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n \n         impl<'r, 'a, T: Ord> Drop for DropGuard<'r, 'a, T> {\n             fn drop(&mut self) {\n-                while let Some(_) = self.0.inner.pop() {}\n+                while self.0.inner.pop().is_some() {}\n             }\n         }\n \n@@ -1350,6 +1378,16 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n impl<T: Ord, I: IntoIterator<Item = T>> SpecExtend<I> for BinaryHeap<T> {\n@@ -1380,4 +1418,14 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }"}, {"sha": "34cacebe79636178c61c40dcb02af0d1511b3cfb", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 476, "deletions": 238, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -4,9 +4,10 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n+use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, mem, ptr};\n+use core::{fmt, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n@@ -39,7 +40,7 @@ use UnderflowResult::*;\n /// performance on *small* nodes of elements which are cheap to compare. However in the future we\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n-/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// to take O(B * log(n)) comparisons, which is generally worse than a BST. In practice,\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n@@ -122,7 +123,7 @@ use UnderflowResult::*;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: node::Root<K, V>,\n+    root: Option<node::Root<K, V>>,\n     length: usize,\n }\n \n@@ -147,10 +148,11 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: node::Root::new_leaf(), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let mut out_node = match out_tree.root.as_mut().force() {\n+                        let root = out_tree.root.as_mut().unwrap();\n+                        let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -169,9 +171,14 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n+                    out_tree.ensure_root_is_owned();\n \n                     {\n-                        let mut out_node = out_tree.root.push_level();\n+                        // Ideally we'd use the return of ensure_root_is_owned\n+                        // instead of re-unwrapping here but unfortunately that\n+                        // borrows all of out_tree and we need access to the\n+                        // length below.\n+                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -184,13 +191,13 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                             // We can't destructure subtree directly\n                             // because BTreeMap implements Drop\n                             let (subroot, sublength) = unsafe {\n+                                let subtree = ManuallyDrop::new(subtree);\n                                 let root = ptr::read(&subtree.root);\n                                 let length = subtree.length;\n-                                mem::forget(subtree);\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot);\n+                            out_node.push(k, v, subroot.unwrap_or_else(node::Root::new_leaf));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -203,64 +210,11 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n-            BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+            BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n-\n-    fn clone_from(&mut self, other: &Self) {\n-        BTreeClone::clone_from(self, other);\n-    }\n-}\n-\n-trait BTreeClone {\n-    fn clone_from(&mut self, other: &Self);\n-}\n-\n-impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    default fn clone_from(&mut self, other: &Self) {\n-        *self = other.clone();\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    fn clone_from(&mut self, other: &Self) {\n-        // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists.\n-        let split_off_key = if self.len() > other.len() {\n-            let diff = self.len() - other.len();\n-            if diff <= other.len() {\n-                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n-            } else {\n-                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n-            }\n-        } else {\n-            None\n-        };\n-        if let Some(key) = split_off_key {\n-            self.split_off(&key);\n-        }\n-\n-        let mut siter = self.range_mut(..);\n-        let mut oiter = other.iter();\n-        // After truncation, `self` is at most as long as `other` so this loop\n-        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n-        // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop.\n-        while !siter.is_empty() {\n-            if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because `siter` is nonempty.\n-                let (sk, sv) = unsafe { siter.next_unchecked() };\n-                sk.clone_from(ok);\n-                sv.clone_from(ov);\n-            } else {\n-                break;\n-            }\n-        }\n-        // If `other` is longer than `self`, the remaining elements are inserted.\n-        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n-    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -271,14 +225,14 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -290,7 +244,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -344,15 +298,18 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n     length: usize,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -417,8 +374,8 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -437,8 +394,8 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -447,7 +404,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -528,7 +488,9 @@ struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n-    /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    /// Makes a new empty BTreeMap.\n+    ///\n+    /// Does not allocate anything on its own.\n     ///\n     /// # Examples\n     ///\n@@ -543,8 +505,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// map.insert(1, \"a\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeMap<K, V> {\n+        BTreeMap { root: None, length: 0 }\n     }\n \n     /// Clears the map, removing all elements.\n@@ -589,7 +552,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -616,7 +579,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), k) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -640,12 +603,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n-        let front = self.root.as_ref().first_leaf_edge();\n+    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n+        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -654,7 +613,38 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// if let Some(mut entry) = map.first_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"first\");\n+    ///     }\n+    /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"first\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n+        let kv = front.right_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the first element in the map.\n+    /// The key of this element is the minimum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in ascending order, while keeping a usable map each iteration.\n     ///\n     /// ```\n     /// #![feature(map_first_last)]\n@@ -663,27 +653,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.first_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// while let Some((key, _val)) = map.pop_first() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k > key));\n     /// }\n+    /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n-        let front = self.root.as_mut().first_leaf_edge();\n-        if let Ok(kv) = front.right_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+        self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns the last key-value pair in the map.\n@@ -703,12 +680,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n-        let back = self.root.as_ref().last_leaf_edge();\n+    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n+        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -717,7 +690,38 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// if let Some(mut entry) = map.last_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"last\");\n+    ///     }\n+    /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"a\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n+        let kv = back.left_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the last element in the map.\n+    /// The key of this element is the maximum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in descending order, while keeping a usable map each iteration.\n     ///\n     /// ```\n     /// #![feature(map_first_last)]\n@@ -726,27 +730,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.last_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// while let Some((key, _val)) = map.pop_last() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k < key));\n     /// }\n+    /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n-        let back = self.root.as_mut().last_leaf_edge();\n-        if let Ok(kv) = back.left_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+        self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns `true` if the map contains a value for the specified key.\n@@ -801,7 +792,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n             GoDown(_) => None,\n         }\n@@ -882,21 +873,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btreemap_remove_entry)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n     /// assert_eq!(map.remove_entry(&1), None);\n     /// ```\n-    #[unstable(feature = \"btreemap_remove_entry\", issue = \"66714\")]\n+    #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -992,11 +982,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_ref();\n-        let root2 = self.root.as_ref();\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &self.root {\n+            let (f, b) = range_search(root.as_ref(), range);\n \n-        Range { front: f, back: b }\n+            Range { front: Some(f), back: Some(b) }\n+        } else {\n+            Range { front: None, back: None }\n+        }\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -1036,11 +1028,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = range_search(root.as_mut(), range);\n \n-        RangeMut { front: f, back: b, _marker: PhantomData }\n+            RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n+        } else {\n+            RangeMut { front: None, back: None, _marker: PhantomData }\n+        }\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1065,7 +1059,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut(), &key) {\n+        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1077,7 +1071,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1126,7 +1120,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(&mut self) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1187,14 +1181,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n-        right.root = node::Root::new_leaf();\n-        for _ in 0..(self.root.as_ref().height()) {\n-            right.root.push_level();\n+        let right_root = right.ensure_root_is_owned();\n+        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+            right_root.push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut();\n-            let mut right_node = right.root.as_mut();\n+            let mut left_node = self.root.as_mut().unwrap().as_mut();\n+            let mut right_node = right.root.as_mut().unwrap().as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1223,7 +1217,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_right_border();\n         right.fix_left_border();\n \n-        if self.root.as_ref().height() < right.root.as_ref().height() {\n+        if self.root.as_ref().unwrap().as_ref().height()\n+            < right.root.as_ref().unwrap().as_ref().height()\n+        {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1234,6 +1230,48 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let odds = map;\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.drain_filter_inner() }\n+    }\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+    }\n+\n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n         fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n@@ -1261,27 +1299,27 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n \n     /// Removes empty levels on the top.\n     fn fix_top(&mut self) {\n         loop {\n             {\n-                let node = self.root.as_ref();\n+                let node = self.root.as_ref().unwrap().as_ref();\n                 if node.height() == 0 || node.len() > 0 {\n                     break;\n                 }\n             }\n-            self.root.pop_level();\n+            self.root.as_mut().unwrap().pop_level();\n         }\n     }\n \n     fn fix_right_border(&mut self) {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -1307,7 +1345,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -1326,13 +1364,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n-\n-    /// If the root node is the shared root node, allocate our own node.\n-    fn ensure_root_is_owned(&mut self) {\n-        if self.root.is_shared_root() {\n-            self.root = node::Root::new_leaf();\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,12 +1489,14 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        let root1 = unsafe { ptr::read(&self.root).into_ref() };\n-        let root2 = unsafe { ptr::read(&self.root).into_ref() };\n-        let len = self.length;\n-        mem::forget(self);\n+        let mut me = ManuallyDrop::new(self);\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n \n-        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n+        } else {\n+            IntoIter { front: None, back: None, length: 0 }\n+        }\n     }\n }\n \n@@ -1478,9 +1511,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n                 // don't have to care about panics this time (they'll abort).\n                 while let Some(_) = self.0.next() {}\n \n-                // No need to avoid the shared root, because the tree was definitely not empty.\n                 unsafe {\n-                    let mut node = ptr::read(&self.0.front).into_node().forget_type();\n+                    let mut node =\n+                        unwrap_unchecked(ptr::read(&self.0.front)).into_node().forget_type();\n                     while let Some(parent) = node.deallocate_and_ascend() {\n                         node = parent.into_node().forget_type();\n                     }\n@@ -1495,14 +1528,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n         }\n \n         unsafe {\n-            let mut node = ptr::read(&self.front).into_node().forget_type();\n-            if node.is_shared_root() {\n-                return;\n-            }\n-            // Most of the nodes have been deallocated while traversing\n-            // but one pile from a leaf up to the root is left standing.\n-            while let Some(parent) = node.deallocate_and_ascend() {\n-                node = parent.into_node().forget_type();\n+            if let Some(front) = ptr::read(&self.front) {\n+                let mut node = front.into_node().forget_type();\n+                // Most of the nodes have been deallocated while traversing\n+                // but one pile from a leaf up to the root is left standing.\n+                while let Some(parent) = node.deallocate_and_ascend() {\n+                    node = parent.into_node().forget_type();\n+                }\n             }\n         }\n     }\n@@ -1517,7 +1549,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.front.next_unchecked() })\n+            Some(unsafe { self.front.as_mut().unwrap().next_unchecked() })\n         }\n     }\n \n@@ -1533,7 +1565,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.back.next_back_unchecked() })\n+            Some(unsafe { self.back.as_mut().unwrap().next_back_unchecked() })\n         }\n     }\n }\n@@ -1630,6 +1662,101 @@ impl<K, V> Clone for Values<'_, K, V> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeMap.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    K: 'a,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    pred: F,\n+    inner: DrainFilterInner<'a, K, V>,\n+}\n+pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n+    length: &'a mut usize,\n+    cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> Drop for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> fmt::Debug for DrainFilter<'_, K, V, F>\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next(&mut self.pred)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n+    /// Allow Debug implementations to predict the next element.\n+    pub(super) fn peek(&self) -> Option<(&K, &V)> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n+    }\n+\n+    unsafe fn next_kv(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        unsafe { ptr::read(edge).next_kv().ok() }\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        while let Some(mut kv) = unsafe { self.next_kv() } {\n+            let (k, v) = kv.kv_mut();\n+            if pred(k, v) {\n+                *self.length -= 1;\n+                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(leaf_edge_location);\n+                return Some((k, v));\n+            }\n+            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n+        }\n+        None\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(*self.length))\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -1683,7 +1810,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.front.next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1696,7 +1823,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.back.next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n \n@@ -1734,7 +1861,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.front.next_unchecked()\n+        unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n \n@@ -1755,7 +1882,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.back.next_back_unchecked()\n+        unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n \n@@ -1776,13 +1903,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n             self.insert(k, v);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1854,9 +1991,9 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n-    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n ) -> (\n     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n@@ -1870,19 +2007,16 @@ where\n         (Excluded(s), Excluded(e)) if s == e => {\n             panic!(\"range start and end are equal and excluded in BTreeMap\")\n         }\n-        (Included(s), Included(e))\n-        | (Included(s), Excluded(e))\n-        | (Excluded(s), Included(e))\n-        | (Excluded(s), Excluded(e))\n-            if s > e =>\n-        {\n+        (Included(s) | Excluded(s), Included(e) | Excluded(e)) if s > e => {\n             panic!(\"range start is greater than range end in BTreeMap\")\n         }\n         _ => {}\n     };\n \n-    let mut min_node = root1;\n-    let mut max_node = root2;\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n     let mut min_found = false;\n     let mut max_found = false;\n \n@@ -1943,6 +2077,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -1967,12 +2128,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().first_leaf_edge(),\n-                back: self.root.as_ref().last_leaf_edge(),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -1999,15 +2160,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n-        IterMut {\n-            range: RangeMut {\n-                front: root1.first_leaf_edge(),\n-                back: root2.last_leaf_edge(),\n-                _marker: PhantomData,\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n \n@@ -2116,6 +2277,12 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// If the root node is the empty (non-allocated) root node, allocate our\n+    /// own node.\n+    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n+        self.root.get_or_insert_with(node::Root::new_leaf)\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n@@ -2163,6 +2330,34 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n         }\n     }\n \n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n     /// Returns a reference to this entry's key.\n     ///\n     /// # Examples\n@@ -2282,15 +2477,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n     ///\n-    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n     ///\n-    /// // count the number of occurrences of letters in the vec\n-    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n-    ///     *count.entry(x).or_insert(0) += 1;\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n     /// }\n-    ///\n-    /// assert_eq!(count[\"a\"], 3);\n+    /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n@@ -2498,85 +2692,129 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n+        (old_key, old_val)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair.\n+    fn remove_kv_tracking(\n+        self,\n+    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, false)\n             }\n             Internal(mut internal) => {\n+                // Replace the location freed in the internal node with the next KV,\n+                // and remove that next KV from its leaf.\n+\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n+                // Deleting from the left side is typically faster since we can\n+                // just pop an element from the end of the KV array without\n+                // needing to shift the other values.\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();\n \n                 let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n                 let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut cur_node = small_leaf.forget_type();\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n-                EmptyParent(_) => unreachable!(),\n-                Merged(parent) => {\n+                Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            Leaf(leaf) => leaf,\n+                            Internal(_) => unreachable!(),\n+                        };\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n                     if parent.len() == 0 {\n                         // We must be at the root\n                         parent.into_root_mut().pop_level();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n+                        at_leaf = false;\n+                    }\n+                }\n+                Stole(stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.next_unchecked();\n+                        }\n                     }\n+                    break;\n                 }\n-                Stole(_) => break,\n             }\n         }\n \n-        (old_key, old_val)\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_key, old_val, pos)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n     AtRoot,\n-    EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(bool),\n }\n \n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n-    let parent = if let Ok(parent) = node.ascend() {\n-        parent\n-    } else {\n-        return AtRoot;\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(_) => return AtRoot,\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => match parent.right_kv() {\n-            Ok(right) => (false, right),\n-            Err(parent) => {\n-                return EmptyParent(parent.into_node());\n-            }\n-        },\n+        Err(parent) => {\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n+        }\n     };\n \n     if handle.can_merge() {\n-        Merged(handle.merge().into_node())\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        Merged(handle.merge(), is_left, offset)\n     } else {\n         if is_left {\n             handle.steal_left();\n         } else {\n             handle.steal_right();\n         }\n-        Stole(handle.into_node())\n+        Stole(is_left)\n     }\n }\n "}, {"sha": "543ff41a4d48d55fc2b4616f39a8a17cc69c2a87", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -19,7 +19,9 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n         if cfg!(debug_assertions) {\n             panic!(\"'unchecked' unwrap on None in BTreeMap\");\n         } else {\n-            core::intrinsics::unreachable();\n+            unsafe {\n+                core::intrinsics::unreachable();\n+            }\n         }\n     })\n }"}, {"sha": "5478d822438b1ca3afd2f169f7d50422147dbd52", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -64,8 +64,10 @@ macro_rules! def_next_kv_uncheched_dealloc {\n                 edge = match edge.$adjacent_kv() {\n                     Ok(internal_kv) => return internal_kv,\n                     Err(last_edge) => {\n-                        let parent_edge = last_edge.into_node().deallocate_and_ascend();\n-                        unwrap_unchecked(parent_edge).forget_node_type()\n+                        unsafe {\n+                            let parent_edge = last_edge.into_node().deallocate_and_ascend();\n+                            unwrap_unchecked(parent_edge).forget_node_type()\n+                        }\n                     }\n                 }\n             }\n@@ -82,9 +84,11 @@ def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_k\n /// Safety: The change closure must not panic.\n #[inline]\n unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n-    let value = ptr::read(v);\n+    let value = unsafe { ptr::read(v) };\n     let (new_value, ret) = change(value);\n-    ptr::write(v, new_value);\n+    unsafe {\n+        ptr::write(v, new_value);\n+    }\n     ret\n }\n \n@@ -93,22 +97,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (kv.next_back_leaf_edge(), kv.into_kv())\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (kv.next_back_leaf_edge(), kv.into_kv())\n+            })\n+        }\n     }\n }\n \n@@ -119,14 +127,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n@@ -135,14 +145,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let kv = replace(self, |leaf_edge| {\n-            let kv = leaf_edge.next_back_kv();\n-            let kv = unwrap_unchecked(kv.ok());\n-            (ptr::read(&kv).next_back_leaf_edge(), kv)\n-        });\n-        // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        unsafe {\n+            let kv = replace(self, |leaf_edge| {\n+                let kv = leaf_edge.next_back_kv();\n+                let kv = unwrap_unchecked(kv.ok());\n+                (ptr::read(&kv).next_back_leaf_edge(), kv)\n+            });\n+            // Doing the descend (and perhaps another move) invalidates the references\n+            // returned by `into_kv_mut`, so we have to do this last.\n+            kv.into_kv_mut()\n+        }\n     }\n }\n \n@@ -159,12 +171,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -179,12 +193,14 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        replace(self, |leaf_edge| {\n-            let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n-            let k = ptr::read(kv.reborrow().into_kv().0);\n-            let v = ptr::read(kv.reborrow().into_kv().1);\n-            (kv.next_back_leaf_edge(), (k, v))\n-        })\n+        unsafe {\n+            replace(self, |leaf_edge| {\n+                let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n+                let k = ptr::read(kv.reborrow().into_kv().0);\n+                let v = ptr::read(kv.reborrow().into_kv().1);\n+                (kv.next_back_leaf_edge(), (k, v))\n+            })\n+        }\n     }\n }\n "}, {"sha": "a4b6cf12a23bd92671d30db8cdc4eaa8b293aeed", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 104, "deletions": 172, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -44,34 +44,7 @@ const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n \n-/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n-/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n-/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n-/// case.\n-///\n-/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n-/// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n-/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n-/// by `as_header`.)\n-#[repr(C)]\n-struct NodeHeader<K, V> {\n-    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n-    /// This either points to an actual node or is null.\n-    parent: *const InternalNode<K, V>,\n-\n-    /// This node's index into the parent node's `edges` array.\n-    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n-    /// This is only guaranteed to be initialized when `parent` is non-null.\n-    parent_idx: MaybeUninit<u16>,\n-\n-    /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n-    len: u16,\n-}\n+/// The underlying representation of leaf nodes.\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -111,21 +84,6 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-impl<K, V> NodeHeader<K, V> {\n-    fn is_shared_root(&self) -> bool {\n-        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n-    }\n-}\n-\n-// We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for NodeHeader<(), ()> {}\n-\n-// An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use just a header in order to save space, since no operation on an empty tree will\n-// ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n-\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -149,17 +107,14 @@ impl<K, V> InternalNode<K, V> {\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n     unsafe fn new() -> Self {\n-        InternalNode { data: LeafNode::new(), edges: [MaybeUninit::UNINIT; 2 * B] }\n+        InternalNode { data: unsafe { LeafNode::new() }, edges: [MaybeUninit::UNINIT; 2 * B] }\n     }\n }\n \n /// A managed, non-null pointer to a node. This is either an owned pointer to\n-/// `LeafNode<K, V>`, an owned pointer to `InternalNode<K, V>`, or a (not owned)\n-/// pointer to `NodeHeader<(), ()` (more specifically, the pointer to EMPTY_ROOT_NODE).\n-/// All of these types have a `NodeHeader<K, V>` prefix, meaning that they have at\n-/// least the same size as `NodeHeader<K, V>` and store the same kinds of data at the same\n-/// offsets; and they have a pointer alignment at least as large as `NodeHeader<K, V>`'s.\n-/// However, `BoxedNode` contains no information as to which of the three types\n+/// `LeafNode<K, V>` or an owned pointer to `InternalNode<K, V>`.\n+///\n+/// However, `BoxedNode` contains no information as to which of the two types\n /// of nodes it actually contains, and, partially due to this lack of information,\n /// has no destructor.\n struct BoxedNode<K, V> {\n@@ -176,16 +131,17 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(ptr) }\n+        BoxedNode { ptr: unsafe { Unique::new_unchecked(ptr.as_ptr()) } }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n         NonNull::from(self.ptr)\n     }\n }\n \n-/// Either an owned tree or a shared, empty tree.  Note that this does not have a destructor,\n-/// and must be cleaned up manually if it is an owned tree.\n+/// An owned tree.\n+///\n+/// Note that this does not have a destructor, and must be cleaned up manually.\n pub struct Root<K, V> {\n     node: BoxedNode<K, V>,\n     /// The number of levels below the root node.\n@@ -196,20 +152,6 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n-    /// Whether the instance of `Root` wraps a shared, empty root node. If not,\n-    /// the entire tree is uniquely owned by the owner of the `Root` instance.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_ref().is_shared_root()\n-    }\n-\n-    /// Returns a shared tree, wrapping a shared root node that is eternally empty.\n-    pub fn shared_empty_root() -> Self {\n-        Root {\n-            node: unsafe { BoxedNode::from_ptr(NonNull::from(&EMPTY_ROOT_NODE).cast()) },\n-            height: 0,\n-        }\n-    }\n-\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n@@ -219,7 +161,7 @@ impl<K, V> Root<K, V> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n-            root: self as *const _ as *mut _,\n+            root: ptr::null(),\n             _marker: PhantomData,\n         }\n     }\n@@ -237,15 +179,14 @@ impl<K, V> Root<K, V> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n-            root: ptr::null_mut(), // FIXME: Is there anything better to do here?\n+            root: ptr::null(),\n             _marker: PhantomData,\n         }\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -308,11 +249,6 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!\n-///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n-///   Shared references must be dereferenceable *for the entire size of their pointee*,\n-///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n-///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node.\n     height: usize,\n@@ -354,7 +290,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Note that, despite being safe, calling this function can have the side effect\n     /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n-        self.as_header().len as usize\n+        self.as_leaf().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -374,35 +310,24 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// Unsafe because the node must not be the shared root. For more information,\n-    /// see the `NodeRef` comments.\n-    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n-        debug_assert!(!self.is_shared_root());\n-        self.node.as_ref()\n-    }\n-\n-    fn as_header(&self) -> &NodeHeader<K, V> {\n-        unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n-    }\n-\n-    /// Returns whether the node is the shared, empty root.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_header().is_shared_root()\n+    fn as_leaf(&self) -> &LeafNode<K, V> {\n+        // The node must be valid for at least the LeafNode portion.\n+        // This is not a reference in the NodeRef type because we don't know if\n+        // it should be unique or shared.\n+        unsafe { self.node.as_ref() }\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    pub unsafe fn keys(&self) -> &[K] {\n+    pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals(&self) -> &[V] {\n+    fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -416,7 +341,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n-        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -425,7 +350,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData,\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n+                idx: unsafe { usize::from(*self.as_leaf().parent_idx.as_ptr()) },\n                 _marker: PhantomData,\n             })\n         } else {\n@@ -464,18 +389,19 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        assert!(!self.is_shared_root());\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(\n-            node.cast(),\n-            if height > 0 {\n-                Layout::new::<InternalNode<K, V>>()\n-            } else {\n-                Layout::new::<LeafNode<K, V>>()\n-            },\n-        );\n+        unsafe {\n+            Global.dealloc(\n+                node.cast(),\n+                if height > 0 {\n+                    Layout::new::<InternalNode<K, V>>()\n+                } else {\n+                    Layout::new::<LeafNode<K, V>>()\n+                },\n+            );\n+        }\n         ret\n     }\n }\n@@ -507,41 +433,37 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// (header, keys and values), and this function exposes that.\n     ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n-    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n-    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n         self.node.as_ptr()\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn keys_mut(&mut self) -> &mut [K] {\n-        self.reborrow_mut().into_key_slice_mut()\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals_mut(&mut self) -> &mut [V] {\n-        self.reborrow_mut().into_val_slice_mut()\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice(self) -> &'a [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n+    fn into_key_slice(self) -> &'a [K] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice(self) -> &'a [V] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n+    fn into_val_slice(self) -> &'a [V] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = ptr::read(&self);\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n+        let k = unsafe { ptr::read(&self) };\n         (k.into_key_slice(), self.into_val_slice())\n     }\n }\n@@ -553,37 +475,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-            self.len(),\n-        )\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        debug_assert!(!self.is_shared_root());\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-            self.len(),\n-        )\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        debug_assert!(!self.is_shared_root());\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n         let len = self.len();\n         let leaf = self.as_leaf_mut();\n-        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        // SAFETY: The keys and values of a node must always be initialized up to length.\n+        let keys = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len)\n+        };\n+        let vals = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+        };\n         (keys, vals)\n     }\n }\n@@ -592,7 +518,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -607,7 +532,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -624,7 +548,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -644,7 +567,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         debug_assert!(first <= self.len());\n         debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n+            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n         }\n     }\n \n@@ -658,7 +581,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -744,8 +666,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -804,6 +725,11 @@ impl<Node, Type> Handle<Node, Type> {\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n+\n+    /// Returns the position of this handle in the node.\n+    pub fn idx(&self) -> usize {\n+        self.idx\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n@@ -865,7 +791,7 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n-        Handle { node: self.node.reborrow_mut(), idx: self.idx, _marker: PhantomData }\n+        Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n }\n \n@@ -904,7 +830,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n-        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -962,7 +887,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     unsafe fn cast_unchecked<NewType>(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-        Handle::new_edge(self.node.cast_unchecked(), self.idx)\n+        unsafe { Handle::new_edge(self.node.cast_unchecked(), self.idx) }\n     }\n \n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n@@ -1081,7 +1006,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1113,7 +1037,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n@@ -1226,7 +1149,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n-            if self.node.height > 1 {\n+            let layout = if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n                     right_node.cast_unchecked().as_internal().edges.as_ptr(),\n                     left_node\n@@ -1243,10 +1166,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                         .correct_parent_link();\n                 }\n \n-                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                Layout::new::<InternalNode<K, V>>()\n             } else {\n-                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n-            }\n+                Layout::new::<LeafNode<K, V>>()\n+            };\n+            Global.dealloc(right_node.node.cast(), layout);\n \n             Handle::new_edge(self.node, self.idx)\n         }\n@@ -1408,8 +1332,10 @@ unsafe fn move_kv<K, V>(\n     dest_offset: usize,\n     count: usize,\n ) {\n-    ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n-    ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source.0.add(source_offset), dest.0.add(dest_offset), count);\n+        ptr::copy_nonoverlapping(source.1.add(source_offset), dest.1.add(dest_offset), count);\n+    }\n }\n \n // Source and destination must have the same height.\n@@ -1422,8 +1348,10 @@ unsafe fn move_edges<K, V>(\n ) {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n-    ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n-    dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    unsafe {\n+        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n+        dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+    }\n }\n \n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n@@ -1537,12 +1465,16 @@ pub mod marker {\n }\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n-    ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n-    ptr::write(slice.get_unchecked_mut(idx), val);\n+    unsafe {\n+        ptr::copy(slice.as_ptr().add(idx), slice.as_mut_ptr().add(idx + 1), slice.len() - idx);\n+        ptr::write(slice.get_unchecked_mut(idx), val);\n+    }\n }\n \n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n-    let ret = ptr::read(slice.get_unchecked(idx));\n-    ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n-    ret\n+    unsafe {\n+        let ret = ptr::read(slice.get_unchecked(idx));\n+        ptr::copy(slice.as_ptr().add(idx + 1), slice.as_mut_ptr().add(idx), slice.len() - idx - 1);\n+        ret\n+    }\n }"}, {"sha": "4e80f7f21ebff5c6817a82f9e9436acf3ea5d9d2", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -67,19 +67,16 @@ where\n     Q: Ord,\n     K: Borrow<Q>,\n {\n-    // This function is defined over all borrow types (immutable, mutable, owned),\n-    // and may be called on the shared root in each case.\n+    // This function is defined over all borrow types (immutable, mutable, owned).\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    if len > 0 {\n-        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n-        for (i, k) in keys.iter().enumerate() {\n-            match key.cmp(k.borrow()) {\n-                Ordering::Greater => {}\n-                Ordering::Equal => return (i, true),\n-                Ordering::Less => return (i, false),\n-            }\n+    let keys = node.keys();\n+    for (i, k) in keys.iter().enumerate() {\n+        match key.cmp(k.borrow()) {\n+            Ordering::Greater => {}\n+            Ordering::Equal => return (i, true),\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (len, false)"}, {"sha": "525ef38c32fa269f2e31fefbbb3074a85bc9548a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 103, "deletions": 4, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -8,8 +8,8 @@ use core::fmt::{self, Debug};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n+use super::map::{BTreeMap, Keys};\n use super::Recover;\n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -102,7 +102,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: btree_map::IntoIter<T, ()>,\n+    iter: super::map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -115,7 +115,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: btree_map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, ()>,\n }\n \n /// Core of SymmetricDifference and Union.\n@@ -309,7 +309,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// let mut set: BTreeSet<i32> = BTreeSet::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeSet<T> {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -944,6 +945,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<i32> = (0..8).collect();\n+    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let odds = set;\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    where\n+        F: 'a + FnMut(&T) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+    }\n }\n \n impl<T> BTreeSet<T> {\n@@ -1055,6 +1091,59 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeSet.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, T, F>\n+where\n+    T: 'a,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    pred: F,\n+    inner: super::map::DrainFilterInner<'a, T, ()>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> Drop for DrainFilter<'_, T, F>\n+where\n+    F: FnMut(&T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> fmt::Debug for DrainFilter<'_, T, F>\n+where\n+    T: fmt::Debug,\n+    F: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> Iterator for DrainFilter<'_, T, F>\n+where\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let pred = &mut self.pred;\n+        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> FusedIterator for DrainFilter<'_, T, F> where F: FnMut(&T) -> bool {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n@@ -1063,13 +1152,23 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n             self.insert(elem);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "36b5785fdf6c5ed930340eb4b38d772d7dd21f4a", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 98, "deletions": 31, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -143,7 +143,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.head {\n                 None => self.tail = node,\n@@ -184,7 +184,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.tail {\n                 None => self.head = node,\n@@ -225,17 +225,17 @@ impl<T> LinkedList<T> {\n     /// maintain validity of aliasing pointers.\n     #[inline]\n     unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n-        let node = node.as_mut(); // this one is ours now, we can create an &mut.\n+        let node = unsafe { node.as_mut() }; // this one is ours now, we can create an &mut.\n \n         // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(prev) => (*prev.as_ptr()).next = node.next,\n+            Some(prev) => unsafe { (*prev.as_ptr()).next = node.next },\n             // this node is the head node\n             None => self.head = node.next,\n         };\n \n         match node.next {\n-            Some(next) => (*next.as_ptr()).prev = node.prev,\n+            Some(next) => unsafe { (*next.as_ptr()).prev = node.prev },\n             // this node is the tail node\n             None => self.tail = node.prev,\n         };\n@@ -258,17 +258,23 @@ impl<T> LinkedList<T> {\n         // This method takes care not to create multiple mutable references to whole nodes at the same time,\n         // to maintain validity of aliasing pointers into `element`.\n         if let Some(mut existing_prev) = existing_prev {\n-            existing_prev.as_mut().next = Some(splice_start);\n+            unsafe {\n+                existing_prev.as_mut().next = Some(splice_start);\n+            }\n         } else {\n             self.head = Some(splice_start);\n         }\n         if let Some(mut existing_next) = existing_next {\n-            existing_next.as_mut().prev = Some(splice_end);\n+            unsafe {\n+                existing_next.as_mut().prev = Some(splice_end);\n+            }\n         } else {\n             self.tail = Some(splice_end);\n         }\n-        splice_start.as_mut().prev = existing_prev;\n-        splice_end.as_mut().next = existing_next;\n+        unsafe {\n+            splice_start.as_mut().prev = existing_prev;\n+            splice_end.as_mut().next = existing_next;\n+        }\n \n         self.len += splice_length;\n     }\n@@ -297,9 +303,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let first_part_head;\n             let first_part_tail;\n-            first_part_tail = split_node.as_mut().prev.take();\n+            unsafe {\n+                first_part_tail = split_node.as_mut().prev.take();\n+            }\n             if let Some(mut tail) = first_part_tail {\n-                tail.as_mut().next = None;\n+                unsafe {\n+                    tail.as_mut().next = None;\n+                }\n                 first_part_head = self.head;\n             } else {\n                 first_part_head = None;\n@@ -333,9 +343,13 @@ impl<T> LinkedList<T> {\n         if let Some(mut split_node) = split_node {\n             let second_part_head;\n             let second_part_tail;\n-            second_part_head = split_node.as_mut().next.take();\n+            unsafe {\n+                second_part_head = split_node.as_mut().next.take();\n+            }\n             if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n+                unsafe {\n+                    head.as_mut().prev = None;\n+                }\n                 second_part_tail = self.tail;\n             } else {\n                 second_part_tail = None;\n@@ -390,7 +404,7 @@ impl<T> LinkedList<T> {\n     /// This reuses all the nodes from `other` and moves them into `self`. After\n     /// this operation, `other` becomes empty.\n     ///\n-    /// This operation should compute in O(1) time and O(1) memory.\n+    /// This operation should compute in `O(1)` time and `O(1)` memory.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +561,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -568,7 +582,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns the length of the `LinkedList`.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -594,7 +608,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes all elements from the `LinkedList`.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Examples\n     ///\n@@ -737,7 +751,7 @@ impl<T> LinkedList<T> {\n \n     /// Adds an element first in the list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -760,7 +774,7 @@ impl<T> LinkedList<T> {\n     /// Removes the first element and returns it, or `None` if the list is\n     /// empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -783,7 +797,7 @@ impl<T> LinkedList<T> {\n \n     /// Appends an element to the back of a list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -803,7 +817,7 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -824,7 +838,7 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     ///\n@@ -880,7 +894,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes the element at the given index and returns it.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     /// Panics if at >= len\n@@ -972,7 +986,7 @@ unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n             fn drop(&mut self) {\n                 // Continue the same loop we do below. This only runs when a destructor has\n                 // panicked. If another one panics this will abort.\n-                while let Some(_) = self.0.pop_front_node() {}\n+                while self.0.pop_front_node().is_some() {}\n             }\n         }\n \n@@ -1133,11 +1147,9 @@ impl<T> IterMut<'_, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Box::into_raw_non_null(box Node {\n-                    next: Some(head),\n-                    prev: Some(prev),\n-                    element,\n-                }));\n+                let node = Some(\n+                    Box::leak(box Node { next: Some(head), prev: Some(prev), element }).into(),\n+                );\n \n                 // Not creating references to entire nodes to not invalidate the\n                 // reference to `element` we handed to the user.\n@@ -1197,6 +1209,14 @@ pub struct Cursor<'a, T: 'a> {\n     list: &'a LinkedList<T>,\n }\n \n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T> Clone for Cursor<'_, T> {\n+    fn clone(&self) -> Self {\n+        let Cursor { index, current, list } = *self;\n+        Cursor { index, current, list }\n+    }\n+}\n+\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1442,7 +1462,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_after(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_next = match self.current {\n                 None => self.list.head,\n                 Some(node) => node.as_ref().next,\n@@ -1462,7 +1482,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_before(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_prev = match self.current {\n                 None => self.list.tail,\n                 Some(node) => node.as_ref().prev,\n@@ -1490,6 +1510,31 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n+    /// Removes the current element from the `LinkedList` without deallocating the list node.\n+    ///\n+    /// The node that was removed is returned as a new `LinkedList` containing only this node.\n+    /// The cursor is moved to point to the next element in the current `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T>> {\n+        let mut unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+\n+            unlinked_node.as_mut().prev = None;\n+            unlinked_node.as_mut().next = None;\n+            Some(LinkedList {\n+                head: Some(unlinked_node),\n+                tail: Some(unlinked_node),\n+                len: 1,\n+                marker: PhantomData,\n+            })\n+        }\n+    }\n+\n     /// Inserts the elements from the given `LinkedList` after the current one.\n     ///\n     /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n@@ -1717,6 +1762,11 @@ impl<T> Extend<T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.push_back(elem);\n+    }\n }\n \n impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n@@ -1736,6 +1786,11 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.push_back(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1835,3 +1890,15 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Send for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Send> Send for CursorMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for CursorMut<'_, T> {}"}, {"sha": "b8c93a28bba815a1bfa38fea9a49e581a335c13f", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -182,7 +182,6 @@ fn test_insert_prev() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {"}, {"sha": "15f3a94ca2d6a84d1dc270114de33daddaa15efc", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 259, "deletions": 99, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50", "patch": "@@ -7,12 +7,14 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// ignore-tidy-filelength\n+\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n-use core::mem::{self, replace};\n+use core::mem::{self, replace, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -50,6 +52,7 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of\n /// [`pop_front`]: #method.pop_front\n /// [`extend`]: #method.extend\n /// [`append`]: #method.append\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n@@ -72,7 +75,7 @@ pub struct VecDeque<T> {\n /// It produces the following sequence of matching slices:\n ///\n /// ([0 1], [a b])\n-/// ([2], [c])\n+/// (\\[2\\], \\[c\\])\n /// ([3 4], [d e])\n ///\n /// and the uneven remainder of either A or B is skipped.\n@@ -200,25 +203,27 @@ impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        slice::from_raw_parts(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts(self.ptr(), self.cap()) }\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        slice::from_raw_parts_mut(self.ptr(), self.cap())\n+        unsafe { slice::from_raw_parts_mut(self.ptr(), self.cap()) }\n     }\n \n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n-        ptr::read(self.ptr().add(off))\n+        unsafe { ptr::read(self.ptr().add(off)) }\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n     unsafe fn buffer_write(&mut self, off: usize, value: T) {\n-        ptr::write(self.ptr().add(off), value);\n+        unsafe {\n+            ptr::write(self.ptr().add(off), value);\n+        }\n     }\n \n     /// Returns `true` if the buffer is at full capacity.\n@@ -267,7 +272,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n@@ -289,7 +296,9 @@ impl<T> VecDeque<T> {\n             len,\n             self.cap()\n         );\n-        ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n+        }\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n@@ -329,7 +338,9 @@ impl<T> VecDeque<T> {\n                 // 2 [_ _ A A A A B B _]\n                 //            D . . .\n                 //\n-                self.copy(dst, src, len);\n+                unsafe {\n+                    self.copy(dst, src, len);\n+                }\n             }\n             (false, false, true) => {\n                 // dst before src, src doesn't wrap, dst wraps\n@@ -340,8 +351,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B B B _ _ _ A A]\n                 //    . .           D .\n                 //\n-                self.copy(dst, src, dst_pre_wrap_len);\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, false, true) => {\n                 // src before dst, src doesn't wrap, dst wraps\n@@ -352,8 +365,10 @@ impl<T> VecDeque<T> {\n                 // 3 [B B _ _ _ A A A A]\n                 //    . .           D .\n                 //\n-                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n             (false, true, false) => {\n                 // dst before src, src wraps, dst doesn't wrap\n@@ -364,8 +379,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C _ _ _ B B C C]\n                 //              D . . .\n                 //\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                }\n             }\n             (true, true, false) => {\n                 // src before dst, src wraps, dst doesn't wrap\n@@ -376,8 +393,10 @@ impl<T> VecDeque<T> {\n                 // 3 [C C A A _ _ _ C C]\n                 //    D . . .\n                 //\n-                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n-                self.copy(dst, src, src_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                }\n             }\n             (false, true, true) => {\n                 // dst before src, src wraps, dst wraps\n@@ -391,9 +410,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                 let delta = dst_pre_wrap_len - src_pre_wrap_len;\n-                self.copy(dst, src, src_pre_wrap_len);\n-                self.copy(dst + src_pre_wrap_len, 0, delta);\n-                self.copy(0, delta, len - dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(dst + src_pre_wrap_len, 0, delta);\n+                    self.copy(0, delta, len - dst_pre_wrap_len);\n+                }\n             }\n             (true, true, true) => {\n                 // src before dst, src wraps, dst wraps\n@@ -407,9 +428,11 @@ impl<T> VecDeque<T> {\n                 //\n                 debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                 let delta = src_pre_wrap_len - dst_pre_wrap_len;\n-                self.copy(delta, 0, len - src_pre_wrap_len);\n-                self.copy(0, self.cap() - delta, delta);\n-                self.copy(dst, src, dst_pre_wrap_len);\n+                unsafe {\n+                    self.copy(delta, 0, len - src_pre_wrap_len);\n+                    self.copy(0, self.cap() - delta, delta);\n+                    self.copy(dst, src, dst_pre_wrap_len);\n+                }\n             }\n         }\n     }\n@@ -439,13 +462,17 @@ impl<T> VecDeque<T> {\n             // Nop\n         } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            unsafe {\n+                self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            }\n             self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n             let new_tail = new_capacity - (old_capacity - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            unsafe {\n+                self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            }\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -488,7 +515,7 @@ impl<T> VecDeque<T> {\n         VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }\n     }\n \n-    /// Retrieves an element in the `VecDeque` by index.\n+    /// Provides a reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n@@ -513,7 +540,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Retrieves an element in the `VecDeque` mutably by index.\n+    /// Provides a mutable reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n@@ -651,7 +678,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n     /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient.\n@@ -662,7 +689,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Errors\n     ///\n-    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// If the capacity overflows `usize`, or the allocator reports a failure, then an error\n     /// is returned.\n     ///\n     /// # Examples\n@@ -678,7 +705,7 @@ impl<T> VecDeque<T> {\n     ///     // Pre-reserve the memory, exiting if we can't\n     ///     output.try_reserve_exact(data.len())?;\n     ///\n-    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     // Now we know this can't OOM(Out-Of-Memory) in the middle of our complex work\n     ///     output.extend(data.iter().map(|&val| {\n     ///         val * 2 + 5 // very complicated\n     ///     }));\n@@ -700,7 +727,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Errors\n     ///\n-    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// If the capacity overflows `usize`, or the allocator reports a failure, then an error\n     /// is returned.\n     ///\n     /// # Examples\n@@ -959,6 +986,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -989,6 +1019,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1347,7 +1380,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1370,7 +1405,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1385,7 +1422,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1420,7 +1457,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n     /// last element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1478,7 +1515,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -1876,6 +1915,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2, [2, 3]);\n     /// ```\n     #[inline]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();\n@@ -1995,11 +2035,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -2043,6 +2085,148 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// Once the internal storage is contiguous, the [`as_slices`](#method.as_slices) and\n+    /// [`as_mut_slices`](#method.as_mut_slices) methods will return the entire contents of the\n+    /// `VecDeque` in a single slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"70929\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2139,7 +2323,9 @@ impl<T> VecDeque<T> {\n \n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n-        self.wrap_copy(self.head, self.tail, mid);\n+        unsafe {\n+            self.wrap_copy(self.head, self.tail, mid);\n+        }\n         self.head = self.wrap_add(self.head, mid);\n         self.tail = self.wrap_add(self.tail, mid);\n     }\n@@ -2148,7 +2334,9 @@ impl<T> VecDeque<T> {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n         self.tail = self.wrap_sub(self.tail, k);\n-        self.wrap_copy(self.tail, self.head, k);\n+        unsafe {\n+            self.wrap_copy(self.tail, self.head, k);\n+        }\n     }\n }\n \n@@ -2723,13 +2911,33 @@ impl<A> Extend<A> for VecDeque<A> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: A) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &T) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2749,12 +2957,12 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T>) -> Self {\n+    fn from(other: Vec<T>) -> Self {\n         unsafe {\n+            let mut other = ManuallyDrop::new(other);\n             let other_buf = other.as_mut_ptr();\n             let mut buf = RawVec::from_raw_parts(other_buf, other.capacity());\n             let len = other.len();\n-            mem::forget(other);\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n@@ -2778,7 +2986,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// This never needs to re-allocate, but does need to do `O(n)` data movement if\n     /// the circular buffer doesn't happen to be at the beginning of the allocation.\n     ///\n     /// # Examples\n@@ -2802,67 +3010,19 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n+            let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n-            let out = Vec::from_raw_parts(buf, len, cap);\n-            mem::forget(other);\n-            out\n+            Vec::from_raw_parts(buf, len, cap)\n         }\n     }\n }"}, {"sha": "960af4bfda0533ee12d400bb1f359d51cd989b15", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "26077f3c8d15045820c9912e54d4facd790f9954", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "41c2b221704e67ffb9e358e3174e418658df083b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "e163a166b498fceab4aa669f23d3069f76195629", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "67ebdcc9f33b10ed9f4bc1e4b9091f6d90f3824f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 282, "deletions": 502, "changes": 784, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6418c4a9823f20665b4b4dc0aa9a3d4fdbbb6d8b", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4d50ae9efca9532eb717f17db20985e2541e233e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 161, "deletions": 126, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "e88385faf4fd4c57283645cf2a25adfe33c71933", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d7dc2174d665f3bce0a3ebb5da7da0b328b1576e", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "57927c688479b5f72746d6220b271f58dd2c7e41", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "64d9692244dde2ce0ebaefca78196c2dc029fdd6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 74, "deletions": 5, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "826f0c8fa833fbf001e0aacb434ccddeab100e66", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 276, "deletions": 134, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6f08cd7f123be67c2d036e615f2a5286da21f493", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "0d1cc99df47c552e24bccd7b7e22bd63b7ddd352", "filename": "src/liballoc/task.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "bddaab0c761887a80e99eca5a2bb4e6f94a6acd7", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "c02ba267056d6dd391e51cd97bbbdbaf4906302e", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "62084ccf53c5929f78edcd6c7e1dff45ea614de4", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "8bfcf323f674a74c610038a96cb1ed3beb9b473d", "filename": "src/liballoc/tests/borrow.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fborrow.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "5377485da8f3b7def467ee749689494cd6399b72", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "731a1b5f875b7c32bcf1f046684287df1b5c599d", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 324, "deletions": 82, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "75251ca0d51e9b8b4c49f4f057d03da80f886e54", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "62f062b83d75d77c5e34dfc62b2b347501716236", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "e2dc816b0152647b89036796158a56c35ce3d024", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "501b4f0f816be3f861bf768de3fecc45576875db", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "75b76bb73ed9e83c327f949c833fb5f9f4022ca9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "eee98d45340429f4f759f8bee607e8bd0ca2f5da", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9ea020d2d19f4a6349b3b21920e1e3a2b341f3e5", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "ffff543b07fe52cb79ecfa0209b5bddc741beaad", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 247, "deletions": 31, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "762dc4be44d6208950d4bd03e2fba8de66c45fcc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "1265d0e56b576ceed08c1f12091a4abd8053b043", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 219, "deletions": 102, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "5158aab8b7dc5c21cca20080e6ffd0f3e374ba17", "filename": "src/libarena/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "2a3d92edc4956dafc26936d82c8a506ff0e5029a", "filename": "src/libarena/lib.rs", "status": "removed", "additions": 0, "deletions": 492, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "42c555cafac86f187ddeb681fe62eecf85e86c9d", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d2a513451ccb6bda48317f696b93098e0800d10c", "filename": "src/libcore/alloc.rs", "status": "removed", "additions": 0, "deletions": 1007, "changes": 1007, "blob_url": "https://github.com/rust-lang/rust/blob/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6de3244cd62cbde367c206bc9972daded5281d/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "147fe696ac02fb2433f1071705f15c6882d0c37f", "filename": "src/libcore/alloc/global.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "a09c2387d0de2b597c476ffec8d78e3a568cefde", "filename": "src/libcore/alloc/layout.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "1346fbd4810038caf3064f5dd19f9dfcc90aebe2", "filename": "src/libcore/alloc/mod.rs", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "79b6304958d51332af85ff9987ba5c8740feb385", "filename": "src/libcore/any.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "f6b8d4ba081467647534044fe3dbbfe4428f4d3d", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "549228ffffaa4d832ae1c92d750cf7665d6513a9", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "de4ef7949f344a6842fe1d7c8d2a3214f59e18a1", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "305baa68729eb2a2fb512cac2a98b6bc7b33dd4b", "filename": "src/libcore/benches/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "a1ce33d0bb49ef90f8f065874273e4cda9f39a3e", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4e1fd8bf753cad249414eaa1d2acc32ff202c864", "filename": "src/libcore/benches/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "77ca901a90af39890588491cf122386eca0c763c", "filename": "src/libcore/benches/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "c4293ed7bcfe2a557f2204175d86fd84d48ed39b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d7e39946148ed793fd1eb0b175f275305f92df08", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "dd2f01c679f7347a33ac6409f1fef7fa1b13d3c0", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 351, "deletions": 101, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "1b4e906e4e47523615759379f91b63c7636db132", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "7784ec687ea9a9378ad2cca7770b62e148fb99d7", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9856efc6bd8a48c080048465d2f81b833363be65", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "8ff1ced53b071840f45edad5e3c3184804fb90c2", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "46ba0a279b7fff00462f9cb88309ab1a5f826f12", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9a8d65cd4e06b93e37e075f100a589b18e97eba5", "filename": "src/libcore/default.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "7bc2866dc2e6756eda3eaf9c2c18f2d8c41c32a1", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9c5dbb5e6f3567fd567be94c44d00038e638d58b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4020c254446e3eb2c10dcf878810467df5e753c3", "filename": "src/libcore/future/into_future.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Finto_future.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9dbc23f5c04c5cea9262c56255e2d94727a84491", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "74887b68aa0fadf95eaa9b7504f2ffdd3ae51c5c", "filename": "src/libcore/future/pending.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fpending.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fpending.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fpending.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "31b39d7fb6cd5c8f7b0096c83855e9b6e0c695d0", "filename": "src/libcore/future/ready.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Ffuture%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fready.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d80101753cbef4b554c1a536fcebd4a47523d2c7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "ac058609f45ed34ef6b6006581104bf0e34a7a0d", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "0d794de5fe84b3233d904382b15959203c126b33", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "2298958b88101c84d39f23aa45e1249214423c8a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 261, "deletions": 194, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6700ef017bde43922f51411083d3f99d4b9ce134", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 125, "deletions": 154, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4202e52448dcfc358a865fb4cb9fe58d404a870e", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "502fc2e631502a2c5637a482c746a6ab95b58b05", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "00529f0e2d54f4dcc0ac8ad3ea1c30bfab8efe42", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 224, "deletions": 293, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "e83d36a580f06464022d3b0b51bb0f2c9f64f142", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "bd7e6cfa5a750116009b7b407ebfeef82d9f1ecc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 504, "deletions": 173, "changes": 677, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d76fa89bd012c22f4167b25e336a4aa917d321f0", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9d20022b6ed6db75bd787773d4b4cc7e6ba7e772", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "f6329c6c593ed778a52f9b20b5df28a0a2b54ed3", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "530cf881f29da54dc8bede98ea50bcfdc3b696a5", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 117, "deletions": 61, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "a9ba3908c38982a1e4014e0bf6efb09e4c068456", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4eb2fdbd07868a83352e199925cc4780e046d19b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "3cfdde60135b77d905939f54d0b52d301fca673b", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6040dd31847a9f26f3999525d8e13ab90c5ed683", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "18767c482c77ea47cd863685db33ee1110ffe1dc", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "499016545e967c769231a14ced30b1c06f5edd50", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "066bb8b3dc787a40ec00d36d7883dbcffb7a9ad6", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 161, "deletions": 36, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "aaeb4d8a22c297eee22fb9514d1fe85ee60e6ad6", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "2766843155a0e7fb2c52622f81017ff29362ad4a", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6313de31ce4d582dfc2f7b33e57216ed7d1f1070", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 232, "deletions": 17, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d42e5392c586347af9dd092d4033342b46349e3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 234, "deletions": 19, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "c43536c6fcca86585db29821f1772c2f3fbc94dc", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9bf56e93d896f1d96db0c7de7b6e0053ea62b1e6", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "ffd30b03f2109c677692713e06c203351aa89b09", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "b1317bc2121f6bb496949ee118f088c96ed0b414", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 192, "deletions": 39, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "f6acb8f8b9a9273f3865281c2c47d7cc02f018f6", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "622a138abe9d19cae5ff0945563469b166a1da82", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "3faeb170b0637626090dcdb9dd1fba9c0b999cb3", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "06cfc36363615ee56515bcb64e439bea37676484", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "2cdfee87a3546ab97637817a25f5c35744bc6959", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "4f23620b92b806067b336ac4fa76a5f3a7c96459", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "763b33606fe88b18c044359c74dec2c3bf6172e1", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "d86f39c4550c843fc3aa8f5212ccc5c633710e46", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 16, "deletions": 44, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "9bc35ae1f5c280bf59aabcabb6525943f2a663cb", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "5f0a12678ff432a00b501a0419670a2540ab1694", "filename": "src/libcore/option.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "c7009b76e814817042fb3bab5d9cea92f1ae7845", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "766c69a5f94206ae7944ae635c5f17fbe954c219", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "6f5bf7ad9da52e1e40fae1383d77c813eb6f99fe", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}, {"sha": "b4fff3d67b555b0bf109b5f94c5277208eeda578", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ef46169e2b2631d41d6aa1b7c55b8abf006e50/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=00ef46169e2b2631d41d6aa1b7c55b8abf006e50"}]}