{"sha": "c185610ebc19a0fc22e68472483dc69ea10b92fd", "node_id": "C_kwDOAAsO6NoAKGMxODU2MTBlYmMxOWEwZmMyMmU2ODQ3MjQ4M2RjNjllYTEwYjkyZmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-11T03:52:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-11T03:52:12Z"}, "message": "Auto merge of #91761 - matthiaskrgr:rollup-bjowmvz, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #91668 (Remove the match on `ErrorKind::Other`)\n - #91678 (Add tests fixed by #90023)\n - #91679 (Move core/stream/stream/mod.rs to core/stream/stream.rs)\n - #91681 (fix typo in `intrinsics::raw_eq` docs)\n - #91686 (Fix `Vec::reserve_exact` documentation)\n - #91697 (Delete Utf8Lossy::from_str)\n - #91706 (Add unstable book entries for parts of asm that are not being stabilized)\n - #91709 (Replace iterator-based set construction by *Set::From<[T; N]>)\n - #91716 (Improve x.py logging and defaults a bit more)\n - #91747 (Add pierwill to .mailmap)\n - #91755 (Fix since attribute for const_linked_list_new feature)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6efde3cd2f3283600d3bd97a54a5b87ce3b21f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6efde3cd2f3283600d3bd97a54a5b87ce3b21f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c185610ebc19a0fc22e68472483dc69ea10b92fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c185610ebc19a0fc22e68472483dc69ea10b92fd", "html_url": "https://github.com/rust-lang/rust/commit/c185610ebc19a0fc22e68472483dc69ea10b92fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c185610ebc19a0fc22e68472483dc69ea10b92fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82575a1d6f02a3932fcfa36562368f5e095d93ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/82575a1d6f02a3932fcfa36562368f5e095d93ba", "html_url": "https://github.com/rust-lang/rust/commit/82575a1d6f02a3932fcfa36562368f5e095d93ba"}, {"sha": "637859b26ef431b2533d257184bd7a74ae278f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/637859b26ef431b2533d257184bd7a74ae278f8c", "html_url": "https://github.com/rust-lang/rust/commit/637859b26ef431b2533d257184bd7a74ae278f8c"}], "stats": {"total": 690, "additions": 614, "deletions": 76}, "files": [{"sha": "3d4d47119391a379fc64ec45002fc5e286016a19", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -246,6 +246,7 @@ Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n Philipp Krones <hello@philkrones.com> flip1995 <hello@philkrones.com>\n Philipp Krones <hello@philkrones.com> <philipp.krones@embecosm.com>\n Philipp Matthias Sch\u00e4fer <philipp.matthias.schaefer@posteo.de>\n+pierwill <pierwill@users.noreply.github.com> <19642016+pierwill@users.noreply.github.com>\n Przemys\u0142aw Weso\u0142ek <jest@go.art.pl> Przemek Weso\u0142ek <jest@go.art.pl>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com> Rafael Avila de Espindola <espindola@dream.(none)>\n Ralph Giles <giles@thaumas.net> Ralph Giles <giles@mozilla.com>"}, {"sha": "dfdf3c938428835823564615e2d7ef91f0d2bf31", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -491,7 +491,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let set = BTreeSet::from([1, 2, 3]);\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -515,7 +515,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let set = BTreeSet::from([1, 2, 3]);\n     /// assert_eq!(set.get(&2), Some(&2));\n     /// assert_eq!(set.get(&4), None);\n     /// ```\n@@ -536,7 +536,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let a = BTreeSet::from([1, 2, 3]);\n     /// let mut b = BTreeSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n@@ -562,7 +562,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sup: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let sup = BTreeSet::from([1, 2, 3]);\n     /// let mut set = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n@@ -639,7 +639,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sub: BTreeSet<_> = [1, 2].iter().cloned().collect();\n+    /// let sub = BTreeSet::from([1, 2]);\n     /// let mut set = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n@@ -853,7 +853,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let mut set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = BTreeSet::from([1, 2, 3]);\n     /// assert_eq!(set.take(&2), Some(2));\n     /// assert_eq!(set.take(&2), None);\n     /// ```\n@@ -876,8 +876,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let xs = [1, 2, 3, 4, 5, 6];\n-    /// let mut set: BTreeSet<i32> = xs.iter().cloned().collect();\n+    /// let mut set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n     /// // Keep only the even numbers.\n     /// set.retain(|&k| k % 2 == 0);\n     /// assert!(set.iter().eq([2, 4, 6].iter()));\n@@ -1009,7 +1008,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3].iter().cloned().collect();\n+    /// let set = BTreeSet::from([1, 2, 3]);\n     /// let mut set_iter = set.iter();\n     /// assert_eq!(set_iter.next(), Some(&1));\n     /// assert_eq!(set_iter.next(), Some(&2));\n@@ -1022,7 +1021,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [3, 1, 2].iter().cloned().collect();\n+    /// let set = BTreeSet::from([3, 1, 2]);\n     /// let mut set_iter = set.iter();\n     /// assert_eq!(set_iter.next(), Some(&1));\n     /// assert_eq!(set_iter.next(), Some(&2));\n@@ -1124,7 +1123,7 @@ impl<T> IntoIterator for BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n+    /// let set = BTreeSet::from([1, 2, 3, 4]);\n     ///\n     /// let v: Vec<_> = set.into_iter().collect();\n     /// assert_eq!(v, [1, 2, 3, 4]);\n@@ -1243,8 +1242,8 @@ impl<T: Ord + Clone> Sub<&BTreeSet<T>> for &BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n+    /// let a = BTreeSet::from([1, 2, 3]);\n+    /// let b = BTreeSet::from([3, 4, 5]);\n     ///\n     /// let result = &a - &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n@@ -1266,8 +1265,8 @@ impl<T: Ord + Clone> BitXor<&BTreeSet<T>> for &BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n+    /// let a = BTreeSet::from([1, 2, 3]);\n+    /// let b = BTreeSet::from([2, 3, 4]);\n     ///\n     /// let result = &a ^ &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n@@ -1289,8 +1288,8 @@ impl<T: Ord + Clone> BitAnd<&BTreeSet<T>> for &BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n+    /// let a = BTreeSet::from([1, 2, 3]);\n+    /// let b = BTreeSet::from([2, 3, 4]);\n     ///\n     /// let result = &a & &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n@@ -1312,8 +1311,8 @@ impl<T: Ord + Clone> BitOr<&BTreeSet<T>> for &BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n+    /// let a = BTreeSet::from([1, 2, 3]);\n+    /// let b = BTreeSet::from([3, 4, 5]);\n     ///\n     /// let result = &a | &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();"}, {"sha": "4a07d5d4bed10aa2efb84907cde4c220a0972188", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -417,7 +417,7 @@ impl<T> LinkedList<T> {\n     /// let list: LinkedList<u32> = LinkedList::new();\n     /// ```\n     #[inline]\n-    #[rustc_const_stable(feature = \"const_linked_list_new\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_linked_list_new\", since = \"1.39.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     pub const fn new() -> Self {"}, {"sha": "b6b11b75c99c9ab878e8e69550f53566619443e5", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -822,7 +822,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f45ee7b6ee88b7ec039f21eed51daf001db78109", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -1919,7 +1919,7 @@ extern \"rust-intrinsic\" {\n \n     /// Determines whether the raw bytes of the two values are equal.\n     ///\n-    /// The is particularly handy for arrays, since it allows things like just\n+    /// This is particularly handy for arrays, since it allows things like just\n     /// comparing `i96`s instead of forcing `alloca`s for `[6 x i16]`.\n     ///\n     /// Above some backend-decided threshold this will emit calls to `memcmp`,"}, {"sha": "6ec1c93908fc741f2b6681735bf7c5366c6d4c09", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -12,11 +12,6 @@ pub struct Utf8Lossy {\n }\n \n impl Utf8Lossy {\n-    #[must_use]\n-    pub fn from_str(s: &str) -> &Utf8Lossy {\n-        Utf8Lossy::from_bytes(s.as_bytes())\n-    }\n-\n     #[must_use]\n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n         // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required."}, {"sha": "d102619b8e5ec135f09090ae7b1e08e5413c3a87", "filename": "library/core/src/stream/stream.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fstream%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fcore%2Fsrc%2Fstream%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fstream.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "previous_filename": "library/core/src/stream/stream/mod.rs"}, {"sha": "a1e28c0b0a695acba54719d5dee8187918124421", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -233,7 +233,7 @@ impl<T, S> HashSet<T, S> {\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::from([1, 2, 3]);\n     /// assert!(!set.is_empty());\n     ///\n     /// // print 1, 2, 3 in an arbitrary order\n@@ -489,8 +489,8 @@ where\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([4, 2, 3, 4]);\n     ///\n     /// // Can be seen as `a - b`.\n     /// for x in a.difference(&b) {\n@@ -518,8 +518,8 @@ where\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([4, 2, 3, 4]);\n     ///\n     /// // Print 1, 4 in arbitrary order.\n     /// for x in a.symmetric_difference(&b) {\n@@ -548,8 +548,8 @@ where\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([4, 2, 3, 4]);\n     ///\n     /// // Print 2, 3 in arbitrary order.\n     /// for x in a.intersection(&b) {\n@@ -576,8 +576,8 @@ where\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([4, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order.\n     /// for x in a.union(&b) {\n@@ -608,7 +608,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let set = HashSet::from([1, 2, 3]);\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -633,7 +633,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let set = HashSet::from([1, 2, 3]);\n     /// assert_eq!(set.get(&2), Some(&2));\n     /// assert_eq!(set.get(&4), None);\n     /// ```\n@@ -657,7 +657,7 @@ where\n     ///\n     /// use std::collections::HashSet;\n     ///\n-    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::from([1, 2, 3]);\n     /// assert_eq!(set.len(), 3);\n     /// assert_eq!(set.get_or_insert(2), &2);\n     /// assert_eq!(set.get_or_insert(100), &100);\n@@ -744,7 +744,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n     /// let mut b = HashSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n@@ -770,7 +770,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let sup = HashSet::from([1, 2, 3]);\n     /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n@@ -792,7 +792,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n+    /// let sub = HashSet::from([1, 2]);\n     /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n@@ -893,7 +893,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::from([1, 2, 3]);\n     /// assert_eq!(set.take(&2), Some(2));\n     /// assert_eq!(set.take(&2), None);\n     /// ```\n@@ -917,8 +917,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let xs = [1, 2, 3, 4, 5, 6];\n-    /// let mut set: HashSet<i32> = xs.iter().cloned().collect();\n+    /// let mut set = HashSet::from([1, 2, 3, 4, 5, 6]);\n     /// set.retain(|&k| k % 2 == 0);\n     /// assert_eq!(set.len(), 3);\n     /// ```\n@@ -1097,8 +1096,8 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([3, 4, 5]);\n     ///\n     /// let set = &a | &b;\n     ///\n@@ -1130,8 +1129,8 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([2, 3, 4]);\n     ///\n     /// let set = &a & &b;\n     ///\n@@ -1163,8 +1162,8 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([3, 4, 5]);\n     ///\n     /// let set = &a ^ &b;\n     ///\n@@ -1196,8 +1195,8 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    /// let a = HashSet::from([1, 2, 3]);\n+    /// let b = HashSet::from([3, 4, 5]);\n     ///\n     /// let set = &a - &b;\n     ///\n@@ -1226,7 +1225,7 @@ where\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n ///\n /// let mut iter = a.iter();\n /// ```\n@@ -1248,7 +1247,7 @@ pub struct Iter<'a, K: 'a> {\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n ///\n /// let mut iter = a.into_iter();\n /// ```\n@@ -1269,7 +1268,7 @@ pub struct IntoIter<K> {\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n+/// let mut a = HashSet::from([1, 2, 3]);\n ///\n /// let mut drain = a.drain();\n /// ```\n@@ -1291,7 +1290,7 @@ pub struct Drain<'a, K: 'a> {\n ///\n /// use std::collections::HashSet;\n ///\n-/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n+/// let mut a = HashSet::from([1, 2, 3]);\n ///\n /// let mut drain_filtered = a.drain_filter(|v| v % 2 == 0);\n /// ```\n@@ -1315,8 +1314,8 @@ where\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n-/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n+/// let b = HashSet::from([4, 2, 3, 4]);\n ///\n /// let mut intersection = a.intersection(&b);\n /// ```\n@@ -1342,8 +1341,8 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n-/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n+/// let b = HashSet::from([4, 2, 3, 4]);\n ///\n /// let mut difference = a.difference(&b);\n /// ```\n@@ -1369,8 +1368,8 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n-/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n+/// let b = HashSet::from([4, 2, 3, 4]);\n ///\n /// let mut intersection = a.symmetric_difference(&b);\n /// ```\n@@ -1393,8 +1392,8 @@ pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n-/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n+/// let a = HashSet::from([1, 2, 3]);\n+/// let b = HashSet::from([4, 2, 3, 4]);\n ///\n /// let mut union_iter = a.union(&b);\n /// ```"}, {"sha": "5df3d0bde6d58725cb4715b640614dbb9b921720", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -189,11 +189,11 @@ def default_build_triple(verbose):\n         host = next(x for x in version.split('\\n') if x.startswith(\"host: \"))\n         triple = host.split(\"host: \")[1]\n         if verbose:\n-            print(\"detected default triple {}\".format(triple))\n+            print(\"detected default triple {} from pre-installed rustc\".format(triple))\n         return triple\n     except Exception as e:\n         if verbose:\n-            print(\"rustup not detected: {}\".format(e))\n+            print(\"pre-installed rustc not detected: {}\".format(e))\n             print(\"falling back to auto-detect\")\n \n     required = sys.platform != 'win32'\n@@ -726,12 +726,15 @@ def maybe_download_ci_toolchain(self):\n         status = subprocess.call([\"git\", \"diff-index\", \"--quiet\", commit, \"--\", compiler, library])\n         if status != 0:\n             if download_rustc == \"if-unchanged\":\n+                if self.verbose:\n+                    print(\"warning: saw changes to compiler/ or library/ since {}; \" \\\n+                          \"ignoring `download-rustc`\".format(commit))\n                 return None\n-            print(\"warning: `download-rustc` is enabled, but there are changes to \\\n-                   compiler/ or library/\")\n+            print(\"warning: `download-rustc` is enabled, but there are changes to \" \\\n+                  \"compiler/ or library/\")\n \n         if self.verbose:\n-            print(\"using downloaded stage1 artifacts from CI (commit {})\".format(commit))\n+            print(\"using downloaded stage2 artifacts from CI (commit {})\".format(commit))\n         self.rustc_commit = commit\n         # FIXME: support downloading artifacts from the beta channel\n         self.download_toolchain(False, \"nightly\")"}, {"sha": "952a65a428688bf42cefc188534fe7c6473b6410", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -1578,11 +1578,11 @@ impl<'a> Builder<'a> {\n                 panic!(\"{}\", out);\n             }\n             if let Some(out) = self.cache.get(&step) {\n-                self.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n+                self.verbose_than(1, &format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n                 return out;\n             }\n-            self.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n+            self.verbose_than(1, &format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n \n@@ -1605,7 +1605,7 @@ impl<'a> Builder<'a> {\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.verbose_than(1, &format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n         self.cache.put(step, out.clone());\n         out\n     }"}, {"sha": "3b73dc1c7df74bb5ade409e9dfb74cb47a0fef7b", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -75,10 +75,10 @@ fn rm_rf(path: &Path) {\n             do_op(path, \"remove dir\", |p| {\n                 fs::remove_dir(p).or_else(|e| {\n                     // Check for dir not empty on Windows\n+                    // FIXME: Once `ErrorKind::DirectoryNotEmpty` is stabilized,\n+                    // match on `e.kind()` instead.\n                     #[cfg(windows)]\n-                    if matches!(e.kind(), std::io::ErrorKind::Other)\n-                        && e.raw_os_error() == Some(145)\n-                    {\n+                    if e.raw_os_error() == Some(145) {\n                         return Ok(());\n                     }\n "}, {"sha": "88359fff191e3978076da84f206a7a49a9de529a", "filename": "src/bootstrap/defaults/config.tools.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -11,6 +11,10 @@ incremental = true\n # This cuts compile times by almost 60x, but means you can't modify the compiler.\n download-rustc = \"if-unchanged\"\n \n+[build]\n+# Document with the in-tree rustdoc by default, since `download-rustc` makes it quick to compile.\n+doc-stage = 2\n+\n [llvm]\n # Will download LLVM from CI if available on your platform.\n download-ci-llvm = \"if-available\""}, {"sha": "1063c23b6dfba4f0650e89c12d6eed6a2ea42ecd", "filename": "src/doc/unstable-book/src/language-features/asm-const.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-const.md?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,11 @@\n+# `asm_const`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+This feature adds a `const <expr>` operand type to `asm!` and `global_asm!`.\n+- `<expr>` must be an integer constant expression.\n+- The value of the expression is formatted as a string and substituted directly into the asm template string."}, {"sha": "ec97eaa8b2b5b969d46fa223bfd69d5984299e07", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,117 @@\n+# `asm_experimental_arch`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+This feature tracks `asm!` and `global_asm!` support for the following architectures:\n+- NVPTX\n+- PowerPC\n+- Hexagon\n+- MIPS32r2 and MIPS64r2\n+- wasm32\n+- BPF\n+- SPIR-V\n+- AVR\n+\n+## Register classes\n+\n+| Architecture | Register class | Registers                          | LLVM constraint code |\n+| ------------ | -------------- | ---------------------------------- | -------------------- |\n+| MIPS         | `reg`          | `$[2-25]`                          | `r`                  |\n+| MIPS         | `freg`         | `$f[0-31]`                         | `f`                  |\n+| NVPTX        | `reg16`        | None\\*                             | `h`                  |\n+| NVPTX        | `reg32`        | None\\*                             | `r`                  |\n+| NVPTX        | `reg64`        | None\\*                             | `l`                  |\n+| Hexagon      | `reg`          | `r[0-28]`                          | `r`                  |\n+| PowerPC      | `reg`          | `r[0-31]`                          | `r`                  |\n+| PowerPC      | `reg_nonzero`  | `r[1-31]`                          | `b`                  |\n+| PowerPC      | `freg`         | `f[0-31]`                          | `f`                  |\n+| PowerPC      | `cr`           | `cr[0-7]`, `cr`                    | Only clobbers        |\n+| PowerPC      | `xer`          | `xer`                              | Only clobbers        |\n+| wasm32       | `local`        | None\\*                             | `r`                  |\n+| BPF          | `reg`          | `r[0-10]`                          | `r`                  |\n+| BPF          | `wreg`         | `w[0-10]`                          | `w`                  |\n+| AVR          | `reg`          | `r[2-25]`, `XH`, `XL`, `ZH`, `ZL`  | `r`                  |\n+| AVR          | `reg_upper`    | `r[16-25]`, `XH`, `XL`, `ZH`, `ZL` | `d`                  |\n+| AVR          | `reg_pair`     | `r3r2` .. `r25r24`, `X`, `Z`       | `r`                  |\n+| AVR          | `reg_iw`       | `r25r24`, `X`, `Z`                 | `w`                  |\n+| AVR          | `reg_ptr`      | `X`, `Z`                           | `e`                  |\n+\n+> **Notes**:\n+> - NVPTX doesn't have a fixed register set, so named registers are not supported.\n+>\n+> - WebAssembly doesn't have registers, so named registers are not supported.\n+\n+# Register class supported types\n+\n+| Architecture | Register class                  | Target feature | Allowed types                           |\n+| ------------ | ------------------------------- | -------------- | --------------------------------------- |\n+| MIPS32       | `reg`                           | None           | `i8`, `i16`, `i32`, `f32`               |\n+| MIPS32       | `freg`                          | None           | `f32`, `f64`                            |\n+| MIPS64       | `reg`                           | None           | `i8`, `i16`, `i32`, `i64`, `f32`, `f64` |\n+| MIPS64       | `freg`                          | None           | `f32`, `f64`                            |\n+| NVPTX        | `reg16`                         | None           | `i8`, `i16`                             |\n+| NVPTX        | `reg32`                         | None           | `i8`, `i16`, `i32`, `f32`               |\n+| NVPTX        | `reg64`                         | None           | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| Hexagon      | `reg`                           | None           | `i8`, `i16`, `i32`, `f32`               |\n+| PowerPC      | `reg`                           | None           | `i8`, `i16`, `i32`                      |\n+| PowerPC      | `reg_nonzero`                   | None           | `i8`, `i16`, `i32`                      |\n+| PowerPC      | `freg`                          | None           | `f32`, `f64`                            |\n+| PowerPC      | `cr`                            | N/A            | Only clobbers                           |\n+| PowerPC      | `xer`                           | N/A            | Only clobbers                           |\n+| wasm32       | `local`                         | None           | `i8` `i16` `i32` `i64` `f32` `f64`      |\n+| BPF          | `reg`                           | None           | `i8` `i16` `i32` `i64`                  |\n+| BPF          | `wreg`                          | `alu32`        | `i8` `i16` `i32`                        |\n+| AVR          | `reg`, `reg_upper`              | None           | `i8`                                    |\n+| AVR          | `reg_pair`, `reg_iw`, `reg_ptr` | None           | `i16`                                   |\n+\n+## Register aliases\n+\n+| Architecture | Base register | Aliases   |\n+| ------------ | ------------- | --------- |\n+| Hexagon      | `r29`         | `sp`      |\n+| Hexagon      | `r30`         | `fr`      |\n+| Hexagon      | `r31`         | `lr`      |\n+| BPF          | `r[0-10]`     | `w[0-10]` |\n+| AVR          | `XH`          | `r27`     |\n+| AVR          | `XL`          | `r26`     |\n+| AVR          | `ZH`          | `r31`     |\n+| AVR          | `ZL`          | `r30`     |\n+\n+## Unsupported registers\n+\n+| Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n+| ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n+| All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n+| MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n+| MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n+| MIPS         | `$26`/`$k0`, `$27`/`$k1`                | OS-reserved registers.                                                                                                                                                              |\n+| MIPS         | `$28`/`$gp`                             | Global pointer cannot be used as inputs or outputs.                                                                                                                                 |\n+| MIPS         | `$ra`                                   | Return address cannot be used as inputs or outputs.                                                                                                                                 |\n+| Hexagon      | `lr`                                    | This is the link register which cannot be used as an input or output.                                                                                                               |\n+| AVR          | `r0`, `r1`, `r1r0`                      | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n+\n+## Template modifiers\n+\n+| Architecture | Register class | Modifier | Example output | LLVM modifier |\n+| ------------ | -------------- | -------- | -------------- | ------------- |\n+| MIPS         | `reg`          | None     | `$2`           | None          |\n+| MIPS         | `freg`         | None     | `$f0`          | None          |\n+| NVPTX        | `reg16`        | None     | `rs0`          | None          |\n+| NVPTX        | `reg32`        | None     | `r0`           | None          |\n+| NVPTX        | `reg64`        | None     | `rd0`          | None          |\n+| Hexagon      | `reg`          | None     | `r0`           | None          |\n+| PowerPC      | `reg`          | None     | `0`            | None          |\n+| PowerPC      | `reg_nonzero`  | None     | `3`            | `b`           |\n+| PowerPC      | `freg`         | None     | `0`            | None          |\n+\n+# Flags covered by `preserves_flags`\n+\n+These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n+- AVR\n+  - The status register `SREG`."}, {"sha": "7544e20807e9247cc939f513dde3731c6a58d4af", "filename": "src/doc/unstable-book/src/language-features/asm-sym.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-sym.md", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-sym.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-sym.md?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,13 @@\n+# `asm_sym`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+This feature adds a `sym <path>` operand type to `asm!` and `global_asm!`.\n+- `<path>` must refer to a `fn` or `static`.\n+- A mangled symbol name referring to the item is substituted into the asm template string.\n+- The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).\n+- `<path>` is allowed to point to a `#[thread_local]` static, in which case the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) to read from thread-local data."}, {"sha": "414193fe801774de89c1596fe032d4d0c16cf036", "filename": "src/doc/unstable-book/src/language-features/asm-unwind.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-unwind.md", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-unwind.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-unwind.md?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,9 @@\n+# `asm_unwind`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+This feature adds a `may_unwind` option to `asm!` which allows an `asm` block to unwind stack and be part of the stack unwinding process. This option is only supported by the LLVM backend right now."}, {"sha": "2f196533dd88c931c131d9696c149a68ec14363b", "filename": "src/test/ui/const-generics/issues/issue-79674.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,28 @@\n+#![feature(const_fn_trait_bound, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait MiniTypeId {\n+    const TYPE_ID: u64;\n+}\n+\n+impl<T> MiniTypeId for T {\n+    const TYPE_ID: u64 = 0;\n+}\n+\n+enum Lift<const V: bool> {}\n+\n+trait IsFalse {}\n+impl IsFalse for Lift<false> {}\n+\n+const fn is_same_type<T: MiniTypeId, U: MiniTypeId>() -> bool {\n+    T::TYPE_ID == U::TYPE_ID\n+}\n+\n+fn requires_distinct<A, B>(_a: A, _b: B) where\n+    A: MiniTypeId, B: MiniTypeId,\n+    Lift<{is_same_type::<A, B>()}>: IsFalse {}\n+\n+fn main() {\n+    requires_distinct(\"str\", 12);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "8c029289cbb0d78e57c2903d03d81ed5146508d0", "filename": "src/test/ui/const-generics/issues/issue-79674.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-79674.rs:26:5\n+   |\n+LL |     requires_distinct(\"str\", 12);\n+   |     ^^^^^^^^^^^^^^^^^ expected `true`, found `false`\n+   |\n+   = note: expected type `true`\n+              found type `false`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "68536348d3884584af1ae07d1dd71fc2774e6a3b", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,115 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait TensorDimension {\n+    const DIM : usize;\n+    const ISSCALAR : bool = Self::DIM == 0;\n+    fn is_scalar(&self) -> bool {Self::ISSCALAR}\n+}\n+\n+trait TensorSize : TensorDimension {\n+    fn size(&self) -> [usize;Self::DIM];\n+    fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n+        index.iter().zip(self.size().iter()).all(|(i,s)| i < s)\n+    }\n+}\n+\n+\n+trait Broadcastable: TensorSize + Sized {\n+    type Element;\n+    fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n+    fn lazy_updim<const NEWDIM : usize>(&self, size : [usize;NEWDIM] ) ->\n+       LazyUpdim<Self,{Self::DIM},NEWDIM>\n+    {\n+        assert!(NEWDIM >= Self::DIM,\n+            \"Updimmed tensor cannot have fewer indices than the initial one.\");\n+        LazyUpdim {size,reference:&self}\n+    }\n+    fn bmap<T,F :Fn(Self::Element) -> T>(&self,foo : F) -> BMap<T,Self,F,{Self::DIM}>{\n+        BMap {reference:self,closure : foo}\n+    }\n+}\n+\n+\n+struct LazyUpdim<'a,T : Broadcastable,const OLDDIM : usize, const DIM : usize> {\n+    size : [usize;DIM],\n+    reference : &'a T\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize> TensorDimension for LazyUpdim<'a,T,{T::DIM},DIM> {\n+    const DIM : usize = DIM;\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize> TensorSize for LazyUpdim<'a,T,{T::DIM},DIM> {\n+    fn size(&self) -> [usize;DIM] {self.size}\n+    //~^ ERROR method not compatible with trait\n+}\n+\n+impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM>\n+{\n+    type Element = T::Element;\n+    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+      //~^ ERROR method not compatible with trait\n+        assert!(DIM >= T::DIM);\n+        if !self.inbounds(index) {return None}\n+        //~^ ERROR unconstrained generic constant\n+        //~| ERROR mismatched types\n+        let size = self.size();\n+        //~^ ERROR unconstrained generic constant\n+        let newindex : [usize;T::DIM] = Default::default();\n+        //~^ ERROR the trait bound `[usize; _]: Default` is not satisfied\n+        self.reference.bget(newindex)\n+    }\n+}\n+\n+struct BMap<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  , const DIM: usize> {\n+    reference : &'a T,\n+    closure : F\n+}\n+\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R,\n+     const DIM: usize> TensorDimension for BMap<'a,R,T,F,DIM> {\n+\n+    const DIM : usize = DIM;\n+}\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n+      const DIM: usize> TensorSize for BMap<'a,R,T,F,DIM> {\n+\n+    fn size(&self) -> [usize;DIM] {self.reference.size()}\n+    //~^ ERROR unconstrained generic constant\n+    //~| ERROR mismatched types\n+    //~| ERROR method not compatible with trait\n+}\n+\n+impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n+  const DIM: usize> Broadcastable for BMap<'a,R,T,F,DIM> {\n+\n+    type Element = R;\n+    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+      //~^ ERROR method not compatible with trait\n+        self.reference.bget(index).map(&self.closure)\n+        //~^ ERROR unconstrained generic constant\n+        //~| ERROR mismatched types\n+    }\n+}\n+\n+impl<T> TensorDimension for Vec<T> {\n+    const DIM : usize = 1;\n+}\n+impl<T> TensorSize for Vec<T> {\n+    fn size(&self) -> [usize;1] {[self.len()]}\n+}\n+impl<T: Clone> Broadcastable for Vec<T> {\n+    type Element = T;\n+    fn bget(& self,index : [usize;1]) -> Option<T> {\n+        self.get(index[0]).cloned()\n+    }\n+}\n+\n+fn main() {\n+    let v = vec![1,2,3];\n+    let bv = v.lazy_updim([3,4]);\n+    let bbv = bv.bmap(|x| x*x);\n+\n+    println!(\"The size of v is {:?}\",bbv.bget([0,2]).expect(\"Out of bounds.\"));\n+}"}, {"sha": "a49f850717f8a6afa51b0b4fb42ff62b42d95cd0", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,130 @@\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:44:5\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.size}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:51:5\n+   |\n+LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:78:5\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:88:5\n+   |\n+LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:54:18\n+   |\n+LL |         if !self.inbounds(index) {return None}\n+   |                  ^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::inbounds`\n+  --> $DIR/issue-83765.rs:12:38\n+   |\n+LL |     fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n+   |                                      ^^^^^^^^^ required by this bound in `TensorSize::inbounds`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:54:27\n+   |\n+LL |         if !self.inbounds(index) {return None}\n+   |                           ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:57:25\n+   |\n+LL |         let size = self.size();\n+   |                         ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::size`\n+  --> $DIR/issue-83765.rs:11:30\n+   |\n+LL |     fn size(&self) -> [usize;Self::DIM];\n+   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n+\n+error[E0277]: the trait bound `[usize; _]: Default` is not satisfied\n+  --> $DIR/issue-83765.rs:59:41\n+   |\n+LL |         let newindex : [usize;T::DIM] = Default::default();\n+   |                                         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `[usize; _]`\n+   |\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM> where [usize; _]: Default\n+   |                                                                                              +++++++++++++++++++++++++\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:78:51\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |                                                   ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::size`\n+  --> $DIR/issue-83765.rs:11:30\n+   |\n+LL |     fn size(&self) -> [usize;Self::DIM];\n+   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:78:36\n+   |\n+LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n+   |\n+   = note: expected type `DIM`\n+              found type `Self::DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:90:24\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                        ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `Broadcastable::bget`\n+  --> $DIR/issue-83765.rs:20:33\n+   |\n+LL |     fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n+   |                                 ^^^^^^^^^ required by this bound in `Broadcastable::bget`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:90:29\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                             ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected type `Self::DIM`\n+              found type `DIM`\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "cf08f722fbb8092d26868b37ca3acf324a78b118", "filename": "src/test/ui/const-generics/issues/issue-86033.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86033.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+pub trait IsTrue<const T: bool> {}\n+impl IsTrue<true> for () {}\n+\n+pub trait IsZST {}\n+\n+impl<T> IsZST for T\n+where\n+    (): IsTrue<{ std::mem::size_of::<T>() == 0 }>\n+{}\n+\n+fn _func() -> impl IsZST {\n+    || {}\n+}\n+\n+fn main() {}"}, {"sha": "914047236ab5d3d7a7c70dec1e1e450451a1419d", "filename": "src/test/ui/const-generics/issues/issue-88468.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-88468.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(generic_const_exprs)]\n+\n+pub struct Assert<const COND: bool>();\n+pub trait IsTrue {}\n+impl IsTrue for Assert<true> {}\n+\n+pub trait IsNotZST {}\n+impl<T> IsNotZST for T where Assert<{ std::mem::size_of::<T>() > 0 }>: IsTrue {}\n+\n+fn main() {}"}, {"sha": "0c640a5ef7136c12f79c593b38e586f565df9b10", "filename": "src/test/ui/const-generics/issues/issue-90318.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_type_id)]\n+#![feature(generic_const_exprs)]\n+#![feature(core_intrinsics)]\n+#![allow(incomplete_features)]\n+\n+use std::any::TypeId;\n+\n+struct If<const B: bool>;\n+pub trait True {}\n+impl True for If<true> {}\n+\n+fn consume<T: 'static>(_val: T)\n+where\n+    If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+    //~^ ERROR: overly complex generic constant\n+    //~| ERROR: calls in constants are limited to constant functions\n+{\n+}\n+\n+fn test<T: 'static>()\n+where\n+    If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+    //~^ ERROR: overly complex generic constant\n+    //~| ERROR: calls in constants are limited to constant functions\n+{\n+}\n+\n+fn main() {\n+    let a = ();\n+    consume(0i32);\n+    consume(a);\n+}"}, {"sha": "2b8afe2ef09ed77040bf834394fce922a2008c60", "filename": "src/test/ui/const-generics/issues/issue-90318.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c185610ebc19a0fc22e68472483dc69ea10b92fd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr?ref=c185610ebc19a0fc22e68472483dc69ea10b92fd", "patch": "@@ -0,0 +1,37 @@\n+error: overly complex generic constant\n+  --> $DIR/issue-90318.rs:14:8\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |        ^^-----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          borrowing is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n+\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-90318.rs:14:10\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: overly complex generic constant\n+  --> $DIR/issue-90318.rs:22:8\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |        ^^-----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          borrowing is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n+\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-90318.rs:22:10\n+   |\n+LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}]}