{"sha": "cd74364e5ddd3e81fa27ea149194966a3a172d9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNzQzNjRlNWRkZDNlODFmYTI3ZWExNDkxOTQ5NjZhM2ExNzJkOWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-12-11T20:42:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-12-22T06:05:37Z"}, "message": "std: Use cfg(target_thread_local) in thread_local!\n\nThis transitions the standard library's `thread_local!` macro to use the\nfreshly-added and gated `#[cfg(target_thread_local)]` attribute. This greatly\nsimplifies the `#[cfg]` logic in play here, but requires that the standard\nlibrary expose both the OS and ELF TLS implementation modules as unstable\nimplementation details.\n\nThe implementation details were shuffled around a bit but end up generally\ncompiling to the same thing.\n\nCloses #26581 (this supersedes the need for the option)\nCloses #27057 (this also starts ignoring the option)", "tree": {"sha": "d2a50c7c82e12dead2efa2c4797bae2120d08b61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2a50c7c82e12dead2efa2c4797bae2120d08b61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd74364e5ddd3e81fa27ea149194966a3a172d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd74364e5ddd3e81fa27ea149194966a3a172d9b", "html_url": "https://github.com/rust-lang/rust/commit/cd74364e5ddd3e81fa27ea149194966a3a172d9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd74364e5ddd3e81fa27ea149194966a3a172d9b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "617a7af70400c7a3f82fafcb50daf01f01db95a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/617a7af70400c7a3f82fafcb50daf01f01db95a0", "html_url": "https://github.com/rust-lang/rust/commit/617a7af70400c7a3f82fafcb50daf01f01db95a0"}], "stats": {"total": 128, "additions": 50, "deletions": 78}, "files": [{"sha": "01bf514755702b95a6c650422d37a9196b98ccfa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cd74364e5ddd3e81fa27ea149194966a3a172d9b", "patch": "@@ -227,6 +227,7 @@\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cfg_target_vendor)]\n+#![feature(cfg_target_thread_local)]\n #![feature(char_internals)]\n #![feature(clone_from_slice)]\n #![feature(collections)]"}, {"sha": "ca0f10315625304313699bbf75ca67268cf68965", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 44, "deletions": 76, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=cd74364e5ddd3e81fa27ea149194966a3a172d9b", "patch": "@@ -15,10 +15,6 @@\n use cell::UnsafeCell;\n use mem;\n \n-// Sure wish we had macro hygiene, no?\n-#[doc(hidden)]\n-pub use self::imp::Key as __KeyInner;\n-\n /// A thread local storage key which owns its contents.\n ///\n /// This key uses the fastest possible implementation available to it for the\n@@ -61,78 +57,42 @@ pub use self::imp::Key as __KeyInner;\n /// });\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LocalKey<T:'static> {\n-    // The key itself may be tagged with #[thread_local], and this `Key` is\n-    // stored as a `static`, and it's not valid for a static to reference the\n-    // address of another thread_local static. For this reason we kinda wonkily\n-    // work around this by generating a shim function which will give us the\n-    // address of the inner TLS key at runtime.\n+pub struct LocalKey<T: 'static> {\n+    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n+    // but actual data inside will sometimes be tagged with #[thread_local].\n+    // It's not valid for a true static to reference a #[thread_local] static,\n+    // so we get around that by exposing an accessor through a layer of function\n+    // indirection (this thunk).\n+    //\n+    // Note that the thunk is itself unsafe because the returned lifetime of the\n+    // slot where data lives, `'static`, is not actually valid. The lifetime\n+    // here is actually `'thread`!\n     //\n-    // This is trivially devirtualizable by LLVM because we never store anything\n-    // to this field and rustc can declare the `static` as constant as well.\n-    inner: fn() -> &'static __KeyInner<T>,\n+    // Although this is an extra layer of indirection, it should in theory be\n+    // trivially devirtualizable by LLVM because the value of `inner` never\n+    // changes and the constant should be readonly within a crate. This mainly\n+    // only runs into problems when TLS statics are exported across crates.\n+    inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     init: fn() -> T,\n }\n \n-// Macro pain #4586:\n-//\n-// When cross compiling, rustc will load plugins and macros from the *host*\n-// platform before search for macros from the target platform. This is primarily\n-// done to detect, for example, plugins. Ideally the macro below would be\n-// defined once per module below, but unfortunately this means we have the\n-// following situation:\n-//\n-// 1. We compile libstd for x86_64-unknown-linux-gnu, this thread_local!() macro\n-//    will inject #[thread_local] statics.\n-// 2. We then try to compile a program for arm-linux-androideabi\n-// 3. The compiler has a host of linux and a target of android, so it loads\n-//    macros from the *linux* libstd.\n-// 4. The macro generates a #[thread_local] field, but the android libstd does\n-//    not use #[thread_local]\n-// 5. Compile error about structs with wrong fields.\n-//\n-// To get around this, we're forced to inject the #[cfg] logic into the macro\n-// itself. Woohoo.\n-\n /// Declare a new thread local storage key of type `std::thread::LocalKey`.\n ///\n /// See [LocalKey documentation](thread/struct.LocalKey.html) for more\n /// information.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-#[cfg(not(no_elf_tls))]\n-macro_rules! thread_local {\n-    (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init,\n-                #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                               not(target_arch = \"aarch64\")),\n-                           thread_local)]);\n-    );\n-    (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init,\n-                #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                               not(target_arch = \"aarch64\")),\n-                           thread_local)]);\n-    );\n-}\n-\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-#[cfg(no_elf_tls)]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init, #[]);\n+            __thread_local_inner!($t, $init);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         pub static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init, #[]);\n+            __thread_local_inner!($t, $init);\n     );\n }\n \n@@ -143,12 +103,25 @@ macro_rules! thread_local {\n #[macro_export]\n #[allow_internal_unstable]\n macro_rules! __thread_local_inner {\n-    ($t:ty, $init:expr, #[$($attr:meta),*]) => {{\n-        $(#[$attr])*\n-        static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-            $crate::thread::__LocalKeyInner::new();\n+    ($t:ty, $init:expr) => {{\n         fn __init() -> $t { $init }\n-        fn __getit() -> &'static $crate::thread::__LocalKeyInner<$t> { &__KEY }\n+\n+        unsafe fn __getit() -> $crate::option::Option<\n+            &'static $crate::cell::UnsafeCell<\n+                $crate::option::Option<$t>>>\n+        {\n+            #[thread_local]\n+            #[cfg(target_thread_local)]\n+            static __KEY: $crate::thread::__ElfLocalKeyInner<$t> =\n+                $crate::thread::__ElfLocalKeyInner::new();\n+\n+            #[cfg(not(target_thread_local))]\n+            static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                $crate::thread::__OsLocalKeyInner::new();\n+\n+            __KEY.get()\n+        }\n+\n         $crate::thread::LocalKey::new(__getit, __init)\n     }}\n }\n@@ -190,11 +163,11 @@ impl<T: 'static> LocalKey<T> {\n     #[unstable(feature = \"thread_local_internals\",\n                reason = \"recently added to create a key\",\n                issue = \"0\")]\n-    pub const fn new(inner: fn() -> &'static __KeyInner<T>,\n+    pub const fn new(inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n                      init: fn() -> T) -> LocalKey<T> {\n         LocalKey {\n             inner: inner,\n-            init: init\n+            init: init,\n         }\n     }\n \n@@ -211,10 +184,10 @@ impl<T: 'static> LocalKey<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n-        let slot = (self.inner)();\n         unsafe {\n-            let slot = slot.get().expect(\"cannot access a TLS value during or \\\n-                                          after it is destroyed\");\n+            let slot = (self.inner)();\n+            let slot = slot.expect(\"cannot access a TLS value during or \\\n+                                    after it is destroyed\");\n             f(match *slot.get() {\n                 Some(ref inner) => inner,\n                 None => self.init(slot),\n@@ -270,7 +243,7 @@ impl<T: 'static> LocalKey<T> {\n                issue = \"27716\")]\n     pub fn state(&'static self) -> LocalKeyState {\n         unsafe {\n-            match (self.inner)().get() {\n+            match (self.inner)() {\n                 Some(cell) => {\n                     match *cell.get() {\n                         Some(..) => LocalKeyState::Valid,\n@@ -283,11 +256,9 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n-#[cfg(all(any(target_os = \"macos\", target_os = \"linux\"),\n-          not(target_arch = \"aarch64\"),\n-          not(no_elf_tls)))]\n+#[cfg(target_thread_local)]\n #[doc(hidden)]\n-mod imp {\n+pub mod elf {\n     use cell::{Cell, UnsafeCell};\n     use intrinsics;\n     use ptr;\n@@ -431,11 +402,8 @@ mod imp {\n     }\n }\n \n-#[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")),\n-          target_arch = \"aarch64\",\n-          no_elf_tls))]\n #[doc(hidden)]\n-mod imp {\n+pub mod os {\n     use prelude::v1::*;\n \n     use cell::{Cell, UnsafeCell};"}, {"sha": "0e525f394216c9bdadef5d415f8e40e54fd16a9b", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=cd74364e5ddd3e81fa27ea149194966a3a172d9b", "patch": "@@ -191,7 +191,10 @@ pub use self::local::{LocalKey, LocalKeyState};\n pub use self::scoped_tls::ScopedKey;\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n-#[doc(hidden)] pub use self::local::__KeyInner as __LocalKeyInner;\n+#[cfg(target_thread_local)]\n+#[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n+#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n+#[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::scoped_tls::__KeyInner as __ScopedKeyInner;\n "}, {"sha": "4ea0fd76fea4a6c38868651b0a34eb188f4aa4ae", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd74364e5ddd3e81fa27ea149194966a3a172d9b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=cd74364e5ddd3e81fa27ea149194966a3a172d9b", "patch": "@@ -238,7 +238,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"type_ascription\", \"1.6.0\", Some(23416), Active),\n \n     // Allows cfg(target_thread_local)\n-    (\"cfg_target_thread_local\", \"1.7.0\", Some(26581), Active),\n+    (\"cfg_target_thread_local\", \"1.7.0\", Some(29594), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n "}]}