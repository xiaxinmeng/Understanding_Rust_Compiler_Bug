{"sha": "56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MTI5ZDM5YzBkNmYwZTE1ZTJmNGZjNDBiODA3OWI4YjIyZTM0ZmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-02T10:18:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-02T10:41:38Z"}, "message": "flt2dec: properly handle uninitialized memory", "tree": {"sha": "9fb7d137b77a70a9c9cd7bd98ca2b27a3fc4a508", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb7d137b77a70a9c9cd7bd98ca2b27a3fc4a508"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "html_url": "https://github.com/rust-lang/rust/commit/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9cd4a33f53689bc0847775669a14f666a138fd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9cd4a33f53689bc0847775669a14f666a138fd7", "html_url": "https://github.com/rust-lang/rust/commit/d9cd4a33f53689bc0847775669a14f666a138fd7"}], "stats": {"total": 680, "additions": 387, "deletions": 293}, "files": [{"sha": "319b9773e49fee6042cbcb8cd67d82ed80b268bb", "filename": "library/core/benches/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -1,59 +1,76 @@\n use super::super::*;\n use core::num::flt2dec::strategy::dragon::*;\n+use std::mem::MaybeUninit;\n use test::Bencher;\n \n #[bench]\n fn bench_small_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n+    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n+    b.iter(|| {\n+        format_shortest(&decoded, &mut buf);\n+    });\n }\n \n #[bench]\n fn bench_big_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n+    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n+    b.iter(|| {\n+        format_shortest(&decoded, &mut buf);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 3];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 3];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 12];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 12];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 1024];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 1024];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }"}, {"sha": "76425731e1ddda955c2bae64ed8f0a73c36f871b", "filename": "library/core/benches/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -1,5 +1,6 @@\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n+use std::mem::MaybeUninit;\n use test::Bencher;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n@@ -12,55 +13,71 @@ pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n #[bench]\n fn bench_small_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n+    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n+    b.iter(|| {\n+        format_shortest(&decoded, &mut buf);\n+    });\n }\n \n #[bench]\n fn bench_big_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; MAX_SIG_DIGITS];\n-    b.iter(|| format_shortest(&decoded, &mut buf));\n+    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n+    b.iter(|| {\n+        format_shortest(&decoded, &mut buf);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 3];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 3];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 3];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 12];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 12];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 12];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_small_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 1024];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }\n \n #[bench]\n fn bench_big_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n-    let mut buf = [0; 1024];\n-    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+    let mut buf = [MaybeUninit::new(0); 1024];\n+    b.iter(|| {\n+        format_exact(&decoded, &mut buf, i16::MIN);\n+    });\n }"}, {"sha": "5908da477e11e55a66cb7d97ca64da796699f15f", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 48, "deletions": 68, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -14,25 +14,17 @@ fn float_to_decimal_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n-    unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n-        // FIXME(#76092): This is calling `assume_init_mut` on an uninitialized\n-        // `MaybeUninit` (here and elsewhere in this file). Revisit this once\n-        // we decided whether that is valid or not.\n-        // We can do this only because we are libstd and coupled to the compiler.\n-        // (FWIW, using `freeze` would not be enough; `flt2dec::Part` is an enum!)\n-        let formatted = flt2dec::to_exact_fixed_str(\n-            flt2dec::strategy::grisu::format_exact,\n-            *num,\n-            sign,\n-            precision,\n-            buf.assume_init_mut(),\n-            parts.assume_init_mut(),\n-        );\n-        fmt.pad_formatted_parts(&formatted)\n-    }\n+    let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n+    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n+    let formatted = flt2dec::to_exact_fixed_str(\n+        flt2dec::strategy::grisu::format_exact,\n+        *num,\n+        sign,\n+        precision,\n+        &mut buf,\n+        &mut parts,\n+    );\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -47,22 +39,18 @@ fn float_to_decimal_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n-    unsafe {\n-        // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n-        let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n-        // FIXME(#76092)\n-        let formatted = flt2dec::to_shortest_str(\n-            flt2dec::strategy::grisu::format_shortest,\n-            *num,\n-            sign,\n-            precision,\n-            buf.assume_init_mut(),\n-            parts.assume_init_mut(),\n-        );\n-        fmt.pad_formatted_parts(&formatted)\n-    }\n+    // enough for f32 and f64\n+    let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n+    let formatted = flt2dec::to_shortest_str(\n+        flt2dec::strategy::grisu::format_shortest,\n+        *num,\n+        sign,\n+        precision,\n+        &mut buf,\n+        &mut parts,\n+    );\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n // Common code of floating point Debug and Display.\n@@ -103,22 +91,18 @@ fn float_to_exponential_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n-    unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n-        // FIXME(#76092)\n-        let formatted = flt2dec::to_exact_exp_str(\n-            flt2dec::strategy::grisu::format_exact,\n-            *num,\n-            sign,\n-            precision,\n-            upper,\n-            buf.assume_init_mut(),\n-            parts.assume_init_mut(),\n-        );\n-        fmt.pad_formatted_parts(&formatted)\n-    }\n+    let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n+    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n+    let formatted = flt2dec::to_exact_exp_str(\n+        flt2dec::strategy::grisu::format_exact,\n+        *num,\n+        sign,\n+        precision,\n+        upper,\n+        &mut buf,\n+        &mut parts,\n+    );\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -133,23 +117,19 @@ fn float_to_exponential_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n-    unsafe {\n-        // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n-        let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n-        // FIXME(#76092)\n-        let formatted = flt2dec::to_shortest_exp_str(\n-            flt2dec::strategy::grisu::format_shortest,\n-            *num,\n-            sign,\n-            (0, 0),\n-            upper,\n-            buf.assume_init_mut(),\n-            parts.assume_init_mut(),\n-        );\n-        fmt.pad_formatted_parts(&formatted)\n-    }\n+    // enough for f32 and f64\n+    let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n+    let formatted = flt2dec::to_shortest_exp_str(\n+        flt2dec::strategy::grisu::format_shortest,\n+        *num,\n+        sign,\n+        (0, 0),\n+        upper,\n+        &mut buf,\n+        &mut parts,\n+    );\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n // Common code of floating point LowerExp and UpperExp."}, {"sha": "1f28edb41282748bb64cf94207979809244de021", "filename": "library/core/src/num/flt2dec/mod.rs", "status": "modified", "additions": 128, "deletions": 98, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -124,6 +124,8 @@ functions.\n \n pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n \n+use crate::mem::MaybeUninit;\n+\n pub mod decoder;\n pub mod estimator;\n \n@@ -140,23 +142,23 @@ pub mod strategy {\n /// The exact formula is `ceil(# bits in mantissa * log_10 2 + 1)`.\n pub const MAX_SIG_DIGITS: usize = 17;\n \n-/// When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n-/// Returns a next digit when it causes the length change.\n+/// When `d` contains decimal digits, increase the last digit and propagate carry.\n+/// Returns a next digit when it causes the length to change.\n #[doc(hidden)]\n-pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n-    match d[..n].iter().rposition(|&c| c != b'9') {\n+pub fn round_up(d: &mut [u8]) -> Option<u8> {\n+    match d.iter().rposition(|&c| c != b'9') {\n         Some(i) => {\n             // d[i+1..n] is all nines\n             d[i] += 1;\n-            for j in i + 1..n {\n+            for j in i + 1..d.len() {\n                 d[j] = b'0';\n             }\n             None\n         }\n-        None if n > 0 => {\n+        None if d.len() > 0 => {\n             // 999..999 rounds to 1000..000 with an increased exponent\n             d[0] = b'1';\n-            for j in 1..n {\n+            for j in 1..d.len() {\n                 d[j] = b'0';\n             }\n             Some(b'0')\n@@ -281,7 +283,7 @@ fn digits_to_dec_str<'a>(\n     buf: &'a [u8],\n     exp: i16,\n     frac_digits: usize,\n-    parts: &'a mut [Part<'a>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n@@ -303,38 +305,44 @@ fn digits_to_dec_str<'a>(\n     if exp <= 0 {\n         // the decimal point is before rendered digits: [0.][000...000][1234][____]\n         let minus_exp = -(exp as i32) as usize;\n-        parts[0] = Part::Copy(b\"0.\");\n-        parts[1] = Part::Zero(minus_exp);\n-        parts[2] = Part::Copy(buf);\n+        parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n+        parts[1] = MaybeUninit::new(Part::Zero(minus_exp));\n+        parts[2] = MaybeUninit::new(Part::Copy(buf));\n         if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n-            parts[3] = Part::Zero((frac_digits - buf.len()) - minus_exp);\n-            &parts[..4]\n+            parts[3] = MaybeUninit::new(Part::Zero((frac_digits - buf.len()) - minus_exp));\n+            // SAFETY: we just initialized the elements `..4`.\n+            unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n         } else {\n-            &parts[..3]\n+            // SAFETY: we just initialized the elements `..3`.\n+            unsafe { MaybeUninit::slice_get_ref(&parts[..3]) }\n         }\n     } else {\n         let exp = exp as usize;\n         if exp < buf.len() {\n             // the decimal point is inside rendered digits: [12][.][34][____]\n-            parts[0] = Part::Copy(&buf[..exp]);\n-            parts[1] = Part::Copy(b\".\");\n-            parts[2] = Part::Copy(&buf[exp..]);\n+            parts[0] = MaybeUninit::new(Part::Copy(&buf[..exp]));\n+            parts[1] = MaybeUninit::new(Part::Copy(b\".\"));\n+            parts[2] = MaybeUninit::new(Part::Copy(&buf[exp..]));\n             if frac_digits > buf.len() - exp {\n-                parts[3] = Part::Zero(frac_digits - (buf.len() - exp));\n-                &parts[..4]\n+                parts[3] = MaybeUninit::new(Part::Zero(frac_digits - (buf.len() - exp)));\n+                // SAFETY: we just initialized the elements `..4`.\n+                unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n             } else {\n-                &parts[..3]\n+                // SAFETY: we just initialized the elements `..3`.\n+                unsafe { MaybeUninit::slice_get_ref(&parts[..3]) }\n             }\n         } else {\n             // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n-            parts[0] = Part::Copy(buf);\n-            parts[1] = Part::Zero(exp - buf.len());\n+            parts[0] = MaybeUninit::new(Part::Copy(buf));\n+            parts[1] = MaybeUninit::new(Part::Zero(exp - buf.len()));\n             if frac_digits > 0 {\n-                parts[2] = Part::Copy(b\".\");\n-                parts[3] = Part::Zero(frac_digits);\n-                &parts[..4]\n+                parts[2] = MaybeUninit::new(Part::Copy(b\".\"));\n+                parts[3] = MaybeUninit::new(Part::Zero(frac_digits));\n+                // SAFETY: we just initialized the elements `..4`.\n+                unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n             } else {\n-                &parts[..2]\n+                // SAFETY: we just initialized the elements `..2`.\n+                unsafe { MaybeUninit::slice_get_ref(&parts[..2]) }\n             }\n         }\n     }\n@@ -354,37 +362,38 @@ fn digits_to_exp_str<'a>(\n     exp: i16,\n     min_ndigits: usize,\n     upper: bool,\n-    parts: &'a mut [Part<'a>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 6);\n \n     let mut n = 0;\n \n-    parts[n] = Part::Copy(&buf[..1]);\n+    parts[n] = MaybeUninit::new(Part::Copy(&buf[..1]));\n     n += 1;\n \n     if buf.len() > 1 || min_ndigits > 1 {\n-        parts[n] = Part::Copy(b\".\");\n-        parts[n + 1] = Part::Copy(&buf[1..]);\n+        parts[n] = MaybeUninit::new(Part::Copy(b\".\"));\n+        parts[n + 1] = MaybeUninit::new(Part::Copy(&buf[1..]));\n         n += 2;\n         if min_ndigits > buf.len() {\n-            parts[n] = Part::Zero(min_ndigits - buf.len());\n+            parts[n] = MaybeUninit::new(Part::Zero(min_ndigits - buf.len()));\n             n += 1;\n         }\n     }\n \n     // 0.1234 x 10^exp = 1.234 x 10^(exp-1)\n     let exp = exp as i32 - 1; // avoid underflow when exp is i16::MIN\n     if exp < 0 {\n-        parts[n] = Part::Copy(if upper { b\"E-\" } else { b\"e-\" });\n-        parts[n + 1] = Part::Num(-exp as u16);\n+        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E-\" } else { b\"e-\" }));\n+        parts[n + 1] = MaybeUninit::new(Part::Num(-exp as u16));\n     } else {\n-        parts[n] = Part::Copy(if upper { b\"E\" } else { b\"e\" });\n-        parts[n + 1] = Part::Num(exp as u16);\n+        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E\" } else { b\"e\" }));\n+        parts[n + 1] = MaybeUninit::new(Part::Num(exp as u16));\n     }\n-    &parts[..n + 2]\n+    // SAFETY: we just initialized the elements `..n + 2`.\n+    unsafe { MaybeUninit::slice_get_ref(&parts[..n + 2]) }\n }\n \n /// Sign formatting options.\n@@ -446,6 +455,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_shortest` should be the underlying digit-generation function.\n+/// It should return the part of the buffer that it initialized.\n /// You probably would want `strategy::grisu::format_shortest` for this.\n ///\n /// `frac_digits` can be less than the number of actual fractional digits in `v`;\n@@ -461,12 +471,12 @@ pub fn to_shortest_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    buf: &'a mut [u8],\n-    parts: &'a mut [Part<'a>],\n+    buf: &'a mut [MaybeUninit<u8>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> Formatted<'a>\n where\n     T: DecodableFloat,\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     assert!(parts.len() >= 4);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n@@ -475,27 +485,31 @@ where\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 {\n                 // [0.][0000]\n-                parts[0] = Part::Copy(b\"0.\");\n-                parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign, parts: &parts[..2] }\n+                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n+                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n+                // SAFETY: we just initialized the elements `..2`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n             } else {\n-                parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign, parts: &parts[..1] }\n+                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n+                // SAFETY: we just initialized the elements `..1`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n-            let (len, exp) = format_shortest(decoded, buf);\n-            Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            let (buf, exp) = format_shortest(decoded, buf);\n+            Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n         }\n     }\n }\n@@ -509,6 +523,7 @@ where\n /// an empty string if no sign is rendered).\n ///\n /// `format_shortest` should be the underlying digit-generation function.\n+/// It should return the part of the buffer that it initialized.\n /// You probably would want `strategy::grisu::format_shortest` for this.\n ///\n /// The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n@@ -525,12 +540,12 @@ pub fn to_shortest_exp_str<'a, T, F>(\n     sign: Sign,\n     dec_bounds: (i16, i16),\n     upper: bool,\n-    buf: &'a mut [u8],\n-    parts: &'a mut [Part<'a>],\n+    buf: &'a mut [MaybeUninit<u8>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> Formatted<'a>\n where\n     T: DecodableFloat,\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     assert!(parts.len() >= 6);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n@@ -540,28 +555,31 @@ where\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n-                Part::Copy(b\"0\")\n+                MaybeUninit::new(Part::Copy(b\"0\"))\n             } else {\n-                Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" })\n+                MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }))\n             };\n-            Formatted { sign, parts: &parts[..1] }\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Finite(ref decoded) => {\n-            let (len, exp) = format_shortest(decoded, buf);\n+            let (buf, exp) = format_shortest(decoded, buf);\n             let vis_exp = exp as i32 - 1;\n             let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n-                digits_to_dec_str(&buf[..len], exp, 0, parts)\n+                digits_to_dec_str(buf, exp, 0, parts)\n             } else {\n-                digits_to_exp_str(&buf[..len], exp, 0, upper, parts)\n+                digits_to_exp_str(buf, exp, 0, upper, parts)\n             };\n             Formatted { sign, parts }\n         }\n@@ -600,6 +618,7 @@ fn estimate_max_buf_len(exp: i16) -> usize {\n /// an empty string if no sign is rendered).\n ///\n /// `format_exact` should be the underlying digit-generation function.\n+/// It should return the part of the buffer that it initialized.\n /// You probably would want `strategy::grisu::format_exact` for this.\n ///\n /// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n@@ -613,12 +632,12 @@ pub fn to_exact_exp_str<'a, T, F>(\n     sign: Sign,\n     ndigits: usize,\n     upper: bool,\n-    buf: &'a mut [u8],\n-    parts: &'a mut [Part<'a>],\n+    buf: &'a mut [MaybeUninit<u8>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> Formatted<'a>\n where\n     T: DecodableFloat,\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     assert!(parts.len() >= 6);\n     assert!(ndigits > 0);\n@@ -627,32 +646,36 @@ where\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if ndigits > 1 {\n                 // [0.][0000][e0]\n-                parts[0] = Part::Copy(b\"0.\");\n-                parts[1] = Part::Zero(ndigits - 1);\n-                parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n-                Formatted { sign, parts: &parts[..3] }\n+                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n+                parts[1] = MaybeUninit::new(Part::Zero(ndigits - 1));\n+                parts[2] = MaybeUninit::new(Part::Copy(if upper { b\"E0\" } else { b\"e0\" }));\n+                // SAFETY: we just initialized the elements `..3`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..3]) } }\n             } else {\n-                parts[0] = Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" });\n-                Formatted { sign, parts: &parts[..1] }\n+                parts[0] = MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }));\n+                // SAFETY: we just initialized the elements `..1`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let maxlen = estimate_max_buf_len(decoded.exp);\n             assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n \n             let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n-            let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n-            Formatted { sign, parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+            let (buf, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n+            Formatted { sign, parts: digits_to_exp_str(buf, exp, ndigits, upper, parts) }\n         }\n     }\n }\n@@ -665,6 +688,7 @@ where\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_exact` should be the underlying digit-generation function.\n+/// It should return the part of the buffer that it initialized.\n /// You probably would want `strategy::grisu::format_exact` for this.\n ///\n /// The byte buffer should be enough for the output unless `frac_digits` is\n@@ -677,35 +701,39 @@ pub fn to_exact_fixed_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    buf: &'a mut [u8],\n-    parts: &'a mut [Part<'a>],\n+    buf: &'a mut [MaybeUninit<u8>],\n+    parts: &'a mut [MaybeUninit<Part<'a>>],\n ) -> Formatted<'a>\n where\n     T: DecodableFloat,\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     assert!(parts.len() >= 4);\n \n     let (negative, full_decoded) = decode(v);\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign, parts: &parts[..1] }\n+            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n+            // SAFETY: we just initialized the elements `..1`.\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 {\n                 // [0.][0000]\n-                parts[0] = Part::Copy(b\"0.\");\n-                parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign, parts: &parts[..2] }\n+                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n+                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n+                // SAFETY: we just initialized the elements `..2`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n             } else {\n-                parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign, parts: &parts[..1] }\n+                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n+                // SAFETY: we just initialized the elements `..1`.\n+                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -716,23 +744,25 @@ where\n             // `format_exact` will end rendering digits much earlier in this case,\n             // because we are strictly limited by `maxlen`.\n             let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n-            let (len, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n+            let (buf, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n             if exp <= limit {\n                 // the restriction couldn't been met, so this should render like zero no matter\n                 // `exp` was. this does not include the case that the restriction has been met\n                 // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n-                debug_assert_eq!(len, 0);\n+                debug_assert_eq!(buf.len(), 0);\n                 if frac_digits > 0 {\n                     // [0.][0000]\n-                    parts[0] = Part::Copy(b\"0.\");\n-                    parts[1] = Part::Zero(frac_digits);\n-                    Formatted { sign, parts: &parts[..2] }\n+                    parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n+                    parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n+                    // SAFETY: we just initialized the elements `..2`.\n+                    Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n                 } else {\n-                    parts[0] = Part::Copy(b\"0\");\n-                    Formatted { sign, parts: &parts[..1] }\n+                    parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n+                    // SAFETY: we just initialized the elements `..1`.\n+                    Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n                 }\n             } else {\n-                Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+                Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n             }\n         }\n     }"}, {"sha": "8cb6763cdbe455bf38a3224c9ca031e71a0b3ec7", "filename": "library/core/src/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -5,6 +5,7 @@\n //!   quickly and accurately. SIGPLAN Not. 31, 5 (May. 1996), 108-116.\n \n use crate::cmp::Ordering;\n+use crate::mem::MaybeUninit;\n \n use crate::num::bignum::Big32x40 as Big;\n use crate::num::bignum::Digit32 as Digit;\n@@ -97,7 +98,10 @@ fn div_rem_upto_16<'a>(\n }\n \n /// The shortest mode implementation for Dragon.\n-pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+pub fn format_shortest<'a>(\n+    d: &Decoded,\n+    buf: &'a mut [MaybeUninit<u8>],\n+) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n     // the number `v` to format is known to be:\n     // - equal to `mant * 2^exp`;\n     // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n@@ -186,7 +190,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // generate one digit: `d[n] = floor(mant / scale) < 10`.\n         let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n         debug_assert!(d < 10);\n-        buf[i] = b'0' + d;\n+        buf[i] = MaybeUninit::new(b'0' + d);\n         i += 1;\n \n         // this is a simplified description of the modified Dragon algorithm.\n@@ -241,18 +245,24 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // if rounding up changes the length, the exponent should also change.\n         // it seems that this condition is very hard to satisfy (possibly impossible),\n         // but we are just being safe and consistent here.\n-        if let Some(c) = round_up(buf, i) {\n-            buf[i] = c;\n+        // SAFETY: we initialized that memory above.\n+        if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) }) {\n+            buf[i] = MaybeUninit::new(c);\n             i += 1;\n             k += 1;\n         }\n     }\n \n-    (i, k)\n+    // SAFETY: we initialized that memory above.\n+    (unsafe { MaybeUninit::slice_get_ref(&buf[..i]) }, k)\n }\n \n /// The exact and fixed mode implementation for Dragon.\n-pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+pub fn format_exact<'a>(\n+    d: &Decoded,\n+    buf: &'a mut [MaybeUninit<u8>],\n+    limit: i16,\n+) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n     assert!(d.plus > 0);\n@@ -319,9 +329,10 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n                 // following digits are all zeroes, we stop here\n                 // do *not* try to perform rounding! rather, fill remaining digits.\n                 for c in &mut buf[i..len] {\n-                    *c = b'0';\n+                    *c = MaybeUninit::new(b'0');\n                 }\n-                return (len, k);\n+                // SAFETY: we initialized that memory above.\n+                return (unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, k);\n             }\n \n             let mut d = 0;\n@@ -343,7 +354,7 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n             }\n             debug_assert!(mant < scale);\n             debug_assert!(d < 10);\n-            buf[i] = b'0' + d;\n+            buf[i] = MaybeUninit::new(b'0' + d);\n             mant.mul_small(10);\n         }\n     }\n@@ -353,21 +364,25 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n     if order == Ordering::Greater\n-        || (order == Ordering::Equal && (len == 0 || buf[len - 1] & 1 == 1))\n+        || (order == Ordering::Equal\n+            // SAFETY: `buf[len-1]` is initialized.\n+            && (len == 0 || unsafe { buf[len - 1].assume_init() } & 1 == 1))\n     {\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n-        if let Some(c) = round_up(buf, len) {\n+        // SAFETY: we initialized that memory above.\n+        if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..len]) }) {\n             // ...unless we've been requested the fixed precision instead.\n             // we also need to check that, if the original buffer was empty,\n             // the additional digit can only be added when `k == limit` (edge case).\n             k += 1;\n             if k > limit && len < buf.len() {\n-                buf[len] = c;\n+                buf[len] = MaybeUninit::new(c);\n                 len += 1;\n             }\n         }\n     }\n \n-    (len, k)\n+    // SAFETY: we initialized that memory above.\n+    (unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, k)\n }"}, {"sha": "ed1dd654a3add2d6dcee24981958c0940c5184b0", "filename": "library/core/src/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -5,6 +5,7 @@\n //! [^1]: Florian Loitsch. 2010. Printing floating-point numbers quickly and\n //!   accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n \n+use crate::mem::MaybeUninit;\n use crate::num::diy_float::Fp;\n use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n@@ -161,10 +162,10 @@ pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n /// The shortest mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_shortest_opt(\n+pub fn format_shortest_opt<'a>(\n     d: &Decoded,\n-    buf: &mut [u8],\n-) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+    buf: &'a mut [MaybeUninit<u8>],\n+) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n     assert!(d.plus > 0);\n@@ -266,14 +267,23 @@ pub fn format_shortest_opt(\n         let q = remainder / ten_kappa;\n         let r = remainder % ten_kappa;\n         debug_assert!(q < 10);\n-        buf[i] = b'0' + q as u8;\n+        buf[i] = MaybeUninit::new(b'0' + q as u8);\n         i += 1;\n \n         let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n         if plus1rem < delta1 {\n             // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n             let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n-            return round_and_weed(&mut buf[..i], exp, plus1rem, delta1, plus1 - v.f, ten_kappa, 1);\n+            return round_and_weed(\n+                // SAFETY: we initialized that memory above.\n+                unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) },\n+                exp,\n+                plus1rem,\n+                delta1,\n+                plus1 - v.f,\n+                ten_kappa,\n+                1,\n+            );\n         }\n \n         // break the loop when we have rendered all integral digits.\n@@ -310,13 +320,14 @@ pub fn format_shortest_opt(\n         let q = remainder >> e;\n         let r = remainder & ((1 << e) - 1);\n         debug_assert!(q < 10);\n-        buf[i] = b'0' + q as u8;\n+        buf[i] = MaybeUninit::new(b'0' + q as u8);\n         i += 1;\n \n         if r < threshold {\n             let ten_kappa = 1 << e; // implicit divisor\n             return round_and_weed(\n-                &mut buf[..i],\n+                // SAFETY: we initialized that memory above.\n+                unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) },\n                 exp,\n                 r,\n                 threshold,\n@@ -355,7 +366,7 @@ pub fn format_shortest_opt(\n         plus1v: u64,\n         ten_kappa: u64,\n         ulp: u64,\n-    ) -> Option<(usize, i16)> {\n+    ) -> Option<(&[u8], i16)> {\n         assert!(!buf.is_empty());\n \n         // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n@@ -437,20 +448,22 @@ pub fn format_shortest_opt(\n         // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n         // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n         // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n-        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp {\n-            Some((buf.len(), exp))\n-        } else {\n-            None\n-        }\n+        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp { Some((buf, exp)) } else { None }\n     }\n }\n \n /// The shortest mode implementation for Grisu with Dragon fallback.\n ///\n /// This should be used for most cases.\n-pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+pub fn format_shortest<'a>(\n+    d: &Decoded,\n+    buf: &'a mut [MaybeUninit<u8>],\n+) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n     use crate::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    match format_shortest_opt(d, buf) {\n+    // SAFETY: The borrow checker is not smart enough to let us use `buf`\n+    // in the second branch, so we launder the lifetime here. But we only re-use\n+    // `buf` if `format_shortest_opt` returned `None` so this is okay.\n+    match format_shortest_opt(d, unsafe { &mut *(buf as *mut _) }) {\n         Some(ret) => ret,\n         None => fallback(d, buf),\n     }\n@@ -459,11 +472,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n /// The exact and fixed mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_exact_opt(\n+pub fn format_exact_opt<'a>(\n     d: &Decoded,\n-    buf: &mut [u8],\n+    buf: &'a mut [MaybeUninit<u8>],\n     limit: i16,\n-) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n     assert!(!buf.is_empty());\n@@ -510,7 +523,11 @@ pub fn format_exact_opt(\n         // thus we are being sloppy here and widen the error range by a factor of 10.\n         // this will increase the false negative rate, but only very, *very* slightly;\n         // it can only matter noticeably when the mantissa is bigger than 60 bits.\n-        return possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e);\n+        //\n+        // SAFETY: `len=0`, so the obligation of having initialized this memory is trivial.\n+        return unsafe {\n+            possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e)\n+        };\n     } else if ((exp as i32 - limit as i32) as usize) < buf.len() {\n         (exp - limit) as usize\n     } else {\n@@ -534,13 +551,16 @@ pub fn format_exact_opt(\n         let q = remainder / ten_kappa;\n         let r = remainder % ten_kappa;\n         debug_assert!(q < 10);\n-        buf[i] = b'0' + q as u8;\n+        buf[i] = MaybeUninit::new(b'0' + q as u8);\n         i += 1;\n \n         // is the buffer full? run the rounding pass with the remainder.\n         if i == len {\n             let vrem = ((r as u64) << e) + vfrac; // == (v % 10^kappa) * 2^e\n-            return possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e);\n+            // SAFETY: we have initialized `len` many bytes.\n+            return unsafe {\n+                possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e)\n+            };\n         }\n \n         // break the loop when we have rendered all integral digits.\n@@ -585,12 +605,13 @@ pub fn format_exact_opt(\n         let q = remainder >> e;\n         let r = remainder & ((1 << e) - 1);\n         debug_assert!(q < 10);\n-        buf[i] = b'0' + q as u8;\n+        buf[i] = MaybeUninit::new(b'0' + q as u8);\n         i += 1;\n \n         // is the buffer full? run the rounding pass with the remainder.\n         if i == len {\n-            return possibly_round(buf, len, exp, limit, r, 1 << e, err);\n+            // SAFETY: we have initialized `len` many bytes.\n+            return unsafe { possibly_round(buf, len, exp, limit, r, 1 << e, err) };\n         }\n \n         // restore invariants\n@@ -610,15 +631,17 @@ pub fn format_exact_opt(\n     // - `remainder = (v % 10^kappa) * k`\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn possibly_round(\n-        buf: &mut [u8],\n+    //\n+    // SAFETY: the first `len` bytes of `buf` must be initialized.\n+    unsafe fn possibly_round(\n+        buf: &mut [MaybeUninit<u8>],\n         mut len: usize,\n         mut exp: i16,\n         limit: i16,\n         remainder: u64,\n         ten_kappa: u64,\n         ulp: u64,\n-    ) -> Option<(usize, i16)> {\n+    ) -> Option<(&[u8], i16)> {\n         debug_assert!(remainder < ten_kappa);\n \n         //           10^kappa\n@@ -677,7 +700,8 @@ pub fn format_exact_opt(\n         // we've already verified that `ulp < 10^kappa / 2`, so as long as\n         // `10^kappa` did not overflow after all, the second check is fine.\n         if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n-            return Some((len, exp));\n+            // SAFETY: our caller initialized that memory.\n+            return Some((unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, exp));\n         }\n \n         //   :<------- remainder ------>|   :\n@@ -698,17 +722,19 @@ pub fn format_exact_opt(\n         // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n         // so the second check does not overflow.\n         if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n-            if let Some(c) = round_up(buf, len) {\n+            // SAFETY: our caller must have initialized that memory.\n+            if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..len]) }) {\n                 // only add an additional digit when we've been requested the fixed precision.\n                 // we also need to check that, if the original buffer was empty,\n                 // the additional digit can only be added when `exp == limit` (edge case).\n                 exp += 1;\n                 if exp > limit && len < buf.len() {\n-                    buf[len] = c;\n+                    buf[len] = MaybeUninit::new(c);\n                     len += 1;\n                 }\n             }\n-            return Some((len, exp));\n+            // SAFETY: we and our caller initialized that memory.\n+            return Some((unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, exp));\n         }\n \n         // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n@@ -720,9 +746,16 @@ pub fn format_exact_opt(\n /// The exact and fixed mode implementation for Grisu with Dragon fallback.\n ///\n /// This should be used for most cases.\n-pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+pub fn format_exact<'a>(\n+    d: &Decoded,\n+    buf: &'a mut [MaybeUninit<u8>],\n+    limit: i16,\n+) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n     use crate::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    match format_exact_opt(d, buf, limit) {\n+    // SAFETY: The borrow checker is not smart enough to let us use `buf`\n+    // in the second branch, so we launder the lifetime here. But we only re-use\n+    // `buf` if `format_exact_opt` returned `None` so this is okay.\n+    match format_exact_opt(d, unsafe { &mut *(buf as *mut _) }, limit) {\n         Some(ret) => ret,\n         None => fallback(d, buf, limit),\n     }"}, {"sha": "8e95249a79d190bec17474204a8da41290688c1c", "filename": "library/core/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -1,3 +1,4 @@\n+use std::mem::MaybeUninit;\n use std::{fmt, str};\n \n use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n@@ -36,20 +37,20 @@ macro_rules! check_shortest {\n     );\n \n     ($f:ident($v:expr) => $buf:expr, $exp:expr; $fmt:expr, $($key:ident = $val:expr),*) => ({\n-        let mut buf = [b'_'; MAX_SIG_DIGITS];\n-        let (len, k) = $f(&decode_finite($v), &mut buf);\n-        assert!((&buf[..len], k) == ($buf, $exp),\n-                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+        let mut buf = [MaybeUninit::new(b'_'); MAX_SIG_DIGITS];\n+        let (buf, k) = $f(&decode_finite($v), &mut buf);\n+        assert!((buf, k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                       expected = (str::from_utf8($buf).unwrap(), $exp),\n                       $($key = $val),*);\n     });\n \n     ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr;\n                                          $fmt:expr, $($key:ident = $val:expr),*) => ({\n-        let mut buf = [b'_'; MAX_SIG_DIGITS];\n-        let (len, k) = $f(&Decoded { $($k: $v),+ }, &mut buf);\n-        assert!((&buf[..len], k) == ($buf, $exp),\n-                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+        let mut buf = [MaybeUninit::new(b'_'); MAX_SIG_DIGITS];\n+        let (buf, k) = $f(&Decoded { $($k: $v),+ }, &mut buf);\n+        assert!((buf, k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                       expected = (str::from_utf8($buf).unwrap(), $exp),\n                       $($key = $val),*);\n     })\n@@ -58,9 +59,9 @@ macro_rules! check_shortest {\n macro_rules! try_exact {\n     ($f:ident($decoded:expr) => $buf:expr, $expected:expr, $expectedk:expr;\n                                 $fmt:expr, $($key:ident = $val:expr),*) => ({\n-        let (len, k) = $f($decoded, &mut $buf[..$expected.len()], i16::MIN);\n-        assert!((&$buf[..len], k) == ($expected, $expectedk),\n-                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+        let (buf, k) = $f($decoded, &mut $buf[..$expected.len()], i16::MIN);\n+        assert!((buf, k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                       expected = (str::from_utf8($expected).unwrap(), $expectedk),\n                       $($key = $val),*);\n     })\n@@ -69,9 +70,9 @@ macro_rules! try_exact {\n macro_rules! try_fixed {\n     ($f:ident($decoded:expr) => $buf:expr, $request:expr, $expected:expr, $expectedk:expr;\n                                 $fmt:expr, $($key:ident = $val:expr),*) => ({\n-        let (len, k) = $f($decoded, &mut $buf[..], $request);\n-        assert!((&$buf[..len], k) == ($expected, $expectedk),\n-                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+        let (buf, k) = $f($decoded, &mut $buf[..], $request);\n+        assert!((buf, k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                       expected = (str::from_utf8($expected).unwrap(), $expectedk),\n                       $($key = $val),*);\n     })\n@@ -93,10 +94,10 @@ fn ldexp_f64(a: f64, b: i32) -> f64 {\n fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\n where\n     T: DecodableFloat,\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     // use a large enough buffer\n-    let mut buf = [b'_'; 1024];\n+    let mut buf = [MaybeUninit::new(b'_'); 1024];\n     let mut expected_ = [b'_'; 1024];\n \n     let decoded = decode_finite(v);\n@@ -118,7 +119,7 @@ where\n                 // we should always return `100..00` (`i` digits) instead, since that's\n                 // what we can came up with `i` digits anyway. `round_up` assumes that\n                 // the adjustment to the length is done by caller, which we simply ignore.\n-                if let Some(_) = round_up(&mut expected_, i) {\n+                if let Some(_) = round_up(&mut expected_[..i]) {\n                     expectedk_ += 1;\n                 }\n             }\n@@ -193,10 +194,10 @@ impl TestableFloat for f64 {\n fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n where\n     T: TestableFloat,\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     // use a large enough buffer\n-    let mut buf = [b'_'; 1024];\n+    let mut buf = [MaybeUninit::new(b'_'); 1024];\n     let v: T = TestableFloat::ldexpi(x, e);\n     let decoded = decode_finite(v);\n \n@@ -230,7 +231,7 @@ macro_rules! check_exact_one {\n \n pub fn f32_shortest_sanity_test<F>(mut f: F)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     // 0.0999999940395355224609375\n     // 0.100000001490116119384765625\n@@ -277,7 +278,7 @@ where\n \n pub fn f32_exact_sanity_test<F>(mut f: F)\n where\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     let minf32 = ldexp_f32(1.0, -149);\n \n@@ -321,7 +322,7 @@ where\n \n pub fn f64_shortest_sanity_test<F>(mut f: F)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     // 0.0999999999999999777955395074968691915273...\n     // 0.1000000000000000055511151231257827021181...\n@@ -387,7 +388,7 @@ where\n \n pub fn f64_exact_sanity_test<F>(mut f: F)\n where\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     let minf64 = ldexp_f64(1.0, -1074);\n \n@@ -474,7 +475,7 @@ where\n \n pub fn more_shortest_sanity_test<F>(mut f: F)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n                       exp: 0, inclusive: true} => b\"1\", 18);\n@@ -484,10 +485,10 @@ where\n \n fn to_string_with_parts<F>(mut f: F) -> String\n where\n-    F: for<'a> FnMut(&'a mut [u8], &'a mut [Part<'a>]) -> Formatted<'a>,\n+    F: for<'a> FnMut(&'a mut [MaybeUninit<u8>], &'a mut [MaybeUninit<Part<'a>>]) -> Formatted<'a>,\n {\n-    let mut buf = [0; 1024];\n-    let mut parts = [Part::Zero(0); 16];\n+    let mut buf = [MaybeUninit::new(0); 1024];\n+    let mut parts = [MaybeUninit::new(Part::Zero(0)); 16];\n     let formatted = f(&mut buf, &mut parts);\n     let mut ret = vec![0; formatted.len()];\n     assert_eq!(formatted.write(&mut ret), Some(ret.len()));\n@@ -496,14 +497,14 @@ where\n \n pub fn to_shortest_str_test<F>(mut f_: F)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n-        F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n     {\n         to_string_with_parts(|buf, parts| {\n             to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, buf, parts)\n@@ -597,14 +598,14 @@ where\n \n pub fn to_shortest_exp_str_test<F>(mut f_: F)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String\n     where\n         T: DecodableFloat,\n-        F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n     {\n         to_string_with_parts(|buf, parts| {\n             to_shortest_exp_str(|d, b| f(d, b), v, sign, exp_bounds, upper, buf, parts)\n@@ -716,14 +717,14 @@ where\n \n pub fn to_exact_exp_str_test<F>(mut f_: F)\n where\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String\n     where\n         T: DecodableFloat,\n-        F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n     {\n         to_string_with_parts(|buf, parts| {\n             to_exact_exp_str(|d, b, l| f(d, b, l), v, sign, ndigits, upper, buf, parts)\n@@ -989,14 +990,14 @@ where\n \n pub fn to_exact_fixed_str_test<F>(mut f_: F)\n where\n-    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n {\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n-        F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n     {\n         to_string_with_parts(|buf, parts| {\n             to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, buf, parts)"}, {"sha": "57b3dcf8e1e04fed5504e48029be9d5abb97f033", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=56129d39c0d6f0e15e2f4fc40b8079b8b22e34fe", "patch": "@@ -1,5 +1,6 @@\n #![cfg(not(target_arch = \"wasm32\"))]\n \n+use std::mem::MaybeUninit;\n use std::str;\n \n use core::num::flt2dec::strategy::grisu::format_exact_opt;\n@@ -20,8 +21,8 @@ pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n \n fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n+    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n     V: FnMut(usize) -> Decoded,\n {\n     assert!(k <= 1024);\n@@ -42,21 +43,21 @@ where\n         }\n \n         let decoded = v(i);\n-        let mut buf1 = [0; 1024];\n-        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n-            let mut buf2 = [0; 1024];\n-            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n-            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n+        let mut buf1 = [MaybeUninit::new(0); 1024];\n+        if let Some((buf1, e1)) = f(&decoded, &mut buf1[..k]) {\n+            let mut buf2 = [MaybeUninit::new(0); 1024];\n+            let (buf2, e2) = g(&decoded, &mut buf2[..k]);\n+            if e1 == e2 && buf1 == buf2 {\n                 npassed += 1;\n             } else {\n                 println!(\n                     \"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n                     i,\n                     n,\n                     decoded,\n-                    str::from_utf8(&buf1[..len1]).unwrap(),\n+                    str::from_utf8(buf1).unwrap(),\n                     e1,\n-                    str::from_utf8(&buf2[..len2]).unwrap(),\n+                    str::from_utf8(buf2).unwrap(),\n                     e2\n                 );\n             }\n@@ -85,8 +86,8 @@ where\n \n pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n+    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n@@ -101,8 +102,8 @@ where\n \n pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n+    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n@@ -117,8 +118,8 @@ where\n \n pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n where\n-    F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-    G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n+    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n {\n     // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n     // so why not simply testing all of them?"}]}