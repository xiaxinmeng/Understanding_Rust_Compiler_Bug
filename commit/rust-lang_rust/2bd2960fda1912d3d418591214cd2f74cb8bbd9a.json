{"sha": "2bd2960fda1912d3d418591214cd2f74cb8bbd9a", "node_id": "C_kwDOAAsO6NoAKDJiZDI5NjBmZGExOTEyZDNkNDE4NTkxMjE0Y2QyZjc0Y2I4YmJkOWE", "commit": {"author": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2021-12-22T00:51:26Z"}, "committer": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2021-12-22T00:51:26Z"}, "message": "Don't support if-let branches", "tree": {"sha": "4cd029d4586860fe8c2a5ca9fa3155df00da3894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cd029d4586860fe8c2a5ca9fa3155df00da3894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bd2960fda1912d3d418591214cd2f74cb8bbd9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEaiSth+M9lPoQjHQDxt6lcKOwJvwFAmHCdpYACgkQxt6lcKOw\nJvzzKAgAqfSyOPRue9TGc3CAOxgNk9yGF2bO18wU+YostzzaK7U58qLnUv9P6gtz\nw8IuOT4+meSm0Pfr1waZcp/7GSGKBIEuPfvZX/YTTD9+rZd5vVvLxnN6ngD71Zet\nHiI6it/sAUWQeLWi1GM/V9yal32D0UBUExyc794lYO/FpQwHrf6JyCe22wKDrzTF\nTbKtwasYn7oUXY2TGFxxlyySWLMxcLCvbeEzZNcVB3hyhj7Bos7RwESM3xLoTxmJ\nKdTURzgeLTXLF6XvbGTWh76AV0QpJ1kWf1LRRo3sxDuncT/vlswNmyTkDZV9W8bM\nJPCSUbocwhmltYeQ/sfVhHdFL2TBIg==\n=AvO8\n-----END PGP SIGNATURE-----", "payload": "tree 4cd029d4586860fe8c2a5ca9fa3155df00da3894\nparent d0986cd96b8765f252fe3d9d140cc313298d919b\nauthor Wang Ruochen <wrc@ruo-chen.wang> 1640134286 -0800\ncommitter Wang Ruochen <wrc@ruo-chen.wang> 1640134286 -0800\n\nDon't support if-let branches\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd2960fda1912d3d418591214cd2f74cb8bbd9a", "html_url": "https://github.com/rust-lang/rust/commit/2bd2960fda1912d3d418591214cd2f74cb8bbd9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bd2960fda1912d3d418591214cd2f74cb8bbd9a/comments", "author": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "committer": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0986cd96b8765f252fe3d9d140cc313298d919b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0986cd96b8765f252fe3d9d140cc313298d919b", "html_url": "https://github.com/rust-lang/rust/commit/d0986cd96b8765f252fe3d9d140cc313298d919b"}], "stats": {"total": 86, "additions": 22, "deletions": 64}, "files": [{"sha": "4dcb6d91f97a9db41a8e8ba39d804276b1cff56a", "filename": "crates/ide_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 22, "deletions": 64, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2bd2960fda1912d3d418591214cd2f74cb8bbd9a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd2960fda1912d3d418591214cd2f74cb8bbd9a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=2bd2960fda1912d3d418591214cd2f74cb8bbd9a", "patch": "@@ -158,75 +158,51 @@ pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContex\n                     }\n                 }\n             }\n-            match tail {\n-                Some(Tail::IfLet(e)) => {\n-                    cov_mark::hit!(move_guard_ifelse_iflet_tail);\n-                    let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n-                    // Put the if-let expression in a block\n-                    let iflet_expr: Expr = e.reset_indent().indent(1.into()).into();\n-                    let iflet_block =\n-                        make::block_expr(std::iter::empty(), Some(iflet_expr)).indent(indent_level);\n-                    edit.insert(then_arm_end, guard);\n-                    edit.insert(then_arm_end, iflet_block.syntax().text());\n-                }\n-                Some(Tail::Else(e)) => {\n-                    cov_mark::hit!(move_guard_ifelse_else_tail);\n-                    let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n-                    edit.insert(then_arm_end, guard);\n-                    let only_expr = e.statements().next().is_none();\n-                    match &e.tail_expr() {\n-                        Some(expr) if only_expr => {\n-                            cov_mark::hit!(move_guard_ifelse_expr_only);\n-                            edit.insert(then_arm_end, expr.syntax().text());\n-                            edit.insert(then_arm_end, \",\");\n-                        }\n-                        _ => {\n-                            let to_insert = e.dedent(dedent.into()).syntax().text();\n-                            edit.insert(then_arm_end, to_insert)\n-                        }\n+            if let Some(e) = tail {\n+                cov_mark::hit!(move_guard_ifelse_else_tail);\n+                let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n+                edit.insert(then_arm_end, guard);\n+                let only_expr = e.statements().next().is_none();\n+                match &e.tail_expr() {\n+                    Some(expr) if only_expr => {\n+                        cov_mark::hit!(move_guard_ifelse_expr_only);\n+                        edit.insert(then_arm_end, expr.syntax().text());\n+                        edit.insert(then_arm_end, \",\");\n+                    }\n+                    _ => {\n+                        let to_insert = e.dedent(dedent.into()).syntax().text();\n+                        edit.insert(then_arm_end, to_insert)\n                     }\n                 }\n-                _ => {\n-                    cov_mark::hit!(move_guard_ifelse_notail);\n-                }\n+            } else {\n+                cov_mark::hit!(move_guard_ifelse_notail);\n             }\n         },\n     )\n }\n \n-#[derive(Debug)]\n-enum Tail {\n-    Else(BlockExpr),\n-    IfLet(IfExpr),\n-}\n-\n // Parses an if-else-if chain to get the conditons and the then branches until we encounter an else\n // branch, an if-let branch or the end.\n-fn parse_if_chain(if_expr: IfExpr) -> Option<(Vec<(Condition, BlockExpr)>, Option<Tail>)> {\n+fn parse_if_chain(if_expr: IfExpr) -> Option<(Vec<(Condition, BlockExpr)>, Option<BlockExpr>)> {\n     let mut conds_blocks = Vec::new();\n     let mut curr_if = if_expr;\n-    let mut applicable = false;\n-    let tail: Option<Tail> = loop {\n+    let tail = loop {\n         let cond = curr_if.condition()?;\n+        // Not support moving if let to arm guard\n         if cond.is_pattern_cond() {\n-            break Some(Tail::IfLet(curr_if));\n+            return None;\n         }\n         conds_blocks.push((cond, curr_if.then_branch()?));\n-        applicable = true;\n         match curr_if.else_branch() {\n             Some(ElseBranch::IfExpr(e)) => {\n                 curr_if = e;\n             }\n             Some(ElseBranch::Block(b)) => {\n-                break Some(Tail::Else(b));\n+                break Some(b);\n             }\n             None => break None,\n         }\n     };\n-    if !applicable {\n-        // The first if branch is an if-let branch\n-        return None;\n-    }\n     Some((conds_blocks, tail))\n }\n \n@@ -853,8 +829,7 @@ fn main() {\n \n     #[test]\n     fn move_arm_cond_to_match_guard_elseif_iflet() {\n-        cov_mark::check!(move_guard_ifelse_iflet_tail);\n-        check_assist(\n+        check_assist_not_applicable(\n             move_arm_cond_to_match_guard,\n             r#\"\n fn main() {\n@@ -872,23 +847,6 @@ fn main() {\n         },\n     }\n }\n-\"#,\n-            r#\"\n-fn main() {\n-    match 92 {\n-        3 => 0,\n-        x if x > 10 => 1,\n-        x if x > 5 => 2,\n-        x => {\n-            if let 4 = 4 {\n-                42;\n-                3\n-            } else {\n-                4\n-            }\n-        }\n-    }\n-}\n \"#,\n         )\n     }"}]}