{"sha": "f1807216f0f600136d040f00a222f811fde4b842", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxODA3MjE2ZjBmNjAwMTM2ZDA0MGYwMGEyMjJmODExZmRlNGI4NDI=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2021-03-23T23:09:11Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2021-03-23T23:09:11Z"}, "message": "small cleanups in rustc_errors / emitter", "tree": {"sha": "84f82309fb7c151fd79e163921a69486f0506c5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84f82309fb7c151fd79e163921a69486f0506c5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1807216f0f600136d040f00a222f811fde4b842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1807216f0f600136d040f00a222f811fde4b842", "html_url": "https://github.com/rust-lang/rust/commit/f1807216f0f600136d040f00a222f811fde4b842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1807216f0f600136d040f00a222f811fde4b842/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "673d0db5e393e9c64897005b470bfeb6d5aec61b", "url": "https://api.github.com/repos/rust-lang/rust/commits/673d0db5e393e9c64897005b470bfeb6d5aec61b", "html_url": "https://github.com/rust-lang/rust/commit/673d0db5e393e9c64897005b470bfeb6d5aec61b"}], "stats": {"total": 34, "additions": 14, "deletions": 20}, "files": [{"sha": "66499fbb8da9238f189a771cf6c35c5441ad8f23", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1807216f0f600136d040f00a222f811fde4b842/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1807216f0f600136d040f00a222f811fde4b842/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=f1807216f0f600136d040f00a222f811fde4b842", "patch": "@@ -434,34 +434,31 @@ pub trait Emitter {\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n     ) {\n+        let source_map = if let Some(ref sm) = source_map {\n+            sm\n+        } else {\n+            return;\n+        };\n         debug!(\"fix_multispans_in_extern_macros: before: span={:?} children={:?}\", span, children);\n-        for span in iter::once(&mut *span).chain(children.iter_mut().map(|child| &mut child.span)) {\n-            self.fix_multispan_in_extern_macros(source_map, span);\n+        self.fix_multispan_in_extern_macros(source_map, span);\n+        for child in children.iter_mut() {\n+            self.fix_multispan_in_extern_macros(source_map, &mut child.span);\n         }\n         debug!(\"fix_multispans_in_extern_macros: after: span={:?} children={:?}\", span, children);\n     }\n \n     // This \"fixes\" MultiSpans that contain `Span`s pointing to locations inside of external macros.\n     // Since these locations are often difficult to read,\n     // we move these spans from the external macros to their corresponding use site.\n-    fn fix_multispan_in_extern_macros(\n-        &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n-        span: &mut MultiSpan,\n-    ) {\n-        let sm = match source_map {\n-            Some(ref sm) => sm,\n-            None => return,\n-        };\n-\n+    fn fix_multispan_in_extern_macros(&self, source_map: &Lrc<SourceMap>, span: &mut MultiSpan) {\n         // First, find all the spans in external macros and point instead at their use site.\n         let replacements: Vec<(Span, Span)> = span\n             .primary_spans()\n             .iter()\n             .copied()\n             .chain(span.span_labels().iter().map(|sp_label| sp_label.span))\n             .filter_map(|sp| {\n-                if !sp.is_dummy() && sm.is_imported(sp) {\n+                if !sp.is_dummy() && source_map.is_imported(sp) {\n                     let maybe_callsite = sp.source_callsite();\n                     if sp != maybe_callsite {\n                         return Some((sp, maybe_callsite));\n@@ -1232,7 +1229,6 @@ impl EmitterWriter {\n         is_secondary: bool,\n     ) -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n-        let header_style = if is_secondary { Style::HeaderMsg } else { Style::MainHeaderMsg };\n \n         if !msp.has_primary_spans() && !msp.has_span_labels() && is_secondary && !self.short_message\n         {\n@@ -1257,6 +1253,7 @@ impl EmitterWriter {\n                 buffer.append(0, &code, Style::Level(*level));\n                 buffer.append(0, \"]\", Style::Level(*level));\n             }\n+            let header_style = if is_secondary { Style::HeaderMsg } else { Style::MainHeaderMsg };\n             if *level != Level::FailureNote {\n                 buffer.append(0, \": \", header_style);\n             }\n@@ -1470,9 +1467,7 @@ impl EmitterWriter {\n                     let mut to_add = FxHashMap::default();\n \n                     for (depth, style) in depths {\n-                        if multilines.get(&depth).is_some() {\n-                            multilines.remove(&depth);\n-                        } else {\n+                        if multilines.remove(&depth).is_none() {\n                             to_add.insert(depth, style);\n                         }\n                     }\n@@ -1726,14 +1721,13 @@ impl EmitterWriter {\n                     if !self.short_message {\n                         draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n                     }\n-                    match emit_to_destination(\n+                    if let Err(e) = emit_to_destination(\n                         &buffer.render(),\n                         level,\n                         &mut self.dst,\n                         self.short_message,\n                     ) {\n-                        Ok(()) => (),\n-                        Err(e) => panic!(\"failed to emit error: {}\", e),\n+                        panic!(\"failed to emit error: {}\", e)\n                     }\n                 }\n                 if !self.short_message {"}]}