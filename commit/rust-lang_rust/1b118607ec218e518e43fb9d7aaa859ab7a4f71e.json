{"sha": "1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMTE4NjA3ZWMyMThlNTE4ZTQzZmI5ZDdhYWE4NTlhYjdhNGY3MWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-24T08:51:20Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T18:43:09Z"}, "message": "Use chaining for diagnosics in parser.", "tree": {"sha": "4cfcd7091872683c0f96d8d75d8c70740fe768a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cfcd7091872683c0f96d8d75d8c70740fe768a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "html_url": "https://github.com/rust-lang/rust/commit/1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b118607ec218e518e43fb9d7aaa859ab7a4f71e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfad725be540137e0bc3022fe5341378e4690b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfad725be540137e0bc3022fe5341378e4690b9b", "html_url": "https://github.com/rust-lang/rust/commit/dfad725be540137e0bc3022fe5341378e4690b9b"}], "stats": {"total": 307, "additions": 155, "deletions": 152}, "files": [{"sha": "eb8aa4e5761f716731acf16827995c91aa2a29a5", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1b118607ec218e518e43fb9d7aaa859ab7a4f71e/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b118607ec218e518e43fb9d7aaa859ab7a4f71e/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "patch": "@@ -549,8 +549,10 @@ impl<'a> Parser<'a> {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = op.span.to(self.token.span);\n-                let mut err = self.diagnostic().struct_span_err(op_span,\n-                    \"chained comparison operators require parentheses\");\n+                let mut err = self.struct_span_err(\n+                    op_span,\n+                    \"chained comparison operators require parentheses\",\n+                );\n                 if op.node == BinOpKind::Lt &&\n                     *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n                     *outer_op == AssocOp::Greater  // even in a case like the following:\n@@ -1149,17 +1151,14 @@ impl<'a> Parser<'a> {\n     crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                self.prev_span,\n-                \"expected iterable, found keyword `in`\",\n-            );\n-            err.span_suggestion_short(\n-                in_span.until(self.prev_span),\n-                \"remove the duplicated `in`\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n+                .span_suggestion_short(\n+                    in_span.until(self.prev_span),\n+                    \"remove the duplicated `in`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n         }\n     }\n \n@@ -1172,12 +1171,12 @@ impl<'a> Parser<'a> {\n \n     crate fn eat_incorrect_doc_comment_for_arg_type(&mut self) {\n         if let token::DocComment(_) = self.token.kind {\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 self.token.span,\n                 \"documentation comments cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(self.token.span, \"doc comments are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(self.token.span, \"doc comments are not allowed here\")\n+            .emit();\n             self.bump();\n         } else if self.token == token::Pound && self.look_ahead(1, |t| {\n             *t == token::OpenDelim(token::Bracket)\n@@ -1189,12 +1188,12 @@ impl<'a> Parser<'a> {\n             }\n             let sp = lo.to(self.token.span);\n             self.bump();\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 sp,\n                 \"attributes cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(sp, \"attributes are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(sp, \"attributes are not allowed here\")\n+            .emit();\n         }\n     }\n \n@@ -1250,18 +1249,19 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        let mut err = self.diagnostic().struct_span_err_with_code(\n-            pat.span,\n-            \"patterns aren't allowed in methods without bodies\",\n-            DiagnosticId::Error(\"E0642\".into()),\n-        );\n-        err.span_suggestion_short(\n-            pat.span,\n-            \"give this argument a name or use an underscore to ignore it\",\n-            \"_\".to_owned(),\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+        self.diagnostic()\n+            .struct_span_err_with_code(\n+                pat.span,\n+                \"patterns aren't allowed in methods without bodies\",\n+                DiagnosticId::Error(\"E0642\".into()),\n+            )\n+            .span_suggestion_short(\n+                pat.span,\n+                \"give this argument a name or use an underscore to ignore it\",\n+                \"_\".to_owned(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat = P(Pat {"}, {"sha": "21f0cb05ee11f83c295951096e7013bfd88d8ffc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 122, "deletions": 119, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/1b118607ec218e518e43fb9d7aaa859ab7a4f71e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b118607ec218e518e43fb9d7aaa859ab7a4f71e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1b118607ec218e518e43fb9d7aaa859ab7a4f71e", "patch": "@@ -2323,19 +2323,19 @@ impl<'a> Parser<'a> {\n             // This is a struct literal, but we don't can't accept them here\n             let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n-                let mut err = self.diagnostic().struct_span_err(\n+                self.struct_span_err(\n                     expr.span,\n                     \"struct literals are not allowed here\",\n-                );\n-                err.multipart_suggestion(\n+                )\n+                .multipart_suggestion(\n                     \"surround the struct literal with parentheses\",\n                     vec![\n                         (lo.shrink_to_lo(), \"(\".to_string()),\n                         (expr.span.shrink_to_hi(), \")\".to_string()),\n                     ],\n                     Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                )\n+                .emit();\n             }\n             return Some(expr);\n         }\n@@ -2364,18 +2364,18 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 if self.token == token::Comma {\n-                    let mut err = self.sess.span_diagnostic.mut_span_err(\n+                    self.struct_span_err(\n                         exp_span.to(self.prev_span),\n                         \"cannot use a comma after the base struct\",\n-                    );\n-                    err.span_suggestion_short(\n+                    )\n+                    .span_suggestion_short(\n                         self.token.span,\n                         \"remove this comma\",\n                         String::new(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.note(\"the base struct must always be the last field\");\n-                    err.emit();\n+                    )\n+                    .note(\"the base struct must always be the last field\")\n+                    .emit();\n                     self.recover_stmt();\n                 }\n                 break;\n@@ -2730,15 +2730,14 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span_of_tilde = lo;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\");\n-                err.span_suggestion_short(\n-                    span_of_tilde,\n-                    \"use `!` to perform bitwise negation\",\n-                    \"!\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n+                    .span_suggestion_short(\n+                        span_of_tilde,\n+                        \"use `!` to perform bitwise negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n@@ -2786,21 +2785,20 @@ impl<'a> Parser<'a> {\n                 if cannot_continue_expr {\n                     self.bump();\n                     // Emit the error ...\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(self.token.span,\n-                                         &format!(\"unexpected {} after identifier\",\n-                                                  self.this_token_descr()));\n-                    // span the `not` plus trailing whitespace to avoid\n-                    // trailing whitespace after the `!` in our suggestion\n-                    let to_replace = self.sess.source_map()\n-                        .span_until_non_whitespace(lo.to(self.token.span));\n-                    err.span_suggestion_short(\n-                        to_replace,\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n+                    )\n+                    .span_suggestion_short(\n+                        // Span the `not` plus trailing whitespace to avoid\n+                        // trailing whitespace after the `!` in our suggestion\n+                        self.sess.source_map()\n+                            .span_until_non_whitespace(lo.to(self.token.span)),\n                         \"use `!` to perform logical negation\",\n                         \"!\".to_owned(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    )\n+                    .emit();\n                     // \u2014and recover! (just as if we were in the block\n                     // for the `token::Not` arm)\n                     let e = self.parse_prefix_expr(None);\n@@ -2878,7 +2876,7 @@ impl<'a> Parser<'a> {\n                 // We've found an expression that would be parsed as a statement, but the next\n                 // token implies this should be parsed as an expression.\n                 // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.token.span, &format!(\n+                let mut err = self.struct_span_err(self.token.span, &format!(\n                     \"expected expression, found `{}`\",\n                     pprust::token_to_string(&self.token),\n                 ));\n@@ -3066,28 +3064,32 @@ impl<'a> Parser<'a> {\n                         // in AST and continue parsing.\n                         let msg = format!(\"`<` is interpreted as a start of generic \\\n                                            arguments for `{}`, not a {}\", path, op_noun);\n-                        let mut err =\n-                            self.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        err.span_label(self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                       \"interpreted as generic arguments\");\n-                        err.span_label(self.token.span, format!(\"not interpreted as {}\", op_noun));\n-\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n                             node: TyKind::Path(None, path),\n                             id: ast::DUMMY_NODE_ID\n                         }));\n \n-                        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n-                                                .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"try {} the cast value\", op_verb),\n-                            format!(\"({})\", expr_str),\n-                            Applicability::MachineApplicable\n-                        );\n-                        err.emit();\n+                        let expr_str = self\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(expr.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+\n+                        self.struct_span_err(self.token.span, &msg)\n+                            .span_label(\n+                                self.look_ahead(1, |t| t.span).to(span_after_type),\n+                                \"interpreted as generic arguments\"\n+                            )\n+                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_suggestion(\n+                                expr.span,\n+                                &format!(\"try {} the cast value\", op_verb),\n+                                format!(\"({})\", expr_str),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n \n                         Ok(expr)\n                     }\n@@ -3270,9 +3272,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    fn parse_for_expr(&mut self, opt_label: Option<Label>,\n-                          span_lo: Span,\n-                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_for_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         // Record whether we are about to parse `for (`.\n@@ -3286,14 +3291,14 @@ impl<'a> Parser<'a> {\n         let pat = self.parse_top_level_pat()?;\n         if !self.eat_keyword(kw::In) {\n             let in_span = self.prev_span.between(self.token.span);\n-            let mut err = self.sess.span_diagnostic\n-                .struct_span_err(in_span, \"missing `in` in `for` loop\");\n-            err.span_suggestion_short(\n-                in_span, \"try adding `in` here\", \" in \".into(),\n-                // has been misleading, at least in the past (closed Issue #48492)\n-                Applicability::MaybeIncorrect\n-            );\n-            err.emit();\n+            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+                .span_suggestion_short(\n+                    in_span,\n+                    \"try adding `in` here\", \" in \".into(),\n+                    // has been misleading, at least in the past (closed Issue #48492)\n+                    Applicability::MaybeIncorrect\n+                )\n+                .emit();\n         }\n         let in_span = self.prev_span;\n         self.check_for_for_in_in_typo(in_span);\n@@ -3527,15 +3532,14 @@ impl<'a> Parser<'a> {\n             pats.push(self.parse_top_level_pat()?);\n \n             if self.token == token::OrOr {\n-                let mut err = self.struct_span_err(self.token.span,\n-                                                   \"unexpected token `||` after pattern\");\n-                err.span_suggestion(\n-                    self.token.span,\n-                    \"use a single `|` to specify multiple patterns\",\n-                    \"|\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"use a single `|` to specify multiple patterns\",\n+                        \"|\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 self.bump();\n             } else if self.eat(&token::BinOp(token::Or)) {\n                 // This is a No-op. Continue the loop to parse the next\n@@ -3632,15 +3636,14 @@ impl<'a> Parser<'a> {\n \n                 if self.token == token::DotDotDot { // Issue #46718\n                     // Accept `...` as if it were `..` to avoid further errors\n-                    let mut err = self.struct_span_err(self.token.span,\n-                                                       \"expected field pattern, found `...`\");\n-                    err.span_suggestion(\n-                        self.token.span,\n-                        \"to omit remaining fields, use one fewer `.`\",\n-                        \"..\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+                        .span_suggestion(\n+                            self.token.span,\n+                            \"to omit remaining fields, use one fewer `.`\",\n+                            \"..\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n                 }\n                 self.bump();  // `..` || `...`\n \n@@ -5858,15 +5861,16 @@ impl<'a> Parser<'a> {\n                 if let token::DocComment(_) = self.token.kind {\n                     if self.look_ahead(1,\n                     |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        let mut err = self.diagnostic().struct_span_err_with_code(\n+                        self.diagnostic().struct_span_err_with_code(\n                             self.token.span,\n                             \"found a documentation comment that doesn't document anything\",\n                             DiagnosticId::Error(\"E0584\".into()),\n-                        );\n-                        err.help(\"doc comments must come before what they document, maybe a \\\n+                        )\n+                        .help(\n+                            \"doc comments must come before what they document, maybe a \\\n                             comment was intended with `//`?\",\n-                        );\n-                        err.emit();\n+                        )\n+                        .emit();\n                         self.bump();\n                         continue;\n                     }\n@@ -6310,12 +6314,15 @@ impl<'a> Parser<'a> {\n                 let sp = path.span;\n                 let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let mut err = struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg);\n-                err.help(suggestion);\n-                err.span_suggestion(\n-                    sp, &help_msg, format!(\"in {}\", path), Applicability::MachineApplicable\n-                );\n-                err.emit();  // emit diagnostic, but continue with public visibility\n+                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n+                    .help(suggestion)\n+                    .span_suggestion(\n+                        sp,\n+                        &help_msg,\n+                        format!(\"in {}\", path),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();  // emit diagnostic, but continue with public visibility\n             }\n         }\n \n@@ -6749,14 +6756,10 @@ impl<'a> Parser<'a> {\n             }\n             ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n \n-            let mut err = self.struct_span_err(fixed_name_sp, error_msg);\n-            err.span_label(fixed_name_sp, \"dash-separated idents are not valid\");\n-            err.multipart_suggestion(\n-                suggestion_msg,\n-                replacement,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(fixed_name_sp, error_msg)\n+                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n+                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n+                .emit();\n         }\n         Ok(ident)\n     }\n@@ -6911,14 +6914,14 @@ impl<'a> Parser<'a> {\n             if !self.eat(&token::Comma) {\n                 if self.token.is_ident() && !self.token.is_reserved_ident() {\n                     let sp = self.sess.source_map().next_point(self.prev_span);\n-                    let mut err = self.struct_span_err(sp, \"missing comma\");\n-                    err.span_suggestion_short(\n-                        sp,\n-                        \"missing comma\",\n-                        \",\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(sp, \"missing comma\")\n+                        .span_suggestion_short(\n+                            sp,\n+                            \"missing comma\",\n+                            \",\".to_owned(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                 } else {\n                     break;\n                 }\n@@ -6957,15 +6960,16 @@ impl<'a> Parser<'a> {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n                         let prev_span = self.prev_span;\n-                        let mut err = struct_span_err!(\n+                        struct_span_err!(\n                             self.sess.span_diagnostic,\n                             prev_span,\n                             E0703,\n                             \"invalid ABI: found `{}`\",\n-                            symbol);\n-                        err.span_label(prev_span, \"invalid ABI\");\n-                        err.help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")));\n-                        err.emit();\n+                            symbol\n+                        )\n+                        .span_label(prev_span, \"invalid ABI\")\n+                        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+                        .emit();\n                         Ok(None)\n                     }\n                 }\n@@ -7135,16 +7139,15 @@ impl<'a> Parser<'a> {\n             // CONST ITEM\n             if self.eat_keyword(kw::Mut) {\n                 let prev_span = self.prev_span;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(prev_span, \"const globals cannot be mutable\");\n-                err.span_label(prev_span, \"cannot be mutable\");\n-                err.span_suggestion(\n-                    const_span,\n-                    \"you might want to declare a static instead\",\n-                    \"static\".to_owned(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n+                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n+                    .span_label(prev_span, \"cannot be mutable\")\n+                    .span_suggestion(\n+                        const_span,\n+                        \"you might want to declare a static instead\",\n+                        \"static\".to_owned(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;"}]}