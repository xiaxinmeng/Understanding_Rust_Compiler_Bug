{"sha": "a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNTljYjJmMzM0NGMwYTllZmFlMTdkZGUzZDBlMTZhNTVjZTkzZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-27T21:11:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T21:11:07Z"}, "message": "Auto merge of #36601 - jseyfried:build_reduced_graph_in_expansion, r=nrc\n\nAssign def ids and build the module graph during expansion\n\nr? @nrc", "tree": {"sha": "f8c95278a99c33a5f92ae0f9e5ea4bfc0ecf47c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c95278a99c33a5f92ae0f9e5ea4bfc0ecf47c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "html_url": "https://github.com/rust-lang/rust/commit/a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "322b5530ba8a74e0363243da5cdc3d0ac43762d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/322b5530ba8a74e0363243da5cdc3d0ac43762d7", "html_url": "https://github.com/rust-lang/rust/commit/322b5530ba8a74e0363243da5cdc3d0ac43762d7"}, {"sha": "dfa69be38a3d232ebb0a548afff5e3560dd905ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa69be38a3d232ebb0a548afff5e3560dd905ce", "html_url": "https://github.com/rust-lang/rust/commit/dfa69be38a3d232ebb0a548afff5e3560dd905ce"}], "stats": {"total": 602, "additions": 321, "deletions": 281}, "files": [{"sha": "c0f38061a0d6dac2681a1a6fb47a68db53986594", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -18,31 +18,39 @@ use middle::cstore::InlinedItem;\n \n use syntax::ast::*;\n use syntax::visit;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n \n /// Creates def ids for nodes in the HIR.\n-pub struct DefCollector<'ast> {\n+pub struct DefCollector<'a> {\n     // If we are walking HIR (c.f., AST), we need to keep a reference to the\n     // crate.\n-    hir_crate: Option<&'ast hir::Crate>,\n-    definitions: &'ast mut Definitions,\n+    hir_crate: Option<&'a hir::Crate>,\n+    definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n+    pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n }\n \n-impl<'ast> DefCollector<'ast> {\n-    pub fn new(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n+pub struct MacroInvocationData {\n+    pub id: NodeId,\n+    pub def_index: DefIndex,\n+    pub const_integer: bool,\n+}\n+\n+impl<'a> DefCollector<'a> {\n+    pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n             hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n+            visit_macro_invoc: None,\n         }\n     }\n \n     pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  definitions: &'ast mut Definitions)\n-                  -> DefCollector<'ast> {\n+                  definitions: &'a mut Definitions)\n+                  -> Self {\n         let mut collector = DefCollector::new(definitions);\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n@@ -65,7 +73,7 @@ impl<'ast> DefCollector<'ast> {\n         self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n     }\n \n-    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n+    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n         self.hir_crate = Some(krate);\n         ii.visit(self);\n     }\n@@ -84,29 +92,28 @@ impl<'ast> DefCollector<'ast> {\n         self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let parent = self.parent_def;\n         self.parent_def = Some(parent_def);\n         f(self);\n         self.parent_def = parent;\n     }\n \n-    fn visit_ast_const_integer(&mut self, expr: &Expr) {\n-        // Find the node which will be used after lowering.\n-        if let ExprKind::Paren(ref inner) = expr.node {\n-            return self.visit_ast_const_integer(inner);\n-        }\n-\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let ExprKind::Closure(..) = expr.node {\n-            return;\n+    pub fn visit_ast_const_integer(&mut self, expr: &Expr) {\n+        match expr.node {\n+            // Find the node which will be used after lowering.\n+            ExprKind::Paren(ref inner) => return self.visit_ast_const_integer(inner),\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, true),\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            ExprKind::Closure(..) => return,\n+            _ => {}\n         }\n \n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &'ast hir::Expr) {\n+    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         if let hir::ExprClosure(..) = expr.node {\n@@ -115,9 +122,19 @@ impl<'ast> DefCollector<'ast> {\n \n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n+\n+    fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n+        if let Some(ref mut visit) = self.visit_macro_invoc {\n+            visit(MacroInvocationData {\n+                id: id,\n+                const_integer: const_integer,\n+                def_index: self.parent_def.unwrap(),\n+            })\n+        }\n+    }\n }\n \n-impl<'ast> visit::Visitor for DefCollector<'ast> {\n+impl<'a> visit::Visitor for DefCollector<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -129,10 +146,14 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n                 DefPathData::TypeNs(i.ident.name.as_str()),\n+            ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n+                return visit::walk_item(self, i);\n+            }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+            ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::Use(..) => DefPathData::Misc,\n         };\n         let def = self.create_def(i.id, def_data);\n@@ -198,7 +219,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name.as_str()),\n             TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n-            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name.as_str()),\n+            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -216,7 +237,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_str()),\n             ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n-            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name.as_str()),\n+            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -232,9 +253,13 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         let parent_def = self.parent_def;\n \n-        if let PatKind::Ident(_, id, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n-            self.parent_def = Some(def);\n+        match pat.node {\n+            PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n+            PatKind::Ident(_, id, _) => {\n+                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_pat(self, pat);\n@@ -244,25 +269,28 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &Expr) {\n         let parent_def = self.parent_def;\n \n-        if let ExprKind::Repeat(_, ref count) = expr.node {\n-            self.visit_ast_const_integer(count);\n-        }\n-\n-        if let ExprKind::Closure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n+        match expr.node {\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n+            ExprKind::Repeat(_, ref count) => self.visit_ast_const_integer(count),\n+            ExprKind::Closure(..) => {\n+                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_expr(self, expr);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_ty(&mut self, ty: &Ty) {\n-        if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n-            self.visit_ast_const_integer(length);\n-        }\n-        if let TyKind::ImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n+        match ty.node {\n+            TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n+            TyKind::FixedLengthVec(_, ref length) => self.visit_ast_const_integer(length),\n+            TyKind::ImplTrait(..) => {\n+                self.create_def(ty.id, DefPathData::ImplTrait);\n+            }\n+            _ => {}\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -274,6 +302,13 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n+\n+    fn visit_stmt(&mut self, stmt: &Stmt) {\n+        match stmt.node {\n+            StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),\n+            _ => visit::walk_stmt(self, stmt),\n+        }\n+    }\n }\n \n // We walk the HIR rather than the AST when reading items from metadata."}, {"sha": "f87844652cc199e8e6ab0e0e9cd36644ccf7bf9d", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher, SipHasher};\n-use syntax::{ast, visit};\n+use syntax::ast;\n use syntax::parse::token::{self, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -224,12 +223,6 @@ impl Definitions {\n         }\n     }\n \n-    pub fn collect(&mut self, krate: &ast::Crate) {\n-        let mut def_collector = DefCollector::new(self);\n-        def_collector.collect_root();\n-        visit::walk_crate(&mut def_collector, krate);\n-    }\n-\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "bafb00edc190c1db00c65b18cea3d46e89e969e1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -11,7 +11,7 @@\n pub use self::Node::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n-use self::def_collector::DefCollector;\n+pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n "}, {"sha": "f9ac1312d3c7505e71aa62ec34ae8a77c7f42be9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -639,6 +639,12 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     }\n     sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n+    // Currently, we ignore the name resolution data structures for the purposes of dependency\n+    // tracking. Instead we will run name resolution and include its output in the hash of each\n+    // item, much like we do for macro expansion. In other words, the hash reflects not just\n+    // its contents but the results of name resolution on those contents. Hopefully we'll push\n+    // this back at some point.\n+    let _ignore = sess.dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, &krate, crate_name);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n@@ -733,9 +739,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         })\n     })?;\n \n-    // Collect defintions for def ids.\n-    time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n-\n     time(sess.time_passes(),\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));\n@@ -745,13 +748,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n          || ast_validation::check_crate(sess, &krate));\n \n     time(sess.time_passes(), \"name resolution\", || -> CompileResult {\n-        // Currently, we ignore the name resolution data structures for the purposes of dependency\n-        // tracking. Instead we will run name resolution and include its output in the hash of each\n-        // item, much like we do for macro expansion. In other words, the hash reflects not just\n-        // its contents but the results of name resolution on those contents. Hopefully we'll push\n-        // this back at some point.\n-        let _ignore = sess.dep_graph.in_ignore();\n-        resolver.build_reduced_graph(&krate);\n         resolver.resolve_imports();\n \n         // Since import resolution will eventually happen in expansion,"}, {"sha": "c03375bf8254fe822d095b3ae73e041bcebee967", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -98,10 +98,10 @@ Erroneous code examples:\n \n ```compile_fail,E0466\n #[macro_use(a_macro(another_macro))] // error: invalid import declaration\n-extern crate some_crate;\n+extern crate core as some_crate;\n \n #[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n-extern crate another_crate;\n+extern crate core as another_crate;\n ```\n \n This is a syntax error at the level of attribute declarations. The proper\n@@ -135,10 +135,10 @@ Erroneous code examples:\n \n ```compile_fail,E0467\n #[macro_reexport]                    // error: no macros listed for export\n-extern crate macros_for_good;\n+extern crate core as macros_for_good;\n \n #[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n-extern crate other_macros_for_good;\n+extern crate core as other_macros_for_good;\n ```\n \n This is a syntax error at the level of attribute declarations.\n@@ -165,8 +165,8 @@ Example of erroneous code:\n ```compile_fail,E0468\n mod foo {\n     #[macro_use(helpful_macro)] // error: must be at crate root to import\n-    extern crate some_crate;    //        macros from another crate\n-    helpful_macro!(...)\n+    extern crate core;          //        macros from another crate\n+    helpful_macro!(...);\n }\n ```\n "}, {"sha": "55bf5dcf1cff0e692c7fce657bb473c0eb1b24d7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 94, "deletions": 16, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -20,21 +20,25 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n+use rustc::middle::cstore::LoadedMacro;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::map::DefPathData;\n use rustc::ty;\n \n use std::cell::Cell;\n+use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n use syntax::parse::token;\n \n-use syntax::ast::{Block, Crate};\n-use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n+use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n+use syntax::ext::hygiene::Mark;\n+use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n \n@@ -53,11 +57,6 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n }\n \n impl<'b> Resolver<'b> {\n-    /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(&mut self, krate: &Crate) {\n-        visit::walk_crate(&mut BuildReducedGraphVisitor { resolver: self }, krate);\n-    }\n-\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n@@ -72,15 +71,13 @@ impl<'b> Resolver<'b> {\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block.stmts.iter().any(|statement| match statement.node {\n-            StmtKind::Item(_) => true,\n+            StmtKind::Item(_) | StmtKind::Mac(_) => true,\n             _ => false,\n         })\n     }\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n-        self.crate_loader.process_item(item, &self.definitions);\n-\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;\n@@ -188,8 +185,20 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                // n.b. we don't need to look at the path option here, because cstore already\n-                // did\n+                // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                // crate root, because `$crate` won't work properly.\n+                let is_crate_root = self.current_module.parent.is_none();\n+                for def in self.crate_loader.load_macros(item, is_crate_root) {\n+                    match def {\n+                        LoadedMacro::Def(def) => self.add_macro(Mark::root(), def),\n+                        LoadedMacro::CustomDerive(name, ext) => {\n+                            self.insert_custom_derive(&name, ext, item.span);\n+                        }\n+                    }\n+                }\n+                self.crate_loader.process_item(item, &self.definitions);\n+\n+                // n.b. we don't need to look at the path option here, because cstore already did\n                 if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId {\n                         krate: crate_id,\n@@ -206,13 +215,16 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n \n+            ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n+\n             ItemKind::Mod(..) => {\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n                 let module = self.arenas.alloc_module(ModuleS {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n+                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -222,7 +234,7 @@ impl<'b> Resolver<'b> {\n                 self.current_module = module;\n             }\n \n-            ItemKind::ForeignMod(..) => {}\n+            ItemKind::ForeignMod(..) => self.crate_loader.process_item(item, &self.definitions),\n \n             // These items live in the value namespace.\n             ItemKind::Static(_, m, _) => {\n@@ -476,14 +488,79 @@ impl<'b> Resolver<'b> {\n         }\n         module.populated.set(true)\n     }\n+\n+    // does this attribute list contain \"macro_use\"?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.session.struct_span_warn(attr.span, msg);\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            } else if !attr.check_name(\"macro_use\") {\n+                continue;\n+            }\n+\n+            if !attr.is_word() {\n+                self.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+            }\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n+        if !self.session.features.borrow().rustc_macro {\n+            let sess = &self.session.parse_sess;\n+            let msg = \"loading custom derive macro crates is experimentally supported\";\n+            emit_feature_err(sess, \"rustc_macro\", sp, feature_gate::GateIssue::Language, msg);\n+        }\n+        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n+            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n+        }\n+    }\n+}\n+\n+pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n+    pub resolver: &'a mut Resolver<'b>,\n+}\n+\n+impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) {\n+        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module =\n+            self.resolver.current_module;\n+    }\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n-    resolver: &'a mut Resolver<'b>,\n+macro_rules! method {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n+        fn $visit(&mut self, node: &$ty) {\n+            match node.node {\n+                $invoc(..) => self.visit_invoc(node.id),\n+                _ => visit::$walk(self, node),\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n+    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n+    method!(visit_stmt:      ast::Stmt,     ast::StmtKind::Mac,       walk_stmt);\n+    method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n+    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n+    method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n+\n     fn visit_item(&mut self, item: &Item) {\n+        match item.node {\n+            ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::Mac(..) => return self.visit_invoc(item.id),\n+            _ => {}\n+        }\n+\n         let parent = self.resolver.current_module;\n         self.resolver.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n@@ -492,6 +569,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item);\n+        visit::walk_foreign_item(self, foreign_item);\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n@@ -515,7 +593,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n                 (Def::Method(item_def_id), ValueNS)\n             }\n             TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n-            TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n+            TraitItemKind::Macro(_) => return self.visit_invoc(item.id),\n         };\n \n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);"}, {"sha": "0694edd235777dee30e653cb40cbc7d9bdad0c3a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -42,7 +42,7 @@ use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n \n-use rustc::hir::map::Definitions;\n+use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -72,9 +73,9 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n \n use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n use std::fmt;\n use std::mem::replace;\n+use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n \n@@ -791,6 +792,9 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -808,6 +812,8 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n+            macros: RefCell::new(FnvHashMap()),\n+            macros_escape: false,\n         }\n     }\n \n@@ -1079,7 +1085,7 @@ pub struct Resolver<'a> {\n     macro_names: FnvHashSet<Name>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: FnvHashMap<u32, macros::ExpansionData>,\n+    expansion_data: FnvHashMap<u32, macros::ExpansionData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1193,13 +1199,16 @@ impl<'a> Resolver<'a> {\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n \n+        let mut definitions = Definitions::new();\n+        DefCollector::new(&mut definitions).collect_root();\n+\n         let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(0, macros::ExpansionData::default()); // Crate root expansion\n+        expansion_data.insert(0, macros::ExpansionData::root(graph_root)); // Crate root expansion\n \n         Resolver {\n             session: session,\n \n-            definitions: Definitions::new(),\n+            definitions: definitions,\n             macros_at_scope: FnvHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1269,6 +1278,13 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n+        // Collect `DefId`s for exported macro defs.\n+        for def in &krate.exported_macros {\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(def)\n+            })\n+        }\n+\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n "}, {"sha": "17f2dff28c3f450217319ddcc108517753b67b38", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 56, "deletions": 137, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -8,48 +8,60 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Resolver;\n-use rustc::middle::cstore::LoadedMacro;\n-use rustc::util::nodemap::FnvHashMap;\n-use std::cell::RefCell;\n-use std::mem;\n+use {Module, Resolver};\n+use build_reduced_graph::BuildReducedGraphVisitor;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::map::{self, DefCollector};\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n-use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token::{self, intern};\n+use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit::{self, Visitor};\n-use syntax_pos::Span;\n \n-#[derive(Clone, Default)]\n-pub struct ExpansionData {\n-    module: Rc<ModuleData>,\n+#[derive(Clone)]\n+pub struct ExpansionData<'a> {\n+    pub module: Module<'a>,\n+    def_index: DefIndex,\n+    // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n+    // c.f. `DefCollector::visit_ast_const_integer`.\n+    const_integer: bool,\n }\n \n-// FIXME(jseyfried): merge with `::ModuleS`.\n-#[derive(Default)]\n-struct ModuleData {\n-    parent: Option<Rc<ModuleData>>,\n-    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n-    macros_escape: bool,\n+impl<'a> ExpansionData<'a> {\n+    pub fn root(graph_root: Module<'a>) -> Self {\n+        ExpansionData {\n+            module: graph_root,\n+            def_index: CRATE_DEF_INDEX,\n+            const_integer: false,\n+        }\n+    }\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        expansion.visit_with(&mut ExpansionVisitor {\n-            current_module: self.expansion_data[&mark.as_u32()].module.clone(),\n-            resolver: self,\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n+        let mark = Mark::fresh();\n+        let module = self.module_map[&id];\n+        self.expansion_data.insert(mark.as_u32(), ExpansionData {\n+            module: module,\n+            def_index: module.def_id().unwrap().index,\n+            const_integer: false,\n         });\n+        mark\n+    }\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n+        self.collect_def_ids(mark, expansion);\n+        self.current_module = self.expansion_data[&mark.as_u32()].module;\n+        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self });\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n@@ -71,9 +83,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.macro_names.insert(ident.name);\n         }\n \n-        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module;\n         while module.macros_escape {\n-            module = module.parent.clone().unwrap();\n+            module = module.parent.unwrap();\n         }\n         module.macros.borrow_mut().insert(ident.name, ext);\n     }\n@@ -113,12 +125,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module;\n         loop {\n             if let Some(ext) = module.macros.borrow().get(&name) {\n                 return Some(ext.clone());\n             }\n-            match module.parent.clone() {\n+            match module.parent {\n                 Some(parent) => module = parent,\n                 None => break,\n             }\n@@ -147,116 +159,23 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n-        if !self.session.features.borrow().rustc_macro {\n-            let sess = &self.session.parse_sess;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(sess, \"rustc_macro\", sp, feature_gate::GateIssue::Language, msg);\n-        }\n-        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n-            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n-}\n-\n-struct ExpansionVisitor<'b, 'a: 'b> {\n-    resolver: &'b mut Resolver<'a>,\n-    current_module: Rc<ModuleData>,\n-}\n+    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n+        let expansion_data = &mut self.expansion_data;\n+        let ExpansionData { def_index, const_integer, module } = expansion_data[&mark.as_u32()];\n+        let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n+            expansion_data.entry(invoc.id.as_u32()).or_insert(ExpansionData {\n+                def_index: invoc.def_index,\n+                const_integer: invoc.const_integer,\n+                module: module,\n+            });\n+        };\n \n-impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.insert(id.as_u32(), ExpansionData {\n-            module: self.current_module.clone(),\n+        let mut def_collector = DefCollector::new(&mut self.definitions);\n+        def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n+        def_collector.with_parent(def_index, |def_collector| if !const_integer {\n+            expansion.visit_with(def_collector)\n+        } else if let Expansion::Expr(ref expr) = *expansion {\n+            def_collector.visit_ast_const_integer(expr);\n         });\n     }\n-\n-    // does this attribute list contain \"macro_use\"?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.resolver.session.struct_span_warn(attr.span, msg);\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            } else if !attr.check_name(\"macro_use\") {\n-                continue;\n-            }\n-\n-            if !attr.is_word() {\n-                self.resolver.session.span_err(attr.span,\n-                                               \"arguments to macro_use are not allowed here\");\n-            }\n-            return true;\n-        }\n-\n-        false\n-    }\n-}\n-\n-macro_rules! method {\n-    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n-        fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n-    method!(visit_trait_item: ast::TraitItem, ast::TraitItemKind::Macro, walk_trait_item);\n-    method!(visit_impl_item:  ast::ImplItem,  ast::ImplItemKind::Macro,  walk_impl_item);\n-    method!(visit_stmt:       ast::Stmt,      ast::StmtKind::Mac,        walk_stmt);\n-    method!(visit_expr:       ast::Expr,      ast::ExprKind::Mac,        walk_expr);\n-    method!(visit_pat:        ast::Pat,       ast::PatKind::Mac,         walk_pat);\n-    method!(visit_ty:         ast::Ty,        ast::TyKind::Mac,          walk_ty);\n-\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => {} // Scope placeholder\n-            ast::ItemKind::Mac(..) => self.visit_invoc(item.id),\n-            ast::ItemKind::Mod(..) => {\n-                let module_data = ModuleData {\n-                    parent: Some(self.current_module.clone()),\n-                    macros: RefCell::new(FnvHashMap()),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n-                };\n-                let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n-                visit::walk_item(self, item);\n-                self.current_module = orig_module;\n-            }\n-            ast::ItemKind::ExternCrate(..) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                // FIXME(jseyfried): This will be nicer once `ModuleData` is merged with `ModuleS`.\n-                let is_crate_root = self.current_module.parent.as_ref().unwrap().parent.is_none();\n-                for def in self.resolver.crate_loader.load_macros(item, is_crate_root) {\n-                    match def {\n-                        LoadedMacro::Def(def) => self.resolver.add_macro(Mark::root(), def),\n-                        LoadedMacro::CustomDerive(name, ext) => {\n-                            self.resolver.insert_custom_derive(&name, ext, item.span);\n-                        }\n-                    }\n-                }\n-                visit::walk_item(self, item);\n-            }\n-            _ => visit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_block(&mut self, block: &ast::Block) {\n-        let module_data = ModuleData {\n-            parent: Some(self.current_module.clone()),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n-        };\n-        let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n-        visit::walk_block(self, block);\n-        self.current_module = orig_module;\n-    }\n }"}, {"sha": "94a7f6030b9373d557fec1c6d3ec4c720f1430a9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -303,6 +303,6 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n \n-fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n+pub fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"test\") || attr.check_name(\"bench\")\n }"}, {"sha": "5082f64ccbb415e02f0fe2016e2a0635427f478c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -515,6 +515,7 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n     fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n@@ -530,6 +531,7 @@ pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n+    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n     fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}\n@@ -567,6 +569,7 @@ pub struct ExtCtxt<'a> {\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub resolver: &'a mut Resolver,\n+    pub resolve_err_count: usize,\n     pub current_expansion: ExpansionData,\n }\n \n@@ -581,6 +584,7 @@ impl<'a> ExtCtxt<'a> {\n             ecfg: ecfg,\n             crate_root: None,\n             resolver: resolver,\n+            resolve_err_count: 0,\n             current_expansion: ExpansionData {\n                 mark: Mark::root(),\n                 depth: 0,"}, {"sha": "36a33dcc5c570aa201effdf160513b5b2b9f0c03", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -16,7 +16,7 @@ use ext::placeholders::{placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n-use config::StripUnconfigured;\n+use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n@@ -206,7 +206,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+        if self.cx.parse_sess.span_diagnostic.err_count() - self.cx.resolve_err_count > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n         }\n \n@@ -277,8 +277,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.cfg = crate_config;\n \n         if self.monotonic {\n+            let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n             let mark = self.cx.current_expansion.mark;\n             self.cx.resolver.visit_expansion(mark, &result.0);\n+            self.cx.resolve_err_count += self.cx.parse_sess.span_diagnostic.err_count() - err_count;\n         }\n \n         result\n@@ -674,7 +676,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let item = configure!(self, item);\n \n-        let (item, attr) = self.classify_item(item);\n+        let (mut item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n             let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n             return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n@@ -731,6 +733,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.cx.current_expansion.module = orig_module;\n                 return result;\n             }\n+            // Ensure that test functions are accessible from the test harness.\n+            ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n+                if item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n+                    item = item.map(|mut item| { item.vis = ast::Visibility::Public; item });\n+                }\n+                noop_fold_item(item, self)\n+            }\n             _ => noop_fold_item(item, self),\n         }\n     }"}, {"sha": "e4510520a55a435c43de5671d48651a0a044b8c3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n \n-        let i = if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n+        if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n                 ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n@@ -136,54 +136,37 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n-                    // debug!(\"have {} test/bench functions\",\n-                    //        cx.testfns.len());\n-\n-                    // Make all tests public so we can call them from outside\n-                    // the module (note that the tests are re-exported and must\n-                    // be made public themselves to avoid privacy errors).\n-                    i.map(|mut i| {\n-                        i.vis = ast::Visibility::Public;\n-                        i\n-                    })\n                 }\n             }\n-        } else {\n-            i\n-        };\n+        }\n \n+        let mut item = i.unwrap();\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        let res = match i.node {\n-            ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n-            _ => SmallVector::one(i),\n-        };\n+        if let ast::ItemKind::Mod(module) = item.node {\n+            let tests = mem::replace(&mut self.tests, Vec::new());\n+            let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n+            let mut mod_folded = fold::noop_fold_mod(module, self);\n+            let tests = mem::replace(&mut self.tests, tests);\n+            let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n+\n+            if !tests.is_empty() || !tested_submods.is_empty() {\n+                let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n+                mod_folded.items.push(it);\n+\n+                if !self.cx.path.is_empty() {\n+                    self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n+                } else {\n+                    debug!(\"pushing nothing, sym: {:?}\", sym);\n+                    self.cx.toplevel_reexport = Some(sym);\n+                }\n+            }\n+            item.node = ast::ItemKind::Mod(mod_folded);\n+        }\n         if ident.name != keywords::Invalid.name() {\n             self.cx.path.pop();\n         }\n-        res\n-    }\n-\n-    fn fold_mod(&mut self, m: ast::Mod) -> ast::Mod {\n-        let tests = mem::replace(&mut self.tests, Vec::new());\n-        let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n-        let mut mod_folded = fold::noop_fold_mod(m, self);\n-        let tests = mem::replace(&mut self.tests, tests);\n-        let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n-\n-        if !tests.is_empty() || !tested_submods.is_empty() {\n-            let (it, sym) = mk_reexport_mod(&mut self.cx, tests, tested_submods);\n-            mod_folded.items.push(it);\n-\n-            if !self.cx.path.is_empty() {\n-                self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n-            } else {\n-                debug!(\"pushing nothing, sym: {:?}\", sym);\n-                self.cx.toplevel_reexport = Some(sym);\n-            }\n-        }\n-\n-        mod_folded\n+        SmallVector::one(P(item))\n     }\n \n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n@@ -239,7 +222,7 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n+fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident>,\n                    tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n     let super_ = token::str_to_ident(\"super\");\n \n@@ -257,6 +240,8 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n+    let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n+    cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),"}, {"sha": "0295311334b6b04c73c6f3344ec678901fe2fb59", "filename": "src/test/codegen-units/item-collection/overloaded-operators.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -45,16 +45,16 @@ impl IndexMut<usize> for Indexable {\n }\n \n \n-//~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::eq[0]\n-//~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::ne[0]\n+//~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::eq[0]\n+//~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::ne[0]\n #[derive(PartialEq)]\n pub struct Equatable(u32);\n \n \n impl Add<u32> for Equatable {\n     type Output = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[3]::add[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::add[0]\n     fn add(self, rhs: u32) -> u32 {\n         self.0 + rhs\n     }\n@@ -63,7 +63,7 @@ impl Add<u32> for Equatable {\n impl Deref for Equatable {\n     type Target = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::deref[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[3]::deref[0]\n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }"}, {"sha": "6ae5544d68699651fba5ac593a8e28a3e1be426b", "filename": "src/test/compile-fail-fulldeps/derive-no-std-not-supported.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -10,7 +10,6 @@\n \n #![no_std]\n \n-extern crate core;\n extern crate rand;\n extern crate serialize as rustc_serialize;\n "}, {"sha": "9e042c3a7d50e2313ad3bfd849133a35dfb552d1", "filename": "src/test/compile-fail/gated-non-ascii-idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail%2Fgated-non-ascii-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail%2Fgated-non-ascii-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-non-ascii-idents.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate b\u00e4z; //~ ERROR non-ascii idents\n+extern crate core as b\u00e4z; //~ ERROR non-ascii idents\n \n use f\u00f6\u00f6::bar; //~ ERROR non-ascii idents\n "}, {"sha": "0f2a3f12107ef792cea29421797fc2c4773d9a51", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059cb2f3344c0a9efae17dde3d0e16a55ce93db/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=a059cb2f3344c0a9efae17dde3d0e16a55ce93db", "patch": "@@ -38,11 +38,17 @@ pub fn main() {\n     }\n }\n \n-use std::option::Option as Self;\n-//~^ ERROR expected identifier, found keyword `Self`\n+mod m1 {\n+    extern crate core as Self;\n+    //~^ ERROR expected identifier, found keyword `Self`\n+}\n \n-extern crate Self;\n-//~^ ERROR expected identifier, found keyword `Self`\n+mod m2 {\n+    use std::option::Option as Self;\n+    //~^ ERROR expected identifier, found keyword `Self`\n+}\n \n-trait Self {}\n-//~^ ERROR expected identifier, found keyword `Self`\n+mod m3 {\n+    trait Self {}\n+    //~^ ERROR expected identifier, found keyword `Self`\n+}"}]}