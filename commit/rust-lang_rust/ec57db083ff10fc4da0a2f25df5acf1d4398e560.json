{"sha": "ec57db083ff10fc4da0a2f25df5acf1d4398e560", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTdkYjA4M2ZmMTBmYzRkYTBhMmYyNWRmNWFjZjFkNDM5OGU1NjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-25T03:45:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T18:48:04Z"}, "message": "rustc: Add the concept of a Strict Version Hash\n\nThis new SVH is used to uniquely identify all crates as a snapshot in time of\ntheir ABI/API/publicly reachable state. This current calculation is just a hash\nof the entire crate's AST. This is obviously incorrect, but it is currently the\nreality for today.\n\nThis change threads through the new Svh structure which originates from crate\ndependencies. The concept of crate id hash is preserved to provide efficient\nmatching on filenames for crate loading. The inspected hash once crate metadata\nis opened has been changed to use the new Svh.\n\nThe goal of this hash is to identify when upstream crates have changed but\ndownstream crates have not been recompiled. This will prevent the def-id drift\nproblem where upstream crates were recompiled, thereby changing their metadata,\nbut downstream crates were not recompiled.\n\nIn the future this hash can be expanded to exclude contents of the AST like doc\ncomments, but limitations in the compiler prevent this change from being made at\nthis time.\n\nCloses #10207", "tree": {"sha": "335775f0a85a2a892dc3ed8fdb4091d4b3440ba1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/335775f0a85a2a892dc3ed8fdb4091d4b3440ba1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec57db083ff10fc4da0a2f25df5acf1d4398e560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec57db083ff10fc4da0a2f25df5acf1d4398e560", "html_url": "https://github.com/rust-lang/rust/commit/ec57db083ff10fc4da0a2f25df5acf1d4398e560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec57db083ff10fc4da0a2f25df5acf1d4398e560/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8213e184477c19eba75840e9310266a6529de20a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8213e184477c19eba75840e9310266a6529de20a", "html_url": "https://github.com/rust-lang/rust/commit/8213e184477c19eba75840e9310266a6529de20a"}], "stats": {"total": 480, "additions": 343, "deletions": 137}, "files": [{"sha": "bc5961a99813165e54e97cdad6f63350f74ca900", "filename": "mk/clean.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -58,6 +58,7 @@ clean-generic-$(2)-$(1):\n          -name '*.[odasS]' -o \\\n          -name '*.so' -o      \\\n          -name '*.dylib' -o   \\\n+         -name '*.rlib' -o   \\\n          -name 'stamp.*' -o   \\\n          -name '*.lib' -o     \\\n          -name '*.dll' -o     \\"}, {"sha": "bacc98a01356aab59aa7de9e0214a800e6ad81cd", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n+use back::svh::Svh;\n use driver::driver::{CrateTranslation, OutputFilenames};\n use driver::session::Session;\n use driver::session;\n@@ -499,28 +499,31 @@ pub mod write {\n  *    system linkers understand.\n  */\n \n-pub fn build_link_meta(attrs: &[ast::Attribute],\n-                       output: &OutputFilenames,\n-                       symbol_hasher: &mut Sha256)\n-                       -> LinkMeta {\n-    // This calculates CMH as defined above\n-    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> ~str {\n-        symbol_hasher.reset();\n-        symbol_hasher.input_str(crateid.to_str());\n-        truncated_hash_result(symbol_hasher)\n-    }\n-\n-    let crateid = match attr::find_crateid(attrs) {\n+pub fn find_crate_id(attrs: &[ast::Attribute],\n+                     output: &OutputFilenames) -> CrateId {\n+    match attr::find_crateid(attrs) {\n         None => from_str(output.out_filestem).unwrap(),\n         Some(s) => s,\n-    };\n+    }\n+}\n \n-    let hash = crate_hash(symbol_hasher, &crateid);\n+pub fn crate_id_hash(crate_id: &CrateId) -> ~str {\n+    // This calculates CMH as defined above. Note that we don't use the path of\n+    // the crate id in the hash because lookups are only done by (name/vers),\n+    // not by path.\n+    let mut s = Sha256::new();\n+    s.input_str(crate_id.short_name_with_version());\n+    truncated_hash_result(&mut s).slice_to(8).to_owned()\n+}\n \n-    LinkMeta {\n-        crateid: crateid,\n-        crate_hash: hash,\n-    }\n+pub fn build_link_meta(krate: &ast::Crate,\n+                       output: &OutputFilenames) -> LinkMeta {\n+    let r = LinkMeta {\n+        crateid: find_crate_id(krate.attrs, output),\n+        crate_hash: Svh::calculate(krate),\n+    };\n+    info!(\"{}\", r);\n+    return r;\n }\n \n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n@@ -539,7 +542,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &mut Sha256,\n     symbol_hasher.reset();\n     symbol_hasher.input_str(link_meta.crateid.name);\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(link_meta.crate_hash);\n+    symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n@@ -712,11 +715,8 @@ pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> ~str\n     mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n }\n \n-pub fn output_lib_filename(lm: &LinkMeta) -> ~str {\n-    format!(\"{}-{}-{}\",\n-            lm.crateid.name,\n-            lm.crate_hash.slice_chars(0, 8),\n-            lm.crateid.version_or_default())\n+pub fn output_lib_filename(id: &CrateId) -> ~str {\n+    format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {\n@@ -779,11 +779,11 @@ fn remove(sess: Session, path: &Path) {\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   lm: &LinkMeta) -> ~[Path] {\n+                   id: &CrateId) -> ~[Path] {\n     let mut out_filenames = ~[];\n     let crate_types = sess.crate_types.borrow();\n     for &crate_type in crate_types.get().iter() {\n-        let out_file = link_binary_output(sess, trans, crate_type, outputs, lm);\n+        let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n         out_filenames.push(out_file);\n     }\n \n@@ -807,8 +807,8 @@ fn is_writeable(p: &Path) -> bool {\n }\n \n pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n-                          lm: &LinkMeta, out_filename: &Path) -> Path {\n-    let libname = output_lib_filename(lm);\n+                          id: &CrateId, out_filename: &Path) -> Path {\n+    let libname = output_lib_filename(id);\n     match crate_type {\n         session::CrateTypeRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n@@ -834,13 +834,13 @@ fn link_binary_output(sess: Session,\n                       trans: &CrateTranslation,\n                       crate_type: session::CrateType,\n                       outputs: &OutputFilenames,\n-                      lm: &LinkMeta) -> Path {\n+                      id: &CrateId) -> Path {\n     let obj_filename = outputs.temp_path(OutputTypeObject);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n         None => {\n             let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(&sess, crate_type, lm, &out_filename)\n+            filename_for_input(&sess, crate_type, id, &out_filename)\n         }\n     };\n "}, {"sha": "5f8a12b022a508ae887bedbff42d4f52eb19ad49", "filename": "src/librustc/back/svh.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation and management of a Strict Version Hash for crates\n+//!\n+//! # Today's ABI problem\n+//!\n+//! In today's implementation of rustc, it is incredibly difficult to achieve\n+//! forward binary compatibility without resorting to C-like interfaces. Within\n+//! rust code itself, abi details such as symbol names suffer from a variety of\n+//! unrelated factors to code changing such as the \"def id drift\" problem. This\n+//! ends up yielding confusing error messages about metadata mismatches and\n+//! such.\n+//!\n+//! The core of this problem is when when an upstream dependency changes and\n+//! downstream dependants are not recompiled. This causes compile errors because\n+//! the upstream crate's metadata has changed but the downstream crates are\n+//! still referencing the older crate's metadata.\n+//!\n+//! This problem exists for many reasons, the primary of which is that rust does\n+//! not currently support forwards ABI compatibility (in place upgrades of a\n+//! crate).\n+//!\n+//! # SVH and how it alleviates the problem\n+//!\n+//! With all of this knowledge on hand, this module contains the implementation\n+//! of a notion of a \"Strict Version Hash\" for a crate. This is essentially a\n+//! hash of all contents of a crate which can somehow be exposed to downstream\n+//! crates.\n+//!\n+//! This hash is currently calculated by just hashing the AST, but this is\n+//! obviously wrong (doc changes should not result in an incompatible ABI).\n+//! Implementation-wise, this is required at this moment in time.\n+//!\n+//! By encoding this strict version hash into all crate's metadata, stale crates\n+//! can be detected immediately and error'd about by rustc itself.\n+//!\n+//! # Relevant links\n+//!\n+//! Original issue: https://github.com/mozilla/rust/issues/10207\n+\n+use std::fmt;\n+use std::hash::Hash;\n+use std::hash::sip::SipState;\n+use std::iter::range_step;\n+use syntax::ast;\n+\n+#[deriving(Clone, Eq)]\n+pub struct Svh {\n+    priv hash: ~str,\n+}\n+\n+impl Svh {\n+    pub fn new(hash: &str) -> Svh {\n+        assert!(hash.len() == 16);\n+        Svh { hash: hash.to_owned() }\n+    }\n+\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        self.hash.as_slice()\n+    }\n+\n+    pub fn calculate(krate: &ast::Crate) -> Svh {\n+        // FIXME: see above for why this is wrong, it shouldn't just hash the\n+        //        crate.  Fixing this would require more in-depth analysis in\n+        //        this function about what portions of the crate are reachable\n+        //        in tandem with bug fixes throughout the rest of the compiler.\n+        //\n+        //        Note that for now we actually exclude some top-level things\n+        //        from the crate like the CrateConfig/span. The CrateConfig\n+        //        contains command-line `--cfg` flags, so this means that the\n+        //        stage1/stage2 AST for libstd and such is different hash-wise\n+        //        when it's actually the exact same representation-wise.\n+        //\n+        //        As a first stab at only hashing the relevant parts of the\n+        //        AST, this only hashes the module/attrs, not the CrateConfig\n+        //        field.\n+        //\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipState::new();\n+        krate.module.hash(&mut state);\n+        krate.attrs.hash(&mut state);\n+\n+        let hash = state.result();\n+        return Svh {\n+            hash: range_step(0, 64, 4).map(|i| hex(hash >> i)).collect()\n+        };\n+\n+        fn hex(b: u64) -> char {\n+            let b = (b & 0xf) as u8;\n+            let b = match b {\n+                0 .. 9 => '0' as u8 + b,\n+                _ => 'a' as u8 + b - 10,\n+            };\n+            b as char\n+        }\n+    }\n+}\n+\n+impl fmt::Show for Svh {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(self.as_str())\n+    }\n+}"}, {"sha": "d5ee736b6fb7f0284401440593d476399bb76c66", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -433,7 +433,7 @@ pub fn phase_6_link_output(sess: Session,\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           &trans.link));\n+                           &trans.link.crateid));\n }\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n@@ -472,8 +472,7 @@ fn write_out_deps(sess: Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n-    let lm = link::build_link_meta(krate.attrs, outputs,\n-                                   &mut ::util::sha2::Sha256::new());\n+    let id = link::find_crate_id(krate.attrs, outputs);\n \n     let mut out_filenames = ~[];\n     for output_type in sess.opts.output_types.iter() {\n@@ -482,7 +481,7 @@ fn write_out_deps(sess: Session,\n             link::OutputTypeExe => {\n                 let crate_types = sess.crate_types.borrow();\n                 for output in crate_types.get().iter() {\n-                    let p = link::filename_for_input(&sess, *output, &lm, &file);\n+                    let p = link::filename_for_input(&sess, *output, &id, &file);\n                     out_filenames.push(p);\n                 }\n             }"}, {"sha": "2e647e5ca82950265e407a90b16aeec061d83722", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -55,7 +55,6 @@ use std::str;\n use std::task;\n use std::vec;\n use syntax::ast;\n-use syntax::attr;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n use syntax::parse;\n@@ -104,16 +103,17 @@ pub mod front {\n }\n \n pub mod back {\n-    pub mod archive;\n-    pub mod link;\n     pub mod abi;\n+    pub mod archive;\n     pub mod arm;\n+    pub mod link;\n+    pub mod lto;\n     pub mod mips;\n-    pub mod x86;\n-    pub mod x86_64;\n     pub mod rpath;\n+    pub mod svh;\n     pub mod target_strs;\n-    pub mod lto;\n+    pub mod x86;\n+    pub mod x86_64;\n }\n \n pub mod metadata;\n@@ -312,28 +312,18 @@ pub fn run_compiler(args: &[~str]) {\n         let attrs = parse_crate_attrs(sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n                                                   attrs, sess);\n-        if crate_id || crate_name {\n-            let crateid = match attr::find_crateid(attrs) {\n-                Some(crateid) => crateid,\n-                None => {\n-                    sess.fatal(\"No crate_id and --crate-id or \\\n-                                --crate-name requested\")\n-                }\n-            };\n-            if crate_id {\n-                println!(\"{}\", crateid.to_str());\n-            }\n-            if crate_name {\n-                println!(\"{}\", crateid.name);\n-            }\n-        }\n+        let id = link::find_crate_id(attrs, &t_outputs);\n \n+        if crate_id {\n+            println!(\"{}\", id.to_str());\n+        }\n+        if crate_name {\n+            println!(\"{}\", id.name);\n+        }\n         if crate_file_name {\n-            let lm = link::build_link_meta(attrs, &t_outputs,\n-                                           &mut ::util::sha2::Sha256::new());\n             let crate_types = session::collect_crate_types(&sess, attrs);\n             for &style in crate_types.iter() {\n-                let fname = link::filename_for_input(&sess, style, &lm,\n+                let fname = link::filename_for_input(&sess, style, &id,\n                                                      &t_outputs.with_extension(\"\"));\n                 println!(\"{}\", fname.filename_display());\n             }"}, {"sha": "7b7d526411c932d709136eedc4d430b60d3bd28d", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -12,6 +12,7 @@\n \n use std::cast;\n use syntax::crateid::CrateId;\n+use back::svh::Svh;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -207,8 +208,8 @@ pub static tag_macro_registrar_fn: uint = 0x63;\n pub static tag_exported_macros: uint = 0x64;\n pub static tag_macro_def: uint = 0x65;\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct LinkMeta {\n     crateid: CrateId,\n-    crate_hash: ~str,\n+    crate_hash: Svh,\n }"}, {"sha": "165c1abdeedfa96376de205fb94b9ca42bf8b827", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -12,6 +12,8 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n+use back::link;\n+use back::svh::Svh;\n use driver::{driver, session};\n use driver::session::Session;\n use metadata::csearch;\n@@ -78,7 +80,7 @@ impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n-    hash: ~str,\n+    hash: Svh,\n     crate_id: CrateId,\n }\n \n@@ -148,7 +150,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, \"\",\n+            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, None,\n                                      i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -276,12 +278,13 @@ fn visit_item(e: &Env, i: &ast::Item) {\n }\n \n fn existing_match(e: &Env, crate_id: &CrateId,\n-                  hash: &str) -> Option<ast::CrateNum> {\n+                  hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n-        if crate_id.matches(&c.crate_id) &&\n-           (hash.is_empty() || hash == c.hash.as_slice()) {\n-            return Some(c.cnum)\n+        if !crate_id.matches(&c.crate_id) { continue }\n+        match hash {\n+            Some(hash) if *hash != c.hash => {}\n+            Some(..) | None => return Some(c.cnum)\n         }\n     }\n     None\n@@ -291,19 +294,22 @@ fn resolve_crate(e: &mut Env,\n                  root_ident: Option<&str>,\n                  ident: &str,\n                  crate_id: &CrateId,\n-                 hash: &str,\n+                 hash: Option<&Svh>,\n                  span: Span)\n               -> ast::CrateNum {\n     match existing_match(e, crate_id, hash) {\n         None => {\n-            let load_ctxt = loader::Context {\n+            let id_hash = link::crate_id_hash(crate_id);\n+            let mut load_ctxt = loader::Context {\n                 sess: e.sess,\n                 span: span,\n                 ident: ident,\n                 crate_id: crate_id,\n-                hash: hash,\n+                id_hash: id_hash,\n+                hash: hash.map(|a| &*a),\n                 os: e.os,\n-                intr: e.intr\n+                intr: e.intr,\n+                rejected_via_hash: false,\n             };\n             let loader::Library {\n                 dylib, rlib, metadata\n@@ -375,7 +381,7 @@ fn resolve_crate_deps(e: &mut Env,\n         let local_cnum = resolve_crate(e, root_ident,\n                                        dep.crate_id.name.as_slice(),\n                                        &dep.crate_id,\n-                                       dep.hash,\n+                                       Some(&dep.hash),\n                                        span);\n         cnum_map.insert(extrn_cnum, local_cnum);\n     }\n@@ -406,7 +412,7 @@ impl CrateLoader for Loader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n         let cnum = resolve_crate(&mut self.env, None, info.ident,\n-                                 &info.crate_id, \"\", krate.span);\n+                                 &info.crate_id, None, krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "baca85d50ae97c525cc839ccd2aeb0d2cf5f053a", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -13,6 +13,7 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n+use back::svh::Svh;\n use metadata::decoder;\n use metadata::loader;\n \n@@ -92,7 +93,7 @@ impl CStore {\n         *metas.get().get(&cnum)\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> ~str {\n+    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }"}, {"sha": "42754aedba704cfd416fe2804464abde439151be", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n use metadata::csearch::StaticMethodInfo;\n@@ -1089,9 +1090,9 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     return attrs;\n }\n \n-fn list_crate_attributes(md: ebml::Doc, hash: &str,\n+fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n-    try!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n+    try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n@@ -1109,7 +1110,7 @@ pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n     crate_id: CrateId,\n-    hash: ~str,\n+    hash: Svh,\n }\n \n pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n@@ -1123,7 +1124,7 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let crate_id = from_str(docstr(depdoc, tag_crate_dep_crateid)).unwrap();\n-        let hash = docstr(depdoc, tag_crate_dep_hash);\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n         deps.push(CrateDep {\n             cnum: crate_num,\n             crate_id: crate_id,\n@@ -1144,10 +1145,10 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     Ok(())\n }\n \n-pub fn get_crate_hash(data: &[u8]) -> ~str {\n+pub fn get_crate_hash(data: &[u8]) -> Svh {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    hashdoc.as_str_slice().to_str()\n+    Svh::new(hashdoc.as_str_slice())\n }\n \n pub fn get_crate_id(data: &[u8]) -> CrateId {\n@@ -1159,7 +1160,7 @@ pub fn get_crate_id(data: &[u8]) -> CrateId {\n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    try!(list_crate_attributes(md, hash, out));\n+    try!(list_crate_attributes(md, &hash, out));\n     list_crate_deps(bytes, out)\n }\n "}, {"sha": "5bcc113ef946ba01b3a8818903cfac6d275559bc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -13,6 +13,7 @@\n #[allow(unused_must_use)]; // everything is just a MemWriter, can't fail\n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n@@ -1733,14 +1734,14 @@ fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n     ebml_w.writer.write(dep.crate_id.to_str().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(dep.hash.as_bytes());\n+    ebml_w.writer.write(dep.hash.as_str().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n+fn encode_hash(ebml_w: &mut writer::Encoder, hash: &Svh) {\n     ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(hash.as_bytes());\n+    ebml_w.writer.write(hash.as_str().as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -1809,7 +1810,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     let mut ebml_w = writer::Encoder(wr);\n \n     encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n-    encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n+    encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n \n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);"}, {"sha": "9c61191ff9916da0c8220485075c81e2c52e5446", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -11,6 +11,7 @@\n //! Finds crate binaries and loads their metadata\n \n use back::archive::{ArchiveRO, METADATA_FILENAME};\n+use back::svh::Svh;\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n@@ -21,7 +22,6 @@ use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n-use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n@@ -49,9 +49,11 @@ pub struct Context<'a> {\n     span: Span,\n     ident: &'a str,\n     crate_id: &'a CrateId,\n-    hash: &'a str,\n+    id_hash: &'a str,\n+    hash: Option<&'a Svh>,\n     os: Os,\n-    intr: @IdentInterner\n+    intr: @IdentInterner,\n+    rejected_via_hash: bool,\n }\n \n pub struct Library {\n@@ -79,23 +81,34 @@ fn realpath(p: &Path) -> Path {\n }\n \n impl<'a> Context<'a> {\n-    pub fn load_library_crate(&self, root_ident: Option<&str>) -> Library {\n+    pub fn load_library_crate(&mut self, root_ident: Option<&str>) -> Library {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n                 self.sess.abort_if_errors();\n+                let message = if self.rejected_via_hash {\n+                    format!(\"found possibly newer version of crate `{}`\",\n+                            self.ident)\n+                } else {\n+                    format!(\"can't find crate for `{}`\", self.ident)\n+                };\n                 let message = match root_ident {\n-                    None => format!(\"can't find crate for `{}`\", self.ident),\n-                    Some(c) => format!(\"can't find crate for `{}` which `{}` depends on\",\n-                                       self.ident,\n-                                       c)\n+                    None => message,\n+                    Some(c) => format!(\"{} which `{}` depends on\", message, c),\n                 };\n-                self.sess.span_fatal(self.span, message);\n+                self.sess.span_err(self.span, message);\n+\n+                if self.rejected_via_hash {\n+                    self.sess.span_note(self.span, \"perhaps this crate needs \\\n+                                                    to be recompiled?\");\n+                }\n+                self.sess.abort_if_errors();\n+                unreachable!()\n             }\n         }\n     }\n \n-    fn find_library_crate(&self) -> Option<Library> {\n+    fn find_library_crate(&mut self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n         let (dyprefix, dysuffix) = self.dylibname();\n \n@@ -212,13 +225,8 @@ impl<'a> Context<'a> {\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n-                    let attrs = decoder::get_crate_attributes(data);\n-                    match attr::find_crateid(attrs) {\n-                        None => {}\n-                        Some(crateid) => {\n-                            note_crateid_attr(self.sess.diagnostic(), &crateid);\n-                        }\n-                    }\n+                    let crate_id = decoder::get_crate_id(data);\n+                    note_crateid_attr(self.sess.diagnostic(), &crate_id);\n                 }\n                 None\n             }\n@@ -240,18 +248,21 @@ impl<'a> Context<'a> {\n         debug!(\"matching -- {}, middle: {}\", file, middle);\n         let mut parts = middle.splitn('-', 1);\n         let hash = match parts.next() { Some(h) => h, None => return None };\n-        debug!(\"matching -- {}, hash: {}\", file, hash);\n+        debug!(\"matching -- {}, hash: {} (want {})\", file, hash, self.id_hash);\n         let vers = match parts.next() { Some(v) => v, None => return None };\n-        debug!(\"matching -- {}, vers: {}\", file, vers);\n+        debug!(\"matching -- {}, vers: {} (want {})\", file, vers,\n+               self.crate_id.version);\n         match self.crate_id.version {\n             Some(ref version) if version.as_slice() != vers => return None,\n-            Some(..) | None => {}\n+            Some(..) => {} // check the hash\n+\n+            // hash is irrelevant, no version specified\n+            None => return Some(hash.to_owned())\n         }\n-        debug!(\"matching -- {}, vers ok (requested {})\", file,\n-               self.crate_id.version);\n+        debug!(\"matching -- {}, vers ok\", file);\n         // hashes in filenames are prefixes of the \"true hash\"\n-        if self.hash.is_empty() || self.hash.starts_with(hash) {\n-            debug!(\"matching -- {}, hash ok (requested {})\", file, self.hash);\n+        if self.id_hash == hash.as_slice() {\n+            debug!(\"matching -- {}, hash ok\", file);\n             Some(hash.to_owned())\n         } else {\n             None\n@@ -270,7 +281,7 @@ impl<'a> Context<'a> {\n     // FIXME(#10786): for an optimization, we only read one of the library's\n     //                metadata sections. In theory we should read both, but\n     //                reading dylib metadata is quite slow.\n-    fn extract_one(&self, m: HashSet<Path>, flavor: &str,\n+    fn extract_one(&mut self, m: HashSet<Path>, flavor: &str,\n                    slot: &mut Option<MetadataBlob>) -> Option<Path> {\n         if m.len() == 0 { return None }\n         if m.len() > 1 {\n@@ -290,7 +301,7 @@ impl<'a> Context<'a> {\n             info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n             match get_metadata_section(self.os, &lib) {\n                 Some(blob) => {\n-                    if crate_matches(blob.as_slice(), self.crate_id, self.hash){\n+                    if self.crate_matches(blob.as_slice()) {\n                         *slot = Some(blob);\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -306,6 +317,22 @@ impl<'a> Context<'a> {\n         return Some(lib);\n     }\n \n+    fn crate_matches(&mut self, crate_data: &[u8]) -> bool {\n+        let other_id = decoder::get_crate_id(crate_data);\n+        if !self.crate_id.matches(&other_id) { return false }\n+        match self.hash {\n+            None => true,\n+            Some(hash) => {\n+                if *hash != decoder::get_crate_hash(crate_data) {\n+                    self.rejected_via_hash = true;\n+                    false\n+                } else {\n+                    true\n+                }\n+            }\n+        }\n+    }\n+\n     // Returns the corresponding (prefix, suffix) that files need to have for\n     // dynamic libraries\n     fn dylibname(&self) -> (&'static str, &'static str) {\n@@ -323,15 +350,6 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n \n-fn crate_matches(crate_data: &[u8], crate_id: &CrateId, hash: &str) -> bool {\n-    let other_id = decoder::get_crate_id(crate_data);\n-    if !crate_id.matches(&other_id) { return false }\n-    if hash != \"\" && hash != decoder::get_crate_hash(crate_data).as_slice() {\n-        return false\n-    }\n-    return true;\n-}\n-\n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n         let data: &'static [u8] = {"}, {"sha": "683246f3333beb73d0dd3a0ebbd8ba150beadbc2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -2453,7 +2453,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(\"_rust_crate_map_\" + mapmeta.crateid.name, mapmeta.crate_hash,\n+        symname(\"_rust_crate_map_\" + mapmeta.crateid.name,\n+                mapmeta.crate_hash.as_str(),\n                 mapmeta.crateid.version_or_default())\n     };\n \n@@ -2487,7 +2488,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     while cstore.have_crate_data(i) {\n         let cdata = cstore.get_crate_data(i);\n         let nm = symname(format!(\"_rust_crate_map_{}\", cdata.name),\n-                         cstore.get_crate_hash(i),\n+                         cstore.get_crate_hash(i).as_str(),\n                          cstore.get_crate_id(i).version_or_default());\n         let cr = nm.with_c_str(|buf| {\n             unsafe {\n@@ -2609,9 +2610,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n     }\n \n-    let mut symbol_hasher = Sha256::new();\n-    let link_meta = link::build_link_meta(krate.attrs, output,\n-                                          &mut symbol_hasher);\n+    let link_meta = link::build_link_meta(&krate, output);\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n     //\n@@ -2621,16 +2620,16 @@ pub fn trans_crate(sess: session::Session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.crateid.name.clone() + \".rs\";\n+    let llmod_id = link_meta.crateid.name + \".rs\";\n \n     let ccx = @CrateContext::new(sess,\n-                                     llmod_id,\n-                                     analysis.ty_cx,\n-                                     analysis.exp_map2,\n-                                     analysis.maps,\n-                                     symbol_hasher,\n-                                     link_meta,\n-                                     analysis.reachable);\n+                                 llmod_id,\n+                                 analysis.ty_cx,\n+                                 analysis.exp_map2,\n+                                 analysis.maps,\n+                                 Sha256::new(),\n+                                 link_meta,\n+                                 analysis.reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &krate.module);"}, {"sha": "8350b24c451c9b5958cc408c4771404c42fedebf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -329,7 +329,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx,\n                 substs.tys[0],\n-                ccx.link_meta.crate_hash.clone());\n+                &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);"}, {"sha": "2ca19f0b61d82e5bbcb734db0921385c2a4e9810", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -10,6 +10,7 @@\n \n #[allow(non_camel_case_types)];\n \n+use back::svh::Svh;\n use driver::session;\n use metadata::csearch;\n use metadata;\n@@ -4882,7 +4883,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n+pub fn hash_crate_independent(tcx: ctxt, t: t, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n@@ -4913,11 +4914,11 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n     };\n     let did = |state: &mut sip::SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n-            local_hash.clone()\n+            svh.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_bytes().hash(state);\n+        h.as_str().hash(state);\n         did.node.hash(state);\n     };\n     let mt = |state: &mut sip::SipState, mt: mt| {"}, {"sha": "c0bdbf81772ac4edcf37c8e9c35d6ae2c6b995f0", "filename": "src/test/auxiliary/changing-crates-a1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"a\"];\n+\n+pub fn foo<T>() {}"}, {"sha": "cc123c0f65ddf9f259e0e1a3aa146563972e73de", "filename": "src/test/auxiliary/changing-crates-a2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"a\"];\n+\n+pub fn foo<T>() { println!(\"hello!\"); }\n+"}, {"sha": "9b80583bb84a03143a1ddb39eed6079aa15b2216", "filename": "src/test/auxiliary/changing-crates-b.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id = \"b\"];\n+\n+extern crate a;\n+\n+pub fn foo() { a::foo::<int>(); }"}, {"sha": "43956752cd9b343fc72ee2f8f375ceab67815498", "filename": "src/test/compile-fail/bad-crate-id.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-crate-id.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo = \"\"; //~ ERROR: malformed crate id\n+extern crate bar = \"#a\"; //~ ERROR: malformed crate id\n+\n+fn main() {}"}, {"sha": "ae3ef7606671058d4cf9e314de5b51dbeee861ef", "filename": "src/test/compile-fail/changing-crates.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec57db083ff10fc4da0a2f25df5acf1d4398e560/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs?ref=ec57db083ff10fc4da0a2f25df5acf1d4398e560", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// note that these aux-build directives must be in this order\n+// aux-build:changing-crates-a1.rs\n+// aux-build:changing-crates-b.rs\n+// aux-build:changing-crates-a2.rs\n+\n+extern crate a;\n+extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n+//~^ NOTE: perhaps this crate needs to be recompiled\n+\n+fn main() {}"}]}