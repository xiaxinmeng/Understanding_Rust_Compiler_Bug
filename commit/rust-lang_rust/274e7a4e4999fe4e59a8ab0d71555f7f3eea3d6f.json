{"sha": "274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NGU3YTRlNDk5OWZlNGU1OWE4YWIwZDcxNTU1ZjdmM2VlYTNkNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-16T04:01:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-16T04:01:20Z"}, "message": "auto merge of #7816 : thestinger/rust/header, r=huonw\n\nNote that the headers are still on `~[T]` when `T` is managed. This is continued from #7605, which removed all the code relying on the headers and removed them from `~T` for non-managed `T`.", "tree": {"sha": "8ebad07a9b590b0e627ebb323423072bbb136f6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ebad07a9b590b0e627ebb323423072bbb136f6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "html_url": "https://github.com/rust-lang/rust/commit/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ba4583dbf234c4a080496715700c0878472a78", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ba4583dbf234c4a080496715700c0878472a78", "html_url": "https://github.com/rust-lang/rust/commit/47ba4583dbf234c4a080496715700c0878472a78"}, {"sha": "e118555ce67aadb0a58039b3e74f44a43b210528", "url": "https://api.github.com/repos/rust-lang/rust/commits/e118555ce67aadb0a58039b3e74f44a43b210528", "html_url": "https://github.com/rust-lang/rust/commit/e118555ce67aadb0a58039b3e74f44a43b210528"}], "stats": {"total": 374, "additions": 234, "deletions": 140}, "files": [{"sha": "0e9361193b0a31a5a9e6640d68089b51c686cb92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -63,34 +63,33 @@ pub enum LangItem {\n     FailFnLangItem,                    // 24\n     FailBoundsCheckFnLangItem,         // 25\n     ExchangeMallocFnLangItem,          // 26\n-    VectorExchangeMallocFnLangItem,    // 27\n-    ClosureExchangeMallocFnLangItem,   // 28\n-    ExchangeFreeFnLangItem,            // 29\n-    MallocFnLangItem,                  // 30\n-    FreeFnLangItem,                    // 31\n-    BorrowAsImmFnLangItem,             // 32\n-    BorrowAsMutFnLangItem,             // 33\n-    ReturnToMutFnLangItem,             // 34\n-    CheckNotBorrowedFnLangItem,        // 35\n-    StrDupUniqFnLangItem,              // 36\n-    RecordBorrowFnLangItem,            // 37\n-    UnrecordBorrowFnLangItem,          // 38\n-\n-    StartFnLangItem,                   // 39\n-\n-    TyDescStructLangItem,              // 40\n-    TyVisitorTraitLangItem,            // 41\n-    OpaqueStructLangItem,              // 42\n+    ClosureExchangeMallocFnLangItem,   // 27\n+    ExchangeFreeFnLangItem,            // 28\n+    MallocFnLangItem,                  // 29\n+    FreeFnLangItem,                    // 30\n+    BorrowAsImmFnLangItem,             // 31\n+    BorrowAsMutFnLangItem,             // 32\n+    ReturnToMutFnLangItem,             // 33\n+    CheckNotBorrowedFnLangItem,        // 34\n+    StrDupUniqFnLangItem,              // 35\n+    RecordBorrowFnLangItem,            // 36\n+    UnrecordBorrowFnLangItem,          // 37\n+\n+    StartFnLangItem,                   // 38\n+\n+    TyDescStructLangItem,              // 39\n+    TyVisitorTraitLangItem,            // 40\n+    OpaqueStructLangItem,              // 41\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..43]\n+    items: [Option<def_id>, ..42]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..43 ]\n+            items: [ None, ..42 ]\n         }\n     }\n \n@@ -130,24 +129,23 @@ impl LanguageItems {\n             24 => \"fail_\",\n             25 => \"fail_bounds_check\",\n             26 => \"exchange_malloc\",\n-            27 => \"vector_exchange_malloc\",\n-            28 => \"closure_exchange_malloc\",\n-            29 => \"exchange_free\",\n-            30 => \"malloc\",\n-            31 => \"free\",\n-            32 => \"borrow_as_imm\",\n-            33 => \"borrow_as_mut\",\n-            34 => \"return_to_mut\",\n-            35 => \"check_not_borrowed\",\n-            36 => \"strdup_uniq\",\n-            37 => \"record_borrow\",\n-            38 => \"unrecord_borrow\",\n-\n-            39 => \"start\",\n-\n-            40 => \"ty_desc\",\n-            41 => \"ty_visitor\",\n-            42 => \"opaque\",\n+            27 => \"closure_exchange_malloc\",\n+            28 => \"exchange_free\",\n+            29 => \"malloc\",\n+            30 => \"free\",\n+            31 => \"borrow_as_imm\",\n+            32 => \"borrow_as_mut\",\n+            33 => \"return_to_mut\",\n+            34 => \"check_not_borrowed\",\n+            35 => \"strdup_uniq\",\n+            36 => \"record_borrow\",\n+            37 => \"unrecord_borrow\",\n+\n+            38 => \"start\",\n+\n+            39 => \"ty_desc\",\n+            40 => \"ty_visitor\",\n+            41 => \"opaque\",\n \n             _ => \"???\"\n         }\n@@ -240,9 +238,6 @@ impl LanguageItems {\n     pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n-    pub fn vector_exchange_malloc_fn(&self) -> def_id {\n-        self.items[VectorExchangeMallocFnLangItem as uint].get()\n-    }\n     pub fn closure_exchange_malloc_fn(&self) -> def_id {\n         self.items[ClosureExchangeMallocFnLangItem as uint].get()\n     }\n@@ -336,7 +331,6 @@ impl<'self> LanguageItemCollector<'self> {\n         item_refs.insert(@\"fail_bounds_check\",\n                          FailBoundsCheckFnLangItem as uint);\n         item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-        item_refs.insert(@\"vector_exchange_malloc\", VectorExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"closure_exchange_malloc\", ClosureExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n         item_refs.insert(@\"malloc\", MallocFnLangItem as uint);"}, {"sha": "6e7ae19794da4a33e812af7aa1cc93dadf71d21c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -294,25 +294,6 @@ pub fn malloc_raw_dyn(bcx: block,\n             [size],\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n-    } else if heap == heap_exchange_vector {\n-        // Grab the TypeRef type of box_ptr_ty.\n-        let element_type = match ty::get(t).sty {\n-            ty::ty_unboxed_vec(e) => e,\n-            _ => fail!(\"not a vector body\")\n-        };\n-        let box_ptr_ty = ty::mk_evec(bcx.tcx(), element_type, ty::vstore_uniq);\n-        let llty = type_of(ccx, box_ptr_ty);\n-\n-        let llty_value = type_of::type_of(ccx, t);\n-        let llalign = llalign_of_min(ccx, llty_value);\n-\n-        // Allocate space:\n-        let r = callee::trans_lang_call(\n-            bcx,\n-            bcx.tcx().lang_items.vector_exchange_malloc_fn(),\n-            [C_i32(llalign as i32), size],\n-            None);\n-        rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     } else {\n         // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n         let (mk_fn, langcall) = match heap {\n@@ -322,7 +303,7 @@ pub fn malloc_raw_dyn(bcx: block,\n             heap_exchange_closure => {\n                 (ty::mk_imm_box, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n             }\n-            _ => fail!(\"heap_exchange/heap_exchange_vector already handled\")\n+            _ => fail!(\"heap_exchange already handled\")\n         };\n \n         // Grab the TypeRef type of box_ptr_ty."}, {"sha": "196807baabbe6c1c1a405ec7ab6c7a9e1c040da3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -283,7 +283,6 @@ pub enum heap {\n     heap_managed,\n     heap_managed_unique,\n     heap_exchange,\n-    heap_exchange_vector,\n     heap_exchange_closure\n }\n \n@@ -405,7 +404,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n         f\n       }\n-      heap_exchange | heap_exchange_vector | heap_exchange_closure => {\n+      heap_exchange | heap_exchange_closure => {\n         let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }"}, {"sha": "72e9f2724688f3e38479198be39f2de48df6ee41", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -460,7 +460,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                                       expr, contents);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n-            let heap = tvec::heap_for_unique_vector(bcx, expr_ty(bcx, contents));\n+            let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }"}, {"sha": "f007aa502dc1385cd21a6b33b6aace3fc2f6d243", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -397,9 +397,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_uniq(*) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n-        tvec::make_uniq_free_glue(bcx, v, t)\n-      }\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n       }"}, {"sha": "47f0a4c06aff419f3995ea8de9c19c5f621b4883", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -122,9 +122,9 @@ impl Reflector {\n                      bracket_name: &str,\n                      extra: &[ValueRef],\n                      inner: &fn(&mut Reflector)) {\n-        self.visit(~\"enter_\" + bracket_name, extra);\n+        self.visit(\"enter_\" + bracket_name, extra);\n         inner(self);\n-        self.visit(~\"leave_\" + bracket_name, extra);\n+        self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n     pub fn vstore_name_and_extra(&mut self,\n@@ -183,7 +183,11 @@ impl Reflector {\n           ty::ty_evec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n-              self.visit(~\"evec_\" + name, extra)\n+              if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).contains_managed() {\n+                  self.visit(\"evec_uniq_managed\", extra)\n+              } else {\n+                  self.visit(~\"evec_\" + name, extra)\n+              }\n           }\n           ty::ty_box(ref mt) => {\n               let extra = self.c_mt(mt);"}, {"sha": "8fff23c649848ab025a1fd248ad3285ce7d028fb", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -33,23 +33,6 @@ use std::option::None;\n use syntax::ast;\n use syntax::codemap;\n \n-pub fn make_uniq_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n-    -> block {\n-    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n-\n-    let not_null = IsNotNull(bcx, box_datum.val);\n-    do with_cond(bcx, not_null) |bcx| {\n-        let body_datum = box_datum.box_body(bcx);\n-        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n-                                body_datum.ty);\n-        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n-            glue::trans_free(bcx, box_datum.val)\n-        } else {\n-            glue::trans_exchange_free(bcx, box_datum.val)\n-        }\n-    }\n-}\n-\n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n@@ -59,7 +42,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n-        fail!(\"cannot treat vectors/strings as exchange allocations yet\");\n+        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n       }\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n@@ -80,8 +63,12 @@ pub fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    GEPi(bcx, vptr, [0u, abi::box_field_body])\n+pub fn get_bodyptr(bcx: block, vptr: ValueRef, t: ty::t) -> ValueRef {\n+    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+        GEPi(bcx, vptr, [0u, abi::box_field_body])\n+    } else {\n+        vptr\n+    }\n }\n \n pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n@@ -104,25 +91,24 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let base::MallocResult {bcx, box: bx, body} =\n-        base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n-    Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n-    base::maybe_set_managed_unique_rc(bcx, bx, heap);\n-    return rslt(bcx, bx);\n-}\n-\n-pub fn heap_for_unique_vector(bcx: block, t: ty::t) -> heap {\n-    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n-        heap_managed_unique\n+    if heap == heap_exchange {\n+        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vecbodyty, heap_exchange, vecsize);\n+        Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n+        Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n+        return rslt(bcx, val);\n     } else {\n-        heap_exchange_vector\n+        let base::MallocResult {bcx, box: bx, body} =\n+            base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n+        Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n+        Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n+        base::maybe_set_managed_unique_rc(bcx, bx, heap);\n+        return rslt(bcx, bx);\n     }\n }\n \n pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n-    alloc_raw(bcx, unit_ty, fill, alloc, heap_for_unique_vector(bcx, unit_ty))\n+    alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n }\n \n pub fn alloc_vec(bcx: block,\n@@ -146,12 +132,12 @@ pub fn alloc_vec(bcx: block,\n pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n     let _icx = push_ctxt(\"tvec::duplicate_uniq\");\n \n-    let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n+    let fill = get_fill(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let Result {bcx, val: newptr} = alloc_uniq_raw(bcx, unit_ty, fill, fill);\n \n-    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n-    let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr));\n+    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n+    let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr, vec_ty));\n     base::call_memcpy(bcx, new_data_ptr, data_ptr, fill, 1);\n \n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n@@ -323,7 +309,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n \n     // Handle ~\"\".\n     match heap {\n-        heap_exchange_vector => {\n+        heap_exchange => {\n             match content_expr.node {\n                 ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n@@ -346,7 +332,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                 _ => {}\n             }\n         }\n-        heap_exchange | heap_exchange_closure => fail!(\"vectors use vector_exchange_alloc\"),\n+        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n \n@@ -356,7 +342,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n     let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n \n     add_clean_free(bcx, val, heap);\n-    let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n+    let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n \n     debug!(\"alloc_vec() returned val=%s, dataptr=%s\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n@@ -562,7 +548,7 @@ pub fn get_base_and_len(bcx: block,\n             (base, len)\n         }\n         ty::vstore_uniq | ty::vstore_box => {\n-            let body = get_bodyptr(bcx, llval);\n+            let body = get_bodyptr(bcx, llval, vec_ty);\n             (get_dataptr(bcx, body), get_fill(bcx, body))\n         }\n     }\n@@ -604,7 +590,7 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n pub fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                      fill: ValueRef, f: iter_vec_block) -> block {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n-    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n+    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n "}, {"sha": "4e15b4bc229473fabefea56323a057c66770839d", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -183,7 +183,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_estr(ty::vstore_uniq) => {\n-        Type::unique(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n+        Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n@@ -217,7 +217,11 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n           let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n-          Type::unique(cx, &ty).ptr_to()\n+          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+              Type::unique(cx, &ty).ptr_to()\n+          } else {\n+              ty.ptr_to()\n+          }\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);"}, {"sha": "fd16f4e5c6927b287d46ddeaad8cc71095c6e986", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -297,6 +297,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[@u8]>();\n+        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~[@u8]>();\n+        true\n+    }\n+\n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }"}, {"sha": "7707e83a9ce437079e268d8b47db7b6c25034435", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -353,6 +353,14 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&UnboxedVecRepr> |b| {\n+            self.writer.write_char('~');\n+            self.write_unboxed_vec_repr(mtbl, *b, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<&VecRepr> |b| {\n             self.writer.write_char('~');\n             self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);"}, {"sha": "d0b268ace54703963486a5931711fadc72d8669a", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -84,14 +84,6 @@ pub unsafe fn exchange_malloc(size: uintptr_t) -> *c_char {\n     malloc_raw(size as uint) as *c_char\n }\n \n-#[cfg(not(test))]\n-#[lang=\"vector_exchange_malloc\"]\n-#[inline]\n-pub unsafe fn vector_exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n-    let total_size = get_box_size(size as uint, align as uint);\n-    malloc_raw(total_size as uint) as *c_char\n-}\n-\n // FIXME: #7496\n #[cfg(not(test))]\n #[lang=\"closure_exchange_malloc\"]"}, {"sha": "bc3015685bb51caba2ae97d0b9a6d2f8975f37b3", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -1003,6 +1003,7 @@ pub mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **mut vec::raw::VecRepr = cast::transmute(v);\n         let repr: *mut vec::raw::VecRepr = *v;\n@@ -1012,6 +1013,18 @@ pub mod raw {\n         *null = 0u8;\n     }\n \n+    /// Sets the length of the string and adds the null terminator\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n+        let v: **mut vec::UnboxedVecRepr = cast::transmute(v);\n+        let repr: *mut vec::UnboxedVecRepr = *v;\n+        (*repr).fill = new_len + 1u;\n+        let null = ptr::mut_offset(cast::transmute(&((*repr).data)),\n+                                   new_len);\n+        *null = 0u8;\n+    }\n+\n     #[test]\n     fn test_from_buf_len() {\n         unsafe {\n@@ -2027,7 +2040,7 @@ impl NullTerminatedStr for @str {\n      */\n     #[inline]\n     fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n-        let ptr: &'a ~[u8] = unsafe { ::cast::transmute(self) };\n+        let ptr: &'a @[u8] = unsafe { ::cast::transmute(self) };\n         let slice: &'a [u8] = *ptr;\n         slice\n     }"}, {"sha": "015ecd67c83ccd2d658173aca9d85b0edf8d4510", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -99,6 +99,7 @@ pub trait TyVisitor {\n     fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool;"}, {"sha": "c728d4a60f15f3b292e5ef1e81358f24d2ae5caf", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 98, "deletions": 8, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -30,6 +30,7 @@ use ptr::RawPtr;\n use rt::global_heap::malloc_raw;\n use rt::global_heap::realloc_raw;\n use sys;\n+use sys::size_of;\n use uint;\n use unstable::intrinsics;\n #[cfg(stage0)]\n@@ -108,9 +109,9 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n             vec\n         } else {\n             let alloc = capacity * sys::nonzero_size_of::<T>();\n-            let ptr = malloc_raw(alloc + sys::size_of::<raw::VecRepr>()) as *mut raw::VecRepr;\n-            (*ptr).unboxed.alloc = alloc;\n-            (*ptr).unboxed.fill = 0;\n+            let ptr = malloc_raw(alloc + sys::size_of::<UnboxedVecRepr>()) as *mut UnboxedVecRepr;\n+            (*ptr).alloc = alloc;\n+            (*ptr).fill = 0;\n             cast::transmute(ptr)\n         }\n     }\n@@ -1150,7 +1151,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + sys::size_of::<raw::VecRepr>())\n+                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())\n                            as *mut raw::VecRepr;\n                     (**ptr).unboxed.alloc = alloc;\n                 }\n@@ -1173,19 +1174,20 @@ impl<T> OwnedVector<T> for ~[T] {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n             unsafe {\n-                let ptr: *mut *mut raw::VecRepr = cast::transmute(self);\n                 let td = get_tydesc::<T>();\n                 if contains_managed::<T>() {\n+                    let ptr: *mut *mut raw::VecRepr = cast::transmute(self);\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n+                    let ptr: *mut *mut UnboxedVecRepr = cast::transmute(self);\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    let size = alloc + sys::size_of::<raw::VecRepr>();\n+                    let size = alloc + sys::size_of::<UnboxedVecRepr>();\n                     if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n                         fail!(\"vector size is too large: %u\", n);\n                     }\n                     *ptr = realloc_raw(*ptr as *mut c_void, size)\n-                           as *mut raw::VecRepr;\n-                    (**ptr).unboxed.alloc = alloc;\n+                           as *mut UnboxedVecRepr;\n+                    (**ptr).alloc = alloc;\n                 }\n             }\n         }\n@@ -1211,15 +1213,32 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Returns the number of elements the vector can hold without reallocating.\n     #[inline]\n+    #[cfg(stage0)]\n     fn capacity(&self) -> uint {\n         unsafe {\n             let repr: **raw::VecRepr = transmute(self);\n             (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n         }\n     }\n \n+    /// Returns the number of elements the vector can hold without reallocating.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            if contains_managed::<T>() {\n+                let repr: **raw::VecRepr = transmute(self);\n+                (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n+            } else {\n+                let repr: **UnboxedVecRepr = transmute(self);\n+                (**repr).alloc / sys::nonzero_size_of::<T>()\n+            }\n+        }\n+    }\n+\n     /// Append an element to a vector\n     #[inline]\n+    #[cfg(stage0)]\n     fn push(&mut self, t: T) {\n         unsafe {\n             let repr: **raw::VecRepr = transmute(&mut *self);\n@@ -1233,8 +1252,36 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n+    /// Append an element to a vector\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn push(&mut self, t: T) {\n+        unsafe {\n+            if contains_managed::<T>() {\n+                let repr: **raw::VecRepr = transmute(&mut *self);\n+                let fill = (**repr).unboxed.fill;\n+                if (**repr).unboxed.alloc <= fill {\n+                    let new_len = self.len() + 1;\n+                    self.reserve_at_least(new_len);\n+                }\n+\n+                self.push_fast(t);\n+            } else {\n+                let repr: **UnboxedVecRepr = transmute(&mut *self);\n+                let fill = (**repr).fill;\n+                if (**repr).alloc <= fill {\n+                    let new_len = self.len() + 1;\n+                    self.reserve_at_least(new_len);\n+                }\n+\n+                self.push_fast(t);\n+            }\n+        }\n+    }\n+\n     // This doesn't bother to make sure we have space.\n     #[inline] // really pretty please\n+    #[cfg(stage0)]\n     unsafe fn push_fast(&mut self, t: T) {\n         let repr: **mut raw::VecRepr = transmute(self);\n         let fill = (**repr).unboxed.fill;\n@@ -1244,6 +1291,27 @@ impl<T> OwnedVector<T> for ~[T] {\n         intrinsics::move_val_init(&mut(*p), t);\n     }\n \n+    // This doesn't bother to make sure we have space.\n+    #[inline] // really pretty please\n+    #[cfg(not(stage0))]\n+    unsafe fn push_fast(&mut self, t: T) {\n+        if contains_managed::<T>() {\n+            let repr: **mut raw::VecRepr = transmute(self);\n+            let fill = (**repr).unboxed.fill;\n+            (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n+            let p = to_unsafe_ptr(&((**repr).unboxed.data));\n+            let p = ptr::offset(p, fill) as *mut T;\n+            intrinsics::move_val_init(&mut(*p), t);\n+        } else {\n+            let repr: **mut UnboxedVecRepr = transmute(self);\n+            let fill = (**repr).fill;\n+            (**repr).fill += sys::nonzero_size_of::<T>();\n+            let p = to_unsafe_ptr(&((**repr).data));\n+            let p = ptr::offset(p, fill) as *mut T;\n+            intrinsics::move_val_init(&mut(*p), t);\n+        }\n+    }\n+\n     /// Takes ownership of the vector `rhs`, moving all elements into\n     /// the current vector. This does not copy any elements, and it is\n     /// illegal to use the `rhs` vector after calling this method\n@@ -1834,6 +1902,8 @@ pub mod raw {\n     use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n     use util;\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::contains_managed;\n \n     /// The internal representation of a (boxed) vector\n     #[allow(missing_doc)]\n@@ -1858,11 +1928,31 @@ pub mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         let repr: **mut VecRepr = transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n     }\n \n+    /**\n+     * Sets the length of a vector\n+     *\n+     * This will explicitly set the size of the vector, without actually\n+     * modifing its buffers, so it is up to the caller to ensure that\n+     * the vector is actually the specified size.\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n+        if contains_managed::<T>() {\n+            let repr: **mut VecRepr = transmute(v);\n+            (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n+        } else {\n+            let repr: **mut UnboxedVecRepr = transmute(v);\n+            (**repr).fill = new_len * sys::nonzero_size_of::<T>();\n+        }\n+    }\n+\n     /**\n      * Returns an unsafe pointer to the vector's buffer\n      *"}, {"sha": "d70c2a91366bbbeff850284e54e35efb7ee2b9bc", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -390,9 +390,9 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n     if (zone != NULL) {\n         size_t size = strlen(zone);\n         reserve_vec_exact(&out_tm->tm_zone, size + 1);\n-        memcpy(out_tm->tm_zone->body.data, zone, size);\n-        out_tm->tm_zone->body.fill = size + 1;\n-        out_tm->tm_zone->body.data[size] = '\\0';\n+        memcpy(out_tm->tm_zone->data, zone, size);\n+        out_tm->tm_zone->fill = size + 1;\n+        out_tm->tm_zone->data[size] = '\\0';\n     }\n }\n "}, {"sha": "95651c686029fa5e66f825ebbfb662cf827d9e37", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -57,17 +57,17 @@ vec_data(rust_vec *v) {\n     return reinterpret_cast<T*>(v->data);\n }\n \n-inline void reserve_vec_exact(rust_vec_box** vpp,\n+inline void reserve_vec_exact(rust_vec** vpp,\n                               size_t size) {\n-    if (size > (*vpp)->body.alloc) {\n+    if (size > (*vpp)->alloc) {\n         rust_exchange_alloc exchange_alloc;\n-        *vpp = (rust_vec_box*)exchange_alloc\n-            .realloc(*vpp, size + sizeof(rust_vec_box));\n-        (*vpp)->body.alloc = size;\n+        *vpp = (rust_vec*)exchange_alloc\n+            .realloc(*vpp, size + sizeof(rust_vec));\n+        (*vpp)->alloc = size;\n     }\n }\n \n-typedef rust_vec_box rust_str;\n+typedef rust_vec rust_str;\n \n inline size_t get_box_size(size_t body_size, size_t body_align) {\n     size_t header_size = sizeof(rust_opaque_box);"}, {"sha": "b7ef4e3ff25d2c7bd70f98253f6e96063b15c101", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -284,6 +284,13 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[@u8]>();\n+        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~[@u8]>();\n+        true\n+    }\n+\n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n@@ -567,6 +574,7 @@ impl TyVisitor for my_visitor {\n     fn visit_unboxed_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }"}, {"sha": "e0d9165fe9949f5eeebf2df6fe7e59e9fe84c4d3", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=274e7a4e4999fe4e59a8ab0d71555f7f3eea3d6f", "patch": "@@ -85,6 +85,14 @@ impl TyVisitor for MyVisitor {\n         self.types.push(~\"]\");\n         true\n     }\n+    fn visit_evec_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.types.push(~\"[\");\n+        unsafe {\n+            visit_tydesc(inner, (@*self) as @TyVisitor);\n+        }\n+        self.types.push(~\"]\");\n+        true\n+    }\n     fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }"}]}