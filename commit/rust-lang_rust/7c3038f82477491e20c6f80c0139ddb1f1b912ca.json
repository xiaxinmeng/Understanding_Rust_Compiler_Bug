{"sha": "7c3038f82477491e20c6f80c0139ddb1f1b912ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMzAzOGY4MjQ3NzQ5MWUyMGM2ZjgwYzAxMzlkZGIxZjFiOTEyY2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-12T18:29:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-09T18:12:36Z"}, "message": "std: Don't spawn threads in `wait_with_output`\n\nSemantically there's actually no reason for us to spawn threads as part of the\ncall to `wait_with_output`, and that's generally an incredibly heavyweight\noperation for just reading a few bytes (especially when stderr probably rarely\nhas bytes!). An equivalent operation in terms of what's implemented today would\nbe to just drain both pipes of all contents and then call `wait` on the child\nprocess itself.\n\nOn Unix we can implement this through some convenient use of the `select`\nfunction, whereas on Windows we can make use of overlapped I/O. Note that on\nWindows this requires us to use named pipes instead of anonymous pipes, but\nthey're semantically the same under the hood.", "tree": {"sha": "915cb9e7c39365463e0c5ca2391e985dc72730b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/915cb9e7c39365463e0c5ca2391e985dc72730b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3038f82477491e20c6f80c0139ddb1f1b912ca", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3038f82477491e20c6f80c0139ddb1f1b912ca", "html_url": "https://github.com/rust-lang/rust/commit/7c3038f82477491e20c6f80c0139ddb1f1b912ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3038f82477491e20c6f80c0139ddb1f1b912ca/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6afa32a2504fa90b48f74979bb4061cb397e9270", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afa32a2504fa90b48f74979bb4061cb397e9270", "html_url": "https://github.com/rust-lang/rust/commit/6afa32a2504fa90b48f74979bb4061cb397e9270"}], "stats": {"total": 493, "additions": 459, "deletions": 34}, "files": [{"sha": "2278a549559c38872b4338cb002ecc2a80d860dc", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -1 +1 @@\n-Subproject commit e19309c8b4e8bbd11f4d84dfffd75e3d1ac477fe\n+Subproject commit 2278a549559c38872b4338cb002ecc2a80d860dc"}, {"sha": "5813d82a315a6bb17d371157ad2bef357e5f118c", "filename": "src/libstd/process.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -20,10 +20,9 @@ use fmt;\n use io;\n use path::Path;\n use str;\n-use sys::pipe::AnonPipe;\n+use sys::pipe::{read2, AnonPipe};\n use sys::process as imp;\n use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n-use thread::{self, JoinHandle};\n \n /// Representation of a running or exited child process.\n ///\n@@ -503,24 +502,29 @@ impl Child {\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait_with_output(mut self) -> io::Result<Output> {\n         drop(self.stdin.take());\n-        fn read<R>(mut input: R) -> JoinHandle<io::Result<Vec<u8>>>\n-            where R: Read + Send + 'static\n-        {\n-            thread::spawn(move || {\n-                let mut ret = Vec::new();\n-                input.read_to_end(&mut ret).map(|_| ret)\n-            })\n+\n+        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n+        match (self.stdout.take(), self.stderr.take()) {\n+            (None, None) => {}\n+            (Some(mut out), None) => {\n+                let res = out.read_to_end(&mut stdout);\n+                res.unwrap();\n+            }\n+            (None, Some(mut err)) => {\n+                let res = err.read_to_end(&mut stderr);\n+                res.unwrap();\n+            }\n+            (Some(out), Some(err)) => {\n+                let res = read2(out.inner, &mut stdout, err.inner, &mut stderr);\n+                res.unwrap();\n+            }\n         }\n-        let stdout = self.stdout.take().map(read);\n-        let stderr = self.stderr.take().map(read);\n-        let status = try!(self.wait());\n-        let stdout = stdout.and_then(|t| t.join().unwrap().ok());\n-        let stderr = stderr.and_then(|t| t.join().unwrap().ok());\n \n+        let status = try!(self.wait());\n         Ok(Output {\n             status: status,\n-            stdout: stdout.unwrap_or(Vec::new()),\n-            stderr: stderr.unwrap_or(Vec::new()),\n+            stdout: stdout,\n+            stderr: stderr,\n         })\n     }\n }"}, {"sha": "8ec073858fd2115eb6aaf32773e9d03f586da1f4", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n use prelude::v1::*;\n \n use io::{self, Read};\n@@ -75,6 +77,20 @@ impl FileDesc {\n         }\n     }\n \n+    pub fn set_nonblocking(&self, nonblocking: bool) {\n+        unsafe {\n+            let previous = libc::fcntl(self.fd, libc::F_GETFL);\n+            debug_assert!(previous != -1);\n+            let new = if nonblocking {\n+                previous | libc::O_NONBLOCK\n+            } else {\n+                previous & !libc::O_NONBLOCK\n+            };\n+            let ret = libc::fcntl(self.fd, libc::F_SETFL, new);\n+            debug_assert!(ret != -1);\n+        }\n+    }\n+\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n@@ -126,7 +142,6 @@ impl FileDesc {\n     }\n }\n \n-#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n impl<'a> Read for &'a FileDesc {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)"}, {"sha": "e5cb37610011b42496490e2514c63eb098f8d3da", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n+use cmp;\n use io;\n use libc::{self, c_int};\n+use mem;\n use sys::cvt_r;\n use sys::fd::FileDesc;\n \n@@ -68,3 +72,54 @@ impl AnonPipe {\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n     pub fn into_fd(self) -> FileDesc { self.0 }\n }\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+    // Set both pipes into nonblocking mode as we're gonna be reading from both\n+    // in the `select` loop below, and we wouldn't want one to block the other!\n+    let p1 = p1.into_fd();\n+    let p2 = p2.into_fd();\n+    p1.set_nonblocking(true);\n+    p2.set_nonblocking(true);\n+\n+    let max = cmp::max(p1.raw(), p2.raw());\n+    loop {\n+        // wait for either pipe to become readable using `select`\n+        try!(cvt_r(|| unsafe {\n+            let mut read: libc::fd_set = mem::zeroed();\n+            libc::FD_SET(p1.raw(), &mut read);\n+            libc::FD_SET(p2.raw(), &mut read);\n+            libc::select(max + 1, &mut read, 0 as *mut _, 0 as *mut _,\n+                         0 as *mut _)\n+        }));\n+\n+        // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+        // EAGAIN. If we hit EOF, then this will happen because the underlying\n+        // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+        // this case we flip the other fd back into blocking mode and read\n+        // whatever's leftover on that file descriptor.\n+        let read = |fd: &FileDesc, dst: &mut Vec<u8>| {\n+            match fd.read_to_end(dst) {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n+                       e.raw_os_error() == Some(libc::EAGAIN) {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        };\n+        if try!(read(&p1, v1)) {\n+            p2.set_nonblocking(false);\n+            return p2.read_to_end(v2).map(|_| ());\n+        }\n+        if try!(read(&p2, v2)) {\n+            p1.set_nonblocking(false);\n+            return p1.read_to_end(v1).map(|_| ());\n+        }\n+    }\n+}"}, {"sha": "47b0ff42f932274169413b5658df890fef60aea5", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -651,7 +651,7 @@ mod tests {\n             cmd.stdin(Stdio::MakePipe);\n             cmd.stdout(Stdio::MakePipe);\n \n-            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null));\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n "}, {"sha": "002ffc7c8685a7a7a48b619f0955d01688132409", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(bad_style)]\n #![cfg_attr(test, allow(dead_code))]\n+#![unstable(issue = \"0\", feature = \"windows_c\")]\n \n use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort,};\n use os::raw::{c_char, c_ulonglong};\n@@ -181,13 +182,15 @@ pub const ERROR_PATH_NOT_FOUND: DWORD = 3;\n pub const ERROR_ACCESS_DENIED: DWORD = 5;\n pub const ERROR_INVALID_HANDLE: DWORD = 6;\n pub const ERROR_NO_MORE_FILES: DWORD = 18;\n+pub const ERROR_HANDLE_EOF: DWORD = 38;\n pub const ERROR_BROKEN_PIPE: DWORD = 109;\n pub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\n pub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\n pub const ERROR_ALREADY_EXISTS: DWORD = 183;\n pub const ERROR_NO_DATA: DWORD = 232;\n pub const ERROR_ENVVAR_NOT_FOUND: DWORD = 203;\n pub const ERROR_OPERATION_ABORTED: DWORD = 995;\n+pub const ERROR_IO_PENDING: DWORD = 997;\n pub const ERROR_TIMEOUT: DWORD = 0x5B4;\n \n pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n@@ -292,6 +295,14 @@ pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n                                     EXCEPTION_TARGET_UNWIND |\n                                     EXCEPTION_COLLIDED_UNWIND;\n \n+pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n+pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n+pub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n+pub const PIPE_WAIT: DWORD = 0x00000000;\n+pub const PIPE_TYPE_BYTE: DWORD = 0x00000000;\n+pub const PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\n+pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -913,10 +924,6 @@ extern \"system\" {\n                            nOutBufferSize: DWORD,\n                            lpBytesReturned: LPDWORD,\n                            lpOverlapped: LPOVERLAPPED) -> BOOL;\n-    pub fn CreatePipe(hReadPipe: LPHANDLE,\n-                      hWritePipe: LPHANDLE,\n-                      lpPipeAttributes: LPSECURITY_ATTRIBUTES,\n-                      nSize: DWORD) -> BOOL;\n     pub fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n                         dwStackSize: SIZE_T,\n                         lpStartAddress: extern \"system\" fn(*mut c_void)\n@@ -1129,6 +1136,29 @@ extern \"system\" {\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n+\n+    pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCWSTR) -> HANDLE;\n+    pub fn WaitForMultipleObjects(nCount: DWORD,\n+                                  lpHandles: *const HANDLE,\n+                                  bWaitAll: BOOL,\n+                                  dwMilliseconds: DWORD) -> DWORD;\n+    pub fn CreateNamedPipeW(lpName: LPCWSTR,\n+                            dwOpenMode: DWORD,\n+                            dwPipeMode: DWORD,\n+                            nMaxInstances: DWORD,\n+                            nOutBufferSize: DWORD,\n+                            nInBufferSize: DWORD,\n+                            nDefaultTimeOut: DWORD,\n+                            lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                            -> HANDLE;\n+    pub fn CancelIo(handle: HANDLE) -> BOOL;\n+    pub fn GetOverlappedResult(hFile: HANDLE,\n+                               lpOverlapped: LPOVERLAPPED,\n+                               lpNumberOfBytesTransferred: LPDWORD,\n+                               bWait: BOOL) -> BOOL;\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "1396d670902bb6c32a9936d74bcdd6279f1bd549", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_handle\")]\n+\n use prelude::v1::*;\n \n use cmp;\n@@ -42,6 +44,20 @@ impl Handle {\n         Handle(RawHandle::new(handle))\n     }\n \n+    pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n+        unsafe {\n+            let event = c::CreateEventW(0 as *mut _,\n+                                        manual as c::BOOL,\n+                                        init as c::BOOL,\n+                                        0 as *const _);\n+            if event.is_null() {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(Handle::new(event))\n+            }\n+        }\n+    }\n+\n     pub fn into_raw(self) -> c::HANDLE {\n         let ret = self.raw();\n         mem::forget(self);\n@@ -90,6 +106,59 @@ impl RawHandle {\n         }\n     }\n \n+    pub unsafe fn read_overlapped(&self,\n+                                  buf: &mut [u8],\n+                                  overlapped: *mut c::OVERLAPPED)\n+                                  -> io::Result<Option<usize>> {\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let mut amt = 0;\n+        let res = cvt({\n+            c::ReadFile(self.0, buf.as_ptr() as c::LPVOID,\n+                        len, &mut amt, overlapped)\n+        });\n+        match res {\n+            Ok(_) => Ok(Some(amt as usize)),\n+            Err(e) => {\n+                if e.raw_os_error() == Some(c::ERROR_IO_PENDING as i32) {\n+                    Ok(None)\n+                } else if e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n+                    Ok(Some(0))\n+                } else {\n+                    Err(e)\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn overlapped_result(&self,\n+                             overlapped: *mut c::OVERLAPPED,\n+                             wait: bool) -> io::Result<usize> {\n+        unsafe {\n+            let mut bytes = 0;\n+            let wait = if wait {c::TRUE} else {c::FALSE};\n+            let res = cvt({\n+                c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait)\n+            });\n+            match res {\n+                Ok(_) => Ok(bytes as usize),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) ||\n+                       e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n+                        Ok(0)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn cancel_io(&self) -> io::Result<()> {\n+        unsafe {\n+            cvt(c::CancelIo(self.raw())).map(|_| ())\n+        }\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let mut me = self;\n         (&mut me).read_to_end(buf)\n@@ -120,7 +189,6 @@ impl RawHandle {\n     }\n }\n \n-#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n impl<'a> Read for &'a RawHandle {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)"}, {"sha": "bb3c79c5a84fd0a76a707495f8dbf1b2f73c1b21", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_net\")]\n+\n use prelude::v1::*;\n \n use cmp;"}, {"sha": "fbe38d76e9571e95ed52ab5138367b5e958bf293", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 259, "deletions": 10, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -9,11 +9,16 @@\n // except according to those terms.\n \n use prelude::v1::*;\n+use os::windows::prelude::*;\n \n+use ffi::OsStr;\n+use path::Path;\n use io;\n-use ptr;\n-use sys::cvt;\n+use mem;\n+use rand::{self, Rng};\n+use slice;\n use sys::c;\n+use sys::fs::{File, OpenOptions};\n use sys::handle::Handle;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -25,14 +30,76 @@ pub struct AnonPipe {\n }\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    let mut reader = c::INVALID_HANDLE_VALUE;\n-    let mut writer = c::INVALID_HANDLE_VALUE;\n-    try!(cvt(unsafe {\n-        c::CreatePipe(&mut reader, &mut writer, ptr::null_mut(), 0)\n-    }));\n-    let reader = Handle::new(reader);\n-    let writer = Handle::new(writer);\n-    Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer }))\n+    // Note that we specifically do *not* use `CreatePipe` here because\n+    // unfortunately the anonymous pipes returned do not support overlapped\n+    // operations.\n+    //\n+    // Instead, we create a \"hopefully unique\" name and create a named pipe\n+    // which has overlapped operations enabled.\n+    //\n+    // Once we do this, we connect do it as usual via `CreateFileW`, and then we\n+    // return those reader/writer halves.\n+    unsafe {\n+        let reader;\n+        let mut name;\n+        let mut tries = 0;\n+        loop {\n+            tries += 1;\n+            let key: u64 = rand::thread_rng().gen();\n+            name = format!(r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n+                           c::GetCurrentProcessId(),\n+                           key);\n+            let wide_name = OsStr::new(&name)\n+                                  .encode_wide()\n+                                  .chain(Some(0))\n+                                  .collect::<Vec<_>>();\n+\n+            let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n+                                             c::PIPE_ACCESS_INBOUND |\n+                                              c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n+                                              c::FILE_FLAG_OVERLAPPED,\n+                                             c::PIPE_TYPE_BYTE |\n+                                              c::PIPE_READMODE_BYTE |\n+                                              c::PIPE_WAIT |\n+                                              c::PIPE_REJECT_REMOTE_CLIENTS,\n+                                             1,\n+                                             4096,\n+                                             4096,\n+                                             0,\n+                                             0 as *mut _);\n+\n+            // We pass the FILE_FLAG_FIRST_PIPE_INSTANCE flag above, and we're\n+            // also just doing a best effort at selecting a unique name. If\n+            // ERROR_ACCESS_DENIED is returned then it could mean that we\n+            // accidentally conflicted with an already existing pipe, so we try\n+            // again.\n+            //\n+            // Don't try again too much though as this could also perhaps be a\n+            // legit error.\n+            if handle == c::INVALID_HANDLE_VALUE {\n+                let err = io::Error::last_os_error();\n+                if tries < 10 &&\n+                   err.raw_os_error() == Some(c::ERROR_ACCESS_DENIED as i32) {\n+                    continue\n+                }\n+                return Err(err)\n+            }\n+            reader = Handle::new(handle);\n+            break\n+        }\n+\n+        // Connect to the named pipe we just created in write-only mode (also\n+        // overlapped for async I/O below).\n+        let mut opts = OpenOptions::new();\n+        opts.write(true);\n+        opts.read(false);\n+        opts.share_mode(0);\n+        opts.attributes(c::FILE_FLAG_OVERLAPPED);\n+        let writer = try!(File::open(Path::new(&name), &opts));\n+        let writer = AnonPipe { inner: writer.into_handle() };\n+\n+        Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer.into_handle() }))\n+    }\n }\n \n impl AnonPipe {\n@@ -51,3 +118,185 @@ impl AnonPipe {\n         self.inner.write(buf)\n     }\n }\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+    let p1 = p1.into_handle();\n+    let p2 = p2.into_handle();\n+\n+    let mut p1 = try!(AsyncPipe::new(p1, v1));\n+    let mut p2 = try!(AsyncPipe::new(p2, v2));\n+    let objs = [p1.event.raw(), p2.event.raw()];\n+\n+    // In a loop we wait for either pipe's scheduled read operation to complete.\n+    // If the operation completes with 0 bytes, that means EOF was reached, in\n+    // which case we just finish out the other pipe entirely.\n+    //\n+    // Note that overlapped I/O is in general super unsafe because we have to\n+    // be careful to ensure that all pointers in play are valid for the entire\n+    // duration of the I/O operation (where tons of operations can also fail).\n+    // The destructor for `AsyncPipe` ends up taking care of most of this.\n+    loop {\n+        let res = unsafe {\n+            c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE)\n+        };\n+        if res == c::WAIT_OBJECT_0 {\n+            if !try!(p1.result()) || !try!(p1.schedule_read()) {\n+                return p2.finish()\n+            }\n+        } else if res == c::WAIT_OBJECT_0 + 1 {\n+            if !try!(p2.result()) || !try!(p2.schedule_read()) {\n+                return p1.finish()\n+            }\n+        } else {\n+            return Err(io::Error::last_os_error())\n+        }\n+    }\n+}\n+\n+struct AsyncPipe<'a> {\n+    pipe: Handle,\n+    event: Handle,\n+    overlapped: Box<c::OVERLAPPED>, // needs a stable address\n+    dst: &'a mut Vec<u8>,\n+    state: State,\n+}\n+\n+#[derive(PartialEq, Debug)]\n+enum State {\n+    NotReading,\n+    Reading,\n+    Read(usize),\n+}\n+\n+impl<'a> AsyncPipe<'a> {\n+    fn new(pipe: Handle, dst: &'a mut Vec<u8>) -> io::Result<AsyncPipe<'a>> {\n+        // Create an event which we'll use to coordinate our overlapped\n+        // opreations, this event will be used in WaitForMultipleObjects\n+        // and passed as part of the OVERLAPPED handle.\n+        //\n+        // Note that we do a somewhat clever thing here by flagging the\n+        // event as being manually reset and setting it initially to the\n+        // signaled state. This means that we'll naturally fall through the\n+        // WaitForMultipleObjects call above for pipes created initially,\n+        // and the only time an even will go back to \"unset\" will be once an\n+        // I/O operation is successfully scheduled (what we want).\n+        let event = try!(Handle::new_event(true, true));\n+        let mut overlapped: Box<c::OVERLAPPED> = unsafe {\n+            Box::new(mem::zeroed())\n+        };\n+        overlapped.hEvent = event.raw();\n+        Ok(AsyncPipe {\n+            pipe: pipe,\n+            overlapped: overlapped,\n+            event: event,\n+            dst: dst,\n+            state: State::NotReading,\n+        })\n+    }\n+\n+    /// Executes an overlapped read operation.\n+    ///\n+    /// Must not currently be reading, and returns whether the pipe is currently\n+    /// at EOF or not. If the pipe is not at EOF then `result()` must be called\n+    /// to complete the read later on (may block), but if the pipe is at EOF\n+    /// then `result()` should not be called as it will just block forever.\n+    fn schedule_read(&mut self) -> io::Result<bool> {\n+        assert_eq!(self.state, State::NotReading);\n+        let amt = unsafe {\n+            let slice = slice_to_end(self.dst);\n+            try!(self.pipe.read_overlapped(slice, &mut *self.overlapped))\n+        };\n+\n+        // If this read finished immediately then our overlapped event will\n+        // remain signaled (it was signaled coming in here) and we'll progress\n+        // down to the method below.\n+        //\n+        // Otherwise the I/O operation is scheduled and the system set our event\n+        // to not signaled, so we flag ourselves into the reading state and move\n+        // on.\n+        self.state = match amt {\n+            Some(0) => return Ok(false),\n+            Some(amt) => State::Read(amt),\n+            None => State::Reading,\n+        };\n+        Ok(true)\n+    }\n+\n+    /// Wait for the result of the overlapped operation previously executed.\n+    ///\n+    /// Takes a parameter `wait` which indicates if this pipe is currently being\n+    /// read whether the function should block waiting for the read to complete.\n+    ///\n+    /// Return values:\n+    ///\n+    /// * `true` - finished any pending read and the pipe is not at EOF (keep\n+    ///            going)\n+    /// * `false` - finished any pending read and pipe is at EOF (stop issuing\n+    ///             reads)\n+    fn result(&mut self) -> io::Result<bool> {\n+        let amt = match self.state {\n+            State::NotReading => return Ok(true),\n+            State::Reading => {\n+                try!(self.pipe.overlapped_result(&mut *self.overlapped, true))\n+            }\n+            State::Read(amt) => amt,\n+        };\n+        self.state = State::NotReading;\n+        unsafe {\n+            let len = self.dst.len();\n+            self.dst.set_len(len + amt);\n+        }\n+        Ok(amt != 0)\n+    }\n+\n+    /// Finishes out reading this pipe entirely.\n+    ///\n+    /// Waits for any pending and schedule read, and then calls `read_to_end`\n+    /// if necessary to read all the remaining information.\n+    fn finish(&mut self) -> io::Result<()> {\n+        while try!(self.result()) && try!(self.schedule_read()) {\n+            // ...\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> Drop for AsyncPipe<'a> {\n+    fn drop(&mut self) {\n+        match self.state {\n+            State::Reading => {}\n+            _ => return,\n+        }\n+\n+        // If we have a pending read operation, then we have to make sure that\n+        // it's *done* before we actually drop this type. The kernel requires\n+        // that the `OVERLAPPED` and buffer pointers are valid for the entire\n+        // I/O operation.\n+        //\n+        // To do that, we call `CancelIo` to cancel any pending operation, and\n+        // if that succeeds we wait for the overlapped result.\n+        //\n+        // If anything here fails, there's not really much we can do, so we leak\n+        // the buffer/OVERLAPPED pointers to ensure we're at least memory safe.\n+        if self.pipe.cancel_io().is_err() || self.result().is_err() {\n+            let buf = mem::replace(self.dst, Vec::new());\n+            let overlapped = Box::new(unsafe { mem::zeroed() });\n+            let overlapped = mem::replace(&mut self.overlapped, overlapped);\n+            mem::forget((buf, overlapped));\n+        }\n+    }\n+}\n+\n+unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n+    if v.capacity() == 0 {\n+        v.reserve(16);\n+    }\n+    if v.capacity() == v.len() {\n+        v.reserve(1);\n+    }\n+    slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n+                              v.capacity() - v.len())\n+}"}, {"sha": "5883904c21d729c92e14c786628424faed0ef4b8", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3038f82477491e20c6f80c0139ddb1f1b912ca/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=7c3038f82477491e20c6f80c0139ddb1f1b912ca", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(issue = \"0\", feature = \"windows_stdio\")]\n+\n use prelude::v1::*;\n use io::prelude::*;\n "}]}