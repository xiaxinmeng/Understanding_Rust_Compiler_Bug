{"sha": "8d9df5b442929fe33fb941ac302496845a08a7ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOWRmNWI0NDI5MjlmZTMzZmI5NDFhYzMwMjQ5Njg0NWEwOGE3YWI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T04:51:19Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T04:51:19Z"}, "message": "report: Finish the report.", "tree": {"sha": "38c1b1a25114cd798e3dffcc638f1b944c107c5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38c1b1a25114cd798e3dffcc638f1b944c107c5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d9df5b442929fe33fb941ac302496845a08a7ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9df5b442929fe33fb941ac302496845a08a7ab", "html_url": "https://github.com/rust-lang/rust/commit/8d9df5b442929fe33fb941ac302496845a08a7ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d9df5b442929fe33fb941ac302496845a08a7ab/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc", "html_url": "https://github.com/rust-lang/rust/commit/f3d0e1826478d6da609a78e2a4f05fa5b8b2eecc"}], "stats": {"total": 204, "additions": 181, "deletions": 23}, "files": [{"sha": "e1eb35a316dc9502b74abbc2a25d37d1c06e0589", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 181, "deletions": 23, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/8d9df5b442929fe33fb941ac302496845a08a7ab/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/8d9df5b442929fe33fb941ac302496845a08a7ab/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=8d9df5b442929fe33fb941ac302496845a08a7ab", "patch": "@@ -344,22 +344,49 @@ \\subsection{Aggregates}\n closure.}. Miri supports all common usage of all of these types. The main missing piece is to handle\n \\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n \n+\\subsection{Lvalue projections}\n+\n+This category includes field accesses like \\rust{foo.bar}, dereferencing, accessing data in an\n+\\rust{enum} variant, and indexing arrays. Miri supports all of these, including nested projections\n+such as \\rust{*foo.bar[2]}.\n+\n \\subsection{Control flow}\n \n All of Rust's standard control flow features, including \\rust{loop}, \\rust{while}, \\rust{for},\n \\rust{if}, \\rust{if let}, \\rust{while let}, \\rust{match}, \\rust{break}, \\rust{continue}, and\n \\rust{return} are supported. In fact, supporting these were quite easy since the Rust compiler\n reduces them all down to a comparatively smaller set of control-flow graph primitives in MIR.\n \n-\\subsection{Closures}\n+\\subsection{Function calls}\n+\n+As previously described, Miri supports arbitrary function calls without growing its own stack (only\n+its virtual call stack). It is somewhat limited by the fact that cross-crate\\footnote{A crate is a\n+single Rust library (or executable).} calls only work for functions whose MIR is stored in crate\n+metadata. This is currently true for \\rust{const}, generic, and \\texttt{\\#[inline]} functions. A\n+branch of the compiler could be made that stores MIR for all functions. This would be a non-issue\n+for a compile-time evaluator based on Miri, since it would only call \\rust{const fn}s.\n+\n+\\subsubsection{Method calls}\n+\n+Trait method calls require a bit more machinery dealing with compiler internals than normal function\n+calls, but Miri supports them.\n+\n+\\subsubsection{Closures}\n \n Closures are like structs containing a field for each captured variable, but closures also have an\n associated function. Supporting closure function calls required some extra machinery to get the\n necessary information from the compiler, but it is all supported except for one edge case on my todo\n list\\footnote{The edge case is calling a closure that takes a reference to its captures via a\n closure interface that passes the captures by value.}.\n \n-\\subsection{Intrinsics}\n+\\subsubsection{Function pointers}\n+\n+Function pointers are not currently supported by Miri, but there is a relatively simple way they\n+could be encoded using a relocation with a special reserved allocation identifier. The offset of the\n+relocation would determine which function it points to in a special array of functions in the\n+interpreter.\n+\n+\\subsubsection{Intrinsics}\n \n To support unsafe code, and in particular the unsafe code used to implement Rust's standard library,\n it became clear that Miri would have to support calls to compiler\n@@ -375,6 +402,25 @@ \\subsection{Intrinsics}\n been implementing intrinsics on a case-by-case basis as I write test cases which require missing\n ones, so I haven't yet exhaustively implemented them all.\n \n+\\subsubsection{Generic function calls}\n+\n+Miri needs special support for generic function calls since Rust is a \\emph{monomorphizing}\n+compiler, meaning it generates a special version of each function for each distinct set of type\n+parameters it gets called with. Since functions in MIR are still polymorphic, Miri has to do the\n+same thing and substitute function type parameters into all types it encounters to get fully\n+concrete, monomorphized types. For example, in\\ldots\n+\n+\\begin{minted}[autogobble]{rust}\n+  fn some<T>(t: T) -> Option<T> { Some(t) }\n+\\end{minted}\n+\n+\\ldots{} Miri needs to know how many bytes to copy from the argument to the return value, based on\n+the size of \\rust{T}. If we call \\rust{some(10i32)} Miri will execute \\rust{some} knowing that\n+\\rust{T = i32} and generate a representation for \\rust{Option<i32>}.\n+\n+Miri currently does this monomorphization on-demand, or lazily, unlike the Rust back-end which does\n+it all ahead of time.\n+\n \\subsection{Heap allocations}\n \n The next piece of the puzzle for supporting interesting programs (and the standard library) was heap\n@@ -400,16 +446,58 @@ \\subsection{Heap allocations}\n \n \\subsection{Destructors}\n \n+When values go out of scope that ``own'' some resource, like a heap allocation or file handle, Rust\n+inserts \\emph{drop glue} that calls the user-defined destructor for the type if it exists, and then\n+drops all of the subfields. Destructors for types like \\rust{Box<T>} and \\rust{Vec<T>} deallocate\n+heap memory.\n+\n Miri doesn't yet support calling user-defined destructors, but it has most of the machinery in place\n to do so already and it's next on my to-do list. There \\emph{is} support for dropping \\rust{Box<T>}\n types, including deallocating their associated allocations. This is enough to properly execute the\n dangling pointer example in \\autoref{sec:deterministic}.\n \n+\\subsection{Constants}\n+\n+Only basic integer, boolean, string, and byte-string literals are currently supported. Evaluating\n+more complicated constant expressions in their current form would be a somewhat pointless exercise\n+for Miri. Instead, we should lower constant expressions to MIR so Miri can run them directly. (This\n+is precisely what would be done to use Miri as the actual constant evaluator.)\n+\n+\\subsection{Static variables}\n+\n+While it would be invalid to write to static (i.e.\\ global) variables in Miri executions, it would\n+probably be fine to allow reads. However, Miri doesn't currently support them and they would need\n+support similar to constants.\n+\n \\subsection{Standard library}\n-\\blindtext\n \n-\\section{Unsupported}\n-\\blindtext\n+Throughout the implementation of the above features, I often followed this process:\n+\n+\\begin{enumerate}\n+  \\item Try using a feature from the standard library.\n+  \\item See where Miri runs into stuff it can't handle.\n+  \\item Fix the problem.\n+  \\item Go to 1.\n+\\end{enumerate}\n+\n+At present, Miri supports a number of major non-trivial features from the standard library along\n+with tons of minor features. Smart pointer types such as \\rust{Box}, \\rust{Rc}\\footnote{Reference\n+counted shared pointer} and \\rust{Arc}\\footnote{Atomically reference-counted thread-safe shared\n+pointer} all seem to work. I've also tested using the shared smart pointer types with \\rust{Cell}\n+and \\rust{RefCell}\\footnote{\\href{https://doc.rust-lang.org/stable/std/cell/index.html}{Rust\n+documentation for cell types}} for internal mutability, and that works as well, although\n+\\rust{RefCell} can't ever be borrowed twice until I implement destructor calls, since its destructor\n+is what releases the borrow.\n+\n+But the standard library collection I spent the most time on was \\rust{Vec}, the standard\n+dynamically-growable array type, similar to C++'s \\texttt{std::vector} or Java's\n+\\texttt{java.util.ArrayList}. In Rust, \\rust{Vec} is an extremely pervasive collection, so\n+supporting it is a big win for supporting a larger swath of Rust programs in Miri.\n+\n+See \\autoref{fig:vec} for an example (working in Miri today) of initializing a \\rust{Vec} with a\n+small amount of space on the heap and then pushing enough elements to force it to reallocate its\n+data array. This involves cross-crate generic function calls, unsafe code using raw pointers, heap\n+allocation, handling of uninitialized memory, compiler intrinsics, and more.\n \n \\begin{figure}[t]\n   \\begin{minted}[autogobble]{rust}\n@@ -441,15 +529,57 @@ \\section{Unsupported}\n     // B: 01 02 03 __\n   \\end{minted}\n   \\caption{\\rust{Vec} example on 32-bit little-endian}\n+  \\label{fig:vec}\n+\\end{figure}\n+\n+You can even do unsafe things with \\rust{Vec} like \\rust{v.set_len(10)} or\n+\\rust{v.get_unchecked(2)}, but if you do these things carefully in a way that doesn't cause any\n+undefined behaviour (just like when you write unsafe code for regular Rust), then Miri can handle it\n+all. But if you do slip up, Miri will error out with an appropriate message (see\n+\\autoref{fig:vec-error}).\n+\n+\\begin{figure}[t]\n+  \\begin{minted}[autogobble]{rust}\n+    fn out_of_bounds() -> u8 {\n+        let v = vec![1, 2];\n+        let p = unsafe { v.get_unchecked(5) };\n+        *p + 10\n+    //  ~~ error: pointer offset outside\n+    //       bounds of allocation\n+    }\n+\n+    fn undefined_bytes() -> u8 {\n+        let v = Vec::<u8>::with_capacity(10);\n+        let p = unsafe { v.get_unchecked(5) };\n+        *p + 10\n+    //  ~~~~~~~ error: attempted to read\n+    //            undefined bytes\n+    }\n+  \\end{minted}\n+  \\caption{\\rust{Vec} examples with undefined behaviour}\n+  \\label{fig:vec-error}\n \\end{figure}\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n-\\section{Future work}\n+\\section{Future directions}\n \n \\subsection{Finishing the implementation}\n \n-\\blindtext\n+There are a number of pressing items on my to-do list for Miri, including:\n+\n+\\begin{itemize}\n+  \\item Destructors and \\rust{__rust_deallocate}.\n+  \\item Non-trivial casts between primitive types like integers and pointers.\n+  \\item Handling statics and global memory.\n+  \\item Reporting errors for all undefined behaviour.\\footnote{\\href{https://doc.rust-lang.org/reference.html\\#behavior-considered-undefined}{The Rust reference on what is considered undefined behaviour}}\n+  \\item Function pointers.\n+  \\item Accounting for target machine primitive type alignment and endianness.\n+  \\item Optimizing stuff (undefined byte masks, tail-calls).\n+  \\item Benchmarking Miri vs. unoptimized Rust.\n+  \\item Various \\texttt{TODO}s and \\texttt{FIXME}s left in the code.\n+  \\item Getting a version of Miri into rustc for real.\n+\\end{itemize}\n \n \\subsection{Alternative applications}\n \n@@ -459,32 +589,60 @@ \\subsection{Alternative applications}\n   \\item A graphical or text-mode debugger that steps through MIR execution one statement at a time,\n     for figuring out why some compile-time execution is raising an error or simply learning how Rust\n     works at a low level.\n-  \\item A read-eval-print-loop (REPL) for Rust may be easier to implement on top of Miri than the\n-    usual LLVM back-end.\n-  \\item An extended version of Miri could be developed apart from the purpose of compile-time\n-    execution that is able to run foreign functions from C/C++ and generally have full access to the\n-    operating system. Such a version of Miri could be used to more quickly prototype changes to the\n-    Rust language that would otherwise require changes to the LLVM back-end.\n-  \\item Miri might be useful for unit-testing the compiler by comparing the results of Miri's\n-    execution against the results of LLVM-compiled machine code's execution. This would help to\n-    guarantee that compile-time execution works the same as runtime execution.\n+  \\item A read-eval-print-loop (REPL) for Rust, which may be easier to implement on top of Miri than\n+    the usual LLVM back-end.\n+  \\item An extended version of Miri developed apart from the purpose of compile-time execution that\n+    is able to run foreign functions from C/C++ and generally have full access to the operating\n+    system. Such a version of Miri could be used to more quickly prototype changes to the Rust\n+    language that would otherwise require changes to the LLVM back-end.\n+  \\item Unit-testing the compiler by comparing the results of Miri's execution against the results\n+    of LLVM-compiled machine code's execution. This would help to guarantee that compile-time\n+    execution works the same as runtime execution.\n+  \\item Some kind of symbolic evaluator that examines multiple possible code paths at once to\n+    determine if undefined behaviour could be observed on any of them.\n \\end{itemize}\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Final thoughts}\n \n-% TODO(tsion): Reword this.\n-Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n-of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n-unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n-simulating execution of unsafe code, which allows it to detect when unsafe code does something\n-invalid.\n+Writing an interpreter which models values of varying sizes, stack and heap allocation, unsafe\n+memory operations, and more requires some unconventional techniques compared to typical\n+interpreters. However, aside from the somewhat complicated abstract memory model, making Miri work\n+was primarily a software engineering problem, and not a particularly tricky one. This is a testament\n+to MIR's suitability as an intermediate representation for Rust---removing enough unnecessary\n+abstraction to keep it simple. For example, Miri doesn't even need to know that there are different\n+kind of loops, or how to match patterns in a \\rust{match} expression.\n+\n+Another advantage to targeting MIR is that any new features at the syntax-level or type-level\n+generally require little to no change in Miri. For example, when the new ``question mark'' syntax\n+for error handling\\footnote{\n+  \\href{https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md}\n+    {Question mark syntax RFC}}\n+was added to rustc, Miri also supported it the same day with no change. When specialization\\footnote{\n+  \\href{https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md}\n+    {Specialization RFC}}\n+was added, Miri supported it with just minor changes to trait method lookup.\n+\n+Of course, Miri also has limitations. The inability to execute FFI and inline assembly reduces the\n+amount of Rust programs Miri could ever execute. The good news is that in the constant evaluator,\n+FFI can be stubbed out in cases where it makes sense, like I did with \\rust{__rust_allocate}, and\n+for Miri outside of the compiler it may be possible to use libffi to call C functions from the\n+interpreter.\n+\n+In conclusion, Miri was a surprisingly effective project, and a lot of fun to implement. There were\n+times where I ended up supporting Rust features I didn't even intend to while I was adding support\n+for some other feature, due to the design of MIR collapsing features at the source level into fewer\n+features at the MIR level. I am excited to work with the compiler team going forward to try to make\n+Miri useful for constant evaluation in Rust.\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Thanks}\n \n-Eduard Burtescu, Niko Matsakis, and Christopher Dutchyn.\n+A big thanks goes to Eduard Burtescu for writing the abstract machine specification and answering my\n+incessant questions on IRC, to Niko Matsakis for coming up with the idea for Miri and supporting my\n+desire to work with the Rust compiler, and to my research supervisor Christopher Dutchyn. Thanks\n+also to everyone else on the compiler team and on Mozilla IRC who helped me figure stuff out.\n \n \\end{document}"}]}