{"sha": "8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYTQyZWQ3YzJhZGI5ZjM3ZmFhNmViOTA1Zjg5MGY2MTk5ZTFkYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T20:44:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T20:44:18Z"}, "message": "Auto merge of #61787 - ecstatic-morse:dataflow-split-block-sets, r=pnkfelix\n\nrustc_mir: Hide initial block state when defining transfer functions\n\nThis PR addresses [this FIXME](https://github.com/rust-lang/rust/blob/2887008e0ce0824be4e0e9562c22ea397b165c97/src/librustc_mir/dataflow/mod.rs#L594-L596).\n\nThis makes `sets.on_entry` inaccessible in `{before_,}{statement,terminator}_effect`. This field was meant to allow implementors of `BitDenotation` to access the initial state for each block (optionally with the effect of all previous statements applied via `accumulates_intrablock_state`) while defining transfer functions.  However, the ability to set the initial value for the entry set of each basic block (except for START_BLOCK) no longer exists. As a result, this functionality is mostly useless, and when it *was* used it was used erroneously (see #62007).\n\nSince `on_entry` is now useless, we can also remove `BlockSets`, which held the `gen`, `kill`, and `on_entry` bitvectors and replace it with a `GenKill` struct. Variables of this type are called `trans` since they represent a transfer function. `GenKill`s are stored contiguously in `AllSets`, which reduces the number of bounds checks and may improve cache performance: one is almost never accessed without the other.\n\nReplacing `BlockSets` with `GenKill` allows us to define some new helper functions which streamline dataflow iteration and the dataflow-at-location APIs. Notably, `state_for_location` used a subtle side-effect of the `kill`/`kill_all` setters to apply the transfer function, and could be incorrect if a transfer function depended on effects of previous statements in the block on `gen_set`.\n\nAdditionally, this PR merges `BitSetOperator` and `InitialFlow` into one trait. Since the value of `InitialFlow` defines the semantics of the `join` operation, there's no reason to have seperate traits for each. We can add a default impl of `join` which branches based on `BOTTOM_VALUE`.  This should get optimized away.", "tree": {"sha": "4adb27a7ad0464b384825c885844ef22b33332fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4adb27a7ad0464b384825c885844ef22b33332fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "html_url": "https://github.com/rust-lang/rust/commit/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e08576e4276a97b523c25bfd196d419c39c7b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e08576e4276a97b523c25bfd196d419c39c7b87", "html_url": "https://github.com/rust-lang/rust/commit/7e08576e4276a97b523c25bfd196d419c39c7b87"}, {"sha": "c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "html_url": "https://github.com/rust-lang/rust/commit/c8cbd4fc784e5d432c02b0dc14a592f112dab59f"}], "stats": {"total": 681, "additions": 275, "deletions": 406}, "files": [{"sha": "5d8388d89f5b3097a17b2ff9ab7a02aa28545cd8", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -316,11 +316,6 @@ impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n     }\n }\n \n-pub trait BitSetOperator {\n-    /// Combine one bitset into another.\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool;\n-}\n-\n #[inline]\n fn bitwise<Op>(out_vec: &mut [Word], in_vec: &[Word], op: Op) -> bool\n     where Op: Fn(Word, Word) -> Word"}, {"sha": "7735528d8f8e06aeb99577ee35239398650d17ab", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 23, "deletions": 54, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -4,7 +4,7 @@\n use rustc::mir::{BasicBlock, Location};\n use rustc_data_structures::bit_set::{BitIter, BitSet, HybridBitSet};\n \n-use crate::dataflow::{BitDenotation, BlockSets, DataflowResults};\n+use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n \n use std::iter;\n@@ -66,8 +66,7 @@ where\n {\n     base_results: DataflowResults<'tcx, BD>,\n     curr_state: BitSet<BD::Idx>,\n-    stmt_gen: HybridBitSet<BD::Idx>,\n-    stmt_kill: HybridBitSet<BD::Idx>,\n+    stmt_trans: GenKillSet<BD::Idx>,\n }\n \n impl<'tcx, BD> FlowAtLocation<'tcx, BD>\n@@ -89,19 +88,17 @@ where\n     where\n         F: FnMut(BD::Idx),\n     {\n-        self.stmt_gen.iter().for_each(f)\n+        self.stmt_trans.gen_set.iter().for_each(f)\n     }\n \n     pub fn new(results: DataflowResults<'tcx, BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n         let curr_state = BitSet::new_empty(bits_per_block);\n-        let stmt_gen = HybridBitSet::new_empty(bits_per_block);\n-        let stmt_kill = HybridBitSet::new_empty(bits_per_block);\n+        let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n         FlowAtLocation {\n             base_results: results,\n-            curr_state: curr_state,\n-            stmt_gen: stmt_gen,\n-            stmt_kill: stmt_kill,\n+            curr_state,\n+            stmt_trans,\n         }\n     }\n \n@@ -127,8 +124,7 @@ where\n         F: FnOnce(BitIter<'_, BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n-        curr_state.union(&self.stmt_gen);\n-        curr_state.subtract(&self.stmt_kill);\n+        self.stmt_trans.apply(&mut curr_state);\n         f(curr_state.iter());\n     }\n \n@@ -142,68 +138,41 @@ impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n     where BD: BitDenotation<'tcx>\n {\n     fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.sets().on_entry_set_for(bb.index()));\n+        self.curr_state.overwrite(self.base_results.sets().entry_set_for(bb.index()));\n     }\n \n     fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n         self.reset_to_entry_of(bb);\n-        self.curr_state.union(self.base_results.sets().gen_set_for(bb.index()));\n-        self.curr_state.subtract(self.base_results.sets().kill_set_for(bb.index()));\n+        let trans = self.base_results.sets().trans_for(bb.index());\n+        trans.apply(&mut self.curr_state)\n     }\n \n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.clear();\n-        self.stmt_kill.clear();\n-        {\n-            let mut sets = BlockSets {\n-                on_entry: &mut self.curr_state,\n-                gen_set: &mut self.stmt_gen,\n-                kill_set: &mut self.stmt_kill,\n-            };\n-            self.base_results\n-                .operator()\n-                .before_statement_effect(&mut sets, loc);\n-        }\n-        self.apply_local_effect(loc);\n+        self.stmt_trans.clear();\n+        self.base_results\n+            .operator()\n+            .before_statement_effect(&mut self.stmt_trans, loc);\n+        self.stmt_trans.apply(&mut self.curr_state);\n \n-        let mut sets = BlockSets {\n-            on_entry: &mut self.curr_state,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n         self.base_results\n             .operator()\n-            .statement_effect(&mut sets, loc);\n+            .statement_effect(&mut self.stmt_trans, loc);\n     }\n \n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.clear();\n-        self.stmt_kill.clear();\n-        {\n-            let mut sets = BlockSets {\n-                on_entry: &mut self.curr_state,\n-                gen_set: &mut self.stmt_gen,\n-                kill_set: &mut self.stmt_kill,\n-            };\n-            self.base_results\n-                .operator()\n-                .before_terminator_effect(&mut sets, loc);\n-        }\n-        self.apply_local_effect(loc);\n+        self.stmt_trans.clear();\n+        self.base_results\n+            .operator()\n+            .before_terminator_effect(&mut self.stmt_trans, loc);\n+        self.stmt_trans.apply(&mut self.curr_state);\n \n-        let mut sets = BlockSets {\n-            on_entry: &mut self.curr_state,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n         self.base_results\n             .operator()\n-            .terminator_effect(&mut sets, loc);\n+            .terminator_effect(&mut self.stmt_trans, loc);\n     }\n \n     fn apply_local_effect(&mut self, _loc: Location) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n+        self.stmt_trans.apply(&mut self.curr_state)\n     }\n }\n "}, {"sha": "b0d8581784606f69c71707fc70fa7342d50308ba", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -170,7 +170,7 @@ where MWF: MirWithFlowState<'tcx>,\n \n         write!(w, \"<tr>\")?;\n         // Entry\n-        dump_set_for!(on_entry_set_for, interpret_set);\n+        dump_set_for!(entry_set_for, interpret_set);\n \n         // MIR statements\n         write!(w, \"<td>\")?;\n@@ -208,7 +208,7 @@ where MWF: MirWithFlowState<'tcx>,\n         write!(w, \"<tr>\")?;\n \n         // Entry\n-        let set = flow.sets.on_entry_set_for(i);\n+        let set = flow.sets.entry_set_for(i);\n         write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string()))?;\n \n         // Terminator\n@@ -221,13 +221,10 @@ where MWF: MirWithFlowState<'tcx>,\n         }\n         write!(w, \"</td>\")?;\n \n-        // Gen\n-        let set = flow.sets.gen_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", set)))?;\n-\n-        // Kill\n-        let set = flow.sets.kill_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", set)))?;\n+        // Gen/Kill\n+        let trans = flow.sets.trans_for(i);\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.gen_set)))?;\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.kill_set)))?;\n \n         write!(w, \"</tr>\")?;\n "}, {"sha": "0f7f37f2db8b47b10de129eae036b792750fabd0", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -2,7 +2,7 @@ pub use super::*;\n \n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n-use crate::dataflow::BitDenotation;\n+use crate::dataflow::{BitDenotation, GenKillSet};\n \n /// This calculates if any part of a MIR local could have previously been borrowed.\n /// This means that once a local has been borrowed, its bit will be set\n@@ -33,39 +33,39 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n         self.body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n+    fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n         // Nothing is borrowed on function entry\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, Local>,\n+                        trans: &mut GenKillSet<Local>,\n                         loc: Location) {\n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n \n         BorrowedLocalsVisitor {\n-            sets,\n+            trans,\n         }.visit_statement(stmt, loc);\n \n         // StorageDead invalidates all borrows and raw pointers to a local\n         match stmt.kind {\n-            StatementKind::StorageDead(l) => sets.kill(l),\n+            StatementKind::StorageDead(l) => trans.kill(l),\n             _ => (),\n         }\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, Local>,\n+                         trans: &mut GenKillSet<Local>,\n                          loc: Location) {\n         let terminator = self.body[loc.block].terminator();\n         BorrowedLocalsVisitor {\n-            sets,\n+            trans,\n         }.visit_terminator(terminator, loc);\n         match &terminator.kind {\n             // Drop terminators borrows the location\n             TerminatorKind::Drop { location, .. } |\n             TerminatorKind::DropAndReplace { location, .. } => {\n                 if let Some(local) = find_local(location) {\n-                    sets.gen(local);\n+                    trans.gen(local);\n                 }\n             }\n             _ => (),\n@@ -83,22 +83,13 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = unborrowed\n-    }\n+impl<'a, 'tcx> BottomValue for HaveBeenBorrowedLocals<'a, 'tcx> {\n+    // bottom = unborrowed\n+    const BOTTOM_VALUE: bool = false;\n }\n \n-struct BorrowedLocalsVisitor<'b, 'c> {\n-    sets: &'b mut BlockSets<'c, Local>,\n+struct BorrowedLocalsVisitor<'gk> {\n+    trans: &'gk mut GenKillSet<Local>,\n }\n \n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n@@ -117,13 +108,13 @@ fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     })\n }\n \n-impl<'tcx, 'b, 'c> Visitor<'tcx> for BorrowedLocalsVisitor<'b, 'c> {\n+impl<'tcx> Visitor<'tcx> for BorrowedLocalsVisitor<'_> {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Ref(_, _, ref place) = *rvalue {\n             if let Some(local) = find_local(place) {\n-                self.sets.gen(local);\n+                self.trans.gen(local);\n             }\n         }\n "}, {"sha": "53d00d44e3f55e6000e47ba4cdd446f87da9b327", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -5,11 +5,11 @@ use rustc::mir::{self, Location, Place, PlaceBase, Body};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n \n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n-use crate::dataflow::{BitDenotation, BlockSets, InitialFlow};\n+use crate::dataflow::{BitDenotation, BottomValue, GenKillSet};\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::places_conflict;\n@@ -168,7 +168,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n     /// That means they went out of a nonlexical scope\n     fn kill_loans_out_of_scope_at_location(&self,\n-                                           sets: &mut BlockSets<'_, BorrowIndex>,\n+                                           trans: &mut GenKillSet<BorrowIndex>,\n                                            location: Location) {\n         // NOTE: The state associated with a given `location`\n         // reflects the dataflow on entry to the statement.\n@@ -182,14 +182,14 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         // region, then setting that gen-bit will override any\n         // potential kill introduced here.\n         if let Some(indices) = self.borrows_out_of_scope_at_location.get(&location) {\n-            sets.kill_all(indices);\n+            trans.kill_all(indices);\n         }\n     }\n \n     /// Kill any borrows that conflict with `place`.\n     fn kill_borrows_on_place(\n         &self,\n-        sets: &mut BlockSets<'_, BorrowIndex>,\n+        trans: &mut GenKillSet<BorrowIndex>,\n         place: &Place<'tcx>\n     ) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n             if let Place::Base(PlaceBase::Local(_)) = place {\n-                sets.kill_all(other_borrows_of_local);\n+                trans.kill_all(other_borrows_of_local);\n                 return;\n             }\n \n@@ -224,7 +224,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n                         places_conflict::PlaceConflictBias::NoOverlap)\n                 });\n \n-            sets.kill_all(definitely_conflicting_borrows);\n+            trans.kill_all(definitely_conflicting_borrows);\n         }\n     }\n }\n@@ -236,21 +236,24 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n         self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut BitSet<BorrowIndex>) {\n+    fn start_block_effect(&self, _entry_set: &mut BitSet<Self::Idx>) {\n         // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n+        // function execution, so this method has no effect.\n     }\n \n     fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<'_, BorrowIndex>,\n+                               trans: &mut GenKillSet<Self::Idx>,\n                                location: Location) {\n-        debug!(\"Borrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.kill_loans_out_of_scope_at_location(sets, location);\n+        debug!(\"Borrows::before_statement_effect trans: {:?} location: {:?}\",\n+               trans, location);\n+        self.kill_loans_out_of_scope_at_location(trans, location);\n     }\n \n-    fn statement_effect(&self, sets: &mut BlockSets<'_, BorrowIndex>, location: Location) {\n-        debug!(\"Borrows::statement_effect: sets={:?} location={:?}\", sets, location);\n+    fn statement_effect(&self,\n+                        trans: &mut GenKillSet<Self::Idx>,\n+                        location: Location) {\n+        debug!(\"Borrows::statement_effect: trans={:?} location={:?}\",\n+               trans, location);\n \n         let block = &self.body.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n@@ -264,7 +267,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                self.kill_borrows_on_place(sets, lhs);\n+                self.kill_borrows_on_place(trans, lhs);\n \n                 if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n@@ -278,20 +281,20 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n-                    sets.gen(*index);\n+                    trans.gen(*index);\n                 }\n             }\n \n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(sets, &Place::Base(PlaceBase::Local(local)));\n+                self.kill_borrows_on_place(trans, &Place::Base(PlaceBase::Local(local)));\n             }\n \n             mir::StatementKind::InlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n-                        self.kill_borrows_on_place(sets, output);\n+                        self.kill_borrows_on_place(trans, output);\n                     }\n                 }\n             }\n@@ -307,13 +310,16 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n     }\n \n     fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<'_, BorrowIndex>,\n+                                trans: &mut GenKillSet<Self::Idx>,\n                                 location: Location) {\n-        debug!(\"Borrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.kill_loans_out_of_scope_at_location(sets, location);\n+        debug!(\"Borrows::before_terminator_effect: trans={:?} location={:?}\",\n+               trans, location);\n+        self.kill_loans_out_of_scope_at_location(trans, location);\n     }\n \n-    fn terminator_effect(&self, _: &mut BlockSets<'_, BorrowIndex>, _: Location) {}\n+    fn terminator_effect(&self,\n+                         _: &mut GenKillSet<Self::Idx>,\n+                         _: Location) {}\n \n     fn propagate_call_return(\n         &self,\n@@ -325,16 +331,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for Borrows<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for Borrows<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = nothing is reserved or activated yet\n-    }\n+impl<'a, 'tcx> BottomValue for Borrows<'a, 'tcx> {\n+    /// bottom = nothing is reserved or activated yet;\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "065cfe8a4e82340d1ef42a41af418fff35a90db0", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 43, "deletions": 86, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -4,15 +4,15 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Body, Location};\n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex, InitKind};\n-use super::{BitDenotation, BlockSets, InitialFlow};\n+use super::{BitDenotation, BottomValue, GenKillSet};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -226,34 +226,37 @@ impl<'a, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n+    fn update_bits(trans: &mut GenKillSet<MovePathIndex>,\n+                   path: MovePathIndex,\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.kill(path),\n-            DropFlagState::Present => sets.gen(path),\n+            DropFlagState::Absent => trans.kill(path),\n+            DropFlagState::Present => trans.gen(path),\n         }\n     }\n }\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n+    fn update_bits(trans: &mut GenKillSet<MovePathIndex>,\n+                   path: MovePathIndex,\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.gen(path),\n-            DropFlagState::Present => sets.kill(path),\n+            DropFlagState::Absent => trans.gen(path),\n+            DropFlagState::Present => trans.kill(path),\n         }\n     }\n }\n \n impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<'_, MovePathIndex>, path: MovePathIndex,\n+    fn update_bits(trans: &mut GenKillSet<MovePathIndex>,\n+                   path: MovePathIndex,\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.kill(path),\n-            DropFlagState::Present => sets.gen(path),\n+            DropFlagState::Absent => trans.kill(path),\n+            DropFlagState::Present => trans.gen(path),\n         }\n     }\n }\n@@ -275,24 +278,24 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, MovePathIndex>,\n+                        trans: &mut GenKillSet<Self::Idx>,\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, MovePathIndex>,\n+                         trans: &mut GenKillSet<Self::Idx>,\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n@@ -333,24 +336,24 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, MovePathIndex>,\n+                        trans: &mut GenKillSet<Self::Idx>,\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, MovePathIndex>,\n+                         trans: &mut GenKillSet<Self::Idx>,\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n@@ -389,24 +392,24 @@ impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, MovePathIndex>,\n+                        trans: &mut GenKillSet<Self::Idx>,\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, MovePathIndex>,\n+                         trans: &mut GenKillSet<Self::Idx>,\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.body, self.mdpe,\n             location,\n-            |path, s| Self::update_bits(sets, path, s)\n+            |path, s| Self::update_bits(trans, path, s)\n         )\n     }\n \n@@ -439,7 +442,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, InitIndex>,\n+                        trans: &mut GenKillSet<Self::Idx>,\n                         location: Location) {\n         let (_, body, move_data) = (self.tcx, self.body, self.move_data());\n         let stmt = &body[location.block].statements[location.statement_index];\n@@ -449,7 +452,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n \n         debug!(\"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n                stmt, location, &init_loc_map[location]);\n-        sets.gen_all(&init_loc_map[location]);\n+        trans.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n             mir::StatementKind::StorageDead(local) => {\n@@ -458,22 +461,22 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n                 let move_path_index = rev_lookup.find_local(local);\n                 debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n                         stmt, location, &init_path_map[move_path_index]);\n-                sets.kill_all(&init_path_map[move_path_index]);\n+                trans.kill_all(&init_path_map[move_path_index]);\n             }\n             _ => {}\n         }\n     }\n \n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, InitIndex>,\n+                         trans: &mut GenKillSet<Self::Idx>,\n                          location: Location)\n     {\n         let (body, move_data) = (self.body, self.move_data());\n         let term = body[location.block].terminator();\n         let init_loc_map = &move_data.init_loc_map;\n         debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n                term, location, &init_loc_map[location]);\n-        sets.gen_all(\n+        trans.gen_all(\n             init_loc_map[location].iter().filter(|init_index| {\n                 move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n             })\n@@ -502,68 +505,22 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for MaybeInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for MaybeUninitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.intersect(in_set) // \"definitely\" means we intersect effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // inits from both preds are in scope\n-    }\n-}\n-\n-// The way that dataflow fixed point iteration works, you want to\n-// start at bottom and work your way to a fixed point. Control-flow\n-// merges will apply the `join` operator to each block entry's current\n-// state (which starts at that bottom value).\n-//\n-// This means, for propagation across the graph, that you either want\n-// to start at all-zeroes and then use Union as your merge when\n-// propagating, or you start at all-ones and then use Intersect as\n-// your merge when propagating.\n-\n-impl<'a, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = uninitialized\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeInitializedPlaces<'a, 'tcx> {\n+    /// bottom = uninitialized\n+    const BOTTOM_VALUE: bool = false;\n }\n \n-impl<'a, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = initialized (start_block_effect counters this at outset)\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeUninitializedPlaces<'a, 'tcx> {\n+    /// bottom = initialized (start_block_effect counters this at outset)\n+    const BOTTOM_VALUE: bool = false;\n }\n \n-impl<'a, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        true // bottom = initialized (start_block_effect counters this at outset)\n-    }\n+impl<'a, 'tcx> BottomValue for DefinitelyInitializedPlaces<'a, 'tcx> {\n+    /// bottom = initialized (start_block_effect counters this at outset)\n+    const BOTTOM_VALUE: bool = true;\n }\n \n-impl<'a, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no initialized variables by default\n-    }\n+impl<'a, 'tcx> BottomValue for EverInitializedPlaces<'a, 'tcx> {\n+    /// bottom = no initialized variables by default\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "d2003993d45063f1f014b347412ec623dcddb984", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -26,24 +26,24 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n         self.body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n+    fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n         // Nothing is live on function entry\n     }\n \n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, Local>,\n+                        trans: &mut GenKillSet<Local>,\n                         loc: Location) {\n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n \n         match stmt.kind {\n-            StatementKind::StorageLive(l) => sets.gen(l),\n-            StatementKind::StorageDead(l) => sets.kill(l),\n+            StatementKind::StorageLive(l) => trans.gen(l),\n+            StatementKind::StorageDead(l) => trans.kill(l),\n             _ => (),\n         }\n     }\n \n     fn terminator_effect(&self,\n-                         _sets: &mut BlockSets<'_, Local>,\n+                         _trans: &mut GenKillSet<Local>,\n                          _loc: Location) {\n         // Terminators have no effect\n     }\n@@ -59,16 +59,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for MaybeStorageLive<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for MaybeStorageLive<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = dead\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "80f65a9c8d04e513ccf41a42d8c9d641caa29547", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 135, "deletions": 157, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -1,7 +1,7 @@\n use syntax::ast::{self, MetaItem};\n use syntax::symbol::{Symbol, sym};\n \n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n+use rustc_data_structures::bit_set::{BitSet, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n@@ -131,7 +131,7 @@ pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(\n     p: P,\n ) -> DataflowResults<'tcx, BD>\n where\n-    BD: BitDenotation<'tcx> + InitialFlow,\n+    BD: BitDenotation<'tcx>,\n     P: Fn(&BD, BD::Idx) -> DebugFormatted,\n {\n     let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n@@ -199,42 +199,27 @@ where\n     }\n \n     fn build_sets(&mut self) {\n-        // First we need to build the entry-, gen- and kill-sets.\n-\n-        {\n-            let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n-            self.flow_state.operator.start_block_effect(&mut sets.on_entry);\n-        }\n-\n+        // Build the transfer function for each block.\n         for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n \n-            let mut interim_state;\n-            let sets = &mut self.flow_state.sets.for_block(bb.index());\n-            let track_intrablock = BD::accumulates_intrablock_state();\n-            if track_intrablock {\n-                debug!(\"swapping in mutable on_entry, initially {:?}\", sets.on_entry);\n-                interim_state = sets.on_entry.to_owned();\n-                sets.on_entry = &mut interim_state;\n-            }\n+            let trans = self.flow_state.sets.trans_mut_for(bb.index());\n             for j_stmt in 0..statements.len() {\n                 let location = Location { block: bb, statement_index: j_stmt };\n-                self.flow_state.operator.before_statement_effect(sets, location);\n-                self.flow_state.operator.statement_effect(sets, location);\n-                if track_intrablock {\n-                    sets.apply_local_effect();\n-                }\n+                self.flow_state.operator.before_statement_effect(trans, location);\n+                self.flow_state.operator.statement_effect(trans, location);\n             }\n \n             if terminator.is_some() {\n                 let location = Location { block: bb, statement_index: statements.len() };\n-                self.flow_state.operator.before_terminator_effect(sets, location);\n-                self.flow_state.operator.terminator_effect(sets, location);\n-                if track_intrablock {\n-                    sets.apply_local_effect();\n-                }\n+                self.flow_state.operator.before_terminator_effect(trans, location);\n+                self.flow_state.operator.terminator_effect(trans, location);\n             }\n         }\n+\n+        // Initialize the flow state at entry to the start block.\n+        let on_entry = self.flow_state.sets.entry_set_mut_for(mir::START_BLOCK.index());\n+        self.flow_state.operator.start_block_effect(on_entry);\n     }\n }\n \n@@ -247,14 +232,12 @@ where\n             WorkQueue::with_all(self.builder.body.basic_blocks().len());\n         let body = self.builder.body;\n         while let Some(bb) = dirty_queue.pop() {\n+            let (on_entry, trans) = self.builder.flow_state.sets.get_mut(bb.index());\n+            debug_assert!(in_out.words().len() == on_entry.words().len());\n+            in_out.overwrite(on_entry);\n+            trans.apply(in_out);\n+\n             let bb_data = &body[bb];\n-            {\n-                let sets = self.builder.flow_state.sets.for_block(bb.index());\n-                debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n-                in_out.overwrite(sets.on_entry);\n-                in_out.union(sets.gen_set);\n-                in_out.subtract(sets.kill_set);\n-            }\n             self.builder.propagate_bits_into_graph_successors_of(\n                 in_out, (bb, bb_data), &mut dirty_queue);\n         }\n@@ -366,33 +349,27 @@ pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         result: &DataflowResults<'tcx, T>,\n                                                         body: &Body<'tcx>)\n     -> BitSet<T::Idx> {\n-    let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n-    let mut kill_set = on_entry.to_hybrid();\n-    let mut gen_set = kill_set.clone();\n+    let mut trans = GenKill::from_elem(HybridBitSet::new_empty(analysis.bits_per_block()));\n \n-    {\n-        let mut sets = BlockSets {\n-            on_entry: &mut on_entry,\n-            kill_set: &mut kill_set,\n-            gen_set: &mut gen_set,\n-        };\n-\n-        for stmt in 0..loc.statement_index {\n-            let mut stmt_loc = loc;\n-            stmt_loc.statement_index = stmt;\n-            analysis.before_statement_effect(&mut sets, stmt_loc);\n-            analysis.statement_effect(&mut sets, stmt_loc);\n-        }\n+    for stmt in 0..loc.statement_index {\n+        let mut stmt_loc = loc;\n+        stmt_loc.statement_index = stmt;\n+        analysis.before_statement_effect(&mut trans, stmt_loc);\n+        analysis.statement_effect(&mut trans, stmt_loc);\n+    }\n \n-        // Apply the pre-statement effect of the statement we're evaluating.\n-        if loc.statement_index == body[loc.block].statements.len() {\n-            analysis.before_terminator_effect(&mut sets, loc);\n-        } else {\n-            analysis.before_statement_effect(&mut sets, loc);\n-        }\n+    // Apply the pre-statement effect of the statement we're evaluating.\n+    if loc.statement_index == body[loc.block].statements.len() {\n+        analysis.before_terminator_effect(&mut trans, loc);\n+    } else {\n+        analysis.before_statement_effect(&mut trans, loc);\n     }\n \n-    gen_set.to_dense()\n+    // Apply the transfer function for all preceding statements to the fixpoint\n+    // at the start of the block.\n+    let mut state = result.sets().entry_set_for(loc.block.index()).to_owned();\n+    trans.apply(&mut state);\n+    state\n }\n \n pub struct DataflowAnalysis<'a, 'tcx, O>\n@@ -462,58 +439,41 @@ impl<'tcx, O: BitDenotation<'tcx>> DataflowState<'tcx, O> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct AllSets<E: Idx> {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Vec<BitSet<E>>,\n-\n-    /// For each block, bits generated by executing the statements +\n-    /// terminator in the block -- with one caveat. In particular, for\n-    /// *call terminators*, the effect of storing the destination is\n-    /// not included, since that only takes effect on the **success**\n-    /// edge (and not the unwind edge).\n-    gen_sets: Vec<HybridBitSet<E>>,\n-\n-    /// For each block, bits killed by executing the statements +\n-    /// terminator in the block -- with one caveat. In particular, for\n-    /// *call terminators*, the effect of storing the destination is\n-    /// not included, since that only takes effect on the **success**\n-    /// edge (and not the unwind edge).\n-    kill_sets: Vec<HybridBitSet<E>>,\n-}\n-\n-/// Triple of sets associated with a given block.\n-///\n-/// Generally, one sets up `on_entry`, `gen_set`, and `kill_set` for\n-/// each block individually, and then runs the dataflow analysis which\n-/// iteratively modifies the various `on_entry` sets (but leaves the\n-/// other two sets unchanged, since they represent the effect of the\n-/// block, which should be invariant over the course of the analysis).\n+/// A 2-tuple representing the \"gen\" and \"kill\" bitsets during\n+/// dataflow analysis.\n ///\n /// It is best to ensure that the intersection of `gen_set` and\n /// `kill_set` is empty; otherwise the results of the dataflow will\n /// have a hidden dependency on what order the bits are generated and\n /// killed during the iteration. (This is such a good idea that the\n /// `fn gen` and `fn kill` methods that set their state enforce this\n /// for you.)\n-#[derive(Debug)]\n-pub struct BlockSets<'a, E: Idx> {\n-    /// Dataflow state immediately before control flow enters the given block.\n-    pub(crate) on_entry: &'a mut BitSet<E>,\n+#[derive(Debug, Clone, Copy)]\n+pub struct GenKill<T> {\n+    pub(crate) gen_set: T,\n+    pub(crate) kill_set: T,\n+}\n \n-    /// Bits that are set to 1 by the time we exit the given block. Hybrid\n-    /// because it usually contains only 0 or 1 elements.\n-    pub(crate) gen_set: &'a mut HybridBitSet<E>,\n+type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n \n-    /// Bits that are set to 0 by the time we exit the given block. Hybrid\n-    /// because it usually contains only 0 or 1 elements.\n-    pub(crate) kill_set: &'a mut HybridBitSet<E>,\n+impl<T> GenKill<T> {\n+    /// Creates a new tuple where `gen_set == kill_set == elem`.\n+    pub(crate) fn from_elem(elem: T) -> Self\n+        where T: Clone\n+    {\n+        GenKill {\n+            gen_set: elem.clone(),\n+            kill_set: elem,\n+        }\n+    }\n }\n \n-impl<'a, E:Idx> BlockSets<'a, E> {\n+impl<E:Idx> GenKillSet<E> {\n+    pub(crate) fn clear(&mut self) {\n+        self.gen_set.clear();\n+        self.kill_set.clear();\n+    }\n+\n     fn gen(&mut self, e: E) {\n         self.gen_set.insert(e);\n         self.kill_set.remove(e);\n@@ -541,73 +501,93 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         }\n     }\n \n-    fn apply_local_effect(&mut self) {\n-        self.on_entry.union(self.gen_set);\n-        self.on_entry.subtract(self.kill_set);\n+    /// Computes `(set \u222a gen) - kill` and assigns the result to `set`.\n+    pub(crate) fn apply(&self, set: &mut BitSet<E>) {\n+        set.union(&self.gen_set);\n+        set.subtract(&self.kill_set);\n     }\n }\n \n+#[derive(Debug)]\n+pub struct AllSets<E: Idx> {\n+    /// Analysis bitwidth for each block.\n+    bits_per_block: usize,\n+\n+    /// For each block, bits valid on entry to the block.\n+    on_entry: Vec<BitSet<E>>,\n+\n+    /// The transfer function of each block expressed as the set of bits\n+    /// generated and killed by executing the statements + terminator in the\n+    /// block -- with one caveat. In particular, for *call terminators*, the\n+    /// effect of storing the destination is not included, since that only takes\n+    /// effect on the **success** edge (and not the unwind edge).\n+    trans: Vec<GenKillSet<E>>,\n+}\n+\n impl<E:Idx> AllSets<E> {\n     pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n-    pub fn for_block(&mut self, block_idx: usize) -> BlockSets<'_, E> {\n-        BlockSets {\n-            on_entry: &mut self.on_entry_sets[block_idx],\n-            gen_set: &mut self.gen_sets[block_idx],\n-            kill_set: &mut self.kill_sets[block_idx],\n-        }\n+\n+    pub fn get_mut(&mut self, block_idx: usize) -> (&mut BitSet<E>, &mut GenKillSet<E>) {\n+        (&mut self.on_entry[block_idx], &mut self.trans[block_idx])\n     }\n \n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n-        &self.on_entry_sets[block_idx]\n+    pub fn trans_for(&self, block_idx: usize) -> &GenKillSet<E> {\n+        &self.trans[block_idx]\n+    }\n+    pub fn trans_mut_for(&mut self, block_idx: usize) -> &mut GenKillSet<E> {\n+        &mut self.trans[block_idx]\n+    }\n+    pub fn entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n+        &self.on_entry[block_idx]\n+    }\n+    pub fn entry_set_mut_for(&mut self, block_idx: usize) -> &mut BitSet<E> {\n+        &mut self.on_entry[block_idx]\n     }\n     pub fn gen_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.gen_sets[block_idx]\n+        &self.trans_for(block_idx).gen_set\n     }\n     pub fn kill_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.kill_sets[block_idx]\n+        &self.trans_for(block_idx).kill_set\n     }\n }\n \n /// Parameterization for the precise form of data flow that is used.\n-/// `InitialFlow` handles initializing the bitvectors before any\n-/// code is inspected by the analysis. Analyses that need more nuanced\n-/// initialization (e.g., they need to consult the results of some other\n-/// dataflow analysis to set up the initial bitvectors) should not\n-/// implement this.\n-pub trait InitialFlow {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn bottom_value() -> bool;\n+///\n+/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n+/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n+/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n+/// point.\n+///\n+/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n+/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n+/// as your merge when propagating.\n+pub trait BottomValue {\n+    /// Specifies the initial value for each bit in the entry set for each basic block.\n+    const BOTTOM_VALUE: bool;\n+\n+    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n+    #[inline]\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        if Self::BOTTOM_VALUE == false {\n+            inout_set.union(in_set)\n+        } else {\n+            inout_set.intersect(in_set)\n+        }\n+    }\n }\n \n-pub trait BitDenotation<'tcx>: BitSetOperator {\n+/// A specific flavor of dataflow analysis.\n+///\n+/// To run a dataflow analysis, one sets up an initial state for the\n+/// `START_BLOCK` via `start_block_effect` and a transfer function (`trans`)\n+/// for each block individually. The entry set for all other basic blocks is\n+/// initialized to `Self::BOTTOM_VALUE`. The dataflow analysis then\n+/// iteratively modifies the various entry sets (but leaves the the transfer\n+/// function unchanged).\n+pub trait BitDenotation<'tcx>: BottomValue {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n-    /// Some analyses want to accumulate knowledge within a block when\n-    /// analyzing its statements for building the gen/kill sets. Override\n-    /// this method to return true in such cases.\n-    ///\n-    /// When this returns true, the statement-effect (re)construction\n-    /// will clone the `on_entry` state and pass along a reference via\n-    /// `sets.on_entry` to that local clone into `statement_effect` and\n-    /// `terminator_effect`).\n-    ///\n-    /// When it's false, no local clone is constructed; instead a\n-    /// reference directly into `on_entry` is passed along via\n-    /// `sets.on_entry` instead, which represents the flow state at\n-    /// the block's start, not necessarily the state immediately prior\n-    /// to the statement/terminator under analysis.\n-    ///\n-    /// In either case, the passed reference is mutable, but this is a\n-    /// wart from using the `BlockSets` type in the API; the intention\n-    /// is that the `statement_effect` and `terminator_effect` methods\n-    /// mutate only the gen/kill sets.\n-    //\n-    // FIXME: we should consider enforcing the intention described in\n-    // the previous paragraph by passing the three sets in separate\n-    // parameters to encode their distinct mutabilities.\n-    fn accumulates_intrablock_state() -> bool { false }\n-\n     /// A name describing the dataflow analysis that this\n     /// `BitDenotation` is supporting. The name should be something\n     /// suitable for plugging in as part of a filename (i.e., avoid\n@@ -640,7 +620,7 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// applied, in that order, before moving for the next\n     /// statement.\n     fn before_statement_effect(&self,\n-                               _sets: &mut BlockSets<'_, Self::Idx>,\n+                               _trans: &mut GenKillSet<Self::Idx>,\n                                _location: Location) {}\n \n     /// Mutates the block-sets (the flow sets for the given\n@@ -654,7 +634,7 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// `bb_data` is the sequence of statements identified by `bb` in\n     /// the MIR.\n     fn statement_effect(&self,\n-                        sets: &mut BlockSets<'_, Self::Idx>,\n+                        trans: &mut GenKillSet<Self::Idx>,\n                         location: Location);\n \n     /// Similar to `terminator_effect`, except it applies\n@@ -669,7 +649,7 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// applied, in that order, before moving for the next\n     /// terminator.\n     fn before_terminator_effect(&self,\n-                                _sets: &mut BlockSets<'_, Self::Idx>,\n+                                _trans: &mut GenKillSet<Self::Idx>,\n                                 _location: Location) {}\n \n     /// Mutates the block-sets (the flow sets for the given\n@@ -683,7 +663,7 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// The effects applied here cannot depend on which branch the\n     /// terminator took.\n     fn terminator_effect(&self,\n-                         sets: &mut BlockSets<'_, Self::Idx>,\n+                         trans: &mut GenKillSet<Self::Idx>,\n                          location: Location);\n \n     /// Mutates the block-sets according to the (flow-dependent)\n@@ -718,27 +698,25 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n {\n     pub fn new(body: &'a Body<'tcx>,\n                dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-               denotation: D) -> Self where D: InitialFlow {\n+               denotation: D) -> Self {\n         let bits_per_block = denotation.bits_per_block();\n         let num_blocks = body.basic_blocks().len();\n \n-        let on_entry_sets = if D::bottom_value() {\n+        let on_entry = if D::BOTTOM_VALUE == true {\n             vec![BitSet::new_filled(bits_per_block); num_blocks]\n         } else {\n             vec![BitSet::new_empty(bits_per_block); num_blocks]\n         };\n-        let gen_sets = vec![HybridBitSet::new_empty(bits_per_block); num_blocks];\n-        let kill_sets = gen_sets.clone();\n+        let nop = GenKill::from_elem(HybridBitSet::new_empty(bits_per_block));\n \n         DataflowAnalysis {\n             body,\n             dead_unwinds,\n             flow_state: DataflowState {\n                 sets: AllSets {\n                     bits_per_block,\n-                    on_entry_sets,\n-                    gen_sets,\n-                    kill_sets,\n+                    on_entry,\n+                    trans: vec![nop; num_blocks],\n                 },\n                 operator: denotation,\n             }\n@@ -836,7 +814,7 @@ where\n                                          in_out: &BitSet<D::Idx>,\n                                          bb: mir::BasicBlock,\n                                          dirty_queue: &mut WorkQueue<mir::BasicBlock>) {\n-        let entry_set = &mut self.flow_state.sets.for_block(bb.index()).on_entry;\n+        let entry_set = self.flow_state.sets.entry_set_mut_for(bb.index());\n         let set_changed = self.flow_state.operator.join(entry_set, &in_out);\n         if set_changed {\n             dirty_queue.insert(bb);"}, {"sha": "b2b489b2e38841981533baa279e824542579748d", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -95,7 +95,7 @@ fn find_dead_unwinds<'tcx>(\n         };\n \n         let mut init_data = InitializationData {\n-            live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n+            live: flow_inits.sets().entry_set_for(bb.index()).to_owned(),\n             dead: BitSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n@@ -304,9 +304,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn initialization_data_at(&self, loc: Location) -> InitializationData {\n         let mut data = InitializationData {\n-            live: self.flow_inits.sets().on_entry_set_for(loc.block.index())\n+            live: self.flow_inits.sets().entry_set_for(loc.block.index())\n                 .to_owned(),\n-            dead: self.flow_uninits.sets().on_entry_set_for(loc.block.index())\n+            dead: self.flow_uninits.sets().entry_set_for(loc.block.index())\n                 .to_owned(),\n         };\n         for stmt in 0..loc.statement_index {"}, {"sha": "f12309c1d0a13f32a3d5760ddc7edb4e23059bda", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa42ed7c2adb9f37faa6eb905f890f6199e1db9/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=8aa42ed7c2adb9f37faa6eb905f890f6199e1db9", "patch": "@@ -18,7 +18,6 @@ use crate::dataflow::{\n };\n use crate::dataflow::move_paths::{MovePathIndex, LookupResult};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n-use crate::dataflow;\n \n use crate::dataflow::has_rustc_mir_with;\n \n@@ -133,20 +132,15 @@ fn each_block<'tcx, O>(\n         }\n     };\n \n-    let mut on_entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n-    let mut gen_set = results.0.sets.gen_set_for(bb.index()).clone();\n-    let mut kill_set = results.0.sets.kill_set_for(bb.index()).clone();\n+    let mut on_entry = results.0.sets.entry_set_for(bb.index()).to_owned();\n+    let mut trans = results.0.sets.trans_for(bb.index()).clone();\n \n     // Emulate effect of all statements in the block up to (but not\n     // including) the borrow within `peek_arg_place`. Do *not* include\n     // call to `peek_arg_place` itself (since we are peeking the state\n     // of the argument at time immediate preceding Call to\n     // `rustc_peek`).\n \n-    let mut sets = dataflow::BlockSets { on_entry: &mut on_entry,\n-                                         gen_set: &mut gen_set,\n-                                         kill_set: &mut kill_set };\n-\n     for (j, stmt) in statements.iter().enumerate() {\n         debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n         let (place, rvalue) = match stmt.kind {\n@@ -170,7 +164,7 @@ fn each_block<'tcx, O>(\n                 // Okay, our search is over.\n                 match move_data.rev_lookup.find(peeking_at_place) {\n                     LookupResult::Exact(peek_mpi) => {\n-                        let bit_state = sets.on_entry.contains(peek_mpi);\n+                        let bit_state = on_entry.contains(peek_mpi);\n                         debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n                                place, peeking_at_place, bit_state);\n                         if !bit_state {\n@@ -197,18 +191,18 @@ fn each_block<'tcx, O>(\n         debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n                place, lhs_mpi, stmt);\n         // reset GEN and KILL sets before emulating their effect.\n-        sets.gen_set.clear();\n-        sets.kill_set.clear();\n+        trans.clear();\n         results.0.operator.before_statement_effect(\n-            &mut sets, Location { block: bb, statement_index: j });\n+            &mut trans,\n+            Location { block: bb, statement_index: j });\n         results.0.operator.statement_effect(\n-            &mut sets, Location { block: bb, statement_index: j });\n-        sets.on_entry.union(sets.gen_set);\n-        sets.on_entry.subtract(sets.kill_set);\n+            &mut trans,\n+            Location { block: bb, statement_index: j });\n+        trans.apply(&mut on_entry);\n     }\n \n     results.0.operator.before_terminator_effect(\n-        &mut sets,\n+        &mut trans,\n         Location { block: bb, statement_index: statements.len() });\n \n     tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\"}]}