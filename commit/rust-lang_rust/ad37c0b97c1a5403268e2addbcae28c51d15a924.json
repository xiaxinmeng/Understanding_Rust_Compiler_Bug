{"sha": "ad37c0b97c1a5403268e2addbcae28c51d15a924", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMzdjMGI5N2MxYTU0MDMyNjhlMmFkZGJjYWUyOGM1MWQxNWE5MjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T09:01:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T09:01:43Z"}, "message": "auto merge of #12740 : nical/rust/json-streaming, r=erickt\n\nHi rust enthusiasts,\r\n\r\nWith this patch I propose to add a \"streaming\" API to the existing json parser in libserialize.\r\n\r\nBy \"streaming\" I mean a parser that let you act on JsonEvents that are generated as while parsing happens, as opposed to parsing the entire source, generating a big data structure and working with this data structure. I think both approaches have their pros and cons so this pull request adds the streaming API, preserving the existing one.\r\n\r\nThe streaming API is simple: It consist into an Iterator<JsonEvent> that consumes an Iterator<char>. JsonEvent is an enum with values such as NumberValue(f64), BeginList, EndList, BeginObject, etc.\r\n\r\nThe user would ideally use the API as follows:\r\n\r\n```\r\nfor evt in StreamingParser::new(src) {\r\n  match evt {\r\n    BeginList => {\r\n       // ...\r\n    }\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nThe iterator provides a stack() method returning a slice of StackNodes which represent \"where we currently are\" in the logical structure of the json stream (for instance at \"foo.bar[3].x\" you get [ Key(\"foo\"), Key(\"bar\"), Index(3), Key(\"x\") ].)\r\n\r\nI wrote \"ideally\" above because the current way rust expands for loops, you can't call the stack() method because the iterator is already borrowed. So for know you need to manually advance the iterator in the loop. I hope this is something we can cope with, until for loops are better integrated with the compiler.\r\n\r\nStreaming parsers are useful when you want to read from a json stream, generate a custom data structure and you know how the json is going to be structured. For example, imagine you have to parse a 3D mesh file represented in the json format. In this case you probably expect to have large arrays of vertices and using the generic parser will be very inefficient because it will create a big list of all these vertices, which you will copy into a contiguous array afterwards (so you end up doing a lot of small allocations, parsing the json once and parsing the data structure afterwards). With a streaming parser, you can add the vertices to a contiguous array as they come in without paying the cost of creating the intermediate Json data structure. You have much fewer allocations since you write directly in the final data structure and you can be smart in how you will pre-allocate it.\r\n\r\nI added added this directly into serialize::json rather than in its own library because it turns out I can reuse most of the existing code whereas maintaining a separate library (which I did originally) forces me to duplicate this code.\r\n\r\nI wrote this trying to minimize the size of the patch so there may be places where the code could be nicer at the expenses of more changes (let me know what you prefer).\r\n\r\nThis is my first (potential) contribution to rust, so please let me know if I am doing something wrong (maybe I should have first introduced this proposition in the mailing list, or opened a github issue, etc.?). I work a few meters away from @pknfelix so I am not too hard to find :)", "tree": {"sha": "cb79e418da4c118b58b82e9e35de6e649eccb461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb79e418da4c118b58b82e9e35de6e649eccb461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad37c0b97c1a5403268e2addbcae28c51d15a924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad37c0b97c1a5403268e2addbcae28c51d15a924", "html_url": "https://github.com/rust-lang/rust/commit/ad37c0b97c1a5403268e2addbcae28c51d15a924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad37c0b97c1a5403268e2addbcae28c51d15a924/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f77784b57f55b1aa0c5e8359995a688750a9217b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f77784b57f55b1aa0c5e8359995a688750a9217b", "html_url": "https://github.com/rust-lang/rust/commit/f77784b57f55b1aa0c5e8359995a688750a9217b"}, {"sha": "02c45dece43f9f884b5b09ceb3db26c2a056a7f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c45dece43f9f884b5b09ceb3db26c2a056a7f4", "html_url": "https://github.com/rust-lang/rust/commit/02c45dece43f9f884b5b09ceb3db26c2a056a7f4"}], "stats": {"total": 1320, "additions": 1054, "deletions": 266}, "files": [{"sha": "01af70d755a2a7ee825855392dcb36620c6b5b07", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1049, "deletions": 261, "changes": 1310, "blob_url": "https://github.com/rust-lang/rust/blob/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ad37c0b97c1a5403268e2addbcae28c51d15a924", "patch": "@@ -235,13 +235,15 @@ fn main() {\n use collections::HashMap;\n use std::char;\n use std::f64;\n-use std::fmt;\n use std::io::MemWriter;\n use std::io;\n use std::num;\n use std::str;\n use std::str::ScalarValue;\n use std::strbuf::StrBuf;\n+use std::fmt;\n+use std::vec::Vec;\n+use std::mem::swap;\n \n use Encodable;\n use collections::TreeMap;\n@@ -260,31 +262,93 @@ pub enum Json {\n pub type List = ~[Json];\n pub type Object = TreeMap<~str, Json>;\n \n-#[deriving(Eq, Show)]\n-pub enum Error {\n+/// The errors that can arise while parsing a JSON stream.\n+#[deriving(Clone, Eq)]\n+pub enum ErrorCode {\n+    InvalidSyntax,\n+    InvalidNumber,\n+    EOFWhileParsingObject,\n+    EOFWhileParsingList,\n+    EOFWhileParsingValue,\n+    EOFWhileParsingString,\n+    KeyMustBeAString,\n+    ExpectedColon,\n+    TrailingCharacters,\n+    InvalidEscape,\n+    InvalidUnicodeCodePoint,\n+    LoneLeadingSurrogateInHexEscape,\n+    UnexpectedEndOfHexEscape,\n+    UnrecognizedHex,\n+    NotFourDigit,\n+    NotUtf8,\n+}\n+\n+#[deriving(Clone, Eq, Show)]\n+pub enum ParserError {\n     /// msg, line, col\n-    ParseError(~str, uint, uint),\n+    SyntaxError(ErrorCode, uint, uint),\n+    IoError(io::IoErrorKind, &'static str),\n+}\n+\n+// Builder and Parser have the same errors.\n+pub type BuilderError = ParserError;\n+\n+#[deriving(Clone, Eq, Show)]\n+pub enum DecoderError {\n+    ParseError(ParserError),\n     ExpectedError(~str, ~str),\n     MissingFieldError(~str),\n     UnknownVariantError(~str),\n-    IoError(io::IoError)\n+}\n+\n+/// Returns a readable error string for a given error code.\n+pub fn error_str(error: ErrorCode) -> &'static str {\n+    return match error {\n+        InvalidSyntax => \"invalid syntax\",\n+        InvalidNumber => \"invalid number\",\n+        EOFWhileParsingObject => \"EOF While parsing object\",\n+        EOFWhileParsingList => \"EOF While parsing list\",\n+        EOFWhileParsingValue => \"EOF While parsing value\",\n+        EOFWhileParsingString => \"EOF While parsing string\",\n+        KeyMustBeAString => \"key must be a string\",\n+        ExpectedColon => \"expected `:`\",\n+        TrailingCharacters => \"trailing characters\",\n+        InvalidEscape => \"invalid escape\",\n+        UnrecognizedHex => \"invalid \\\\u escape (unrecognized hex)\",\n+        NotFourDigit => \"invalid \\\\u escape (not four digits)\",\n+        NotUtf8 => \"contents not utf-8\",\n+        InvalidUnicodeCodePoint => \"invalid unicode code point\",\n+        LoneLeadingSurrogateInHexEscape => \"lone leading surrogate in hex escape\",\n+        UnexpectedEndOfHexEscape => \"unexpected end of hex escape\",\n+    }\n+}\n+\n+impl fmt::Show for ErrorCode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        error_str(*self).fmt(f)\n+    }\n+}\n+\n+\n+fn io_error_to_error(io: io::IoError) -> ParserError {\n+    IoError(io.kind, io.desc)\n }\n \n pub type EncodeResult = io::IoResult<()>;\n-pub type DecodeResult<T> = Result<T, Error>;\n+pub type DecodeResult<T> = Result<T, DecoderError>;\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = StrBuf::from_str(\"\\\"\");\n     for c in s.chars() {\n         match c {\n-          '\"' => escaped.push_str(\"\\\\\\\"\"),\n-          '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n-          '\\x08' => escaped.push_str(\"\\\\b\"),\n-          '\\x0c' => escaped.push_str(\"\\\\f\"),\n-          '\\n' => escaped.push_str(\"\\\\n\"),\n-          '\\r' => escaped.push_str(\"\\\\r\"),\n-          '\\t' => escaped.push_str(\"\\\\t\"),\n-          _ => escaped.push_char(c),\n+            '\"' => escaped.push_str(\"\\\\\\\"\"),\n+            '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n+            '\\x08' => escaped.push_str(\"\\\\b\"),\n+            '\\x0c' => escaped.push_str(\"\\\\f\"),\n+            '\\n' => escaped.push_str(\"\\\\n\"),\n+            '\\r' => escaped.push_str(\"\\\\r\"),\n+            '\\t' => escaped.push_str(\"\\\\t\"),\n+            _ => escaped.push_char(c),\n         }\n     };\n     escaped.push_char('\"');\n@@ -901,46 +965,236 @@ impl Json {\n     }\n }\n \n+/// The output of the streaming parser.\n+#[deriving(Eq, Clone, Show)]\n+pub enum JsonEvent {\n+    ObjectStart,\n+    ObjectEnd,\n+    ListStart,\n+    ListEnd,\n+    BooleanValue(bool),\n+    NumberValue(f64),\n+    StringValue(~str),\n+    NullValue,\n+    Error(ParserError),\n+}\n+\n+#[deriving(Eq, Show)]\n+enum ParserState {\n+    // Parse a value in a list, true means first element.\n+    ParseList(bool),\n+    // Parse ',' or ']' after an element in a list.\n+    ParseListComma,\n+    // Parse a key:value in an object, true means first element.\n+    ParseObject(bool),\n+    // Parse ',' or ']' after an element in an object.\n+    ParseObjectComma,\n+    // Initialial state.\n+    ParseStart,\n+    // Expecting the stream to end.\n+    ParseBeforeFinish,\n+    // Parsing can't continue.\n+    ParseFinished,\n+}\n+\n+/// A Stack represents the current position of the parser in the logical\n+/// structure of the JSON stream.\n+/// For example foo.bar[3].x\n+pub struct Stack {\n+    stack: Vec<InternalStackElement>,\n+    str_buffer: Vec<u8>,\n+}\n+\n+/// StackElements compose a Stack.\n+/// For example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\n+/// StackElements compositing the stack that represents foo.bar[3].x\n+#[deriving(Eq, Clone, Show)]\n+pub enum StackElement<'l> {\n+    Index(u32),\n+    Key(&'l str),\n+}\n+\n+// Internally, Key elements are stored as indices in a buffer to avoid\n+// allocating a string for every member of an object.\n+#[deriving(Eq, Clone, Show)]\n+enum InternalStackElement {\n+    InternalIndex(u32),\n+    InternalKey(u16, u16), // start, size\n+}\n+\n+impl Stack {\n+    pub fn new() -> Stack {\n+        Stack {\n+            stack: Vec::new(),\n+            str_buffer: Vec::new(),\n+        }\n+    }\n+\n+    /// Returns The number of elements in the Stack.\n+    pub fn len(&self) -> uint { self.stack.len() }\n+\n+    /// Returns true if the stack is empty, equivalent to self.len() == 0.\n+    pub fn is_empty(&self) -> bool { self.stack.len() == 0 }\n+\n+    /// Provides access to the StackElement at a given index.\n+    /// lower indices are at the bottom of the stack while higher indices are\n+    /// at the top.\n+    pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n+        return match *self.stack.get(idx) {\n+          InternalIndex(i) => { Index(i) }\n+          InternalKey(start, size) => {\n+            Key(str::from_utf8(self.str_buffer.slice(start as uint, (start+size) as uint)).unwrap())\n+          }\n+        }\n+    }\n+\n+    /// Compares this stack with an array of StackElements.\n+    pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n+        if self.stack.len() != rhs.len() { return false; }\n+        for i in range(0, rhs.len()) {\n+            if self.get(i) != rhs[i] { return false; }\n+        }\n+        return true;\n+    }\n+\n+    /// Returns true if the bottom-most elements of this stack are the same as\n+    /// the ones passed as parameter.\n+    pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n+        if self.stack.len() < rhs.len() { return false; }\n+        for i in range(0, rhs.len()) {\n+            if self.get(i) != rhs[i] { return false; }\n+        }\n+        return true;\n+    }\n+\n+    /// Returns true if the top-most elements of this stack are the same as\n+    /// the ones passed as parameter.\n+    pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n+        if self.stack.len() < rhs.len() { return false; }\n+        let offset = self.stack.len() - rhs.len();\n+        for i in range(0, rhs.len()) {\n+            if self.get(i + offset) != rhs[i] { return false; }\n+        }\n+        return true;\n+    }\n+\n+    /// Returns the top-most element (if any).\n+    pub fn top<'l>(&'l self) -> Option<StackElement<'l>> {\n+        return match self.stack.last() {\n+            None => None,\n+            Some(&InternalIndex(i)) => Some(Index(i)),\n+            Some(&InternalKey(start, size)) => {\n+                Some(Key(str::from_utf8(\n+                    self.str_buffer.slice(start as uint, (start+size) as uint)\n+                ).unwrap()))\n+            }\n+        }\n+    }\n+\n+    // Used by Parser to insert Key elements at the top of the stack.\n+    fn push_key(&mut self, key: ~str) {\n+        self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n+        for c in key.as_bytes().iter() {\n+            self.str_buffer.push(*c);\n+        }\n+    }\n+\n+    // Used by Parser to insert Index elements at the top of the stack.\n+    fn push_index(&mut self, index: u32) {\n+        self.stack.push(InternalIndex(index));\n+    }\n+\n+    // Used by Parser to remove the top-most element of the stack.\n+    fn pop(&mut self) {\n+        assert!(!self.is_empty());\n+        match *self.stack.last().unwrap() {\n+            InternalKey(_, sz) => {\n+                let new_size = self.str_buffer.len() - sz as uint;\n+                unsafe {\n+                    self.str_buffer.set_len(new_size);\n+                }\n+            }\n+            InternalIndex(_) => {}\n+        }\n+        self.stack.pop();\n+    }\n+\n+    // Used by Parser to test whether the top-most element is an index.\n+    fn last_is_index(&self) -> bool {\n+        if self.is_empty() { return false; }\n+        return match *self.stack.last().unwrap() {\n+            InternalIndex(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    // Used by Parser to increment the index of the top-most element.\n+    fn bump_index(&mut self) {\n+        let len = self.stack.len();\n+        let idx = match *self.stack.last().unwrap() {\n+          InternalIndex(i) => { i + 1 }\n+          _ => { fail!(); }\n+        };\n+        *self.stack.get_mut(len - 1) = InternalIndex(idx);\n+    }\n+}\n+\n+/// A streaming JSON parser implemented as an iterator of JsonEvent, consuming\n+/// an iterator of char.\n pub struct Parser<T> {\n     rdr: T,\n     ch: Option<char>,\n     line: uint,\n     col: uint,\n+    // We maintain a stack representing where we are in the logical structure\n+    // of the JSON stream.\n+    stack: Stack,\n+    // A state machine is kept to make it possible to interupt and resume parsing.\n+    state: ParserState,\n+}\n+\n+impl<T: Iterator<char>> Iterator<JsonEvent> for Parser<T> {\n+    fn next(&mut self) -> Option<JsonEvent> {\n+        if self.state == ParseFinished {\n+            return None;\n+        }\n+\n+        if self.state == ParseBeforeFinish {\n+            self.parse_whitespace();\n+            // Make sure there is no trailing characters.\n+            if self.eof() {\n+                self.state = ParseFinished;\n+                return None;\n+            } else {\n+                return Some(self.error_event(TrailingCharacters));\n+            }\n+        }\n+\n+        return Some(self.parse());\n+    }\n }\n \n impl<T: Iterator<char>> Parser<T> {\n-    /// Decode a json value from an Iterator<char>\n+    /// Creates the JSON parser.\n     pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n             rdr: rdr,\n             ch: Some('\\x00'),\n             line: 1,\n             col: 0,\n+            stack: Stack::new(),\n+            state: ParseStart,\n         };\n         p.bump();\n-        p\n+        return p;\n     }\n-}\n \n-impl<T: Iterator<char>> Parser<T> {\n-    pub fn parse(&mut self) -> DecodeResult<Json> {\n-        match self.parse_value() {\n-          Ok(value) => {\n-            // Skip trailing whitespaces.\n-            self.parse_whitespace();\n-            // Make sure there is no trailing characters.\n-            if self.eof() {\n-                Ok(value)\n-            } else {\n-                self.error(\"trailing characters\".to_owned())\n-            }\n-          }\n-          Err(e) => Err(e)\n-        }\n+    /// Provides access to the current position in the logical structure of the\n+    /// JSON stream.\n+    pub fn stack<'l>(&'l self) -> &'l Stack {\n+        return &'l self.stack;\n     }\n-}\n \n-impl<T : Iterator<char>> Parser<T> {\n     fn eof(&self) -> bool { self.ch.is_none() }\n     fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }\n     fn bump(&mut self) {\n@@ -962,30 +1216,8 @@ impl<T : Iterator<char>> Parser<T> {\n         self.ch == Some(c)\n     }\n \n-    fn error<T>(&self, msg: ~str) -> DecodeResult<T> {\n-        Err(ParseError(msg, self.line, self.col))\n-    }\n-\n-    fn parse_value(&mut self) -> DecodeResult<Json> {\n-        self.parse_whitespace();\n-\n-        if self.eof() { return self.error(\"EOF while parsing value\".to_owned()); }\n-\n-        match self.ch_or_null() {\n-            'n' => self.parse_ident(\"ull\", Null),\n-            't' => self.parse_ident(\"rue\", Boolean(true)),\n-            'f' => self.parse_ident(\"alse\", Boolean(false)),\n-            '0' .. '9' | '-' => self.parse_number(),\n-            '\"' => {\n-                match self.parse_str() {\n-                    Ok(s) => Ok(String(s)),\n-                    Err(e) => Err(e),\n-                }\n-            },\n-            '[' => self.parse_list(),\n-            '{' => self.parse_object(),\n-            _ => self.error(\"invalid syntax\".to_owned()),\n-        }\n+    fn error<T>(&self, reason: ErrorCode) -> Result<T, ParserError> {\n+        Err(SyntaxError(reason, self.line, self.col))\n     }\n \n     fn parse_whitespace(&mut self) {\n@@ -995,16 +1227,7 @@ impl<T : Iterator<char>> Parser<T> {\n               self.ch_is('\\r') { self.bump(); }\n     }\n \n-    fn parse_ident(&mut self, ident: &str, value: Json) -> DecodeResult<Json> {\n-        if ident.chars().all(|c| Some(c) == self.next_char()) {\n-            self.bump();\n-            Ok(value)\n-        } else {\n-            self.error(\"invalid syntax\".to_owned())\n-        }\n-    }\n-\n-    fn parse_number(&mut self) -> DecodeResult<Json> {\n+    fn parse_number(&mut self) -> Result<f64, ParserError> {\n         let mut neg = 1.0;\n \n         if self.ch_is('-') {\n@@ -1031,10 +1254,10 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n         }\n \n-        Ok(Number(neg * res))\n+        Ok(neg * res)\n     }\n \n-    fn parse_integer(&mut self) -> DecodeResult<f64> {\n+    fn parse_integer(&mut self) -> Result<f64, ParserError> {\n         let mut res = 0.0;\n \n         match self.ch_or_null() {\n@@ -1043,7 +1266,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n                 // There can be only one leading '0'.\n                 match self.ch_or_null() {\n-                    '0' .. '9' => return self.error(\"invalid number\".to_owned()),\n+                    '0' .. '9' => return self.error(InvalidNumber),\n                     _ => ()\n                 }\n             },\n@@ -1053,25 +1276,24 @@ impl<T : Iterator<char>> Parser<T> {\n                         c @ '0' .. '9' => {\n                             res *= 10.0;\n                             res += ((c as int) - ('0' as int)) as f64;\n-\n                             self.bump();\n                         }\n                         _ => break,\n                     }\n                 }\n             }\n-            _ => return self.error(\"invalid number\".to_owned()),\n+            _ => return self.error(InvalidNumber),\n         }\n         Ok(res)\n     }\n \n-    fn parse_decimal(&mut self, res: f64) -> DecodeResult<f64> {\n+    fn parse_decimal(&mut self, res: f64) -> Result<f64, ParserError> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n         match self.ch_or_null() {\n             '0' .. '9' => (),\n-             _ => return self.error(\"invalid number\".to_owned())\n+             _ => return self.error(InvalidNumber)\n         }\n \n         let mut res = res;\n@@ -1081,7 +1303,6 @@ impl<T : Iterator<char>> Parser<T> {\n                 c @ '0' .. '9' => {\n                     dec /= 10.0;\n                     res += (((c as int) - ('0' as int)) as f64) * dec;\n-\n                     self.bump();\n                 }\n                 _ => break,\n@@ -1091,7 +1312,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_exponent(&mut self, mut res: f64) -> DecodeResult<f64> {\n+    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, ParserError> {\n         self.bump();\n \n         let mut exp = 0u;\n@@ -1107,7 +1328,7 @@ impl<T : Iterator<char>> Parser<T> {\n         // Make sure a digit follows the exponent place.\n         match self.ch_or_null() {\n             '0' .. '9' => (),\n-            _ => return self.error(\"invalid number\".to_owned())\n+            _ => return self.error(InvalidNumber)\n         }\n         while !self.eof() {\n             match self.ch_or_null() {\n@@ -1131,7 +1352,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn decode_hex_escape(&mut self) -> DecodeResult<u16> {\n+    fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n         let mut i = 0u;\n         let mut n = 0u16;\n         while i < 4u && !self.eof() {\n@@ -1144,30 +1365,28 @@ impl<T : Iterator<char>> Parser<T> {\n                 'd' | 'D' => n * 16_u16 + 13_u16,\n                 'e' | 'E' => n * 16_u16 + 14_u16,\n                 'f' | 'F' => n * 16_u16 + 15_u16,\n-                _ => return self.error(\n-                    \"invalid \\\\u escape (unrecognized hex)\".to_owned())\n+                _ => return self.error(InvalidEscape)\n             };\n \n             i += 1u;\n         }\n \n         // Error out if we didn't parse 4 digits.\n         if i != 4u {\n-            return self.error(\n-                \"invalid \\\\u escape (not four digits)\".to_owned());\n+            return self.error(InvalidEscape);\n         }\n \n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> DecodeResult<~str> {\n+    fn parse_str(&mut self) -> Result<~str, ParserError> {\n         let mut escape = false;\n         let mut res = StrBuf::new();\n \n         loop {\n             self.bump();\n             if self.eof() {\n-                return self.error(\"EOF while parsing string\".to_owned());\n+                return self.error(EOFWhileParsingString);\n             }\n \n             if escape {\n@@ -1180,9 +1399,9 @@ impl<T : Iterator<char>> Parser<T> {\n                     'n' => res.push_char('\\n'),\n                     'r' => res.push_char('\\r'),\n                     't' => res.push_char('\\t'),\n+//<<<<<<< HEAD\n                     'u' => match try!(self.decode_hex_escape()) {\n-                        0xDC00 .. 0xDFFF => return self.error(\n-                                \"lone trailing surrogate in hex escape\".to_owned()),\n+                        0xDC00 .. 0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n \n                         // Non-BMP characters are encoded as a sequence of\n                         // two hex escapes, representing UTF-16 surrogates.\n@@ -1191,25 +1410,52 @@ impl<T : Iterator<char>> Parser<T> {\n                             let c2 = self.next_char();\n                             match (c1, c2) {\n                                 (Some('\\\\'), Some('u')) => (),\n-                                _ => return self.error(\n-                                    \"unexpected end of non-BMP hex escape\".to_owned()),\n+                                _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n \n                             let buf = [n1, try!(self.decode_hex_escape())];\n                             match str::utf16_items(buf.as_slice()).next() {\n                                 Some(ScalarValue(c)) => res.push_char(c),\n-                                _ => return self.error(\n-                                    \"lone leading surrogate in hex escape\".to_owned()),\n+                                _ => return self.error(LoneLeadingSurrogateInHexEscape),\n                             }\n                         }\n \n                         n => match char::from_u32(n as u32) {\n                             Some(c) => res.push_char(c),\n-                            None => return self.error(\n-                                format!(\"invalid Unicode codepoint {:u}\", n)),\n+                            None => return self.error(InvalidUnicodeCodePoint),\n                         },\n                     },\n-                    _ => return self.error(\"invalid escape\".to_owned()),\n+                    _ => return self.error(InvalidEscape),\n+/*=======\n+                    'u' => {\n+                        // Parse \\u1234.\n+                        let mut i = 0u;\n+                        let mut n = 0u;\n+                        while i < 4u && !self.eof() {\n+                            self.bump();\n+                            n = match self.ch_or_null() {\n+                                c @ '0' .. '9' => n * 16u + (c as uint) - ('0' as uint),\n+                                'a' | 'A' => n * 16u + 10u,\n+                                'b' | 'B' => n * 16u + 11u,\n+                                'c' | 'C' => n * 16u + 12u,\n+                                'd' | 'D' => n * 16u + 13u,\n+                                'e' | 'E' => n * 16u + 14u,\n+                                'f' | 'F' => n * 16u + 15u,\n+                                _ => return self.error(UnrecognizedHex)\n+                            };\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Error out if we didn't parse 4 digits.\n+                        if i != 4u {\n+                            return self.error(NotFourDigit);\n+                        }\n+\n+                        res.push_char(char::from_u32(n as u32).unwrap());\n+                    }\n+                    _ => return self.error(InvalidEscape),\n+>>>>>>> Add a streaming parser to serialize::json.*/\n                 }\n                 escape = false;\n             } else if self.ch_is('\\\\') {\n@@ -1227,108 +1473,347 @@ impl<T : Iterator<char>> Parser<T> {\n         }\n     }\n \n-    fn parse_list(&mut self) -> DecodeResult<Json> {\n-        self.bump();\n-        self.parse_whitespace();\n+    // Invoked at each iteration, consumes the stream until it has enough\n+    // information to return a JsonEvent.\n+    // Manages an internal state so that parsing can be interrupted and resumed.\n+    // Also keeps track of the position in the logical structure of the json\n+    // stream int the form of a stack that can be queried by the user usng the\n+    // stack() method.\n+    fn parse(&mut self) -> JsonEvent {\n+        loop {\n+            // The only paths where the loop can spin a new iteration\n+            // are in the cases ParseListComma and ParseObjectComma if ','\n+            // is parsed. In these cases the state is set to (respectively)\n+            // ParseList(false) and ParseObject(false), which always return,\n+            // so there is no risk of getting stuck in an infinite loop.\n+            // All other paths return before the end of the loop's iteration.\n+            self.parse_whitespace();\n \n-        let mut values = Vec::new();\n+            match self.state {\n+                ParseStart => {\n+                    return self.parse_start();\n+                }\n+                ParseList(first) => {\n+                    return self.parse_list(first);\n+                }\n+                ParseListComma => {\n+                    match self.parse_list_comma_or_end() {\n+                        Some(evt) => { return evt; }\n+                        None => {}\n+                    }\n+                }\n+                ParseObject(first) => {\n+                    return self.parse_object(first);\n+                }\n+                ParseObjectComma => {\n+                    self.stack.pop();\n+                    if self.ch_is(',') {\n+                        self.state = ParseObject(false);\n+                        self.bump();\n+                    } else {\n+                        return self.parse_object_end();\n+                    }\n+                }\n+                _ => {\n+                    return self.error_event(InvalidSyntax);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_start(&mut self) -> JsonEvent {\n+        let val = self.parse_value();\n+        self.state = match val {\n+            Error(_) => { ParseFinished }\n+            ListStart => { ParseList(true) }\n+            ObjectStart => { ParseObject(true) }\n+            _ => { ParseBeforeFinish }\n+        };\n+        return val;\n+    }\n \n+    fn parse_list(&mut self, first: bool) -> JsonEvent {\n         if self.ch_is(']') {\n+            if !first {\n+                return self.error_event(InvalidSyntax);\n+            }\n+            if self.stack.is_empty() {\n+                self.state = ParseBeforeFinish;\n+            } else {\n+                self.state = if self.stack.last_is_index() {\n+                    ParseListComma\n+                } else {\n+                    ParseObjectComma\n+                }\n+            }\n             self.bump();\n-            return Ok(List(values.move_iter().collect()));\n+            return ListEnd;\n+        }\n+        if first {\n+            self.stack.push_index(0);\n         }\n \n-        loop {\n-            match self.parse_value() {\n-              Ok(v) => values.push(v),\n-              Err(e) => return Err(e)\n-            }\n+        let val = self.parse_value();\n \n-            self.parse_whitespace();\n-            if self.eof() {\n-                return self.error(\"EOF while parsing list\".to_owned());\n-            }\n+        self.state = match val {\n+            Error(_) => { ParseFinished }\n+            ListStart => { ParseList(true) }\n+            ObjectStart => { ParseObject(true) }\n+            _ => { ParseListComma }\n+        };\n+        return val;\n+    }\n \n-            if self.ch_is(',') {\n-                self.bump();\n-            } else if self.ch_is(']') {\n-                self.bump();\n-                return Ok(List(values.move_iter().collect()));\n+    fn parse_list_comma_or_end(&mut self) -> Option<JsonEvent> {\n+        if self.ch_is(',') {\n+            self.stack.bump_index();\n+            self.state = ParseList(false);\n+            self.bump();\n+            return None;\n+        } else if self.ch_is(']') {\n+            self.stack.pop();\n+            if self.stack.is_empty() {\n+                self.state = ParseBeforeFinish;\n             } else {\n-                return self.error(\"expected `,` or `]`\".to_owned())\n+                self.state = if self.stack.last_is_index() {\n+                    ParseListComma\n+                } else {\n+                    ParseObjectComma\n+                }\n             }\n-        };\n+            self.bump();\n+            return Some(ListEnd);\n+        } else if self.eof() {\n+            return Some(self.error_event(EOFWhileParsingList));\n+        } else {\n+            return Some(self.error_event(InvalidSyntax));\n+        }\n     }\n \n-    fn parse_object(&mut self) -> DecodeResult<Json> {\n+    fn parse_object(&mut self, first: bool) -> JsonEvent {\n+        if self.ch_is('}') {\n+            if !first {\n+                self.stack.pop();\n+            }\n+            if self.stack.is_empty() {\n+                self.state = ParseBeforeFinish;\n+            } else {\n+                self.state = if self.stack.last_is_index() {\n+                    ParseListComma\n+                } else {\n+                    ParseObjectComma\n+                }\n+            }\n+            self.bump();\n+            return ObjectEnd;\n+        }\n+        if self.eof() {\n+            return self.error_event(EOFWhileParsingObject);\n+        }\n+        if !self.ch_is('\"') {\n+            return self.error_event(KeyMustBeAString);\n+        }\n+        let s = match self.parse_str() {\n+            Ok(s) => { s }\n+            Err(e) => {\n+                self.state = ParseFinished;\n+                return Error(e);\n+            }\n+        };\n+        self.parse_whitespace();\n+        if self.eof() {\n+            return self.error_event(EOFWhileParsingObject);\n+        } else if self.ch_or_null() != ':' {\n+            return self.error_event(ExpectedColon);\n+        }\n+        self.stack.push_key(s);\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~TreeMap::new();\n+        let val = self.parse_value();\n \n+        self.state = match val {\n+            Error(_) => { ParseFinished }\n+            ListStart => { ParseList(true) }\n+            ObjectStart => { ParseObject(true) }\n+            _ => { ParseObjectComma }\n+        };\n+        return val;\n+    }\n+\n+    fn parse_object_end(&mut self) -> JsonEvent {\n         if self.ch_is('}') {\n-          self.bump();\n-          return Ok(Object(values));\n+            if self.stack.is_empty() {\n+                self.state = ParseBeforeFinish;\n+            } else {\n+                self.state = if self.stack.last_is_index() {\n+                    ParseListComma\n+                } else {\n+                    ParseObjectComma\n+                }\n+            }\n+            self.bump();\n+            return ObjectEnd;\n+        } else if self.eof() {\n+            return self.error_event(EOFWhileParsingObject);\n+        } else {\n+            return self.error_event(InvalidSyntax);\n         }\n+    }\n \n-        while !self.eof() {\n-            self.parse_whitespace();\n-\n-            if !self.ch_is('\"') {\n-                return self.error(\"key must be a string\".to_owned());\n+    fn parse_value(&mut self) -> JsonEvent {\n+        if self.eof() { return self.error_event(EOFWhileParsingValue); }\n+        match self.ch_or_null() {\n+            'n' => { return self.parse_ident(\"ull\", NullValue); }\n+            't' => { return self.parse_ident(\"rue\", BooleanValue(true)); }\n+            'f' => { return self.parse_ident(\"alse\", BooleanValue(false)); }\n+            '0' .. '9' | '-' => return match self.parse_number() {\n+                Ok(f) => NumberValue(f),\n+                Err(e) => Error(e),\n+            },\n+            '\"' => return match self.parse_str() {\n+                Ok(s) => StringValue(s),\n+                Err(e) => Error(e),\n+            },\n+            '[' => {\n+                self.bump();\n+                return ListStart;\n+            }\n+            '{' => {\n+                self.bump();\n+                return ObjectStart;\n             }\n+            _ => { return self.error_event(InvalidSyntax); }\n+        }\n+    }\n \n-            let key = match self.parse_str() {\n-              Ok(key) => key,\n-              Err(e) => return Err(e)\n-            };\n+    fn parse_ident(&mut self, ident: &str, value: JsonEvent) -> JsonEvent {\n+        if ident.chars().all(|c| Some(c) == self.next_char()) {\n+            self.bump();\n+            value\n+        } else {\n+            Error(SyntaxError(InvalidSyntax, self.line, self.col))\n+        }\n+    }\n \n-            self.parse_whitespace();\n+    fn error_event(&mut self, reason: ErrorCode) -> JsonEvent {\n+        self.state = ParseFinished;\n+        Error(SyntaxError(reason, self.line, self.col))\n+    }\n+}\n \n-            if !self.ch_is(':') {\n-                if self.eof() { break; }\n-                return self.error(\"expected `:`\".to_owned());\n-            }\n-            self.bump();\n+/// A Builder consumes a json::Parser to create a generic Json structure.\n+pub struct Builder<T> {\n+    parser: Parser<T>,\n+    token: Option<JsonEvent>,\n+}\n \n-            match self.parse_value() {\n-              Ok(value) => { values.insert(key, value); }\n-              Err(e) => return Err(e)\n+impl<T: Iterator<char>> Builder<T> {\n+    /// Create a JSON Builder.\n+    pub fn new(src: T) -> Builder<T> {\n+        Builder {\n+            parser: Parser::new(src),\n+            token: None,\n+        }\n+    }\n+\n+    // Decode a Json value from a Parser.\n+    pub fn build(&mut self) -> Result<Json, BuilderError> {\n+        self.bump();\n+        let result = self.build_value();\n+        self.bump();\n+        match self.token {\n+            None => {}\n+            Some(Error(e)) => { return Err(e); }\n+            ref tok => { fail!(\"unexpected token {}\", tok.clone()); }\n+        }\n+        return result;\n+    }\n+\n+    fn bump(&mut self) {\n+        self.token = self.parser.next();\n+    }\n+\n+    fn build_value(&mut self) -> Result<Json, BuilderError> {\n+        return match self.token {\n+            Some(NullValue) => { Ok(Null) }\n+            Some(NumberValue(n)) => { Ok(Number(n)) }\n+            Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n+            Some(StringValue(ref mut s)) => {\n+                let mut temp = ~\"\";\n+                swap(s, &mut temp);\n+                Ok(String(temp))\n             }\n-            self.parse_whitespace();\n+            Some(Error(e)) => { Err(e) }\n+            Some(ListStart) => { self.build_list() }\n+            Some(ObjectStart) => { self.build_object() }\n+            Some(ObjectEnd) => { self.parser.error(InvalidSyntax) }\n+            Some(ListEnd) => { self.parser.error(InvalidSyntax) }\n+            None => { self.parser.error(EOFWhileParsingValue) }\n+        }\n+    }\n \n-            match self.ch_or_null() {\n-                ',' => self.bump(),\n-                '}' => { self.bump(); return Ok(Object(values)); },\n-                _ => {\n-                    if self.eof() { break; }\n-                    return self.error(\"expected `,` or `}`\".to_owned());\n-                }\n+    fn build_list(&mut self) -> Result<Json, BuilderError> {\n+        self.bump();\n+        let mut values = Vec::new();\n+\n+        loop {\n+            if self.token == Some(ListEnd) {\n+                return Ok(List(values.move_iter().collect()));\n+            }\n+            match self.build_value() {\n+                Ok(v) => values.push(v),\n+                Err(e) => { return Err(e) }\n             }\n+            self.bump();\n         }\n+    }\n \n-        return self.error(\"EOF while parsing object\".to_owned());\n+    fn build_object(&mut self) -> Result<Json, BuilderError> {\n+        self.bump();\n+\n+        let mut values = ~TreeMap::new();\n+\n+        while self.token != None {\n+            match self.token {\n+                Some(ObjectEnd) => { return Ok(Object(values)); }\n+                Some(Error(e)) => { return Err(e); }\n+                None => { break; }\n+                _ => {}\n+            }\n+            let key = match self.parser.stack().top() {\n+                Some(Key(k)) => { k.into_owned() }\n+                _ => { fail!(\"invalid state\"); }\n+            };\n+            match self.build_value() {\n+                Ok(value) => { values.insert(key, value); }\n+                Err(e) => { return Err(e); }\n+            }\n+            self.bump();\n+        }\n+        return self.parser.error(EOFWhileParsingObject);\n     }\n }\n \n+\n /// Decodes a json value from an `&mut io::Reader`\n-pub fn from_reader(rdr: &mut io::Reader) -> DecodeResult<Json> {\n+pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n     let contents = match rdr.read_to_end() {\n         Ok(c) => c,\n-        Err(e) => return Err(IoError(e))\n+        Err(e) => return Err(io_error_to_error(e))\n     };\n     let s = match str::from_utf8(contents.as_slice()) {\n         Some(s) => s.to_owned(),\n-        None => return Err(ParseError(\"contents not utf-8\".to_owned(), 0, 0))\n+        None => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n-    let mut parser = Parser::new(s.chars());\n-    parser.parse()\n+    let mut builder = Builder::new(s.chars());\n+    builder.build()\n }\n \n /// Decodes a json value from a string\n-pub fn from_str(s: &str) -> DecodeResult<Json> {\n-    let mut parser = Parser::new(s.chars());\n-    parser.parse()\n+pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n+    let mut builder = Builder::new(s.chars());\n+    return builder.build();\n }\n \n /// A structure to decode JSON to values in rust.\n@@ -1366,7 +1851,7 @@ macro_rules! expect(\n     })\n )\n \n-impl ::Decoder<Error> for Decoder {\n+impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         debug!(\"read_nil\");\n         try!(expect!(self.pop(), Null));\n@@ -1782,10 +2267,18 @@ impl fmt::Show for Json {\n \n #[cfg(test)]\n mod tests {\n+    extern crate test;\n+    use self::test::Bencher;\n     use {Encodable, Decodable};\n     use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n-                MissingFieldError, UnknownVariantError, DecodeResult };\n+                MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n+                JsonEvent, Parser, StackElement,\n+                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, NumberValue, StringValue,\n+                NullValue, SyntaxError, Key, Index, Stack,\n+                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n+                EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n+                TrailingCharacters};\n     use std::io;\n     use collections::TreeMap;\n \n@@ -2040,36 +2533,22 @@ mod tests {\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert_eq!(from_str(\"nulla\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 5u)));\n-        assert_eq!(from_str(\"truea\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 5u)));\n-        assert_eq!(from_str(\"falsea\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 6u)));\n-        assert_eq!(from_str(\"1a\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"[]a\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 3u)));\n-        assert_eq!(from_str(\"{}a\"),\n-            Err(ParseError(\"trailing characters\".to_owned(), 1u, 3u)));\n+        assert_eq!(from_str(\"nulla\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+        assert_eq!(from_str(\"truea\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+        assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n+        assert_eq!(from_str(\"1a\"),     Err(SyntaxError(TrailingCharacters, 1, 2)));\n+        assert_eq!(from_str(\"[]a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n+        assert_eq!(from_str(\"{}a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert_eq!(from_str(\"n\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"nul\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n-\n-        assert_eq!(from_str(\"t\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"truz\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n-\n-        assert_eq!(from_str(\"f\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"faz\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 3u)));\n+        assert_eq!(from_str(\"n\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(from_str(\"nul\"),  Err(SyntaxError(InvalidSyntax, 1, 4)));\n+        assert_eq!(from_str(\"t\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n+        assert_eq!(from_str(\"f\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(from_str(\"faz\"),  Err(SyntaxError(InvalidSyntax, 1, 3)));\n \n         assert_eq!(from_str(\"null\"), Ok(Null));\n         assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n@@ -2096,21 +2575,13 @@ mod tests {\n \n     #[test]\n     fn test_read_number() {\n-        assert_eq!(from_str(\"+\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 1u)));\n-        assert_eq!(from_str(\".\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 1u)));\n-\n-        assert_eq!(from_str(\"-\"),\n-            Err(ParseError(\"invalid number\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"00\"),\n-            Err(ParseError(\"invalid number\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"1.\"),\n-            Err(ParseError(\"invalid number\".to_owned(), 1u, 3u)));\n-        assert_eq!(from_str(\"1e\"),\n-            Err(ParseError(\"invalid number\".to_owned(), 1u, 3u)));\n-        assert_eq!(from_str(\"1e+\"),\n-            Err(ParseError(\"invalid number\".to_owned(), 1u, 4u)));\n+        assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+        assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+        assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n+        assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n+        assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+        assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+        assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n \n         assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n         assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n@@ -2155,31 +2626,19 @@ mod tests {\n \n     #[test]\n     fn test_read_str() {\n-        assert_eq!(from_str(\"\\\"\"),\n-            Err(ParseError(\"EOF while parsing string\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"\\\"lol\"),\n-            Err(ParseError(\"EOF while parsing string\".to_owned(), 1u, 5u)));\n-\n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_owned())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_owned())));\n-\n-        // Non-BMP escapes.  The exact error messages and positions are kind of\n-        // arbitrary.\n-        assert_eq!(from_str(\"\\\"\\\\ud83d\\\\udca9\\\"\"), Ok(String(\"\\U0001F4A9\".to_owned())));\n-        assert!(from_str(\"\\\"\\\\ud83d\\\"\").is_err());\n-        assert!(from_str(\"\\\"\\\\udca9\\\"\").is_err());\n-        assert!(from_str(\"\\\"\\\\ud83d\\\\ud83d\\\"\").is_err());\n-        assert!(from_str(\"\\\"\\\\ud83dx\\\"\").is_err());\n-        assert!(from_str(\"\\\"\\\\udca9\\\\udca9\\\"\").is_err());\n-        assert!(from_str(\"\\\"\\\\udca9x\\\"\").is_err());\n+        assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n+        assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n+\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n@@ -2223,16 +2682,11 @@ mod tests {\n \n     #[test]\n     fn test_read_list() {\n-        assert_eq!(from_str(\"[\"),\n-            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"[1\"),\n-            Err(ParseError(\"EOF while parsing list\".to_owned(), 1u, 3u)));\n-        assert_eq!(from_str(\"[1,\"),\n-            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 4u)));\n-        assert_eq!(from_str(\"[1,]\"),\n-            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n-        assert_eq!(from_str(\"[6 7]\"),\n-            Err(ParseError(\"expected `,` or `]`\".to_owned(), 1u, 4u)));\n+        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n \n         assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n         assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n@@ -2276,29 +2730,18 @@ mod tests {\n \n     #[test]\n     fn test_read_object() {\n-        assert_eq!(from_str(\"{\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"{ \"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 3u)));\n-        assert_eq!(from_str(\"{1\"),\n-            Err(ParseError(\"key must be a string\".to_owned(), 1u, 2u)));\n-        assert_eq!(from_str(\"{ \\\"a\\\"\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 6u)));\n-        assert_eq!(from_str(\"{\\\"a\\\"\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 5u)));\n-        assert_eq!(from_str(\"{\\\"a\\\" \"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 6u)));\n-\n-        assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n-            Err(ParseError(\"expected `:`\".to_owned(), 1u, 6u)));\n-        assert_eq!(from_str(\"{\\\"a\\\":\"),\n-            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 6u)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 7u)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n-            Err(ParseError(\"expected `,` or `}`\".to_owned(), 1u, 8u)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 8u)));\n+        assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n+        assert_eq!(from_str(\"{ \"),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+        assert_eq!(from_str(\"{1\"),      Err(SyntaxError(KeyMustBeAString,      1, 2)));\n+        assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+        assert_eq!(from_str(\"{\\\"a\\\"\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+        assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+        assert_eq!(from_str(\"{\\\"a\\\" 1\"),   Err(SyntaxError(ExpectedColon,         1, 6)));\n+        assert_eq!(from_str(\"{\\\"a\\\":\"),    Err(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+        assert_eq!(from_str(\"{\\\"a\\\":1\"),   Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+        assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n+        assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n@@ -2396,7 +2839,7 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(ParseError(\"EOF while parsing object\".to_owned(), 3u, 8u)));\n+            Err(SyntaxError(EOFWhileParsingObject, 3u, 8u)));\n     }\n \n     #[deriving(Decodable)]\n@@ -2411,20 +2854,20 @@ mod tests {\n         A(f64),\n         B(~str)\n     }\n-    fn check_err<T: Decodable<Decoder, Error>>(to_parse: &'static str, expected: Error) {\n+    fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n+                                                      expected: DecoderError) {\n         let res: DecodeResult<T> = match from_str(to_parse) {\n-            Err(e) => Err(e),\n+            Err(e) => Err(ParseError(e)),\n             Ok(json) => Decodable::decode(&mut Decoder::new(json))\n         };\n         match res {\n             Ok(_) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n                               to_parse, expected),\n-            Err(ParseError(e, _, _)) => fail!(\"`{}` is not valid json: {}\",\n+            Err(ParseError(e)) => fail!(\"`{}` is not valid json: {}\",\n                                            to_parse, e),\n             Err(e) => {\n                 assert_eq!(e, expected);\n             }\n-\n         }\n     }\n     #[test]\n@@ -2592,7 +3035,7 @@ mod tests {\n         let mut mem_buf = MemWriter::new();\n         {\n             let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder).unwrap();\n+            hm.encode(&mut encoder).unwrap()\n         }\n         let bytes = mem_buf.unwrap();\n         let json_str = from_utf8(bytes.as_slice()).unwrap();\n@@ -2613,4 +3056,349 @@ mod tests {\n         let mut decoder = Decoder::new(json_obj);\n         let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n+\n+    fn assert_stream_equal(src: &str, expected: ~[(JsonEvent, ~[StackElement])]) {\n+        let mut parser = Parser::new(src.chars());\n+        let mut i = 0;\n+        loop {\n+            let evt = match parser.next() {\n+                Some(e) => e,\n+                None => { break; }\n+            };\n+            let (ref expected_evt, ref expected_stack) = expected[i];\n+            if !parser.stack().is_equal_to(expected_stack.as_slice()) {\n+                fail!(\"Parser stack is not equal to {}\", expected_stack);\n+            }\n+            assert_eq!(&evt, expected_evt);\n+            i+=1;\n+        }\n+    }\n+    #[test]\n+    fn test_streaming_parser() {\n+        assert_stream_equal(\n+            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n+            ~[\n+                (ObjectStart,             ~[]),\n+                  (StringValue(~\"bar\"),   ~[Key(\"foo\")]),\n+                  (ListStart,             ~[Key(\"array\")]),\n+                    (NumberValue(0.0),    ~[Key(\"array\"), Index(0)]),\n+                    (NumberValue(1.0),    ~[Key(\"array\"), Index(1)]),\n+                    (NumberValue(2.0),    ~[Key(\"array\"), Index(2)]),\n+                    (NumberValue(3.0),    ~[Key(\"array\"), Index(3)]),\n+                    (NumberValue(4.0),    ~[Key(\"array\"), Index(4)]),\n+                    (NumberValue(5.0),    ~[Key(\"array\"), Index(5)]),\n+                  (ListEnd,               ~[Key(\"array\")]),\n+                  (ListStart,             ~[Key(\"idents\")]),\n+                    (NullValue,           ~[Key(\"idents\"), Index(0)]),\n+                    (BooleanValue(true),  ~[Key(\"idents\"), Index(1)]),\n+                    (BooleanValue(false), ~[Key(\"idents\"), Index(2)]),\n+                  (ListEnd,               ~[Key(\"idents\")]),\n+                (ObjectEnd,               ~[]),\n+            ]\n+        );\n+    }\n+    fn last_event(src: &str) -> JsonEvent {\n+        let mut parser = Parser::new(src.chars());\n+        let mut evt = NullValue;\n+        loop {\n+            evt = match parser.next() {\n+                Some(e) => e,\n+                None => return evt,\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_read_object_streaming() {\n+        assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+        assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n+        assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+        assert_eq!(last_event(\"{\\\"a\\\"\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+        assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+        assert_eq!(last_event(\"{\\\"a\\\" 1\"),   Error(SyntaxError(ExpectedColon,         1, 6)));\n+        assert_eq!(last_event(\"{\\\"a\\\":\"),    Error(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+        assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+        assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n+        assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+\n+        assert_stream_equal(\n+            \"{}\",\n+            ~[(ObjectStart, ~[]), (ObjectEnd, ~[])]\n+        );\n+        assert_stream_equal(\n+            \"{\\\"a\\\": 3}\",\n+            ~[\n+                (ObjectStart,        ~[]),\n+                  (NumberValue(3.0), ~[Key(\"a\")]),\n+                (ObjectEnd,          ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n+            ~[\n+                (ObjectStart,           ~[]),\n+                  (NullValue,           ~[Key(\"a\")]),\n+                  (BooleanValue(true),  ~[Key(\"b\")]),\n+                (ObjectEnd,             ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n+            ~[\n+                (ObjectStart,           ~[]),\n+                  (NumberValue(1.0),    ~[Key(\"a\")]),\n+                  (ListStart,           ~[Key(\"b\")]),\n+                    (BooleanValue(true),~[Key(\"b\"), Index(0)]),\n+                  (ListEnd,             ~[Key(\"b\")]),\n+                (ObjectEnd,             ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            r#\"{\n+                \"a\": 1.0,\n+                \"b\": [\n+                    true,\n+                    \"foo\\nbar\",\n+                    { \"c\": {\"d\": null} }\n+                ]\n+            }\"#,\n+            ~[\n+                (ObjectStart,                   ~[]),\n+                  (NumberValue(1.0),            ~[Key(\"a\")]),\n+                  (ListStart,                   ~[Key(\"b\")]),\n+                    (BooleanValue(true),        ~[Key(\"b\"), Index(0)]),\n+                    (StringValue(~\"foo\\nbar\"),  ~[Key(\"b\"), Index(1)]),\n+                    (ObjectStart,               ~[Key(\"b\"), Index(2)]),\n+                      (ObjectStart,             ~[Key(\"b\"), Index(2), Key(\"c\")]),\n+                        (NullValue,             ~[Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n+                      (ObjectEnd,               ~[Key(\"b\"), Index(2), Key(\"c\")]),\n+                    (ObjectEnd,                 ~[Key(\"b\"), Index(2)]),\n+                  (ListEnd,                     ~[Key(\"b\")]),\n+                (ObjectEnd,                     ~[]),\n+            ]\n+        );\n+    }\n+    #[test]\n+    fn test_read_list_streaming() {\n+        assert_stream_equal(\n+            \"[]\",\n+            ~[\n+                (ListStart, ~[]),\n+                (ListEnd,   ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[ ]\",\n+            ~[\n+                (ListStart, ~[]),\n+                (ListEnd,   ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[true]\",\n+            ~[\n+                (ListStart,              ~[]),\n+                    (BooleanValue(true), ~[Index(0)]),\n+                (ListEnd,                ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[ false ]\",\n+            ~[\n+                (ListStart,               ~[]),\n+                    (BooleanValue(false), ~[Index(0)]),\n+                (ListEnd,                 ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[null]\",\n+            ~[\n+                (ListStart,     ~[]),\n+                    (NullValue, ~[Index(0)]),\n+                (ListEnd,       ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[3, 1]\",\n+            ~[\n+                (ListStart,     ~[]),\n+                    (NumberValue(3.0), ~[Index(0)]),\n+                    (NumberValue(1.0), ~[Index(1)]),\n+                (ListEnd,       ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"\\n[3, 2]\\n\",\n+            ~[\n+                (ListStart,     ~[]),\n+                    (NumberValue(3.0), ~[Index(0)]),\n+                    (NumberValue(2.0), ~[Index(1)]),\n+                (ListEnd,       ~[]),\n+            ]\n+        );\n+        assert_stream_equal(\n+            \"[2, [4, 1]]\",\n+            ~[\n+                (ListStart,                 ~[]),\n+                    (NumberValue(2.0),      ~[Index(0)]),\n+                    (ListStart,             ~[Index(1)]),\n+                        (NumberValue(4.0),  ~[Index(1), Index(0)]),\n+                        (NumberValue(1.0),  ~[Index(1), Index(1)]),\n+                    (ListEnd,               ~[Index(1)]),\n+                (ListEnd,                   ~[]),\n+            ]\n+        );\n+\n+        assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n+\n+        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n+\n+    }\n+    #[test]\n+    fn test_trailing_characters_streaming() {\n+        assert_eq!(last_event(\"nulla\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+        assert_eq!(last_event(\"truea\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+        assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n+        assert_eq!(last_event(\"1a\"),     Error(SyntaxError(TrailingCharacters, 1, 2)));\n+        assert_eq!(last_event(\"[]a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+        assert_eq!(last_event(\"{}a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+    }\n+    #[test]\n+    fn test_read_identifiers_streaming() {\n+        assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n+        assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n+        assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n+\n+        assert_eq!(last_event(\"n\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(last_event(\"nul\"),  Error(SyntaxError(InvalidSyntax, 1, 4)));\n+        assert_eq!(last_event(\"t\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n+        assert_eq!(last_event(\"f\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+        assert_eq!(last_event(\"faz\"),  Error(SyntaxError(InvalidSyntax, 1, 3)));\n+    }\n+\n+    #[test]\n+    fn test_stack() {\n+        let mut stack = Stack::new();\n+\n+        assert!(stack.is_empty());\n+        assert!(stack.len() == 0);\n+        assert!(!stack.last_is_index());\n+\n+        stack.push_index(0);\n+        stack.bump_index();\n+\n+        assert!(stack.len() == 1);\n+        assert!(stack.is_equal_to([Index(1)]));\n+        assert!(stack.starts_with([Index(1)]));\n+        assert!(stack.ends_with([Index(1)]));\n+        assert!(stack.last_is_index());\n+        assert!(stack.get(0) == Index(1));\n+\n+        stack.push_key(~\"foo\");\n+\n+        assert!(stack.len() == 2);\n+        assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with([Index(1)]));\n+        assert!(stack.ends_with([Index(1), Key(\"foo\")]));\n+        assert!(stack.ends_with([Key(\"foo\")]));\n+        assert!(!stack.last_is_index());\n+        assert!(stack.get(0) == Index(1));\n+        assert!(stack.get(1) == Key(\"foo\"));\n+\n+        stack.push_key(~\"bar\");\n+\n+        assert!(stack.len() == 3);\n+        assert!(stack.is_equal_to([Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.starts_with([Index(1)]));\n+        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with([Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.ends_with([Key(\"bar\")]));\n+        assert!(stack.ends_with([Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.ends_with([Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(!stack.last_is_index());\n+        assert!(stack.get(0) == Index(1));\n+        assert!(stack.get(1) == Key(\"foo\"));\n+        assert!(stack.get(2) == Key(\"bar\"));\n+\n+        stack.pop();\n+\n+        assert!(stack.len() == 2);\n+        assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with([Index(1)]));\n+        assert!(stack.ends_with([Index(1), Key(\"foo\")]));\n+        assert!(stack.ends_with([Key(\"foo\")]));\n+        assert!(!stack.last_is_index());\n+        assert!(stack.get(0) == Index(1));\n+        assert!(stack.get(1) == Key(\"foo\"));\n+    }\n+\n+    #[bench]\n+    fn bench_streaming_small(b: &mut Bencher) {\n+        b.iter( || {\n+            let mut parser = Parser::new(\n+                r#\"{\n+                    \"a\": 1.0,\n+                    \"b\": [\n+                        true,\n+                        \"foo\\nbar\",\n+                        { \"c\": {\"d\": null} }\n+                    ]\n+                }\"#.chars()\n+            );\n+            loop {\n+                match parser.next() {\n+                    None => return,\n+                    _ => {}\n+                }\n+            }\n+        });\n+    }\n+    #[bench]\n+    fn bench_small(b: &mut Bencher) {\n+        b.iter( || {\n+            let _ = from_str(r#\"{\n+                \"a\": 1.0,\n+                \"b\": [\n+                    true,\n+                    \"foo\\nbar\",\n+                    { \"c\": {\"d\": null} }\n+                ]\n+            }\"#);\n+        });\n+    }\n+\n+    fn big_json() -> ~str {\n+        let mut src = ~\"[\\n\";\n+        for _ in range(0, 500) {\n+            src = src + r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": [1,2,3]},\"#;\n+        }\n+        src = src + \"{}]\";\n+        return src;\n+    }\n+\n+    #[bench]\n+    fn bench_streaming_large(b: &mut Bencher) {\n+        let src = big_json();\n+        b.iter( || {\n+            let mut parser = Parser::new(src.chars());\n+            loop {\n+                match parser.next() {\n+                    None => return,\n+                    _ => {}\n+                }\n+            }\n+        });\n+    }\n+    #[bench]\n+    fn bench_large(b: &mut Bencher) {\n+        let src = big_json();\n+        b.iter( || { let _ = from_str(src); });\n+    }\n }"}, {"sha": "9343de83d4d7c09ee459fe462f8e5132f8ffdea0", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=ad37c0b97c1a5403268e2addbcae28c51d15a924", "patch": "@@ -261,7 +261,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n }\n \n // FIXME(#5121)\n-fn json_decode<T:Decodable<json::Decoder, json::Error>>(s: &str) -> T {\n+fn json_decode<T:Decodable<json::Decoder, json::DecoderError>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n     let mut decoder = json::Decoder::new(j);\n@@ -394,14 +394,14 @@ impl<'a> Prep<'a> {\n \n     pub fn exec<'a, T:Send +\n         Encodable<json::Encoder<'a>, io::IoError> +\n-        Decodable<json::Decoder, json::Error>>(\n+        Decodable<json::Decoder, json::DecoderError>>(\n             &'a self, blk: proc(&mut Exec):Send -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<'a, T:Send +\n         Encodable<json::Encoder<'a>, io::IoError> +\n-        Decodable<json::Decoder, json::Error>>( // FIXME(#5121)\n+        Decodable<json::Decoder, json::DecoderError>>( // FIXME(#5121)\n             &'a self, blk: proc(&mut Exec):Send -> T) -> Work<'a, T> {\n         let mut bo = Some(blk);\n \n@@ -445,7 +445,7 @@ impl<'a> Prep<'a> {\n \n impl<'a, T:Send +\n        Encodable<json::Encoder<'a>, io::IoError> +\n-       Decodable<json::Decoder, json::Error>>\n+       Decodable<json::Decoder, json::DecoderError>>\n     Work<'a, T> { // FIXME(#5121)\n \n     pub fn from_value(elt: T) -> Work<'a, T> {"}, {"sha": "20b818f47d47749fd636244232f7cf2a0f4417c0", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad37c0b97c1a5403268e2addbcae28c51d15a924/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=ad37c0b97c1a5403268e2addbcae28c51d15a924", "patch": "@@ -13,7 +13,7 @@ extern crate serialize;\n \n use serialize::{json, Decodable};\n \n-trait JD : Decodable<json::Decoder, json::Error> { }\n+trait JD : Decodable<json::Decoder, json::DecoderError> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();"}]}