{"sha": "b5082f7da85303e5aee97949e98fd137fa77f845", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MDgyZjdkYTg1MzAzZTVhZWU5Nzk0OWU5OGZkMTM3ZmE3N2Y4NDU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-22T13:38:10Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-30T18:21:21Z"}, "message": "Support unsized types", "tree": {"sha": "768c9ce154d3e483d138bc128eddf00e07cda5af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/768c9ce154d3e483d138bc128eddf00e07cda5af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5082f7da85303e5aee97949e98fd137fa77f845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5082f7da85303e5aee97949e98fd137fa77f845", "html_url": "https://github.com/rust-lang/rust/commit/b5082f7da85303e5aee97949e98fd137fa77f845", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5082f7da85303e5aee97949e98fd137fa77f845/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0117b7872ad9be5e9484bd27eb271022d31ce82e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0117b7872ad9be5e9484bd27eb271022d31ce82e", "html_url": "https://github.com/rust-lang/rust/commit/0117b7872ad9be5e9484bd27eb271022d31ce82e"}], "stats": {"total": 148, "additions": 123, "deletions": 25}, "files": [{"sha": "efe07ca2eccbf7dc352153e3019c51401924ec04", "filename": "examples/example.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/examples%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/examples%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fexample.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -141,9 +141,9 @@ unsafe fn call_uninit() -> u8 {\n }\n \n // TODO: enable when fat pointers are supported\n-/*unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n+unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n     &*s\n-}*/\n+}\n \n fn use_array(arr: [u8; 3]) -> u8 {\n     arr[1]"}, {"sha": "112d87743feabbd54aac4b26ed35010a57d8d19f", "filename": "src/abi.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -28,6 +28,11 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n     ty: Ty<'tcx>,\n     is_return: bool,\n ) -> PassMode {\n+    assert!(\n+        !tcx.layout_of(ParamEnv::reveal_all().and(ty))\n+            .unwrap()\n+            .is_unsized()\n+    );\n     if ty.sty == tcx.mk_nil().sty {\n         if is_return {\n             //if false {\n@@ -312,7 +317,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             //unimplemented!(\"pass mode nopass\");\n             fx.local_map.insert(\n                 RETURN_PLACE,\n-                CPlace::Addr(null, fx.layout_of(fx.return_type())),\n+                CPlace::Addr(null, None, fx.layout_of(fx.return_type())),\n             );\n         }\n         PassMode::ByVal(ret_ty) => {\n@@ -321,8 +326,10 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                 .insert(RETURN_PLACE, CPlace::Var(RETURN_PLACE, ret_layout));\n         }\n         PassMode::ByRef => {\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::Addr(ret_param.unwrap(), ret_layout));\n+            fx.local_map.insert(\n+                RETURN_PLACE,\n+                CPlace::Addr(ret_param.unwrap(), None, ret_layout),\n+            );\n         }\n     }\n "}, {"sha": "8cbdf6db855a08972b1727360baad60dac6ab2fb", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -309,8 +309,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 }\n                 Rvalue::Ref(_, _, place) => {\n                     let place = trans_place(fx, place);\n-                    let addr = place.expect_addr();\n-                    lval.write_cvalue(fx, CValue::ByVal(addr, dest_layout));\n+                    place.write_place_ref(fx, lval);\n                 }\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n@@ -893,13 +892,7 @@ pub fn trans_place<'a, 'tcx: 'a>(\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n             match projection.elem {\n-                ProjectionElem::Deref => {\n-                    let layout = fx.layout_of(place.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx));\n-                    if layout.is_unsized() {\n-                        unimpl!(\"Unsized places are not yet implemented\");\n-                    }\n-                    CPlace::Addr(base.to_cvalue(fx).load_value(fx), layout)\n-                }\n+                ProjectionElem::Deref => base.place_deref(fx),\n                 ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n                 ProjectionElem::Index(local) => {\n                     let index = fx.get_local_place(local).to_cvalue(fx).load_value(fx);"}, {"sha": "768c8cd25e1ab7b66ef21a8de4964156d93b9d52", "filename": "src/common.rs", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -19,6 +19,24 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n+fn scalar_to_cton_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n+    match scalar.value.size(tcx).bits() {\n+        8 => types::I8,\n+        16 => types::I16,\n+        32 => types::I32,\n+        64 => types::I64,\n+        size => bug!(\"Unsupported scalar size {}\", size),\n+    }\n+}\n+\n+fn ptr_referee<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.sty {\n+        ty::Ref(_, ty, _) => ty,\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty,\n+        _ => bug!(\"{:?}\", ty),\n+    }\n+}\n+\n pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -224,18 +242,19 @@ impl<'tcx> CValue<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub enum CPlace<'tcx> {\n     Var(Local, TyLayout<'tcx>),\n-    Addr(Value, TyLayout<'tcx>),\n+    Addr(Value, Option<Value>, TyLayout<'tcx>),\n }\n \n impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n         match *self {\n-            CPlace::Var(_, layout) | CPlace::Addr(_, layout) => layout,\n+            CPlace::Var(_, layout) | CPlace::Addr(_, _, layout) => layout,\n         }\n     }\n \n     pub fn temp(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, ty: Ty<'tcx>) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n+        assert!(!layout.is_unsized());\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n@@ -245,6 +264,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             fx.bcx\n                 .ins()\n                 .stack_addr(fx.module.pointer_type(), stack_slot, 0),\n+            None,\n             layout,\n         )\n     }\n@@ -255,24 +275,30 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n+        assert!(!layout.is_unsized());\n         CPlace::Addr(\n             fx.bcx\n                 .ins()\n                 .stack_addr(fx.module.pointer_type(), stack_slot, 0),\n+            None,\n             layout,\n         )\n     }\n \n     pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n         match self {\n             CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(mir_var(var)), layout),\n-            CPlace::Addr(addr, layout) => CValue::ByRef(addr, layout),\n+            CPlace::Addr(addr, extra, layout) => {\n+                assert!(extra.is_none(), \"unsized values are not yet supported\");\n+                CValue::ByRef(addr, layout)\n+            }\n         }\n     }\n \n     pub fn expect_addr(self) -> Value {\n         match self {\n-            CPlace::Addr(addr, _layout) => addr,\n+            CPlace::Addr(addr, None, _layout) => addr,\n+            CPlace::Addr(_, _, _) => bug!(\"Expected sized CPlace::Addr, found {:?}\", self),\n             CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n     }\n@@ -308,7 +334,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 let data = from.load_value(fx);\n                 fx.bcx.def_var(mir_var(var), data)\n             }\n-            CPlace::Addr(addr, layout) => {\n+            CPlace::Addr(addr, None, layout) => {\n                 let size = layout.size.bytes() as i32;\n \n                 match from {\n@@ -346,6 +372,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                     }\n                 }\n             }\n+            CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n         }\n     }\n \n@@ -354,11 +381,14 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n-        let base = self.expect_addr();\n         let layout = self.layout();\n+        if layout.is_unsized() {\n+            unimpl!(\"unsized place_field\");\n+        }\n \n+        let base = self.expect_addr();\n         let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        CPlace::Addr(field_ptr, field_layout)\n+        CPlace::Addr(field_ptr, None, field_layout)\n     }\n \n     pub fn place_index(\n@@ -368,24 +398,91 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     ) -> CPlace<'tcx> {\n         let addr = self.expect_addr();\n         let layout = self.layout();\n+        if layout.is_unsized() {\n+            unimpl!(\"unsized place_field\");\n+        }\n+\n         match layout.ty.sty {\n             ty::Array(elem_ty, _) => {\n                 let elem_layout = fx.layout_of(elem_ty);\n                 let offset = fx\n                     .bcx\n                     .ins()\n                     .imul_imm(index, elem_layout.size.bytes() as i64);\n-                CPlace::Addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n+                CPlace::Addr(fx.bcx.ins().iadd(addr, offset), None, elem_layout)\n             }\n             ty::Slice(_elem_ty) => unimplemented!(\"place_index(TySlice)\"),\n             _ => bug!(\"place_index({:?})\", layout.ty),\n         }\n     }\n \n+    pub fn place_deref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CPlace<'tcx> {\n+        let inner_layout = fx.layout_of(ptr_referee(self.layout().ty));\n+        if !inner_layout.is_unsized() {\n+            CPlace::Addr(self.to_cvalue(fx).load_value(fx), None, inner_layout)\n+        } else {\n+            match self.layout().abi {\n+                Abi::ScalarPair(ref a, ref b) => {\n+                    let addr = self.expect_addr();\n+                    let ptr =\n+                        fx.bcx\n+                            .ins()\n+                            .load(scalar_to_cton_type(fx.tcx, a), MemFlags::new(), addr, 0);\n+                    let extra = fx.bcx.ins().load(\n+                        scalar_to_cton_type(fx.tcx, b),\n+                        MemFlags::new(),\n+                        addr,\n+                        a.value.size(fx.tcx).bytes() as u32 as i32,\n+                    );\n+                    println!(\n+                        \"unsized deref: ptr: {:?} extra: {:?} self: {:?}\",\n+                        ptr, extra, self\n+                    );\n+                    CPlace::Addr(ptr, Some(extra), inner_layout)\n+                }\n+                _ => bug!(\n+                    \"Fat ptr doesn't have abi ScalarPair, but it has {:?}\",\n+                    self.layout().abi\n+                ),\n+            }\n+        }\n+    }\n+\n+    pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+        if !self.layout().is_unsized() {\n+            let ptr = CValue::ByVal(self.expect_addr(), dest.layout());\n+            dest.write_cvalue(fx, ptr);\n+        } else {\n+            match self {\n+                CPlace::Var(_, _) => bug!(\"expected CPlace::Addr found CPlace::Var\"),\n+                CPlace::Addr(value, extra, _) => match dest.layout().abi {\n+                    Abi::ScalarPair(ref a, _) => {\n+                        fx.bcx\n+                            .ins()\n+                            .store(MemFlags::new(), value, dest.expect_addr(), 0);\n+                        fx.bcx.ins().store(\n+                            MemFlags::new(),\n+                            extra.expect(\"unsized type without metadata\"),\n+                            dest.expect_addr(),\n+                            a.value.size(fx.tcx).bytes() as u32 as i32,\n+                        );\n+                    }\n+                    _ => bug!(\n+                        \"Non ScalarPair abi {:?} in write_place_ref dest\",\n+                        dest.layout().abi\n+                    ),\n+                },\n+            }\n+        }\n+    }\n+\n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n         match self {\n             CPlace::Var(var, _) => CPlace::Var(var, layout),\n-            CPlace::Addr(addr, _) => CPlace::Addr(addr, layout),\n+            CPlace::Addr(addr, extra, _) => {\n+                assert!(!layout.is_unsized());\n+                CPlace::Addr(addr, extra, layout)\n+            }\n         }\n     }\n "}, {"sha": "f912f435fcbf7acdc5a050b740397d8ac85c5b1b", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -179,7 +179,8 @@ fn cplace_for_dataid<'a, 'tcx: 'a>(\n         .ins()\n         .global_value(fx.module.pointer_type(), local_data_id);\n     let layout = fx.layout_of(fx.monomorphize(&ty));\n-    CPlace::Addr(global_ptr, layout)\n+    assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n+    CPlace::Addr(global_ptr, None, layout)\n }\n \n fn define_all_allocs<'a, 'tcx: 'a, B: Backend + 'a>("}, {"sha": "fa74f928ddb45aa7a94a0d2ded0f06ed569b34ba", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5082f7da85303e5aee97949e98fd137fa77f845/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b5082f7da85303e5aee97949e98fd137fa77f845", "patch": "@@ -63,7 +63,7 @@ mod prelude {\n     pub use rustc::mir::interpret::AllocId;\n     pub use rustc::mir::*;\n     pub use rustc::session::{config::CrateType, Session};\n-    pub use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n+    pub use rustc::ty::layout::{self, Abi, LayoutOf, Scalar, Size, TyLayout};\n     pub use rustc::ty::{\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeAndMut, TypeFoldable,"}]}