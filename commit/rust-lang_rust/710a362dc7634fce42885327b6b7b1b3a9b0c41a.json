{"sha": "710a362dc7634fce42885327b6b7b1b3a9b0c41a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMGEzNjJkYzc2MzRmY2U0Mjg4NTMyN2I2YjdiMWIzYTliMGM0MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-05T17:45:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-05T17:45:31Z"}, "message": "Auto merge of #66828 - GuillaumeGomez:less-minification, r=kinnison\n\nLess minification\n\nThe goal of this PR is to remove the minification process on the `search-index.js` file. It provides great result in term of space reduction but the computation time is far too long. I'll work on this issue and will put it back once it's fast enough.\n\ncc @nox @lqd\nr? @kinnison", "tree": {"sha": "94fffdf9ceb1ed040dd048027ae647f1afd33d61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94fffdf9ceb1ed040dd048027ae647f1afd33d61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/710a362dc7634fce42885327b6b7b1b3a9b0c41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/710a362dc7634fce42885327b6b7b1b3a9b0c41a", "html_url": "https://github.com/rust-lang/rust/commit/710a362dc7634fce42885327b6b7b1b3a9b0c41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/710a362dc7634fce42885327b6b7b1b3a9b0c41a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0312c156d8470179101ab71ef6a69c0b9a8dd0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0312c156d8470179101ab71ef6a69c0b9a8dd0b", "html_url": "https://github.com/rust-lang/rust/commit/a0312c156d8470179101ab71ef6a69c0b9a8dd0b"}, {"sha": "2d0f0ca25b473c16bfa8f071d2d8462a36f43ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0f0ca25b473c16bfa8f071d2d8462a36f43ce0", "html_url": "https://github.com/rust-lang/rust/commit/2d0f0ca25b473c16bfa8f071d2d8462a36f43ce0"}], "stats": {"total": 105, "additions": 14, "deletions": 91}, "files": [{"sha": "e245764b302090b5ca44df93be616250d19857cd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 90, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/710a362dc7634fce42885327b6b7b1b3a9b0c41a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/710a362dc7634fce42885327b6b7b1b3a9b0c41a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=710a362dc7634fce42885327b6b7b1b3a9b0c41a", "patch": "@@ -644,10 +644,9 @@ themePicker.onblur = handleThemeButtonsBlur;\n     themes.appendChild(but);\n }});\"#,\n                  as_json(&themes));\n-    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n-          theme_js.as_bytes()\n-    )?;\n-\n+    write_minify(&cx.shared.fs, cx.path(\"theme.js\"),\n+                 &theme_js,\n+                 options.enable_minification)?;\n     write_minify(&cx.shared.fs, cx.path(\"main.js\"),\n                  static_files::MAIN_JS,\n                  options.enable_minification)?;\n@@ -715,19 +714,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n         path: &Path,\n         krate: &str,\n         key: &str,\n-        for_search_index: bool,\n-    ) -> io::Result<(Vec<String>, Vec<String>, Vec<String>)> {\n+    ) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n-        let mut variables = Vec::new();\n \n         if path.exists() {\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n-                if for_search_index && line.starts_with(\"var R\") {\n-                    variables.push(line.clone());\n-                    continue;\n-                }\n                 if !line.starts_with(key) {\n                     continue;\n                 }\n@@ -741,7 +734,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                                  .unwrap_or_else(|| String::new()));\n             }\n         }\n-        Ok((ret, krates, variables))\n+        Ok((ret, krates))\n     }\n \n     fn show_item(item: &IndexItem, krate: &str) -> String {\n@@ -756,7 +749,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n     {\n-        let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n+        let (mut all_aliases, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\"), &dst);\n         let mut output = String::with_capacity(100);\n         for (alias, items) in &cx.cache.aliases {\n             if items.is_empty() {\n@@ -853,9 +846,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n \n         let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n-        let (mut all_sources, _krates, _) = try_err!(collect(&dst, &krate.name, \"sourcesIndex\",\n-                                                             false),\n-                                                     &dst);\n+        let (mut all_sources, _krates) = try_err!(collect(&dst, &krate.name, \"sourcesIndex\"), &dst);\n         all_sources.push(format!(\"sourcesIndex[\\\"{}\\\"] = {};\",\n                                  &krate.name,\n                                  hierarchy.to_json_string()));\n@@ -867,23 +858,18 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the search index\n     let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n-    let (mut all_indexes, mut krates, variables) = try_err!(collect(&dst,\n-                                                                    &krate.name,\n-                                                                    \"searchIndex\",\n-                                                                    true), &dst);\n+    let (mut all_indexes, mut krates) = try_err!(collect(&dst, &krate.name, \"searchIndex\"), &dst);\n     all_indexes.push(search_index);\n \n     // Sort the indexes by crate so the file will be generated identically even\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     {\n-        let mut v = String::from(\"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={};\\n\");\n-        v.push_str(&minify_replacer(\n-            &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n-            options.enable_minification));\n+        let mut v = String::from(\"var searchIndex={};\\n\");\n+        v.push_str(&all_indexes.join(\"\\n\"));\n         // \"addSearchOptions\" has to be called first so the crate filtering can be set before the\n         // search might start (if it's set into the URL for example).\n-        v.push_str(\"addSearchOptions(searchIndex);initSearch(searchIndex);\");\n+        v.push_str(\"\\naddSearchOptions(searchIndex);initSearch(searchIndex);\");\n         cx.shared.fs.write(&dst, &v)?;\n     }\n     if options.enable_index_page {\n@@ -981,9 +967,8 @@ themePicker.onblur = handleThemeButtonsBlur;\n                             remote_item_type,\n                             remote_path[remote_path.len() - 1]));\n \n-        let (mut all_implementors, _, _) = try_err!(collect(&mydst, &krate.name, \"implementors\",\n-                                                            false),\n-                                                    &mydst);\n+        let (mut all_implementors, _) = try_err!(collect(&mydst, &krate.name, \"implementors\"),\n+                                                 &mydst);\n         all_implementors.push(implementors);\n         // Sort the implementors by crate so the file will be generated\n         // identically even with rustdoc running in parallel.\n@@ -1020,68 +1005,6 @@ fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bo\n     }\n }\n \n-fn minify_replacer(\n-    contents: &str,\n-    enable_minification: bool,\n-) -> String {\n-    use minifier::js::{simple_minify, Keyword, ReservedChar, Token, Tokens};\n-\n-    if enable_minification {\n-        let tokens: Tokens<'_> = simple_minify(contents)\n-            .into_iter()\n-            .filter(|(f, next)| {\n-                // We keep backlines.\n-                minifier::js::clean_token_except(f, next, &|c: &Token<'_>| {\n-                    c.get_char() != Some(ReservedChar::Backline)\n-                })\n-            })\n-            .map(|(f, _)| {\n-                minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n-                    match *t {\n-                        Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n-                        Token::String(s) => {\n-                            let s = &s[1..s.len() -1]; // The quotes are included\n-                            if s.is_empty() {\n-                                Some(Token::Other(\"E\"))\n-                            } else if s == \"t\" {\n-                                Some(Token::Other(\"T\"))\n-                            } else if s == \"u\" {\n-                                Some(Token::Other(\"U\"))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-            })\n-            .collect::<Vec<_>>()\n-            .into();\n-        let o = tokens.apply(|f| {\n-            // We add a backline after the newly created variables.\n-            minifier::js::aggregate_strings_into_array_with_separation_filter(\n-                f,\n-                \"R\",\n-                Token::Char(ReservedChar::Backline),\n-                // This closure prevents crates' names from being aggregated.\n-                //\n-                // The point here is to check if the string is preceded by '[' and\n-                // \"searchIndex\". If so, it means this is a crate name and that it\n-                // shouldn't be aggregated.\n-                |tokens, pos| {\n-                    pos < 2 ||\n-                    !tokens[pos - 1].eq_char(ReservedChar::OpenBracket) ||\n-                    tokens[pos - 2].get_other() != Some(\"searchIndex\")\n-                }\n-            )\n-        })\n-        .to_string();\n-        format!(\"{}\\n\", o)\n-    } else {\n-        format!(\"{}\\n\", contents)\n-    }\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,"}, {"sha": "49a9cb093da2a3d1bf0fc64b94154171380bf00c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/710a362dc7634fce42885327b6b7b1b3a9b0c41a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/710a362dc7634fce42885327b6b7b1b3a9b0c41a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=710a362dc7634fce42885327b6b7b1b3a9b0c41a", "patch": "@@ -1221,7 +1221,7 @@ function getSearchElement() {\n                     // then an exact path match\n                     path.indexOf(keys[i]) > -1 ||\n                     // next if there is a parent, check for exact parent match\n-                    (parent !== undefined &&\n+                    (parent !== undefined && parent.name !== undefined &&\n                         parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n                     // lastly check to see if the name was a levenshtein match\n                     levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {"}]}