{"sha": "eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZDczYzZlNGQyMWUyNWNkNTUzZmUwNmEyNGU1MjAwNzE0YmMwYWI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-02T17:57:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-02T17:57:34Z"}, "message": "Rollup merge of #83757 - sexxi-goose:migrations_out, r=nikomatsakis\n\n2229: Support migration via rustfix\n\n- Adds support of machine applicable suggestions for `disjoint_capture_drop_reorder`.\n- Doesn't migrate in the case of pre-existing bugs in user code\n\nr? ``@nikomatsakis``", "tree": {"sha": "fc5ad524e2f0c942dbba686f8e02fc887c24a855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5ad524e2f0c942dbba686f8e02fc887c24a855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgZ1sPCRBK7hj4Ov3rIwAAdHIIABrLtoJR8Z+XxyETNMQffttG\nPfKK8IyzaErRviCf3H0V2XauJCxBfrNCOb5zbtlMSxxi2AxHnA1nE07R+VM7u3z1\noh1pTFsDQbdWhO/MSRcG5y4if82NTeVptYEA3LAmrwxSS8Fh14S+ydDuSFq0zJLb\nfVYYOoRIF7iSOJZ4VrIlPx4igeB/rN2WxcO8MS+simYwVlixqE5EFfK/DMvrVfuy\nx+eGtXzU5CyZEe3Ld2aIqem60QaJnkXInUn9wjNBQuVjm5hOemxUKwlnR5jBm5FK\nBLX0TGHD9KAnOuAfiZf2RPIblRbUFsqd5prk+zNg5IsgWM5gyg63ljmAzcs7/84=\n=Uz7o\n-----END PGP SIGNATURE-----\n", "payload": "tree fc5ad524e2f0c942dbba686f8e02fc887c24a855\nparent 70091171bd823cac1d3131cd6aea0f191d99a998\nparent 1b9620d75f75aad6629bb8815344a1a2f14a2081\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617386254 +0200\ncommitter GitHub <noreply@github.com> 1617386254 +0200\n\nRollup merge of #83757 - sexxi-goose:migrations_out, r=nikomatsakis\n\n2229: Support migration via rustfix\n\n- Adds support of machine applicable suggestions for `disjoint_capture_drop_reorder`.\n- Doesn't migrate in the case of pre-existing bugs in user code\n\nr? ``@nikomatsakis``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "html_url": "https://github.com/rust-lang/rust/commit/eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70091171bd823cac1d3131cd6aea0f191d99a998", "url": "https://api.github.com/repos/rust-lang/rust/commits/70091171bd823cac1d3131cd6aea0f191d99a998", "html_url": "https://github.com/rust-lang/rust/commit/70091171bd823cac1d3131cd6aea0f191d99a998"}, {"sha": "1b9620d75f75aad6629bb8815344a1a2f14a2081", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9620d75f75aad6629bb8815344a1a2f14a2081", "html_url": "https://github.com/rust-lang/rust/commit/1b9620d75f75aad6629bb8815344a1a2f14a2081"}], "stats": {"total": 857, "additions": 721, "deletions": 136}, "files": [{"sha": "6f8dd39958c04f020153fc8c0653a7efa3711f55", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 81, "deletions": 28, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -34,6 +34,7 @@ use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n@@ -91,7 +92,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n         if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.kind {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n-            self.fcx.analyze_closure(expr.hir_id, expr.span, body, cc);\n+            self.fcx.analyze_closure(expr.hir_id, expr.span, body_id, body, cc);\n         }\n \n         intravisit::walk_expr(self, expr);\n@@ -104,6 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n+        body_id: hir::BodyId,\n         body: &'tcx hir::Body<'tcx>,\n         capture_clause: hir::CaptureBy,\n     ) {\n@@ -167,7 +169,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if should_do_migration_analysis(self.tcx, closure_hir_id) {\n-            self.perform_2229_migration_anaysis(closure_def_id, capture_clause, span);\n+            self.perform_2229_migration_anaysis(closure_def_id, body_id, capture_clause, span);\n         }\n \n         // We now fake capture information for all variables that are mentioned within the closure\n@@ -465,6 +467,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn perform_2229_migration_anaysis(\n         &self,\n         closure_def_id: DefId,\n+        body_id: hir::BodyId,\n         capture_clause: hir::CaptureBy,\n         span: Span,\n     ) {\n@@ -476,7 +479,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         if !need_migrations.is_empty() {\n-            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations);\n+            let (migration_string, migrated_variables_concat) =\n+                migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n@@ -488,7 +492,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut diagnostics_builder = lint.build(\n                         \"drop order affected for closure because of `capture_disjoint_fields`\",\n                     );\n-                    diagnostics_builder.note(&migrations_text);\n+                    let closure_body_span = self.tcx.hir().span(body_id.hir_id);\n+                    let (sugg, app) =\n+                        match self.tcx.sess.source_map().span_to_snippet(closure_body_span) {\n+                            Ok(s) => {\n+                                let trimmed = s.trim_start();\n+\n+                                // If the closure contains a block then replace the opening brace\n+                                // with \"{ let _ = (..); \"\n+                                let sugg = if let Some('{') = trimmed.chars().next() {\n+                                    format!(\"{{ {}; {}\", migration_string, &trimmed[1..])\n+                                } else {\n+                                    format!(\"{{ {}; {} }}\", migration_string, s)\n+                                };\n+                                (sugg, Applicability::MachineApplicable)\n+                            }\n+                            Err(_) => (migration_string.clone(), Applicability::HasPlaceholders),\n+                        };\n+\n+                    let diagnostic_msg = format!(\n+                        \"add a dummy let to cause {} to be fully captured\",\n+                        migrated_variables_concat\n+                    );\n+\n+                    diagnostics_builder.span_suggestion(\n+                        closure_body_span,\n+                        &diagnostic_msg,\n+                        sugg,\n+                        app,\n+                    );\n                     diagnostics_builder.emit();\n                 },\n             );\n@@ -621,7 +653,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `w[c]`.\n     /// Notation:\n     /// - Ty(place): Type of place\n-    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_projs`\n+    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_by_move_projs`\n     /// respectively.\n     /// ```\n     ///                  (Ty(w), [ &[p, x], &[c] ])\n@@ -682,7 +714,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         closure_def_id: DefId,\n         closure_span: Span,\n         base_path_ty: Ty<'tcx>,\n-        captured_projs: Vec<&[Projection<'tcx>]>,\n+        captured_by_move_projs: Vec<&[Projection<'tcx>]>,\n     ) -> bool {\n         let needs_drop = |ty: Ty<'tcx>| {\n             ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n@@ -707,33 +739,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // eg. If `a.b` is captured and we are processing `a.b`, then we can't have the closure also\n         //     capture `a.b.c`, because that voilates min capture.\n-        let is_completely_captured = captured_projs.iter().any(|projs| projs.is_empty());\n+        let is_completely_captured = captured_by_move_projs.iter().any(|projs| projs.is_empty());\n \n-        assert!(!is_completely_captured || (captured_projs.len() == 1));\n+        assert!(!is_completely_captured || (captured_by_move_projs.len() == 1));\n \n         if is_completely_captured {\n             // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n             // when the closure is dropped.\n             return false;\n         }\n \n+        if captured_by_move_projs.is_empty() {\n+            return needs_drop(base_path_ty);\n+        }\n+\n         if is_drop_defined_for_ty {\n             // If drop is implemented for this type then we need it to be fully captured,\n-            // which we know it is not because of the previous check. Therefore we need to\n-            // do migrate.\n-            return true;\n-        }\n+            // and we know it is not completely captured because of the previous checks.\n \n-        if captured_projs.is_empty() {\n-            return needs_drop(base_path_ty);\n+            // Note that this is a bug in the user code that will be reported by the\n+            // borrow checker, since we can't move out of drop types.\n+\n+            // The bug exists in the user's code pre-migration, and we don't migrate here.\n+            return false;\n         }\n \n         match base_path_ty.kind() {\n             // Observations:\n-            // - `captured_projs` is not empty. Therefore we can call\n-            //   `captured_projs.first().unwrap()` safely.\n-            // - All entries in `captured_projs` have atleast one projection.\n-            //   Therefore we can call `captured_projs.first().unwrap().first().unwrap()` safely.\n+            // - `captured_by_move_projs` is not empty. Therefore we can call\n+            //   `captured_by_move_projs.first().unwrap()` safely.\n+            // - All entries in `captured_by_move_projs` have atleast one projection.\n+            //   Therefore we can call `captured_by_move_projs.first().unwrap().first().unwrap()` safely.\n \n             // We don't capture derefs in case of move captures, which would have be applied to\n             // access any further paths.\n@@ -743,19 +779,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             ty::Adt(def, substs) => {\n                 // Multi-varaint enums are captured in entirety,\n-                // which would've been handled in the case of single empty slice in `captured_projs`.\n+                // which would've been handled in the case of single empty slice in `captured_by_move_projs`.\n                 assert_eq!(def.variants.len(), 1);\n \n                 // Only Field projections can be applied to a non-box Adt.\n                 assert!(\n-                    captured_projs.iter().all(|projs| matches!(\n+                    captured_by_move_projs.iter().all(|projs| matches!(\n                         projs.first().unwrap().kind,\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n                 def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n                     |(i, field)| {\n-                        let paths_using_field = captured_projs\n+                        let paths_using_field = captured_by_move_projs\n                             .iter()\n                             .filter_map(|projs| {\n                                 if let ProjectionKind::Field(field_idx, _) =\n@@ -782,14 +818,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Tuple(..) => {\n                 // Only Field projections can be applied to a tuple.\n                 assert!(\n-                    captured_projs.iter().all(|projs| matches!(\n+                    captured_by_move_projs.iter().all(|projs| matches!(\n                         projs.first().unwrap().kind,\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n \n                 base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n-                    let paths_using_field = captured_projs\n+                    let paths_using_field = captured_by_move_projs\n                         .iter()\n                         .filter_map(|projs| {\n                             if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind\n@@ -1515,12 +1551,29 @@ fn should_do_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool\n     !matches!(level, lint::Level::Allow)\n }\n \n-fn migration_suggestion_for_2229(tcx: TyCtxt<'_>, need_migrations: &Vec<hir::HirId>) -> String {\n-    let need_migrations_strings =\n-        need_migrations.iter().map(|v| format!(\"{}\", var_name(tcx, *v))).collect::<Vec<_>>();\n-    let migrations_list_concat = need_migrations_strings.join(\", \");\n+/// Return a two string tuple (s1, s2)\n+/// - s1: Line of code that is needed for the migration: eg: `let _ = (&x, ...)`.\n+/// - s2: Comma separated names of the variables being migrated.\n+fn migration_suggestion_for_2229(\n+    tcx: TyCtxt<'_>,\n+    need_migrations: &Vec<hir::HirId>,\n+) -> (String, String) {\n+    let need_migrations_variables =\n+        need_migrations.iter().map(|v| var_name(tcx, *v)).collect::<Vec<_>>();\n+\n+    let migration_ref_concat =\n+        need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");\n+\n+    let migration_string = if 1 == need_migrations.len() {\n+        format!(\"let _ = {}\", migration_ref_concat)\n+    } else {\n+        format!(\"let _ = ({})\", migration_ref_concat)\n+    };\n+\n+    let migrated_variables_concat =\n+        need_migrations_variables.iter().map(|v| format!(\"`{}`\", v)).collect::<Vec<_>>().join(\", \");\n \n-    format!(\"drop(&({}));\", migrations_list_concat)\n+    (migration_string, migrated_variables_concat)\n }\n \n /// Helper function to determine if we need to escalate CaptureKind from"}, {"sha": "300f67e8b1e811db3e101a203eabf51a517132e3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,133 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a insignificant drop (stlib defined)\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || { let _ = (&t, &t1, &t2); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || { let _ = (&t, &t1); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+        println!(\"{}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// Copy types get copied into the closure instead of move. Therefore we don't need to\n+// migrate then as their drop order isn't tied to the closure.\n+fn test4_only_non_copy_types_need_migration() {\n+    let t = (String::new(), String::new());\n+\n+    // `t1` is Copy because all of its elements are Copy\n+    let t1 = (0i32, 0i32);\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn test5_only_drop_types_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (String::new(), String::new());\n+\n+    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n+    let s = S(0i32, 0i32);\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+        let _s = s.0;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test6_move_closures_non_copy_types_might_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = move || { let _ = (&t1, &t); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n+        println!(\"{} {}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test7_drop_non_drop_aggregate_need_migration() {\n+    let t = (String::new(), String::new(), 0i32);\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_only_non_copy_types_need_migration();\n+    test5_only_drop_types_need_migration();\n+    test6_move_closures_non_copy_types_might_need_migration();\n+    test7_drop_non_drop_aggregate_need_migration();\n+}"}, {"sha": "a17c70d3e287780e0355a17c072cc11ff708f5c3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![deny(disjoint_capture_drop_reorder)]\n //~^ NOTE: the lint level is defined here\n \n@@ -11,8 +13,9 @@ fn test1_all_need_migration() {\n     let t2 = (String::new(), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1, t2));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2.0;\n@@ -29,8 +32,8 @@ fn test2_only_precise_paths_need_migration() {\n     let t2 = (String::new(), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2;\n@@ -45,8 +48,8 @@ fn test3_only_by_value_need_migration() {\n     let t = (String::new(), String::new());\n     let t1 = (String::new(), String::new());\n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n         println!(\"{}\", t1.1);\n     };\n@@ -63,8 +66,8 @@ fn test4_only_non_copy_types_need_migration() {\n     let t1 = (0i32, 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n     };\n@@ -81,8 +84,8 @@ fn test5_only_drop_types_need_migration() {\n     let s = S(0i32, 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n         let _s = s.0;\n     };\n@@ -96,8 +99,8 @@ fn test6_move_closures_non_copy_types_might_need_migration() {\n     let t = (String::new(), String::new());\n     let t1 = (String::new(), String::new());\n     let c = move || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t1, t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{} {}\", t1.1, t.1);\n     };\n \n@@ -111,8 +114,8 @@ fn test7_drop_non_drop_aggregate_need_migration() {\n     let t = (String::new(), String::new(), 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n     };\n "}, {"sha": "69c12d2bb56c0f914eba16073767067714c9e0d0", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,25 +1,33 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:13:13\n+  --> $DIR/insignificant_drop.rs:15:13\n    |\n LL |       let c = || {\n    |  _____________^\n LL | |\n LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t1 = t1.0;\n+LL | |\n+...  |\n LL | |         let _t2 = t2.0;\n LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/insignificant_drop.rs:1:9\n+  --> $DIR/insignificant_drop.rs:3:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t, t1, t2));\n+help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1, &t2); \n+LL |\n+LL |\n+LL | \n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:31:13\n+  --> $DIR/insignificant_drop.rs:34:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -31,10 +39,18 @@ LL | |         let _t2 = t2;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t, t1));\n+help: add a dummy let to cause `t`, `t1` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1); \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:47:13\n+  --> $DIR/insignificant_drop.rs:50:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -45,10 +61,18 @@ LL | |         println!(\"{}\", t1.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         println!(\"{}\", t1.1);\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:65:13\n+  --> $DIR/insignificant_drop.rs:68:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -59,10 +83,18 @@ LL | |         let _t1 = t1.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:83:13\n+  --> $DIR/insignificant_drop.rs:86:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -73,10 +105,18 @@ LL | |         let _s = s.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _s = s.0;\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:98:13\n+  --> $DIR/insignificant_drop.rs:101:13\n    |\n LL |       let c = move || {\n    |  _____________^\n@@ -86,10 +126,17 @@ LL | |         println!(\"{} {}\", t1.1, t.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t1, t));\n+help: add a dummy let to cause `t1`, `t` to be fully captured\n+   |\n+LL |     let c = move || { let _ = (&t1, &t); \n+LL |\n+LL |\n+LL |         println!(\"{} {}\", t1.1, t.1);\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:113:13\n+  --> $DIR/insignificant_drop.rs:116:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -99,7 +146,14 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     };\n+   |\n \n error: aborting due to 7 previous errors\n "}, {"sha": "a3e51a2b8e91af1c264f196dc7f19ddceb7e1c40", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test the two possible cases for automated migartion using rustfix\n+// - Closure contains a block i.e.  `|| { .. };`\n+// - Closure contains just an expr `|| ..;`\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+fn closure_contains_block() {\n+    let t = (Foo(0), Foo(0));\n+    let c = || { let _ = &t; \n+        //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn closure_doesnt_contain_block() {\n+    let t = (Foo(0), Foo(0));\n+    let c = || { let _ = &t; t.0 };\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+\n+    c();\n+}\n+\n+fn main() {\n+    closure_contains_block();\n+    closure_doesnt_contain_block();\n+}"}, {"sha": "0eb837b6888350413e5d74a7d3bf7680a1ccb016", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test the two possible cases for automated migartion using rustfix\n+// - Closure contains a block i.e.  `|| { .. };`\n+// - Closure contains just an expr `|| ..;`\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+fn closure_contains_block() {\n+    let t = (Foo(0), Foo(0));\n+    let c = || {\n+        //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+fn closure_doesnt_contain_block() {\n+    let t = (Foo(0), Foo(0));\n+    let c = || t.0;\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+\n+    c();\n+}\n+\n+fn main() {\n+    closure_contains_block();\n+    closure_doesnt_contain_block();\n+}"}, {"sha": "e6173217edc2fb9b95cb4b46ddb626e4136a3773", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,38 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/migrations_rustfix.rs:19:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/migrations_rustfix.rs:2:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     };\n+   |\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/migrations_rustfix.rs:30:13\n+   |\n+LL |     let c = || t.0;\n+   |             ^^^^^^\n+   |\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; t.0 };\n+   |                ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b739035c784223ffd5d5ba38f89b5b677deea308", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.fixed", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+// Test that lint is triggered if a path that implements Drop is not captured by move\n+fn test_precise_analysis_drop_paths_not_captured_by_move() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+        let _t = &t.1;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test precise analysis for the lint works with paths longer than one.\n+fn test_precise_analysis_long_path_missing() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || { let _ = &u; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `u` to be fully captured\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_drop_paths_not_captured_by_move();\n+    test_precise_analysis_long_path_missing();\n+}"}, {"sha": "e1f29c9d0e9d8cb9544bb6712fbf3e7d112709b7", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,5 +1,6 @@\n+// run-rustfix\n+\n #![deny(disjoint_capture_drop_reorder)]\n-//~^ NOTE: the lint level is defined here\n \n #[derive(Debug)]\n struct Foo(i32);\n@@ -11,35 +12,13 @@ impl Drop for Foo {\n \n struct ConstainsDropField(Foo, Foo);\n \n-#[derive(Debug)]\n-struct ContainsAndImplsDrop(Foo);\n-impl Drop for ContainsAndImplsDrop {\n-    fn drop(&mut self) {\n-        println!(\"{:?} dropped\", self.0);\n-    }\n-}\n-\n-// Test that even if all paths starting at root variable that implement Drop are captured,\n-// the lint is triggered if the root variable implements drop and isn't captured.\n-fn test_precise_analysis_parent_root_impl_drop_not_captured() {\n-    let t = ContainsAndImplsDrop(Foo(10));\n-\n-    let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n-        let _t = t.0;\n-    };\n-\n-    c();\n-}\n-\n // Test that lint is triggered if a path that implements Drop is not captured by move\n fn test_precise_analysis_drop_paths_not_captured_by_move() {\n     let t = ConstainsDropField(Foo(10), Foo(20));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n         let _t = &t.1;\n     };\n@@ -61,8 +40,8 @@ fn test_precise_analysis_long_path_missing() {\n     let u = U(T(S, S), T(S, S));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(u));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `u` to be fully captured\n         let _x = u.0.0;\n         let _x = u.0.1;\n         let _x = u.1.0;\n@@ -72,7 +51,6 @@ fn test_precise_analysis_long_path_missing() {\n }\n \n fn main() {\n-    test_precise_analysis_parent_root_impl_drop_not_captured();\n     test_precise_analysis_drop_paths_not_captured_by_move();\n     test_precise_analysis_long_path_missing();\n }"}, {"sha": "7135ded13c2563a6d104c7f6d30f643d7b3c5986", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,37 +1,32 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:27:13\n+  --> $DIR/precise.rs:19:13\n    |\n LL |       let c = || {\n    |  _____________^\n LL | |\n LL | |\n LL | |         let _t = t.0;\n+LL | |         let _t = &t.1;\n LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/precise.rs:1:9\n+  --> $DIR/precise.rs:3:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t));\n-\n-error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:40:13\n+help: add a dummy let to cause `t` to be fully captured\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t = &t.1;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t = &t.1;\n+LL |     };\n    |\n-   = note: drop(&(t));\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:63:13\n+  --> $DIR/precise.rs:42:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -43,7 +38,15 @@ LL | |         let _x = u.1.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(u));\n+help: add a dummy let to cause `u` to be fully captured\n+   |\n+LL |     let c = || { let _ = &u; \n+LL |\n+LL |\n+LL |         let _x = u.0.0;\n+LL |         let _x = u.0.1;\n+LL |         let _x = u.1.0;\n+ ...\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "e1b212153f431053fb8ce06ddd176a021a589bb1", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -0,0 +1,136 @@\n+// run-rustfix\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a significant drop (user defined)\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ConstainsDropField(Foo, Foo);\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || { let _ = (&t, &t1, &t2); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || { let _ = (&t, &t1); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+        println!(\"{:?}\", t1.1);\n+    };\n+\n+    c();\n+}\n+\n+// The root variable might not implement drop themselves but some path starting\n+// at the root variable might implement Drop.\n+//\n+// If this path isn't captured we need to migrate for the root variable.\n+fn test4_type_contains_drop_need_migration() {\n+    let t = ConstainsDropField(Foo(0), Foo(0));\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test5_drop_non_drop_aggregate_need_migration() {\n+    let t = (Foo(0), Foo(0), 0i32);\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Significant and Insignificant Drop aggregates.\n+fn test6_significant_insignificant_drop_aggregate_need_migration() {\n+    let t = (Foo(0), String::new());\n+\n+    let c = || { let _ = &t; \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test7_move_closures_non_copy_types_might_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0), Foo(0));\n+\n+    let c = move || { let _ = (&t1, &t); \n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n+        println!(\"{:?} {:?}\", t1.1, t.1);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_type_contains_drop_need_migration();\n+    test5_drop_non_drop_aggregate_need_migration();\n+    test6_significant_insignificant_drop_aggregate_need_migration();\n+    test7_move_closures_non_copy_types_might_need_migration();\n+}"}, {"sha": "106b2933515156249b2946595722b10504d115d8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![deny(disjoint_capture_drop_reorder)]\n //~^ NOTE: the lint level is defined here\n \n@@ -22,8 +23,8 @@ fn test1_all_need_migration() {\n     let t2 = (Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1, t2));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2.0;\n@@ -40,8 +41,8 @@ fn test2_only_precise_paths_need_migration() {\n     let t2 = (Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2;\n@@ -56,8 +57,8 @@ fn test3_only_by_value_need_migration() {\n     let t = (Foo(0), Foo(0));\n     let t1 = (Foo(0), Foo(0));\n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n         println!(\"{:?}\", t1.1);\n     };\n@@ -73,8 +74,8 @@ fn test4_type_contains_drop_need_migration() {\n     let t = ConstainsDropField(Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n     };\n \n@@ -88,8 +89,8 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n     let t = (Foo(0), Foo(0), 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n     };\n \n@@ -98,13 +99,11 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n \n // Test migration analysis in case of Significant and Insignificant Drop aggregates.\n fn test6_significant_insignificant_drop_aggregate_need_migration() {\n-    struct S(i32, i32);\n-\n     let t = (Foo(0), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.1;\n     };\n \n@@ -118,8 +117,8 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n     let t1 = (Foo(0), Foo(0), Foo(0));\n \n     let c = move || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t1, t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{:?} {:?}\", t1.1, t.1);\n     };\n "}, {"sha": "ee29fe1306059377efa3d28209282d9fd2bb92c5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eed73c6e4d21e25cd553fe06a24e5200714bc0ab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=eed73c6e4d21e25cd553fe06a24e5200714bc0ab", "patch": "@@ -1,5 +1,5 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:24:13\n+  --> $DIR/significant_drop.rs:25:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -12,14 +12,22 @@ LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/significant_drop.rs:1:9\n+  --> $DIR/significant_drop.rs:2:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t, t1, t2));\n+help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1, &t2); \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2.0;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:42:13\n+  --> $DIR/significant_drop.rs:43:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -31,10 +39,18 @@ LL | |         let _t2 = t2;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t, t1));\n+help: add a dummy let to cause `t`, `t1` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1); \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:58:13\n+  --> $DIR/significant_drop.rs:59:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -45,10 +61,18 @@ LL | |         println!(\"{:?}\", t1.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         println!(\"{:?}\", t1.1);\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:75:13\n+  --> $DIR/significant_drop.rs:76:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -58,10 +82,17 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:90:13\n+  --> $DIR/significant_drop.rs:91:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -71,10 +102,17 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:105:13\n+  --> $DIR/significant_drop.rs:104:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -84,10 +122,17 @@ LL | |         let _t = t.1;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: add a dummy let to cause `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; \n+LL |\n+LL |\n+LL |         let _t = t.1;\n+LL |     };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:120:13\n+  --> $DIR/significant_drop.rs:119:13\n    |\n LL |       let c = move || {\n    |  _____________^\n@@ -97,7 +142,14 @@ LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t1, t));\n+help: add a dummy let to cause `t1`, `t` to be fully captured\n+   |\n+LL |     let c = move || { let _ = (&t1, &t); \n+LL |\n+LL |\n+LL |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL |     };\n+   |\n \n error: aborting due to 7 previous errors\n "}]}