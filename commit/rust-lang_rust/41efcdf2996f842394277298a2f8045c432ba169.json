{"sha": "41efcdf2996f842394277298a2f8045c432ba169", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZWZjZGYyOTk2Zjg0MjM5NDI3NzI5OGEyZjgwNDVjNDMyYmExNjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-20T19:21:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-08T17:55:10Z"}, "message": "Make all allocas named so we can see where they originate\nin the generated LLVM code.", "tree": {"sha": "d4bed9bc2eb8454713168c7f7a818f64b90e7daf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4bed9bc2eb8454713168c7f7a818f64b90e7daf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41efcdf2996f842394277298a2f8045c432ba169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41efcdf2996f842394277298a2f8045c432ba169", "html_url": "https://github.com/rust-lang/rust/commit/41efcdf2996f842394277298a2f8045c432ba169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41efcdf2996f842394277298a2f8045c432ba169/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90843b6f58a042cd1548555064a80034a608c02b", "url": "https://api.github.com/repos/rust-lang/rust/commits/90843b6f58a042cd1548555064a80034a608c02b", "html_url": "https://github.com/rust-lang/rust/commit/90843b6f58a042cd1548555064a80034a608c02b"}], "stats": {"total": 106, "additions": 60, "deletions": 46}, "files": [{"sha": "a58ee284046745b0ee0525db04056d88382608ef", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -268,7 +268,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n         }\n         lit(UnitLikeStructLit(pat_id)) => {\n             let struct_ty = ty::node_id_to_type(bcx.tcx(), pat_id);\n-            let datumblock = datum::scratch_datum(bcx, struct_ty, true);\n+            let datumblock = datum::scratch_datum(bcx, struct_ty, \"\", true);\n             return single_result(datumblock.to_result(bcx));\n         }\n         lit(ConstLit(lit_id)) => {\n@@ -927,7 +927,7 @@ pub fn extract_vec_elems(bcx: block,\n             ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n             ty::vstore_slice(ty::re_static)\n         );\n-        let scratch = scratch_datum(bcx, slice_ty, false);\n+        let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n         Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n@@ -1095,9 +1095,9 @@ pub fn compare_values(cx: block,\n \n     match ty::get(rhs_t).sty {\n         ty::ty_estr(ty::vstore_uniq) => {\n-            let scratch_lhs = alloca(cx, val_ty(lhs));\n+            let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n             Store(cx, lhs, scratch_lhs);\n-            let scratch_rhs = alloca(cx, val_ty(rhs));\n+            let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n             Store(cx, rhs, scratch_rhs);\n             let did = cx.tcx().lang_items.uniq_str_eq_fn();\n             let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n@@ -1636,12 +1636,12 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                let is_move = ccx.maps.moves_map.contains(&p_id);\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to());\n-                trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n+                trmode = TrByValue(alloca(bcx, llvariable_ty,\n+                                          bcx.ident(ident)));\n             }\n             ast::bind_by_ref(_) => {\n-                llmatch = alloca(bcx, llvariable_ty);\n+                llmatch = alloca(bcx, llvariable_ty, bcx.ident(ident));\n                 trmode = TrByRef;\n             }\n         };"}, {"sha": "8da7c1351c7b827eddae800fb73e178f534738ee", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -1012,7 +1012,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     match bcx.fcx.personality {\n       Some(addr) => Store(pad_bcx, llretval, addr),\n       None => {\n-        let addr = alloca(pad_bcx, val_ty(llretval));\n+        let addr = alloca(pad_bcx, val_ty(llretval), \"\");\n         bcx.fcx.personality = Some(addr);\n         Store(pad_bcx, llretval, addr);\n       }\n@@ -1056,15 +1056,15 @@ pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n-    let llptr = alloc_ty(bcx, t);\n+    let llptr = alloc_ty(bcx, t, \"\");\n     Store(bcx, v, llptr);\n     return llptr;\n }\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n-    let llptr = alloca(cx, val_ty(v));\n+    let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n@@ -1561,28 +1561,28 @@ pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n     Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n-pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n+pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n-    let val = alloca(bcx, ty);\n+    let val = alloca(bcx, ty, name);\n     return val;\n }\n \n-pub fn alloca(cx: block, ty: Type) -> ValueRef {\n-    alloca_maybe_zeroed(cx, ty, false)\n+pub fn alloca(cx: block, ty: Type, name: &str) -> ValueRef {\n+    alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n-    let p = Alloca(initcx, ty);\n+    let p = Alloca(initcx, ty, name);\n     if zero { memzero(initcx, p, ty); }\n     p\n }\n@@ -1623,7 +1623,8 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype)\n+            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype,\n+                   \"__make_return_pointer\")\n         }\n     }\n }"}, {"sha": "db5553ca939d79d67ed4e8d5f26c69eec9e63cb8", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -505,11 +505,17 @@ pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Alloca(cx: block, Ty: Type) -> ValueRef {\n+pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"alloca\");\n-        return llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname());\n+        if name.is_empty() {\n+            llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname())\n+        } else {\n+            str::as_c_str(\n+                name,\n+                |c| llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), c))\n+        }\n     }\n }\n "}, {"sha": "8d741369e1a25af5affae8f55cd323aeae60645a", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -130,10 +130,10 @@ impl FnType {\n             j = 1u;\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {\n-            let retptr = alloca(bcx, self.ret_ty.ty);\n+            let retptr = alloca(bcx, self.ret_ty.ty, \"\");\n             BitCast(bcx, retptr, ret_ty.ptr_to())\n         } else {\n-            alloca(bcx, ret_ty)\n+            alloca(bcx, ret_ty, \"\")\n         };\n \n         let mut i = 0u;"}, {"sha": "cf81def3abf7400b525be127a683b193c61730e4", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -600,7 +600,7 @@ pub fn trans_call_inner(in_cx: block,\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n         let ret_flag = if ret_in_loop {\n-            let flag = alloca(bcx, Type::bool());\n+            let flag = alloca(bcx, Type::bool(), \"__ret_flag\");\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n         } else {\n@@ -675,7 +675,7 @@ pub fn trans_call_inner(in_cx: block,\n                 unsafe {\n                     if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n                         if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                            let llscratchptr = alloc_ty(bcx, ret_ty);\n+                            let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n                             Store(bcx, llresult, llscratchptr);\n                             bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n                         } else {\n@@ -733,7 +733,7 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: Option<expr::Dest>)\n                     llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n                 }\n             } else {\n-                alloc_ty(bcx, retty)\n+                alloc_ty(bcx, retty, \"__trans_ret_slot\")\n             }\n         }\n     }\n@@ -823,7 +823,7 @@ pub fn trans_arg_expr(bcx: block,\n                         _\n                     }) => {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n-                    let scratch = alloc_ty(bcx, scratch_ty);\n+                    let scratch = alloc_ty(bcx, scratch_ty, \"__ret_flag\");\n                     let arg_ty = expr_ty(bcx, arg_expr);\n                     let sigil = ty::ty_closure_sigil(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n@@ -895,7 +895,8 @@ pub fn trans_arg_expr(bcx: block,\n                                 arg_datum.appropriate_mode(bcx.tcx()).is_by_ref() {\n                             debug!(\"by copy arg with type %s, storing to scratch\",\n                                    bcx.ty_to_str(arg_datum.ty));\n-                            let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+                            let scratch = scratch_datum(bcx, arg_datum.ty,\n+                                                        \"__arg\", false);\n \n                             arg_datum.store_to_datum(bcx,\n                                                      arg_expr.id,"}, {"sha": "5b0212cc05cc7ff2a722974bdf1dd5a6bea479e2", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -193,7 +193,7 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-            let llbox = alloc_ty(bcx, cbox_ty);\n+            let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n             nuke_ref_count(bcx, llbox);\n             rslt(bcx, llbox)\n         }"}, {"sha": "24648ada8935eeaa9c82e7966f3f4b45b8e3aa13", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -608,6 +608,10 @@ impl block_ {\n     pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n+    pub fn ident(&self, ident: ident) -> @str {\n+        token::ident_to_str(&ident)\n+    }\n+\n     pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }"}, {"sha": "ed0adbcff873c6271b3d4c920f039445b9a07ab1", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -173,19 +173,19 @@ pub fn immediate_rvalue_bcx(bcx: block,\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     /*!\n-     *\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n      * space will be zeroed when it is allocated; this is normally not\n      * necessary, but in the case of automatic rooting in match\n      * statements it is possible to have temporaries that may not get\n      * initialized if a certain arm is not taken, so we must zero\n-     * them. You must arrange any cleanups etc yourself! */\n+     * them. You must arrange any cleanups etc yourself!\n+     */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca_maybe_zeroed(bcx, llty, zero);\n+    let scratch = alloca_maybe_zeroed(bcx, llty, name, zero);\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n@@ -476,7 +476,7 @@ impl Datum {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n                     C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n-                    let slot = alloc_ty(bcx, self.ty);\n+                    let slot = alloc_ty(bcx, self.ty, \"\");\n                     Store(bcx, self.val, slot);\n                     slot\n                 }"}, {"sha": "2d5ac23b3b38b6fb513709d33f99322cc5655c2a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -274,7 +274,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                    ty::mt { ty: unit_ty, mutbl: ast::m_imm },\n                                    ty::vstore_slice(ty::re_static));\n \n-        let scratch = scratch_datum(bcx, slice_ty, false);\n+        let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n@@ -290,7 +290,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n-        let scratch = scratch_datum(bcx, closure_ty, false);\n+        let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n@@ -423,7 +423,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n                 return nil(bcx, ty);\n             } else {\n-                let scratch = scratch_datum(bcx, ty, false);\n+                let scratch = scratch_datum(bcx, ty, \"\", false);\n                 bcx = trans_rvalue_dps_unadjusted(\n                     bcx, expr, SaveIn(scratch.val));\n \n@@ -1687,7 +1687,7 @@ fn trans_assign_op(bcx: block,\n     // A user-defined operator method\n     if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n-        let scratch = scratch_datum(bcx, dst_datum.ty, false);\n+        let scratch = scratch_datum(bcx, dst_datum.ty, \"__assign_op\", false);\n         let bcx = trans_overloaded_op(bcx,\n                                       expr,\n                                       callee_id,"}, {"sha": "bdae222059894694ce15ad9aa41889a2e70af7fa", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -195,14 +195,15 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n         fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n-                                   lloutputtype));\n+                                   lloutputtype,\n+                                   \"\"));\n     }\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n \n     // Allocate the struct and write the arguments into it.\n-    let llargbundle = alloca(bcx, tys.bundle_ty);\n+    let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n \n     // Create call itself.\n@@ -732,7 +733,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n \n                 let llsrcval = get_param(decl, first_real_arg);\n                 let llsrcptr = if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    let llsrcptr = alloca(bcx, llintype);\n+                    let llsrcptr = alloca(bcx, llintype, \"__llsrcptr\");\n                     Store(bcx, llsrcval, llsrcptr);\n                     llsrcptr\n                 } else {"}, {"sha": "25e73fd640d43cb916c8ba4d90e6ef6bb185ebf9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -132,7 +132,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) |\n       ty::ty_opaque_closure_ptr(_) => {\n-        let vp = alloca(bcx, type_of(bcx.ccx(), t));\n+        let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n         Store(bcx, v, vp);\n         free_ty(bcx, vp, t)\n       }"}, {"sha": "a3b544dbc6195b7c18dde6364f4a2c774bf09303", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -57,7 +57,7 @@ impl Reflector {\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::re_static);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n-        let scratch = scratch_datum(bcx, str_ty, false);\n+        let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len() + 1);\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));"}, {"sha": "825320b9ff6369fcce554da3887db590da776108", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -332,7 +332,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n-                    let lldestval = scratch_datum(bcx, typ, false);\n+                    let lldestval = scratch_datum(bcx, typ, \"\", false);\n                     let bcx = callee::trans_lang_call(\n                         bcx,\n                         bcx.tcx().lang_items.strdup_uniq_fn(),\n@@ -454,7 +454,7 @@ pub fn write_content(bcx: block,\n \n                     let loop_counter = {\n                         // i = 0\n-                        let i = alloca(loop_bcx, bcx.ccx().int_type);\n+                        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n                         Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n \n                         Br(loop_bcx, cond_bcx.llbb);"}, {"sha": "1804a7334f23fb4d37475e763ce3be7c76395a9d", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41efcdf2996f842394277298a2f8045c432ba169/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=41efcdf2996f842394277298a2f8045c432ba169", "patch": "@@ -120,7 +120,7 @@ fn root(datum: &Datum,\n     // First, root the datum. Note that we must zero this value,\n     // because sometimes we root on one path but not another.\n     // See e.g. #4904.\n-    let scratch = scratch_datum(bcx, datum.ty, true);\n+    let scratch = scratch_datum(bcx, datum.ty, \"__write_guard\", true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n     add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n@@ -135,7 +135,8 @@ fn root(datum: &Datum,\n             // scratch.val will be NULL should the cleanup get\n             // called without the freezing actually occurring, and\n             // return_to_mut checks for this condition.\n-            let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n+            let scratch_bits = scratch_datum(bcx, ty::mk_uint(),\n+                                             \"__write_guard_bits\", false);\n \n             let freeze_did = match freeze_kind {\n                 DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),"}]}