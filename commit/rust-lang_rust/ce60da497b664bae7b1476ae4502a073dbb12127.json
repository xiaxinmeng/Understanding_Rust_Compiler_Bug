{"sha": "ce60da497b664bae7b1476ae4502a073dbb12127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNjBkYTQ5N2I2NjRiYWU3YjE0NzZhZTQ1MDJhMDczZGJiMTIxMjc=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-09-29T08:45:47Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-09-29T09:06:53Z"}, "message": "Fix `vec![x; n]` with null raw fat pointer zeroing the pointer metadata\n\nhttps://github.com/rust-lang/rust/pull/49496 introduced specialization based on:\n\n```\nunsafe impl<T: ?Sized> IsZero for *mut T {\n    fn is_zero(&self) -> bool {\n        (*self).is_null()\n    }\n}\n```\n\n\u2026 to call `RawVec::with_capacity_zeroed` for creating `Vec<*mut T>`,\nwhich is incorrect for fat pointers\nsince `<*mut T>::is_null` only looks at the data component.\nThat is, a fat pointer can be \u201cnull\u201d without being made entirely of zero bits.\n\nThis commit fixes it by removing the `?Sized` bound on this impl\n(and the corresponding `*const T` one).\nThis regresses `vec![x; n]` with `x` a null raw slice of length zero,\nbut that seems exceptionally uncommon.\n(Vtable pointers are never null, so raw trait objects would not take\nthe fast path anyway.\n\nAn alternative to keep the `?Sized` bound\n(or even generalize to `impl<U: Copy> IsZero for U`)\nwould be to cast to `&[u8]` of length `size_of::<U>()`,\nbut the optimizer seems not to be able to propagate alignment information\nand sticks with comparing one byte at a time:\n\nhttps://rust.godbolt.org/z/xQFkwL\n\n----\n\nWithout the library change, the new test fails as follows:\n\n```\n---- vec::vec_macro_repeating_null_raw_fat_pointer stdout ----\n[src/liballoc/tests/vec.rs:1301] ptr_metadata(raw_dyn) = 0x00005596ef95f9a8\n[src/liballoc/tests/vec.rs:1306] ptr_metadata(vec[0]) = 0x0000000000000000\nthread 'vec::vec_macro_repeating_null_raw_fat_pointer' panicked at 'assertion failed: vec[0] == null_raw_dyn', src/liballoc/tests/vec.rs:1307:5\n```", "tree": {"sha": "9ab0676aa271de9733bff1c4f02ff44d1eb999b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ab0676aa271de9733bff1c4f02ff44d1eb999b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce60da497b664bae7b1476ae4502a073dbb12127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce60da497b664bae7b1476ae4502a073dbb12127", "html_url": "https://github.com/rust-lang/rust/commit/ce60da497b664bae7b1476ae4502a073dbb12127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce60da497b664bae7b1476ae4502a073dbb12127/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bbab7d99dde8620604fb265706dc8bff20345a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbab7d99dde8620604fb265706dc8bff20345a7", "html_url": "https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7"}], "stats": {"total": 52, "additions": 50, "deletions": 2}, "files": [{"sha": "98d013dfa2b57616889bb8b3150111077fe90fcf", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ce60da497b664bae7b1476ae4502a073dbb12127/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce60da497b664bae7b1476ae4502a073dbb12127/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=ce60da497b664bae7b1476ae4502a073dbb12127", "patch": "@@ -1281,3 +1281,51 @@ fn test_stable_push_pop() {\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n }\n+\n+// https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:\n+//\n+// ```\n+// unsafe impl<T: ?Sized> IsZero for *mut T {\n+//     fn is_zero(&self) -> bool {\n+//         (*self).is_null()\n+//     }\n+// }\n+// ```\n+//\n+// \u2026 to call `RawVec::with_capacity_zeroed` for creating `Vec<*mut T>`,\n+// which is incorrect for fat pointers since `<*mut T>::is_null` only looks at the data component.\n+// That is, a fat pointer can be \u201cnull\u201d without being made entirely of zero bits.\n+#[test]\n+fn vec_macro_repeating_null_raw_fat_pointer() {\n+    let raw_dyn = &mut (|| ()) as &mut dyn Fn() as *mut dyn Fn();\n+    let vtable = dbg!(ptr_metadata(raw_dyn));\n+    let null_raw_dyn = ptr_from_raw_parts(std::ptr::null_mut(), vtable);\n+    assert!(null_raw_dyn.is_null());\n+\n+    let vec = vec![null_raw_dyn; 1];\n+    dbg!(ptr_metadata(vec[0]));\n+    assert!(vec[0] == null_raw_dyn);\n+\n+    // Polyfill for https://github.com/rust-lang/rfcs/pull/2580\n+\n+    fn ptr_metadata(ptr: *mut dyn Fn()) -> *mut () {\n+        unsafe {\n+            std::mem::transmute::<*mut dyn Fn(), DynRepr>(ptr).vtable\n+        }\n+    }\n+\n+    fn ptr_from_raw_parts(data: *mut (), vtable: *mut()) -> *mut dyn Fn() {\n+        unsafe {\n+            std::mem::transmute::<DynRepr, *mut dyn Fn()>(DynRepr {\n+                data,\n+                vtable\n+            })\n+        }\n+    }\n+\n+    #[repr(C)]\n+    struct DynRepr {\n+        data: *mut (),\n+        vtable: *mut (),\n+    }\n+}"}, {"sha": "f6f59ae408272a31223490570a7052961543dd45", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce60da497b664bae7b1476ae4502a073dbb12127/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce60da497b664bae7b1476ae4502a073dbb12127/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=ce60da497b664bae7b1476ae4502a073dbb12127", "patch": "@@ -1734,14 +1734,14 @@ impl_is_zero!(char, |x| x == '\\0');\n impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n \n-unsafe impl<T: ?Sized> IsZero for *const T {\n+unsafe impl<T> IsZero for *const T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for *mut T {\n+unsafe impl<T> IsZero for *mut T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()"}]}