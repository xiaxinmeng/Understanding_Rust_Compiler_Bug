{"sha": "ba2b79c757d45a2892b24953c8411cb40c2a789b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMmI3OWM3NTdkNDVhMjg5MmIyNDk1M2M4NDExY2I0MGMyYTc4OWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:27Z"}, "message": "rollup merge of #20197: pczarn/ring_buf-collections-reform\n\nPart of collections reform part 1 and 2, #18424 and #19986\n\n* shrink_to_fit\n* swap_back_remove\n* swap_front_remove\n* truncate\n* resize", "tree": {"sha": "b4569c1cd8dcd92d99bd0bf68c89cbc3cc0277a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4569c1cd8dcd92d99bd0bf68c89cbc3cc0277a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba2b79c757d45a2892b24953c8411cb40c2a789b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2b79c757d45a2892b24953c8411cb40c2a789b", "html_url": "https://github.com/rust-lang/rust/commit/ba2b79c757d45a2892b24953c8411cb40c2a789b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba2b79c757d45a2892b24953c8411cb40c2a789b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f4f79cbd7b53cfcef50f1262ea24422e37600e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f4f79cbd7b53cfcef50f1262ea24422e37600e9", "html_url": "https://github.com/rust-lang/rust/commit/7f4f79cbd7b53cfcef50f1262ea24422e37600e9"}, {"sha": "156a1c31346634c16beaf827d4d6efdfef6e2b36", "url": "https://api.github.com/repos/rust-lang/rust/commits/156a1c31346634c16beaf827d4d6efdfef6e2b36", "html_url": "https://github.com/rust-lang/rust/commit/156a1c31346634c16beaf827d4d6efdfef6e2b36"}], "stats": {"total": 329, "additions": 307, "deletions": 22}, "files": [{"sha": "a2afc98e2237ade119616e8fe502760356262267", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 307, "deletions": 22, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/ba2b79c757d45a2892b24953c8411cb40c2a789b/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2b79c757d45a2892b24953c8411cb40c2a789b/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=ba2b79c757d45a2892b24953c8411cb40c2a789b", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{self, FromIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n use core::kinds::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n@@ -30,11 +30,8 @@ use std::cmp;\n \n use alloc::heap;\n \n-static INITIAL_CAPACITY: uint = 8u; // 2^3\n-static MINIMUM_CAPACITY: uint = 2u;\n-\n-// FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n-// be scrapped anyway. Defer to rewrite?\n+static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n+static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n #[stable]\n@@ -127,7 +124,20 @@ impl<T> RingBuf<T> {\n                       self.cap);\n         ptr::copy_memory(\n             self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int) as *const T,\n+            self.ptr.offset(src as int),\n+            len);\n+    }\n+\n+    /// Copies a contiguous block of memory len long from src to dst\n+    #[inline]\n+    unsafe fn copy_nonoverlapping(&self, dst: uint, src: uint, len: uint) {\n+        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        ptr::copy_nonoverlapping_memory(\n+            self.ptr.offset(dst as int),\n+            self.ptr.offset(src as int),\n             len);\n     }\n }\n@@ -143,7 +153,8 @@ impl<T> RingBuf<T> {\n     #[stable]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n-        let cap = cmp::max(n + 1, MINIMUM_CAPACITY).next_power_of_two();\n+        let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        assert!(cap > n, \"capacity overflow\");\n         let size = cap.checked_mul(mem::size_of::<T>())\n                       .expect(\"capacity overflow\");\n \n@@ -346,31 +357,134 @@ impl<T> RingBuf<T> {\n                 // Nop\n             } else if self.head < oldcap - self.tail { // B\n                 unsafe {\n-                    ptr::copy_nonoverlapping_memory(\n-                        self.ptr.offset(oldcap as int),\n-                        self.ptr as *const T,\n-                        self.head\n-                    );\n+                    self.copy_nonoverlapping(oldcap, 0, self.head);\n                 }\n                 self.head += oldcap;\n                 debug_assert!(self.head > self.tail);\n             } else { // C\n+                let new_tail = count - (oldcap - self.tail);\n                 unsafe {\n-                    ptr::copy_nonoverlapping_memory(\n-                        self.ptr.offset((count - (oldcap - self.tail)) as int),\n-                        self.ptr.offset(self.tail as int) as *const T,\n-                        oldcap - self.tail\n-                    );\n+                    self.copy_nonoverlapping(new_tail, self.tail, oldcap - self.tail);\n                 }\n-                self.tail = count - (oldcap - self.tail);\n+                self.tail = new_tail;\n+                debug_assert!(self.head < self.tail);\n+            }\n+            debug_assert!(self.head < self.cap);\n+            debug_assert!(self.tail < self.cap);\n+            debug_assert!(self.cap.count_ones() == 1);\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the ringbuf as much as possible.\n+    ///\n+    /// It will drop down as close as possible to the length but the allocator may still inform the\n+    /// ringbuf that there is space for a few more elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::with_capacity(15);\n+    /// buf.extend(range(0u, 4));\n+    /// assert_eq!(buf.capacity(), 15);\n+    /// buf.shrink_to_fit();\n+    /// assert!(buf.capacity() >= 4);\n+    /// ```\n+    pub fn shrink_to_fit(&mut self) {\n+        // +1 since the ringbuffer always leaves one space empty\n+        // len + 1 can't overflow for an existing, well-formed ringbuf.\n+        let target_cap = cmp::max(self.len() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        if target_cap < self.cap {\n+            // There are three cases of interest:\n+            //   All elements are out of desired bounds\n+            //   Elements are contiguous, and head is out of desired bounds\n+            //   Elements are discontiguous, and tail is out of desired bounds\n+            //\n+            // At all other times, element positions are unaffected.\n+            //\n+            // Indicates that elements at the head should be moved.\n+            let head_outside = self.head == 0 || self.head >= target_cap;\n+            // Move elements from out of desired bounds (positions after target_cap)\n+            if self.tail >= target_cap && head_outside {\n+                //                    T             H\n+                //   [. . . . . . . . o o o o o o o . ]\n+                //    T             H\n+                //   [o o o o o o o . ]\n+                unsafe {\n+                    self.copy_nonoverlapping(0, self.tail, self.len());\n+                }\n+                self.head = self.len();\n+                self.tail = 0;\n+            } else if self.tail != 0 && self.tail < target_cap && head_outside {\n+                //          T             H\n+                //   [. . . o o o o o o o . . . . . . ]\n+                //        H T\n+                //   [o o . o o o o o ]\n+                let len = self.wrap_index(self.head - target_cap);\n+                unsafe {\n+                    self.copy_nonoverlapping(0, target_cap, len);\n+                }\n+                self.head = len;\n+                debug_assert!(self.head < self.tail);\n+            } else if self.tail >= target_cap {\n+                //              H                 T\n+                //   [o o o o o . . . . . . . . . o o ]\n+                //              H T\n+                //   [o o o o o . o o ]\n+                debug_assert!(self.wrap_index(self.head - 1) < target_cap);\n+                let len = self.cap - self.tail;\n+                let new_tail = target_cap - len;\n+                unsafe {\n+                    self.copy_nonoverlapping(new_tail, self.tail, len);\n+                }\n+                self.tail = new_tail;\n                 debug_assert!(self.head < self.tail);\n             }\n+\n+            if mem::size_of::<T>() != 0 {\n+                let old = self.cap * mem::size_of::<T>();\n+                let new_size = target_cap * mem::size_of::<T>();\n+                unsafe {\n+                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n+                                                old,\n+                                                new_size,\n+                                                mem::min_align_of::<T>()) as *mut T;\n+                    if self.ptr.is_null() { ::alloc::oom() }\n+                }\n+            }\n+            self.cap = target_cap;\n             debug_assert!(self.head < self.cap);\n             debug_assert!(self.tail < self.cap);\n             debug_assert!(self.cap.count_ones() == 1);\n         }\n     }\n \n+    /// Shorten a ringbuf, dropping excess elements from the back.\n+    ///\n+    /// If `len` is greater than the ringbuf's current length, this has no\n+    /// effect.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(15);\n+    /// buf.truncate(1);\n+    /// assert_eq!(buf.len(), 1);\n+    /// assert_eq!(Some(&5), buf.get(0));\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn truncate(&mut self, len: uint) {\n+        for _ in range(len, self.len()) {\n+            self.pop_back();\n+        }\n+    }\n+\n     /// Returns a front-to-back iterator.\n     ///\n     /// # Examples\n@@ -735,6 +849,70 @@ impl<T> RingBuf<T> {\n         self.tail <= self.head\n     }\n \n+    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the last\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// Returns `None` if `index` is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// assert_eq!(buf.swap_back_remove(0), None);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(99);\n+    /// buf.push_back(15);\n+    /// buf.push_back(20);\n+    /// buf.push_back(10);\n+    /// assert_eq!(buf.swap_back_remove(1), Some(99));\n+    /// ```\n+    #[unstable = \"the naming of this function may be altered\"]\n+    pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n+        let length = self.len();\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n+        } else if index >= length {\n+            return None;\n+        }\n+        self.pop_back()\n+    }\n+\n+    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the first\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n+    ///\n+    /// Returns `None` if `index` is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// assert_eq!(buf.swap_front_remove(0), None);\n+    /// buf.push_back(15i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n+    /// buf.push_back(99);\n+    /// buf.push_back(20i);\n+    /// assert_eq!(buf.swap_front_remove(3), Some(99));\n+    /// ```\n+    #[unstable = \"the naming of this function may be altered\"]\n+    pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n+        let length = self.len();\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n+        } else if index >= length {\n+            return None;\n+        }\n+        self.pop_front()\n+    }\n+\n     /// Inserts an element at position `i` within the ringbuf. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n@@ -743,7 +921,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// Panics if `i` is greater than ringbuf's length\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```rust\n     /// use std::collections::RingBuf;\n     ///\n@@ -945,7 +1123,7 @@ impl<T> RingBuf<T> {\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `i` is out of bounds.\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```rust\n     /// use std::collections::RingBuf;\n     ///\n@@ -990,7 +1168,7 @@ impl<T> RingBuf<T> {\n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n \n-        let contiguous = self.tail <= self.head;\n+        let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) => unsafe {\n@@ -1105,6 +1283,37 @@ impl<T> RingBuf<T> {\n     }\n }\n \n+impl<T: Clone> RingBuf<T> {\n+    /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n+    /// either by removing excess elements or by appending copies of a value to the back.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(15);\n+    /// buf.resize(2, 0);\n+    /// buf.resize(6, 20);\n+    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(buf.iter()) {\n+    ///     assert_eq!(a, b);\n+    /// }\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len))\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n+}\n+\n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n fn wrap_index(index: uint, size: uint) -> uint {\n@@ -2270,6 +2479,50 @@ mod tests {\n         assert_eq!(ring.get_mut(2), None);\n     }\n \n+    #[test]\n+    fn test_swap_front_back_remove() {\n+        fn test(back: bool) {\n+            // This test checks that every single combination of tail position and length is tested.\n+            // Capacity 15 should be large enough to cover every case.\n+            let mut tester = RingBuf::with_capacity(15);\n+            let usable_cap = tester.capacity();\n+            let final_len = usable_cap / 2;\n+\n+            for len in range(0, final_len) {\n+                let expected = if back {\n+                    range(0, len).collect()\n+                } else {\n+                    range(0, len).rev().collect()\n+                };\n+                for tail_pos in range(0, usable_cap) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    if back {\n+                        for i in range(0, len * 2) {\n+                            tester.push_front(i);\n+                        }\n+                        for i in range(0, len) {\n+                            assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n+                        }\n+                    } else {\n+                        for i in range(0, len * 2) {\n+                            tester.push_back(i);\n+                        }\n+                        for i in range(0, len) {\n+                            let idx = tester.len() - 1 - i;\n+                            assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n+                        }\n+                    }\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+        test(true);\n+        test(false);\n+    }\n+\n     #[test]\n     fn test_insert() {\n         // This test checks that every single combination of tail position, length, and\n@@ -2341,6 +2594,38 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_shrink_to_fit() {\n+        // This test checks that every single combination of head and tail position,\n+        // is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+        tester.reserve(63);\n+        let max_cap = tester.capacity();\n+\n+        for len in range(0, cap + 1) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, max_cap + 1) {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                tester.reserve(63);\n+                for i in range(0, len) {\n+                    tester.push_back(i);\n+                }\n+                tester.shrink_to_fit();\n+                assert!(tester.capacity() <= cap);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_front() {\n         let mut ring = RingBuf::new();"}]}