{"sha": "253dfc338775570a76d6c68bf349b2026e700797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1M2RmYzMzODc3NTU3MGE3NmQ2YzY4YmYzNDliMjAyNmU3MDA3OTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T00:01:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T00:36:24Z"}, "message": "rustc: Implement pattern matching for structs", "tree": {"sha": "016895b995fc0bce525eae43c83edecae9e9e750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/016895b995fc0bce525eae43c83edecae9e9e750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/253dfc338775570a76d6c68bf349b2026e700797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/253dfc338775570a76d6c68bf349b2026e700797", "html_url": "https://github.com/rust-lang/rust/commit/253dfc338775570a76d6c68bf349b2026e700797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/253dfc338775570a76d6c68bf349b2026e700797/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cb3a94bfbafc6548b2dde42beddc903a97c9eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cb3a94bfbafc6548b2dde42beddc903a97c9eb2", "html_url": "https://github.com/rust-lang/rust/commit/5cb3a94bfbafc6548b2dde42beddc903a97c9eb2"}], "stats": {"total": 545, "additions": 445, "deletions": 100}, "files": [{"sha": "a325b8c634a5882719ce955d4bf56e53acae0248", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -166,6 +166,7 @@ enum pat_ {\n     pat_enum(@path, option<~[@pat]>), // \"none\" means a * pattern where\n                                   // we don't bind the fields to names\n     pat_rec(~[field_pat], bool),\n+    pat_struct(@path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),\n     pat_uniq(@pat),"}, {"sha": "45556e941d49c32d63a5e7a243ef0424d7c804d3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -602,7 +602,8 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n       pat_ident(_, pth, some(p)) => walk_pat(p, it),\n-      pat_rec(fields, _) => for fields.each |f| { walk_pat(f.pat, it) }\n+      pat_rec(fields, _) | pat_struct(_, fields, _) =>\n+        for fields.each |f| { walk_pat(f.pat, it) }\n       pat_enum(_, some(s)) | pat_tup(s) => for s.each |p| {\n         walk_pat(p, it)\n       }"}, {"sha": "57cebbf044af9081aff3c4df5d6b2e116b4df738", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -354,6 +354,16 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n+          pat_struct(pth, fields, etc) => {\n+            let pth_ = fld.fold_path(pth);\n+            let mut fs = ~[];\n+            for fields.each |f| {\n+                vec::push(fs,\n+                          {ident: /* FIXME (#2543) */ copy f.ident,\n+                           pat: fld.fold_pat(f.pat)});\n+            }\n+            pat_struct(pth_, fs, etc)\n+          }\n           pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(x))),\n           pat_box(inner) => pat_box(fld.fold_pat(inner)),\n           pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),"}, {"sha": "42bdab193bea69c478154b471fefef274a06d211", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 128, "deletions": 62, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -42,14 +42,14 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              mac_ellipsis, mac_invoc, mac_invoc_tt, mac_var, matcher,\n              match_nonterminal, match_seq, match_tok, method, mode, mt, mul,\n              mutability, neg, noreturn, not, pat, pat_box, pat_enum,\n-             pat_ident, pat_lit, pat_range, pat_rec, pat_tup, pat_uniq,\n-             pat_wild, path, private, proto, proto_bare, proto_block,\n-             proto_box, proto_uniq, provided, public, pure_fn, purity,\n-             re_anon, re_named, region, rem, required, ret_style, return_val,\n-             self_ty, shl, shr, stmt, stmt_decl, stmt_expr, stmt_semi,\n-             subtract, sty_box, sty_by_ref, sty_region, sty_uniq, sty_value,\n-             token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok,\n-             tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n+             pat_ident, pat_lit, pat_range, pat_rec, pat_struct, pat_tup,\n+             pat_uniq, pat_wild, path, private, proto, proto_bare,\n+             proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n+             purity, re_anon, re_named, region, rem, required, ret_style,\n+             return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n+             stmt_semi, subtract, sty_box, sty_by_ref, sty_region, sty_uniq,\n+             sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n+             tt_tok, tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n              ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_path, ty_ptr,\n              ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec,\n              ty_fixed_length, unchecked_blk, uniq, unsafe_blk, unsafe_fn,\n@@ -1640,6 +1640,52 @@ class parser {\n         };\n     }\n \n+    fn parse_pat_fields(refutable: bool) -> (~[ast::field_pat], bool) {\n+        let mut fields = ~[];\n+        let mut etc = false;\n+        let mut first = true;\n+        while self.token != token::RBRACE {\n+            if first { first = false; }\n+            else { self.expect(token::COMMA); }\n+\n+            if self.token == token::UNDERSCORE {\n+                self.bump();\n+                if self.token != token::RBRACE {\n+                    self.fatal(~\"expected `}`, found `\" +\n+                               token_to_str(self.reader, self.token) +\n+                               ~\"`\");\n+                }\n+                etc = true;\n+                break;\n+            }\n+\n+            let lo1 = self.last_span.lo;\n+            let fieldname = if self.look_ahead(1u) == token::COLON {\n+                self.parse_ident()\n+            } else {\n+                self.parse_value_ident()\n+            };\n+            let hi1 = self.last_span.lo;\n+            let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n+                                                    fieldname);\n+            let mut subpat;\n+            if self.token == token::COLON {\n+                self.bump();\n+                subpat = self.parse_pat(refutable);\n+            } else {\n+                subpat = @{\n+                    id: self.get_id(),\n+                    node: pat_ident(bind_by_implicit_ref,\n+                                    fieldpath,\n+                                    none),\n+                    span: self.last_span\n+                };\n+            }\n+            vec::push(fields, {ident: fieldname, pat: subpat});\n+        }\n+        return (fields, etc);\n+    }\n+\n     fn parse_pat(refutable: bool) -> @pat {\n         maybe_whole!{self, nt_pat};\n \n@@ -1685,48 +1731,7 @@ class parser {\n           }\n           token::LBRACE => {\n             self.bump();\n-            let mut fields = ~[];\n-            let mut etc = false;\n-            let mut first = true;\n-            while self.token != token::RBRACE {\n-                if first { first = false; }\n-                else { self.expect(token::COMMA); }\n-\n-                if self.token == token::UNDERSCORE {\n-                    self.bump();\n-                    if self.token != token::RBRACE {\n-                        self.fatal(~\"expected `}`, found `\" +\n-                                   token_to_str(self.reader, self.token) +\n-                                   ~\"`\");\n-                    }\n-                    etc = true;\n-                    break;\n-                }\n-\n-                let lo1 = self.last_span.lo;\n-                let fieldname = if self.look_ahead(1u) == token::COLON {\n-                    self.parse_ident()\n-                } else {\n-                    self.parse_value_ident()\n-                };\n-                let hi1 = self.last_span.lo;\n-                let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n-                                                        fieldname);\n-                let mut subpat;\n-                if self.token == token::COLON {\n-                    self.bump();\n-                    subpat = self.parse_pat(refutable);\n-                } else {\n-                    subpat = @{\n-                        id: self.get_id(),\n-                        node: pat_ident(bind_by_implicit_ref,\n-                                        fieldpath,\n-                                        none),\n-                        span: mk_sp(lo, hi)\n-                    };\n-                }\n-                vec::push(fields, {ident: fieldname, pat: subpat});\n-            }\n+            let (fields, etc) = self.parse_pat_fields(refutable);\n             hi = self.span.hi;\n             self.bump();\n             pat = pat_rec(fields, etc);\n@@ -1771,21 +1776,82 @@ class parser {\n             } else if !is_plain_ident(self.token) {\n                 pat = self.parse_enum_variant(refutable);\n             } else {\n-                // this is a plain identifier, like `x` or `x(...)`\n+                let binding_mode;\n+                if self.eat_keyword(~\"copy\") {\n+                    binding_mode = bind_by_value;\n+                } else if refutable {\n+                    // XXX: Should be bind_by_value, but that's not\n+                    // backward compatible.\n+                    binding_mode = bind_by_implicit_ref;\n+                } else {\n+                    binding_mode = bind_by_value;\n+                }\n+\n+                let cannot_be_enum_or_struct;\n                 match self.look_ahead(1) {\n-                  token::LPAREN | token::LBRACKET | token::LT => {\n-                    pat = self.parse_enum_variant(refutable);\n-                  }\n-                  _ => {\n-                    let binding_mode = if refutable {\n-                        // XXX: Should be bind_by_value, but that's not\n-                        // backward compatible.\n-                        bind_by_implicit_ref\n+                    token::LPAREN | token::LBRACKET | token::LT |\n+                    token::LBRACE =>\n+                        cannot_be_enum_or_struct = false,\n+                    _ =>\n+                        cannot_be_enum_or_struct = true\n+                }\n+\n+                if is_plain_ident(self.token) && cannot_be_enum_or_struct {\n+                    let name = self.parse_value_path();\n+                    let sub;\n+                    if self.eat(token::AT) {\n+                        sub = some(self.parse_pat(refutable));\n                     } else {\n-                        bind_by_value\n+                        sub = none;\n                     };\n-                    pat = self.parse_pat_ident(refutable, binding_mode);\n-                  }\n+                    pat = pat_ident(binding_mode, name, sub);\n+                } else {\n+                    let enum_path = self.parse_path_with_tps(true);\n+                    match self.token {\n+                        token::LBRACE => {\n+                            self.bump();\n+                            let (fields, etc) =\n+                                self.parse_pat_fields(refutable);\n+                            self.bump();\n+                            pat = pat_struct(enum_path, fields, etc);\n+                        }\n+                        _ => {\n+                            let mut args: ~[@pat] = ~[];\n+                            let mut star_pat = false;\n+                            match self.token {\n+                              token::LPAREN => match self.look_ahead(1u) {\n+                                token::BINOP(token::STAR) => {\n+                                    // This is a \"top constructor only\" pat\n+                                      self.bump(); self.bump();\n+                                      star_pat = true;\n+                                      self.expect(token::RPAREN);\n+                                  }\n+                                _ => {\n+                                    args = self.parse_unspanned_seq(\n+                                        token::LPAREN, token::RPAREN,\n+                                        seq_sep_trailing_disallowed\n+                                            (token::COMMA),\n+                                        |p| p.parse_pat(refutable));\n+                                  }\n+                              }\n+                              _ => ()\n+                            }\n+                            // at this point, we're not sure whether it's a\n+                            // enum or a bind\n+                            if star_pat {\n+                                pat = pat_enum(enum_path, none);\n+                            }\n+                            else if vec::is_empty(args) &&\n+                                vec::len(enum_path.idents) == 1u {\n+                                pat = pat_ident(binding_mode,\n+                                                enum_path,\n+                                                none);\n+                            }\n+                            else {\n+                                pat = pat_enum(enum_path, some(args));\n+                            }\n+                        }\n+                    }\n                 }\n             }\n             hi = self.span.hi;"}, {"sha": "3fd30eb30a90599135e92ab4ce602023714fe266", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -1375,6 +1375,24 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         }\n         word(s.s, ~\"}\");\n       }\n+      ast::pat_struct(path, fields, etc) => {\n+        print_path(s, path, true);\n+        word(s.s, ~\"{\");\n+        fn print_field(s: ps, f: ast::field_pat) {\n+            cbox(s, indent_unit);\n+            word(s.s, *f.ident);\n+            word_space(s, ~\":\");\n+            print_pat(s, f.pat);\n+            end(s);\n+        }\n+        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n+        commasep_cmnt(s, consistent, fields, print_field, get_span);\n+        if etc {\n+            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n+            word(s.s, ~\"_\");\n+        }\n+        word(s.s, ~\"}\");\n+      }\n       ast::pat_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, print_pat);"}, {"sha": "c988c89f8c2a445387c6f535c73627e436959db3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -222,6 +222,12 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n       pat_rec(fields, _) => for fields.each |f| {\n         v.visit_pat(f.pat, e, v)\n       }\n+      pat_struct(path, fields, _) => {\n+        visit_path(path, e, v);\n+        for fields.each |f| {\n+            v.visit_pat(f.pat, e, v);\n+        }\n+      }\n       pat_tup(elts) => for elts.each |elt| {\n         v.visit_pat(elt, e, v)\n       }"}, {"sha": "79696becfebd7b36d4b8421f37986eee288b2a5b", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -513,6 +513,14 @@ impl methods for gather_loan_ctxt {\n             }\n           }\n \n+          ast::pat_struct(_, field_pats, _) => {\n+            // {f1: p1, ..., fN: pN}\n+            for field_pats.each |fp| {\n+                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n+                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n+            }\n+          }\n+\n           ast::pat_tup(subpats) => {\n             // (p1, ..., pN)\n             for subpats.each |subpat| {"}, {"sha": "6b135e2e256a6a62e1cf3db4ab99052c58dad3ad", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -212,7 +212,8 @@ fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n       pat_range(lo, hi) => {\n         some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n       }\n-      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) => {\n+      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) |\n+      pat_struct(*) => {\n         some(single)\n       }\n     }\n@@ -234,7 +235,8 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n \n fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n     match ty::get(left_ty).struct {\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) => {\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) |\n+      ty::ty_class(*) => {\n         for m.each |r| {\n             if !is_wild(tcx, r[0]) { return none; }\n         }\n@@ -286,6 +288,7 @@ fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n           some(v) => v.args.len()\n         }\n       }\n+      ty::ty_class(cid, _) => ty::lookup_class_fields(tcx, cid).len(),\n       _ => 0u\n     }\n }\n@@ -327,7 +330,29 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         };\n         let args = vec::map(ty_flds, |ty_f| {\n             match vec::find(flds, |f| f.ident == ty_f.ident ) {\n-              some(f) => f.pat, _ => wild()\n+              some(f) => f.pat,\n+              _ => wild()\n+            }\n+        });\n+        some(vec::append(args, vec::tail(r)))\n+      }\n+      pat_struct(_, flds, _) => {\n+        // Grab the class data that we care about.\n+        let class_fields, class_id;\n+        match ty::get(left_ty).struct {\n+            ty::ty_class(cid, substs) => {\n+                class_id = cid;\n+                class_fields = ty::lookup_class_fields(tcx, class_id);\n+            }\n+            _ => {\n+                tcx.sess.span_bug(r0.span, ~\"struct pattern didn't resolve \\\n+                                             to a struct\");\n+            }\n+        }\n+        let args = vec::map(class_fields, |class_field| {\n+            match vec::find(flds, |f| f.ident == class_field.ident ) {\n+              some(f) => f.pat,\n+              _ => wild()\n             }\n         });\n         some(vec::append(args, vec::tail(r)))\n@@ -377,7 +402,9 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     match tcx.def_map.find(pat.id) {\n       some(def_variant(enum_id, var_id)) => {\n-        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u { return true; }\n+        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u {\n+            return true;\n+        }\n       }\n       _ => ()\n     }\n@@ -394,6 +421,12 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n         }\n         false\n       }\n+      pat_struct(_, fields, _) => {\n+        for fields.each |it| {\n+            if is_refutable(tcx, it.pat) { return true; }\n+        }\n+        false\n+      }\n       pat_tup(elts) => {\n         for elts.each |elt| { if is_refutable(tcx, elt) { return true; } }\n         false"}, {"sha": "cf8d1f348c922ea200b337bbed701c9d8f7cba6c", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -15,8 +15,8 @@ import syntax::ast::{bound_trait, binding_mode,\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_local, def_mod};\n-import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param,\n-                     def_typaram_binder};\n+import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n+import syntax::ast::{def_typaram_binder};\n import syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n import syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_path};\n@@ -30,13 +30,13 @@ import syntax::ast::{instance_var, item, item_class, item_const, item_enum};\n import syntax::ast::{item_fn, item_mac, item_foreign_mod, item_impl};\n import syntax::ast::{item_mod, item_trait, item_ty, le, local, local_crate};\n import syntax::ast::{lt, method, mul, ne, neg, node_id, pat, pat_enum};\n-import syntax::ast::{pat_ident, path, prim_ty, pat_box, pat_uniq, pat_lit};\n-import syntax::ast::{pat_range, pat_rec, pat_tup, pat_wild, provided};\n-import syntax::ast::{required, rem, self_ty_, shl, stmt_decl, subtract, ty};\n-import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n-import syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param};\n-import syntax::ast::{ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8};\n-import syntax::ast::{ty_uint, variant, view_item, view_item_export};\n+import syntax::ast::{pat_ident, pat_struct, path, prim_ty, pat_box, pat_uniq};\n+import syntax::ast::{pat_lit, pat_range, pat_rec, pat_tup, pat_wild};\n+import syntax::ast::{provided, required, rem, self_ty_, shl, stmt_decl};\n+import syntax::ast::{subtract, ty, ty_bool, ty_char, ty_f, ty_f32, ty_f64};\n+import syntax::ast::{ty_float, ty_i, ty_i16, ty_i32, ty_i64, ty_i8, ty_int};\n+import syntax::ast::{ty_param, ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64};\n+import syntax::ast::{ty_u8, ty_uint, variant, view_item, view_item_export};\n import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n import syntax::ast::{view_path_list, view_path_simple};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n@@ -4017,6 +4017,26 @@ class Resolver {\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n+                pat_struct(path, _, _) => {\n+                    match self.resolve_path(path, TypeNS, false, visitor) {\n+                        some(definition @ def_ty(class_id))\n+                                if self.structs.contains_key(class_id) => {\n+                            let has_constructor = self.structs.get(class_id);\n+                            let class_def = def_class(class_id,\n+                                                      has_constructor);\n+                            self.record_def(pattern.id, class_def);\n+                        }\n+                        _ => {\n+                            self.session.span_err(path.span,\n+                                                  fmt!(\"`%s` does not name a \\\n+                                                        structure\",\n+                                                       connect(path.idents.map\n+                                                               (|x| *x),\n+                                                               ~\"::\")));\n+                        }\n+                    }\n+                }\n+\n                 _ => {\n                     // Nothing to do.\n                 }"}, {"sha": "6e3034f26eff3b18fb10aa7e3ebbe04041ed2b96", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 94, "deletions": 7, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -187,7 +187,8 @@ fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) => some(~[]),\n+          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) |\n+          ast::pat_struct(*) => some(~[]),\n           ast::pat_ident(_, _, none) if !pat_is_variant(dm, p) => some(~[]),\n           _ => none\n         }\n@@ -221,12 +222,12 @@ fn enter_opt(bcx: block, m: match_, opt: opt, col: uint,\n     }\n }\n \n-fn enter_rec(bcx: block, dm: DefMap, m: match_, col: uint,\n-             fields: ~[ast::ident], val: ValueRef) -> match_ {\n+fn enter_rec_or_struct(bcx: block, dm: DefMap, m: match_, col: uint,\n+                       fields: ~[ast::ident], val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_rec(fpats, _) => {\n+          ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n             let mut pats = ~[];\n             for vec::each(fields) |fname| {\n                 let mut pat = dummy;\n@@ -344,6 +345,23 @@ fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n     return fields;\n }\n \n+fn collect_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n+    let mut fields: ~[ast::ident] = ~[];\n+    for vec::each(m) |br| {\n+        match br.pats[col].node {\n+          ast::pat_struct(_, fs, _) => {\n+            for vec::each(fs) |f| {\n+                if !vec::any(fields, |x| str::eq(f.ident, x)) {\n+                    vec::push(fields, f.ident);\n+                }\n+            }\n+          }\n+          _ => ()\n+        }\n+    }\n+    return fields;\n+}\n+\n fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n@@ -500,15 +518,56 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n-    if rec_fields.len() > 0u {\n+    if rec_fields.len() > 0 {\n         let fields = ty::get_fields(node_id_type(bcx, pat_id));\n         let mut rec_vals = ~[];\n         for vec::each(rec_fields) |field_name| {\n             let ix = option::get(ty::field_idx(field_name, fields));\n             vec::push(rec_vals, GEPi(bcx, val, ~[0u, ix]));\n         }\n-        compile_submatch(bcx, enter_rec(bcx, dm, m, col, rec_fields, val),\n-                         vec::append(rec_vals, vals_left), chk, exits);\n+        compile_submatch(bcx,\n+                         enter_rec_or_struct(bcx, dm, m, col, rec_fields,\n+                                             val),\n+                         vec::append(rec_vals, vals_left),\n+                         chk,\n+                         exits);\n+        return;\n+    }\n+\n+    // Separate path for extracting and binding struct fields.\n+    let struct_fields = collect_struct_fields(m, col);\n+    if struct_fields.len() > 0 {\n+        let class_id, class_fields;\n+        match ty::get(node_id_type(bcx, pat_id)).struct {\n+            ty::ty_class(cid, _) => {\n+                class_id = cid;\n+                class_fields = ty::lookup_class_fields(ccx.tcx, class_id);\n+            }\n+            _ => {\n+                ccx.tcx.sess.bug(~\"struct pattern didn't resolve to a \\\n+                                   struct\");\n+            }\n+        }\n+\n+        // Index the class fields.\n+        let field_map = std::map::box_str_hash();\n+        for class_fields.eachi |i, class_field| {\n+            field_map.insert(class_field.ident, i);\n+        }\n+\n+        // Fetch each field.\n+        let mut struct_vals = ~[];\n+        for struct_fields.each |field_name| {\n+            let index = field_map.get(field_name);\n+            let fldptr = base::get_struct_field(bcx, val, class_id, index);\n+            vec::push(struct_vals, fldptr);\n+        }\n+        compile_submatch(bcx,\n+                         enter_rec_or_struct(bcx, dm, m, col, struct_fields,\n+                                             val),\n+                         vec::append(struct_vals, vals_left),\n+                         chk,\n+                         exits);\n         return;\n     }\n \n@@ -877,6 +936,34 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n+      ast::pat_struct(_, fields, _) => {\n+        // Grab the class data that we care about.\n+        let class_fields, class_id;\n+        match ty::get(node_id_type(bcx, pat.id)).struct {\n+            ty::ty_class(cid, substs) => {\n+                class_id = cid;\n+                class_fields = ty::lookup_class_fields(ccx.tcx, class_id);\n+            }\n+            _ => {\n+                ccx.tcx.sess.span_bug(pat.span, ~\"struct pattern didn't \\\n+                                                  resolve to a struct\");\n+            }\n+        }\n+\n+        // Index the class fields.\n+        let field_map = std::map::box_str_hash();\n+        for class_fields.eachi |i, class_field| {\n+            field_map.insert(class_field.ident, i);\n+        }\n+\n+        // Fetch each field.\n+        for fields.each |supplied_field| {\n+            let index = field_map.get(supplied_field.ident);\n+            let fldptr = base::get_struct_field(bcx, val, class_id, index);\n+            bcx = bind_irrefutable_pat(bcx, supplied_field.pat, fldptr,\n+                                       make_copy);\n+        }\n+      }\n       ast::pat_tup(elems) => {\n         let mut i = 0u;\n         for vec::each(elems) |elem| {"}, {"sha": "2f090cdab7c384d335855dfe18322a1302be0acd", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -3391,6 +3391,18 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     return bcx;\n }\n \n+// If the class has a destructor, our GEP is a little more\n+// complicated.\n+fn get_struct_field(block_context: block, dest_address: ValueRef,\n+                    class_id: ast::def_id, index: uint) -> ValueRef {\n+    if ty::ty_dtor(block_context.tcx(), class_id).is_some() {\n+        return GEPi(block_context,\n+                    GEPi(block_context, dest_address, ~[0, 1]),\n+                    ~[0, index]);\n+    }\n+    return GEPi(block_context, dest_address, ~[0, index]);\n+}\n+\n fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                 base: option<@ast::expr>, id: ast::node_id, dest: dest)\n              -> block {\n@@ -3434,18 +3446,6 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n         }\n     }\n \n-    // If the class has a destructor, our GEP is a little more\n-    // complicated.\n-    fn get_field(block_context: block, dest_address: ValueRef,\n-                 class_id: ast::def_id, index: uint) -> ValueRef {\n-        if ty::ty_dtor(block_context.tcx(), class_id).is_some() {\n-            return GEPi(block_context,\n-                        GEPi(block_context, dest_address, ~[0, 1]),\n-                        ~[0, index]);\n-        }\n-        return GEPi(block_context, dest_address, ~[0, index]);\n-    }\n-\n     // Now translate each field.\n     let mut temp_cleanups = ~[];\n     for fields.each |field| {\n@@ -3468,7 +3468,8 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n             }\n         }\n \n-        let dest = get_field(block_context, dest_address, class_id, index);\n+        let dest = get_struct_field(block_context, dest_address, class_id,\n+                                    index);\n \n         block_context = trans_expr_save_in(block_context,\n                                            field.node.expr,\n@@ -3494,10 +3495,10 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                 if exists {\n                     again;\n                 }\n-                let lldestfieldvalue = get_field(block_context,\n-                                                 dest_address,\n-                                                 class_id,\n-                                                 i);\n+                let lldestfieldvalue = get_struct_field(block_context,\n+                                                        dest_address,\n+                                                        class_id,\n+                                                        i);\n                 let llbasefieldvalue = GEPi(block_context,\n                                             llbasevalue,\n                                             ~[0, i]);"}, {"sha": "4fb348e598c02fc58ce2969e59973f689d2a49aa", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -232,6 +232,86 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, expected);\n       }\n+      ast::pat_struct(path, fields, etc) => {\n+        // Grab the class data that we care about.\n+        let class_fields, class_id, substitutions;\n+        match structure_of(fcx, pat.span, expected) {\n+            ty::ty_class(cid, substs) => {\n+                class_id = cid;\n+                substitutions = substs;\n+                class_fields = ty::lookup_class_fields(tcx, class_id);\n+            }\n+            _ => {\n+                // XXX: This should not be fatal.\n+                tcx.sess.span_fatal(pat.span,\n+                                    fmt!(\"mismatched types: expected `%s` \\\n+                                          but found struct\",\n+                                         fcx.infcx.ty_to_str(expected)));\n+            }\n+        }\n+\n+        // Check to ensure that the struct is the one specified.\n+        match tcx.def_map.get(pat.id) {\n+            ast::def_class(supplied_def_id, _)\n+                    if supplied_def_id == class_id => {\n+                // OK.\n+            }\n+            ast::def_class(*) => {\n+                let name = syntax::print::pprust::path_to_str(path);\n+                tcx.sess.span_err(pat.span,\n+                                  fmt!(\"mismatched types: expected `%s` but \\\n+                                        found `%s`\",\n+                                       fcx.infcx.ty_to_str(expected),\n+                                       name));\n+            }\n+            _ => {\n+                tcx.sess.span_bug(pat.span, ~\"resolve didn't write in class\");\n+            }\n+        }\n+\n+        // Index the class fields.\n+        let field_map = std::map::box_str_hash();\n+        for class_fields.eachi |i, class_field| {\n+            field_map.insert(class_field.ident, i);\n+        }\n+\n+        // Typecheck each field.\n+        let found_fields = std::map::uint_hash();\n+        for fields.each |field| {\n+            match field_map.find(field.ident) {\n+                some(index) => {\n+                    let class_field = class_fields[index];\n+                    let field_type = ty::lookup_field_type(tcx,\n+                                                           class_id,\n+                                                           class_field.id,\n+                                                           substitutions);\n+                    check_pat(pcx, field.pat, field_type);\n+                    found_fields.insert(index, ());\n+                }\n+                none => {\n+                    let name = syntax::print::pprust::path_to_str(path);\n+                    tcx.sess.span_err(pat.span,\n+                                      fmt!(\"struct `%s` does not have a field\n+                                            named `%s`\", name, *field.ident));\n+                }\n+            }\n+        }\n+\n+        // Report an error if not all the fields were specified.\n+        if !etc {\n+            for class_fields.eachi |i, field| {\n+                if found_fields.contains_key(i) {\n+                    again;\n+                }\n+                tcx.sess.span_err(pat.span,\n+                                  fmt!(\"pattern does not mention field `%s`\",\n+                                       *field.ident));\n+            }\n+        }\n+\n+        // Finally, write in the type.\n+        fcx.write_ty(pat.id, expected);\n+      }\n       ast::pat_tup(elts) => {\n         let ex_elts = match structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) => elts,"}, {"sha": "0a4f3b933c0ea461e1cfff9fb116028413ab9237", "filename": "src/test/run-pass/struct-pattern-matching.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/253dfc338775570a76d6c68bf349b2026e700797/src%2Ftest%2Frun-pass%2Fstruct-pattern-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/253dfc338775570a76d6c68bf349b2026e700797/src%2Ftest%2Frun-pass%2Fstruct-pattern-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-pattern-matching.rs?ref=253dfc338775570a76d6c68bf349b2026e700797", "patch": "@@ -0,0 +1,14 @@\n+struct Foo {\n+    x: int;\n+    y: int;\n+}\n+\n+fn main() {\n+    let a = Foo { x: 1, y: 2 };\n+    match a {\n+        Foo { x: x, y: y } => io::println(fmt!(\"yes, %d, %d\", x, y))\n+    }\n+}\n+\n+\n+"}]}