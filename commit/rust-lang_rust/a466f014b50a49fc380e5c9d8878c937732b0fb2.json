{"sha": "a466f014b50a49fc380e5c9d8878c937732b0fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NjZmMDE0YjUwYTQ5ZmMzODBlNWM5ZDg4NzhjOTM3NzMyYjBmYjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-27T15:46:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-27T15:46:51Z"}, "message": "Rollup merge of #65566 - estebank:let-expr-as-ty, r=Centril\n\nUse heuristics to suggest assignment\n\nWhen detecting a possible `=` -> `:` typo in a `let` binding, suggest\nassigning instead of setting the type.\n\nPartially address #57828.", "tree": {"sha": "7893326dddb6402a6ae31255f550e222bc207149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7893326dddb6402a6ae31255f550e222bc207149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a466f014b50a49fc380e5c9d8878c937732b0fb2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdtbvrCRBK7hj4Ov3rIwAAdHIIAJ61rtWuBloBvbzOcMSrLfn/\naonzjiEpYDdC9eAucg7y0IGhZPTOiqKUghZXthT0ZXiwIuW5y+bds74XV52GCOc+\n9t9Tlq7V0Dzkb/eJ32VqfsEFs1FdOpHm0cIMCAA7v9VJ+5LbXNXFW9nw8BFJo5rB\n7KmU+8uKYRVd1GNna2CausaXsezxjkEcW6MGfoKcu7C8f42hOulbRqG47PGhvu3Y\nkNoiyQEumUXYojpehbTOMVXjBwBWbOLpQvJKz8U31OO+vbLNaK6x6k+07ahhlzhY\nBue8+GCToMZsBXtzEUf4TI2U3D2c3c9gbLdszSKrWESjC65X2FZn/Xy44eyhogQ=\n=bQLN\n-----END PGP SIGNATURE-----\n", "payload": "tree 7893326dddb6402a6ae31255f550e222bc207149\nparent b7176b44a203322c834302f3b515f8c10a54f2c1\nparent b579c5a2d6948e9ff2efa81db85f7bca64f574e4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572191211 +0100\ncommitter GitHub <noreply@github.com> 1572191211 +0100\n\nRollup merge of #65566 - estebank:let-expr-as-ty, r=Centril\n\nUse heuristics to suggest assignment\n\nWhen detecting a possible `=` -> `:` typo in a `let` binding, suggest\nassigning instead of setting the type.\n\nPartially address #57828.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a466f014b50a49fc380e5c9d8878c937732b0fb2", "html_url": "https://github.com/rust-lang/rust/commit/a466f014b50a49fc380e5c9d8878c937732b0fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a466f014b50a49fc380e5c9d8878c937732b0fb2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7176b44a203322c834302f3b515f8c10a54f2c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7176b44a203322c834302f3b515f8c10a54f2c1", "html_url": "https://github.com/rust-lang/rust/commit/b7176b44a203322c834302f3b515f8c10a54f2c1"}, {"sha": "b579c5a2d6948e9ff2efa81db85f7bca64f574e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b579c5a2d6948e9ff2efa81db85f7bca64f574e4", "html_url": "https://github.com/rust-lang/rust/commit/b579c5a2d6948e9ff2efa81db85f7bca64f574e4"}], "stats": {"total": 213, "additions": 162, "deletions": 51}, "files": [{"sha": "9b254ab7ec1a2d2fb085faecee3541aacb350cef", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -316,22 +316,8 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n-struct LateResolutionVisitor<'a, 'b> {\n-    r: &'b mut Resolver<'a>,\n-\n-    /// The module that represents the current item scope.\n-    parent_scope: ParentScope<'a>,\n-\n-    /// The current set of local scopes for types and values.\n-    /// FIXME #4948: Reuse ribs to avoid allocation.\n-    ribs: PerNS<Vec<Rib<'a>>>,\n-\n-    /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a, NodeId>>,\n-\n-    /// The trait that the current context can refer to.\n-    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n-\n+#[derive(Default)]\n+struct DiagnosticMetadata {\n     /// The current trait's associated types' ident, used for diagnostic suggestions.\n     current_trait_assoc_types: Vec<Ident>,\n \n@@ -350,6 +336,29 @@ struct LateResolutionVisitor<'a, 'b> {\n \n     /// Only used for better errors on `fn(): fn()`.\n     current_type_ascription: Vec<Span>,\n+\n+    /// Only used for better errors on `let <pat>: <expr, not type>;`.\n+    current_let_binding: Option<(Span, Option<Span>, Option<Span>)>,\n+}\n+\n+struct LateResolutionVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+\n+    /// The module that represents the current item scope.\n+    parent_scope: ParentScope<'a>,\n+\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n+    ribs: PerNS<Vec<Rib<'a>>>,\n+\n+    /// The current set of local scopes, for labels.\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n+\n+    /// The trait that the current context can refer to.\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n+\n+    /// Fields used to add information to diagnostic errors.\n+    diagnostic_metadata: DiagnosticMetadata,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n@@ -373,7 +382,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.resolve_expr(expr, None);\n     }\n     fn visit_local(&mut self, local: &'tcx Local) {\n+        let local_spans = match local.pat.kind {\n+            // We check for this to avoid tuple struct fields.\n+            PatKind::Wild => None,\n+            _ => Some((\n+                local.pat.span,\n+                local.ty.as_ref().map(|ty| ty.span),\n+                local.init.as_ref().map(|init| init.span),\n+            )),\n+        };\n+        let original = replace(&mut self.diagnostic_metadata.current_let_binding, local_spans);\n         self.resolve_local(local);\n+        self.diagnostic_metadata.current_let_binding = original;\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.kind {\n@@ -415,7 +435,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, sp: Span, _: NodeId) {\n-        let previous_value = replace(&mut self.current_function, Some(sp));\n+        let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n@@ -441,7 +461,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 debug!(\"(resolving function) leaving function\");\n             })\n         });\n-        self.current_function = previous_value;\n+        self.diagnostic_metadata.current_function = previous_value;\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n@@ -475,7 +495,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         // (We however cannot ban `Self` for defaults on *all* generic\n         // lists; e.g. trait generics can usefully refer to `Self`,\n         // such as in the case of `trait Add<Rhs = Self>`.)\n-        if self.current_self_item.is_some() { // (`Some` if + only if we are in ADT's generics.)\n+        if self.diagnostic_metadata.current_self_item.is_some() {\n+            // (`Some` if + only if we are in ADT's generics.)\n             default_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n@@ -527,12 +548,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             },\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n-            current_trait_assoc_types: Vec::new(),\n-            current_self_type: None,\n-            current_self_item: None,\n-            current_function: None,\n-            unused_labels: Default::default(),\n-            current_type_ascription: Vec::new(),\n+            diagnostic_metadata: DiagnosticMetadata::default(),\n         }\n     }\n \n@@ -892,16 +908,22 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n         // Handle nested impls (inside fn bodies)\n-        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n+        let previous_value = replace(\n+            &mut self.diagnostic_metadata.current_self_type,\n+            Some(self_type.clone()),\n+        );\n         let result = f(self);\n-        self.current_self_type = previous_value;\n+        self.diagnostic_metadata.current_self_type = previous_value;\n         result\n     }\n \n     fn with_current_self_item<T>(&mut self, self_item: &Item, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let previous_value = replace(\n+            &mut self.diagnostic_metadata.current_self_item,\n+            Some(self_item.id),\n+        );\n         let result = f(self);\n-        self.current_self_item = previous_value;\n+        self.diagnostic_metadata.current_self_item = previous_value;\n         result\n     }\n \n@@ -912,14 +934,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let trait_assoc_types = replace(\n-            &mut self.current_trait_assoc_types,\n+            &mut self.diagnostic_metadata.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.kind {\n                 TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n                 _ => None,\n             }).collect(),\n         );\n         let result = f(self);\n-        self.current_trait_assoc_types = trait_assoc_types;\n+        self.diagnostic_metadata.current_trait_assoc_types = trait_assoc_types;\n         result\n     }\n \n@@ -1746,7 +1768,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {\n         if let Some(label) = label {\n-            self.unused_labels.insert(id, label.ident.span);\n+            self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             self.with_label_rib(NormalRibKind, |this| {\n                 let ident = label.ident.modern_and_legacy();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n@@ -1850,7 +1872,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     Some(node_id) => {\n                         // Since this res is a label, it is never read.\n                         self.r.label_res_map.insert(expr.id, node_id);\n-                        self.unused_labels.remove(&node_id);\n+                        self.diagnostic_metadata.unused_labels.remove(&node_id);\n                     }\n                 }\n \n@@ -1912,9 +1934,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 }\n             }\n             ExprKind::Type(ref type_expr, _) => {\n-                self.current_type_ascription.push(type_expr.span);\n+                self.diagnostic_metadata.current_type_ascription.push(type_expr.span);\n                 visit::walk_expr(self, expr);\n-                self.current_type_ascription.pop();\n+                self.diagnostic_metadata.current_type_ascription.pop();\n             }\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n@@ -2073,7 +2095,7 @@ impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n-        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n+        for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n             self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n         }\n     }"}, {"sha": "07f44e0742e34b2745a616a00cf102d4d5a5c316", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -72,10 +72,26 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n         let code = source.error_code(res.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n+        let (base_msg, fallback_label, base_span, could_be_expr) = if let Some(res) = res {\n             (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 format!(\"not a {}\", expected),\n-                span)\n+                span,\n+                match res {\n+                    Res::Def(DefKind::Fn, _) => {\n+                        // Verify whether this is a fn call or an Fn used as a type.\n+                        self.r.session.source_map().span_to_snippet(span).map(|snippet| {\n+                            snippet.ends_with(')')\n+                        }).unwrap_or(false)\n+                    }\n+                    Res::Def(DefKind::Ctor(..), _) |\n+                    Res::Def(DefKind::Method, _) |\n+                    Res::Def(DefKind::Const, _) |\n+                    Res::Def(DefKind::AssocConst, _) |\n+                    Res::SelfCtor(_) |\n+                    Res::PrimTy(_) |\n+                    Res::Local(_) => true,\n+                    _ => false,\n+                })\n         } else {\n             let item_span = path.last().unwrap().ident.span;\n             let (mod_prefix, mod_str) = if path.len() == 1 {\n@@ -94,7 +110,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             };\n             (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n                 format!(\"not found in {}\", mod_str),\n-                item_span)\n+                item_span,\n+                false)\n         };\n \n         let code = DiagnosticId::Error(code.into());\n@@ -134,7 +151,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                     \"`self` value is a keyword only available in methods with a `self` parameter\",\n                 ),\n             });\n-            if let Some(span) = &self.current_function {\n+            if let Some(span) = &self.diagnostic_metadata.current_function {\n                 err.span_label(*span, \"this function doesn't have a `self` parameter\");\n             }\n             return (err, Vec::new());\n@@ -257,6 +274,18 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         if !levenshtein_worked {\n             err.span_label(base_span, fallback_label);\n             self.type_ascription_suggestion(&mut err, base_span);\n+            match self.diagnostic_metadata.current_let_binding {\n+                Some((pat_sp, Some(ty_sp), None))\n+                if ty_sp.contains(base_span) && could_be_expr => {\n+                    err.span_suggestion_short(\n+                        pat_sp.between(ty_sp),\n+                        \"use `=` if you meant to assign\",\n+                        \" = \".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            }\n         }\n         (err, candidates)\n     }\n@@ -491,7 +520,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n         // Fields are generally expected in the same contexts as locals.\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+            if let Some(node_id) = self.diagnostic_metadata.current_self_type.as_ref()\n+                .and_then(extract_node_id)\n+            {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.r.partial_res_map.get(&node_id) {\n                     match resolution.base_res() {\n@@ -510,7 +541,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             }\n         }\n \n-        for assoc_type_ident in &self.current_trait_assoc_types {\n+        for assoc_type_ident in &self.diagnostic_metadata.current_trait_assoc_types {\n             if *assoc_type_ident == ident {\n                 return Some(AssocSuggestion::AssocItem);\n             }\n@@ -644,11 +675,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         err: &mut DiagnosticBuilder<'_>,\n         base_span: Span,\n     ) {\n-        debug!(\"type_ascription_suggetion {:?}\", base_span);\n         let cm = self.r.session.source_map();\n         let base_snippet = cm.span_to_snippet(base_span);\n-        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n-        if let Some(sp) = self.current_type_ascription.last() {\n+        if let Some(sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             let mut sp = *sp;\n             loop {\n                 // Try to find the `:`; bail on first non-':' / non-whitespace."}, {"sha": "ea7e4c05ea1ae2ad9846c71797e522bdd2fc8f67", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -239,7 +239,7 @@ impl<'a> Parser<'a> {\n                 err.span_suggestion_short(\n                     colon_sp,\n                     \"use `=` if you meant to assign\",\n-                    \"=\".to_string(),\n+                    \" =\".to_string(),\n                     Applicability::MachineApplicable\n                 );\n                 err.emit();"}, {"sha": "61fcebd787e5142da2d509fb01e628f7dc4f2f78", "filename": "src/test/ui/privacy/privacy-ns2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -39,6 +39,7 @@ fn test_single2() {\n     use foo2::Bar;\n \n     let _x : Box<Bar>; //~ ERROR expected type, found function `Bar`\n+    let _x : Bar(); //~ ERROR expected type, found function `Bar`\n }\n \n fn test_list2() {"}, {"sha": "58671addecdedbb32c46f24b4510e1b97f4f4fc5", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -48,7 +48,26 @@ LL | use foo3::Bar;\n    |\n \n error[E0573]: expected type, found function `Bar`\n-  --> $DIR/privacy-ns2.rs:47:17\n+  --> $DIR/privacy-ns2.rs:42:14\n+   |\n+LL |     let _x : Bar();\n+   |              ^^^^^ not a type\n+   |\n+help: use `=` if you meant to assign\n+   |\n+LL |     let _x = Bar();\n+   |            ^\n+help: possible better candidates are found in other modules, you can import them into scope\n+   |\n+LL | use foo1::Bar;\n+   |\n+LL | use foo2::Bar;\n+   |\n+LL | use foo3::Bar;\n+   |\n+\n+error[E0573]: expected type, found function `Bar`\n+  --> $DIR/privacy-ns2.rs:48:17\n    |\n LL |     let _x: Box<Bar>;\n    |                 ^^^\n@@ -67,24 +86,24 @@ LL | use foo3::Bar;\n    |\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:60:15\n+  --> $DIR/privacy-ns2.rs:61:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:64:15\n+  --> $DIR/privacy-ns2.rs:65:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:71:16\n+  --> $DIR/privacy-ns2.rs:72:16\n    |\n LL |     use foo3::{Bar,Baz};\n    |                ^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0423, E0573, E0603.\n For more information about an error, try `rustc --explain E0423`."}, {"sha": "beea951a18a2931d8af4d8c76ddd3e7d843118db", "filename": "src/test/ui/suggestions/let-binding-init-expr-as-ty.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.rs?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -0,0 +1,12 @@\n+pub fn foo(num: i32) -> i32 {\n+    let foo: i32::from_be(num);\n+    //~^ ERROR expected type, found local variable `num`\n+    //~| ERROR parenthesized type parameters may only be used with a `Fn` trait\n+    //~| ERROR ambiguous associated type\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    foo\n+}\n+\n+fn main() {\n+    let _ = foo(42);\n+}"}, {"sha": "a7c784fe82788402f3a14468bb1a79b00149eb36", "filename": "src/test/ui/suggestions/let-binding-init-expr-as-ty.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a466f014b50a49fc380e5c9d8878c937732b0fb2/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr?ref=a466f014b50a49fc380e5c9d8878c937732b0fb2", "patch": "@@ -0,0 +1,28 @@\n+error[E0573]: expected type, found local variable `num`\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:27\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |            --             ^^^ not a type\n+   |            |\n+   |            help: use `=` if you meant to assign\n+\n+error: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:19\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |                   ^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/let-binding-init-expr-as-ty.rs:2:14\n+   |\n+LL |     let foo: i32::from_be(num);\n+   |              ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<i32 as Trait>::from_be`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0223, E0573.\n+For more information about an error, try `rustc --explain E0223`."}]}