{"sha": "6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiY2Y4Nzc3ZmU2MzJmYjJjNTA2ZTMxZDEyZmJmZTIwNzEyZWNmZTY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-07-23T22:09:00Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-07-23T22:09:00Z"}, "message": "Point only at invalid positional arguments", "tree": {"sha": "08011929d3cf9d9f1f8b2c44b401ef58db1858a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08011929d3cf9d9f1f8b2c44b401ef58db1858a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "html_url": "https://github.com/rust-lang/rust/commit/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42306591b9c0a280da363c83df16b47ad8b04024", "url": "https://api.github.com/repos/rust-lang/rust/commits/42306591b9c0a280da363c83df16b47ad8b04024", "html_url": "https://github.com/rust-lang/rust/commit/42306591b9c0a280da363c83df16b47ad8b04024"}], "stats": {"total": 154, "additions": 84, "deletions": 70}, "files": [{"sha": "a320b52fb7bd94677b5ab61b7c5e4bdc1848cfbb", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 76, "deletions": 62, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "patch": "@@ -14,18 +14,18 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::ext::base::*;\n use syntax::ext::base;\n+use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use syntax::tokenstream;\n+use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n-use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry;\n+use std::collections::{HashMap, HashSet};\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -111,9 +111,11 @@ struct Context<'a, 'b: 'a> {\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `build_piece`.\n     curarg: usize,\n+    /// Current piece being evaluated, used for error reporting.\n     curpiece: usize,\n-    /// Keep track of invalid references to positional arguments\n-    invalid_refs: Vec<usize>,\n+    /// Keep track of invalid references to positional arguments.\n+    invalid_refs: Vec<(usize, usize)>,\n+    /// Spans of all the formatting arguments, in order.\n     arg_spans: Vec<Span>,\n }\n \n@@ -157,15 +159,20 @@ fn parse_args(ecx: &mut ExtCtxt,\n                     i\n                 }\n                 _ if named => {\n-                    ecx.span_err(p.span,\n-                                 \"expected ident, positional arguments \\\n-                                 cannot follow named arguments\");\n+                    ecx.span_err(\n+                        p.span,\n+                        \"expected ident, positional arguments cannot follow named arguments\",\n+                    );\n                     return None;\n                 }\n                 _ => {\n-                    ecx.span_err(p.span,\n-                                 &format!(\"expected ident for named argument, found `{}`\",\n-                                          p.this_token_to_string()));\n+                    ecx.span_err(\n+                        p.span,\n+                        &format!(\n+                            \"expected ident for named argument, found `{}`\",\n+                            p.this_token_to_string()\n+                        ),\n+                    );\n                     return None;\n                 }\n             };\n@@ -267,34 +274,47 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// errors for the case where all arguments are positional and for when\n     /// there are named arguments or numbered positional arguments in the\n     /// format string.\n-    fn report_invalid_references(&self, numbered_position_args: bool, arg_places: &[(usize, usize)]) {\n+    fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let sps = arg_places.iter()\n-            .map(|&(start, end)| self.fmtsp.from_inner_byte_pos(start, end))\n-            .collect::<Vec<_>>();\n-        let sp = MultiSpan::from_spans(sps);\n-        let mut refs: Vec<_> = self.invalid_refs\n+        let sp = MultiSpan::from_spans(self.arg_spans.clone());\n+        let mut refs: Vec<_> = self\n+            .invalid_refs\n             .iter()\n-            .map(|r| r.to_string())\n+            .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)))\n             .collect();\n \n         if self.names.is_empty() && !numbered_position_args {\n-            e = self.ecx.mut_span_err(sp,\n-                &format!(\"{} positional argument{} in format string, but {}\",\n+            e = self.ecx.mut_span_err(\n+                sp,\n+                &format!(\n+                    \"{} positional argument{} in format string, but {}\",\n                          self.pieces.len(),\n                          if self.pieces.len() > 1 { \"s\" } else { \"\" },\n-                         self.describe_num_args()));\n+                    self.describe_num_args()\n+                ),\n+            );\n         } else {\n-            let arg_list = match refs.len() {\n+            let (arg_list, sp) = match refs.len() {\n                 1 => {\n-                    let reg = refs.pop().unwrap();\n-                    format!(\"argument {}\", reg)\n-                },\n+                    let (reg, pos) = refs.pop().unwrap();\n+                    (\n+                        format!(\"argument {}\", reg),\n+                        MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n+                    )\n+                }\n                 _ => {\n+                    let pos =\n+                        MultiSpan::from_spans(refs.iter().map(|(_, p)| *p.unwrap()).collect());\n+                    let mut refs: Vec<String> = refs.iter().map(|(s, _)| s.to_owned()).collect();\n                     let reg = refs.pop().unwrap();\n-                    format!(\"arguments {head} and {tail}\",\n-                             tail=reg,\n-                             head=refs.join(\", \"))\n+                    (\n+                        format!(\n+                            \"arguments {head} and {tail}\",\n+                            tail = reg,\n+                            head = refs.join(\", \")\n+                        ),\n+                        pos,\n+                    )\n                 }\n             };\n \n@@ -314,7 +334,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         match arg {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n-                    self.invalid_refs.push(arg);\n+                    self.invalid_refs.push((arg, self.curpiece));\n                     return;\n                 }\n                 match ty {\n@@ -520,33 +540,27 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let prec = self.build_count(arg.format.precision);\n                 let width = self.build_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n-                let fmt =\n-                    self.ecx.expr_struct(sp,\n+                let fmt = self.ecx.expr_struct(\n+                    sp,\n                                          path,\n-                                         vec![self.ecx\n-                                                  .field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"align\"),\n-                                                                 align),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"flags\"),\n-                                                                 flags),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"precision\"),\n-                                                                 prec),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"width\"),\n-                                                                 width)]);\n+                    vec![\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                    ],\n+                );\n \n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n-                Some(self.ecx.expr_struct(sp,\n+                Some(self.ecx.expr_struct(\n+                    sp,\n                                           path,\n-                                          vec![self.ecx.field_imm(sp,\n-                                                                  self.ecx.ident_of(\"position\"),\n-                                                                  pos),\n-                                               self.ecx.field_imm(sp,\n-                                                                  self.ecx.ident_of(\"format\"),\n-                                                                  fmt)]))\n+                    vec![\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                    ],\n+                ))\n             }\n         }\n     }\n@@ -559,9 +573,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n-        let names_pos: Vec<_> = (0..self.args.len()).map(|i| {\n-            self.ecx.ident_of(&format!(\"arg{}\", i)).gensym()\n-        }).collect();\n+        let names_pos: Vec<_> = (0..self.args.len())\n+            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i)).gensym())\n+            .collect();\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n@@ -705,10 +719,11 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n     }\n }\n \n-pub fn expand_format_args_nl<'cx>(ecx: &'cx mut ExtCtxt,\n+pub fn expand_format_args_nl<'cx>(\n+    ecx: &'cx mut ExtCtxt,\n                                   mut sp: Span,\n-                                  tts: &[tokenstream::TokenTree])\n-                                  -> Box<dyn base::MacResult + 'cx> {\n+    tts: &[tokenstream::TokenTree],\n+) -> Box<dyn base::MacResult + 'cx> {\n     //if !ecx.ecfg.enable_allow_internal_unstable() {\n \n     // For some reason, the only one that actually works for `println` is the first check\n@@ -759,7 +774,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             let sugg_fmt = match args.len() {\n                 0 => \"{}\".to_string(),\n                 _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n-\n             };\n             err.span_suggestion(\n                 fmt_sp.shrink_to_lo(),\n@@ -768,7 +782,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             );\n             err.emit();\n             return DummyResult::raw_expr(sp);\n-        },\n+        }\n     };\n \n     let mut cx = Context {\n@@ -862,7 +876,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     }\n \n     if cx.invalid_refs.len() >= 1 {\n-        cx.report_invalid_references(numbered_position_args, &parser.arg_places);\n+        cx.report_invalid_references(numbered_position_args);\n     }\n \n     // Make sure that all arguments were used and all arguments have types.\n@@ -894,7 +908,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             } else {\n                 let mut diag = cx.ecx.struct_span_err(\n                     errs.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-                    \"multiple unused formatting arguments\"\n+                    \"multiple unused formatting arguments\",\n                 );\n                 diag.span_label(cx.fmtsp, \"multiple missing formatting arguments\");\n                 diag"}, {"sha": "4f5f37132e821973a245fe9d55daeee6da6720a4", "filename": "src/test/ui/ifmt-bad-arg.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bcf8777fe632fb2c506e31d12fbfe20712ecfe6/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr?ref=6bcf8777fe632fb2c506e31d12fbfe20712ecfe6", "patch": "@@ -25,34 +25,34 @@ LL |     format!(\"{} {}\");\n    |              ^^ ^^\n \n error: invalid reference to positional argument 1 (there is 1 argument)\n-  --> $DIR/ifmt-bad-arg.rs:26:14\n+  --> $DIR/ifmt-bad-arg.rs:26:18\n    |\n LL |     format!(\"{0} {1}\", 1);\n-   |              ^^^ ^^^\n+   |                  ^^^\n    |\n    = note: positional arguments are zero-based\n \n error: invalid reference to positional argument 2 (there are 2 arguments)\n-  --> $DIR/ifmt-bad-arg.rs:29:14\n+  --> $DIR/ifmt-bad-arg.rs:29:22\n    |\n LL |     format!(\"{0} {1} {2}\", 1, 2);\n-   |              ^^^ ^^^ ^^^\n+   |                      ^^^\n    |\n    = note: positional arguments are zero-based\n \n error: invalid reference to positional argument 2 (there are 2 arguments)\n-  --> $DIR/ifmt-bad-arg.rs:32:14\n+  --> $DIR/ifmt-bad-arg.rs:32:28\n    |\n LL |     format!(\"{} {value} {} {}\", 1, value=2);\n-   |              ^^ ^^^^^^^ ^^ ^^\n+   |                            ^^\n    |\n    = note: positional arguments are zero-based\n \n error: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n-  --> $DIR/ifmt-bad-arg.rs:34:14\n+  --> $DIR/ifmt-bad-arg.rs:34:38\n    |\n LL |     format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n-   |              ^^^^^^ ^^^^^^^ ^^ ^^ ^^ ^^ ^^ ^^\n+   |                                      ^^ ^^ ^^\n    |\n    = note: positional arguments are zero-based\n "}]}