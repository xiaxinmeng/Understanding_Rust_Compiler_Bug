{"sha": "27617a10f6647e98a90adbfce4f881c32c82a4dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NjE3YTEwZjY2NDdlOThhOTBhZGJmY2U0Zjg4MWMzMmM4MmE0ZGM=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-22T03:21:53Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-29T00:40:48Z"}, "message": "librustc_trans: Get rid of unnecessary allocation in finding discriminant field.", "tree": {"sha": "5660243e5991ee28bbfcb0a3ae3db5cdbc3b5574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5660243e5991ee28bbfcb0a3ae3db5cdbc3b5574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27617a10f6647e98a90adbfce4f881c32c82a4dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27617a10f6647e98a90adbfce4f881c32c82a4dc", "html_url": "https://github.com/rust-lang/rust/commit/27617a10f6647e98a90adbfce4f881c32c82a4dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27617a10f6647e98a90adbfce4f881c32c82a4dc/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15df8e68f62a973b322109101ead205830dc767", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15df8e68f62a973b322109101ead205830dc767", "html_url": "https://github.com/rust-lang/rust/commit/c15df8e68f62a973b322109101ead205830dc767"}], "stats": {"total": 85, "additions": 38, "deletions": 47}, "files": [{"sha": "cd788945d3b281c5d4bdb5df79ce14ed62e72970", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 38, "deletions": 47, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/27617a10f6647e98a90adbfce4f881c32c82a4dc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27617a10f6647e98a90adbfce4f881c32c82a4dc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=27617a10f6647e98a90adbfce4f881c32c82a4dc", "patch": "@@ -228,24 +228,24 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         let st = mk_struct(cx, cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n-                            Some(ref pf) if pf.len() == 1 && st.fields.len() == 1 => {\n+                            Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nnty: st.fields[0],\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n-                            Some(pf) => {\n-                                let mut discrfield = vec![0];\n-                                discrfield.extend(pf.into_iter());\n+                            Some(mut discrfield) => {\n+                                discrfield.push(0);\n+                                discrfield.reverse();\n                                 return StructWrappedNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nonnull: st,\n                                     discrfield: discrfield,\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n-                            None => { }\n+                            None => {}\n                         }\n                     }\n                     discr += 1;\n@@ -338,33 +338,38 @@ struct Case<'tcx> {\n /// This represents the (GEP) indices to follow to get to the discriminant field\n pub type DiscrField = Vec<uint>;\n \n-fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Option<DiscrField> {\n+fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    ty: Ty<'tcx>,\n+                                    mut path: DiscrField) -> Option<DiscrField> {\n     match ty.sty {\n-        // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n-        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n-            // &[T] and &str are a pointer and length pair\n-            ty::ty_vec(_, None) | ty::ty_str => Some(vec![FAT_PTR_ADDR]),\n-\n-            ty::ty_struct(..) if !ty::type_is_sized(tcx, ty) => Some(vec![FAT_PTR_ADDR]),\n-\n-            // Any other &T is just a pointer\n-            _ => Some(vec![])\n+        // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n+        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !ty::type_is_sized(tcx, ty) => {\n+            path.push(FAT_PTR_ADDR);\n+            Some(path)\n         },\n \n+        // Regular thin pointer: &T/&mut T/Box<T>\n+        ty::ty_rptr(..) | ty::ty_uniq(..) => Some(path),\n+\n         // Functions are just pointers\n-        ty::ty_bare_fn(..) => Some(vec![]),\n+        ty::ty_bare_fn(..) => Some(path),\n \n         // Closures are a pair of pointers: the code and environment\n-        ty::ty_closure(..) => Some(vec![FAT_PTR_ADDR]),\n+        ty::ty_closure(..) => {\n+            path.push(FAT_PTR_ADDR);\n+            Some(path)\n+        },\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n         ty::ty_struct(did, ref substs) if Some(did) == tcx.lang_items.non_zero() => {\n             let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n             assert_eq!(nonzero_fields.len(), 1);\n             let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n-                ty::ty_ptr(..) | ty::ty_int(..) |\n-                ty::ty_uint(..) => Some(vec![0]),\n+                ty::ty_ptr(..) | ty::ty_int(..) | ty::ty_uint(..) => {\n+                    path.push(0);\n+                    Some(path)\n+                },\n                 _ => None\n             }\n         },\n@@ -375,13 +380,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Optio\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             for (j, field) in fields.iter().enumerate() {\n                 let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n-                match find_discr_field_candidate(tcx, field_ty) {\n-                    Some(v) => {\n-                        let mut discrfield = vec![j];\n-                        discrfield.extend(v.into_iter());\n-                        return Some(discrfield);\n-                    }\n-                    None => continue\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n                 }\n             }\n             None\n@@ -390,13 +391,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Optio\n         // Can we use one of the fields in this tuple?\n         ty::ty_tup(ref tys) => {\n             for (j, &ty) in tys.iter().enumerate() {\n-                match find_discr_field_candidate(tcx, ty) {\n-                    Some(v) => {\n-                        let mut discrfield = vec![j];\n-                        discrfield.extend(v.into_iter());\n-                        return Some(discrfield);\n-                    }\n-                    None => continue\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n                 }\n             }\n             None\n@@ -405,13 +402,11 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Optio\n         // Is this a fixed-size array of something non-zero\n         // with at least one element?\n         ty::ty_vec(ety, Some(d)) if d > 0 => {\n-            match find_discr_field_candidate(tcx, ety) {\n-                Some(v) => {\n-                    let mut discrfield = vec![0];\n-                    discrfield.extend(v.into_iter());\n-                    return Some(discrfield);\n-                }\n-                None => None\n+            if let Some(mut vpath) = find_discr_field_candidate(tcx, ety, path) {\n+                vpath.push(0);\n+                Some(vpath)\n+            } else {\n+                None\n             }\n         },\n \n@@ -427,13 +422,9 @@ impl<'tcx> Case<'tcx> {\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n         for (i, &ty) in self.tys.iter().enumerate() {\n-            match find_discr_field_candidate(cx.tcx(), ty) {\n-                Some(v) => {\n-                    let mut discrfield = vec![i];\n-                    discrfield.extend(v.into_iter());\n-                    return Some(discrfield);\n-                }\n-                None => continue\n+            if let Some(mut path) = find_discr_field_candidate(cx.tcx(), ty, vec![]) {\n+                path.push(i);\n+                return Some(path);\n             }\n         }\n         None"}]}