{"sha": "6d78142bf05ae8848101190cf5410ea02ef47226", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNzgxNDJiZjA1YWU4ODQ4MTAxMTkwY2Y1NDEwZWEwMmVmNDcyMjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-01T06:29:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-01T06:29:11Z"}, "message": "Rollup merge of #60330 - varkor:range-endpoint-overflow-lint, r=estebank\n\nSuggest using an inclusive range instead of an exclusive range when the endpoint overflows by 1\n\nFixes https://github.com/rust-lang/rust/issues/47213.", "tree": {"sha": "c351c3af082e0c061531c83788993d89ca23adc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c351c3af082e0c061531c83788993d89ca23adc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d78142bf05ae8848101190cf5410ea02ef47226", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcyTy3CRBK7hj4Ov3rIwAAdHIIALF5T4gZwtaj5YuuvdJnJjg/\nGmv/U4CddkyPK5teYdBCObjJK7qfTe3MPoayrLNNYq5On9tQkyyOw0HdMnQZdZ0n\nS9z5iMfJTx8YV0MvVXNt5vWhpiLSQaOOp2OGuWYdMw/o3Nlo/bEGlDo3iq8FOAB2\nxYZB6rFcOybcEKc/0KiFrLuWTitEkF5LmgNoAXEHBEDXeT0zQSdVxMc1g9vp/kqZ\nR2qxOrNNjlfiInRi2bFUiXs8FA0aCIhTCowJzPBFLZnxVnPwaeF2+nl3vXJ+nGJh\ntJNYnLaXPxmup00Y6OQdm1JxymCTEW8DEVSjTpMUN22T2asizuuordoY2/wQ+no=\n=kBIC\n-----END PGP SIGNATURE-----\n", "payload": "tree c351c3af082e0c061531c83788993d89ca23adc3\nparent 1c2ea8f59643386c1cf2c41ca9a19379d0fcac72\nparent b7711bff524716c27140256e6f6e78bbb8fd1283\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556692151 +0200\ncommitter GitHub <noreply@github.com> 1556692151 +0200\n\nRollup merge of #60330 - varkor:range-endpoint-overflow-lint, r=estebank\n\nSuggest using an inclusive range instead of an exclusive range when the endpoint overflows by 1\n\nFixes https://github.com/rust-lang/rust/issues/47213.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d78142bf05ae8848101190cf5410ea02ef47226", "html_url": "https://github.com/rust-lang/rust/commit/6d78142bf05ae8848101190cf5410ea02ef47226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d78142bf05ae8848101190cf5410ea02ef47226/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2ea8f59643386c1cf2c41ca9a19379d0fcac72", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2ea8f59643386c1cf2c41ca9a19379d0fcac72", "html_url": "https://github.com/rust-lang/rust/commit/1c2ea8f59643386c1cf2c41ca9a19379d0fcac72"}, {"sha": "b7711bff524716c27140256e6f6e78bbb8fd1283", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7711bff524716c27140256e6f6e78bbb8fd1283", "html_url": "https://github.com/rust-lang/rust/commit/b7711bff524716c27140256e6f6e78bbb8fd1283"}], "stats": {"total": 950, "additions": 551, "deletions": 399}, "files": [{"sha": "0366d1e5c24e9d4777f8b0d256ce81aba442a313", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -5400,3 +5400,65 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n+\n+/// Checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n+    use hir::{Path, QPath, ExprKind, TyKind};\n+\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.as_str().to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n+\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_lit(sess: &Session, span: &Span) -> bool {\n+        let source_map = sess.source_map();\n+        let end_point = source_map.end_point(*span);\n+\n+        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.node {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && is_lit(sess, &expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && is_lit(sess, &expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n+                    let new_call = segment.ident.as_str() == \"new\";\n+                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}"}, {"sha": "f4ebfd79fe1db41f1bfee121dd045a1be2de7569", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 345, "deletions": 250, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,6 +1,7 @@\n #![allow(non_snake_case)]\n \n-use rustc::hir::Node;\n+use rustc::hir::{ExprKind, Node};\n+use rustc::hir::lowering::is_range_literal;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n@@ -57,6 +58,347 @@ impl TypeLimits {\n     }\n }\n \n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n+/// Returns `true` iff the lint was overridden.\n+fn lint_overflowing_range_endpoint<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    lit: &ast::Lit,\n+    lit_val: u128,\n+    max: u128,\n+    expr: &'tcx hir::Expr,\n+    parent_expr: &'tcx hir::Expr,\n+    ty: impl std::fmt::Debug,\n+) -> bool {\n+    // We only want to handle exclusive (`..`) ranges,\n+    // which are represented as `ExprKind::Struct`.\n+    if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+        debug_assert_eq!(eps.len(), 2);\n+        // We can suggest using an inclusive range\n+        // (`..=`) instead only if it is the `end` that is\n+        // overflowing and only by 1.\n+        if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n+            let mut err = cx.struct_span_lint(\n+                OVERFLOWING_LITERALS,\n+                parent_expr.span,\n+                &format!(\"range endpoint is out of range for `{:?}`\", ty),\n+            );\n+            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                use ast::{LitKind, LitIntType};\n+                // We need to preserve the literal's suffix,\n+                // as it may determine typing information.\n+                let suffix = match lit.node {\n+                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                    _ => bug!(),\n+                };\n+                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                err.span_suggestion(\n+                    parent_expr.span,\n+                    &\"use an inclusive range instead\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+// For `isize` & `usize`, be conservative with the warnings, so that the\n+// warnings are consistent between 32- and 64-bit platforms.\n+fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n+    match int_ty {\n+        ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+        ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+        ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+        ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n+    }\n+}\n+\n+fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n+    match uint_ty {\n+        ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+        ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+        ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+        ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n+    }\n+}\n+\n+fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n+    let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n+    let firstch = src.chars().next()?;\n+\n+    if firstch == '0' {\n+        match src.chars().nth(1) {\n+            Some('x') | Some('b') => return Some(src),\n+            _ => return None,\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn report_bin_hex_error(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    ty: attr::IntType,\n+    repr_str: String,\n+    val: u128,\n+    negative: bool,\n+) {\n+    let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = sign_extend(val, size) as i128;\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = truncate(val, size);\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+    };\n+    let mut err = cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        &format!(\"literal out of range for {}\", t),\n+    );\n+    err.note(&format!(\n+        \"the literal `{}` (decimal `{}`) does not fit into \\\n+            an `{}` and will become `{}{}`\",\n+        repr_str, val, t, actually, t\n+    ));\n+    if let Some(sugg_ty) =\n+        get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n+    {\n+        if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+            let (sans_suffix, _) = repr_str.split_at(pos);\n+            err.span_suggestion(\n+                expr.span,\n+                &format!(\"consider using `{}` instead\", sugg_ty),\n+                format!(\"{}{}\", sans_suffix, sugg_ty),\n+                Applicability::MachineApplicable\n+            );\n+        } else {\n+            err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n+// This function finds the next fitting type and generates a suggestion string.\n+// It searches for fitting types in the following way (`X < Y`):\n+//  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+//  - `-iX` => `iY`\n+//  - `uX` => `uY`\n+//\n+// No suggestion for: `isize`, `usize`.\n+fn get_type_suggestion<'a>(\n+    t: Ty<'_>,\n+    val: u128,\n+    negative: bool,\n+) -> Option<String> {\n+    use syntax::ast::IntTy::*;\n+    use syntax::ast::UintTy::*;\n+    macro_rules! find_fit {\n+        ($ty:expr, $val:expr, $negative:expr,\n+         $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+            {\n+                let _neg = if negative { 1 } else { 0 };\n+                match $ty {\n+                    $($type => {\n+                        $(if !negative && val <= uint_ty_range($utypes).1 {\n+                            return Some(format!(\"{:?}\", $utypes))\n+                        })*\n+                        $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                            return Some(format!(\"{:?}\", $itypes))\n+                        })*\n+                        None\n+                    },)*\n+                    _ => None\n+                }\n+            }\n+        }\n+    }\n+    match t.sty {\n+        ty::Int(i) => find_fit!(i, val, negative,\n+                      I8 => [U8] => [I16, I32, I64, I128],\n+                      I16 => [U16] => [I32, I64, I128],\n+                      I32 => [U32] => [I64, I128],\n+                      I64 => [U64] => [I128],\n+                      I128 => [U128] => []),\n+        ty::Uint(u) => find_fit!(u, val, negative,\n+                      U8 => [U8, U16, U32, U64, U128] => [],\n+                      U16 => [U16, U32, U64, U128] => [],\n+                      U32 => [U32, U64, U128] => [],\n+                      U64 => [U64, U128] => [],\n+                      U128 => [U128] => []),\n+        _ => None,\n+    }\n+}\n+\n+fn lint_int_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::IntTy,\n+    v: u128,\n+) {\n+    let int_type = if let ast::IntTy::Isize = t {\n+        cx.sess().target.isize_ty\n+    } else {\n+        t\n+    };\n+\n+    let (_, max) = int_ty_range(int_type);\n+    let max = max as u128;\n+    let negative = type_limits.negated_expr_id == e.hir_id;\n+\n+    // Detect literal value out of range [min, max] inclusive\n+    // avoiding use of -min to prevent overflow/panic\n+    if (negative && v > max + 1) || (!negative && v > max) {\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(\n+                cx,\n+                e,\n+                attr::IntType::SignedInt(t),\n+                repr_str,\n+                v,\n+                negative,\n+            );\n+            return;\n+        }\n+\n+        let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n+            if let hir::ExprKind::Struct(..) = par_e.node {\n+                if is_range_literal(cx.sess(), par_e)\n+                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n+                {\n+                    // The overflowing literal lint was overridden.\n+                    return;\n+                }\n+            }\n+        }\n+\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_uint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::UintTy,\n+) {\n+    let uint_type = if let ast::UintTy::Usize = t {\n+        cx.sess().target.usize_ty\n+    } else {\n+        t\n+    };\n+    let (min, max) = uint_ty_range(uint_type);\n+    let lit_val: u128 = match lit.node {\n+        // _v is u8, within range by definition\n+        ast::LitKind::Byte(_v) => return,\n+        ast::LitKind::Int(v, _) => v,\n+        _ => bug!(),\n+    };\n+    if lit_val < min || lit_val > max {\n+        let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(parent_id) {\n+            match par_e.node {\n+                hir::ExprKind::Cast(..) => {\n+                    if let ty::Char = cx.tables.expr_ty(par_e).sty {\n+                        let mut err = cx.struct_span_lint(\n+                            OVERFLOWING_LITERALS,\n+                            par_e.span,\n+                            \"only `u8` can be cast into `char`\",\n+                        );\n+                        err.span_suggestion(\n+                            par_e.span,\n+                            &\"use a `char` literal instead\",\n+                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        return;\n+                    }\n+                }\n+                hir::ExprKind::Struct(..)\n+                    if is_range_literal(cx.sess(), par_e) => {\n+                        if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n+                            // The overflowing literal lint was overridden.\n+                            return;\n+                        }\n+                    }\n+                _ => {}\n+            }\n+        }\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n+            return;\n+        }\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+) {\n+    match cx.tables.node_type(e.hir_id).sty {\n+        ty::Int(t) => {\n+            match lit.node {\n+                ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n+                    lint_int_literal(cx, type_limits, e, lit, t, v)\n+                }\n+                _ => bug!(),\n+            };\n+        }\n+        ty::Uint(t) => {\n+            lint_uint_literal(cx, e, lit, t)\n+        }\n+        ty::Float(t) => {\n+            let is_infinite = match lit.node {\n+                ast::LitKind::Float(v, _) |\n+                ast::LitKind::FloatUnsuffixed(v) => {\n+                    match t {\n+                        ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                        ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                    }\n+                }\n+                _ => bug!(),\n+            };\n+            if is_infinite == Ok(true) {\n+                cx.span_lint(OVERFLOWING_LITERALS,\n+                             e.span,\n+                             &format!(\"literal out of range for `{:?}`\", t));\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n@@ -73,118 +415,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n             }\n-            hir::ExprKind::Lit(ref lit) => {\n-                match cx.tables.node_type(e.hir_id).sty {\n-                    ty::Int(t) => {\n-                        match lit.node {\n-                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n-                                let int_type = if let ast::IntTy::Isize = t {\n-                                    cx.sess().target.isize_ty\n-                                } else {\n-                                    t\n-                                };\n-                                let (_, max) = int_ty_range(int_type);\n-                                let max = max as u128;\n-                                let negative = self.negated_expr_id == e.hir_id;\n-\n-                                // Detect literal value out of range [min, max] inclusive\n-                                // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) || (!negative && v > max) {\n-                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                        report_bin_hex_error(\n-                                            cx,\n-                                            e,\n-                                            attr::IntType::SignedInt(t),\n-                                            repr_str,\n-                                            v,\n-                                            negative,\n-                                        );\n-                                        return;\n-                                    }\n-                                    cx.span_lint(\n-                                        OVERFLOWING_LITERALS,\n-                                        e.span,\n-                                        &format!(\"literal out of range for {:?}\", t),\n-                                    );\n-                                    return;\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                    }\n-                    ty::Uint(t) => {\n-                        let uint_type = if let ast::UintTy::Usize = t {\n-                            cx.sess().target.usize_ty\n-                        } else {\n-                            t\n-                        };\n-                        let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u128 = match lit.node {\n-                            // _v is u8, within range by definition\n-                            ast::LitKind::Byte(_v) => return,\n-                            ast::LitKind::Int(v, _) => v,\n-                            _ => bug!(),\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n-                                if let hir::ExprKind::Cast(..) = parent_expr.node {\n-                                    if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n-                                        let mut err = cx.struct_span_lint(\n-                                                             OVERFLOWING_LITERALS,\n-                                                             parent_expr.span,\n-                                                             \"only u8 can be cast into char\");\n-                                        err.span_suggestion(\n-                                            parent_expr.span,\n-                                            &\"use a char literal instead\",\n-                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                        err.emit();\n-                                        return\n-                                    }\n-                                }\n-                            }\n-                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                report_bin_hex_error(\n-                                    cx,\n-                                    e,\n-                                    attr::IntType::UnsignedInt(t),\n-                                    repr_str,\n-                                    lit_val,\n-                                    false,\n-                                );\n-                                return;\n-                            }\n-                            cx.span_lint(\n-                                OVERFLOWING_LITERALS,\n-                                e.span,\n-                                &format!(\"literal out of range for {:?}\", t),\n-                            );\n-                        }\n-                    }\n-                    ty::Float(t) => {\n-                        let is_infinite = match lit.node {\n-                            ast::LitKind::Float(v, _) |\n-                            ast::LitKind::FloatUnsuffixed(v) => {\n-                                match t {\n-                                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if is_infinite == Ok(true) {\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    }\n-                    _ => (),\n-                };\n-            }\n-            _ => (),\n+            hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n+            _ => {}\n         };\n \n         fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n@@ -209,30 +441,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             })\n         }\n \n-        // for isize & usize, be conservative with the warnings, so that the\n-        // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n-            match int_ty {\n-                ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n-                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n-                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n-                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n-            }\n-        }\n-\n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n-            match uint_ty {\n-                ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n-                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n-                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n-                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n-            }\n-        }\n-\n         fn check_limits(cx: &LateContext<'_, '_>,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,\n@@ -289,119 +497,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n-\n-        fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n-            let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n-            let firstch = src.chars().next()?;\n-\n-            if firstch == '0' {\n-                match src.chars().nth(1) {\n-                    Some('x') | Some('b') => return Some(src),\n-                    _ => return None,\n-                }\n-            }\n-\n-            None\n-        }\n-\n-        // This function finds the next fitting type and generates a suggestion string.\n-        // It searches for fitting types in the following way (`X < Y`):\n-        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n-        //  - `-iX` => `iY`\n-        //  - `uX` => `uY`\n-        //\n-        // No suggestion for: `isize`, `usize`.\n-        fn get_type_suggestion<'a>(\n-            t: Ty<'_>,\n-            val: u128,\n-            negative: bool,\n-        ) -> Option<String> {\n-            use syntax::ast::IntTy::*;\n-            use syntax::ast::UintTy::*;\n-            macro_rules! find_fit {\n-                ($ty:expr, $val:expr, $negative:expr,\n-                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n-                    {\n-                        let _neg = if negative { 1 } else { 0 };\n-                        match $ty {\n-                            $($type => {\n-                                $(if !negative && val <= uint_ty_range($utypes).1 {\n-                                    return Some(format!(\"{:?}\", $utypes))\n-                                })*\n-                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                                    return Some(format!(\"{:?}\", $itypes))\n-                                })*\n-                                None\n-                            },)*\n-                            _ => None\n-                        }\n-                    }\n-                }\n-            }\n-            match t.sty {\n-                ty::Int(i) => find_fit!(i, val, negative,\n-                              I8 => [U8] => [I16, I32, I64, I128],\n-                              I16 => [U16] => [I32, I64, I128],\n-                              I32 => [U32] => [I64, I128],\n-                              I64 => [U64] => [I128],\n-                              I128 => [U128] => []),\n-                ty::Uint(u) => find_fit!(u, val, negative,\n-                              U8 => [U8, U16, U32, U64, U128] => [],\n-                              U16 => [U16, U32, U64, U128] => [],\n-                              U32 => [U32, U64, U128] => [],\n-                              U64 => [U64, U128] => [],\n-                              U128 => [U128] => []),\n-                _ => None,\n-            }\n-        }\n-\n-        fn report_bin_hex_error(\n-            cx: &LateContext<'_, '_>,\n-            expr: &hir::Expr,\n-            ty: attr::IntType,\n-            repr_str: String,\n-            val: u128,\n-            negative: bool,\n-        ) {\n-            let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = sign_extend(val, size) as i128;\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = truncate(val, size);\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-            };\n-            let mut err = cx.struct_span_lint(\n-                OVERFLOWING_LITERALS,\n-                expr.span,\n-                &format!(\"literal out of range for {}\", t),\n-            );\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 an `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n-            {\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion(\n-                        expr.span,\n-                        &format!(\"consider using `{}` instead\", sugg_ty),\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n-                }\n-            }\n-\n-            err.emit();\n-        }\n     }\n }\n "}, {"sha": "8ae66a96c763a8e26dff828a22be9852d1c82423", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -7,7 +7,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::Node;\n-use rustc::hir::print;\n+use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{Applicability, DiagnosticBuilder};\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprKind::Cast(_, _) |\n                             hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if self.is_range_literal(expr) => true,\n+                            _ if is_range_literal(self.tcx.sess, expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens {\n@@ -479,70 +479,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// This function checks if the specified expression is a built-in range literal.\n-    /// (See: `LoweringContext::lower_expr()` in `src/librustc/hir/lowering.rs`).\n-    fn is_range_literal(&self, expr: &hir::Expr) -> bool {\n-        use hir::{Path, QPath, ExprKind, TyKind};\n-\n-        // We support `::std::ops::Range` and `::core::ops::Range` prefixes\n-        let is_range_path = |path: &Path| {\n-            let mut segs = path.segments.iter()\n-                .map(|seg| seg.ident.as_str());\n-\n-            if let (Some(root), Some(std_core), Some(ops), Some(range), None) =\n-                (segs.next(), segs.next(), segs.next(), segs.next(), segs.next())\n-            {\n-                // \"{{root}}\" is the equivalent of `::` prefix in Path\n-                root == \"{{root}}\" && (std_core == \"std\" || std_core == \"core\")\n-                    && ops == \"ops\" && range.starts_with(\"Range\")\n-            } else {\n-                false\n-            }\n-        };\n-\n-        let span_is_range_literal = |span: &Span| {\n-            // Check whether a span corresponding to a range expression\n-            // is a range literal, rather than an explicit struct or `new()` call.\n-            let source_map = self.tcx.sess.source_map();\n-            let end_point = source_map.end_point(*span);\n-\n-            if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-                !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-            } else {\n-                false\n-            }\n-        };\n-\n-        match expr.node {\n-            // All built-in range literals but `..=` and `..` desugar to Structs\n-            ExprKind::Struct(ref qpath, _, _) => {\n-                if let QPath::Resolved(None, ref path) = **qpath {\n-                    return is_range_path(&path) && span_is_range_literal(&expr.span);\n-                }\n-            }\n-            // `..` desugars to its struct path\n-            ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-                return is_range_path(&path) && span_is_range_literal(&expr.span);\n-            }\n-\n-            // `..=` desugars into `::std::ops::RangeInclusive::new(...)`\n-            ExprKind::Call(ref func, _) => {\n-                if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n-                    if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n-                        let call_to_new = segment.ident.as_str() == \"new\";\n-\n-                        return is_range_path(&path) && span_is_range_literal(&expr.span)\n-                            && call_to_new;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n     pub fn check_for_cast(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,"}, {"sha": "9634ed56f7b723149d93903a91dc287886a2f2cd", "filename": "src/test/ui/cast_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fcast_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fcast_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -2,9 +2,9 @@\n \n fn main() {\n     const XYZ: char = 0x1F888 as char;\n-    //~^ ERROR only u8 can be cast into char\n+    //~^ ERROR only `u8` can be cast into `char`\n     const XY: char = 129160 as char;\n-    //~^ ERROR only u8 can be cast into char\n+    //~^ ERROR only `u8` can be cast into `char`\n     const ZYX: char = '\\u{01F888}';\n     println!(\"{}\", XYZ);\n }"}, {"sha": "37ef98bcb5067c8fd45ac3638a634d0b675257a9", "filename": "src/test/ui/cast_char.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fcast_char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fcast_char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,20 +1,20 @@\n-error: only u8 can be cast into char\n+error: only `u8` can be cast into `char`\n   --> $DIR/cast_char.rs:4:23\n    |\n LL |     const XYZ: char = 0x1F888 as char;\n-   |                       ^^^^^^^^^^^^^^^ help: use a char literal instead: `'\\u{1F888}'`\n+   |                       ^^^^^^^^^^^^^^^ help: use a `char` literal instead: `'\\u{1F888}'`\n    |\n note: lint level defined here\n   --> $DIR/cast_char.rs:1:9\n    |\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: only u8 can be cast into char\n+error: only `u8` can be cast into `char`\n   --> $DIR/cast_char.rs:6:22\n    |\n LL |     const XY: char = 129160 as char;\n-   |                      ^^^^^^^^^^^^^^ help: use a char literal instead: `'\\u{1F888}'`\n+   |                      ^^^^^^^^^^^^^^ help: use a `char` literal instead: `'\\u{1F888}'`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "85cd73d6f0855e09ba9714472c0d5abf9ae3ae69", "filename": "src/test/ui/enum/enum-discrim-too-small2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -5,28 +5,28 @@\n enum Ei8 {\n     Ai8 = 23,\n     Bi8 = -23,\n-    Ci8 = 223, //~ ERROR literal out of range for i8\n+    Ci8 = 223, //~ ERROR literal out of range for `i8`\n }\n \n #[repr(i16)]\n enum Ei16 {\n     Ai16 = 23,\n     Bi16 = -22333,\n-    Ci16 = 55555, //~ ERROR literal out of range for i16\n+    Ci16 = 55555, //~ ERROR literal out of range for `i16`\n }\n \n #[repr(i32)]\n enum Ei32 {\n     Ai32 = 23,\n     Bi32 = -2_000_000_000,\n-    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32\n+    Ci32 = 3_000_000_000, //~ ERROR literal out of range for `i32`\n }\n \n #[repr(i64)]\n enum Ei64 {\n     Ai64 = 23,\n     Bi64 = -9223372036854775808,\n-    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64\n+    Ci64 = 9223372036854775809, //~ ERROR literal out of range for `i64`\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "f7220044ba42dcf422a53e77f47e8896099dddc7", "filename": "src/test/ui/enum/enum-discrim-too-small2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,4 +1,4 @@\n-error: literal out of range for i8\n+error: literal out of range for `i8`\n   --> $DIR/enum-discrim-too-small2.rs:8:11\n    |\n LL |     Ci8 = 223,\n@@ -10,19 +10,19 @@ note: lint level defined here\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i16\n+error: literal out of range for `i16`\n   --> $DIR/enum-discrim-too-small2.rs:15:12\n    |\n LL |     Ci16 = 55555,\n    |            ^^^^^\n \n-error: literal out of range for i32\n+error: literal out of range for `i32`\n   --> $DIR/enum-discrim-too-small2.rs:22:12\n    |\n LL |     Ci32 = 3_000_000_000,\n    |            ^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n+error: literal out of range for `i64`\n   --> $DIR/enum-discrim-too-small2.rs:29:12\n    |\n LL |     Ci64 = 9223372036854775809,"}, {"sha": "b887f66e94bd6ceff6787c4d30546a3f80eff7c1", "filename": "src/test/ui/lint/deny-overflowing-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x: u8 = 256;\n-    //~^ error: literal out of range for u8\n+    //~^ error: literal out of range for `u8`\n }"}, {"sha": "1263a7bb7fd1b364b2c5799386840ddcc80701c1", "filename": "src/test/ui/lint/deny-overflowing-literals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,4 +1,4 @@\n-error: literal out of range for u8\n+error: literal out of range for `u8`\n   --> $DIR/deny-overflowing-literals.rs:2:17\n    |\n LL |     let x: u8 = 256;"}, {"sha": "7034d56aa5d8350a1c315f1be1927d95901d0492", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -0,0 +1,17 @@\n+#![deny(overflowing_literals)]\n+\n+fn main() {\n+    let range_a = 0..256; //~ ERROR range endpoint is out of range for `u8`\n+    let range_b = 0..=255; // ok\n+    let range_c = 0..=256; //~ ERROR literal out of range for `u8`\n+    let range_d = 256..5; //~ ERROR literal out of range for `u8`\n+    let range_e = 0..257; //~ ERROR literal out of range for `u8`\n+    let _range_f = 0..256u8;  //~ ERROR range endpoint is out of range for `u8`\n+    let _range_g = 0..128i8;  //~ ERROR range endpoint is out of range for `i8`\n+\n+    range_a.collect::<Vec<u8>>();\n+    range_b.collect::<Vec<u8>>();\n+    range_c.collect::<Vec<u8>>();\n+    range_d.collect::<Vec<u8>>();\n+    range_e.collect::<Vec<u8>>();\n+}"}, {"sha": "939451d6bc022edd6446e76b6e08f73f251e0d5a", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -0,0 +1,44 @@\n+error: range endpoint is out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:4:19\n+   |\n+LL |     let range_a = 0..256;\n+   |                   ^^^^^^ help: use an inclusive range instead: `0..=255`\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-range-endpoint-overflow.rs:1:9\n+   |\n+LL | #![deny(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:6:23\n+   |\n+LL |     let range_c = 0..=256;\n+   |                       ^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:7:19\n+   |\n+LL |     let range_d = 256..5;\n+   |                   ^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:8:22\n+   |\n+LL |     let range_e = 0..257;\n+   |                      ^^^\n+\n+error: range endpoint is out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:9:20\n+   |\n+LL |     let _range_f = 0..256u8;\n+   |                    ^^^^^^^^ help: use an inclusive range instead: `0..=255u8`\n+\n+error: range endpoint is out of range for `i8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:10:20\n+   |\n+LL |     let _range_g = 0..128i8;\n+   |                    ^^^^^^^^ help: use an inclusive range instead: `0..=127i8`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "3f90119cd89543d8d39ba015a3802be2c8c485cf", "filename": "src/test/ui/lint/lint-type-limits2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -11,5 +11,5 @@ fn bar() -> i8 {\n \n fn baz() -> bool {\n     128 > bar() //~ ERROR comparison is useless due to type limits\n-                //~| WARN literal out of range for i8\n+                //~| WARN literal out of range for `i8`\n }"}, {"sha": "0b3d292856707cf3097980f1899903b147fc0409", "filename": "src/test/ui/lint/lint-type-limits2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -6,7 +6,7 @@ LL |     128 > bar()\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-limits2.rs:13:5\n    |\n LL |     128 > bar()"}, {"sha": "ceecf9ab30bb8f0b82cdf4d50115dc0069ac7d64", "filename": "src/test/ui/lint/lint-type-limits3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -7,7 +7,7 @@ fn main() { }\n fn qux() {\n     let mut i = 1i8;\n     while 200 != i { //~ ERROR comparison is useless due to type limits\n-                     //~| WARN literal out of range for i8\n+                     //~| WARN literal out of range for `i8`\n         i += 1;\n     }\n }"}, {"sha": "70cd9c859ecf30d9d248080267b89ddba6b700d9", "filename": "src/test/ui/lint/lint-type-limits3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -6,7 +6,7 @@ LL |     while 200 != i {\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-limits3.rs:9:11\n    |\n LL |     while 200 != i {"}, {"sha": "9672da6d3586cdac57cc37b40e0f8db8a4f3d49c", "filename": "src/test/ui/lint/lint-type-overflow.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,5 +1,3 @@\n-//\n-\n #![deny(overflowing_literals)]\n \n fn test(x: i8) {\n@@ -9,39 +7,39 @@ fn test(x: i8) {\n #[allow(unused_variables)]\n fn main() {\n     let x1: u8 = 255; // should be OK\n-    let x1: u8 = 256; //~ error: literal out of range for u8\n+    let x1: u8 = 256; //~ error: literal out of range for `u8`\n \n     let x1 = 255_u8; // should be OK\n-    let x1 = 256_u8; //~ error: literal out of range for u8\n+    let x1 = 256_u8; //~ error: literal out of range for `u8`\n \n     let x2: i8 = -128; // should be OK\n-    let x1: i8 = 128; //~ error: literal out of range for i8\n+    let x1: i8 = 128; //~ error: literal out of range for `i8`\n \n-    let x3: i8 = -129; //~ error: literal out of range for i8\n-    let x3: i8 = -(129); //~ error: literal out of range for i8\n-    let x3: i8 = -{129}; //~ error: literal out of range for i8\n+    let x3: i8 = -129; //~ error: literal out of range for `i8`\n+    let x3: i8 = -(129); //~ error: literal out of range for `i8`\n+    let x3: i8 = -{129}; //~ error: literal out of range for `i8`\n \n-    test(1000); //~ error: literal out of range for i8\n+    test(1000); //~ error: literal out of range for `i8`\n \n-    let x = 128_i8; //~ error: literal out of range for i8\n+    let x = 128_i8; //~ error: literal out of range for `i8`\n     let x = 127_i8;\n     let x = -128_i8;\n     let x = -(128_i8);\n-    let x = -129_i8; //~ error: literal out of range for i8\n+    let x = -129_i8; //~ error: literal out of range for `i8`\n \n     let x: i32 = 2147483647; // should be OK\n     let x = 2147483647_i32; // should be OK\n-    let x: i32 = 2147483648; //~ error: literal out of range for i32\n-    let x = 2147483648_i32; //~ error: literal out of range for i32\n+    let x: i32 = 2147483648; //~ error: literal out of range for `i32`\n+    let x = 2147483648_i32; //~ error: literal out of range for `i32`\n     let x: i32 = -2147483648; // should be OK\n     let x = -2147483648_i32; // should be OK\n-    let x: i32 = -2147483649; //~ error: literal out of range for i32\n-    let x = -2147483649_i32; //~ error: literal out of range for i32\n-    let x = 2147483648; //~ error: literal out of range for i32\n+    let x: i32 = -2147483649; //~ error: literal out of range for `i32`\n+    let x = -2147483649_i32; //~ error: literal out of range for `i32`\n+    let x = 2147483648; //~ error: literal out of range for `i32`\n \n-    let x = 9223372036854775808_i64; //~ error: literal out of range for i64\n+    let x = 9223372036854775808_i64; //~ error: literal out of range for `i64`\n     let x = -9223372036854775808_i64; // should be OK\n-    let x = 18446744073709551615_i64; //~ error: literal out of range for i64\n-    let x: i64 = -9223372036854775809; //~ error: literal out of range for i64\n-    let x = -9223372036854775809_i64; //~ error: literal out of range for i64\n+    let x = 18446744073709551615_i64; //~ error: literal out of range for `i64`\n+    let x: i64 = -9223372036854775809; //~ error: literal out of range for `i64`\n+    let x = -9223372036854775809_i64; //~ error: literal out of range for `i64`\n }"}, {"sha": "6fcd9b58b2dc766665996364f72f749a0693d712", "filename": "src/test/ui/lint/lint-type-overflow.stderr", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,113 +1,113 @@\n-error: literal out of range for u8\n-  --> $DIR/lint-type-overflow.rs:12:18\n+error: literal out of range for `u8`\n+  --> $DIR/lint-type-overflow.rs:10:18\n    |\n LL |     let x1: u8 = 256;\n    |                  ^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-type-overflow.rs:3:9\n+  --> $DIR/lint-type-overflow.rs:1:9\n    |\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for u8\n-  --> $DIR/lint-type-overflow.rs:15:14\n+error: literal out of range for `u8`\n+  --> $DIR/lint-type-overflow.rs:13:14\n    |\n LL |     let x1 = 256_u8;\n    |              ^^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:18:18\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:16:18\n    |\n LL |     let x1: i8 = 128;\n    |                  ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:20:19\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:18:19\n    |\n LL |     let x3: i8 = -129;\n    |                   ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:21:19\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:19:19\n    |\n LL |     let x3: i8 = -(129);\n    |                   ^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:22:20\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:20:20\n    |\n LL |     let x3: i8 = -{129};\n    |                    ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:24:10\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:22:10\n    |\n LL |     test(1000);\n    |          ^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:26:13\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:24:13\n    |\n LL |     let x = 128_i8;\n    |             ^^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:30:14\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:28:14\n    |\n LL |     let x = -129_i8;\n    |              ^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:34:18\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:32:18\n    |\n LL |     let x: i32 = 2147483648;\n    |                  ^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:35:13\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:33:13\n    |\n LL |     let x = 2147483648_i32;\n    |             ^^^^^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:38:19\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:36:19\n    |\n LL |     let x: i32 = -2147483649;\n    |                   ^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:39:14\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:37:14\n    |\n LL |     let x = -2147483649_i32;\n    |              ^^^^^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:40:13\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:38:13\n    |\n LL |     let x = 2147483648;\n    |             ^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:42:13\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:40:13\n    |\n LL |     let x = 9223372036854775808_i64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:44:13\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:42:13\n    |\n LL |     let x = 18446744073709551615_i64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:45:19\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:43:19\n    |\n LL |     let x: i64 = -9223372036854775809;\n    |                   ^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:46:14\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:44:14\n    |\n LL |     let x = -9223372036854775809_i64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c76e9e25d5a93207b554e968db811c186d326f38", "filename": "src/test/ui/lint/lint-type-overflow2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,4 +1,4 @@\n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-overflow2.rs:9:20\n    |\n LL |     let x2: i8 = --128;\n@@ -10,25 +10,25 @@ note: lint level defined here\n LL | #![warn(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f32\n+warning: literal out of range for `f32`\n   --> $DIR/lint-type-overflow2.rs:11:14\n    |\n LL |     let x = -3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f32\n+warning: literal out of range for `f32`\n   --> $DIR/lint-type-overflow2.rs:12:14\n    |\n LL |     let x =  3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f64\n+warning: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:13:14\n    |\n LL |     let x = -1.7976931348623159e+308_f64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f64\n+warning: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:14:14\n    |\n LL |     let x =  1.7976931348623159e+308_f64;"}, {"sha": "dabfb876fbb924b53b262bd487114bb0b3b85f6e", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d78142bf05ae8848101190cf5410ea02ef47226/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=6d78142bf05ae8848101190cf5410ea02ef47226", "patch": "@@ -1,4 +1,4 @@\n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/type-overflow.rs:5:17\n    |\n LL |     let error = 255i8;"}]}