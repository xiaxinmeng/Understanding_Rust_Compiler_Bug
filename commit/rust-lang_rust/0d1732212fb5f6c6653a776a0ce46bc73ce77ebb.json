{"sha": "0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMTczMjIxMmZiNWY2YzY2NTNhNzc2YTBjZTQ2YmM3M2NlNzdlYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-20T12:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-20T12:18:49Z"}, "message": "Auto merge of #59564 - bjorn3:move_link_to_cg_ssa, r=eddyb\n\nMove back::link and debuginfo::type_names to cg ssa\n\nr? @eddyb", "tree": {"sha": "b1ea21466b0b6133dc027eb1272d46c3b784c9be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ea21466b0b6133dc027eb1272d46c3b784c9be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "html_url": "https://github.com/rust-lang/rust/commit/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "647a951b084e5718b37bb97cd36760918e37c2f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/647a951b084e5718b37bb97cd36760918e37c2f0", "html_url": "https://github.com/rust-lang/rust/commit/647a951b084e5718b37bb97cd36760918e37c2f0"}, {"sha": "3af60e09a1bca5f335e2f2994c45095e1800eede", "url": "https://api.github.com/repos/rust-lang/rust/commits/3af60e09a1bca5f335e2f2994c45095e1800eede", "html_url": "https://github.com/rust-lang/rust/commit/3af60e09a1bca5f335e2f2994c45095e1800eede"}], "stats": {"total": 3219, "additions": 1620, "deletions": 1599}, "files": [{"sha": "72a05753d097a835a70ebd14380b24968e13388a", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -2634,6 +2634,7 @@ dependencies = [\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "e0e26e9af2537796bdb37428eb82076f4cc34196", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -7,14 +7,13 @@ use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n-use crate::back::bytecode::RLIB_BYTECODE_EXTENSION;\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind};\n-use crate::metadata::METADATA_FILENAME;\n-use rustc_codegen_ssa::back::archive::find_library;\n+use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n use rustc::session::Session;\n \n-pub struct ArchiveConfig<'a> {\n+struct ArchiveConfig<'a> {\n     pub sess: &'a Session,\n     pub dst: PathBuf,\n     pub src: Option<PathBuf>,\n@@ -23,7 +22,7 @@ pub struct ArchiveConfig<'a> {\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n-pub struct ArchiveBuilder<'a> {\n+pub struct LlvmArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n     removals: Vec<String>,\n     additions: Vec<Addition>,\n@@ -49,11 +48,26 @@ fn is_relevant_child(c: &Child<'_>) -> bool {\n     }\n }\n \n-impl<'a> ArchiveBuilder<'a> {\n+fn archive_config<'a>(sess: &'a Session,\n+                      output: &Path,\n+                      input: Option<&Path>) -> ArchiveConfig<'a> {\n+    use rustc_codegen_ssa::back::link::archive_search_paths;\n+    ArchiveConfig {\n+        sess,\n+        dst: output.to_path_buf(),\n+        src: input.map(|p| p.to_path_buf()),\n+        lib_search_paths: archive_search_paths(sess),\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     /// Creates a new static archive, ready for modifying the archive specified\n     /// by `config`.\n-    pub fn new(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n-        ArchiveBuilder {\n+    fn new(sess: &'a Session,\n+            output: &Path,\n+            input: Option<&Path>) -> LlvmArchiveBuilder<'a> {\n+        let config = archive_config(sess, output, input);\n+        LlvmArchiveBuilder {\n             config,\n             removals: Vec::new(),\n             additions: Vec::new(),\n@@ -63,12 +77,12 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     /// Removes a file from this archive\n-    pub fn remove_file(&mut self, file: &str) {\n+    fn remove_file(&mut self, file: &str) {\n         self.removals.push(file.to_string());\n     }\n \n     /// Lists all files in an archive\n-    pub fn src_files(&mut self) -> Vec<String> {\n+    fn src_files(&mut self) -> Vec<String> {\n         if self.src_archive().is_none() {\n             return Vec::new()\n         }\n@@ -84,18 +98,9 @@ impl<'a> ArchiveBuilder<'a> {\n                .collect()\n     }\n \n-    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n-        if let Some(ref a) = self.src_archive {\n-            return a.as_ref()\n-        }\n-        let src = self.config.src.as_ref()?;\n-        self.src_archive = Some(ArchiveRO::open(src).ok());\n-        self.src_archive.as_ref().unwrap().as_ref()\n-    }\n-\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) {\n+    fn add_native_library(&mut self, name: &str) {\n         let location = find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n@@ -109,7 +114,7 @@ impl<'a> ArchiveBuilder<'a> {\n     ///\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self,\n+    fn add_rlib(&mut self,\n                     rlib: &Path,\n                     name: &str,\n                     lto: bool,\n@@ -141,23 +146,8 @@ impl<'a> ArchiveBuilder<'a> {\n         })\n     }\n \n-    fn add_archive<F>(&mut self, archive: &Path, skip: F)\n-                      -> io::Result<()>\n-        where F: FnMut(&str) -> bool + 'static\n-    {\n-        let archive = match ArchiveRO::open(archive) {\n-            Ok(ar) => ar,\n-            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n-        };\n-        self.additions.push(Addition::Archive {\n-            archive,\n-            skip: Box::new(skip),\n-        });\n-        Ok(())\n-    }\n-\n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path) {\n+    fn add_file(&mut self, file: &Path) {\n         let name = file.file_name().unwrap().to_str().unwrap();\n         self.additions.push(Addition::File {\n             path: file.to_path_buf(),\n@@ -167,13 +157,13 @@ impl<'a> ArchiveBuilder<'a> {\n \n     /// Indicate that the next call to `build` should update all symbols in\n     /// the archive (equivalent to running 'ar s' over it).\n-    pub fn update_symbols(&mut self) {\n+    fn update_symbols(&mut self) {\n         self.should_update_symbols = true;\n     }\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    pub fn build(&mut self) {\n+    fn build(mut self) {\n         let kind = self.llvm_archive_kind().unwrap_or_else(|kind|\n             self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind)));\n \n@@ -182,6 +172,32 @@ impl<'a> ArchiveBuilder<'a> {\n         }\n \n     }\n+}\n+\n+impl<'a> LlvmArchiveBuilder<'a> {\n+    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n+        if let Some(ref a) = self.src_archive {\n+            return a.as_ref()\n+        }\n+        let src = self.config.src.as_ref()?;\n+        self.src_archive = Some(ArchiveRO::open(src).ok());\n+        self.src_archive.as_ref().unwrap().as_ref()\n+    }\n+\n+    fn add_archive<F>(&mut self, archive: &Path, skip: F)\n+                      -> io::Result<()>\n+        where F: FnMut(&str) -> bool + 'static\n+    {\n+        let archive = match ArchiveRO::open(archive) {\n+            Ok(ar) => ar,\n+            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n+        };\n+        self.additions.push(Addition::Archive {\n+            archive,\n+            skip: Box::new(skip),\n+        });\n+        Ok(())\n+    }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n         let kind = &*self.config.sess.target.target.options.archive_format;"}, {"sha": "397cdecbb6f77563b59acc48c27e4410dc4f57e6", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -37,8 +37,6 @@ pub const RLIB_BYTECODE_OBJECT_MAGIC: &[u8] = b\"RUST_OBJECT\";\n // The version number this compiler will write to bytecode objects in rlibs\n pub const RLIB_BYTECODE_OBJECT_VERSION: u8 = 2;\n \n-pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n-\n pub fn encode(identifier: &str, bytecode: &[u8]) -> Vec<u8> {\n     let mut encoded = Vec::new();\n "}, {"sha": "6a3c2adc856188527db92e97cee6230b69eb560e", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "removed", "additions": 0, "deletions": 1494, "changes": 1494, "blob_url": "https://github.com/rust-lang/rust/blob/647a951b084e5718b37bb97cd36760918e37c2f0/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a951b084e5718b37bb97cd36760918e37c2f0/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=647a951b084e5718b37bb97cd36760918e37c2f0", "patch": "@@ -1,1494 +0,0 @@\n-use super::archive::{ArchiveBuilder, ArchiveConfig};\n-use super::bytecode::RLIB_BYTECODE_EXTENSION;\n-use super::rpath::RPathConfig;\n-use super::rpath;\n-use crate::back::wasm;\n-use crate::metadata::METADATA_FILENAME;\n-use crate::context::get_reloc_model;\n-use crate::llvm;\n-use rustc_codegen_ssa::back::linker::Linker;\n-use rustc_codegen_ssa::back::link::{remove, ignored_for_lto, each_linked_rlib, linker_and_flavor,\n-    get_linker};\n-use rustc_codegen_ssa::back::command::Command;\n-use rustc::session::config::{self, DebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::{RUST_CGU_EXT, Lto, Sanitizer};\n-use rustc::session::filesearch;\n-use rustc::session::search_paths::PathKind;\n-use rustc::session::Session;\n-use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n-use rustc::middle::dependency_format::Linkage;\n-use rustc_codegen_ssa::CodegenResults;\n-use rustc::util::common::{time, time_ext};\n-use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc::hir::def_id::CrateNum;\n-use tempfile::{Builder as TempFileBuilder, TempDir};\n-use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n-use rustc_data_structures::fx::FxHashSet;\n-\n-use std::ascii;\n-use std::char;\n-use std::env;\n-use std::fmt;\n-use std::fs;\n-use std::io;\n-use std::iter;\n-use std::path::{Path, PathBuf};\n-use std::process::{Output, Stdio};\n-use std::str;\n-use syntax::attr;\n-\n-pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                    invalid_output_for_target, filename_for_metadata,\n-                                    out_filename, check_file_is_writeable};\n-\n-\n-/// Performs the linkage portion of the compilation phase. This will generate all\n-/// of the requested outputs for this compilation session.\n-pub(crate) fn link_binary(sess: &Session,\n-                          codegen_results: &CodegenResults,\n-                          outputs: &OutputFilenames,\n-                          crate_name: &str) -> Vec<PathBuf> {\n-    let mut out_filenames = Vec::new();\n-    for &crate_type in sess.crate_types.borrow().iter() {\n-        // Ignore executable crates if we have -Z no-codegen, as they will error.\n-        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n-        if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n-           !output_metadata &&\n-           crate_type == config::CrateType::Executable {\n-            continue;\n-        }\n-\n-        if invalid_output_for_target(sess, crate_type) {\n-           bug!(\"invalid output type `{:?}` for target os `{}`\",\n-                crate_type, sess.opts.target_triple);\n-        }\n-        let out_files = link_binary_output(sess,\n-                                           codegen_results,\n-                                           crate_type,\n-                                           outputs,\n-                                           crate_name);\n-        out_filenames.extend(out_files);\n-    }\n-\n-    // Remove the temporary object file and metadata if we aren't saving temps\n-    if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n-            for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-                remove(sess, obj);\n-            }\n-        }\n-        for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n-            remove(sess, obj);\n-        }\n-        if let Some(ref obj) = codegen_results.metadata_module.object {\n-            remove(sess, obj);\n-        }\n-        if let Some(ref allocator) = codegen_results.allocator_module {\n-            if let Some(ref obj) = allocator.object {\n-                remove(sess, obj);\n-            }\n-            if let Some(ref bc) = allocator.bytecode_compressed {\n-                remove(sess, bc);\n-            }\n-        }\n-    }\n-\n-    out_filenames\n-}\n-\n-/// Returns a boolean indicating whether we should preserve the object files on\n-/// the filesystem for their debug information. This is often useful with\n-/// split-dwarf like schemes.\n-fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n-    // If the objects don't have debuginfo there's nothing to preserve.\n-    if sess.opts.debuginfo == DebugInfo::None {\n-        return false\n-    }\n-\n-    // If we're only producing artifacts that are archives, no need to preserve\n-    // the objects as they're losslessly contained inside the archives.\n-    let output_linked = sess.crate_types.borrow()\n-        .iter()\n-        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n-    if !output_linked {\n-        return false\n-    }\n-\n-    // If we're on OSX then the equivalent of split dwarf is turned on by\n-    // default. The final executable won't actually have any debug information\n-    // except it'll have pointers to elsewhere. Historically we've always run\n-    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n-    // a bummer for incremental compilation! (the whole point of split dwarf is\n-    // that you don't do this sort of dwarf link).\n-    //\n-    // Basically as a result this just means that if we're on OSX and we're\n-    // *not* running dsymutil then the object files are the only source of truth\n-    // for debug information, so we must preserve them.\n-    if sess.target.target.options.is_like_osx {\n-        match sess.opts.debugging_opts.run_dsymutil {\n-            // dsymutil is not being run, preserve objects\n-            Some(false) => return true,\n-\n-            // dsymutil is being run, no need to preserve the objects\n-            Some(true) => return false,\n-\n-            // The default historical behavior was to always run dsymutil, so\n-            // we're preserving that temporarily, but we're likely to switch the\n-            // default soon.\n-            None => return false,\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn link_binary_output(sess: &Session,\n-                      codegen_results: &CodegenResults,\n-                      crate_type: config::CrateType,\n-                      outputs: &OutputFilenames,\n-                      crate_name: &str) -> Vec<PathBuf> {\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        check_file_is_writeable(obj, sess);\n-    }\n-\n-    let mut out_filenames = vec![];\n-\n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with a `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-        if let Err(e) = fs::rename(metadata, &out_filename) {\n-            sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-        }\n-        out_filenames.push(out_filename);\n-    }\n-\n-    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n-        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n-    if outputs.outputs.should_codegen() {\n-        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n-        match crate_type {\n-            config::CrateType::Rlib => {\n-                link_rlib(sess,\n-                          codegen_results,\n-                          RlibFlavor::Normal,\n-                          &out_filename,\n-                          &tmpdir).build();\n-            }\n-            config::CrateType::Staticlib => {\n-                link_staticlib(sess, codegen_results, &out_filename, &tmpdir);\n-            }\n-            _ => {\n-                link_natively(sess, crate_type, &out_filename, codegen_results, tmpdir.path());\n-            }\n-        }\n-        out_filenames.push(out_filename);\n-    }\n-\n-    if sess.opts.cg.save_temps {\n-        let _ = tmpdir.into_path();\n-    }\n-\n-    out_filenames\n-}\n-\n-fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n-    sess.target_filesearch(PathKind::Native).search_path_dirs()\n-}\n-\n-fn archive_config<'a>(sess: &'a Session,\n-                      output: &Path,\n-                      input: Option<&Path>) -> ArchiveConfig<'a> {\n-    ArchiveConfig {\n-        sess,\n-        dst: output.to_path_buf(),\n-        src: input.map(|p| p.to_path_buf()),\n-        lib_search_paths: archive_search_paths(sess),\n-    }\n-}\n-\n-/// We use a temp directory here to avoid races between concurrent rustc processes,\n-/// such as builds in the same directory using the same filename for metadata while\n-/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n-/// directory being searched for `extern crate` (observing an incomplete file).\n-/// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(\n-    sess: &'a Session,\n-    codegen_results: &CodegenResults,\n-    tmpdir: &TempDir\n-) -> PathBuf {\n-    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n-\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-    }\n-\n-    out_filename\n-}\n-\n-enum RlibFlavor {\n-    Normal,\n-    StaticlibBase,\n-}\n-\n-// Create an 'rlib'\n-//\n-// An rlib in its current incarnation is essentially a renamed .a file. The\n-// rlib primarily contains the object file of the crate, but it also contains\n-// all of the object files from native libraries. This is done by unzipping\n-// native libraries and inserting all of the contents into this archive.\n-fn link_rlib<'a>(sess: &'a Session,\n-                 codegen_results: &CodegenResults,\n-                 flavor: RlibFlavor,\n-                 out_filename: &Path,\n-                 tmpdir: &TempDir) -> ArchiveBuilder<'a> {\n-    info!(\"preparing rlib to {:?}\", out_filename);\n-    let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n-\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        ab.add_file(obj);\n-    }\n-\n-    // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n-    // we may not be configured to actually include a static library if we're\n-    // adding it here. That's because later when we consume this rlib we'll\n-    // decide whether we actually needed the static library or not.\n-    //\n-    // To do this \"correctly\" we'd need to keep track of which libraries added\n-    // which object files to the archive. We don't do that here, however. The\n-    // #[link(cfg(..))] feature is unstable, though, and only intended to get\n-    // liblibc working. In that sense the check below just indicates that if\n-    // there are any libraries we want to omit object files for at link time we\n-    // just exclude all custom object files.\n-    //\n-    // Eventually if we want to stabilize or flesh out the #[link(cfg(..))]\n-    // feature then we'll need to figure out how to record what objects were\n-    // loaded from the libraries found here and then encode that into the\n-    // metadata of the rlib we're generating somehow.\n-    for lib in codegen_results.crate_info.used_libraries.iter() {\n-        match lib.kind {\n-            NativeLibraryKind::NativeStatic => {}\n-            NativeLibraryKind::NativeStaticNobundle |\n-            NativeLibraryKind::NativeFramework |\n-            NativeLibraryKind::NativeUnknown => continue,\n-        }\n-        if let Some(name) = lib.name {\n-            ab.add_native_library(&name.as_str());\n-        }\n-    }\n-\n-    // After adding all files to the archive, we need to update the\n-    // symbol table of the archive.\n-    ab.update_symbols();\n-\n-    // Note that it is important that we add all of our non-object \"magical\n-    // files\" *after* all of the object files in the archive. The reason for\n-    // this is as follows:\n-    //\n-    // * When performing LTO, this archive will be modified to remove\n-    //   objects from above. The reason for this is described below.\n-    //\n-    // * When the system linker looks at an archive, it will attempt to\n-    //   determine the architecture of the archive in order to see whether its\n-    //   linkable.\n-    //\n-    //   The algorithm for this detection is: iterate over the files in the\n-    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n-    //   object file. Read architecture from the object file.\n-    //\n-    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n-    //   before all of the objects, then the architecture of this archive would\n-    //   not be correctly inferred once 'foo.o' is removed.\n-    //\n-    // Basically, all this means is that this code should not move above the\n-    // code above.\n-    match flavor {\n-        RlibFlavor::Normal => {\n-            // Instead of putting the metadata in an object file section, rlibs\n-            // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n-\n-            // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.\n-            for bytecode in codegen_results\n-                .modules\n-                .iter()\n-                .filter_map(|m| m.bytecode_compressed.as_ref())\n-            {\n-                ab.add_file(bytecode);\n-            }\n-\n-            // After adding all files to the archive, we need to update the\n-            // symbol table of the archive. This currently dies on macOS (see\n-            // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx {\n-                ab.update_symbols();\n-            }\n-        }\n-\n-        RlibFlavor::StaticlibBase => {\n-            let obj = codegen_results.allocator_module\n-                .as_ref()\n-                .and_then(|m| m.object.as_ref());\n-            if let Some(obj) = obj {\n-                ab.add_file(obj);\n-            }\n-        }\n-    }\n-\n-    ab\n-}\n-\n-// Create a static archive\n-//\n-// This is essentially the same thing as an rlib, but it also involves adding\n-// all of the upstream crates' objects into the archive. This will slurp in\n-// all of the native libraries of upstream dependencies as well.\n-//\n-// Additionally, there's no way for us to link dynamic libraries, so we warn\n-// about all dynamic library dependencies that they're not linked in.\n-//\n-// There's no need to include metadata in a static archive, so ensure to not\n-// link in the metadata object file (and also don't prepare the archive with a\n-// metadata file).\n-fn link_staticlib(sess: &Session,\n-                  codegen_results: &CodegenResults,\n-                  out_filename: &Path,\n-                  tempdir: &TempDir) {\n-    let mut ab = link_rlib(sess,\n-                           codegen_results,\n-                           RlibFlavor::StaticlibBase,\n-                           out_filename,\n-                           tempdir);\n-    let mut all_native_libs = vec![];\n-\n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n-        let name = &codegen_results.crate_info.crate_name[&cnum];\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-\n-        // Here when we include the rlib into our staticlib we need to make a\n-        // decision whether to include the extra object files along the way.\n-        // These extra object files come from statically included native\n-        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n-        //\n-        // This unstable feature, though, only needs liblibc to work. The only\n-        // use case there is where musl is statically included in liblibc.rlib,\n-        // so if we don't want the included version we just need to skip it. As\n-        // a result the logic here is that if *any* linked library is cfg'd away\n-        // we just skip all object files.\n-        //\n-        // Clearly this is not sufficient for a general purpose feature, and\n-        // we'd want to read from the library's metadata to determine which\n-        // object files come from where and selectively skip them.\n-        let skip_object_files = native_libs.iter().any(|lib| {\n-            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n-        });\n-        ab.add_rlib(path,\n-                    &name.as_str(),\n-                    are_upstream_rust_objects_already_included(sess) &&\n-                        !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n-                    skip_object_files).unwrap();\n-\n-        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n-    });\n-    if let Err(e) = res {\n-        sess.fatal(&e);\n-    }\n-\n-    ab.update_symbols();\n-    ab.build();\n-\n-    if !all_native_libs.is_empty() {\n-        if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n-            print_native_static_libs(sess, &all_native_libs);\n-        }\n-    }\n-}\n-\n-fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n-    let lib_args: Vec<_> = all_native_libs.iter()\n-        .filter(|l| relevant_lib(sess, l))\n-        .filter_map(|lib| {\n-            let name = lib.name?;\n-            match lib.kind {\n-                NativeLibraryKind::NativeStaticNobundle |\n-                NativeLibraryKind::NativeUnknown => {\n-                    if sess.target.target.options.is_like_msvc {\n-                        Some(format!(\"{}.lib\", name))\n-                    } else {\n-                        Some(format!(\"-l{}\", name))\n-                    }\n-                },\n-                NativeLibraryKind::NativeFramework => {\n-                    // ld-only syntax, since there are no frameworks in MSVC\n-                    Some(format!(\"-framework {}\", name))\n-                },\n-                // These are included, no need to print them\n-                NativeLibraryKind::NativeStatic => None,\n-            }\n-        })\n-        .collect();\n-    if !lib_args.is_empty() {\n-        sess.note_without_error(\"Link against the following native artifacts when linking \\\n-                                 against this static library. The order and any duplication \\\n-                                 can be significant on some platforms.\");\n-        // Prefix for greppability\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n-    }\n-}\n-\n-fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n-    let fs = sess.target_filesearch(PathKind::Native);\n-    let file_path = fs.get_lib_path().join(name);\n-    if file_path.exists() {\n-        return file_path\n-    }\n-    for search_path in fs.search_paths() {\n-        let file_path = search_path.dir.join(name);\n-        if file_path.exists() {\n-            return file_path\n-        }\n-    }\n-    PathBuf::from(name)\n-}\n-\n-// Create a dynamic library or executable\n-//\n-// This will invoke the system linker/cc to create the resulting file. This\n-// links to all upstream files as well.\n-fn link_natively(sess: &Session,\n-                 crate_type: config::CrateType,\n-                 out_filename: &Path,\n-                 codegen_results: &CodegenResults,\n-                 tmpdir: &Path) {\n-    info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static() {\n-            cmd.args(args);\n-        }\n-    }\n-    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n-\n-    if sess.target.target.options.is_like_fuchsia {\n-        let prefix = match sess.opts.debugging_opts.sanitizer {\n-            Some(Sanitizer::Address) => \"asan/\",\n-            _ => \"\",\n-        };\n-        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n-    }\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n-\n-    {\n-        let target_cpu = crate::llvm_util::target_cpu(sess);\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_args(&mut *linker, flavor, sess, crate_type, tmpdir,\n-                  out_filename, codegen_results);\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-    if sess.crt_static() {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for &(ref k, ref v) in &sess.target.target.options.link_env {\n-        cmd.env(k, v);\n-    }\n-\n-    if sess.opts.debugging_opts.print_link_args {\n-        println!(\"{:?}\", &cmd);\n-    }\n-\n-    // May have not found libraries in the right formats.\n-    sess.abort_if_errors();\n-\n-    // Invoke the system linker\n-    //\n-    // Note that there's a terribly awful hack that really shouldn't be present\n-    // in any compiler. Here an environment variable is supported to\n-    // automatically retry the linker invocation if the linker looks like it\n-    // segfaulted.\n-    //\n-    // Gee that seems odd, normally segfaults are things we want to know about!\n-    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n-    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n-    // pain to land PRs when they spuriously fail due to a segfault.\n-    //\n-    // The issue #38878 has some more debugging information on it as well, but\n-    // this unfortunately looks like it's just a race condition in macOS's linker\n-    // with some thread pool working in the background. It seems that no one\n-    // currently knows a fix for this so in the meantime we're left with this...\n-    info!(\"{:?}\", &cmd);\n-    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n-    let mut prog;\n-    let mut i = 0;\n-    loop {\n-        i += 1;\n-        prog = time(sess, \"running linker\", || {\n-            exec_linker(sess, &mut cmd, out_filename, tmpdir)\n-        });\n-        let output = match prog {\n-            Ok(ref output) => output,\n-            Err(_) => break,\n-        };\n-        if output.status.success() {\n-            break\n-        }\n-        let mut out = output.stderr.clone();\n-        out.extend(&output.stdout);\n-        let out = String::from_utf8_lossy(&out);\n-\n-        // Check to see if the link failed with \"unrecognized command line option:\n-        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n-        // reperform the link step without the -no-pie option. This is safe because\n-        // if the linker doesn't support -no-pie then it should not default to\n-        // linking executables as pie. Different versions of gcc seem to use\n-        // different quotes in the error message so don't check for them.\n-        if sess.target.target.options.linker_is_gnu &&\n-           flavor != LinkerFlavor::Ld &&\n-           (out.contains(\"unrecognized command line option\") ||\n-            out.contains(\"unknown argument\")) &&\n-           out.contains(\"-no-pie\") &&\n-           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n-            info!(\"linker output: {:?}\", out);\n-            warn!(\"Linker does not support -no-pie command line option. Retrying without.\");\n-            for arg in cmd.take_args() {\n-                if arg.to_string_lossy() != \"-no-pie\" {\n-                    cmd.arg(arg);\n-                }\n-            }\n-            info!(\"{:?}\", &cmd);\n-            continue;\n-        }\n-        if !retry_on_segfault || i > 3 {\n-            break\n-        }\n-        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n-        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n-        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n-            break\n-        }\n-\n-        warn!(\n-            \"looks like the linker segfaulted when we tried to call it, \\\n-             automatically retrying again. cmd = {:?}, out = {}.\",\n-            cmd,\n-            out,\n-        );\n-    }\n-\n-    match prog {\n-        Ok(prog) => {\n-            fn escape_string(s: &[u8]) -> String {\n-                str::from_utf8(s).map(|s| s.to_owned())\n-                    .unwrap_or_else(|_| {\n-                        let mut x = \"Non-UTF-8 output: \".to_string();\n-                        x.extend(s.iter()\n-                                  .flat_map(|&b| ascii::escape_default(b))\n-                                  .map(char::from));\n-                        x\n-                    })\n-            }\n-            if !prog.status.success() {\n-                let mut output = prog.stderr.clone();\n-                output.extend_from_slice(&prog.stdout);\n-                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname.display(),\n-                                         prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(&escape_string(&output))\n-                    .emit();\n-                sess.abort_if_errors();\n-            }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n-        },\n-        Err(e) => {\n-            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n-\n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n-                } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n-            }\n-\n-            linker_error.emit();\n-\n-            if sess.target.target.options.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n-                    but `link.exe` was not found\");\n-                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n-                    was installed with the Visual C++ option\");\n-            }\n-            sess.abort_if_errors();\n-        }\n-    }\n-\n-\n-    // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols. Note, though, that if the object files are being preserved\n-    // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.target.options.is_like_osx &&\n-        sess.opts.debuginfo != DebugInfo::None &&\n-        !preserve_objects_for_their_debuginfo(sess)\n-    {\n-        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n-            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n-        }\n-    }\n-\n-    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        wasm::add_producer_section(\n-            &out_filename,\n-            &sess.edition().to_string(),\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n-        );\n-    }\n-}\n-\n-fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n-    -> io::Result<Output>\n-{\n-    // When attempting to spawn the linker we run a risk of blowing out the\n-    // size limits for spawning a new process with respect to the arguments\n-    // we pass on the command line.\n-    //\n-    // Here we attempt to handle errors from the OS saying \"your list of\n-    // arguments is too big\" by reinvoking the linker again with an `@`-file\n-    // that contains all the arguments. The theory is that this is then\n-    // accepted on all linkers and the linker will read all its options out of\n-    // there instead of looking at the command line.\n-    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n-        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n-            Ok(child) => {\n-                let output = child.wait_with_output();\n-                flush_linked_file(&output, out_filename)?;\n-                return output;\n-            }\n-            Err(ref e) if command_line_too_big(e) => {\n-                info!(\"command line to linker was too big: {}\", e);\n-            }\n-            Err(e) => return Err(e)\n-        }\n-    }\n-\n-    info!(\"falling back to passing arguments to linker via an @-file\");\n-    let mut cmd2 = cmd.clone();\n-    let mut args = String::new();\n-    for arg in cmd2.take_args() {\n-        args.push_str(&Escape {\n-            arg: arg.to_str().unwrap(),\n-            is_like_msvc: sess.target.target.options.is_like_msvc,\n-        }.to_string());\n-        args.push_str(\"\\n\");\n-    }\n-    let file = tmpdir.join(\"linker-arguments\");\n-    let bytes = if sess.target.target.options.is_like_msvc {\n-        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n-        // start the stream with a UTF-16 BOM\n-        for c in iter::once(0xFEFF).chain(args.encode_utf16()) {\n-            // encode in little endian\n-            out.push(c as u8);\n-            out.push((c >> 8) as u8);\n-        }\n-        out\n-    } else {\n-        args.into_bytes()\n-    };\n-    fs::write(&file, &bytes)?;\n-    cmd2.arg(format!(\"@{}\", file.display()));\n-    info!(\"invoking linker {:?}\", cmd2);\n-    let output = cmd2.output();\n-    flush_linked_file(&output, out_filename)?;\n-    return output;\n-\n-    #[cfg(unix)]\n-    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(windows)]\n-    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n-        -> io::Result<()>\n-    {\n-        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n-        // even long after process exit, causing nasty, non-reproducible output bugs.\n-        //\n-        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n-        //\n-        // \u0410 full writeup of the original Chrome bug can be found at\n-        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n-\n-        if let &Ok(ref out) = command_output {\n-            if out.status.success() {\n-                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n-                    of.sync_all()?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[cfg(unix)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        err.raw_os_error() == Some(::libc::E2BIG)\n-    }\n-\n-    #[cfg(windows)]\n-    fn command_line_too_big(err: &io::Error) -> bool {\n-        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n-        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n-    }\n-\n-    struct Escape<'a> {\n-        arg: &'a str,\n-        is_like_msvc: bool,\n-    }\n-\n-    impl<'a> fmt::Display for Escape<'a> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            if self.is_like_msvc {\n-                // This is \"documented\" at\n-                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n-                //\n-                // Unfortunately there's not a great specification of the\n-                // syntax I could find online (at least) but some local\n-                // testing showed that this seemed sufficient-ish to catch\n-                // at least a few edge cases.\n-                write!(f, \"\\\"\")?;\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\"' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-                write!(f, \"\\\"\")?;\n-            } else {\n-                // This is documented at https://linux.die.net/man/1/ld, namely:\n-                //\n-                // > Options in file are separated by whitespace. A whitespace\n-                // > character may be included in an option by surrounding the\n-                // > entire option in either single or double quotes. Any\n-                // > character (including a backslash) may be included by\n-                // > prefixing the character to be included with a backslash.\n-                //\n-                // We put an argument on each line, so all we need to do is\n-                // ensure the line is interpreted as one whole argument.\n-                for c in self.arg.chars() {\n-                    match c {\n-                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n-                        c => write!(f, \"{}\", c)?,\n-                    }\n-                }\n-            }\n-            Ok(())\n-        }\n-    }\n-}\n-\n-fn link_args(cmd: &mut dyn Linker,\n-             flavor: LinkerFlavor,\n-             sess: &Session,\n-             crate_type: config::CrateType,\n-             tmpdir: &Path,\n-             out_filename: &Path,\n-             codegen_results: &CodegenResults) {\n-\n-    // Linker plugins should be specified early in the list of arguments\n-    cmd.linker_plugin_lto();\n-\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n-\n-    // target descriptor\n-    let t = &sess.target.target;\n-\n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        cmd.add_object(obj);\n-    }\n-    cmd.output_filename(out_filename);\n-\n-    if crate_type == config::CrateType::Executable &&\n-       sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n-            cmd.subsystem(s);\n-        }\n-    }\n-\n-    // If we're building a dynamic library then some platforms need to make sure\n-    // that all symbols are exported correctly from the dynamic library.\n-    if crate_type != config::CrateType::Executable ||\n-       sess.target.target.options.is_like_emscripten {\n-        cmd.export_symbols(tmpdir, crate_type);\n-    }\n-\n-    // When linking a dynamic library, we put the metadata into a section of the\n-    // executable. This metadata is in a separate object file from the main\n-    // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib ||\n-       crate_type == config::CrateType::ProcMacro {\n-        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n-            cmd.add_object(obj);\n-        }\n-    }\n-\n-    let obj = codegen_results.allocator_module\n-        .as_ref()\n-        .and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n-\n-    // Try to strip as much out of the generated object by removing unused\n-    // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n-        cmd.gc_sections(keep_metadata);\n-    }\n-\n-    let used_link_args = &codegen_results.crate_info.link_args;\n-\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if t.options.position_independent_executables {\n-            let empty_vec = Vec::new();\n-            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-            let more_args = &sess.opts.cg.link_arg;\n-            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n-\n-            if get_reloc_model(sess) == llvm::RelocMode::PIC\n-                && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu\n-                && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n-\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => t.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        },\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        },\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        },\n-        RelroLevel::None => {\n-        },\n-    }\n-\n-    // Pass optimization flags down to the linker.\n-    cmd.optimize();\n-\n-    // Pass debuginfo flags down to the linker.\n-    cmd.debuginfo();\n-\n-    // We want to, by default, prevent the compiler from accidentally leaking in\n-    // any system libraries, so we may explicitly ask linkers to not link to any\n-    // libraries by default. Note that this does not happen for windows because\n-    // windows pulls in some large number of libraries and I couldn't quite\n-    // figure out which subset we wanted.\n-    //\n-    // This is all naturally configurable via the standard methods as well.\n-    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n-        t.options.no_default_libraries\n-    {\n-        cmd.no_default_libraries();\n-    }\n-\n-    // Take careful note of the ordering of the arguments we pass to the linker\n-    // here. Linkers will assume that things on the left depend on things to the\n-    // right. Things on the right cannot depend on things on the left. This is\n-    // all formally implemented in terms of resolving symbols (libs on the right\n-    // resolve unknown symbols of libs on the left, but not vice versa).\n-    //\n-    // For this reason, we have organized the arguments we pass to the linker as\n-    // such:\n-    //\n-    //  1. The local object that LLVM just generated\n-    //  2. Local native libraries\n-    //  3. Upstream rust libraries\n-    //  4. Upstream native libraries\n-    //\n-    // The rationale behind this ordering is that those items lower down in the\n-    // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g., that'd be a circular dependency).\n-    // Upstream rust libraries are not allowed to depend on our local native\n-    // libraries as that would violate the structure of the DAG, in that\n-    // scenario they are required to link to them as well in a shared fashion.\n-    //\n-    // Note that upstream rust libraries may contain native dependencies as\n-    // well, but they also can't depend on what we just started to add to the\n-    // link line. And finally upstream native libraries can't depend on anything\n-    // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g., other native deps).\n-    add_local_native_libraries(cmd, sess, codegen_results);\n-    add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n-\n-    // Tell the linker what we're doing.\n-    if crate_type != config::CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n-    }\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        cmd.build_static_executable();\n-    }\n-\n-    if sess.opts.debugging_opts.pgo_gen.enabled() {\n-        cmd.pgo_gen();\n-    }\n-\n-    // FIXME (#2397): At some point we want to rpath our guesses as to\n-    // where extern libraries might live, based on the\n-    // addl_lib_search_paths\n-    if sess.opts.cg.rpath {\n-        let target_triple = sess.opts.target_triple.triple();\n-        let mut get_install_prefix_lib_path = || {\n-            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n-            let mut path = PathBuf::from(install_prefix);\n-            path.push(&tlib);\n-\n-            path\n-        };\n-        let mut rpath_config = RPathConfig {\n-            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n-            out_filename: out_filename.to_path_buf(),\n-            has_rpath: sess.target.target.options.has_rpath,\n-            is_like_osx: sess.target.target.options.is_like_osx,\n-            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n-            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-        };\n-        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n-    }\n-\n-    // Finally add all the linker arguments provided on the command line along\n-    // with any #[link_args] attributes found inside the crate\n-    if let Some(ref args) = sess.opts.cg.link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.cg.link_arg);\n-    cmd.args(&used_link_args);\n-}\n-\n-// # Native library linking\n-//\n-// User-supplied library search paths (-L on the command line). These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n-//\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut dyn Linker,\n-                              sess: &Session,\n-                              codegen_results: &CodegenResults) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n-            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n-        }\n-    }\n-\n-    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n-        relevant_lib(sess, l)\n-    });\n-\n-    let search_path = archive_search_paths(sess);\n-    for lib in relevant_libs {\n-        let name = match lib.name {\n-            Some(ref l) => l,\n-            None => continue,\n-        };\n-        match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n-                                                                        &search_path)\n-        }\n-    }\n-}\n-\n-// # Rust Crate linking\n-//\n-// Rust crates are not considered at all when creating an rlib output. All\n-// dependencies will be linked when producing the final output (instead of\n-// the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n-                            sess: &Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n-    // All of the heavy lifting has previously been accomplished by the\n-    // dependency_format module of the compiler. This is just crawling the\n-    // output of that module, adding crates as necessary.\n-    //\n-    // Linking to a rlib involves just passing it to the linker (the linker\n-    // will slurp up the object files inside), and linking to a dynamic library\n-    // involves just passing the right -l flag.\n-\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates_dynamic;\n-\n-    // There's a few internal crates in the standard library (aka libcore and\n-    // libstd) which actually have a circular dependence upon one another. This\n-    // currently arises through \"weak lang items\" where libcore requires things\n-    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n-    // circular dependence to work correctly in all situations we'll need to be\n-    // sure to correctly apply the `--start-group` and `--end-group` options to\n-    // GNU linkers, otherwise if we don't use any other symbol from the standard\n-    // library it'll get discarded and the whole application won't link.\n-    //\n-    // In this loop we're calculating the `group_end`, after which crate to\n-    // pass `--end-group` and `group_start`, before which crate to pass\n-    // `--start-group`. We currently do this by passing `--end-group` after\n-    // the first crate (when iterating backwards) that requires a lang item\n-    // defined somewhere else. Once that's set then when we've defined all the\n-    // necessary lang items we'll pass `--start-group`.\n-    //\n-    // Note that this isn't amazing logic for now but it should do the trick\n-    // for the current implementation of the standard library.\n-    let mut group_end = None;\n-    let mut group_start = None;\n-    let mut end_with = FxHashSet::default();\n-    let info = &codegen_results.crate_info;\n-    for &(cnum, _) in deps.iter().rev() {\n-        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n-            end_with.extend(missing.iter().cloned());\n-            if end_with.len() > 0 && group_end.is_none() {\n-                group_end = Some(cnum);\n-            }\n-        }\n-        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n-        if end_with.len() == 0 && group_end.is_some() {\n-            group_start = Some(cnum);\n-            break\n-        }\n-    }\n-\n-    // If we didn't end up filling in all lang items from upstream crates then\n-    // we'll be filling it in with our crate. This probably means we're the\n-    // standard library itself, so skip this for now.\n-    if group_end.is_some() && group_start.is_none() {\n-        group_end = None;\n-    }\n-\n-    let mut compiler_builtins = None;\n-\n-    for &(cnum, _) in deps.iter() {\n-        if group_start == Some(cnum) {\n-            cmd.group_start();\n-        }\n-\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, codegen_results, tmpdir, cnum);\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n-            }\n-        }\n-\n-        if group_end == Some(cnum) {\n-            cmd.group_end();\n-        }\n-    }\n-\n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-    }\n-\n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n-            &stem[3..]\n-        } else {\n-            stem\n-        }\n-    }\n-\n-    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n-    // it's packed in a .rlib, it contains stuff that are not objects that will\n-    // make the linker error. So we must remove those bits from the .rlib before\n-    // linking it.\n-    fn link_sanitizer_runtime(cmd: &mut dyn Linker,\n-                              sess: &Session,\n-                              codegen_results: &CodegenResults,\n-                              tmpdir: &Path,\n-                              cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        if sess.target.target.options.is_like_osx {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            //\n-            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n-            let rpath = cratepath.parent().unwrap();\n-            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n-            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let cfg = archive_config(sess, &dst, Some(cratepath));\n-        let mut archive = ArchiveBuilder::new(cfg);\n-        archive.update_symbols();\n-\n-        for f in archive.src_files() {\n-            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                archive.remove_file(&f);\n-            }\n-        }\n-\n-        archive.build();\n-\n-        cmd.link_whole_rlib(&dst);\n-    }\n-\n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO and\n-    // dynamic libraries. Specifically:\n-    //\n-    // * For LTO, we remove upstream object files.\n-    // * For dylibs we remove metadata and bytecode from upstream rlibs\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // When making a dynamic library, linkers by default don't include any\n-    // object files in an archive if they're not necessary to resolve the link.\n-    // We basically want to convert the archive (rlib) to a dylib, though, so we\n-    // *do* want everything included in the output, regardless of whether the\n-    // linker thinks it's needed or not. As a result we must use the\n-    // --whole-archive option (or the platform equivalent). When using this\n-    // option the linker will fail if there are non-objects in the archive (such\n-    // as our own metadata and/or bytecode). All in all, for rlibs to be\n-    // entirely included in dylibs, we need to remove all non-object files.\n-    //\n-    // Note, however, that if we're not doing LTO or we're not producing a dylib\n-    // (aka we're making an executable), we can just pass the rlib blindly to\n-    // the linker (fast) because it's fine if it's not actually included as\n-    // we're at the end of the dependency chain.\n-    fn add_static_crate(cmd: &mut dyn Linker,\n-                        sess: &Session,\n-                        codegen_results: &CodegenResults,\n-                        tmpdir: &Path,\n-                        crate_type: config::CrateType,\n-                        cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess) ||\n-            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n-           crate_type != config::CrateType::Dylib &&\n-           !skip_native {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n-            return\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-\n-        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n-            let cfg = archive_config(sess, &dst, Some(cratepath));\n-            let mut archive = ArchiveBuilder::new(cfg);\n-            archive.update_symbols();\n-\n-            let mut any_objects = false;\n-            for f in archive.src_files() {\n-                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue\n-                }\n-\n-                let canonical = f.replace(\"-\", \"_\");\n-                let canonical_name = name.replace(\"-\", \"_\");\n-\n-                // Look for `.rcgu.o` at the end of the filename to conclude\n-                // that this is a Rust-related object file.\n-                fn looks_like_rust(s: &str) -> bool {\n-                    let path = Path::new(s);\n-                    let ext = path.extension().and_then(|s| s.to_str());\n-                    if ext != Some(OutputType::Object.extension()) {\n-                        return false\n-                    }\n-                    let ext2 = path.file_stem()\n-                        .and_then(|s| Path::new(s).extension())\n-                        .and_then(|s| s.to_str());\n-                    ext2 == Some(RUST_CGU_EXT)\n-                }\n-\n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) &&\n-                    looks_like_rust(&f);\n-\n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n-                    is_rust_object &&\n-                    (sess.target.target.options.no_builtins ||\n-                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n-\n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    archive.remove_file(&f);\n-                } else {\n-                    any_objects = true;\n-                }\n-            }\n-\n-            if !any_objects {\n-                return\n-            }\n-            archive.build();\n-\n-            // If we're creating a dylib, then we need to include the\n-            // whole of each object in our archive into that artifact. This is\n-            // because a `dylib` can be reused as an intermediate artifact.\n-            //\n-            // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n-            // repeatedly linked anyway.\n-            if crate_type == config::CrateType::Dylib &&\n-                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n-                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            } else {\n-                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            }\n-        });\n-    }\n-\n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n-                            parent.unwrap_or(Path::new(\"\")));\n-    }\n-}\n-\n-// Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native dependencies are all non-static\n-// dependencies. We've got two cases then:\n-//\n-// 1. The upstream crate is an rlib. In this case we *must* link in the\n-// native dependency because the rlib is just an archive.\n-//\n-// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-// have the dependency present on the system somewhere. Thus, we don't\n-// gain a whole lot from not linking in the dynamic dependency to this\n-// crate as well.\n-//\n-// The use case for this is a little subtle. In theory the native\n-// dependencies of a crate are purely an implementation detail of the crate\n-// itself, but the problem arises with generic and inlined functions. If a\n-// generic function calls a native function, then the generic function must\n-// be instantiated in the target crate, meaning that the native symbol must\n-// also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n-    // Be sure to use a topological sorting of crates because there may be\n-    // interdependencies between native libraries. When passing -nodefaultlibs,\n-    // for example, almost all native libraries depend on libc, so we have to\n-    // make sure that's all the way at the right (liblibc is near the base of\n-    // the dependency chain).\n-    //\n-    // This passes RequireStatic, but the actual requirement doesn't matter,\n-    // we're just getting an ordering of crate numbers, we're not worried about\n-    // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    let crates = &codegen_results.crate_info.used_crates_static;\n-    for &(cnum, _) in crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let name = match lib.name {\n-                Some(ref l) => l,\n-                None => continue,\n-            };\n-            if !relevant_lib(sess, &lib) {\n-                continue\n-            }\n-            match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-                NativeLibraryKind::NativeStaticNobundle => {\n-                    // Link \"static-nobundle\" native libs only if the crate they originate from\n-                    // is being linked statically to the current crate.  If it's linked dynamically\n-                    // or is an rlib already included via some other dylib crate, the symbols from\n-                    // native libs will have already been included in that dylib.\n-                    if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(&name.as_str())\n-                    }\n-                },\n-                // ignore statically included native libraries here as we've\n-                // already included them when we included the rust library\n-                // previously\n-                NativeLibraryKind::NativeStatic => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n-fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n-    match sess.lto() {\n-        Lto::Fat => true,\n-        Lto::Thin => {\n-            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n-            // any upstream object files have not been copied yet.\n-            !sess.opts.cg.linker_plugin_lto.enabled()\n-        }\n-        Lto::No |\n-        Lto::ThinLocal => false,\n-    }\n-}"}, {"sha": "74cda2d2fd182978ef69bea6e28681046db0a783", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,4 +1,4 @@\n-use crate::back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n+use crate::back::bytecode::DecodedBytecode;\n use crate::back::write::{self, DiagnosticHandlers, with_llvm_pmb, save_temp_bitcode,\n     to_llvm_opt_settings};\n use crate::llvm::archive_ro::ArchiveRO;\n@@ -16,7 +16,7 @@ use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n+use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, ModuleKind};\n \n use std::ffi::{CStr, CString};\n use std::ptr;"}, {"sha": "cb59cf41a3ca531a8adeecac42debee4d6279ed1", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,5 +1,5 @@\n use crate::attributes;\n-use crate::back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n+use crate::back::bytecode;\n use crate::back::lto::ThinBuffer;\n use crate::base;\n use crate::consts;\n@@ -16,7 +16,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc::session::config::{self, OutputType, Passes, Lto, PgoGenerate};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n+use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, CompiledModule};\n use rustc::util::common::time_ext;\n use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;"}, {"sha": "31348b99c5af0983f52883d4f1242bc1ff42124f", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -376,7 +376,7 @@ fn vec_slice_metadata(\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let slice_type_name = compute_debuginfo_type_name(cx, slice_ptr_type, true);\n+    let slice_type_name = compute_debuginfo_type_name(cx.tcx, slice_ptr_type, true);\n \n     let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n     let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx.types.usize);\n@@ -479,7 +479,7 @@ fn trait_pointer_metadata(\n \n     let trait_object_type = trait_object_type.unwrap_or(trait_type);\n     let trait_type_name =\n-        compute_debuginfo_type_name(cx, trait_object_type, false);\n+        compute_debuginfo_type_name(cx.tcx, trait_object_type, false);\n \n     let file_metadata = unknown_file_metadata(cx);\n \n@@ -866,7 +866,7 @@ fn foreign_type_metadata(\n ) -> &'ll DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n-    let name = compute_debuginfo_type_name(cx, t, false);\n+    let name = compute_debuginfo_type_name(cx.tcx, t, false);\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n@@ -876,7 +876,7 @@ fn pointer_type_metadata(\n     pointee_type_metadata: &'ll DIType,\n ) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n-    let name = compute_debuginfo_type_name(cx, pointer_type, false);\n+    let name = compute_debuginfo_type_name(cx.tcx, pointer_type, false);\n     let name = SmallCStr::new(&name);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n@@ -1072,7 +1072,7 @@ fn prepare_struct_metadata(\n     unique_type_id: UniqueTypeId,\n     span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n+    let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.sty {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n@@ -1138,7 +1138,7 @@ fn prepare_tuple_metadata(\n     unique_type_id: UniqueTypeId,\n     span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n+    let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n     let struct_stub = create_struct_stub(cx,\n                                          tuple_type,\n@@ -1194,7 +1194,7 @@ fn prepare_union_metadata(\n     unique_type_id: UniqueTypeId,\n     span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-    let union_name = compute_debuginfo_type_name(cx, union_type, false);\n+    let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.sty {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n@@ -1607,7 +1607,7 @@ fn prepare_enum_metadata(\n     unique_type_id: UniqueTypeId,\n     span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n+    let enum_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n \n     let containing_scope = get_namespace_for_item(cx, enum_def_id);\n     // FIXME: This should emit actual file metadata for the enum, but we"}, {"sha": "ae498673c1d845e4e244242e03fa17801a7df498", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -29,7 +29,7 @@ use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess,\n-    VariableKind, FunctionDebugContextData};\n+    VariableKind, FunctionDebugContextData, type_names};\n \n use libc::c_uint;\n use std::cell::RefCell;\n@@ -44,7 +44,6 @@ use rustc_codegen_ssa::traits::*;\n pub mod gdb;\n mod utils;\n mod namespace;\n-mod type_names;\n pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n@@ -422,7 +421,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let actual_type =\n                     cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n                 // Add actual type name to <...> clause of function name\n-                let actual_type_name = compute_debuginfo_type_name(cx,\n+                let actual_type_name = compute_debuginfo_type_name(cx.tcx(),\n                                                                    actual_type,\n                                                                    true);\n                 name_to_append_suffix_to.push_str(&actual_type_name[..]);"}, {"sha": "cee0d5be6473b1455a6ca780bc03710e3b914bd7", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -44,8 +44,6 @@ extern crate rustc_fs_util;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n-extern crate serialize;\n-extern crate tempfile;\n \n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n@@ -73,13 +71,10 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n mod error_codes;\n \n mod back {\n-    mod archive;\n+    pub mod archive;\n     pub mod bytecode;\n-    pub mod link;\n     pub mod lto;\n     pub mod write;\n-    mod rpath;\n-    pub mod wasm;\n }\n \n mod abi;\n@@ -331,8 +326,17 @@ impl CodegenBackend for LlvmCodegenBackend {\n         // This should produce either a finished executable or library.\n         sess.profiler(|p| p.start_activity(\"link_crate\"));\n         time(sess, \"linking\", || {\n-            back::link::link_binary(sess, &codegen_results,\n-                                    outputs, &codegen_results.crate_name.as_str());\n+            use rustc_codegen_ssa::back::link::link_binary;\n+            use crate::back::archive::LlvmArchiveBuilder;\n+\n+            let target_cpu = crate::llvm_util::target_cpu(sess);\n+            link_binary::<LlvmArchiveBuilder<'_>>(\n+                sess,\n+                &codegen_results,\n+                outputs,\n+                &codegen_results.crate_name.as_str(),\n+                target_cpu,\n+            );\n         });\n         sess.profiler(|p| p.end_activity(\"link_crate\"));\n "}, {"sha": "7cf497cb5d036afb75215668121a1b314a12e511", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -5,15 +5,15 @@ use rustc::middle::cstore::MetadataLoader;\n use rustc_target::spec::Target;\n \n use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_codegen_ssa::METADATA_FILENAME;\n+\n use std::path::Path;\n use std::ptr;\n use std::slice;\n use rustc_fs_util::path_to_c_string;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n-pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n-\n pub struct LlvmMetadataLoader;\n \n impl MetadataLoader for LlvmMetadataLoader {"}, {"sha": "af99d39182c248c9bb534b5719204942cde0d496", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -20,6 +20,7 @@ log = \"0.4.5\"\n libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n parking_lot = \"0.7\"\n+tempfile = \"3.0.5\"\n \n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "23d580ef08b2d7b7a48873b180102519b301353f", "filename": "src/librustc_codegen_ssa/back/archive.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,6 +1,7 @@\n use rustc::session::Session;\n \n-use std::path::PathBuf;\n+use std::io;\n+use std::path::{Path, PathBuf};\n \n pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n                     -> PathBuf {\n@@ -24,3 +25,23 @@ pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n     sess.fatal(&format!(\"could not find native static library `{}`, \\\n                          perhaps an -L flag is missing?\", name));\n }\n+\n+pub trait ArchiveBuilder<'a> {\n+    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self;\n+\n+    fn add_file(&mut self, path: &Path);\n+    fn remove_file(&mut self, name: &str);\n+    fn src_files(&mut self) -> Vec<String>;\n+\n+    fn add_rlib(\n+        &mut self,\n+        path: &Path,\n+        name: &str,\n+        lto: bool,\n+        skip_objects: bool,\n+    ) -> io::Result<()>;\n+    fn add_native_library(&mut self, name: &str);\n+    fn update_symbols(&mut self);\n+\n+    fn build(self);\n+}"}, {"sha": "166234c83fca5cd632a1efa057681bc543d1552d", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1479, "deletions": 4, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,21 +1,40 @@\n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n \n-use rustc::session::{Session, config};\n+use rustc::session::{Session, filesearch};\n+use rustc::session::config::{\n+    self, RUST_CGU_EXT, DebugInfo, OutputFilenames, OutputType, PrintRequest, Sanitizer\n+};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::cstore::LibSource;\n-use rustc_target::spec::LinkerFlavor;\n+use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc::util::common::{time, time_ext};\n use rustc::hir::def_id::CrateNum;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_fs_util::fix_windows_verbatim_for_gcc;\n+use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n \n+use crate::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION, CrateInfo, CodegenResults};\n+use super::archive::ArchiveBuilder;\n use super::command::Command;\n-use crate::CrateInfo;\n+use super::linker::Linker;\n+use super::rpath::{self, RPathConfig};\n \n use cc::windows_registry;\n+use tempfile::{Builder as TempFileBuilder, TempDir};\n+\n+use std::ascii;\n+use std::char;\n+use std::fmt;\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n+use std::process::{Output, Stdio};\n+use std::str;\n use std::env;\n \n+pub use rustc_codegen_utils::link::*;\n+\n pub fn remove(sess: &Session, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n         sess.err(&format!(\"failed to remove {}: {}\",\n@@ -24,6 +43,129 @@ pub fn remove(sess: &Session, path: &Path) {\n     }\n }\n \n+/// Performs the linkage portion of the compilation phase. This will generate all\n+/// of the requested outputs for this compilation session.\n+pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                          codegen_results: &CodegenResults,\n+                          outputs: &OutputFilenames,\n+                          crate_name: &str,\n+                          target_cpu: &str) -> Vec<PathBuf> {\n+    let mut out_filenames = Vec::new();\n+    for &crate_type in sess.crate_types.borrow().iter() {\n+        // Ignore executable crates if we have -Z no-codegen, as they will error.\n+        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n+        if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n+           !output_metadata &&\n+           crate_type == config::CrateType::Executable {\n+            continue;\n+        }\n+\n+        if invalid_output_for_target(sess, crate_type) {\n+           bug!(\"invalid output type `{:?}` for target os `{}`\",\n+                crate_type, sess.opts.target_triple);\n+        }\n+        let out_files = link_binary_output::<B>(sess,\n+                                           codegen_results,\n+                                           crate_type,\n+                                           outputs,\n+                                           crate_name,\n+                                           target_cpu);\n+        out_filenames.extend(out_files);\n+    }\n+\n+    // Remove the temporary object file and metadata if we aren't saving temps\n+    if !sess.opts.cg.save_temps {\n+        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n+            for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+                remove(sess, obj);\n+            }\n+        }\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref obj) = codegen_results.metadata_module.object {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref allocator) = codegen_results.allocator_module {\n+            if let Some(ref obj) = allocator.object {\n+                remove(sess, obj);\n+            }\n+            if let Some(ref bc) = allocator.bytecode_compressed {\n+                remove(sess, bc);\n+            }\n+        }\n+    }\n+\n+    out_filenames\n+}\n+\n+fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                      codegen_results: &CodegenResults,\n+                      crate_type: config::CrateType,\n+                      outputs: &OutputFilenames,\n+                      crate_name: &str,\n+                      target_cpu: &str) -> Vec<PathBuf> {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        check_file_is_writeable(obj, sess);\n+    }\n+\n+    let mut out_filenames = vec![];\n+\n+    if outputs.outputs.contains_key(&OutputType::Metadata) {\n+        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with a `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n+        if let Err(e) = fs::rename(metadata, &out_filename) {\n+            sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        }\n+        out_filenames.push(out_filename);\n+    }\n+\n+    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+\n+    if outputs.outputs.should_codegen() {\n+        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+        match crate_type {\n+            config::CrateType::Rlib => {\n+                link_rlib::<B>(sess,\n+                          codegen_results,\n+                          RlibFlavor::Normal,\n+                          &out_filename,\n+                          &tmpdir).build();\n+            }\n+            config::CrateType::Staticlib => {\n+                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+            }\n+            _ => {\n+                link_natively::<B>(\n+                    sess,\n+                    crate_type,\n+                    &out_filename,\n+                    codegen_results,\n+                    tmpdir.path(),\n+                    target_cpu,\n+                );\n+            }\n+        }\n+        out_filenames.push(out_filename);\n+    }\n+\n+    if sess.opts.cg.save_temps {\n+        let _ = tmpdir.into_path();\n+    }\n+\n+    out_filenames\n+}\n+\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n@@ -116,6 +258,444 @@ pub fn each_linked_rlib(sess: &Session,\n     Ok(())\n }\n \n+/// We use a temp directory here to avoid races between concurrent rustc processes,\n+/// such as builds in the same directory using the same filename for metadata while\n+/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n+/// directory being searched for `extern crate` (observing an incomplete file).\n+/// The returned path is the temporary file containing the complete metadata.\n+fn emit_metadata<'a>(\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &TempDir\n+) -> PathBuf {\n+    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n+    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n+\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+\n+    out_filename\n+}\n+\n+// Create an 'rlib'\n+//\n+// An rlib in its current incarnation is essentially a renamed .a file. The\n+// rlib primarily contains the object file of the crate, but it also contains\n+// all of the object files from native libraries. This is done by unzipping\n+// native libraries and inserting all of the contents into this archive.\n+fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                 codegen_results: &CodegenResults,\n+                 flavor: RlibFlavor,\n+                 out_filename: &Path,\n+                 tmpdir: &TempDir) -> B {\n+    info!(\"preparing rlib to {:?}\", out_filename);\n+    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n+\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        ab.add_file(obj);\n+    }\n+\n+    // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n+    // we may not be configured to actually include a static library if we're\n+    // adding it here. That's because later when we consume this rlib we'll\n+    // decide whether we actually needed the static library or not.\n+    //\n+    // To do this \"correctly\" we'd need to keep track of which libraries added\n+    // which object files to the archive. We don't do that here, however. The\n+    // #[link(cfg(..))] feature is unstable, though, and only intended to get\n+    // liblibc working. In that sense the check below just indicates that if\n+    // there are any libraries we want to omit object files for at link time we\n+    // just exclude all custom object files.\n+    //\n+    // Eventually if we want to stabilize or flesh out the #[link(cfg(..))]\n+    // feature then we'll need to figure out how to record what objects were\n+    // loaded from the libraries found here and then encode that into the\n+    // metadata of the rlib we're generating somehow.\n+    for lib in codegen_results.crate_info.used_libraries.iter() {\n+        match lib.kind {\n+            NativeLibraryKind::NativeStatic => {}\n+            NativeLibraryKind::NativeStaticNobundle |\n+            NativeLibraryKind::NativeFramework |\n+            NativeLibraryKind::NativeUnknown => continue,\n+        }\n+        if let Some(name) = lib.name {\n+            ab.add_native_library(&name.as_str());\n+        }\n+    }\n+\n+    // After adding all files to the archive, we need to update the\n+    // symbol table of the archive.\n+    ab.update_symbols();\n+\n+    // Note that it is important that we add all of our non-object \"magical\n+    // files\" *after* all of the object files in the archive. The reason for\n+    // this is as follows:\n+    //\n+    // * When performing LTO, this archive will be modified to remove\n+    //   objects from above. The reason for this is described below.\n+    //\n+    // * When the system linker looks at an archive, it will attempt to\n+    //   determine the architecture of the archive in order to see whether its\n+    //   linkable.\n+    //\n+    //   The algorithm for this detection is: iterate over the files in the\n+    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n+    //   object file. Read architecture from the object file.\n+    //\n+    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n+    //   before all of the objects, then the architecture of this archive would\n+    //   not be correctly inferred once 'foo.o' is removed.\n+    //\n+    // Basically, all this means is that this code should not move above the\n+    // code above.\n+    match flavor {\n+        RlibFlavor::Normal => {\n+            // Instead of putting the metadata in an object file section, rlibs\n+            // contain the metadata in a separate file.\n+            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n+\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.\n+            for bytecode in codegen_results\n+                .modules\n+                .iter()\n+                .filter_map(|m| m.bytecode_compressed.as_ref())\n+            {\n+                ab.add_file(bytecode);\n+            }\n+\n+            // After adding all files to the archive, we need to update the\n+            // symbol table of the archive. This currently dies on macOS (see\n+            // #11162), and isn't necessary there anyway\n+            if !sess.target.target.options.is_like_osx {\n+                ab.update_symbols();\n+            }\n+        }\n+\n+        RlibFlavor::StaticlibBase => {\n+            let obj = codegen_results.allocator_module\n+                .as_ref()\n+                .and_then(|m| m.object.as_ref());\n+            if let Some(obj) = obj {\n+                ab.add_file(obj);\n+            }\n+        }\n+    }\n+\n+    ab\n+}\n+\n+// Create a static archive\n+//\n+// This is essentially the same thing as an rlib, but it also involves adding\n+// all of the upstream crates' objects into the archive. This will slurp in\n+// all of the native libraries of upstream dependencies as well.\n+//\n+// Additionally, there's no way for us to link dynamic libraries, so we warn\n+// about all dynamic library dependencies that they're not linked in.\n+//\n+// There's no need to include metadata in a static archive, so ensure to not\n+// link in the metadata object file (and also don't prepare the archive with a\n+// metadata file).\n+fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                  codegen_results: &CodegenResults,\n+                  out_filename: &Path,\n+                  tempdir: &TempDir) {\n+    let mut ab = link_rlib::<B>(sess,\n+                           codegen_results,\n+                           RlibFlavor::StaticlibBase,\n+                           out_filename,\n+                           tempdir);\n+    let mut all_native_libs = vec![];\n+\n+    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+        let name = &codegen_results.crate_info.crate_name[&cnum];\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+\n+        // Here when we include the rlib into our staticlib we need to make a\n+        // decision whether to include the extra object files along the way.\n+        // These extra object files come from statically included native\n+        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n+        //\n+        // This unstable feature, though, only needs liblibc to work. The only\n+        // use case there is where musl is statically included in liblibc.rlib,\n+        // so if we don't want the included version we just need to skip it. As\n+        // a result the logic here is that if *any* linked library is cfg'd away\n+        // we just skip all object files.\n+        //\n+        // Clearly this is not sufficient for a general purpose feature, and\n+        // we'd want to read from the library's metadata to determine which\n+        // object files come from where and selectively skip them.\n+        let skip_object_files = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+        ab.add_rlib(path,\n+                    &name.as_str(),\n+                    are_upstream_rust_objects_already_included(sess) &&\n+                        !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n+                    skip_object_files).unwrap();\n+\n+        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n+    });\n+    if let Err(e) = res {\n+        sess.fatal(&e);\n+    }\n+\n+    ab.update_symbols();\n+    ab.build();\n+\n+    if !all_native_libs.is_empty() {\n+        if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n+            print_native_static_libs(sess, &all_native_libs);\n+        }\n+    }\n+}\n+\n+// Create a dynamic library or executable\n+//\n+// This will invoke the system linker/cc to create the resulting file. This\n+// links to all upstream files as well.\n+fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                 crate_type: config::CrateType,\n+                 out_filename: &Path,\n+                 codegen_results: &CodegenResults,\n+                 tmpdir: &Path,\n+                 target_cpu: &str) {\n+    info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n+    let (linker, flavor) = linker_and_flavor(sess);\n+\n+    // The invocations of cc share some flags across platforms\n+    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n+\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static() {\n+            cmd.args(args);\n+        }\n+    }\n+    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n+\n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n+    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+        &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n+    };\n+    for obj in pre_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+\n+    if crate_type == config::CrateType::Executable && sess.crt_static() {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    {\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n+        link_args::<B>(&mut *linker, flavor, sess, crate_type, tmpdir,\n+                  out_filename, codegen_results);\n+        cmd = linker.finalize();\n+    }\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+    if sess.crt_static() {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for &(ref k, ref v) in &sess.target.target.options.link_env {\n+        cmd.env(k, v);\n+    }\n+\n+    if sess.opts.debugging_opts.print_link_args {\n+        println!(\"{:?}\", &cmd);\n+    }\n+\n+    // May have not found libraries in the right formats.\n+    sess.abort_if_errors();\n+\n+    // Invoke the system linker\n+    //\n+    // Note that there's a terribly awful hack that really shouldn't be present\n+    // in any compiler. Here an environment variable is supported to\n+    // automatically retry the linker invocation if the linker looks like it\n+    // segfaulted.\n+    //\n+    // Gee that seems odd, normally segfaults are things we want to know about!\n+    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n+    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n+    // pain to land PRs when they spuriously fail due to a segfault.\n+    //\n+    // The issue #38878 has some more debugging information on it as well, but\n+    // this unfortunately looks like it's just a race condition in macOS's linker\n+    // with some thread pool working in the background. It seems that no one\n+    // currently knows a fix for this so in the meantime we're left with this...\n+    info!(\"{:?}\", &cmd);\n+    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n+    let mut prog;\n+    let mut i = 0;\n+    loop {\n+        i += 1;\n+        prog = time(sess, \"running linker\", || {\n+            exec_linker(sess, &mut cmd, out_filename, tmpdir)\n+        });\n+        let output = match prog {\n+            Ok(ref output) => output,\n+            Err(_) => break,\n+        };\n+        if output.status.success() {\n+            break\n+        }\n+        let mut out = output.stderr.clone();\n+        out.extend(&output.stdout);\n+        let out = String::from_utf8_lossy(&out);\n+\n+        // Check to see if the link failed with \"unrecognized command line option:\n+        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n+        // reperform the link step without the -no-pie option. This is safe because\n+        // if the linker doesn't support -no-pie then it should not default to\n+        // linking executables as pie. Different versions of gcc seem to use\n+        // different quotes in the error message so don't check for them.\n+        if sess.target.target.options.linker_is_gnu &&\n+           flavor != LinkerFlavor::Ld &&\n+           (out.contains(\"unrecognized command line option\") ||\n+            out.contains(\"unknown argument\")) &&\n+           out.contains(\"-no-pie\") &&\n+           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n+            info!(\"linker output: {:?}\", out);\n+            warn!(\"Linker does not support -no-pie command line option. Retrying without.\");\n+            for arg in cmd.take_args() {\n+                if arg.to_string_lossy() != \"-no-pie\" {\n+                    cmd.arg(arg);\n+                }\n+            }\n+            info!(\"{:?}\", &cmd);\n+            continue;\n+        }\n+        if !retry_on_segfault || i > 3 {\n+            break\n+        }\n+        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n+        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n+        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n+            break\n+        }\n+\n+        warn!(\n+            \"looks like the linker segfaulted when we tried to call it, \\\n+             automatically retrying again. cmd = {:?}, out = {}.\",\n+            cmd,\n+            out,\n+        );\n+    }\n+\n+    match prog {\n+        Ok(prog) => {\n+            fn escape_string(s: &[u8]) -> String {\n+                str::from_utf8(s).map(|s| s.to_owned())\n+                    .unwrap_or_else(|_| {\n+                        let mut x = \"Non-UTF-8 output: \".to_string();\n+                        x.extend(s.iter()\n+                                  .flat_map(|&b| ascii::escape_default(b))\n+                                  .map(char::from));\n+                        x\n+                    })\n+            }\n+            if !prog.status.success() {\n+                let mut output = prog.stderr.clone();\n+                output.extend_from_slice(&prog.stdout);\n+                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                         pname.display(),\n+                                         prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(&escape_string(&output))\n+                    .emit();\n+                sess.abort_if_errors();\n+            }\n+            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n+        },\n+        Err(e) => {\n+            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n+\n+            let mut linker_error = {\n+                if linker_not_found {\n+                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                } else {\n+                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                }\n+            };\n+\n+            linker_error.note(&e.to_string());\n+\n+            if !linker_not_found {\n+                linker_error.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            linker_error.emit();\n+\n+            if sess.target.target.options.is_like_msvc && linker_not_found {\n+                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n+                    but `link.exe` was not found\");\n+                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n+                    was installed with the Visual C++ option\");\n+            }\n+            sess.abort_if_errors();\n+        }\n+    }\n+\n+\n+    // On macOS, debuggers need this utility to get run to do some munging of\n+    // the symbols. Note, though, that if the object files are being preserved\n+    // for their debug information there's no need for us to run dsymutil.\n+    if sess.target.target.options.is_like_osx &&\n+        sess.opts.debuginfo != DebugInfo::None &&\n+        !preserve_objects_for_their_debuginfo(sess)\n+    {\n+        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n+            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n+        }\n+    }\n+\n+    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n+        super::wasm::add_producer_section(\n+            &out_filename,\n+            &sess.edition().to_string(),\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n+        );\n+    }\n+}\n+\n /// Returns a boolean indicating whether the specified crate should be ignored\n /// during LTO.\n ///\n@@ -200,3 +780,898 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     bug!(\"Not enough information provided to determine how to invoke the linker\");\n }\n+\n+/// Returns a boolean indicating whether we should preserve the object files on\n+/// the filesystem for their debug information. This is often useful with\n+/// split-dwarf like schemes.\n+pub fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+    // If the objects don't have debuginfo there's nothing to preserve.\n+    if sess.opts.debuginfo == config::DebugInfo::None {\n+        return false\n+    }\n+\n+    // If we're only producing artifacts that are archives, no need to preserve\n+    // the objects as they're losslessly contained inside the archives.\n+    let output_linked = sess.crate_types.borrow()\n+        .iter()\n+        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n+    if !output_linked {\n+        return false\n+    }\n+\n+    // If we're on OSX then the equivalent of split dwarf is turned on by\n+    // default. The final executable won't actually have any debug information\n+    // except it'll have pointers to elsewhere. Historically we've always run\n+    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n+    // a bummer for incremental compilation! (the whole point of split dwarf is\n+    // that you don't do this sort of dwarf link).\n+    //\n+    // Basically as a result this just means that if we're on OSX and we're\n+    // *not* running dsymutil then the object files are the only source of truth\n+    // for debug information, so we must preserve them.\n+    if sess.target.target.options.is_like_osx {\n+        match sess.opts.debugging_opts.run_dsymutil {\n+            // dsymutil is not being run, preserve objects\n+            Some(false) => return true,\n+\n+            // dsymutil is being run, no need to preserve the objects\n+            Some(true) => return false,\n+\n+            // The default historical behavior was to always run dsymutil, so\n+            // we're preserving that temporarily, but we're likely to switch the\n+            // default soon.\n+            None => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n+pub fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n+    sess.target_filesearch(PathKind::Native).search_path_dirs()\n+}\n+\n+enum RlibFlavor {\n+    Normal,\n+    StaticlibBase,\n+}\n+\n+pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+    let lib_args: Vec<_> = all_native_libs.iter()\n+        .filter(|l| relevant_lib(sess, l))\n+        .filter_map(|lib| {\n+            let name = lib.name?;\n+            match lib.kind {\n+                NativeLibraryKind::NativeStaticNobundle |\n+                NativeLibraryKind::NativeUnknown => {\n+                    if sess.target.target.options.is_like_msvc {\n+                        Some(format!(\"{}.lib\", name))\n+                    } else {\n+                        Some(format!(\"-l{}\", name))\n+                    }\n+                },\n+                NativeLibraryKind::NativeFramework => {\n+                    // ld-only syntax, since there are no frameworks in MSVC\n+                    Some(format!(\"-framework {}\", name))\n+                },\n+                // These are included, no need to print them\n+                NativeLibraryKind::NativeStatic => None,\n+            }\n+        })\n+        .collect();\n+    if !lib_args.is_empty() {\n+        sess.note_without_error(\"Link against the following native artifacts when linking \\\n+                                 against this static library. The order and any duplication \\\n+                                 can be significant on some platforms.\");\n+        // Prefix for greppability\n+        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+    }\n+}\n+\n+pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n+    let fs = sess.target_filesearch(PathKind::Native);\n+    let file_path = fs.get_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path\n+    }\n+    for search_path in fs.search_paths() {\n+        let file_path = search_path.dir.join(name);\n+        if file_path.exists() {\n+            return file_path\n+        }\n+    }\n+    PathBuf::from(name)\n+}\n+\n+pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n+    -> io::Result<Output>\n+{\n+    // When attempting to spawn the linker we run a risk of blowing out the\n+    // size limits for spawning a new process with respect to the arguments\n+    // we pass on the command line.\n+    //\n+    // Here we attempt to handle errors from the OS saying \"your list of\n+    // arguments is too big\" by reinvoking the linker again with an `@`-file\n+    // that contains all the arguments. The theory is that this is then\n+    // accepted on all linkers and the linker will read all its options out of\n+    // there instead of looking at the command line.\n+    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n+        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+            Ok(child) => {\n+                let output = child.wait_with_output();\n+                flush_linked_file(&output, out_filename)?;\n+                return output;\n+            }\n+            Err(ref e) if command_line_too_big(e) => {\n+                info!(\"command line to linker was too big: {}\", e);\n+            }\n+            Err(e) => return Err(e)\n+        }\n+    }\n+\n+    info!(\"falling back to passing arguments to linker via an @-file\");\n+    let mut cmd2 = cmd.clone();\n+    let mut args = String::new();\n+    for arg in cmd2.take_args() {\n+        args.push_str(&Escape {\n+            arg: arg.to_str().unwrap(),\n+            is_like_msvc: sess.target.target.options.is_like_msvc,\n+        }.to_string());\n+        args.push_str(\"\\n\");\n+    }\n+    let file = tmpdir.join(\"linker-arguments\");\n+    let bytes = if sess.target.target.options.is_like_msvc {\n+        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n+        // start the stream with a UTF-16 BOM\n+        for c in std::iter::once(0xFEFF).chain(args.encode_utf16()) {\n+            // encode in little endian\n+            out.push(c as u8);\n+            out.push((c >> 8) as u8);\n+        }\n+        out\n+    } else {\n+        args.into_bytes()\n+    };\n+    fs::write(&file, &bytes)?;\n+    cmd2.arg(format!(\"@{}\", file.display()));\n+    info!(\"invoking linker {:?}\", cmd2);\n+    let output = cmd2.output();\n+    flush_linked_file(&output, out_filename)?;\n+    return output;\n+\n+    #[cfg(unix)]\n+    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    #[cfg(windows)]\n+    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n+        -> io::Result<()>\n+    {\n+        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n+        // even long after process exit, causing nasty, non-reproducible output bugs.\n+        //\n+        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n+        //\n+        // \u0410 full writeup of the original Chrome bug can be found at\n+        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n+\n+        if let &Ok(ref out) = command_output {\n+            if out.status.success() {\n+                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n+                    of.sync_all()?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[cfg(unix)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(::libc::E2BIG)\n+    }\n+\n+    #[cfg(windows)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n+        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n+    }\n+\n+    struct Escape<'a> {\n+        arg: &'a str,\n+        is_like_msvc: bool,\n+    }\n+\n+    impl<'a> fmt::Display for Escape<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            if self.is_like_msvc {\n+                // This is \"documented\" at\n+                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n+                //\n+                // Unfortunately there's not a great specification of the\n+                // syntax I could find online (at least) but some local\n+                // testing showed that this seemed sufficient-ish to catch\n+                // at least a few edge cases.\n+                write!(f, \"\\\"\")?;\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\"' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+                write!(f, \"\\\"\")?;\n+            } else {\n+                // This is documented at https://linux.die.net/man/1/ld, namely:\n+                //\n+                // > Options in file are separated by whitespace. A whitespace\n+                // > character may be included in an option by surrounding the\n+                // > entire option in either single or double quotes. Any\n+                // > character (including a backslash) may be included by\n+                // > prefixing the character to be included with a backslash.\n+                //\n+                // We put an argument on each line, so all we need to do is\n+                // ensure the line is interpreted as one whole argument.\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+             flavor: LinkerFlavor,\n+             sess: &'a Session,\n+             crate_type: config::CrateType,\n+             tmpdir: &Path,\n+             out_filename: &Path,\n+             codegen_results: &CodegenResults) {\n+\n+    // Linker plugins should be specified early in the list of arguments\n+    cmd.linker_plugin_lto();\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n+    }\n+    cmd.output_filename(out_filename);\n+\n+    if crate_type == config::CrateType::Executable &&\n+       sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = codegen_results.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n+    // If we're building a dynamic library then some platforms need to make sure\n+    // that all symbols are exported correctly from the dynamic library.\n+    if crate_type != config::CrateType::Executable ||\n+       sess.target.target.options.is_like_emscripten {\n+        cmd.export_symbols(tmpdir, crate_type);\n+    }\n+\n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if crate_type == config::CrateType::Dylib ||\n+       crate_type == config::CrateType::ProcMacro {\n+        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n+            cmd.add_object(obj);\n+        }\n+    }\n+\n+    let obj = codegen_results.allocator_module\n+        .as_ref()\n+        .and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n+    }\n+\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    if !sess.opts.cg.link_dead_code {\n+        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        cmd.gc_sections(keep_metadata);\n+    }\n+\n+    let used_link_args = &codegen_results.crate_info.link_args;\n+\n+    if crate_type == config::CrateType::Executable {\n+        let mut position_independent_executable = false;\n+\n+        if t.options.position_independent_executables {\n+            let empty_vec = Vec::new();\n+            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+            let more_args = &sess.opts.cg.link_arg;\n+            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n+\n+            if is_pic(sess) && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n+                position_independent_executable = true;\n+            }\n+        }\n+\n+        if position_independent_executable {\n+            cmd.position_independent_executable();\n+        } else {\n+            // recent versions of gcc can be configured to generate position\n+            // independent executables by default. We have to pass -no-pie to\n+            // explicitly turn that off. Not applicable to ld.\n+            if sess.target.target.options.linker_is_gnu\n+                && flavor != LinkerFlavor::Ld {\n+                cmd.no_position_independent_executable();\n+            }\n+        }\n+    }\n+\n+    let relro_level = match sess.opts.debugging_opts.relro_level {\n+        Some(level) => level,\n+        None => t.options.relro_level,\n+    };\n+    match relro_level {\n+        RelroLevel::Full => {\n+            cmd.full_relro();\n+        },\n+        RelroLevel::Partial => {\n+            cmd.partial_relro();\n+        },\n+        RelroLevel::Off => {\n+            cmd.no_relro();\n+        },\n+        RelroLevel::None => {\n+        },\n+    }\n+\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n+\n+    // Pass debuginfo flags down to the linker.\n+    cmd.debuginfo();\n+\n+    // We want to, by default, prevent the compiler from accidentally leaking in\n+    // any system libraries, so we may explicitly ask linkers to not link to any\n+    // libraries by default. Note that this does not happen for windows because\n+    // windows pulls in some large number of libraries and I couldn't quite\n+    // figure out which subset we wanted.\n+    //\n+    // This is all naturally configurable via the standard methods as well.\n+    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n+        t.options.no_default_libraries\n+    {\n+        cmd.no_default_libraries();\n+    }\n+\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Local native libraries\n+    //  3. Upstream rust libraries\n+    //  4. Upstream native libraries\n+    //\n+    // The rationale behind this ordering is that those items lower down in the\n+    // list can't depend on items higher up in the list. For example nothing can\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n+    // Upstream rust libraries are not allowed to depend on our local native\n+    // libraries as that would violate the structure of the DAG, in that\n+    // scenario they are required to link to them as well in a shared fashion.\n+    //\n+    // Note that upstream rust libraries may contain native dependencies as\n+    // well, but they also can't depend on what we just started to add to the\n+    // link line. And finally upstream native libraries can't depend on anything\n+    // in this DAG so far because they're only dylibs and dylibs can only depend\n+    // on other dylibs (e.g., other native deps).\n+    add_local_native_libraries(cmd, sess, codegen_results);\n+    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n+\n+    // Tell the linker what we're doing.\n+    if crate_type != config::CrateType::Executable {\n+        cmd.build_dylib(out_filename);\n+    }\n+    if crate_type == config::CrateType::Executable && sess.crt_static() {\n+        cmd.build_static_executable();\n+    }\n+\n+    if sess.opts.debugging_opts.pgo_gen.enabled() {\n+        cmd.pgo_gen();\n+    }\n+\n+    // FIXME (#2397): At some point we want to rpath our guesses as to\n+    // where extern libraries might live, based on the\n+    // addl_lib_search_paths\n+    if sess.opts.cg.rpath {\n+        let target_triple = sess.opts.target_triple.triple();\n+        let mut get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n+            let mut path = PathBuf::from(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let mut rpath_config = RPathConfig {\n+            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n+            out_filename: out_filename.to_path_buf(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n+            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n+            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n+        };\n+        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n+    }\n+\n+    // Finally add all the linker arguments provided on the command line along\n+    // with any #[link_args] attributes found inside the crate\n+    if let Some(ref args) = sess.opts.cg.link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.cg.link_arg);\n+    cmd.args(&used_link_args);\n+}\n+\n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the command line). These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n+                              sess: &Session,\n+                              codegen_results: &CodegenResults) {\n+    let filesearch = sess.target_filesearch(PathKind::All);\n+    for search_path in filesearch.search_paths() {\n+        match search_path.kind {\n+            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n+        }\n+    }\n+\n+    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n+        relevant_lib(sess, l)\n+    });\n+\n+    let search_path = archive_search_paths(sess);\n+    for lib in relevant_libs {\n+        let name = match lib.name {\n+            Some(ref l) => l,\n+            None => continue,\n+        };\n+        match lib.kind {\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n+                                                                        &search_path)\n+        }\n+    }\n+}\n+\n+// # Rust Crate linking\n+//\n+// Rust crates are not considered at all when creating an rlib output. All\n+// dependencies will be linked when producing the final output (instead of\n+// the intermediate rlib version)\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                            sess: &'a Session,\n+                            codegen_results: &CodegenResults,\n+                            crate_type: config::CrateType,\n+                            tmpdir: &Path) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n+    //\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n+\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = &codegen_results.crate_info.used_crates_dynamic;\n+\n+    // There's a few internal crates in the standard library (aka libcore and\n+    // libstd) which actually have a circular dependence upon one another. This\n+    // currently arises through \"weak lang items\" where libcore requires things\n+    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n+    // circular dependence to work correctly in all situations we'll need to be\n+    // sure to correctly apply the `--start-group` and `--end-group` options to\n+    // GNU linkers, otherwise if we don't use any other symbol from the standard\n+    // library it'll get discarded and the whole application won't link.\n+    //\n+    // In this loop we're calculating the `group_end`, after which crate to\n+    // pass `--end-group` and `group_start`, before which crate to pass\n+    // `--start-group`. We currently do this by passing `--end-group` after\n+    // the first crate (when iterating backwards) that requires a lang item\n+    // defined somewhere else. Once that's set then when we've defined all the\n+    // necessary lang items we'll pass `--start-group`.\n+    //\n+    // Note that this isn't amazing logic for now but it should do the trick\n+    // for the current implementation of the standard library.\n+    let mut group_end = None;\n+    let mut group_start = None;\n+    let mut end_with = FxHashSet::default();\n+    let info = &codegen_results.crate_info;\n+    for &(cnum, _) in deps.iter().rev() {\n+        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n+            end_with.extend(missing.iter().cloned());\n+            if end_with.len() > 0 && group_end.is_none() {\n+                group_end = Some(cnum);\n+            }\n+        }\n+        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n+        if end_with.len() == 0 && group_end.is_some() {\n+            group_start = Some(cnum);\n+            break\n+        }\n+    }\n+\n+    // If we didn't end up filling in all lang items from upstream crates then\n+    // we'll be filling it in with our crate. This probably means we're the\n+    // standard library itself, so skip this for now.\n+    if group_end.is_some() && group_start.is_none() {\n+        group_end = None;\n+    }\n+\n+    let mut compiler_builtins = None;\n+\n+    for &(cnum, _) in deps.iter() {\n+        if group_start == Some(cnum) {\n+            cmd.group_start();\n+        }\n+\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        match data[cnum.as_usize() - 1] {\n+            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+            }\n+            // compiler-builtins are always placed last to ensure that they're\n+            // linked correctly.\n+            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n+                assert!(compiler_builtins.is_none());\n+                compiler_builtins = Some(cnum);\n+            }\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static => {\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            Linkage::Dynamic => {\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n+            }\n+        }\n+\n+        if group_end == Some(cnum) {\n+            cmd.group_end();\n+        }\n+    }\n+\n+    // compiler-builtins are always placed last to ensure that they're\n+    // linked correctly.\n+    // We must always link the `compiler_builtins` crate statically. Even if it\n+    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n+    // is used)\n+    if let Some(cnum) = compiler_builtins {\n+        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+    }\n+\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n+        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n+            &stem[3..]\n+        } else {\n+            stem\n+        }\n+    }\n+\n+    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n+    // it's packed in a .rlib, it contains stuff that are not objects that will\n+    // make the linker error. So we must remove those bits from the .rlib before\n+    // linking it.\n+    fn link_sanitizer_runtime<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                              sess: &'a Session,\n+                              codegen_results: &CodegenResults,\n+                              tmpdir: &Path,\n+                              cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        if sess.target.target.options.is_like_osx {\n+            // On Apple platforms, the sanitizer is always built as a dylib, and\n+            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+            // rpath to the library as well (the rpath should be absolute, see\n+            // PR #41352 for details).\n+            //\n+            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n+            let rpath = cratepath.parent().unwrap();\n+            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n+            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n+        archive.update_symbols();\n+\n+        for f in archive.src_files() {\n+            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                archive.remove_file(&f);\n+            }\n+        }\n+\n+        archive.build();\n+\n+        cmd.link_whole_rlib(&dst);\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    // There's a bit of magic which happens here specifically related to LTO and\n+    // dynamic libraries. Specifically:\n+    //\n+    // * For LTO, we remove upstream object files.\n+    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    //\n+    // When performing LTO, almost(*) all of the bytecode from the upstream\n+    // libraries has already been included in our object file output. As a\n+    // result we need to remove the object files in the upstream libraries so\n+    // the linker doesn't try to include them twice (or whine about duplicate\n+    // symbols). We must continue to include the rest of the rlib, however, as\n+    // it may contain static native libraries which must be linked in.\n+    //\n+    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+    // their bytecode wasn't included. The object files in those libraries must\n+    // still be passed to the linker.\n+    //\n+    // When making a dynamic library, linkers by default don't include any\n+    // object files in an archive if they're not necessary to resolve the link.\n+    // We basically want to convert the archive (rlib) to a dylib, though, so we\n+    // *do* want everything included in the output, regardless of whether the\n+    // linker thinks it's needed or not. As a result we must use the\n+    // --whole-archive option (or the platform equivalent). When using this\n+    // option the linker will fail if there are non-objects in the archive (such\n+    // as our own metadata and/or bytecode). All in all, for rlibs to be\n+    // entirely included in dylibs, we need to remove all non-object files.\n+    //\n+    // Note, however, that if we're not doing LTO or we're not producing a dylib\n+    // (aka we're making an executable), we can just pass the rlib blindly to\n+    // the linker (fast) because it's fine if it's not actually included as\n+    // we're at the end of the dependency chain.\n+    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                        sess: &'a Session,\n+                        codegen_results: &CodegenResults,\n+                        tmpdir: &Path,\n+                        crate_type: config::CrateType,\n+                        cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        // See the comment above in `link_staticlib` and `link_rlib` for why if\n+        // there's a static library that's not relevant we skip all object\n+        // files.\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+        let skip_native = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+\n+        if (!are_upstream_rust_objects_already_included(sess) ||\n+            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n+           crate_type != config::CrateType::Dylib &&\n+           !skip_native {\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            return\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let name = cratepath.file_name().unwrap().to_str().unwrap();\n+        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+\n+        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n+            let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n+            archive.update_symbols();\n+\n+            let mut any_objects = false;\n+            for f in archive.src_files() {\n+                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                    archive.remove_file(&f);\n+                    continue\n+                }\n+\n+                let canonical = f.replace(\"-\", \"_\");\n+                let canonical_name = name.replace(\"-\", \"_\");\n+\n+                // Look for `.rcgu.o` at the end of the filename to conclude\n+                // that this is a Rust-related object file.\n+                fn looks_like_rust(s: &str) -> bool {\n+                    let path = Path::new(s);\n+                    let ext = path.extension().and_then(|s| s.to_str());\n+                    if ext != Some(OutputType::Object.extension()) {\n+                        return false\n+                    }\n+                    let ext2 = path.file_stem()\n+                        .and_then(|s| Path::new(s).extension())\n+                        .and_then(|s| s.to_str());\n+                    ext2 == Some(RUST_CGU_EXT)\n+                }\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) &&\n+                    looks_like_rust(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n+                    is_rust_object &&\n+                    (sess.target.target.options.no_builtins ||\n+                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    archive.remove_file(&f);\n+                } else {\n+                    any_objects = true;\n+                }\n+            }\n+\n+            if !any_objects {\n+                return\n+            }\n+            archive.build();\n+\n+            // If we're creating a dylib, then we need to include the\n+            // whole of each object in our archive into that artifact. This is\n+            // because a `dylib` can be reused as an intermediate artifact.\n+            //\n+            // Note, though, that we don't want to include the whole of a\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n+            // repeatedly linked anyway.\n+            if crate_type == config::CrateType::Dylib &&\n+                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n+                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            } else {\n+                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            }\n+        });\n+    }\n+\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let parent = cratepath.parent();\n+        if let Some(dir) = parent {\n+            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+        }\n+        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n+        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n+                            parent.unwrap_or(Path::new(\"\")));\n+    }\n+}\n+\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native dependencies are all non-static\n+// dependencies. We've got two cases then:\n+//\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+// native dependency because the rlib is just an archive.\n+//\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate are purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n+                                 sess: &Session,\n+                                 codegen_results: &CodegenResults,\n+                                 crate_type: config::CrateType) {\n+    // Be sure to use a topological sorting of crates because there may be\n+    // interdependencies between native libraries. When passing -nodefaultlibs,\n+    // for example, almost all native libraries depend on libc, so we have to\n+    // make sure that's all the way at the right (liblibc is near the base of\n+    // the dependency chain).\n+    //\n+    // This passes RequireStatic, but the actual requirement doesn't matter,\n+    // we're just getting an ordering of crate numbers, we're not worried about\n+    // the paths.\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    let crates = &codegen_results.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n+        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n+            let name = match lib.name {\n+                Some(ref l) => l,\n+                None => continue,\n+            };\n+            if !relevant_lib(sess, &lib) {\n+                continue\n+            }\n+            match lib.kind {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+                NativeLibraryKind::NativeStaticNobundle => {\n+                    // Link \"static-nobundle\" native libs only if the crate they originate from\n+                    // is being linked statically to the current crate.  If it's linked dynamically\n+                    // or is an rlib already included via some other dylib crate, the symbols from\n+                    // native libs will have already been included in that dylib.\n+                    if data[cnum.as_usize() - 1] == Linkage::Static {\n+                        cmd.link_staticlib(&name.as_str())\n+                    }\n+                },\n+                // ignore statically included native libraries here as we've\n+                // already included them when we included the rust library\n+                // previously\n+                NativeLibraryKind::NativeStatic => {}\n+            }\n+        }\n+    }\n+}\n+\n+pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => syntax::attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+    match sess.lto() {\n+        config::Lto::Fat => true,\n+        config::Lto::Thin => {\n+            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n+            // any upstream object files have not been copied yet.\n+            !sess.opts.cg.linker_plugin_lto.enabled()\n+        }\n+        config::Lto::No |\n+        config::Lto::ThinLocal => false,\n+    }\n+}\n+\n+fn is_pic(sess: &Session) -> bool {\n+    let reloc_model_arg = match sess.opts.cg.relocation_model {\n+        Some(ref s) => &s[..],\n+        None => &sess.target.target.options.relocation_model[..],\n+    };\n+\n+    reloc_model_arg == \"pic\"\n+}"}, {"sha": "a16d099ee3e4d0f16120b6ae1eea3dbcd354b36a", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -5,3 +5,5 @@ pub mod link;\n pub mod command;\n pub mod symbol_export;\n pub mod archive;\n+pub mod rpath;\n+pub mod wasm;"}, {"sha": "2b7abcb52bef8cf5391c551c3c7127592e8c5360", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "previous_filename": "src/librustc_codegen_llvm/back/rpath.rs"}, {"sha": "f90bb89fbe87d66c6f8516af5a32508b3b5ba43b", "filename": "src/librustc_codegen_ssa/back/wasm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "previous_filename": "src/librustc_codegen_llvm/back/wasm.rs"}, {"sha": "d60a2e0cb1358e0f67ad22722ff89f87215a2364", "filename": "src/librustc_codegen_ssa/debuginfo/mod.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,6 +1,8 @@\n use syntax_pos::{BytePos, Span};\n use rustc::hir::def_id::CrateNum;\n \n+pub mod type_names;\n+\n pub enum FunctionDebugContext<D> {\n     RegularContext(FunctionDebugContextData<D>),\n     DebugInfoDisabled,", "previous_filename": "src/librustc_codegen_ssa/debuginfo.rs"}, {"sha": "fee6c5b04d0d13d9c028627fc2e787c1b1232e35", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "renamed", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -1,39 +1,34 @@\n // Type Names for Debug Info.\n \n-use crate::common::CodegenCx;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, Ty};\n-use rustc_codegen_ssa::traits::*;\n+use rustc::hir::{self, def_id::DefId};\n+use rustc::ty::{self, Ty, TyCtxt, subst::SubstsRef};\n use rustc_data_structures::fx::FxHashSet;\n \n-use rustc::hir;\n-\n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e., type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)\n                                              -> String {\n     let mut result = String::with_capacity(64);\n     let mut visited = FxHashSet::default();\n-    push_debuginfo_type_name(cx, t, qualified, &mut result, &mut visited);\n+    push_debuginfo_type_name(tcx, t, qualified, &mut result, &mut visited);\n     result\n }\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n                                           output: &mut String,\n                                           visited: &mut FxHashSet<Ty<'tcx>>) {\n \n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n+    let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n \n     match t.sty {\n         ty::Bool => output.push_str(\"bool\"),\n@@ -43,15 +38,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Int(int_ty) => output.push_str(int_ty.ty_to_string()),\n         ty::Uint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n         ty::Float(float_ty) => output.push_str(float_ty.ty_to_string()),\n-        ty::Foreign(def_id) => push_item_name(cx, def_id, qualified, output),\n+        ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            push_item_name(cx, def.did, qualified, output);\n-            push_type_params(cx, substs, output, visited);\n+            push_item_name(tcx, def.did, qualified, output);\n+            push_type_params(tcx, substs, output, visited);\n         },\n         ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_debuginfo_type_name(cx, component_type, true, output, visited);\n+                push_debuginfo_type_name(tcx, component_type, true, output, visited);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -69,7 +64,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n+            push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n@@ -83,16 +78,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push_str(\"mut \");\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n+            push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n             }\n         },\n         ty::Array(inner_type, len) => {\n             output.push('[');\n-            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n-            output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n+            push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n+            output.push_str(&format!(\"; {}\", len.unwrap_usize(tcx)));\n             output.push(']');\n         },\n         ty::Slice(inner_type) => {\n@@ -102,7 +97,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('[');\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n+            push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('>');\n@@ -112,12 +107,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         },\n         ty::Dynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx.normalize_erasing_late_bound_regions(\n+                let principal = tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n                     &principal,\n                 );\n-                push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output, visited);\n+                push_item_name(tcx, principal.def_id, false, output);\n+                push_type_params(tcx, principal.substs, output, visited);\n             } else {\n                 output.push_str(\"dyn '_\");\n             }\n@@ -142,24 +137,24 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n \n \n-            let sig = t.fn_sig(cx.tcx);\n+            let sig = t.fn_sig(tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n \n             let abi = sig.abi();\n-            if abi != crate::abi::Abi::Rust {\n+            if abi != rustc_target::spec::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n                 output.push_str(\"\\\" \");\n             }\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+            let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n-                    push_debuginfo_type_name(cx, parameter_type, true, output, visited);\n+                    push_debuginfo_type_name(tcx, parameter_type, true, output, visited);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -178,7 +173,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output(), true, output, visited);\n+                push_debuginfo_type_name(tcx, sig.output(), true, output, visited);\n             }\n \n \n@@ -213,18 +208,18 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(cx: &CodegenCx<'_, '_>,\n+    fn push_item_name(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx.crate_name(def_id.krate).as_str());\n-            for path_element in cx.tcx.def_path(def_id).data {\n+            output.push_str(&tcx.crate_name(def_id.krate).as_str());\n+            for path_element in tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str().as_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx.item_name(def_id).as_str());\n+            output.push_str(&tcx.item_name(def_id).as_str());\n         }\n     }\n \n@@ -233,7 +228,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+    fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   substs: SubstsRef<'tcx>,\n                                   output: &mut String,\n                                   visited: &mut FxHashSet<Ty<'tcx>>) {\n@@ -244,7 +239,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         output.push('<');\n \n         for type_parameter in substs.types() {\n-            push_debuginfo_type_name(cx, type_parameter, true, output, visited);\n+            push_debuginfo_type_name(tcx, type_parameter, true, output, visited);\n             output.push_str(\", \");\n         }\n ", "previous_filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs"}, {"sha": "9d3d6ef854990015723d3e493de7cba50f027ecd", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1732212fb5f6c6653a776a0ce46bc73ce77ebb/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=0d1732212fb5f6c6653a776a0ce46bc73ce77ebb", "patch": "@@ -66,6 +66,7 @@ pub struct ModuleCodegen<M> {\n     pub kind: ModuleKind,\n }\n \n+pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n \n impl<M> ModuleCodegen<M> {"}]}