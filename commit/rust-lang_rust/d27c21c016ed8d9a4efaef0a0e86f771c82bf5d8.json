{"sha": "d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyN2MyMWMwMTZlZDhkOWE0ZWZhZWYwYTBlODZmNzcxYzgyYmY1ZDg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-28T19:53:20Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:05Z"}, "message": "Refactor for less allocation", "tree": {"sha": "90058b71907dcbab16fbb32c2fcb48143f97850b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90058b71907dcbab16fbb32c2fcb48143f97850b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "html_url": "https://github.com/rust-lang/rust/commit/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c21a0322c55c2da7f2b1479cb631b8596901f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c21a0322c55c2da7f2b1479cb631b8596901f1c", "html_url": "https://github.com/rust-lang/rust/commit/6c21a0322c55c2da7f2b1479cb631b8596901f1c"}], "stats": {"total": 136, "additions": 69, "deletions": 67}, "files": [{"sha": "4cd70a0f57d313234c45b44199b7385f6cfeff11", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "patch": "@@ -612,7 +612,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n /// regardless of the signedness.\n /// For example, the pattern `-128...127i8` is encoded as `0..=255`.\n /// This makes comparisons and arithmetic on interval endpoints much more\n-/// straightforward. See `encode` and `decode` for details.\n+/// straightforward. See `signed_bias` for details.\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n@@ -660,6 +660,8 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n+    // The return value of `signed_bias` should be\n+    // XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::TyInt(ity) => {\n@@ -670,54 +672,52 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn into_inner(self) -> (u128, u128) {\n-        self.range.into_inner()\n-    }\n-}\n-\n-/// Given a pattern in a `match` and a collection of ranges corresponding to the\n-/// domain of values of a type (say, an integer), return a new collection of ranges\n-/// corresponding to those ranges minus the ranges covered by the pattern.\n-fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                     pat_ctor: &Constructor<'tcx>,\n-                                     ranges: Vec<Constructor<'tcx>>)\n-                                     -> Vec<Constructor<'tcx>> {\n-    if let Some(pat_interval) = IntRange::from_ctor(cx.tcx, pat_ctor) {\n+    /// Given an `IntRange` corresponding to a pattern in a `match` and a collection of\n+    /// ranges corresponding to the domain of values of a type (say, an integer), return\n+    /// a new collection of ranges corresponding to the original ranges minus the ranges\n+    /// covered by the `IntRange`.\n+    fn subtract_from(self,\n+                     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                     ranges: Vec<Constructor<'tcx>>)\n+                     -> Vec<Constructor<'tcx>> {\n+        let ranges = ranges.into_iter().filter_map(|r| {\n+            IntRange::from_ctor(tcx, &r).map(|i| i.range)\n+        });\n+        // Convert a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n+        let bias = IntRange::signed_bias(tcx, self.ty);\n+        let ty = ty::ParamEnv::empty().and(self.ty);\n+        let range_to_constant = |r: RangeInclusive<u128>| {\n+            let (lo, hi) = r.into_inner();\n+            if lo == hi {\n+                ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+            } else {\n+                ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n+                              ty::Const::from_bits(tcx, hi ^ bias, ty),\n+                              RangeEnd::Included)\n+            }\n+        };\n         let mut remaining_ranges = vec![];\n-        let mut ranges: Vec<_> = ranges.into_iter().filter_map(|r| {\n-            IntRange::from_ctor(cx.tcx, &r).map(|i| i.into_inner())\n-        }).collect();\n-        let ty = pat_interval.ty;\n-        let (pat_interval_lo, pat_interval_hi) = pat_interval.into_inner();\n-        for (subrange_lo, subrange_hi) in ranges {\n-            if pat_interval_lo > subrange_hi || subrange_lo > pat_interval_hi  {\n+        let (lo, hi) = self.range.into_inner();\n+        for subrange in ranges {\n+            let (subrange_lo, subrange_hi) = subrange.into_inner();\n+            if lo > subrange_hi || subrange_lo > hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(subrange_lo..=subrange_hi);\n+                remaining_ranges.push(range_to_constant(subrange_lo..=subrange_hi));\n             } else {\n-                if pat_interval_lo > subrange_lo {\n+                if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(subrange_lo..=(pat_interval_lo - 1));\n+                    remaining_ranges.push(range_to_constant(subrange_lo..=(lo - 1)));\n                 }\n-                if pat_interval_hi < subrange_hi {\n+                if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push((pat_interval_hi + 1)..=subrange_hi);\n+                    remaining_ranges.push(range_to_constant((hi + 1)..=subrange_hi));\n                 }\n             }\n         }\n-        // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n-        remaining_ranges.into_iter().map(|r| {\n-            let (lo, hi) = r.into_inner();\n-            let bias = IntRange::signed_bias(cx.tcx, ty);\n-            let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantRange(ty::Const::from_bits(cx.tcx, lo ^ bias, ty),\n-                          ty::Const::from_bits(cx.tcx, hi ^ bias, ty),\n-                          RangeEnd::Included)\n-        }).collect()\n-    } else {\n-        ranges\n+        remaining_ranges\n     }\n }\n \n@@ -818,38 +818,41 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // `missing_ctors` are those that should have appeared\n         // as patterns in the `match` expression, but did not.\n         let mut missing_ctors = vec![];\n-        'req: for req_ctor in &all_ctors {\n-            let mut sub_ctors = vec![req_ctor.clone()];\n+        for req_ctor in &all_ctors {\n             // The only constructor patterns for which it is valid to\n             // treat the values as constructors are ranges (see\n             // `all_constructors` for details).\n             let consider_value_constructors = value_constructors && match req_ctor {\n                 ConstantRange(..) => true,\n                 _ => false,\n             };\n-            for used_ctor in &used_ctors {\n-                if consider_value_constructors {\n-                    sub_ctors = ranges_subtract_pattern(cx, used_ctor, sub_ctors);\n+            if consider_value_constructors {\n+                let mut refined_ctors = vec![req_ctor.clone()];\n+                for used_ctor in &used_ctors {\n+                    // Refine the required constructors for the type by subtracting\n+                    // the range defined by the current constructor pattern.\n+                    refined_ctors = match IntRange::from_ctor(cx.tcx, used_ctor) {\n+                        Some(interval) => interval.subtract_from(cx.tcx, refined_ctors),\n+                        None => refined_ctors,\n+                    };\n                     // If the constructor patterns that have been considered so far\n                     // already cover the entire range of values, then we the\n                     // constructor is not missing, and we can move on to the next one.\n-                    if sub_ctors.is_empty() {\n-                        continue 'req;\n-                    }\n-                } else {\n-                    // If the pattern for the required constructor\n-                    // appears in the `match`, then it is not missing,\n-                    // and we can move on to the next one.\n-                    if used_ctor == req_ctor {\n-                        continue 'req;\n+                    if refined_ctors.is_empty() {\n+                        break;\n                     }\n                 }\n+                // If a constructor has not been matched, then it is missing.\n+                // We add `refined_ctors` instead of `req_ctor`, because then we can\n+                // provide more detailed error information about precisely which\n+                // ranges have been omitted.\n+                missing_ctors.extend(refined_ctors);\n+            } else {\n+                // A constructor is missing if it never appears in a `match` arm.\n+                if !used_ctors.iter().any(|used_ctor| used_ctor == req_ctor) {\n+                    missing_ctors.push(req_ctor.clone());\n+                }\n             }\n-            // If a constructor has not been matched, then it is missing.\n-            // We add `sub_ctors` instead of `req_ctor`, because then we can\n-            // provide more detailed error information about precisely which\n-            // ranges have been omitted.\n-            missing_ctors.extend(sub_ctors);\n         }\n \n         // `missing_ctors` is the set of constructors from the same type as the\n@@ -968,11 +971,11 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 match ctor {\n                                     // A constant range of length 1 is simply\n                                     // a constant value.\n-                                    ConstantRange(lo, hi, _) if lo == hi => {\n+                                    ConstantValue(value) => {\n                                         Witness(vec![Pattern {\n                                             ty: pcx.ty,\n                                             span: DUMMY_SP,\n-                                            kind: box PatternKind::Constant { value: lo },\n+                                            kind: box PatternKind::Constant { value },\n                                         }])\n                                     }\n                                     // We always report missing intervals"}, {"sha": "7ec9373130419e82fa26794384fce1efef9cc16a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d27c21c016ed8d9a4efaef0a0e86f771c82bf5d8", "patch": "@@ -368,9 +368,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     \"lower range bound must be less than upper\",\n                                 );\n                                 PatternKind::Wild\n-                            },\n-                            (RangeEnd::Included, None) |\n-                            (RangeEnd::Included, Some(Ordering::Greater)) => {\n+                            }\n+                            (RangeEnd::Included, Some(Ordering::Equal)) => {\n+                                PatternKind::Constant { value: lo }\n+                            }\n+                            (RangeEnd::Included, Some(Ordering::Less)) => {\n+                                PatternKind::Range { lo, hi, end }\n+                            }\n+                            (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n                                     self.tcx.sess,\n                                     lo_expr.span,\n@@ -390,12 +395,6 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 }\n                                 err.emit();\n                                 PatternKind::Wild\n-                            },\n-                            (RangeEnd::Included, Some(Ordering::Equal)) => {\n-                                PatternKind::Constant { value: lo }\n-                            }\n-                            (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range { lo, hi, end }\n                             }\n                         }\n                     }"}]}