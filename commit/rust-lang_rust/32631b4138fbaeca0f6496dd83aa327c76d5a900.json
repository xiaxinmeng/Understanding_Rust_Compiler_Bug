{"sha": "32631b4138fbaeca0f6496dd83aa327c76d5a900", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNjMxYjQxMzhmYmFlY2EwZjY0OTZkZDgzYWEzMjdjNzZkNWE5MDA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-06T03:28:44Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-06T03:28:44Z"}, "message": "Rollup merge of #23010 - alexcrichton:deprecate-some-old-io, r=aturon\n\n The new `io` module has had some time to bake and this commit stabilizes some of\nthe utilities associated with it. This commit also deprecates a number of\n`std::old_io::util` functions and structures.\n\nThese items are now `#[stable]`\n\n* `Cursor`\n* `Cursor::{new, into_inner, get_ref, get_mut, position, set_position}`\n* Implementations of I/O traits for `Cursor<T>`\n* Delegating implementations of I/O traits for references and `Box` pointers\n* Implementations of I/O traits for primitives like slices and `Vec<T>`\n* `ReadExt::bytes`\n* `Bytes` (and impls)\n* `ReadExt::chain`\n* `Chain` (and impls)\n* `ReadExt::take` (and impls)\n* `BufReadExt::lines`\n* `Lines` (and impls)\n* `io::copy`\n* `io::{empty, Empty}` (and impls)\n* `io::{sink, Sink}` (and impls)\n* `io::{repeat, Repeat}` (and impls)\n\nThese items remain `#[unstable]`\n\n* Core I/O traits. These may want a little bit more time to bake along with the\n  commonly used methods like `read_to_end`.\n* `BufReadExt::split` - this function may be renamed to not conflict with\n  `SliceExt::split`.\n* `Error` - there are a number of questions about its representation,\n  `ErrorKind`, and usability.\n\nThese items are now `#[deprecated]` in `old_io`\n\n* `LimitReader` - use `take` instead\n* `NullWriter` - use `io::sink` instead\n* `ZeroReader` - use `io::repeat` instead\n* `NullReader` - use `io::empty` instead\n* `MultiWriter` - use `broadcast` instead\n* `ChainedReader` - use `chain` instead\n* `TeeReader` - use `tee` instead\n* `copy` - use `io::copy` instead\n\n[breaking-change]", "tree": {"sha": "a9fa2541e2f0a5dc6638fc6a44e53f456f836215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9fa2541e2f0a5dc6638fc6a44e53f456f836215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32631b4138fbaeca0f6496dd83aa327c76d5a900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32631b4138fbaeca0f6496dd83aa327c76d5a900", "html_url": "https://github.com/rust-lang/rust/commit/32631b4138fbaeca0f6496dd83aa327c76d5a900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32631b4138fbaeca0f6496dd83aa327c76d5a900/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efb487b503d87f04448fc5e6f75038ca98b8670e", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb487b503d87f04448fc5e6f75038ca98b8670e", "html_url": "https://github.com/rust-lang/rust/commit/efb487b503d87f04448fc5e6f75038ca98b8670e"}, {"sha": "0dfa9978cc57efc8eb51485fc3a333eafd1aa392", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dfa9978cc57efc8eb51485fc3a333eafd1aa392", "html_url": "https://github.com/rust-lang/rust/commit/0dfa9978cc57efc8eb51485fc3a333eafd1aa392"}], "stats": {"total": 185, "additions": 167, "deletions": 18}, "files": [{"sha": "832348a00a651321eb0b4e3ffb6287c620ef301d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -775,6 +775,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n+#[allow(deprecated)]\n pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n     const STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n "}, {"sha": "62001d77d264c1bbf1ba5ec5e4931f202bbb2879", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -111,6 +111,7 @@ pub fn run(input: &str,\n     0\n }\n \n+#[allow(deprecated)]\n fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n            externs: core::Externs,\n            should_fail: bool, no_run: bool, as_test_harness: bool) {"}, {"sha": "2445f5a7a40403e8c7f15190953b70e48926e77d", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_copy_implementations)]\n-\n use prelude::v1::*;\n use io::prelude::*;\n \n@@ -32,33 +30,40 @@ use slice;\n /// Implementations of the I/O traits for `Cursor<T>` are not currently generic\n /// over `T` itself. Instead, specific implementations are provided for various\n /// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cursor<T> {\n     inner: T,\n     pos: u64,\n }\n \n impl<T> Cursor<T> {\n     /// Create a new cursor wrapping the provided underlying I/O object.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: T) -> Cursor<T> {\n         Cursor { pos: 0, inner: inner }\n     }\n \n     /// Consume this cursor, returning the underlying value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T { self.inner }\n \n     /// Get a reference to the underlying value in this cursor.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &T { &self.inner }\n \n     /// Get a mutable reference to the underlying value in this cursor.\n     ///\n     /// Care should be taken to avoid modifying the internal I/O state of the\n     /// underlying value as it may corrupt this cursor's position.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.inner }\n \n     /// Returns the current value of this cursor\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn position(&self) -> u64 { self.pos }\n \n     /// Sets the value of this cursor\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_position(&mut self, pos: u64) { self.pos = pos; }\n }\n \n@@ -83,8 +88,11 @@ macro_rules! seek {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> io::Seek for Cursor<&'a [u8]> { seek!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> io::Seek for Cursor<&'a mut [u8]> { seek!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl io::Seek for Cursor<Vec<u8>> { seek!(); }\n \n macro_rules! read {\n@@ -97,8 +105,11 @@ macro_rules! read {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for Cursor<&'a [u8]> { read!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for Cursor<&'a mut [u8]> { read!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Cursor<Vec<u8>> { read!(); }\n \n macro_rules! buffer {\n@@ -111,10 +122,14 @@ macro_rules! buffer {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for Cursor<&'a [u8]> { buffer!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for Cursor<&'a mut [u8]> { buffer!(); }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for Cursor<Vec<u8>> { buffer!(); }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for Cursor<&'a mut [u8]> {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let pos = cmp::min(self.pos, self.inner.len() as u64);\n@@ -125,6 +140,7 @@ impl<'a> Write for Cursor<&'a mut [u8]> {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Cursor<Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         // Make sure the internal buffer is as least as big as where we"}, {"sha": "c968415d3efdc5670cdee690fb3cea0c6bf60032", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -22,57 +22,88 @@ use vec::Vec;\n // =============================================================================\n // Forwarding implementations\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, R: Read + ?Sized> Read for &'a mut R {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n-\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> { (**self).read_to_end(buf) }\n-\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+        (**self).read_to_end(buf)\n+    }\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n         (**self).read_to_string(buf)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, W: Write + ?Sized> Write for &'a mut W {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n-\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> { (**self).write_all(buf) }\n-\n-    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> { (**self).write_fmt(fmt) }\n-\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        (**self).write_all(buf)\n+    }\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n+        (**self).write_fmt(fmt)\n+    }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n-\n     fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n-\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> {\n         (**self).read_until(byte, buf)\n     }\n-\n-    fn read_line(&mut self, buf: &mut String) -> io::Result<()> { (**self).read_line(buf) }\n+    fn read_line(&mut self, buf: &mut String) -> io::Result<()> {\n+        (**self).read_line(buf)\n+    }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read + ?Sized> Read for Box<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+        (**self).read_to_end(buf)\n+    }\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+        (**self).read_to_string(buf)\n+    }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for Box<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        (**self).write_all(buf)\n+    }\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n+        (**self).write_fmt(fmt)\n+    }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Seek + ?Sized> Seek for Box<S> {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n     fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> {\n+        (**self).read_until(byte, buf)\n+    }\n+    fn read_line(&mut self, buf: &mut String) -> io::Result<()> {\n+        (**self).read_line(buf)\n+    }\n }\n \n // =============================================================================\n // In-memory buffer implementations\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n@@ -83,11 +114,13 @@ impl<'a> Read for &'a [u8] {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for &'a [u8] {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n     fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a mut [u8] {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let amt = cmp::min(data.len(), self.len());\n@@ -108,14 +141,15 @@ impl<'a> Write for &'a mut [u8] {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Vec<u8> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.push_all(buf);\n         Ok(buf.len())\n     }\n \n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        try!(self.write(buf));\n+        self.push_all(buf);\n         Ok(())\n     }\n "}, {"sha": "9137068076b46818d30eb55a5d5cf77d5a0845a9", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -237,11 +237,13 @@ pub trait Read {\n \n /// Extension methods for all instances of `Read`, typically imported through\n /// `std::io::prelude::*`.\n+#[unstable(feature = \"io\", reason = \"may merge into the Read trait\")]\n pub trait ReadExt: Read + Sized {\n     /// Create a \"by reference\" adaptor for this instance of `Read`.\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self { self }\n \n     /// Transform this `Read` instance to an `Iterator` over its bytes.\n@@ -250,6 +252,7 @@ pub trait ReadExt: Read + Sized {\n     /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n     /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n     /// this iterator.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(self) -> Bytes<Self> {\n         Bytes { inner: self }\n     }\n@@ -264,6 +267,9 @@ pub trait ReadExt: Read + Sized {\n     ///\n     /// Currently this adaptor will discard intermediate data read, and should\n     /// be avoided if this is not desired.\n+    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n+                                         of where errors happen is currently \\\n+                                         unclear and may change\")]\n     fn chars(self) -> Chars<Self> {\n         Chars { inner: self }\n     }\n@@ -273,6 +279,7 @@ pub trait ReadExt: Read + Sized {\n     /// The returned `Read` instance will first read all bytes from this object\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n     /// output of `next`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<R: Read>(self, next: R) -> Chain<Self, R> {\n         Chain { first: self, second: next, done_first: false }\n     }\n@@ -283,6 +290,7 @@ pub trait ReadExt: Read + Sized {\n     /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n     /// read errors will not count towards the number of bytes read and future\n     /// calls to `read` may succeed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, limit: u64) -> Take<Self> {\n         Take { inner: self, limit: limit }\n     }\n@@ -293,6 +301,9 @@ pub trait ReadExt: Read + Sized {\n     /// Whenever the returned `Read` instance is read it will write the read\n     /// data to `out`. The current semantics of this implementation imply that\n     /// a `write` error will not report how much data was initially read.\n+    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n+                                         of where errors happen is currently \\\n+                                         unclear and may change\")]\n     fn tee<W: Write>(self, out: W) -> Tee<Self, W> {\n         Tee { reader: self, writer: out }\n     }\n@@ -415,11 +426,13 @@ pub trait Write {\n \n /// Extension methods for all instances of `Write`, typically imported through\n /// `std::io::prelude::*`.\n+#[unstable(feature = \"io\", reason = \"may merge into the Read trait\")]\n pub trait WriteExt: Write + Sized {\n     /// Create a \"by reference\" adaptor for this instance of `Write`.\n     ///\n     /// The returned adaptor also implements `Write` and will simply borrow this\n     /// current writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self { self }\n \n     /// Creates a new writer which will write all data to both this writer and\n@@ -430,11 +443,15 @@ pub trait WriteExt: Write + Sized {\n     /// implementation do not precisely track where errors happen. For example\n     /// an error on the second call to `write` will not report that the first\n     /// call to `write` succeeded.\n+    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n+                                         of where errors happen is currently \\\n+                                         unclear and may change\")]\n     fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W> {\n         Broadcast { first: self, second: other }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Write> WriteExt for T {}\n \n /// An object implementing `Seek` internally has some form of cursor which can\n@@ -592,6 +609,8 @@ pub trait BufReadExt: BufRead + Sized {\n     ///\n     /// This function will yield errors whenever `read_until` would have also\n     /// yielded an error.\n+    #[unstable(feature = \"io\", reason = \"may be renamed to not conflict with \\\n+                                         SliceExt::split\")]\n     fn split(self, byte: u8) -> Split<Self> {\n         Split { buf: self, delim: byte }\n     }\n@@ -604,11 +623,13 @@ pub trait BufReadExt: BufRead + Sized {\n     ///\n     /// This function will yield errors whenever `read_string` would have also\n     /// yielded an error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self> {\n         Lines { buf: self }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: BufRead> BufReadExt for T {}\n \n /// A `Write` adaptor which will write data to multiple locations.\n@@ -635,12 +656,14 @@ impl<T: Write, U: Write> Write for Broadcast<T, U> {\n /// Adaptor to chain together two instances of `Read`.\n ///\n /// For more information, see `ReadExt::chain`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<T, U> {\n     first: T,\n     second: U,\n     done_first: bool,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Read, U: Read> Read for Chain<T, U> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         if !self.done_first {\n@@ -656,11 +679,13 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n /// Reader adaptor which limits the bytes read from an underlying reader.\n ///\n /// For more information, see `ReadExt::take`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<T> {\n     inner: T,\n     limit: u64,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Take<T> {\n     /// Returns the number of bytes that can be read before this instance will\n     /// return EOF.\n@@ -669,9 +694,11 @@ impl<T> Take<T> {\n     ///\n     /// This instance may reach EOF after reading fewer bytes than indicated by\n     /// this method if the underlying `Read` instance reaches EOF.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn limit(&self) -> u64 { self.limit }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Read> Read for Take<T> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         // Don't call into inner reader at all at EOF because it may still block\n@@ -686,6 +713,7 @@ impl<T: Read> Read for Take<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: BufRead> BufRead for Take<T> {\n     fn fill_buf(&mut self) -> Result<&[u8]> {\n         let buf = try!(self.inner.fill_buf());\n@@ -721,10 +749,12 @@ impl<R: Read, W: Write> Read for Tee<R, W> {\n /// A bridge from implementations of `Read` to an `Iterator` of `u8`.\n ///\n /// See `ReadExt::bytes` for more information.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Bytes<R> {\n     inner: R,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read> Iterator for Bytes<R> {\n     type Item = Result<u8>;\n \n@@ -845,10 +875,12 @@ impl<B: BufRead> Iterator for Split<B> {\n /// byte.\n ///\n /// See `BufReadExt::lines` for more information.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<B> {\n     buf: B,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead> Iterator for Lines<B> {\n     type Item = Result<String>;\n "}, {"sha": "20426025257c3761a8bba56c4281f5093ac49ccb", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n \n-use io::{self, Read, Write, ErrorKind};\n+use io::{self, Read, Write, ErrorKind, BufRead};\n \n /// Copies the entire contents of a reader into a writer.\n ///\n@@ -27,6 +27,7 @@ use io::{self, Read, Write, ErrorKind};\n /// This function will return an error immediately if any call to `read` or\n /// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n /// handled by this function and the underlying operation is retried.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: Read, W: Write>(r: &mut R, w: &mut W) -> io::Result<u64> {\n     let mut buf = [0; super::DEFAULT_BUF_SIZE];\n     let mut written = 0;\n@@ -43,26 +44,37 @@ pub fn copy<R: Read, W: Write>(r: &mut R, w: &mut W) -> io::Result<u64> {\n }\n \n /// A reader which is always at EOF.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Empty { _priv: () }\n \n /// Creates an instance of an empty reader.\n ///\n /// All reads from the returned reader will return `Ok(0)`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn empty() -> Empty { Empty { _priv: () } }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Empty {\n     fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl BufRead for Empty {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(&[]) }\n+    fn consume(&mut self, _n: usize) {}\n+}\n \n /// A reader which infinitely yields one byte.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat { byte: u8 }\n \n /// Creates an instance of a reader that infinitely repeats one byte.\n ///\n /// All reads from this reader will succeed by filling the specified buffer with\n /// the given byte.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Repeat {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         for slot in buf.iter_mut() {\n@@ -73,14 +85,17 @@ impl Read for Repeat {\n }\n \n /// A writer which will move data into the void.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sink { _priv: () }\n \n /// Creates an instance of a writer which will successfully consume all data.\n ///\n /// All calls to `write` on the returned instance will return `Ok(buf.len())`\n /// and the contents of the buffer will not be inspected.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sink() -> Sink { Sink { _priv: () } }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Sink {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }"}, {"sha": "4faf8af57b4c4392da158935f543aa28436e15ef", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32631b4138fbaeca0f6496dd83aa327c76d5a900/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=32631b4138fbaeca0f6496dd83aa327c76d5a900", "patch": "@@ -10,20 +10,28 @@\n \n //! Utility implementations of Reader and Writer\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n use cmp;\n use old_io;\n use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n #[derive(Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n+#[unstable(feature = \"old_io\")]\n pub struct LimitReader<R> {\n     limit: uint,\n     inner: R\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Reader> LimitReader<R> {\n     /// Creates a new `LimitReader`\n+    #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn new(r: R, limit: uint) -> LimitReader<R> {\n         LimitReader { limit: limit, inner: r }\n     }\n@@ -41,6 +49,8 @@ impl<R: Reader> LimitReader<R> {\n     pub fn limit(&self) -> uint { self.limit }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Reader> Reader for LimitReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         if self.limit == 0 {\n@@ -57,6 +67,8 @@ impl<R: Reader> Reader for LimitReader<R> {\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n@@ -79,17 +91,25 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n \n /// A `Writer` which ignores bytes written to it, like /dev/null.\n #[derive(Copy, Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct NullWriter;\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n+#[unstable(feature = \"old_io\")]\n impl Writer for NullWriter {\n     #[inline]\n     fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n #[derive(Copy, Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct ZeroReader;\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n+#[unstable(feature = \"old_io\")]\n impl Reader for ZeroReader {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n@@ -98,6 +118,8 @@ impl Reader for ZeroReader {\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n+#[unstable(feature = \"old_io\")]\n impl Buffer for ZeroReader {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         static DATA: [u8; 64] = [0; 64];\n@@ -109,15 +131,21 @@ impl Buffer for ZeroReader {\n \n /// A `Reader` which is always at EOF, like /dev/null.\n #[derive(Copy, Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct NullReader;\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n+#[unstable(feature = \"old_io\")]\n impl Reader for NullReader {\n     #[inline]\n     fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n+#[unstable(feature = \"old_io\")]\n impl Buffer for NullReader {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n@@ -130,17 +158,23 @@ impl Buffer for NullReader {\n /// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n /// that error is returned immediately and remaining `Writer`s are not called.\n #[derive(Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct MultiWriter<W> {\n     writers: Vec<W>\n }\n \n impl<W> MultiWriter<W> where W: Writer {\n     /// Creates a new `MultiWriter`\n+    #[deprecated(since = \"1.0.0\", reason = \"use std::io's broadcast method instead\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn new(writers: Vec<W>) -> MultiWriter<W> {\n         MultiWriter { writers: writers }\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n@@ -162,19 +196,25 @@ impl<W> Writer for MultiWriter<W> where W: Writer {\n /// A `Reader` which chains input from multiple `Reader`s, reading each to\n /// completion before moving onto the next.\n #[derive(Clone, Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct ChainedReader<I, R> {\n     readers: I,\n     cur_reader: Option<R>,\n }\n \n impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n     /// Creates a new `ChainedReader`\n+    #[deprecated(since = \"1.0.0\", reason = \"use std::io's chain method instead\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn new(mut readers: I) -> ChainedReader<I, R> {\n         let r = readers.next();\n         ChainedReader { readers: readers, cur_reader: r }\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n     fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         loop {\n@@ -201,13 +241,19 @@ impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n /// A `Reader` which forwards input from another `Reader`, passing it along to\n /// a `Writer` as well. Similar to the `tee(1)` command.\n #[derive(Debug)]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n+#[unstable(feature = \"old_io\")]\n pub struct TeeReader<R, W> {\n     reader: R,\n     writer: W,\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Reader, W: Writer> TeeReader<R, W> {\n     /// Creates a new `TeeReader`\n+    #[deprecated(since = \"1.0.0\", reason = \"use std::io's tee method instead\")]\n+    #[unstable(feature = \"old_io\")]\n     pub fn new(r: R, w: W) -> TeeReader<R, W> {\n         TeeReader { reader: r, writer: w }\n     }\n@@ -220,6 +266,8 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n     }\n }\n \n+#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n+#[unstable(feature = \"old_io\")]\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n@@ -229,6 +277,8 @@ impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n }\n \n /// Copies all data from a `Reader` to a `Writer`.\n+#[deprecated(since = \"1.0.0\", reason = \"use std::io's copy function instead\")]\n+#[unstable(feature = \"old_io\")]\n pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> {\n     let mut buf = [0; super::DEFAULT_BUF_SIZE];\n     loop {"}]}