{"sha": "83b3c392187003236aafe10e153816c13f7b896d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYjNjMzkyMTg3MDAzMjM2YWFmZTEwZTE1MzgxNmMxM2Y3Yjg5NmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-11T16:56:59Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T15:23:50Z"}, "message": "rustc_metadata: use 0 in index::Index to indicate missing entries.", "tree": {"sha": "02aee155ac59de49d00bd810cbc993cc31bf641e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02aee155ac59de49d00bd810cbc993cc31bf641e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83b3c392187003236aafe10e153816c13f7b896d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83b3c392187003236aafe10e153816c13f7b896d", "html_url": "https://github.com/rust-lang/rust/commit/83b3c392187003236aafe10e153816c13f7b896d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83b3c392187003236aafe10e153816c13f7b896d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea134563e709af1fdcf07766b281b0407b1e3500", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea134563e709af1fdcf07766b281b0407b1e3500", "html_url": "https://github.com/rust-lang/rust/commit/ea134563e709af1fdcf07766b281b0407b1e3500"}], "stats": {"total": 20, "additions": 7, "deletions": 13}, "files": [{"sha": "d37765120be956058cd67bc680a4d5bcafd3e5c6", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83b3c392187003236aafe10e153816c13f7b896d/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b3c392187003236aafe10e153816c13f7b896d/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=83b3c392187003236aafe10e153816c13f7b896d", "patch": "@@ -2,9 +2,9 @@ use crate::schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc_serialize::opaque::Encoder;\n+use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n-use std::u32;\n use log::debug;\n \n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n@@ -73,7 +73,7 @@ impl FixedSizeEncoding for u32 {\n /// of each DefIndex. It is not required that all definitions appear\n /// in the metadata, nor that they are serialized in order, and\n /// therefore we first allocate the vector here and fill it with\n-/// `u32::MAX`. Whenever an index is visited, we fill in the\n+/// `0`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n crate struct Index<'tcx> {\n@@ -84,7 +84,7 @@ crate struct Index<'tcx> {\n impl Index<'tcx> {\n     crate fn new(max_index: usize) -> Self {\n         Index {\n-            positions: vec![0xff; max_index * 4],\n+            positions: vec![0; max_index * 4],\n             _marker: PhantomData,\n         }\n     }\n@@ -95,12 +95,11 @@ impl Index<'tcx> {\n     }\n \n     fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n-        assert!(entry.position.get() < (u32::MAX as usize));\n-        let position = entry.position.get() as u32;\n+        let position: u32 = entry.position.get().try_into().unwrap();\n         let array_index = item.index();\n \n         let positions = &mut self.positions;\n-        assert!(u32::read_from_bytes_at(positions, array_index) == u32::MAX,\n+        assert!(u32::read_from_bytes_at(positions, array_index) == 0,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item,\n                 u32::read_from_bytes_at(positions, array_index),\n@@ -130,12 +129,7 @@ impl Lazy<[Index<'tcx>]> {\n \n         let bytes = &bytes[self.position.get()..][..self.meta * 4];\n         let position = u32::read_from_bytes_at(bytes, def_index.index());\n-        if position == u32::MAX {\n-            debug!(\"Index::lookup: position=u32::MAX\");\n-            None\n-        } else {\n-            debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::from_position(NonZeroUsize::new(position as usize).unwrap()))\n-        }\n+        debug!(\"Index::lookup: position={:?}\", position);\n+        NonZeroUsize::new(position as usize).map(Lazy::from_position)\n     }\n }"}]}