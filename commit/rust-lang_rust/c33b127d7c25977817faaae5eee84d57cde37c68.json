{"sha": "c33b127d7c25977817faaae5eee84d57cde37c68", "node_id": "C_kwDOAAsO6NoAKGMzM2IxMjdkN2MyNTk3NzgxN2ZhYWFlNWVlZTg0ZDU3Y2RlMzdjNjg", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-29T08:52:19Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-29T08:58:36Z"}, "message": "The only reason we had to replace opaque types in closures was due to async fn desugaring, make that explicit", "tree": {"sha": "11a14bb09ef713e1544a6209a50af016ef69b4d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a14bb09ef713e1544a6209a50af016ef69b4d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c33b127d7c25977817faaae5eee84d57cde37c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c33b127d7c25977817faaae5eee84d57cde37c68", "html_url": "https://github.com/rust-lang/rust/commit/c33b127d7c25977817faaae5eee84d57cde37c68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c33b127d7c25977817faaae5eee84d57cde37c68/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77e88a7c7afce2389b16b385f494be2f836c43ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/77e88a7c7afce2389b16b385f494be2f836c43ff", "html_url": "https://github.com/rust-lang/rust/commit/77e88a7c7afce2389b16b385f494be2f836c43ff"}], "stats": {"total": 102, "additions": 35, "deletions": 67}, "files": [{"sha": "cc36d6a0a4fbef9ca772ad793972f5691332b60f", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=c33b127d7c25977817faaae5eee84d57cde37c68", "patch": "@@ -5,7 +5,7 @@ use hir::{HirId, OpaqueTyOrigin};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{\n@@ -38,38 +38,19 @@ pub struct OpaqueTypeDecl<'tcx> {\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n-pub enum ReplaceOpaqueTypes {\n-    /// Closures can't create hidden types for opaque types of their parent, as they\n-    /// do not have all the outlives information available. Also `type_of` looks for\n-    /// hidden types in the owner (so the closure's parent), so it would not find these\n-    /// definitions.\n-    OnlyForRPIT,\n-    All,\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn replace_opaque_types_with_inference_vars(\n         &self,\n         ty: Ty<'tcx>,\n         body_id: HirId,\n         span: Span,\n-        code: ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        replace: ReplaceOpaqueTypes,\n     ) -> InferOk<'tcx, Ty<'tcx>> {\n         if !ty.has_opaque_types() {\n             return InferOk { value: ty, obligations: vec![] };\n         }\n         let mut obligations = vec![];\n-        let replace_opaque_type = |def_id| match self.opaque_type_origin(def_id, span) {\n-            None => false,\n-            Some(OpaqueTyOrigin::FnReturn(..)) => true,\n-            // Not using `==` or `matches!` here to make sure we exhaustively match variants.\n-            Some(_) => match replace {\n-                ReplaceOpaqueTypes::OnlyForRPIT => false,\n-                ReplaceOpaqueTypes::All => true,\n-            },\n-        };\n+        let replace_opaque_type = |def_id| self.opaque_type_origin(def_id, span).is_some();\n         let value = ty.fold_with(&mut ty::fold::BottomUpFolder {\n             tcx: self.tcx,\n             lt_op: |lt| lt,\n@@ -78,7 +59,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ty::Opaque(def_id, _substs) if replace_opaque_type(def_id) => {\n                     let def_span = self.tcx.def_span(def_id);\n                     let span = if span.contains(def_span) { def_span } else { span };\n-                    let cause = ObligationCause::new(span, body_id, code.clone());\n+                    let code = traits::ObligationCauseCode::OpaqueReturnType(None);\n+                    let cause = ObligationCause::new(span, body_id, code);\n                     // FIXME(compiler-errors): We probably should add a new TypeVariableOriginKind\n                     // for opaque types, and then use that kind to fix the spans for type errors\n                     // that we see later on."}, {"sha": "1cd66d1426dbee5a0a01ddd50b0060dc1abba43a", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=c33b127d7c25977817faaae5eee84d57cde37c68", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n-use rustc_infer::infer::opaque_types::ReplaceOpaqueTypes;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -97,9 +96,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             declared_ret_ty,\n             body.value.hir_id,\n             decl.output.span(),\n-            traits::ObligationCauseCode::OpaqueReturnType(None),\n             param_env,\n-            ReplaceOpaqueTypes::All,\n         ));\n     // If we replaced declared_ret_ty with infer vars, then we must be infering\n     // an opaque type, so set a flag so we can improve diagnostics."}, {"sha": "131e594ed94f7dcc4ae4cb099a8185bde18c34b0", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c33b127d7c25977817faaae5eee84d57cde37c68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=c33b127d7c25977817faaae5eee84d57cde37c68", "patch": "@@ -7,16 +7,13 @@ use crate::rustc_middle::ty::subst::Subst;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::infer::opaque_types::ReplaceOpaqueTypes;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n-use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n-use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -430,14 +427,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = expected_sig.sig.map_bound(|sig| {\n-            let output = self.hide_parent_opaque_types(\n-                sig.output(),\n-                expected_sig.cause_span.unwrap_or(DUMMY_SP),\n-                body.id().hir_id,\n-            );\n             self.tcx.mk_fn_sig(\n                 sig.inputs().iter().cloned(),\n-                output,\n+                sig.output(),\n                 sig.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n@@ -609,23 +601,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // function.\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n                     debug!(\"closure is async fn body\");\n-                    self.deduce_future_output_from_obligations(expr_def_id).unwrap_or_else(|| {\n-                        // AFAIK, deducing the future output\n-                        // always succeeds *except* in error cases\n-                        // like #65159. I'd like to return Error\n-                        // here, but I can't because I can't\n-                        // easily (and locally) prove that we\n-                        // *have* reported an\n-                        // error. --nikomatsakis\n-                        astconv.ty_infer(None, decl.output.span())\n-                    })\n+                    self.deduce_future_output_from_obligations(expr_def_id, body.id().hir_id)\n+                        .unwrap_or_else(|| {\n+                            // AFAIK, deducing the future output\n+                            // always succeeds *except* in error cases\n+                            // like #65159. I'd like to return Error\n+                            // here, but I can't because I can't\n+                            // easily (and locally) prove that we\n+                            // *have* reported an\n+                            // error. --nikomatsakis\n+                            astconv.ty_infer(None, decl.output.span())\n+                        })\n                 }\n \n                 _ => astconv.ty_infer(None, decl.output.span()),\n             },\n         };\n-        let supplied_return =\n-            self.hide_parent_opaque_types(supplied_return, decl.output.span(), body.id().hir_id);\n \n         let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n@@ -646,31 +637,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n-    /// Closures can't create hidden types for opaque types of their parent, as they\n-    /// do not have all the outlives information available. Also `type_of` looks for\n-    /// hidden types in the owner (so the closure's parent), so it would not find these\n-    /// definitions.\n-    fn hide_parent_opaque_types(&self, ty: Ty<'tcx>, span: Span, body_id: hir::HirId) -> Ty<'tcx> {\n-        let InferOk { value, obligations } = self.replace_opaque_types_with_inference_vars(\n-            ty,\n-            body_id,\n-            span,\n-            ObligationCauseCode::MiscObligation,\n-            self.param_env,\n-            ReplaceOpaqueTypes::OnlyForRPIT,\n-        );\n-        self.register_predicates(obligations);\n-        value\n-    }\n-\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n     #[instrument(skip(self), level = \"debug\")]\n-    fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {\n+    fn deduce_future_output_from_obligations(\n+        &self,\n+        expr_def_id: DefId,\n+        body_id: hir::HirId,\n+    ) -> Option<Ty<'tcx>> {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n         });\n@@ -700,23 +678,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Infer(ty::TyVar(ret_vid)) => {\n                 self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n-                })\n+                })?\n             }\n             ty::Opaque(def_id, substs) => self\n                 .tcx\n                 .bound_explicit_item_bounds(def_id)\n                 .transpose_iter()\n                 .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-                .find_map(|(p, s)| get_future_output(p.subst(self.tcx, substs), s.0)),\n+                .find_map(|(p, s)| get_future_output(p.subst(self.tcx, substs), s.0))?,\n             ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\"\n             ),\n         };\n \n+        // async fn that have opaque types in their return type need to redo the conversion to inference variables\n+        // as they fetch the still opaque version from the signature.\n+        let InferOk { value: output_ty, obligations } = self\n+            .replace_opaque_types_with_inference_vars(\n+                output_ty,\n+                body_id,\n+                self.tcx.def_span(expr_def_id),\n+                self.param_env,\n+            );\n+        self.register_predicates(obligations);\n+\n         debug!(\"deduce_future_output_from_obligations: output_ty={:?}\", output_ty);\n-        output_ty\n+        Some(output_ty)\n     }\n \n     /// Given a projection like"}]}