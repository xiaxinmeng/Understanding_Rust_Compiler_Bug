{"sha": "202d401c2504f17133c50505b82fe4278ab2c842", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMmQ0MDFjMjUwNGYxNzEzM2M1MDUwNWI4MmZlNDI3OGFiMmM4NDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-09T14:23:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-09T14:41:54Z"}, "message": "miri: simplify singed operator overflow detection", "tree": {"sha": "15f241e1f5b2d3f4396f8d1518bb9b8445c2f9f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15f241e1f5b2d3f4396f8d1518bb9b8445c2f9f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/202d401c2504f17133c50505b82fe4278ab2c842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/202d401c2504f17133c50505b82fe4278ab2c842", "html_url": "https://github.com/rust-lang/rust/commit/202d401c2504f17133c50505b82fe4278ab2c842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/202d401c2504f17133c50505b82fe4278ab2c842/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a34df18b437319a7ff510077bbab95cf7ec6bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a34df18b437319a7ff510077bbab95cf7ec6bc", "html_url": "https://github.com/rust-lang/rust/commit/07a34df18b437319a7ff510077bbab95cf7ec6bc"}], "stats": {"total": 38, "additions": 14, "deletions": 24}, "files": [{"sha": "b4f6b5f89996b999102d30490569805a34e14bfe", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/202d401c2504f17133c50505b82fe4278ab2c842/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202d401c2504f17133c50505b82fe4278ab2c842/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=202d401c2504f17133c50505b82fe4278ab2c842", "patch": "@@ -134,9 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let mut r = r as u32;\n             let size = left_layout.size;\n             oflo |= r >= size.bits() as u32;\n-            if oflo {\n-                r %= size.bits() as u32;\n-            }\n+            r %= size.bits() as u32;\n             let result = if signed {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let result = match bin_op {\n@@ -168,6 +166,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         }\n \n+        let size = left_layout.size;\n+\n         // Operations that need special treatment for signed integers\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n@@ -195,32 +195,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l128 = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n-                let size = left_layout.size;\n-                match bin_op {\n-                    Rem | Div => {\n-                        // int_min / -1\n-                        if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_uint(l, size), true, left_layout.ty));\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-                trace!(\"{}, {}, {}\", l, l128, r);\n-                let (result, mut oflo) = op(l128, r);\n-                trace!(\"{}, {}\", result, oflo);\n-                if !oflo && size.bits() != 128 {\n-                    let max = 1 << (size.bits() - 1);\n-                    oflo = result >= max || result < -max;\n-                }\n-                // this may be out-of-bounds for the result type, so we have to truncate ourselves\n+\n+                let (result, oflo) = op(l128, r);\n+                // This may be out-of-bounds for the result type, so we have to truncate ourselves.\n+                // If that truncation loses any information, we have an overflow.\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n+                return Ok((\n+                    Scalar::from_uint(truncated, size),\n+                    oflo || self.sign_extend(truncated, left_layout) != result,\n+                    left_layout.ty,\n+                ));\n             }\n         }\n \n-        let size = left_layout.size;\n-\n         let (val, ty) = match bin_op {\n             Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n             Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n@@ -247,6 +235,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     _ => bug!(),\n                 };\n                 let (result, oflo) = op(l, r);\n+                // Truncate to target type.\n+                // If that truncation loses any information, we have an overflow.\n                 let truncated = self.truncate(result, left_layout);\n                 return Ok((\n                     Scalar::from_uint(truncated, size),"}]}