{"sha": "84dd17b56a931a631a23dfd5ef2018fd3ef49108", "node_id": "C_kwDOAAsO6NoAKDg0ZGQxN2I1NmE5MzFhNjMxYTIzZGZkNWVmMjAxOGZkM2VmNDkxMDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T19:38:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T19:38:08Z"}, "message": "Auto merge of #110331 - matthiaskrgr:rollup-9vldvow, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108687 (Reformulate `point_at_expr_source_of_inferred_type` to be more accurate)\n - #109272 (Add Command environment variable inheritance docs)\n - #109947 (Add links from `core::cmp` derives to their traits)\n - #110110 (Use `Display` in top-level example for `PanicInfo`)\n - #110154 (Fix typos in library)\n - #110244 (Remove some unneeded imports / qualified paths)\n - #110328 ([rustdoc] Add explanations for auto-disambiguation when an intra doc link is resolved to a proc-macro and a trait at the same time)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "54bf25e0b3e1f48be94752b14fadd46ed7dbed25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bf25e0b3e1f48be94752b14fadd46ed7dbed25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84dd17b56a931a631a23dfd5ef2018fd3ef49108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84dd17b56a931a631a23dfd5ef2018fd3ef49108", "html_url": "https://github.com/rust-lang/rust/commit/84dd17b56a931a631a23dfd5ef2018fd3ef49108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84dd17b56a931a631a23dfd5ef2018fd3ef49108/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "276fa294809e914b1d04192392d256814aa5ce1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/276fa294809e914b1d04192392d256814aa5ce1a", "html_url": "https://github.com/rust-lang/rust/commit/276fa294809e914b1d04192392d256814aa5ce1a"}, {"sha": "0d97522ee751cf485f3daf621bcc0ff1e6771f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d97522ee751cf485f3daf621bcc0ff1e6771f0f", "html_url": "https://github.com/rust-lang/rust/commit/0d97522ee751cf485f3daf621bcc0ff1e6771f0f"}], "stats": {"total": 801, "additions": 409, "deletions": 392}, "files": [{"sha": "13442c3164928305d4c9fc4a51fbc6858a9de8f2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 220, "deletions": 186, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,6 +1,5 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -13,15 +12,13 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n-use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n-use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -62,9 +59,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.suggest_null_ptr_for_literal_zero_given_to_ptr_arg(err, expr, expected)\n-            || self.note_result_coercion(err, expr, expected, expr_ty);\n+            || self.suggest_coercing_result_via_try_operator(err, expr, expected, expr_ty);\n+\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n+            self.note_source_of_type_mismatch_constraint(\n+                err,\n+                expr,\n+                TypeMismatchSource::Ty(expected),\n+            );\n         }\n     }\n \n@@ -218,37 +220,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    pub fn point_at_expr_source_of_inferred_type(\n+    /// Notes the point at which a variable is constrained to some type incompatible\n+    /// with some expectation given by `source`.\n+    pub fn note_source_of_type_mismatch_constraint(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        found: Ty<'tcx>,\n-        expected: Ty<'tcx>,\n-        mismatch_span: Span,\n+        source: TypeMismatchSource<'tcx>,\n     ) -> bool {\n-        let map = self.tcx.hir();\n+        let hir = self.tcx.hir();\n \n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n         let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n-        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n-        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n-        let Some(hir::Node::Local(hir::Local {\n-            ty: None,\n-            init: Some(init),\n-            ..\n-        })) = map.find_parent(pat.hir_id) else { return false; };\n-        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n-        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n-            return false;\n-        }\n+        let hir::def::Res::Local(local_hir_id) = p.res else { return false; };\n+        let hir::Node::Pat(pat) = hir.get(local_hir_id) else { return false; };\n+        let (init_ty_hir_id, init) = match hir.get_parent(pat.hir_id) {\n+            hir::Node::Local(hir::Local { ty: Some(ty), init, .. }) => (ty.hir_id, *init),\n+            hir::Node::Local(hir::Local { init: Some(init), .. }) => (init.hir_id, Some(*init)),\n+            _ => return false,\n+        };\n+        let Some(init_ty) = self.node_ty_opt(init_ty_hir_id) else { return false; };\n \n         // Locate all the usages of the relevant binding.\n-        struct FindExprs<'hir> {\n+        struct FindExprs<'tcx> {\n             hir_id: hir::HirId,\n-            uses: Vec<&'hir hir::Expr<'hir>>,\n+            uses: Vec<&'tcx hir::Expr<'tcx>>,\n         }\n-        impl<'v> Visitor<'v> for FindExprs<'v> {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        impl<'tcx> Visitor<'tcx> for FindExprs<'tcx> {\n+            fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n                     && let hir::def::Res::Local(hir_id) = path.res\n                     && hir_id == self.hir_id\n@@ -259,180 +258,205 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n-        let id = map.get_parent_item(hir_id);\n-        let hir_id: hir::HirId = id.into();\n-\n-        let Some(node) = map.find(hir_id) else { return false; };\n-        let Some(body_id) = node.body_id() else { return false; };\n-        let body = map.body(body_id);\n+        let mut expr_finder = FindExprs { hir_id: local_hir_id, uses: init.into_iter().collect() };\n+        let body =\n+            hir.body(hir.maybe_body_owned_by(self.body_id).expect(\"expected item to have body\"));\n         expr_finder.visit_expr(body.value);\n-        // Hack to make equality checks on types with inference variables and regions useful.\n-        let mut eraser = BottomUpFolder {\n+\n+        use rustc_infer::infer::type_variable::*;\n+        use rustc_middle::infer::unify_key::*;\n+        // Replaces all of the variables in the given type with a fresh inference variable.\n+        let mut fudger = BottomUpFolder {\n             tcx: self.tcx,\n+            ty_op: |ty| {\n+                if let ty::Infer(infer) = ty.kind() {\n+                    match infer {\n+                        ty::InferTy::TyVar(_) => self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        }),\n+                        ty::InferTy::IntVar(_) => self.next_int_var(),\n+                        ty::InferTy::FloatVar(_) => self.next_float_var(),\n+                        _ => bug!(),\n+                    }\n+                } else {\n+                    ty\n+                }\n+            },\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n-            ct_op: |c| c,\n-            ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n-                ty::Infer(ty::IntVar(_)) => self.tcx.mk_int_var(ty::IntVid { index: 0 }),\n-                ty::Infer(ty::FloatVar(_)) => self.tcx.mk_float_var(ty::FloatVid { index: 0 }),\n-                _ => t,\n+            ct_op: |ct| {\n+                if let ty::ConstKind::Infer(_) = ct.kind() {\n+                    self.next_const_var(\n+                        ct.ty(),\n+                        ConstVariableOrigin {\n+                            kind: ConstVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        },\n+                    )\n+                } else {\n+                    ct\n+                }\n             },\n         };\n-        let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span: Option<Span> = None;\n-\n-        for binding in expr_finder.uses {\n-            // In every expression where the binding is referenced, we will look at that\n-            // expression's type and see if it is where the incorrect found type was fully\n-            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n-            if let Some(hir::Node::Expr(expr)\n-            | hir::Node::Stmt(hir::Stmt {\n-                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n-                ..\n-            })) = &map.find_parent(binding.hir_id)\n-                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n-                && rcvr.hir_id == binding.hir_id\n-                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n-            {\n-                // We special case methods, because they can influence inference through the\n-                // call's arguments and we can provide a more explicit span.\n-                let sig = self.tcx.fn_sig(def_id).subst_identity();\n-                let def_self_ty = sig.input(0).skip_binder();\n-                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n-                // If there's an arity mismatch, pointing out the call as the source of an inference\n-                // can be misleading, so we skip it.\n-                if param_tys.len() != args.len() {\n-                    continue;\n-                }\n-                let rcvr_ty = self.node_ty(rcvr.hir_id);\n-                // Get the evaluated type *after* calling the method call, so that the influence\n-                // of the arguments can be reflected in the receiver type. The receiver\n-                // expression has the type *before* this analysis is done.\n-                let ty = match self.lookup_probe_for_diagnostic(\n-                    segment.ident,\n-                    rcvr_ty,\n-                    expr,\n-                    probe::ProbeScope::TraitsInScope,\n-                    None,\n-                ) {\n-                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n-                    Err(_) => rcvr_ty,\n+\n+        let expected_ty = match source {\n+            TypeMismatchSource::Ty(expected_ty) => expected_ty,\n+            // Try to deduce what the possible value of `expr` would be if the\n+            // incompatible arg were compatible. For example, given `Vec<i32>`\n+            // and `vec.push(1u32)`, we ideally want to deduce that the type of\n+            // `vec` *should* have been `Vec<u32>`. This will allow us to then\n+            // run the subsequent code with this expectation, finding out exactly\n+            // when this type diverged from our expectation.\n+            TypeMismatchSource::Arg { call_expr, incompatible_arg: idx } => {\n+                let hir::ExprKind::MethodCall(segment, _, args, _) = call_expr.kind else {\n+                    return false;\n                 };\n-                // Remove one layer of references to account for `&mut self` and\n-                // `&self`, so that we can compare it against the binding.\n-                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n-                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n-                    _ => (ty, def_self_ty),\n+                let Some(arg_ty) = self.node_ty_opt(args[idx].hir_id) else {\n+                    return false;\n                 };\n-                let mut param_args = FxHashMap::default();\n-                let mut param_expected = FxHashMap::default();\n-                let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found) {\n-                    // We only point at the first place where the found type was inferred.\n-                    for (param_ty, arg) in param_tys.zip(args) {\n-                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n-                            // We found an argument that references a type parameter in `Self`,\n-                            // so we assume that this is the argument that caused the found\n-                            // type, which we know already because of `can_eq` above was first\n-                            // inferred in this method call.\n-                            let arg_ty = self.node_ty(arg.hir_id);\n-                            if !arg.span.overlaps(mismatch_span) {\n-                                err.span_label(\n-                                    arg.span,\n-                                    &format!(\n-                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                        inferred as `{ty}`\",\n-                                    ),\n-                                );\n-                            }\n-                            param_args.insert(param_ty, (arg, arg_ty));\n-                        }\n-                    }\n+                let possible_rcvr_ty = expr_finder.uses.iter().find_map(|binding| {\n+                    let possible_rcvr_ty = self.node_ty_opt(binding.hir_id)?;\n+                    // Fudge the receiver, so we can do new inference on it.\n+                    let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n+                    let method = self\n+                        .lookup_method(\n+                            possible_rcvr_ty,\n+                            segment,\n+                            DUMMY_SP,\n+                            call_expr,\n+                            binding,\n+                            args,\n+                        )\n+                        .ok()?;\n+                    // Unify the method signature with our incompatible arg, to\n+                    // do inference in the *opposite* direction and to find out\n+                    // what our ideal rcvr ty would look like.\n+                    let _ = self\n+                        .at(&ObligationCause::dummy(), self.param_env)\n+                        .eq(DefineOpaqueTypes::No, method.sig.inputs()[idx + 1], arg_ty)\n+                        .ok()?;\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    Some(self.resolve_vars_if_possible(possible_rcvr_ty))\n+                });\n+                if let Some(rcvr_ty) = possible_rcvr_ty {\n+                    rcvr_ty\n+                } else {\n+                    return false;\n                 }\n+            }\n+        };\n \n-                // Here we find, for a type param `T`, the type that `T` is in the current\n-                // method call *and* in the original expected type. That way, we can see if we\n-                // can give any structured suggestion for the function argument.\n-                let mut c = CollectAllMismatches {\n-                    infcx: &self.infcx,\n-                    param_env: self.param_env,\n-                    errors: vec![],\n+        // If our expected_ty does not equal init_ty, then it *began* as incompatible.\n+        // No need to note in this case...\n+        if !self.can_eq(self.param_env, expected_ty, init_ty.fold_with(&mut fudger)) {\n+            return false;\n+        }\n+\n+        for window in expr_finder.uses.windows(2) {\n+            // Bindings always update their recorded type after the fact, so we\n+            // need to look at the *following* usage's type to see when the\n+            // binding became incompatible.\n+            let [binding, next_usage] = *window else { continue; };\n+\n+            // Don't go past the binding (always gonna be a nonsense label if so)\n+            if binding.hir_id == expr.hir_id {\n+                break;\n+            }\n+\n+            let Some(next_use_ty) = self.node_ty_opt(next_usage.hir_id) else { continue; };\n+\n+            // If the type is not constrained in a way making it not possible to\n+            // equate with `expected_ty` by this point, skip.\n+            if self.can_eq(self.param_env, expected_ty, next_use_ty.fold_with(&mut fudger)) {\n+                continue;\n+            }\n+\n+            if let hir::Node::Expr(parent_expr) = hir.get_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _) = parent_expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+            {\n+                // If our binding became incompatible while it was a receiver\n+                // to a method call, we may be able to make a better guess to\n+                // the source of a type mismatch.\n+                let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n+                let rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let Ok(method) =\n+                    self.lookup_method(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                else {\n+                    continue;\n                 };\n-                let _ = c.relate(def_self_ty, ty);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_found.insert(error.expected, error.found);\n-                    }\n-                }\n-                c.errors = vec![];\n-                let _ = c.relate(def_self_ty, expected);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_expected.insert(error.expected, error.found);\n-                    }\n-                }\n-                for (param, (arg, arg_ty)) in param_args.iter() {\n-                    let Some(expected) = param_expected.get(param) else { continue; };\n-                    let Some(found) = param_found.get(param) else { continue; };\n-                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n-                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n-                }\n \n-                let ty = eraser.fold_ty(ty);\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found)\n+                let ideal_rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let ideal_method = self\n+                    .lookup_method(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    .ok()\n+                    .and_then(|method| {\n+                        let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .eq(DefineOpaqueTypes::No, ideal_rcvr_ty, expected_ty)\n+                            .ok()?;\n+                        Some(method)\n+                    });\n+\n+                // Find what argument caused our rcvr to become incompatible\n+                // with the expected ty.\n+                for (idx, (expected_arg_ty, arg_expr)) in\n+                    std::iter::zip(&method.sig.inputs()[1..], args).enumerate()\n                 {\n-                    // We only point at the first place where the found type was inferred.\n-                    if !segment.ident.span.overlaps(mismatch_span) {\n+                    let Some(arg_ty) = self.node_ty_opt(arg_expr.hir_id) else { continue; };\n+                    let arg_ty = arg_ty.fold_with(&mut fudger);\n+                    let _ = self.try_coerce(\n+                        arg_expr,\n+                        arg_ty,\n+                        *expected_arg_ty,\n+                        AllowTwoPhase::No,\n+                        None,\n+                    );\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    // If our rcvr, after inference due to unifying the signature\n+                    // with the expected argument type, is still compatible with\n+                    // the rcvr, then it must've not been the source of blame.\n+                    if self.can_eq(self.param_env, rcvr_ty, expected_ty) {\n+                        continue;\n+                    }\n+                    err.span_label(arg_expr.span, format!(\"this argument has type `{arg_ty}`...\"));\n                     err.span_label(\n-                        segment.ident.span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );}\n-                    break;\n-                } else if !param_args.is_empty() {\n-                    break;\n-                }\n-                prev = ty;\n-            } else {\n-                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found)\n-                {\n-                    // We only point at the first place where the found type was inferred.\n-                    // We use the *previous* span because if the type is known *here* it means\n-                    // it was *evaluated earlier*. We don't do this for method calls because we\n-                    // evaluate the method's self type eagerly, but not in any other case.\n-                    if !span.overlaps(mismatch_span) {\n-                        err.span_label(\n-                            span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n+                        binding.span,\n+                        format!(\"... which causes `{ident}` to have type `{next_use_ty}`\"),\n+                    );\n+                    // Using our \"ideal\" method signature, suggest a fix to this\n+                    // blame arg, if possible. Don't do this if we're coming from\n+                    // arg mismatch code, because we'll possibly suggest a mutually\n+                    // incompatible fix at the original mismatch site.\n+                    if matches!(source, TypeMismatchSource::Ty(_))\n+                        && let Some(ideal_method) = ideal_method\n+                    {\n+                        self.emit_type_mismatch_suggestions(\n+                            err,\n+                            arg_expr,\n+                            arg_ty,\n+                            self.resolve_vars_if_possible(ideal_method.sig.inputs()[idx + 1]),\n+                            None,\n+                            None,\n                         );\n                     }\n-                    break;\n+                    return true;\n                 }\n-                prev = ty;\n-            }\n-            if binding.hir_id == expr.hir_id {\n-                // Do not look at expressions that come after the expression we were originally\n-                // evaluating and had a type error.\n-                break;\n             }\n-            prev_span = Some(binding.span);\n+            err.span_label(\n+                binding.span,\n+                format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n+            );\n+            return true;\n         }\n-        true\n+\n+        // We must've not found something that constrained the expr.\n+        false\n     }\n \n     fn annotate_expected_due_to_let_ty(\n@@ -708,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub(crate) fn note_result_coercion(\n+    pub(crate) fn suggest_coercing_result_via_try_operator(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n@@ -2094,3 +2118,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+pub enum TypeMismatchSource<'tcx> {\n+    /// Expected the binding to have the given type, but it was found to have\n+    /// a different type. Find out when that type first became incompatible.\n+    Ty(Ty<'tcx>),\n+    /// When we fail during method argument checking, try to find out if a previous\n+    /// expression has constrained the method's receiver in a way that makes the\n+    /// argument's type incompatible.\n+    Arg { call_expr: &'tcx hir::Expr<'tcx>, incompatible_arg: usize },\n+}"}, {"sha": "ea1b52daaa5e59b368422b93678b1bd40a7079d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n         call_span: Span,\n-        call_expr: &hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         // Next, let's construct the error\n         let (error_span, full_call_span, call_name, is_method) = match &call_expr.kind {\n@@ -807,24 +807,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n-            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n-                (callee_ty, &call_expr.kind)\n+\n+            if let hir::ExprKind::MethodCall(_, rcvr, _, _) = call_expr.kind\n+                && provided_idx.as_usize() == expected_idx.as_usize()\n             {\n-                // Type that would have accepted this argument if it hadn't been inferred earlier.\n-                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n-                // specific type to increase the accuracy of the diagnostic.\n-                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                    span: full_call_span,\n-                });\n-                self.point_at_expr_source_of_inferred_type(\n+                self.note_source_of_type_mismatch_constraint(\n                     &mut err,\n                     rcvr,\n-                    expected,\n-                    callee_ty,\n-                    provided_arg_span,\n+                    crate::demand::TypeMismatchSource::Arg {\n+                        call_expr,\n+                        incompatible_arg: provided_idx.as_usize(),\n+                    },\n                 );\n             }\n+\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "ec1b0a8eba039c32b9cb01ca664707caa072389b", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::iter::Iterator;\n use std::ops::RangeBounds;\n use std::vec::Vec;\n "}, {"sha": "c1d3e1bdfe79d60d7b8c52426d35b22b0176c9d1", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,5 +1,5 @@\n use rand::RngCore;\n-use std::iter::{repeat, FromIterator};\n+use std::iter::repeat;\n use test::{black_box, Bencher};\n \n #[bench]"}, {"sha": "7f88327bf190a150166ab03756c681a02400559f", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -150,16 +150,13 @@ use core::any::Any;\n use core::async_iter::AsyncIterator;\n use core::borrow;\n use core::cmp::Ordering;\n-use core::convert::{From, TryFrom};\n use core::error::Error;\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n-#[cfg(not(no_global_oom_handling))]\n-use core::iter::FromIterator;\n-use core::iter::{FusedIterator, Iterator};\n+use core::iter::FusedIterator;\n use core::marker::Tuple;\n-use core::marker::{Unpin, Unsize};\n+use core::marker::Unsize;\n use core::mem;\n use core::ops::{\n     CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,"}, {"sha": "8aa4d342e6e37656e117f1082f09dcebda158bfa", "filename": "library/alloc/src/collections/binary_heap/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -144,7 +144,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::fmt;\n-use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n+use core::iter::{FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n use core::mem::{self, swap, ManuallyDrop};\n use core::num::NonZeroUsize;\n use core::ops::{Deref, DerefMut};\n@@ -263,7 +263,6 @@ mod tests;\n /// more detailed analysis.\n ///\n /// [`core::cmp::Reverse`]: core::cmp::Reverse\n-/// [`Ord`]: core::cmp::Ord\n /// [`Cell`]: core::cell::Cell\n /// [`RefCell`]: core::cell::RefCell\n /// [push]: BinaryHeap::push\n@@ -1418,7 +1417,6 @@ impl<T> FusedIterator for Iter<'_, T> {}\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: BinaryHeap::into_iter\n-/// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct IntoIter<T> {"}, {"sha": "abd5f17137ec29acd59ef228f642e647b2ec1ea7", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -3,7 +3,7 @@ use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::{self, Debug};\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::FusedIterator;\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n use core::ops::{Bound, Index, RangeBounds};\n@@ -420,7 +420,6 @@ impl<'a, K: 'a, V: 'a> Default for IterMut<'a, K, V> {\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: IntoIterator::into_iter\n-/// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_insignificant_dtor]\n pub struct IntoIter<\n@@ -650,7 +649,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         // avoid moving the allocator\n-        mem::drop(BTreeMap {\n+        drop(BTreeMap {\n             root: mem::replace(&mut self.root, None),\n             length: mem::replace(&mut self.length, 0),\n             alloc: self.alloc.clone(),"}, {"sha": "da00d83bdbb576718280037b68648c0058b79496", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -9,8 +9,7 @@ use crate::testing::ord_chaos::{Cyclic3, Governed, Governor};\n use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n-use std::convert::TryFrom;\n-use std::iter::{self, FromIterator};\n+use std::iter;\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;"}, {"sha": "232a017314e5e601973fdae201eab07ba6eea8ff", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -4,7 +4,7 @@ use core::cmp::Ordering::{self, Equal, Greater, Less};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, FusedIterator, Peekable};\n+use core::iter::{FusedIterator, Peekable};\n use core::mem::ManuallyDrop;\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n@@ -30,7 +30,6 @@ use crate::alloc::{Allocator, Global};\n /// Iterators returned by [`BTreeSet::iter`] produce their items in order, and take worst-case\n /// logarithmic and amortized constant time per item returned.\n ///\n-/// [`Ord`]: core::cmp::Ord\n /// [`Cell`]: core::cell::Cell\n /// [`RefCell`]: core::cell::RefCell\n ///\n@@ -147,7 +146,6 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: BTreeSet#method.into_iter\n-/// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<"}, {"sha": "a7c839d77ed4c56d840dd9dd4e77e19c355fb3a3", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -4,7 +4,6 @@ use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n-use std::iter::FromIterator;\n use std::ops::Bound::{Excluded, Included};\n use std::panic::{catch_unwind, AssertUnwindSafe};\n "}, {"sha": "1743a155c5abf0ef5862b4bd8d7789e5b7df9501", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -15,7 +15,7 @@\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::FusedIterator;\n use core::marker::PhantomData;\n use core::mem;\n use core::ptr::NonNull;\n@@ -130,7 +130,6 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: LinkedList::into_iter\n-/// [`IntoIterator`]: core::iter::IntoIterator\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {"}, {"sha": "d9e274df0f5f24769ceb85c3d9e8a7593e93fae8", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -12,7 +12,6 @@ use super::VecDeque;\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: VecDeque::into_iter\n-/// [`IntoIterator`]: core::iter::IntoIterator\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<"}, {"sha": "8916b42eda05ef424628cc081923b32ceb434d58", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -10,7 +10,7 @@\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_n, repeat_with, ByRefSized, FromIterator};\n+use core::iter::{repeat_n, repeat_with, ByRefSized};\n use core::mem::{ManuallyDrop, SizedTypeProperties};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr;"}, {"sha": "dfd30d99cf041e385eaee50a48a4e4340ab06f16", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -4,7 +4,6 @@ use core::alloc::LayoutError;\n use core::cmp;\n use core::intrinsics;\n use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n-use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n "}, {"sha": "cf93a40496fdf209012938d7ef484042962517c0", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -15,7 +15,7 @@\n //!\n //! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n //! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n-//! does not implement [`Send`][send]. As a result, the Rust compiler\n+//! does not implement [`Send`]. As a result, the Rust compiler\n //! will check *at compile time* that you are not sending [`Rc`]s between\n //! threads. If you need multi-threaded, atomic reference counting, use\n //! [`sync::Arc`][arc].\n@@ -232,7 +232,6 @@\n //! [clone]: Clone::clone\n //! [`Cell`]: core::cell::Cell\n //! [`RefCell`]: core::cell::RefCell\n-//! [send]: core::marker::Send\n //! [arc]: crate::sync::Arc\n //! [`Deref`]: core::ops::Deref\n //! [downgrade]: Rc::downgrade\n@@ -251,13 +250,12 @@ use core::any::Any;\n use core::borrow;\n use core::cell::Cell;\n use core::cmp::Ordering;\n-use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n #[cfg(not(no_global_oom_handling))]\n use core::iter;\n-use core::marker::{self, PhantomData, Unpin, Unsize};\n+use core::marker::{PhantomData, Unsize};\n #[cfg(not(no_global_oom_handling))]\n use core::mem::size_of_val;\n use core::mem::{self, align_of_val_raw, forget};\n@@ -321,15 +319,15 @@ pub struct Rc<T: ?Sized> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !marker::Send for Rc<T> {}\n+impl<T: ?Sized> !Send for Rc<T> {}\n \n // Note that this negative impl isn't strictly necessary for correctness,\n // as `Rc` transitively contains a `Cell`, which is itself `!Sync`.\n // However, given how important `Rc`'s `!Sync`-ness is,\n // having an explicit negative impl is nice for documentation purposes\n // and results in nicer error messages.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> !marker::Sync for Rc<T> {}\n+impl<T: ?Sized> !Sync for Rc<T> {}\n \n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n@@ -1060,7 +1058,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[stable(feature = \"rc_mutate_strong_count\", since = \"1.53.0\")]\n     pub unsafe fn decrement_strong_count(ptr: *const T) {\n-        unsafe { mem::drop(Rc::from_raw(ptr)) };\n+        unsafe { drop(Rc::from_raw(ptr)) };\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`] pointers to\n@@ -1496,7 +1494,7 @@ impl<T> Rc<[T]> {\n     ///\n     /// Behavior is undefined should the size be wrong.\n     #[cfg(not(no_global_oom_handling))]\n-    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Rc<[T]> {\n+    unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Rc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n@@ -2088,7 +2086,7 @@ impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n-impl<T> iter::FromIterator<T> for Rc<[T]> {\n+impl<T> FromIterator<T> for Rc<[T]> {\n     /// Takes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n     ///\n     /// # Performance characteristics\n@@ -2127,7 +2125,7 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// let evens: Rc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n-    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n         ToRcSlice::to_rc_slice(iter.into_iter())\n     }\n }\n@@ -2204,9 +2202,9 @@ pub struct Weak<T: ?Sized> {\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized> !marker::Send for Weak<T> {}\n+impl<T: ?Sized> !Send for Weak<T> {}\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized> !marker::Sync for Weak<T> {}\n+impl<T: ?Sized> !Sync for Weak<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"18598\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}"}, {"sha": "be41919b9dc23b351b6b400c106d0755ad56f5e7", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -45,9 +45,9 @@\n use core::error::Error;\n use core::fmt;\n use core::hash;\n-use core::iter::FusedIterator;\n #[cfg(not(no_global_oom_handling))]\n-use core::iter::{from_fn, FromIterator};\n+use core::iter::from_fn;\n+use core::iter::FusedIterator;\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Add;\n #[cfg(not(no_global_oom_handling))]"}, {"sha": "5bfe537bc830fe9eb5028763a7ce63691f5be51e", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -11,14 +11,13 @@\n use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n-use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::hint;\n use core::intrinsics::abort;\n #[cfg(not(no_global_oom_handling))]\n use core::iter;\n-use core::marker::{PhantomData, Unpin, Unsize};\n+use core::marker::{PhantomData, Unsize};\n #[cfg(not(no_global_oom_handling))]\n use core::mem::size_of_val;\n use core::mem::{self, align_of_val_raw};\n@@ -188,8 +187,6 @@ macro_rules! acquire {\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n /// [atomic]: core::sync::atomic\n-/// [`Send`]: core::marker::Send\n-/// [`Sync`]: core::marker::Sync\n /// [deref]: core::ops::Deref\n /// [downgrade]: Arc::downgrade\n /// [upgrade]: Weak::upgrade\n@@ -1241,7 +1238,7 @@ impl<T: ?Sized> Arc<T> {\n     #[inline]\n     #[stable(feature = \"arc_mutate_strong_count\", since = \"1.51.0\")]\n     pub unsafe fn decrement_strong_count(ptr: *const T) {\n-        unsafe { mem::drop(Arc::from_raw(ptr)) };\n+        unsafe { drop(Arc::from_raw(ptr)) };\n     }\n \n     #[inline]\n@@ -1404,7 +1401,7 @@ impl<T> Arc<[T]> {\n     ///\n     /// Behavior is undefined should the size be wrong.\n     #[cfg(not(no_global_oom_handling))]\n-    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Arc<[T]> {\n+    unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Arc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new ArcInner will be dropped, then the memory freed.\n@@ -2818,7 +2815,7 @@ impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n-impl<T> iter::FromIterator<T> for Arc<[T]> {\n+impl<T> FromIterator<T> for Arc<[T]> {\n     /// Takes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n     ///\n     /// # Performance characteristics\n@@ -2857,7 +2854,7 @@ impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// let evens: Arc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n-    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n         ToArcSlice::to_arc_slice(iter.into_iter())\n     }\n }"}, {"sha": "2c799605b7b672a9f48be7e2d51d817ec2c488af", "filename": "library/alloc/src/vec/cow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,5 +1,4 @@\n use crate::borrow::Cow;\n-use core::iter::FromIterator;\n \n use super::Vec;\n "}, {"sha": "02faf8e638948156fe10f4c5079b0caa6e5b9765", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -108,7 +108,7 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     /// ```\n     /// # let mut into_iter = Vec::<u8>::with_capacity(10).into_iter();\n     /// let mut into_iter = std::mem::replace(&mut into_iter, Vec::new().into_iter());\n-    /// (&mut into_iter).for_each(core::mem::drop);\n+    /// (&mut into_iter).for_each(drop);\n     /// std::mem::forget(into_iter);\n     /// ```\n     ///"}, {"sha": "3736a6e0b0ecbf8fc80921e7a23647b336968ad4", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -56,12 +56,9 @@\n #[cfg(not(no_global_oom_handling))]\n use core::cmp;\n use core::cmp::Ordering;\n-use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter;\n-#[cfg(not(no_global_oom_handling))]\n-use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -2990,7 +2987,7 @@ impl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n     }\n }\n \n-/// Implements comparison of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n+/// Implements comparison of vectors, [lexicographically](Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n     #[inline]\n@@ -3002,7 +2999,7 @@ impl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq, A: Allocator> Eq for Vec<T, A> {}\n \n-/// Implements ordering of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n+/// Implements ordering of vectors, [lexicographically](Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord, A: Allocator> Ord for Vec<T, A> {\n     #[inline]"}, {"sha": "55331475aff2a2b0e92e3e5d011b2c5e2eb7d49a", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -231,7 +231,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n     }\n }\n \n-/// Derive macro generating an impl of the trait `PartialEq`.\n+/// Derive macro generating an impl of the trait [`PartialEq`].\n+/// The behavior of this macro is described in detail [here](PartialEq#derivable).\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, structural_match)]\n@@ -297,7 +298,7 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-/// Derive macro generating an impl of the trait `Eq`.\n+/// Derive macro generating an impl of the trait [`Eq`].\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_eq, structural_match, no_coverage)]\n@@ -859,7 +860,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     }\n }\n \n-/// Derive macro generating an impl of the trait `Ord`.\n+/// Derive macro generating an impl of the trait [`Ord`].\n+/// The behavior of this macro is described in detail [here](Ord#derivable).\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n@@ -1138,7 +1140,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     }\n }\n \n-/// Derive macro generating an impl of the trait `PartialOrd`.\n+/// Derive macro generating an impl of the trait [`PartialOrd`].\n+/// The behavior of this macro is described in detail [here](PartialOrd#derivable).\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]"}, {"sha": "45498a54b25dccb903aa7726f49b72d8a0af55b2", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -247,7 +247,7 @@\n //!     - The exception is the last arm, which must be `_ => basic_block` and corresponds to the\n //!       otherwise branch.\n //!  - [`Call`] has an associated function as well. The third argument of this function is a normal\n-//!    function call expresion, for example `my_other_function(a, 5)`.\n+//!    function call expression, for example `my_other_function(a, 5)`.\n //!\n \n #![unstable("}, {"sha": "d3cd74a4483755430aeb05fda23ee95d9742060e", "filename": "library/core/src/iter/sources/repeat_with.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -19,7 +19,6 @@ use crate::ops::Try;\n /// please open a GitHub issue explaining your use case.\n ///\n /// [`repeat()`]: crate::iter::repeat\n-/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n ///\n /// # Examples\n ///"}, {"sha": "02877604248df85c665d828fd16305fce66aa9b4", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -764,7 +764,6 @@ pub trait Iterator {\n     /// more idiomatic to use [`for`] than `map()`.\n     ///\n     /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n-    /// [`FnMut`]: crate::ops::FnMut\n     ///\n     /// # Examples\n     ///"}, {"sha": "b9a1924d668980a0bf709b94f8c795691c0402fb", "filename": "library/core/src/net/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -9,7 +9,7 @@ use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n use crate::str::FromStr;\n \n-trait ReadNumberHelper: crate::marker::Sized {\n+trait ReadNumberHelper: Sized {\n     const ZERO: Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_add(&self, other: u32) -> Option<Self>;"}, {"sha": "06fbe083ca13df324873786704048b7a8e0baf9a", "filename": "library/core/src/panic/panic_info.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -15,14 +15,10 @@ use crate::panic::Location;\n /// use std::panic;\n ///\n /// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n-///         println!(\"panic occurred: {s:?}\");\n-///     } else {\n-///         println!(\"panic occurred\");\n-///     }\n+///     println!(\"panic occurred: {panic_info}\");\n /// }));\n ///\n-/// panic!(\"Normal panic\");\n+/// panic!(\"critical system failure\");\n /// ```\n #[lang = \"panic_info\"]\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]"}, {"sha": "3df990e5dd9fee4bf5d29baa6b0cd9713ba42973", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -577,7 +577,6 @@ impl Copy for () {\n /// [`is_null`]: pointer::is_null\n /// [`offset`]: pointer::offset\n #[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n-/// [`drop`]: mem::drop\n /// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer {}\n@@ -1026,7 +1025,6 @@ mod prim_str {}\n /// * [`UnwindSafe`]\n /// * [`RefUnwindSafe`]\n ///\n-/// [`Unpin`]: marker::Unpin\n /// [`UnwindSafe`]: panic::UnwindSafe\n /// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n@@ -1405,10 +1403,6 @@ mod prim_ref {}\n ///\n /// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n ///\n-/// [`Fn`]: ops::Fn\n-/// [`FnMut`]: ops::FnMut\n-/// [`FnOnce`]: ops::FnOnce\n-///\n /// Function pointers are pointers that point to *code*, not data. They can be called\n /// just like functions. Like references, function pointers are, among other things, assumed to\n /// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null"}, {"sha": "07fd96f929586e65c53cbfd4d33c92c18332e1e2", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1486,7 +1486,7 @@ where\n }\n \n /// Finds a streak of presorted elements starting at the beginning of the slice. Returns the first\n-/// value that is not part of said streak, and a bool denoting wether the streak was reversed.\n+/// value that is not part of said streak, and a bool denoting whether the streak was reversed.\n /// Streaks can be increasing or decreasing.\n fn find_streak<T, F>(v: &[T], is_less: &mut F) -> (usize, bool)\n where"}, {"sha": "e3a464a1c51a97223dc5f8e641e0dc465248e48e", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1891,7 +1891,7 @@ unsafe fn small_slice_eq(x: &[u8], y: &[u8]) -> bool {\n \n     // SAFETY: Via the conditional above, we know that both `px` and `py`\n     // have the same length, so `px < pxend` implies that `py < pyend`.\n-    // Thus, derefencing both `px` and `py` in the loop below is safe.\n+    // Thus, dereferencing both `px` and `py` in the loop below is safe.\n     //\n     // Moreover, we set `pxend` and `pyend` to be 4 bytes before the actual\n     // end of `px` and `py`. Thus, the final dereference outside of the"}, {"sha": "3f3e19c55d4ba76faee9e6ba215cb33a60a8e30a", "filename": "library/core/src/sync/exclusive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fsync%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fcore%2Fsrc%2Fsync%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fexclusive.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -69,9 +69,6 @@ use core::task::{Context, Poll};\n /// for any value. This is a parallel with the fact that\n /// `&` and `&mut` references together can be thought of as a _compile-time_\n /// version of a read-write lock.\n-///\n-///\n-/// [`Sync`]: core::marker::Sync\n #[unstable(feature = \"exclusive_wrapper\", issue = \"98407\")]\n #[doc(alias = \"SyncWrapper\")]\n #[doc(alias = \"SyncCell\")]"}, {"sha": "b5ba198e5041b82e76e03c31143d70cbd2bd9f02", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -257,7 +257,7 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> core::convert::From<Mask<T, LANES>> for Simd<T, LANES>\n+impl<T, const LANES: usize> From<Mask<T, LANES>> for Simd<T, LANES>\n where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "f4e90544197217b3c37941eda824b5f9c2b81851", "filename": "library/proc_macro/src/bridge/fxhash.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -5,8 +5,6 @@\n //! on the `rustc_hash` crate.\n \n use std::collections::HashMap;\n-use std::convert::TryInto;\n-use std::default::Default;\n use std::hash::BuildHasherDefault;\n use std::hash::Hasher;\n use std::mem::size_of;"}, {"sha": "9d081c8b842d5b767a5b6ed57cdd8f80a9f16c5c", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -47,7 +47,7 @@ use std::cmp::Ordering;\n use std::ops::RangeBounds;\n use std::path::PathBuf;\n use std::str::FromStr;\n-use std::{error, fmt, iter};\n+use std::{error, fmt};\n \n /// Determines whether proc_macro has been made accessible to the currently\n /// running program.\n@@ -310,7 +310,7 @@ impl ConcatStreamsHelper {\n \n /// Collects a number of token trees into a single stream.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-impl iter::FromIterator<TokenTree> for TokenStream {\n+impl FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         let iter = trees.into_iter();\n         let mut builder = ConcatTreesHelper::new(iter.size_hint().0);\n@@ -322,7 +322,7 @@ impl iter::FromIterator<TokenTree> for TokenStream {\n /// A \"flattening\" operation on token streams, collects token trees\n /// from multiple token streams into a single stream.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n-impl iter::FromIterator<TokenStream> for TokenStream {\n+impl FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n         let iter = streams.into_iter();\n         let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);"}, {"sha": "3afc8287ecc0098363934619e33d32300e47347a", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1446,7 +1446,6 @@ impl<'a, K, V> IterMut<'a, K, V> {\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: IntoIterator::into_iter\n-/// [`IntoIterator`]: crate::iter::IntoIterator\n ///\n /// # Example\n ///"}, {"sha": "ac906e682d5f04c20b55a345b8435f5dc273c72a", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1272,7 +1272,6 @@ pub struct Iter<'a, K: 'a> {\n /// (provided by the [`IntoIterator`] trait). See its documentation for more.\n ///\n /// [`into_iter`]: IntoIterator::into_iter\n-/// [`IntoIterator`]: crate::iter::IntoIterator\n ///\n /// # Examples\n ///"}, {"sha": "42f738acb9f7bca7f84bb953373f30ff91e7df3f", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -398,8 +398,6 @@\n //! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n //! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n //! ```\n-//!\n-//! [IntoIterator]: crate::iter::IntoIterator \"iter::IntoIterator\"\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "5c0541d3caf3308d271c54d940307309e792dc21", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -6,7 +6,6 @@ use crate::cmp;\n use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::iter::Extend;\n use crate::ops;\n use crate::rc::Rc;\n use crate::str::FromStr;"}, {"sha": "34c0ce9dcf848288607ac1be02ba2f7e4bba810c", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -11,7 +11,6 @@ mod repr_unpacked;\n #[cfg(not(target_pointer_width = \"64\"))]\n use repr_unpacked::Repr;\n \n-use crate::convert::From;\n use crate::error;\n use crate::fmt;\n use crate::result;"}, {"sha": "43842bee992a7959fffa941164864af0999b14ae", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1678,7 +1678,7 @@ mod super_keyword {}\n /// below `Iterator` is a **supertrait** and `ThreeIterator` is a **subtrait**:\n ///\n /// ```rust\n-/// trait ThreeIterator: std::iter::Iterator {\n+/// trait ThreeIterator: Iterator {\n ///     fn next_three(&mut self) -> Option<[Self::Item; 3]>;\n /// }\n /// ```"}, {"sha": "8014ba992eaf83e09ea47e044d50e71a5d441794", "filename": "library/std/src/path.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -78,7 +78,7 @@ use crate::fmt;\n use crate::fs;\n use crate::hash::{Hash, Hasher};\n use crate::io;\n-use crate::iter::{self, FusedIterator};\n+use crate::iter::FusedIterator;\n use crate::ops::{self, Deref};\n use crate::rc::Rc;\n use crate::str::FromStr;\n@@ -450,26 +450,26 @@ impl<'a> PrefixComponent<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> cmp::PartialEq for PrefixComponent<'a> {\n+impl<'a> PartialEq for PrefixComponent<'a> {\n     #[inline]\n     fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n-        cmp::PartialEq::eq(&self.parsed, &other.parsed)\n+        self.parsed == other.parsed\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n+impl<'a> PartialOrd for PrefixComponent<'a> {\n     #[inline]\n     fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n-        cmp::PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n+        PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Ord for PrefixComponent<'_> {\n+impl Ord for PrefixComponent<'_> {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n-        cmp::Ord::cmp(&self.parsed, &other.parsed)\n+        Ord::cmp(&self.parsed, &other.parsed)\n     }\n }\n \n@@ -988,7 +988,7 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n impl FusedIterator for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> cmp::PartialEq for Components<'a> {\n+impl<'a> PartialEq for Components<'a> {\n     #[inline]\n     fn eq(&self, other: &Components<'a>) -> bool {\n         let Components { path: _, front: _, back: _, has_physical_root: _, prefix: _ } = self;\n@@ -1015,18 +1015,18 @@ impl<'a> cmp::PartialEq for Components<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for Components<'_> {}\n+impl Eq for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> cmp::PartialOrd for Components<'a> {\n+impl<'a> PartialOrd for Components<'a> {\n     #[inline]\n     fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n         Some(compare_components(self.clone(), other.clone()))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Ord for Components<'_> {\n+impl Ord for Components<'_> {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         compare_components(self.clone(), other.clone())\n@@ -1741,7 +1741,7 @@ impl FromStr for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n+impl<P: AsRef<Path>> FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n         let mut buf = PathBuf::new();\n         buf.extend(iter);\n@@ -1750,7 +1750,7 @@ impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n+impl<P: AsRef<Path>> Extend<P> for PathBuf {\n     fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |p| self.push(p.as_ref()));\n     }\n@@ -1904,7 +1904,7 @@ impl ToOwned for Path {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for PathBuf {\n+impl PartialEq for PathBuf {\n     #[inline]\n     fn eq(&self, other: &PathBuf) -> bool {\n         self.components() == other.components()\n@@ -1919,18 +1919,18 @@ impl Hash for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for PathBuf {}\n+impl Eq for PathBuf {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialOrd for PathBuf {\n+impl PartialOrd for PathBuf {\n     #[inline]\n     fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n         Some(compare_components(self.components(), other.components()))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Ord for PathBuf {\n+impl Ord for PathBuf {\n     #[inline]\n     fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n         compare_components(self.components(), other.components())\n@@ -3025,7 +3025,7 @@ impl fmt::Display for Display<'_> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for Path {\n+impl PartialEq for Path {\n     #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.components() == other.components()\n@@ -3084,18 +3084,18 @@ impl Hash for Path {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for Path {}\n+impl Eq for Path {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialOrd for Path {\n+impl PartialOrd for Path {\n     #[inline]\n     fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n         Some(compare_components(self.components(), other.components()))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Ord for Path {\n+impl Ord for Path {\n     #[inline]\n     fn cmp(&self, other: &Path) -> cmp::Ordering {\n         compare_components(self.components(), other.components())"}, {"sha": "1b29c887d21003a8d1bf3e03b5a82d83f9f8c28b", "filename": "library/std/src/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -34,7 +34,7 @@\n //!   marker traits that indicate fundamental properties of types.\n //! * <code>[std::ops]::{[Drop], [Fn], [FnMut], [FnOnce]}</code>, various\n //!   operations for both destructors and overloading `()`.\n-//! * <code>[std::mem]::[drop][mem::drop]</code>, a convenience function for explicitly\n+//! * <code>[std::mem]::[drop]</code>, a convenience function for explicitly\n //!   dropping a value.\n //! * <code>[std::boxed]::[Box]</code>, a way to allocate values on the heap.\n //! * <code>[std::borrow]::[ToOwned]</code>, the conversion trait that defines\n@@ -66,7 +66,6 @@\n //! * <code>[std::convert]::{[TryFrom], [TryInto]}</code>,\n //! * <code>[std::iter]::[FromIterator]</code>.\n //!\n-//! [mem::drop]: crate::mem::drop\n //! [std::borrow]: crate::borrow\n //! [std::boxed]: crate::boxed\n //! [std::clone]: crate::clone\n@@ -86,9 +85,6 @@\n //! [std::slice]: crate::slice\n //! [std::string]: crate::string\n //! [std::vec]: mod@crate::vec\n-//! [TryFrom]: crate::convert::TryFrom\n-//! [TryInto]: crate::convert::TryInto\n-//! [FromIterator]: crate::iter::FromIterator\n //! [`to_owned`]: crate::borrow::ToOwned::to_owned\n //! [book-closures]: ../../book/ch13-01-closures.html\n //! [book-dtor]: ../../book/ch15-03-drop.html"}, {"sha": "3df990e5dd9fee4bf5d29baa6b0cd9713ba42973", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -577,7 +577,6 @@ impl Copy for () {\n /// [`is_null`]: pointer::is_null\n /// [`offset`]: pointer::offset\n #[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n-/// [`drop`]: mem::drop\n /// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer {}\n@@ -1026,7 +1025,6 @@ mod prim_str {}\n /// * [`UnwindSafe`]\n /// * [`RefUnwindSafe`]\n ///\n-/// [`Unpin`]: marker::Unpin\n /// [`UnwindSafe`]: panic::UnwindSafe\n /// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n@@ -1405,10 +1403,6 @@ mod prim_ref {}\n ///\n /// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n ///\n-/// [`Fn`]: ops::Fn\n-/// [`FnMut`]: ops::FnMut\n-/// [`FnOnce`]: ops::FnOnce\n-///\n /// Function pointers are pointers that point to *code*, not data. They can be called\n /// just like functions. Like references, function pointers are, among other things, assumed to\n /// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null"}, {"sha": "0ab72f7ea7a6d34ff20628765838b55f816f2250", "filename": "library/std/src/process.rs", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -652,10 +652,19 @@ impl Command {\n         self\n     }\n \n-    /// Inserts or updates an environment variable mapping.\n+    /// Inserts or updates an explicit environment variable mapping.\n     ///\n-    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n-    /// and case-sensitive on all other platforms.\n+    /// This method allows you to add an environment variable mapping to the spawned process or\n+    /// overwrite a previously set value. You can use [`Command::envs`] to set multiple environment\n+    /// variables simultaneously.\n+    ///\n+    /// Child processes will inherit environment variables from their parent process by default.\n+    /// Environment variables explicitly set using [`Command::env`] take precedence over inherited\n+    /// variables. You can disable environment variable inheritance entirely using\n+    /// [`Command::env_clear`] or for a single key using [`Command::env_remove`].\n+    ///\n+    /// Note that environment variable names are case-insensitive (but\n+    /// case-preserving) on Windows and case-sensitive on all other platforms.\n     ///\n     /// # Examples\n     ///\n@@ -679,7 +688,19 @@ impl Command {\n         self\n     }\n \n-    /// Adds or updates multiple environment variable mappings.\n+    /// Inserts or updates multiple explicit environment variable mappings.\n+    ///\n+    /// This method allows you to add multiple environment variable mappings to the spawned process\n+    /// or overwrite previously set values. You can use [`Command::env`] to set a single environment\n+    /// variable.\n+    ///\n+    /// Child processes will inherit environment variables from their parent process by default.\n+    /// Environment variables explicitly set using [`Command::envs`] take precedence over inherited\n+    /// variables. You can disable environment variable inheritance entirely using\n+    /// [`Command::env_clear`] or for a single key using [`Command::env_remove`].\n+    ///\n+    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows\n+    /// and case-sensitive on all other platforms.\n     ///\n     /// # Examples\n     ///\n@@ -716,7 +737,18 @@ impl Command {\n         self\n     }\n \n-    /// Removes an environment variable mapping.\n+    /// Removes an explicitly set environment variable and prevents inheriting it from a parent\n+    /// process.\n+    ///\n+    /// This method will remove the explicit value of an environment variable set via\n+    /// [`Command::env`] or [`Command::envs`]. In addition, it will prevent the spawned child\n+    /// process from inheriting that environment variable from its parent process.\n+    ///\n+    /// After calling [`Command::env_remove`], the value associated with its key from\n+    /// [`Command::get_envs`] will be [`None`].\n+    ///\n+    /// To clear all explicitly set environment variables and disable all environment variable\n+    /// inheritance, you can use [`Command::env_clear`].\n     ///\n     /// # Examples\n     ///\n@@ -736,7 +768,17 @@ impl Command {\n         self\n     }\n \n-    /// Clears the entire environment map for the child process.\n+    /// Clears all explicitly set environment variables and prevents inheriting any parent process\n+    /// environment variables.\n+    ///\n+    /// This method will remove all explicitly added environment variables set via [`Command::env`]\n+    /// or [`Command::envs`]. In addition, it will prevent the spawned child process from inheriting\n+    /// any environment variable from its parent process.\n+    ///\n+    /// After calling [`Command::env_remove`], the iterator from [`Command::get_envs`] will be\n+    /// empty.\n+    ///\n+    /// You can use [`Command::env_remove`] to clear a single mapping.\n     ///\n     /// # Examples\n     ///\n@@ -988,17 +1030,21 @@ impl Command {\n         CommandArgs { inner: self.inner.get_args() }\n     }\n \n-    /// Returns an iterator of the environment variables that will be set when\n-    /// the process is spawned.\n+    /// Returns an iterator of the environment variables explicitly set for the child process.\n+    ///\n+    /// Environment variables explicitly set using [`Command::env`], [`Command::envs`], and\n+    /// [`Command::env_remove`] can be retrieved with this method.\n+    ///\n+    /// Note that this output does not include environment variables inherited from the parent\n+    /// process.\n     ///\n-    /// Each element is a tuple `(&OsStr, Option<&OsStr>)`, where the first\n-    /// value is the key, and the second is the value, which is [`None`] if\n-    /// the environment variable is to be explicitly removed.\n+    /// Each element is a tuple key/value pair `(&OsStr, Option<&OsStr>)`. A [`None`] value\n+    /// indicates its key was explicitly removed via [`Command::env_remove`]. The associated key for\n+    /// the [`None`] value will no longer inherit from its parent process.\n     ///\n-    /// This only includes environment variables explicitly set with\n-    /// [`Command::env`], [`Command::envs`], and [`Command::env_remove`]. It\n-    /// does not include environment variables that will be inherited by the\n-    /// child process.\n+    /// An empty iterator can indicate that no explicit mappings were added or that\n+    /// [`Command::env_clear`] was called. After calling [`Command::env_clear`], the child process\n+    /// will not inherit any environment variables from its parent process.\n     ///\n     /// # Examples\n     ///"}, {"sha": "01505e94487b2a629dd7e0d12ecf51efeeaa63d7", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -3,7 +3,6 @@\n use crate::arch::asm;\n use crate::cell::UnsafeCell;\n use crate::cmp;\n-use crate::convert::TryInto;\n use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\n use crate::ptr::{self, NonNull};"}, {"sha": "abef170dd5a64700af4e02d8c9970132bbb7ec96", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1893,7 +1893,7 @@ mod remove_dir_impl {\n         // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n         let new_parent_fd = dir_fd.into_raw_fd();\n         // a valid root is not needed because we do not call any functions involving the full path\n-        // of the DirEntrys.\n+        // of the `DirEntry`s.\n         let dummy_root = PathBuf::new();\n         let inner = InnerReadDir { dirp, root: dummy_root };\n         Ok((ReadDir::new(inner), new_parent_fd))"}, {"sha": "d310be6c7a1eb8ba59174cd710518f955cb9f7fb", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -273,8 +273,6 @@ pub mod zircon {\n \n #[cfg(target_os = \"fuchsia\")]\n pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n-    use crate::convert::TryFrom;\n-\n     // Sleep forever if the timeout is longer than fits in a i64.\n     let deadline = timeout\n         .and_then(|d| {"}, {"sha": "a345af76fa217d791c64a0790cc5a493192d05de", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -7,7 +7,6 @@ mod tests;\n \n use crate::os::unix::prelude::*;\n \n-use crate::convert::TryFrom;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;"}, {"sha": "e45c380a0bb8497e9af068ec20680d35aa50bc76", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -166,7 +166,6 @@ impl Process {\n     }\n \n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        use crate::default::Default;\n         use crate::sys::process::zircon::*;\n \n         let mut proc_info: zx_info_process_t = Default::default();\n@@ -199,7 +198,6 @@ impl Process {\n     }\n \n     pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        use crate::default::Default;\n         use crate::sys::process::zircon::*;\n \n         let mut proc_info: zx_info_process_t = Default::default();"}, {"sha": "ad8da19b6daa8332d858520766578f230b1a356e", "filename": "library/std/src/sys/windows/c/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -12,7 +12,7 @@ pub const ERROR_RESOURCE_CALL_TIMED_OUT: DWORD = 5910;\n pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: DWORD = 8014;\n pub const DNS_ERROR_RECORD_TIMED_OUT: DWORD = 9705;\n \n-// The followiung list was obtained from\n+// The following list was obtained from\n //   `/usr/x86_64-w64-mingw32/include/winerror.h`\n // in the Debian package\n //   mingw-w64_6.0.0-3_all.deb"}, {"sha": "cb24caa1e8a60ea93f699fa2d47b924d99216382", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,7 +2,6 @@\n mod tests;\n \n use crate::cmp;\n-use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;"}, {"sha": "15042fc3beecb2c71ab4e1d2dbb173971d769263", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -79,7 +79,7 @@ impl Parker {\n             park_timeout(dur, self.state.as_ptr().addr());\n             // Swap to ensure that we observe all state changes with acquire\n             // ordering, even if the state has been changed after the timeout\n-            // occured.\n+            // occurred.\n             self.state.swap(EMPTY, Acquire);\n         }\n     }"}, {"sha": "e76d6716b94fe13cf5236ff56f63a1b4158dd285", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -219,14 +219,14 @@ pub fn assert_test_result<T: Termination>(result: T) -> Result<(), String> {\n \n struct FilteredTests {\n     tests: Vec<(TestId, TestDescAndFn)>,\n-    benchs: Vec<(TestId, TestDescAndFn)>,\n+    benches: Vec<(TestId, TestDescAndFn)>,\n     next_id: usize,\n }\n \n impl FilteredTests {\n     fn add_bench(&mut self, desc: TestDesc, testfn: TestFn) {\n         let test = TestDescAndFn { desc, testfn };\n-        self.benchs.push((TestId(self.next_id), test));\n+        self.benches.push((TestId(self.next_id), test));\n         self.next_id += 1;\n     }\n     fn add_test(&mut self, desc: TestDesc, testfn: TestFn) {\n@@ -245,7 +245,7 @@ impl FilteredTests {\n         self.add_test(desc, testfn);\n     }\n     fn total_len(&self) -> usize {\n-        self.tests.len() + self.benchs.len()\n+        self.tests.len() + self.benches.len()\n     }\n }\n \n@@ -290,7 +290,7 @@ where\n \n     let tests_len = tests.len();\n \n-    let mut filtered = FilteredTests { tests: Vec::new(), benchs: Vec::new(), next_id: 0 };\n+    let mut filtered = FilteredTests { tests: Vec::new(), benches: Vec::new(), next_id: 0 };\n \n     for test in filter_tests(opts, tests) {\n         let mut desc = test.desc;\n@@ -457,7 +457,7 @@ where\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n-        for (id, b) in filtered.benchs {\n+        for (id, b) in filtered.benches {\n             let event = TestEvent::TeWait(b.desc.clone());\n             notify_about_test_event(event)?;\n             let join_handle = run_test(opts, false, id, b, run_strategy, tx.clone());"}, {"sha": "5376c4ec9c325281a9b6bad8b96c48185de9e9cf", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,9 +1,8 @@\n use std::any::{Any, TypeId};\n use std::borrow::Borrow;\n use std::cell::RefCell;\n-use std::cmp::{Ord, Ordering, PartialOrd};\n+use std::cmp::Ordering;\n use std::collections::HashMap;\n-use std::convert::AsRef;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;"}, {"sha": "eb2285ef90646a7f3d6e028ac542aebfc877ed9d", "filename": "src/doc/rustdoc/src/write-documentation/linking-to-items-by-name.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Flinking-to-items-by-name.md", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Flinking-to-items-by-name.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Flinking-to-items-by-name.md?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -103,6 +103,13 @@ macro_rules! foo {\n }\n ```\n \n+There is one case where the disambiguation will be performed automatically: if an intra doc\n+link is resolved at the same time as a trait and as a derive proc-macro. In this case, it'll\n+always generate a link to the trait and not emit a \"missing disambiguation\" warning. A good\n+example of this case is when you link to the `Clone` trait: there is also a `Clone`\n+proc-macro but it ignores it in this case. If you want to link to the proc-macro, you can\n+use the `macro@` disambiguator.\n+\n ## Warnings, re-exports, and scoping\n \n Links are resolved in the scope of the module where the item is defined, even"}, {"sha": "5fa0c120fba10eef4bbc9c5f9384c82abcd85b52", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -35,7 +35,6 @@ use rustc_span::{self, ExpnKind};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::collections::BTreeMap;\n-use std::default::Default;\n use std::hash::Hash;\n use std::mem;\n use thin_vec::ThinVec;"}, {"sha": "6d2ce9e2833f4ffaa26494bb7a45bdfe9b4e7e8d", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::cell::RefCell;\n-use std::default::Default;\n use std::hash::Hash;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -980,7 +979,7 @@ pub(crate) trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `word`\n     fn has_word(self, word: Symbol) -> bool\n     where\n-        Self: std::marker::Sized,\n+        Self: Sized,\n     {\n         <Self as NestedAttributesExt>::get_word_attr(self, word).is_some()\n     }"}, {"sha": "1be4f364eadebdeb3d36ed4f1ad216c4601aa84a", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::ffi::OsStr;\n use std::fmt;\n use std::path::PathBuf;"}, {"sha": "00aadb8e82aebea222a07332da5602d9df337c5d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -36,7 +36,6 @@ use rustc_span::{Span, Symbol};\n use once_cell::sync::Lazy;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::default::Default;\n use std::fmt::Write;\n use std::ops::{ControlFlow, Range};\n use std::str;"}, {"sha": "463184acaa14f3fa61918c76d9b479e59fda1938", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -38,7 +38,6 @@ pub(crate) use self::context::*;\n pub(crate) use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n-use std::default::Default;\n use std::fmt::{self, Write};\n use std::fs;\n use std::iter::Peekable;"}, {"sha": "f5b4a3f5abd659ae690b85e68571ee8df2e257e2", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn build_index<'tcx>(\n         // `sort_unstable_by_key` produces lifetime errors\n         let k1 = (&k1.path, k1.name.as_str(), &k1.ty, &k1.parent);\n         let k2 = (&k2.path, k2.name.as_str(), &k2.ty, &k2.parent);\n-        std::cmp::Ord::cmp(&k1, &k2)\n+        Ord::cmp(&k1, &k2)\n     });\n \n     // Set up alias indexes."}, {"sha": "cd6509607d5616c8d140a25c2d57589d20d55d5f", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -4,7 +4,6 @@\n \n #![allow(rustc::default_hash_types)]\n \n-use std::convert::From;\n use std::fmt;\n \n use rustc_ast::ast;"}, {"sha": "4a88dc5254de611d025e5cf1a4702ec4fb6e1493", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -69,7 +69,6 @@ extern crate test;\n #[cfg(feature = \"jemalloc\")]\n extern crate jemalloc_sys;\n \n-use std::default::Default;\n use std::env::{self, VarError};\n use std::io::{self, IsTerminal};\n use std::process;"}, {"sha": "b007f9a22c36ff6a1074b606ef018d1369aaea46", "filename": "src/tools/bump-stage0/src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Fbump-stage0%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Fbump-stage0%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbump-stage0%2Fsrc%2Fmain.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,7 +2,6 @@ use anyhow::{Context, Error};\n use curl::easy::Easy;\n use indexmap::IndexMap;\n use std::collections::HashMap;\n-use std::convert::TryInto;\n \n const PATH: &str = \"src/stage0.json\";\n const COMPILER_COMPONENTS: &[&str] = &[\"rustc\", \"rust-std\", \"cargo\"];"}, {"sha": "197e9a9965f7d729b4f728b0e4eb641d755e1786", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -57,8 +57,8 @@ mod os_impl {\n             match fs::File::create(&path) {\n                 Ok(file) => {\n                     let exec = is_executable(&path).unwrap_or(false);\n-                    std::mem::drop(file);\n-                    std::fs::remove_file(&path).expect(\"Deleted temp file\");\n+                    drop(file);\n+                    fs::remove_file(&path).expect(\"Deleted temp file\");\n                     // If the file is executable, then we assume that this\n                     // filesystem does not track executability, so skip this check.\n                     return if exec { Unsupported } else { Supported };"}, {"sha": "6fd41e833624fcc3dc94a4bf87812532c1119a31", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -31,7 +31,6 @@\n //! this in the long term.\n \n use crate::walk::{filter_dirs, walk};\n-use std::iter::Iterator;\n use std::path::Path;\n \n // Paths that may contain platform-specific code."}, {"sha": "7547b49ab2a54e82478de82ab204afcb0c2cc95a", "filename": "src/tools/unicode-table-generator/src/raw_emitter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,6 +1,5 @@\n use crate::fmt_list;\n use std::collections::{BTreeMap, BTreeSet, HashMap};\n-use std::convert::TryFrom;\n use std::fmt::{self, Write};\n use std::ops::Range;\n "}, {"sha": "9b613a94c579549af4971575c70d47230755423b", "filename": "src/tools/unicode-table-generator/src/skiplist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fskiplist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fskiplist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fskiplist.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,6 +1,5 @@\n use crate::fmt_list;\n use crate::raw_emitter::RawEmitter;\n-use std::convert::TryInto;\n use std::fmt::Write as _;\n use std::ops::Range;\n "}, {"sha": "a7252a400277013893301b71bc833e02ee27e851", "filename": "tests/ui/hygiene/panic-location.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhygiene%2Fpanic-location.run.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'capacity overflow', library/alloc/src/raw_vec.rs:525:5\n+thread 'main' panicked at 'capacity overflow', library/alloc/src/raw_vec.rs:524:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "9f4558adab150708696dc1aba163bd6cdbacca3d", "filename": "tests/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -67,9 +67,6 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -78,9 +75,6 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -98,9 +92,6 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "15a3b580568d6228164a4b6296c9b5de623b96f0", "filename": "tests/ui/type/type-check/point-at-inference-3.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,7 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1i32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "a48c4f9862f75777befe63a3371d5e43735e0e5a", "filename": "tests/ui/type/type-check/point-at-inference-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,7 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1u32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "238764812364cc1c56053efa9b728c665bf4df4d", "filename": "tests/ui/type/type-check/point-at-inference-3.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,8 +1,10 @@\n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-3.rs:7:12\n+  --> $DIR/point-at-inference-3.rs:8:12\n    |\n LL |     v.push(0i32);\n-   |            ---- this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+   |     -      ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `v` to have type `Vec<i32>`\n ...\n LL |     v.push(1u32);\n    |       ---- ^^^^ expected `i32`, found `u32`"}, {"sha": "3deb234c2751e308bd2f877eda759e745e2bba21", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -11,8 +11,11 @@ fn main() {\n     let s = S(None);\n     s.infer(0i32);\n     //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n+    //~| NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `s` to have type `S<i32, _>`\n     //~| NOTE an argument is missing\n     //~| HELP provide the argument\n+    //~| HELP change the type of the numeric literal from `i32` to `u32`\n     let t: S<u32, _> = s;\n     //~^ ERROR mismatched types\n     //~| NOTE expected `S<u32, _>`, found `S<i32, _>`"}, {"sha": "5f7bb8b9367ec6d256fb523bb059b95ac7071ce5", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -15,15 +15,24 @@ LL |     s.infer(0i32, /* b */);\n    |            ~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-4.rs:16:24\n+  --> $DIR/point-at-inference-4.rs:19:24\n    |\n+LL |     s.infer(0i32);\n+   |     -       ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `s` to have type `S<i32, _>`\n+...\n LL |     let t: S<u32, _> = s;\n    |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n    |            |\n    |            expected due to this\n    |\n    = note: expected struct `S<u32, _>`\n               found struct `S<i32, _>`\n+help: change the type of the numeric literal from `i32` to `u32`\n+   |\n+LL |     s.infer(0u32);\n+   |              ~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5fc94d4d1b6baacfc0d8958815041bde4fbf7f89", "filename": "tests/ui/type/type-check/point-at-inference.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/point-at-inference.rs:12:9\n    |\n LL |         foo.push(i);\n-   |                  - this is of type `&{integer}`, which causes `foo` to be inferred as `Vec<&{integer}>`\n+   |         ---      - this argument has type `&{integer}`...\n+   |         |\n+   |         ... which causes `foo` to have type `Vec<&{integer}>`\n ...\n LL |     bar(foo);\n    |     --- ^^^ expected `Vec<i32>`, found `Vec<&{integer}>`"}, {"sha": "72533ab1fa37f8a7384283e0201a0ef92d68c67d", "filename": "tests/ui/typeck/bad-type-in-vec-contains.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -7,7 +7,6 @@ LL |     primes.contains(3);\n    |            |        expected `&_`, found integer\n    |            |        help: consider borrowing here: `&3`\n    |            arguments to this method are incorrect\n-   |            here the type of `primes` is inferred to be `[_]`\n    |\n    = note: expected reference `&_`\n                    found type `{integer}`"}, {"sha": "1d5337260fa0ab289f33a6b575385c8f5d914cf2", "filename": "tests/ui/typeck/bad-type-in-vec-push.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -1,8 +1,6 @@\n error[E0308]: mismatched types\n   --> $DIR/bad-type-in-vec-push.rs:11:17\n    |\n-LL |     vector.sort();\n-   |     ------ here the type of `vector` is inferred to be `Vec<_>`\n LL |     result.push(vector);\n    |            ---- ^^^^^^ expected integer, found `Vec<_>`\n    |            |"}, {"sha": "b97e74b7e53fa22d08189a899a1abfeb1caf01ca", "filename": "tests/ui/typeck/issue-107775.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd17b56a931a631a23dfd5ef2018fd3ef49108/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.stderr?ref=84dd17b56a931a631a23dfd5ef2018fd3ef49108", "patch": "@@ -2,9 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-107775.rs:35:16\n    |\n LL |         map.insert(1, Struct::do_something);\n-   |                    -  -------------------- this is of type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n-   |                    |\n-   |                    this is of type `{integer}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+   |         ---           -------------------- this argument has type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`...\n+   |         |\n+   |         ... which causes `map` to have type `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n LL |         Self { map }\n    |                ^^^ expected `HashMap<u16, fn(u8) -> Pin<...>>`, found `HashMap<{integer}, ...>`\n    |"}]}