{"sha": "844bc65333184f90670e950233513e5c7bf0572e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NGJjNjUzMzMxODRmOTA2NzBlOTUwMjMzNTEzZTVjN2JmMDU3MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T01:18:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T01:18:45Z"}, "message": "Auto merge of #50235 - Zoxc:rayon, r=michaelwoerister\n\nAdd a Rayon thread pool\n\nr? @michaelwoerister", "tree": {"sha": "3ac727d32c1a80bd4874923766b09a1a6324763d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ac727d32c1a80bd4874923766b09a1a6324763d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/844bc65333184f90670e950233513e5c7bf0572e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/844bc65333184f90670e950233513e5c7bf0572e", "html_url": "https://github.com/rust-lang/rust/commit/844bc65333184f90670e950233513e5c7bf0572e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/844bc65333184f90670e950233513e5c7bf0572e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "html_url": "https://github.com/rust-lang/rust/commit/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07"}, {"sha": "4afdae633d34384b0582c209f38d1f89ae4aa673", "url": "https://api.github.com/repos/rust-lang/rust/commits/4afdae633d34384b0582c209f38d1f89ae4aa673", "html_url": "https://github.com/rust-lang/rust/commit/4afdae633d34384b0582c209f38d1f89ae4aa673"}], "stats": {"total": 930, "additions": 573, "deletions": 357}, "files": [{"sha": "4cb82f94251ff62ab3a94082220fbebb0d899478", "filename": "src/Cargo.lock", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -1844,6 +1844,27 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc-rayon\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc-rayon-core\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-serialize\"\n version = \"0.3.24\"\n@@ -1911,6 +1932,7 @@ dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1926,6 +1948,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -1943,6 +1966,7 @@ dependencies = [\n  \"rustc_traits 0.0.0\",\n  \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n+ \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n@@ -3118,6 +3142,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-syntax 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b50671adb9b0a7c57a4690ac6a40cb614879f543b64aada42f55b66212492323\"\n \"checksum rustc-ap-syntax_pos 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55793c2a775230c42661194c48d44b35d4c8439d79ad8528e56651e854c48c63\"\n \"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n+\"checksum rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1aa5cd8c3a706edb19b6ec6aa7b056bdc635b6e99c5cf7014f9af9d92f15e99\"\n+\"checksum rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d69983f8613a9c3ba1a3bbf5e8bdf2fd5c42317b1d8dd8623ca8030173bf8a6b\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum rustc_version 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a54aa04a10c68c1c4eacb4337fd883b435997ede17a9385784b990777686b09a\"\n \"checksum rustfix 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"165a212dd11124d7070892da20f71d82970ef1d1dd41cd804b70f39740a21c85\""}, {"sha": "a62000e10c79f8374116269b5eeb45c534307cea", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -88,3 +88,33 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n         self.visitor.visit_impl_item(impl_item);\n     }\n }\n+\n+/// A parallel variant of ItemLikeVisitor\n+pub trait ParItemLikeVisitor<'hir> {\n+    fn visit_item(&self, item: &'hir Item);\n+    fn visit_trait_item(&self, trait_item: &'hir TraitItem);\n+    fn visit_impl_item(&self, impl_item: &'hir ImplItem);\n+}\n+\n+pub trait IntoVisitor<'hir> {\n+    type Visitor: Visitor<'hir>;\n+    fn into_visitor(&self) -> Self::Visitor;\n+}\n+\n+pub struct ParDeepVisitor<V>(pub V);\n+\n+impl<'hir, V> ParItemLikeVisitor<'hir> for ParDeepVisitor<V>\n+    where V: IntoVisitor<'hir>\n+{\n+    fn visit_item(&self, item: &'hir Item) {\n+        self.0.into_visitor().visit_item(item);\n+    }\n+\n+    fn visit_trait_item(&self, trait_item: &'hir TraitItem) {\n+        self.0.into_visitor().visit_trait_item(trait_item);\n+    }\n+\n+    fn visit_impl_item(&self, impl_item: &'hir ImplItem) {\n+        self.0.into_visitor().visit_impl_item(impl_item);\n+    }\n+}"}, {"sha": "33076267dbc9d427009475ef677d8c99b3966b36", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -48,6 +48,7 @@ use ty::AdtKind;\n use ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec;\n+use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope};\n \n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n@@ -720,6 +721,31 @@ impl Crate {\n         }\n     }\n \n+    /// A parallel version of visit_all_item_likes\n+    pub fn par_visit_all_item_likes<'hir, V>(&'hir self, visitor: &V)\n+        where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n+    {\n+        scope(|s| {\n+            s.spawn(|_| {\n+                par_iter(&self.items).for_each(|(_, item)| {\n+                    visitor.visit_item(item);\n+                });\n+            });\n+\n+            s.spawn(|_| {\n+                par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n+                    visitor.visit_trait_item(trait_item);\n+                });\n+            });\n+\n+            s.spawn(|_| {\n+                par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n+                    visitor.visit_impl_item(impl_item);\n+                });\n+            });\n+        });\n+    }\n+\n     pub fn body(&self, id: BodyId) -> &Body {\n         &self.bodies[&id]\n     }"}, {"sha": "61c8470b616f833f2284fede138d1002232b44c2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -38,7 +38,7 @@ use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n-use rustc_data_structures::sync::{MetadataRef, Lrc};\n+use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n \n pub use self::NativeLibraryKind::*;\n \n@@ -255,6 +255,8 @@ pub trait CrateStore {\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n+pub type CrateStoreDyn = CrateStore + sync::Sync;\n+\n // FIXME: find a better place for this?\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let mut err_count = 0;"}, {"sha": "bbf873290a928f76a277fb5ef8213fc7b8adb831", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -869,10 +869,16 @@ impl Session {\n         ret\n     }\n \n+    /// Returns the number of query threads that should be used for this\n+    /// compilation\n+    pub fn query_threads_from_opts(opts: &config::Options) -> usize {\n+        opts.debugging_opts.query_threads.unwrap_or(1)\n+    }\n+\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn query_threads(&self) -> usize {\n-        self.opts.debugging_opts.query_threads.unwrap_or(1)\n+        Self::query_threads_from_opts(&self.opts)\n     }\n \n     /// Returns the number of codegen units that should be used for this"}, {"sha": "dcd20465fbb9a1537954f701501564de942c0a43", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -26,7 +26,7 @@ use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use middle::cstore::{CrateStore, LinkMeta};\n+use middle::cstore::{CrateStoreDyn, LinkMeta};\n use middle::cstore::EncodedMetadata;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n@@ -852,7 +852,7 @@ pub struct GlobalCtxt<'tcx> {\n     global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n-    cstore: &'tcx dyn CrateStore,\n+    cstore: &'tcx CrateStoreDyn,\n \n     pub sess: &'tcx Session,\n \n@@ -1188,7 +1188,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                  cstore: &'tcx dyn CrateStore,\n+                                  cstore: &'tcx CrateStoreDyn,\n                                   local_providers: ty::maps::Providers<'tcx>,\n                                   extern_providers: ty::maps::Providers<'tcx>,\n                                   arenas: &'tcx AllArenas<'tcx>,\n@@ -1800,9 +1800,11 @@ pub mod tls {\n     /// in librustc otherwise. It is used to when diagnostic messages are\n     /// emitted and stores them in the current query, if there is one.\n     fn track_diagnostic(diagnostic: &Diagnostic) {\n-        with_context(|context| {\n-            if let Some(ref query) = context.query {\n-                query.diagnostics.lock().push(diagnostic.clone());\n+        with_context_opt(|icx| {\n+            if let Some(icx) = icx {\n+                if let Some(ref query) = icx.query {\n+                    query.diagnostics.lock().push(diagnostic.clone());\n+                }\n             }\n         })\n     }"}, {"sha": "6f1cbcad2f46c3bec9f83df0dd1614a4548d612c", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -16,6 +16,7 @@ serialize = { path = \"../libserialize\" }\n cfg-if = \"0.1.2\"\n stable_deref_trait = \"1.0.0\"\n parking_lot_core = \"0.2.8\"\n+rustc-rayon = \"0.1.0\"\n \n [dependencies.parking_lot]\n version = \"0.5\""}, {"sha": "b2e7450e76cdf4a9063e4dbb9e5bf6c147d9165d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -44,6 +44,7 @@ extern crate parking_lot;\n #[macro_use]\n extern crate cfg_if;\n extern crate stable_deref_trait;\n+extern crate rustc_rayon as rayon;\n \n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "3661763133014b593f42fd30f0bc1bbd345f3c44", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This mdoule defines types which are thread safe if cfg!(parallel_queries) is true.\n+//! This module defines types which are thread safe if cfg!(parallel_queries) is true.\n //!\n //! `Lrc` is an alias of either Rc or Arc.\n //!\n@@ -40,6 +40,29 @@ use std;\n use std::ops::{Deref, DerefMut};\n use owning_ref::{Erased, OwningRef};\n \n+pub fn serial_join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n+    where A: FnOnce() -> RA,\n+          B: FnOnce() -> RB\n+{\n+    (oper_a(), oper_b())\n+}\n+\n+pub struct SerialScope;\n+\n+impl SerialScope {\n+    pub fn spawn<F>(&self, f: F)\n+        where F: FnOnce(&SerialScope)\n+    {\n+        f(self)\n+    }\n+}\n+\n+pub fn serial_scope<F, R>(f: F) -> R\n+    where F: FnOnce(&SerialScope) -> R\n+{\n+    f(&SerialScope)\n+}\n+\n cfg_if! {\n     if #[cfg(not(parallel_queries))] {\n         pub auto trait Send {}\n@@ -55,9 +78,19 @@ cfg_if! {\n             }\n         }\n \n+        pub use self::serial_join as join;\n+        pub use self::serial_scope as scope;\n+\n+        pub use std::iter::Iterator as ParallelIterator;\n+\n+        pub fn par_iter<T: IntoIterator>(t: T) -> T::IntoIter {\n+            t.into_iter()\n+        }\n+\n         pub type MetadataRef = OwningRef<Box<Erased>, [u8]>;\n \n         pub use std::rc::Rc as Lrc;\n+        pub use std::rc::Weak as Weak;\n         pub use std::cell::Ref as ReadGuard;\n         pub use std::cell::RefMut as WriteGuard;\n         pub use std::cell::RefMut as LockGuard;\n@@ -160,13 +193,22 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n \n         pub use std::sync::Arc as Lrc;\n+        pub use std::sync::Weak as Weak;\n \n         pub use self::Lock as MTLock;\n \n         use parking_lot::Mutex as InnerLock;\n         use parking_lot::RwLock as InnerRwLock;\n \n         use std::thread;\n+        pub use rayon::{join, scope};\n+\n+        pub use rayon::iter::ParallelIterator;\n+        use rayon::iter::IntoParallelIterator;\n+\n+        pub fn par_iter<T: IntoParallelIterator>(t: T) -> T::Iter {\n+            t.into_par_iter()\n+        }\n \n         pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n "}, {"sha": "1827533f0acb5977be80b10f24c89e85f7291980", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -13,6 +13,8 @@ arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n+rustc-rayon = \"0.1.0\"\n+scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "62b3accc46f18e6bfc85600df45e1def21ef59c2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -20,7 +20,7 @@ use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n-use rustc::middle::cstore::CrateStore;\n+use rustc::middle::cstore::CrateStoreDyn;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::ext::base::ExtCtxt;\n@@ -64,6 +64,51 @@ use pretty::ReplaceBodyWithLoop;\n \n use profile;\n \n+#[cfg(not(parallel_queries))]\n+pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n+    opts: config::Options,\n+    f: F\n+) -> R {\n+    f(opts)\n+}\n+\n+#[cfg(parallel_queries)]\n+pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n+    opts: config::Options,\n+    f: F\n+) -> R {\n+    use syntax;\n+    use syntax_pos;\n+    use rayon::{ThreadPoolBuilder, ThreadPool};\n+\n+    let config = ThreadPoolBuilder::new().num_threads(Session::query_threads_from_opts(&opts))\n+                                         .stack_size(16 * 1024 * 1024);\n+\n+    let with_pool = move |pool: &ThreadPool| {\n+        pool.install(move || f(opts))\n+    };\n+\n+    syntax::GLOBALS.with(|syntax_globals| {\n+        syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n+            // The main handler run for each Rayon worker thread and sets up\n+            // the thread local rustc uses. syntax_globals and syntax_pos_globals are\n+            // captured and set on the new threads. ty::tls::with_thread_locals sets up\n+            // thread local callbacks from libsyntax\n+            let main_handler = move |worker: &mut FnMut()| {\n+                syntax::GLOBALS.set(syntax_globals, || {\n+                    syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                        ty::tls::with_thread_locals(|| {\n+                            worker()\n+                        })\n+                    })\n+                })\n+            };\n+\n+            ThreadPool::scoped_pool(config, main_handler, with_pool).unwrap()\n+        })\n+    })\n+}\n+\n pub fn compile_input(\n     trans: Box<TransCrate>,\n     sess: &Session,\n@@ -1047,7 +1092,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n     trans: &TransCrate,\n     control: &CompileController,\n     sess: &'tcx Session,\n-    cstore: &'tcx CrateStore,\n+    cstore: &'tcx CrateStoreDyn,\n     hir_map: hir_map::Map<'tcx>,\n     mut analysis: ty::CrateAnalysis,\n     resolutions: Resolutions,"}, {"sha": "148fbd73e9bd8ffc7d1e9cafea1c8cf684c0b684", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -27,12 +27,15 @@\n #![feature(rustc_stack_internals)]\n #![feature(no_debug)]\n \n+#![recursion_limit=\"256\"]\n+\n extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n extern crate env_logger;\n #[cfg(unix)]\n extern crate libc;\n+extern crate rustc_rayon as rayon;\n extern crate rustc;\n extern crate rustc_allocator;\n extern crate rustc_target;\n@@ -51,6 +54,7 @@ extern crate rustc_save_analysis;\n extern crate rustc_traits;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n+extern crate scoped_tls;\n extern crate serialize;\n #[macro_use]\n extern crate log;\n@@ -64,7 +68,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_data_structures::OnDrop;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n@@ -448,36 +452,40 @@ fn get_trans_sysroot(backend_name: &str) -> fn() -> Box<TransCrate> {\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler<'a>(args: &[String],\n-                        callbacks: &mut CompilerCalls<'a>,\n+                        callbacks: &mut (CompilerCalls<'a> + sync::Send),\n                         file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n                         emitter_dest: Option<Box<Write + Send>>)\n                         -> (CompileResult, Option<Session>)\n {\n     syntax::with_globals(|| {\n-        run_compiler_impl(args, callbacks, file_loader, emitter_dest)\n+        let matches = match handle_options(args) {\n+            Some(matches) => matches,\n+            None => return (Ok(()), None),\n+        };\n+\n+        let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n+\n+        driver::spawn_thread_pool(sopts, |sopts| {\n+            run_compiler_with_pool(matches, sopts, cfg, callbacks, file_loader, emitter_dest)\n+        })\n     })\n }\n \n-fn run_compiler_impl<'a>(args: &[String],\n-                         callbacks: &mut CompilerCalls<'a>,\n-                         file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n-                         emitter_dest: Option<Box<Write + Send>>)\n-                         -> (CompileResult, Option<Session>)\n-{\n+fn run_compiler_with_pool<'a>(\n+    matches: getopts::Matches,\n+    sopts: config::Options,\n+    cfg: ast::CrateConfig,\n+    callbacks: &mut (CompilerCalls<'a> + sync::Send),\n+    file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n+    emitter_dest: Option<Box<Write + Send>>\n+) -> (CompileResult, Option<Session>) {\n     macro_rules! do_or_return {($expr: expr, $sess: expr) => {\n         match $expr {\n             Compilation::Stop => return (Ok(()), $sess),\n             Compilation::Continue => {}\n         }\n     }}\n \n-    let matches = match handle_options(args) {\n-        Some(matches) => matches,\n-        None => return (Ok(()), None),\n-    };\n-\n-    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n-\n     let descriptions = diagnostics_registry();\n \n     do_or_return!(callbacks.early_callback(&matches,"}, {"sha": "108b47623383c0e3e27755fca3c4dd01f4bbd1d0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -20,7 +20,7 @@ use {abort_on_err, driver};\n use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n-use rustc::middle::cstore::CrateStore;\n+use rustc::middle::cstore::CrateStoreDyn;\n use rustc::session::Session;\n use rustc::session::config::{Input, OutputFilenames};\n use rustc_borrowck as borrowck;\n@@ -199,7 +199,7 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, F>(&self,\n                                                sess: &'tcx Session,\n-                                               cstore: &'tcx CrateStore,\n+                                               cstore: &'tcx CrateStoreDyn,\n                                                hir_map: &hir_map::Map<'tcx>,\n                                                analysis: &ty::CrateAnalysis,\n                                                resolutions: &Resolutions,\n@@ -912,7 +912,7 @@ pub fn print_after_parsing(sess: &Session,\n }\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                                cstore: &'tcx CrateStore,\n+                                                cstore: &'tcx CrateStoreDyn,\n                                                 hir_map: &hir_map::Map<'tcx>,\n                                                 analysis: &ty::CrateAnalysis,\n                                                 resolutions: &Resolutions,\n@@ -1068,7 +1068,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                       cstore: &'a CrateStore,\n+                                       cstore: &'a CrateStoreDyn,\n                                        hir_map: &hir_map::Map<'tcx>,\n                                        analysis: &ty::CrateAnalysis,\n                                        resolutions: &Resolutions,"}, {"sha": "7ae26e9e9798e72c15b8f64e70d1459c0b90e6c5", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -99,20 +99,25 @@ fn test_env<F>(source_string: &str,\n     where F: FnOnce(Env)\n {\n     syntax::with_globals(|| {\n-        test_env_impl(source_string, args, body)\n+        let mut options = config::basic_options();\n+        options.debugging_opts.verbose = true;\n+        options.unstable_features = UnstableFeatures::Allow;\n+\n+        driver::spawn_thread_pool(options, |options| {\n+            test_env_with_pool(options, source_string, args, body)\n+        })\n     });\n }\n \n-fn test_env_impl<F>(source_string: &str,\n-                    (emitter, expected_err_count): (Box<Emitter + sync::Send>, usize),\n-                    body: F)\n+fn test_env_with_pool<F>(\n+    options: config::Options,\n+    source_string: &str,\n+    (emitter, expected_err_count): (Box<Emitter + sync::Send>, usize),\n+    body: F\n+)\n     where F: FnOnce(Env)\n {\n-    let mut options = config::basic_options();\n-    options.debugging_opts.verbose = true;\n-    options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n-\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,"}, {"sha": "7d3ba792829382c75d6f613225f906aa1882dc9a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -697,7 +697,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n pub struct Attributes {\n     pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n-    pub cfg: Option<Rc<Cfg>>,\n+    pub cfg: Option<Arc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n     pub links: Vec<(String, Option<DefId>, Option<String>)>,\n@@ -848,7 +848,7 @@ impl Attributes {\n         Attributes {\n             doc_strings,\n             other_attrs,\n-            cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n+            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,\n             links: vec![],\n         }"}, {"sha": "6222edd5450f05cc1facd4fe4271816daab71d5a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 153, "deletions": 152, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -161,161 +161,162 @@ pub fn run_core(search_paths: SearchPaths,\n         edition,\n         ..config::basic_options().clone()\n     };\n-\n-    let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n-    let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n-        ErrorOutputType::HumanReadable(color_config) => Box::new(\n-            EmitterWriter::stderr(\n-                color_config,\n-                Some(codemap.clone()),\n-                false,\n-                sessopts.debugging_opts.teach,\n-            ).ui_testing(sessopts.debugging_opts.ui_testing)\n-        ),\n-        ErrorOutputType::Json(pretty) => Box::new(\n-            JsonEmitter::stderr(\n-                None,\n-                codemap.clone(),\n-                pretty,\n-                sessopts.debugging_opts.suggestion_applicability,\n-            ).ui_testing(sessopts.debugging_opts.ui_testing)\n-        ),\n-        ErrorOutputType::Short(color_config) => Box::new(\n-            EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false)\n-        ),\n-    };\n-\n-    let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n-        emitter,\n-        errors::HandlerFlags {\n-            can_emit_warnings: true,\n-            treat_err_as_bug: false,\n-            external_macro_backtrace: false,\n-            ..Default::default()\n-        },\n-    );\n-\n-    let mut sess = session::build_session_(\n-        sessopts, cpath, diagnostic_handler, codemap,\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let control = &driver::CompileController::basic();\n-\n-    let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n-\n-    let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n-\n-    let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n-\n-    let resolver_arenas = resolve::Resolver::arenas();\n-    let result = driver::phase_2_configure_and_expand_inner(&sess,\n-                                                      &cstore,\n-                                                      krate,\n-                                                      None,\n-                                                      &name,\n-                                                      None,\n-                                                      resolve::MakeGlobMap::No,\n-                                                      &resolver_arenas,\n-                                                      &mut crate_loader,\n-                                                      |_| Ok(()));\n-    let driver::InnerExpansionResult {\n-        mut hir_forest,\n-        resolver,\n-        ..\n-    } = abort_on_err(result, &sess);\n-\n-    // We need to hold on to the complete resolver, so we clone everything\n-    // for the analysis passes to use. Suboptimal, but necessary in the\n-    // current architecture.\n-    let defs = resolver.definitions.clone();\n-    let resolutions = ty::Resolutions {\n-        freevars: resolver.freevars.clone(),\n-        export_map: resolver.export_map.clone(),\n-        trait_map: resolver.trait_map.clone(),\n-        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-        maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-    };\n-    let analysis = ty::CrateAnalysis {\n-        access_levels: Lrc::new(AccessLevels::default()),\n-        name: name.to_string(),\n-        glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n-    };\n-\n-    let arenas = AllArenas::new();\n-    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n-    let output_filenames = driver::build_output_filenames(&input,\n-                                                          &None,\n-                                                          &None,\n-                                                          &[],\n-                                                          &sess);\n-\n-    let resolver = RefCell::new(resolver);\n-\n-    abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n-                                                     control,\n-                                                     &sess,\n-                                                     &*cstore,\n-                                                     hir_map,\n-                                                     analysis,\n-                                                     resolutions,\n-                                                     &arenas,\n-                                                     &name,\n-                                                     &output_filenames,\n-                                                     |tcx, analysis, _, result| {\n-        if let Err(_) = result {\n-            sess.fatal(\"Compilation failed, aborting rustdoc\");\n-        }\n-\n-        let ty::CrateAnalysis { access_levels, .. } = analysis;\n-\n-        // Convert from a NodeId set to a DefId set since we don't always have easy access\n-        // to the map from defid -> nodeid\n-        let access_levels = AccessLevels {\n-            map: access_levels.map.iter()\n-                                  .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n-                                  .collect()\n+    driver::spawn_thread_pool(sessopts, move |sessopts| {\n+        let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n+        let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n+            ErrorOutputType::HumanReadable(color_config) => Box::new(\n+                EmitterWriter::stderr(\n+                    color_config,\n+                    Some(codemap.clone()),\n+                    false,\n+                    sessopts.debugging_opts.teach,\n+                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            ),\n+            ErrorOutputType::Json(pretty) => Box::new(\n+                JsonEmitter::stderr(\n+                    None,\n+                    codemap.clone(),\n+                    pretty,\n+                    sessopts.debugging_opts.suggestion_applicability,\n+                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            ),\n+            ErrorOutputType::Short(color_config) => Box::new(\n+                EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false)\n+            ),\n         };\n \n-        let send_trait = if crate_name == Some(\"core\".to_string()) {\n-            clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n-        } else {\n-            clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+        let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n+            emitter,\n+            errors::HandlerFlags {\n+                can_emit_warnings: true,\n+                treat_err_as_bug: false,\n+                external_macro_backtrace: false,\n+                ..Default::default()\n+            },\n+        );\n+\n+        let mut sess = session::build_session_(\n+            sessopts, cpath, diagnostic_handler, codemap,\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let control = &driver::CompileController::basic();\n+\n+        let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n+\n+        let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n+\n+        let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n+\n+        let resolver_arenas = resolve::Resolver::arenas();\n+        let result = driver::phase_2_configure_and_expand_inner(&sess,\n+                                                        &cstore,\n+                                                        krate,\n+                                                        None,\n+                                                        &name,\n+                                                        None,\n+                                                        resolve::MakeGlobMap::No,\n+                                                        &resolver_arenas,\n+                                                        &mut crate_loader,\n+                                                        |_| Ok(()));\n+        let driver::InnerExpansionResult {\n+            mut hir_forest,\n+            resolver,\n+            ..\n+        } = abort_on_err(result, &sess);\n+\n+        // We need to hold on to the complete resolver, so we clone everything\n+        // for the analysis passes to use. Suboptimal, but necessary in the\n+        // current architecture.\n+        let defs = resolver.definitions.clone();\n+        let resolutions = ty::Resolutions {\n+            freevars: resolver.freevars.clone(),\n+            export_map: resolver.export_map.clone(),\n+            trait_map: resolver.trait_map.clone(),\n+            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n+            maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n         };\n-\n-        let ctxt = DocContext {\n-            tcx,\n-            resolver: &resolver,\n-            crate_name,\n-            cstore: cstore.clone(),\n-            populated_all_crate_impls: Cell::new(false),\n-            access_levels: RefCell::new(access_levels),\n-            external_traits: Default::default(),\n-            active_extern_traits: Default::default(),\n-            renderinfo: Default::default(),\n-            ty_substs: Default::default(),\n-            lt_substs: Default::default(),\n-            impl_trait_bounds: Default::default(),\n-            mod_ids: Default::default(),\n-            send_trait: send_trait,\n-            fake_def_ids: RefCell::new(FxHashMap()),\n-            all_fake_def_ids: RefCell::new(FxHashSet()),\n-            generated_synthetics: RefCell::new(FxHashSet()),\n-        };\n-        debug!(\"crate: {:?}\", tcx.hir.krate());\n-\n-        let krate = {\n-            let mut v = RustdocVisitor::new(&*cstore, &ctxt);\n-            v.visit(tcx.hir.krate());\n-            v.clean(&ctxt)\n+        let analysis = ty::CrateAnalysis {\n+            access_levels: Lrc::new(AccessLevels::default()),\n+            name: name.to_string(),\n+            glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n         };\n \n-        (krate, ctxt.renderinfo.into_inner())\n-    }), &sess)\n+        let arenas = AllArenas::new();\n+        let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n+        let output_filenames = driver::build_output_filenames(&input,\n+                                                            &None,\n+                                                            &None,\n+                                                            &[],\n+                                                            &sess);\n+\n+        let resolver = RefCell::new(resolver);\n+\n+        abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+                                                        control,\n+                                                        &sess,\n+                                                        &*cstore,\n+                                                        hir_map,\n+                                                        analysis,\n+                                                        resolutions,\n+                                                        &arenas,\n+                                                        &name,\n+                                                        &output_filenames,\n+                                                        |tcx, analysis, _, result| {\n+            if let Err(_) = result {\n+                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+            }\n+\n+            let ty::CrateAnalysis { access_levels, .. } = analysis;\n+\n+            // Convert from a NodeId set to a DefId set since we don't always have easy access\n+            // to the map from defid -> nodeid\n+            let access_levels = AccessLevels {\n+                map: access_levels.map.iter()\n+                                    .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n+                                    .collect()\n+            };\n+\n+            let send_trait = if crate_name == Some(\"core\".to_string()) {\n+                clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n+            } else {\n+                clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+            };\n+\n+            let ctxt = DocContext {\n+                tcx,\n+                resolver: &resolver,\n+                crate_name,\n+                cstore: cstore.clone(),\n+                populated_all_crate_impls: Cell::new(false),\n+                access_levels: RefCell::new(access_levels),\n+                external_traits: Default::default(),\n+                active_extern_traits: Default::default(),\n+                renderinfo: Default::default(),\n+                ty_substs: Default::default(),\n+                lt_substs: Default::default(),\n+                impl_trait_bounds: Default::default(),\n+                mod_ids: Default::default(),\n+                send_trait: send_trait,\n+                fake_def_ids: RefCell::new(FxHashMap()),\n+                all_fake_def_ids: RefCell::new(FxHashSet()),\n+                generated_synthetics: RefCell::new(FxHashSet()),\n+            };\n+            debug!(\"crate: {:?}\", tcx.hir.krate());\n+\n+            let krate = {\n+                let mut v = RustdocVisitor::new(&*cstore, &ctxt);\n+                v.visit(tcx.hir.krate());\n+                v.clean(&ctxt)\n+            };\n+\n+            (krate, ctxt.renderinfo.into_inner())\n+        }), &sess)\n+    })\n }"}, {"sha": "f2da09e16036ea05f9b56ca87c2645de6fd95bbe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -26,6 +26,8 @@\n #![feature(vec_remove_item)]\n #![feature(entry_and_modify)]\n \n+#![recursion_limit=\"256\"]\n+\n extern crate arena;\n extern crate getopts;\n extern crate env_logger;"}, {"sha": "fc8abafd4d89b549cb71e4b139f1a8532abec4d0", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use std::sync::Arc;\n \n use clean::{Crate, Item};\n use clean::cfg::Cfg;\n@@ -20,7 +20,7 @@ pub fn propagate_doc_cfg(cr: Crate) -> PluginResult {\n }\n \n struct CfgPropagator {\n-    parent_cfg: Option<Rc<Cfg>>,\n+    parent_cfg: Option<Arc<Cfg>>,\n }\n \n impl DocFolder for CfgPropagator {\n@@ -31,8 +31,8 @@ impl DocFolder for CfgPropagator {\n             (None, None) => None,\n             (Some(rc), None) | (None, Some(rc)) => Some(rc),\n             (Some(mut a), Some(b)) => {\n-                let b = Rc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n-                *Rc::make_mut(&mut a) &= b;\n+                let b = Arc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n+                *Arc::make_mut(&mut a) &= b;\n                 Some(a)\n             }\n         };"}, {"sha": "7be7ce313fcffcbc738bde5667ed6c7a1b31efdf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 163, "deletions": 156, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -85,77 +85,80 @@ pub fn run(input_path: &Path,\n         edition,\n         ..config::basic_options().clone()\n     };\n-\n-    let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n-    let handler =\n-        errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                          true, false,\n-                                          Some(codemap.clone()));\n-\n-    let mut sess = session::build_session_(\n-        sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = CStore::new(trans.metadata_loader());\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                                      &sess,\n-                                                      &input));\n-    let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n-        phase_2_configure_and_expand(\n-            &sess,\n-            &cstore,\n-            krate,\n-            None,\n-            \"rustdoc-test\",\n-            None,\n-            MakeGlobMap::No,\n-            |_| Ok(()),\n-        ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n-    };\n-\n-    let crate_name = crate_name.unwrap_or_else(|| {\n-        ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n-    });\n-    let mut opts = scrape_test_config(hir_forest.krate());\n-    opts.display_warnings |= display_warnings;\n-    let mut collector = Collector::new(crate_name,\n-                                       cfgs,\n-                                       libs,\n-                                       cg,\n-                                       externs,\n-                                       false,\n-                                       opts,\n-                                       maybe_sysroot,\n-                                       Some(codemap),\n-                                       None,\n-                                       linker,\n-                                       edition);\n-\n-    {\n-        let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n-        let krate = map.krate();\n-        let mut hir_collector = HirCollector {\n-            sess: &sess,\n-            collector: &mut collector,\n-            map: &map\n+    driver::spawn_thread_pool(sessopts, |sessopts| {\n+        let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n+        let handler =\n+            errors::Handler::with_tty_emitter(ColorConfig::Auto,\n+                                            true, false,\n+                                            Some(codemap.clone()));\n+\n+        let mut sess = session::build_session_(\n+            sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = CStore::new(trans.metadata_loader());\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n+                                                        &sess,\n+                                                        &input));\n+        let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n+            phase_2_configure_and_expand(\n+                &sess,\n+                &cstore,\n+                krate,\n+                None,\n+                \"rustdoc-test\",\n+                None,\n+                MakeGlobMap::No,\n+                |_| Ok(()),\n+            ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n         };\n-        hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n-            intravisit::walk_crate(this, krate);\n+\n+        let crate_name = crate_name.unwrap_or_else(|| {\n+            ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n         });\n-    }\n+        let mut opts = scrape_test_config(hir_forest.krate());\n+        opts.display_warnings |= display_warnings;\n+        let mut collector = Collector::new(\n+            crate_name,\n+            cfgs,\n+            libs,\n+            cg,\n+            externs,\n+            false,\n+            opts,\n+            maybe_sysroot,\n+            Some(codemap),\n+             None,\n+            linker,\n+            edition\n+        );\n+\n+        {\n+            let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n+            let krate = map.krate();\n+            let mut hir_collector = HirCollector {\n+                sess: &sess,\n+                collector: &mut collector,\n+                map: &map\n+            };\n+            hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+                intravisit::walk_crate(this, krate);\n+            });\n+        }\n \n-    test_args.insert(0, \"rustdoctest\".to_string());\n+        test_args.insert(0, \"rustdoctest\".to_string());\n \n-    testing::test_main(&test_args,\n-                       collector.tests.into_iter().collect(),\n-                       testing::Options::new().display_output(display_warnings));\n-    0\n+        testing::test_main(&test_args,\n+                        collector.tests.into_iter().collect(),\n+                        testing::Options::new().display_output(display_warnings));\n+        0\n+    })\n }\n \n // Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n@@ -229,102 +232,106 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         ..config::basic_options().clone()\n     };\n \n-    // Shuffle around a few input and output handles here. We're going to pass\n-    // an explicit handle into rustc to collect output messages, but we also\n-    // want to catch the error message that rustc prints when it fails.\n-    //\n-    // We take our thread-local stderr (likely set by the test runner) and replace\n-    // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own thread.\n-    //\n-    // The basic idea is to not use a default Handler for rustc, and then also\n-    // not print things by default to the actual stderr.\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n+    let (libdir, outdir) = driver::spawn_thread_pool(sessopts, |sessopts| {\n+        // Shuffle around a few input and output handles here. We're going to pass\n+        // an explicit handle into rustc to collect output messages, but we also\n+        // want to catch the error message that rustc prints when it fails.\n+        //\n+        // We take our thread-local stderr (likely set by the test runner) and replace\n+        // it with a sink that is also passed to rustc itself. When this function\n+        // returns the output of the sink is copied onto the output of our own thread.\n+        //\n+        // The basic idea is to not use a default Handler for rustc, and then also\n+        // not print things by default to the actual stderr.\n+        struct Sink(Arc<Mutex<Vec<u8>>>);\n+        impl Write for Sink {\n+            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+                Write::write(&mut *self.0.lock().unwrap(), data)\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n         }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-    struct Bomb(Arc<Mutex<Vec<u8>>>, Box<Write+Send>);\n-    impl Drop for Bomb {\n-        fn drop(&mut self) {\n-            let _ = self.1.write_all(&self.0.lock().unwrap());\n+        struct Bomb(Arc<Mutex<Vec<u8>>>, Box<Write+Send>);\n+        impl Drop for Bomb {\n+            fn drop(&mut self) {\n+                let _ = self.1.write_all(&self.0.lock().unwrap());\n+            }\n         }\n-    }\n-    let data = Arc::new(Mutex::new(Vec::new()));\n-    let codemap = Lrc::new(CodeMap::new_doctest(\n-        sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n-    ));\n-    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                      Some(codemap.clone()),\n-                                                      false,\n-                                                      false);\n-    let old = io::set_panic(Some(box Sink(data.clone())));\n-    let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n-\n-    // Compile the code\n-    let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n-\n-    let mut sess = session::build_session_(\n-        sessopts, None, diagnostic_handler, codemap,\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = CStore::new(trans.metadata_loader());\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n-    let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n-    let mut control = driver::CompileController::basic();\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let out = Some(outdir.lock().unwrap().path().to_path_buf());\n-\n-    if no_run {\n-        control.after_analysis.stop = Compilation::Stop;\n-    }\n-\n-    let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(\n-            trans,\n-            &sess,\n-            &cstore,\n-            &None,\n-            &input,\n-            &out,\n-            &None,\n-            None,\n-            &control\n-        )\n-    }));\n-\n-    let compile_result = match res {\n-        Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n-        Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n-    };\n-\n-    match (compile_result, compile_fail) {\n-        (Ok(()), true) => {\n-            panic!(\"test compiled while it wasn't supposed to\")\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let codemap = Lrc::new(CodeMap::new_doctest(\n+            sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n+        ));\n+        let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n+                                                        Some(codemap.clone()),\n+                                                        false,\n+                                                        false);\n+        let old = io::set_panic(Some(box Sink(data.clone())));\n+        let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n+\n+        // Compile the code\n+        let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n+\n+        let mut sess = session::build_session_(\n+            sessopts, None, diagnostic_handler, codemap,\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = CStore::new(trans.metadata_loader());\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n+        let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n+        let mut control = driver::CompileController::basic();\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let out = Some(outdir.lock().unwrap().path().to_path_buf());\n+\n+        if no_run {\n+            control.after_analysis.stop = Compilation::Stop;\n         }\n-        (Ok(()), false) => {}\n-        (Err(()), true) => {\n-            if error_codes.len() > 0 {\n-                let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n-                error_codes.retain(|err| !out.contains(err));\n+\n+        let res = panic::catch_unwind(AssertUnwindSafe(|| {\n+            driver::compile_input(\n+                trans,\n+                &sess,\n+                &cstore,\n+                &None,\n+                &input,\n+                &out,\n+                &None,\n+                None,\n+                &control\n+            )\n+        }));\n+\n+        let compile_result = match res {\n+            Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n+            Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n+        };\n+\n+        match (compile_result, compile_fail) {\n+            (Ok(()), true) => {\n+                panic!(\"test compiled while it wasn't supposed to\")\n+            }\n+            (Ok(()), false) => {}\n+            (Err(()), true) => {\n+                if error_codes.len() > 0 {\n+                    let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n+                    error_codes.retain(|err| !out.contains(err));\n+                }\n+            }\n+            (Err(()), false) => {\n+                panic!(\"couldn't compile the test\")\n             }\n         }\n-        (Err(()), false) => {\n-            panic!(\"couldn't compile the test\")\n+\n+        if error_codes.len() > 0 {\n+            panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n         }\n-    }\n \n-    if error_codes.len() > 0 {\n-        panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n-    }\n+        (libdir, outdir)\n+    });\n \n     if no_run { return }\n "}, {"sha": "90af3ba51ecadcff1a3d7fdf58c90099df2c14b4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -73,7 +73,7 @@ macro_rules! unwrap_or {\n     }\n }\n \n-struct Globals {\n+pub struct Globals {\n     used_attrs: Lock<Vec<u64>>,\n     known_attrs: Lock<Vec<u64>>,\n     syntax_pos_globals: syntax_pos::Globals,\n@@ -98,7 +98,7 @@ pub fn with_globals<F, R>(f: F) -> R\n     })\n }\n \n-scoped_thread_local!(static GLOBALS: Globals);\n+scoped_thread_local!(pub static GLOBALS: Globals);\n \n #[macro_use]\n pub mod diagnostics {"}, {"sha": "2258ed12779e4ce7792a195d9cfaa234db812bac", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -527,7 +527,7 @@ impl PartialOrd<InternedString> for InternedString {\n         if self.symbol == other.symbol {\n             return Some(Ordering::Equal);\n         }\n-        self.with(|self_str| other.with(|other_str| self_str.partial_cmp(&other_str)))\n+        self.with(|self_str| other.with(|other_str| self_str.partial_cmp(other_str)))\n     }\n }\n "}, {"sha": "c34cf1bd5ec09691c5993f0ae2facee2205c2eb0", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/844bc65333184f90670e950233513e5c7bf0572e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844bc65333184f90670e950233513e5c7bf0572e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=844bc65333184f90670e950233513e5c7bf0572e", "patch": "@@ -59,6 +59,7 @@ static WHITELIST_CRATES: &'static [CrateVersion] = &[\n static WHITELIST: &'static [Crate] = &[\n     Crate(\"aho-corasick\"),\n     Crate(\"ar\"),\n+    Crate(\"arrayvec\"),\n     Crate(\"atty\"),\n     Crate(\"backtrace\"),\n     Crate(\"backtrace-sys\"),\n@@ -67,6 +68,10 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"cc\"),\n     Crate(\"cfg-if\"),\n     Crate(\"cmake\"),\n+    Crate(\"crossbeam-deque\"),\n+    Crate(\"crossbeam-epoch\"),\n+    Crate(\"crossbeam-utils\"),\n+    Crate(\"either\"),\n     Crate(\"ena\"),\n     Crate(\"env_logger\"),\n     Crate(\"filetime\"),\n@@ -82,7 +87,9 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"log\"),\n     Crate(\"log_settings\"),\n     Crate(\"memchr\"),\n+    Crate(\"memoffset\"),\n     Crate(\"miniz-sys\"),\n+    Crate(\"nodrop\"),\n     Crate(\"num_cpus\"),\n     Crate(\"owning_ref\"),\n     Crate(\"parking_lot\"),\n@@ -95,7 +102,10 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"regex-syntax\"),\n     Crate(\"remove_dir_all\"),\n     Crate(\"rustc-demangle\"),\n+    Crate(\"rustc-rayon\"),\n+    Crate(\"rustc-rayon-core\"),\n     Crate(\"scoped-tls\"),\n+    Crate(\"scopeguard\"),\n     Crate(\"smallvec\"),\n     Crate(\"stable_deref_trait\"),\n     Crate(\"tempdir\"),"}]}