{"sha": "ae26b775b4ae4a1405effefb015ec44f0311c29f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMjZiNzc1YjRhZTRhMTQwNWVmZmVmYjAxNWVjNDRmMDMxMWMyOWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T14:46:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T15:20:46Z"}, "message": "Implement module namespaces\n\nModule names no longer clash with type and value names. The\ntokenizer/parser still needs to be taught to be more careful in\nidentifying keywords, so that we can use 'str' and 'vec' and so as\nmodule names.", "tree": {"sha": "33b7104df2b9fcebca3b74a6b319a8a695a3c907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33b7104df2b9fcebca3b74a6b319a8a695a3c907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae26b775b4ae4a1405effefb015ec44f0311c29f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae26b775b4ae4a1405effefb015ec44f0311c29f", "html_url": "https://github.com/rust-lang/rust/commit/ae26b775b4ae4a1405effefb015ec44f0311c29f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae26b775b4ae4a1405effefb015ec44f0311c29f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "html_url": "https://github.com/rust-lang/rust/commit/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9"}], "stats": {"total": 151, "additions": 78, "deletions": 73}, "files": [{"sha": "f530d3f412f2d6edbdccdef1e714f14b54e93e09", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ae26b775b4ae4a1405effefb015ec44f0311c29f", "patch": "@@ -44,7 +44,9 @@ tag scope {\n tag import_state {\n     todo(@ast::view_item, list[scope]);\n     resolving(span);\n-    resolved(option::t[def] /* value */, option::t[def] /* type */);\n+    resolved(option::t[def] /* value */,\n+             option::t[def] /* type */,\n+             option::t[def] /* module */);\n }\n \n type ext_hash = hashmap[tup(def_id,str,namespace),def];\n@@ -97,6 +99,7 @@ tag dir { inside; outside; }\n tag namespace {\n     ns_value;\n     ns_type;\n+    ns_module;\n }\n \n fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n@@ -159,7 +162,7 @@ fn resolve_imports(&env e) {\n             case (todo(?item, ?sc)) {\n                 resolve_import(e, item, sc);\n             }\n-            case (resolved(_, _)) {}\n+            case (resolved(_, _, _)) {}\n         }\n     }\n }\n@@ -324,51 +327,45 @@ fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n     if (n_idents == 1u) {\n         register(e, defid, it.span, end_id,\n                  lookup_in_scope(e, sc, it.span, end_id, ns_value),\n-                 lookup_in_scope(e, sc, it.span, end_id, ns_type));\n+                 lookup_in_scope(e, sc, it.span, end_id, ns_type),\n+                 lookup_in_scope(e, sc, it.span, end_id, ns_module));\n     } else {\n-        auto dcur = lookup_in_scope_strict(e, sc, it.span, ids.(0), ns_value);\n+        auto dcur = lookup_in_scope_strict(e, sc, it.span, ids.(0),\n+                                           ns_module);\n         auto i = 1u;\n         while (true) {\n-            if (!is_module(dcur)) {\n-                e.sess.span_err(it.span, ids.(i-1u) +\n-                                \" is not a module or crate\");\n-            }\n             if (i == n_idents - 1u) {\n                 register(e, defid, it.span, end_id,\n                          lookup_in_mod(e, dcur, end_id, ns_value, outside),\n-                         lookup_in_mod(e, dcur, end_id, ns_type, outside));\n+                         lookup_in_mod(e, dcur, end_id, ns_type, outside),\n+                         lookup_in_mod(e, dcur, end_id, ns_module, outside));\n                 break;\n             } else {\n                 dcur = lookup_in_mod_strict(e, dcur, it.span, ids.(i),\n-                                            ns_value, outside);\n+                                            ns_module, outside);\n                 i += 1u;\n             }\n         }\n     }\n \n     fn register(&env e, def_id defid, &span sp, &ident id,\n-                &option::t[def] val, &option::t[def] typ) {\n-        if (option::is_none(val) && option::is_none(typ)) {\n+                &option::t[def] val, &option::t[def] typ,\n+                &option::t[def] md) {\n+        if (option::is_none(val) && option::is_none(typ) &&\n+            option::is_none(md)) {\n             unresolved(e, sp, id, \"import\");\n         }\n-        e.imports.insert(defid._1, resolved(val, typ));\n+        e.imports.insert(defid._1, resolved(val, typ, md));\n     }\n }\n \n // Utilities\n \n-fn is_module(def d) -> bool {\n-    alt (d) {\n-        case (ast::def_mod(_)) { ret true; }\n-        case (ast::def_native_mod(_)) { ret true; }\n-        case (_) { ret false; }\n-    }\n-}\n-\n fn ns_name(namespace ns) -> str {\n     alt (ns) {\n         case (ns_type) { ret \"typename\"; }\n         case (ns_value) { ret \"name\"; }\n+        case (ns_module) { ret \"modulename\"; }\n     }\n }\n \n@@ -381,20 +378,14 @@ fn unresolved(&env e, &span sp, &ident id, &str kind) {\n fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n     auto n_idents = _vec::len(idents);\n-    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), ns);\n+    auto headns = if (n_idents == 1u) { ns } else { ns_module };\n+    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;\n     while (i < n_idents) {\n-        if (!is_module(dcur)) {\n-            e.sess.span_err(sp, idents.(i-1u) +\n-                            \" can't be dereferenced as a module\");\n-        }\n-        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), ns, outside);\n+        auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n+        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), curns, outside);\n         i += 1u;\n     }\n-    if (is_module(dcur)) {\n-        e.sess.span_err(sp, _str::connect(idents, \"::\") +\n-                        \" is a module, not a \" + ns_name(ns));\n-    }\n     ret dcur;\n }\n                       \n@@ -566,29 +557,37 @@ fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n \n fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n                 namespace ns) -> option::t[def] {\n-    if (ns == ns_value) {\n-        for (ast::arg a in decl.inputs) {\n-            if (_str::eq(a.ident, id)) {\n-                ret some(ast::def_arg(a.id));\n+    alt (ns) {\n+        case (ns_value) {\n+            for (ast::arg a in decl.inputs) {\n+                if (_str::eq(a.ident, id)) {\n+                    ret some(ast::def_arg(a.id));\n+                }\n             }\n+            ret none[def];\n         }\n-        ret none[def];\n-    } else {\n-        ret lookup_in_ty_params(id, ty_params);\n+        case (ns_type) {\n+            ret lookup_in_ty_params(id, ty_params);\n+        }\n+        case (_) { ret none[def]; }\n     }\n }\n \n fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n                  namespace ns) -> option::t[def] {\n-    if (ns == ns_value) {\n-        for (ast::obj_field f in ob.fields) {\n-            if (_str::eq(f.ident, id)) {\n-                ret some(ast::def_obj_field(f.id));\n+    alt (ns) {\n+        case (ns_value) {\n+            for (ast::obj_field f in ob.fields) {\n+                if (_str::eq(f.ident, id)) {\n+                    ret some(ast::def_obj_field(f.id));\n+                }\n             }\n+            ret none[def];\n         }\n-        ret none[def];\n-    } else {\n-        ret lookup_in_ty_params(id, ty_params);\n+        case (ns_type) {\n+            ret lookup_in_ty_params(id, ty_params);\n+        }\n+        case (_) { ret none[def]; }\n     }\n }\n \n@@ -611,7 +610,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n                                     if (_str::eq(name, id)) {\n                                         ret some(ast::def_ty(defid));\n                                     }\n-                                } else {\n+                                } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n                                         if (_str::eq(v.node.name, id)) {\n                                             ret some(ast::def_variant(\n@@ -623,7 +622,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n                             case (_) {\n                                 if (_str::eq(ast::item_ident(it), id)) {\n                                     auto found = found_def_item(it, ns);\n-                                    if (!option::is_none(found)) { ret found; }\n+                                    if (!option::is_none(found)) {ret found;}\n                                 }\n                             }\n                         }\n@@ -645,10 +644,10 @@ fn found_def_item(@ast::item i, namespace ns) -> option::t[def] {\n             if (ns == ns_value) { ret some(ast::def_fn(defid)); }\n         }\n         case (ast::item_mod(_, _, ?defid)) {\n-            ret some(ast::def_mod(defid));\n+            if (ns == ns_module) { ret some(ast::def_mod(defid)); }\n         }\n         case (ast::item_native_mod(_, _, ?defid)) {\n-            ret some(ast::def_native_mod(defid));\n+            if (ns == ns_module) { ret some(ast::def_native_mod(defid)); }\n         }\n         case (ast::item_ty(_, _, _, ?defid, _)) {\n             if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n@@ -657,8 +656,11 @@ fn found_def_item(@ast::item i, namespace ns) -> option::t[def] {\n             if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n         }\n         case (ast::item_obj(_, _, _, ?odid, _)) {\n-            if (ns == ns_value) { ret some(ast::def_obj(odid.ctor)); }\n-            else { ret some(ast::def_obj(odid.ty)); }\n+            alt (ns) {\n+                case (ns_value) { ret some(ast::def_obj(odid.ctor)); }\n+                case (ns_type) { ret some(ast::def_obj(odid.ty)); }\n+                case (_) { }\n+            }\n         }\n         case (_) { }\n     }\n@@ -725,9 +727,10 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n         case (resolving(?sp)) {\n             e.sess.span_err(sp, \"cyclic import\");\n         }\n-        case (resolved(?val, ?typ)) {\n+        case (resolved(?val, ?typ, ?md)) {\n             ret alt (ns) { case (ns_value) { val }\n-                           case (ns_type) { typ } };\n+                           case (ns_type) { typ }\n+                           case (ns_module) { md } };\n         }\n     }\n }\n@@ -917,31 +920,30 @@ fn index_nmod(&ast::native_mod md) -> nmod_index {\n \n // External lookups\n \n-// FIXME creader should handle multiple namespaces\n-fn check_def_by_ns(def d, namespace ns) -> bool {\n+fn ns_for_def(def d) -> namespace {\n     ret alt (d) {\n-        case (ast::def_fn(?id)) { ns == ns_value }\n-        case (ast::def_obj(?id)) { ns == ns_value }\n-        case (ast::def_obj_field(?id)) { ns == ns_value }\n-        case (ast::def_mod(?id)) { true }\n-        case (ast::def_native_mod(?id)) { true }\n-        case (ast::def_const(?id)) { ns == ns_value }\n-        case (ast::def_arg(?id)) { ns == ns_value }\n-        case (ast::def_local(?id)) { ns == ns_value }\n-        case (ast::def_variant(_, ?id)) { ns == ns_value }\n-        case (ast::def_ty(?id)) { ns == ns_type }\n-        case (ast::def_binding(?id)) { ns == ns_type }\n-        case (ast::def_use(?id)) { true }\n-        case (ast::def_native_ty(?id)) { ns == ns_type }\n-        case (ast::def_native_fn(?id)) { ns == ns_value }\n+        case (ast::def_fn(?id)) { ns_value }\n+        case (ast::def_obj(?id)) { ns_value }\n+        case (ast::def_obj_field(?id)) { ns_value }\n+        case (ast::def_mod(?id)) { ns_module }\n+        case (ast::def_native_mod(?id)) { ns_module }\n+        case (ast::def_const(?id)) { ns_value }\n+        case (ast::def_arg(?id)) { ns_value }\n+        case (ast::def_local(?id)) { ns_value }\n+        case (ast::def_variant(_, ?id)) { ns_value }\n+        case (ast::def_ty(?id)) { ns_type }\n+        case (ast::def_binding(?id)) { ns_type }\n+        case (ast::def_use(?id)) { ns_module }\n+        case (ast::def_native_ty(?id)) { ns_type }\n+        case (ast::def_native_fn(?id)) { ns_value }\n     };\n }\n \n fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n     -> option::t[def] {\n     for (def d in creader::lookup_defs(e.sess, cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n-        if (check_def_by_ns(d, ns)) { ret some(d); }\n+        if (ns == ns_for_def(d)) { ret some(d); }\n     }\n     ret none[def];\n }"}, {"sha": "1ace62956270f8d01c9df0d7d53bae44b41ac842", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=ae26b775b4ae4a1405effefb015ec44f0311c29f", "patch": "@@ -1,4 +1,6 @@\n-// error-pattern: is a module, not a\n+// xfail-boot\n+// xfail-stage0\n+// error-pattern: unresolved name: a\n \n mod m1 {\n   mod a {"}, {"sha": "ef3a79d161b9402c387893793d05c8693abf033a", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=ae26b775b4ae4a1405effefb015ec44f0311c29f", "patch": "@@ -1,5 +1,5 @@\n // xfail-boot\n-// error-pattern: unresolved name\n+// error-pattern: unresolved modulename\n import baz::zed::bar;\n mod baz {\n }"}, {"sha": "95f108458fd5ca8879af5f81183d7e12a4c59bef", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae26b775b4ae4a1405effefb015ec44f0311c29f/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=ae26b775b4ae4a1405effefb015ec44f0311c29f", "patch": "@@ -1,5 +1,6 @@\n // xfail-boot\n-// error-pattern: main is not a module or crate\n+// xfail-stage0\n+// error-pattern: unresolved modulename\n import main::bar;\n \n fn main(vec[str] args) {"}]}