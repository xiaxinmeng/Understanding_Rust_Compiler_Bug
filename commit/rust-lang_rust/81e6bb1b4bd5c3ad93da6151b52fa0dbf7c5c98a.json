{"sha": "81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZTZiYjFiNGJkNWMzYWQ5M2RhNjE1MWI1MmZhMGRiZjdjNWM5OGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T18:07:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T18:08:15Z"}, "message": "libsyntax: First steps toward parsing \"extern mod std;\"", "tree": {"sha": "a4d22c0bcf5e0d358712a5ef9875cbcdb5532819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4d22c0bcf5e0d358712a5ef9875cbcdb5532819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a", "html_url": "https://github.com/rust-lang/rust/commit/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbbe9ac94b623fc95848f2405f938d0dde1f8473", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbe9ac94b623fc95848f2405f938d0dde1f8473", "html_url": "https://github.com/rust-lang/rust/commit/fbbe9ac94b623fc95848f2405f938d0dde1f8473"}], "stats": {"total": 59, "additions": 37, "deletions": 22}, "files": [{"sha": "2a23ace632c4aaa7b71bb97272b26303b97d682f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=81e6bb1b4bd5c3ad93da6151b52fa0dbf7c5c98a", "patch": "@@ -157,6 +157,14 @@ macro_rules! maybe_whole {\n }\n \n \n+pure fn maybe_append(+lhs: ~[attribute], rhs: option<~[attribute]>)\n+                  -> ~[attribute] {\n+    match rhs {\n+        none => lhs,\n+        some(attrs) => vec::append(lhs, attrs)\n+    }\n+}\n+\n \n /* ident is handled by common.rs */\n \n@@ -2803,18 +2811,37 @@ class parser {\n              items: items};\n     }\n \n-    fn parse_item_foreign_mod() -> item_info {\n+    fn parse_item_foreign_mod(lo: uint,\n+                              visibility: visibility,\n+                              attrs: ~[attribute])\n+                           -> item_or_view_item {\n         if self.is_keyword(~\"mod\") {\n             self.expect_keyword(~\"mod\");\n         } else {\n             self.expect_keyword(~\"module\");\n         }\n-        let id = self.parse_ident();\n-        self.expect(token::LBRACE);\n-        let more_attrs = self.parse_inner_attrs_and_next();\n-        let m = self.parse_foreign_mod_items(more_attrs.next);\n-        self.expect(token::RBRACE);\n-        (id, item_foreign_mod(m), some(more_attrs.inner))\n+        let ident = self.parse_ident();\n+\n+        // extern mod { ... }\n+        if self.eat(token::LBRACE) {\n+            let extra_attrs = self.parse_inner_attrs_and_next();\n+            let m = self.parse_foreign_mod_items(extra_attrs.next);\n+            self.expect(token::RBRACE);\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n+                                          item_foreign_mod(m), visibility,\n+                                          maybe_append(attrs,\n+                                                       some(extra_attrs.\n+                                                            inner))));\n+        }\n+\n+        // extern mod foo;\n+        let metadata = self.parse_optional_meta();\n+        return iovi_view_item(@{\n+            node: view_item_use(ident, metadata, self.get_id()),\n+            attrs: attrs,\n+            vis: visibility,\n+            span: mk_sp(lo, self.last_span.hi)\n+        });\n     }\n \n     fn parse_type_decl() -> {lo: uint, ident: ident} {\n@@ -3019,14 +3046,6 @@ class parser {\n             visibility = inherited;\n         }\n \n-        pure fn maybe_append(+lhs: ~[attribute], rhs: option<~[attribute]>)\n-                          -> ~[attribute] {\n-            match rhs {\n-                none => lhs,\n-                some(attrs) => vec::append(lhs, attrs)\n-            }\n-        }\n-\n         if self.eat_keyword(~\"const\") {\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -3063,10 +3082,7 @@ class parser {\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n-            let (ident, item_, extra_attrs) = self.parse_item_foreign_mod();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            return self.parse_item_foreign_mod(lo, visibility, attrs);\n         } else if self.eat_keyword(~\"mod\") || self.eat_keyword(~\"module\") {\n             let (ident, item_, extra_attrs) = self.parse_item_mod();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -3104,9 +3120,8 @@ class parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if !self.is_any_keyword(copy self.token)\n-            && self.look_ahead(1) == token::NOT\n-            && is_plain_ident(self.look_ahead(2))\n-        {\n+                && self.look_ahead(1) == token::NOT\n+                && is_plain_ident(self.look_ahead(2)) {\n             // item macro.\n             let pth = self.parse_path_without_tps();\n             self.expect(token::NOT);"}]}