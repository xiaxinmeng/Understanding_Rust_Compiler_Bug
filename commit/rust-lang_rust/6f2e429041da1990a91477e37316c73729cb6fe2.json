{"sha": "6f2e429041da1990a91477e37316c73729cb6fe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMmU0MjkwNDFkYTE5OTBhOTE0NzdlMzczMTZjNzM3MjljYjZmZTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-29T22:23:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-02T23:00:10Z"}, "message": "libstd: De-mut arena", "tree": {"sha": "3d60bdcd5c7b17586cbbf62a51551eae4806d745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d60bdcd5c7b17586cbbf62a51551eae4806d745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f2e429041da1990a91477e37316c73729cb6fe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2e429041da1990a91477e37316c73729cb6fe2", "html_url": "https://github.com/rust-lang/rust/commit/6f2e429041da1990a91477e37316c73729cb6fe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f2e429041da1990a91477e37316c73729cb6fe2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba842518a2f0834fdc141138a7e73f86e2387f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba842518a2f0834fdc141138a7e73f86e2387f42", "html_url": "https://github.com/rust-lang/rust/commit/ba842518a2f0834fdc141138a7e73f86e2387f42"}], "stats": {"total": 140, "additions": 89, "deletions": 51}, "files": [{"sha": "bea7935d5c3a4bc521a6b3ebfaf7427e75aa9cbf", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6f2e429041da1990a91477e37316c73729cb6fe2/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2e429041da1990a91477e37316c73729cb6fe2/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=6f2e429041da1990a91477e37316c73729cb6fe2", "patch": "@@ -32,11 +32,11 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n+use list::{MutList, MutCons, MutNil};\n use list;\n-use list::{List, Cons, Nil};\n \n use core::at_vec;\n-use core::cast::transmute;\n+use core::cast::{transmute, transmute_mut_region};\n use core::cast;\n use core::libc::size_t;\n use core::ptr;\n@@ -74,26 +74,28 @@ static tydesc_drop_glue_index: size_t = 3 as size_t;\n // will always stay at 0.\n struct Chunk {\n     data: @[u8],\n-    mut fill: uint,\n+    fill: uint,\n     is_pod: bool,\n }\n \n pub struct Arena {\n     // The head is seperated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n-    priv mut head: Chunk,\n-    priv mut pod_head: Chunk,\n-    priv mut chunks: @List<Chunk>,\n+    priv head: Chunk,\n+    priv pod_head: Chunk,\n+    priv chunks: @mut MutList<Chunk>,\n }\n \n #[unsafe_destructor]\n impl Drop for Arena {\n     fn finalize(&self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            for list::each(self.chunks) |chunk| {\n-                if !chunk.is_pod { destroy_chunk(chunk); }\n+            for self.chunks.each |chunk| {\n+                if !chunk.is_pod {\n+                    destroy_chunk(chunk);\n+                }\n             }\n         }\n     }\n@@ -113,7 +115,7 @@ pub fn arena_with_size(initial_size: uint) -> Arena {\n     Arena {\n         head: chunk(initial_size, false),\n         pod_head: chunk(initial_size, true),\n-        chunks: @Nil,\n+        chunks: @mut MutNil,\n     }\n }\n \n@@ -170,39 +172,40 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n \n pub impl Arena {\n     // Functions for the POD part of the arena\n-    priv fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.pod_head, self.chunks);\n+        self.chunks = @mut MutCons(copy self.pod_head, self.chunks);\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n         return self.alloc_pod_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n-        let head = &mut self.pod_head;\n+    priv fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+        unsafe {\n+            // XXX: Borrow check\n+            let head = transmute_mut_region(&mut self.pod_head);\n \n-        let start = round_up_to(head.fill, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_pod_grow(n_bytes, align);\n-        }\n-        head.fill = end;\n+            let start = round_up_to(head.fill, align);\n+            let end = start + n_bytes;\n+            if end > at_vec::capacity(head.data) {\n+                return self.alloc_pod_grow(n_bytes, align);\n+            }\n+            head.fill = end;\n \n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n+            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //       start, n_bytes, align, head.fill);\n \n-        unsafe {\n             ptr::offset(vec::raw::to_ptr(head.data), start)\n         }\n     }\n \n     #[inline(always)]\n     #[cfg(stage0)]\n-    priv fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n+    priv fn alloc_pod<T>(&mut self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -216,7 +219,7 @@ pub impl Arena {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    priv fn alloc_pod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    priv fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -227,42 +230,44 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    priv fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n+                             -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.head, self.chunks);\n+        self.chunks = @mut MutCons(copy self.head, self.chunks);\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n         return self.alloc_nonpod_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n-        let head = &mut self.head;\n-\n-        let tydesc_start = head.fill;\n-        let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n-        let start = round_up_to(after_tydesc, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_nonpod_grow(n_bytes, align);\n-        }\n-        head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+    priv fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n+                               -> (*u8, *u8) {\n+        unsafe {\n+            let head = transmute_mut_region(&mut self.head);\n+\n+            let tydesc_start = head.fill;\n+            let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n+            let start = round_up_to(after_tydesc, align);\n+            let end = start + n_bytes;\n+            if end > at_vec::capacity(head.data) {\n+                return self.alloc_nonpod_grow(n_bytes, align);\n+            }\n+            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n \n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n+            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //       start, n_bytes, align, head.fill);\n \n-        unsafe {\n             let buf = vec::raw::to_ptr(head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }\n \n     #[inline(always)]\n     #[cfg(stage0)]\n-    priv fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n+    priv fn alloc_nonpod<T>(&mut self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -286,7 +291,7 @@ pub impl Arena {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    priv fn alloc_nonpod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    priv fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -309,13 +314,16 @@ pub impl Arena {\n     // The external interface\n     #[inline(always)]\n     #[cfg(stage0)]\n-    fn alloc<T>(&self, op: &fn() -> T) -> &'self T {\n+    fn alloc<T>(&mut self, op: &fn() -> T) -> &'self T {\n         unsafe {\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n             if !rusti::needs_drop::<T>() {\n-                self.alloc_pod(op)\n-            } else {\n-                self.alloc_nonpod(op)\n+                return this.alloc_pod(op);\n             }\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n+            this.alloc_nonpod(op)\n         }\n     }\n \n@@ -324,13 +332,16 @@ pub impl Arena {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n             if !rusti::needs_drop::<T>() {\n-                self.alloc_pod(op)\n-            } else {\n-                self.alloc_nonpod(op)\n+                return this.alloc_pod(op);\n             }\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n+            this.alloc_nonpod(op)\n         }\n     }\n }\n@@ -348,7 +359,9 @@ fn test_arena_destructors() {\n     }\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n     let arena = Arena();\n     // Put some stuff in the arena."}, {"sha": "8d15508b26e05d53380af17369b470a329dd1406", "filename": "src/libstd/list.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f2e429041da1990a91477e37316c73729cb6fe2/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2e429041da1990a91477e37316c73729cb6fe2/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=6f2e429041da1990a91477e37316c73729cb6fe2", "patch": "@@ -16,6 +16,12 @@ pub enum List<T> {\n     Nil,\n }\n \n+#[deriving(Eq)]\n+pub enum MutList<T> {\n+    MutCons(T, @mut MutList<T>),\n+    MutNil,\n+}\n+\n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n@@ -147,6 +153,25 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     }\n }\n \n+impl<T> MutList<T> {\n+    /// Iterate over a mutable list\n+    pub fn each(@mut self, f: &fn(&mut T) -> bool) {\n+        let mut cur = self;\n+        loop {\n+            let borrowed = &mut *cur;\n+            cur = match *borrowed {\n+                MutCons(ref mut hd, tl) => {\n+                    if !f(hd) {\n+                        return;\n+                    }\n+                    tl\n+                }\n+                MutNil => break\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use list::*;"}]}