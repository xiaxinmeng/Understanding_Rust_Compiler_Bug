{"sha": "78be1aa2264470f7b5043fbf13e8c6551b806a7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YmUxYWEyMjY0NDcwZjdiNTA0M2ZiZjEzZThjNjU1MWI4MDZhN2E=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-02-05T23:14:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-05T23:14:11Z"}, "message": "Rollup merge of #81610 - ssomers:btree_emphasize_ord_bound, r=dtolnay\n\nBTreeMap: make Ord bound explicit, compile-test its absence\n\nMost `BTreeMap` and `BTreeSet` members are subject to an `Ord` bound but a fair number of methods are not. To better convey and perhaps later tune the `Ord` bound, make it stand out in individual `where` clauses, instead of once far away at the beginning of an `impl` block. This PR does not introduce or remove any bounds.\n\nAlso adds compilation test cases checking that the bound doesn't creep in unintended on the historically unbounded methods.", "tree": {"sha": "473f9af47ca43083c774d1789b5fadcd4cacc307", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473f9af47ca43083c774d1789b5fadcd4cacc307"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78be1aa2264470f7b5043fbf13e8c6551b806a7a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgHdFDCRBK7hj4Ov3rIwAAdHIIAEPRcpWsbZFFbFCmK1OiuAga\neS0Ks+y2fEXloieIDWeUIVARd6DGVJNDQscAPCvWJTTsV5XhPZSv3mf0Ug/9wqPt\nj48LPoBmE7ZllSS4Q/7BQH5bU2t08JnbErXhMzjjy2+lkEeAdo1nQbE1v1s2NAqY\nt4OKSglIHXqNggF4Zjx42UnRthokX50IN/mckpmcCiWvoMzEj0sPcmqbac26f7BN\nLQfqyDpD7EdXJ9m8KxbL800jzRDrHKbS6k4jyB6aoji2k2UTSmpx4TOVkZV1jm6E\ngiZzwGGMsJkvDDCs07It4w7MMlCpoaUjGqJEZSe3TUByKC0Zf2rGa59bSyEJx4U=\n=hBwP\n-----END PGP SIGNATURE-----\n", "payload": "tree 473f9af47ca43083c774d1789b5fadcd4cacc307\nparent 43b3adb4e2f6f4da7e1bf20648533fc634395468\nparent 1020784040894716670b2d187ad90f145f856900\nauthor Mara Bos <m-ou.se@m-ou.se> 1612566851 +0100\ncommitter GitHub <noreply@github.com> 1612566851 +0100\n\nRollup merge of #81610 - ssomers:btree_emphasize_ord_bound, r=dtolnay\n\nBTreeMap: make Ord bound explicit, compile-test its absence\n\nMost `BTreeMap` and `BTreeSet` members are subject to an `Ord` bound but a fair number of methods are not. To better convey and perhaps later tune the `Ord` bound, make it stand out in individual `where` clauses, instead of once far away at the beginning of an `impl` block. This PR does not introduce or remove any bounds.\n\nAlso adds compilation test cases checking that the bound doesn't creep in unintended on the historically unbounded methods.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78be1aa2264470f7b5043fbf13e8c6551b806a7a", "html_url": "https://github.com/rust-lang/rust/commit/78be1aa2264470f7b5043fbf13e8c6551b806a7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78be1aa2264470f7b5043fbf13e8c6551b806a7a/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b3adb4e2f6f4da7e1bf20648533fc634395468", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b3adb4e2f6f4da7e1bf20648533fc634395468", "html_url": "https://github.com/rust-lang/rust/commit/43b3adb4e2f6f4da7e1bf20648533fc634395468"}, {"sha": "1020784040894716670b2d187ad90f145f856900", "url": "https://api.github.com/repos/rust-lang/rust/commits/1020784040894716670b2d187ad90f145f856900", "html_url": "https://github.com/rust-lang/rust/commit/1020784040894716670b2d187ad90f145f856900"}], "stats": {"total": 245, "additions": 191, "deletions": 54}, "files": [{"sha": "946267d17c0188733631f3bcd72f6c13b09a3746", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=78be1aa2264470f7b5043fbf13e8c6551b806a7a", "patch": "@@ -460,7 +460,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-impl<K: Ord, V> BTreeMap<K, V> {\n+impl<K, V> BTreeMap<K, V> {\n     /// Makes a new, empty `BTreeMap`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -479,7 +479,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeMap<K, V> {\n+    pub const fn new() -> BTreeMap<K, V>\n+    where\n+        K: Ord,\n+    {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -498,7 +501,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        K: Ord,\n+    {\n         *self = BTreeMap::new();\n     }\n \n@@ -522,7 +528,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -550,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -578,7 +584,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n@@ -604,7 +613,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n@@ -631,7 +643,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+    pub fn pop_first(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -652,7 +667,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n@@ -678,7 +696,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n@@ -705,7 +726,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+    pub fn pop_last(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -729,7 +753,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.get(key).is_some()\n@@ -758,7 +782,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_mut()?.borrow_mut();\n@@ -795,7 +819,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V>\n+    where\n+        K: Ord,\n+    {\n         match self.entry(key) {\n             Occupied(mut entry) => Some(entry.insert(value)),\n             Vacant(entry) => {\n@@ -827,7 +854,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.remove_entry(key).map(|(_, v)| v)\n@@ -854,7 +881,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n@@ -886,6 +913,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         self.drain_filter(|k, v| !f(k, v));\n@@ -920,7 +948,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(a[&5], \"f\");\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        K: Ord,\n+    {\n         // Do we have to append anything at all?\n         if other.is_empty() {\n             return;\n@@ -971,7 +1002,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n@@ -1017,7 +1048,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n@@ -1048,7 +1079,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n@@ -1092,7 +1126,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n     {\n         if self.is_empty() {\n             return Self::new();\n@@ -1150,12 +1184,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n             let front = root.borrow_mut().first_leaf_edge();\n@@ -1188,7 +1226,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_keys(self) -> IntoKeys<K, V> {\n+    pub fn into_keys(self) -> IntoKeys<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoKeys { inner: self.into_iter() }\n     }\n \n@@ -1211,7 +1252,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_values(self) -> IntoValues<K, V> {\n+    pub fn into_values(self) -> IntoValues<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoValues { inner: self.into_iter() }\n     }\n }\n@@ -1968,9 +2012,9 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n+impl<K, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n where\n-    K: Borrow<Q>,\n+    K: Borrow<Q> + Ord,\n     Q: Ord,\n {\n     type Output = V;"}, {"sha": "78edf11d3934b667af86fcd9338bf369a6120297", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=78be1aa2264470f7b5043fbf13e8c6551b806a7a", "patch": "@@ -1706,6 +1706,34 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn map<K>(mut map: BTreeMap<K, ()>) {\n+        map.is_empty();\n+        map.len();\n+        map.iter();\n+        map.iter_mut();\n+        map.keys();\n+        map.values();\n+        map.values_mut();\n+        map.into_iter();\n+    }\n+\n+    fn map_debug<K: Debug>(mut map: BTreeMap<K, ()>) {\n+        format!(\"{:?}\", map);\n+        format!(\"{:?}\", map.iter());\n+        format!(\"{:?}\", map.iter_mut());\n+        format!(\"{:?}\", map.keys());\n+        format!(\"{:?}\", map.values());\n+        format!(\"{:?}\", map.values_mut());\n+        format!(\"{:?}\", map.into_iter());\n+    }\n+\n+    fn map_clone<K: Clone>(mut map: BTreeMap<K, ()>) {\n+        map.clone_from(&map.clone());\n+    }\n+}\n+\n #[allow(dead_code)]\n fn test_const() {\n     const MAP: &'static BTreeMap<(), ()> = &BTreeMap::new();"}, {"sha": "be4e50119c0d1bba2d40e90ded0a2709e0d9f596", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=78be1aa2264470f7b5043fbf13e8c6551b806a7a", "patch": "@@ -222,7 +222,7 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n // and it's a power of two to make that division cheap.\n const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n \n-impl<T: Ord> BTreeSet<T> {\n+impl<T> BTreeSet<T> {\n     /// Makes a new, empty `BTreeSet`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -237,7 +237,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeSet<T> {\n+    pub const fn new() -> BTreeSet<T>\n+    where\n+        T: Ord,\n+    {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -267,7 +270,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n     where\n         K: Ord,\n-        T: Borrow<K>,\n+        T: Borrow<K> + Ord,\n         R: RangeBounds<K>,\n     {\n         Range { iter: self.map.range(range) }\n@@ -294,7 +297,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -352,10 +358,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(\n-        &'a self,\n-        other: &'a BTreeSet<T>,\n-    ) -> SymmetricDifference<'a, T> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>) -> SymmetricDifference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -380,7 +386,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -428,7 +437,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T>\n+    where\n+        T: Ord,\n+    {\n         Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -445,7 +457,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        T: Ord,\n+    {\n         self.map.clear()\n     }\n \n@@ -467,7 +482,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.contains_key(value)\n@@ -491,7 +506,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::get(&self.map, value)\n@@ -515,7 +530,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.intersection(other).next().is_none()\n     }\n \n@@ -537,7 +555,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         // Same result as self.difference(other).next().is_none()\n         // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n@@ -613,7 +634,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         other.is_subset(self)\n     }\n \n@@ -636,7 +660,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.first(), Some(&1));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first(&self) -> Option<&T> {\n+    pub fn first(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.first_key_value().map(|(k, _)| k)\n     }\n \n@@ -659,7 +686,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.last(), Some(&2));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last(&self) -> Option<&T> {\n+    pub fn last(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.last_key_value().map(|(k, _)| k)\n     }\n \n@@ -681,7 +711,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<T> {\n+    pub fn pop_first(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_first().map(|kv| kv.0)\n     }\n \n@@ -703,7 +736,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<T> {\n+    pub fn pop_last(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_last().map(|kv| kv.0)\n     }\n \n@@ -728,7 +764,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool {\n+    pub fn insert(&mut self, value: T) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.map.insert(value, ()).is_none()\n     }\n \n@@ -748,7 +787,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n     /// ```\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n-    pub fn replace(&mut self, value: T) -> Option<T> {\n+    pub fn replace(&mut self, value: T) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         Recover::replace(&mut self.map, value)\n     }\n \n@@ -774,7 +816,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.remove(value).is_some()\n@@ -798,7 +840,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::take(&mut self.map, value)\n@@ -823,6 +865,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        T: Ord,\n         F: FnMut(&T) -> bool,\n     {\n         self.drain_filter(|v| !f(v));\n@@ -857,7 +900,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(a.contains(&5));\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        T: Ord,\n+    {\n         self.map.append(&mut other.map);\n     }\n \n@@ -893,7 +939,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n@@ -928,13 +974,12 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n     where\n+        T: Ord,\n         F: 'a + FnMut(&T) -> bool,\n     {\n         DrainFilter { pred, inner: self.map.drain_filter_inner() }\n     }\n-}\n \n-impl<T> BTreeSet<T> {\n     /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n     ///\n     /// # Examples"}, {"sha": "79e469eb0db8b6e0878a261aa8dde2affba458c1", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78be1aa2264470f7b5043fbf13e8c6551b806a7a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=78be1aa2264470f7b5043fbf13e8c6551b806a7a", "patch": "@@ -639,6 +639,26 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn set<K>(set: BTreeSet<K>) {\n+        set.is_empty();\n+        set.len();\n+        set.iter();\n+        set.into_iter();\n+    }\n+\n+    fn set_debug<K: Debug>(set: BTreeSet<K>) {\n+        format!(\"{:?}\", set);\n+        format!(\"{:?}\", set.iter());\n+        format!(\"{:?}\", set.into_iter());\n+    }\n+\n+    fn set_clone<K: Clone>(mut set: BTreeSet<K>) {\n+        set.clone_from(&set.clone());\n+    }\n+}\n+\n #[test]\n fn test_append() {\n     let mut a = BTreeSet::new();"}]}