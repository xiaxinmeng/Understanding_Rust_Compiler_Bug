{"sha": "eb70c82d297c010123e88986f176eb827f8a3b7c", "node_id": "C_kwDOAAsO6NoAKGViNzBjODJkMjk3YzAxMDEyM2U4ODk4NmYxNzZlYjgyN2Y4YTNiN2M", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-12-08T18:31:01Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-02-01T00:08:59Z"}, "message": "BTreeMap: Change internal insert function to return a handle\n\nThis is a prerequisite for cursor support for `BTreeMap`.", "tree": {"sha": "5828be551ed3332a31603cfad972fd1c194ba27e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5828be551ed3332a31603cfad972fd1c194ba27e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb70c82d297c010123e88986f176eb827f8a3b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb70c82d297c010123e88986f176eb827f8a3b7c", "html_url": "https://github.com/rust-lang/rust/commit/eb70c82d297c010123e88986f176eb827f8a3b7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb70c82d297c010123e88986f176eb827f8a3b7c/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a322848c6b0e037c1f0209387558ecb6ab763714", "url": "https://api.github.com/repos/rust-lang/rust/commits/a322848c6b0e037c1f0209387558ecb6ab763714", "html_url": "https://github.com/rust-lang/rust/commit/a322848c6b0e037c1f0209387558ecb6ab763714"}], "stats": {"total": 156, "additions": 119, "deletions": 37}, "files": [{"sha": "000b9bd0fab42408a790d5b811c06f94385eba8a", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=eb70c82d297c010123e88986f176eb827f8a3b7c", "patch": "@@ -41,6 +41,28 @@ impl<'a, T> DormantMutRef<'a, T> {\n         // SAFETY: our own safety conditions imply this reference is again unique.\n         unsafe { &mut *self.ptr.as_ptr() }\n     }\n+\n+    /// Borrows a new mutable reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow(&mut self) -> &'a mut T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &mut *self.ptr.as_ptr() }\n+    }\n+\n+    /// Borrows a new shared reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow_shared(&self) -> &'a T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &*self.ptr.as_ptr() }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e9366eec9cec3028a05635b62672beed4602f5d3", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=eb70c82d297c010123e88986f176eb827f8a3b7c", "patch": "@@ -347,7 +347,7 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n     /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n+    pub fn insert(mut self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle {\n             None => {\n                 // SAFETY: There is no tree yet so no reference to it exists.\n@@ -358,25 +358,27 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n                 map.length = 1;\n                 val_ptr\n             }\n-            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc.clone()) {\n-                (None, val_ptr) => {\n-                    // SAFETY: We have consumed self.handle.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-                (Some(ins), val_ptr) => {\n-                    drop(ins.left);\n-                    // SAFETY: We have consumed self.handle and dropped the\n-                    // remaining reference to the tree, ins.left.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    let root = map.root.as_mut().unwrap(); // same as ins.left\n-                    root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right);\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-            },\n+            Some(handle) => {\n+                let new_handle =\n+                    handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {\n+                        drop(ins.left);\n+                        // SAFETY: Pushing a new root node doesn't invalidate\n+                        // handles to existing nodes.\n+                        let map = unsafe { self.dormant_map.reborrow() };\n+                        let root = map.root.as_mut().unwrap(); // same as ins.left\n+                        root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right)\n+                    });\n+\n+                // Get the pointer to the value\n+                let val_ptr = new_handle.into_val_mut();\n+\n+                // SAFETY: We have consumed self.handle.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n         };\n+\n         // Now that we have finished growing the tree using borrowed references,\n         // dereference the pointer to a part of it, that we picked up along the way.\n         unsafe { &mut *out_ptr }"}, {"sha": "76b304e756faf6d76f82a2a14165c10721f5fb53", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 76, "deletions": 18, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb70c82d297c010123e88986f176eb827f8a3b7c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=eb70c82d297c010123e88986f176eb827f8a3b7c", "patch": "@@ -442,6 +442,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n+\n+    /// Returns a dormant copy of this node with its lifetime erased which can\n+    /// be reawakened later.\n+    pub fn dormant(&self) -> NodeRef<marker::DormantMut, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, Type> NodeRef<marker::DormantMut, K, V, Type> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> NodeRef<marker::Mut<'a>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n }\n \n impl<K, V, Type> NodeRef<marker::Dying, K, V, Type> {\n@@ -798,6 +816,25 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n         Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n+\n+    /// Returns a dormant copy of this handle which can be reawakened later.\n+    ///\n+    /// See [`DormantMutRef`] for more details.\n+    pub fn dormant(&self) -> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+        Handle { node: self.node.dormant(), idx: self.idx, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, NodeType, HandleType> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n+        Handle { node: unsafe { self.node.awaken() }, idx: self.idx, _marker: PhantomData }\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n@@ -851,9 +888,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+    unsafe fn insert_fit(\n+        mut self,\n+        key: K,\n+        val: V,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n         debug_assert!(self.node.len() < CAPACITY);\n         let new_len = self.node.len() + 1;\n \n@@ -862,7 +901,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n             *self.node.len_mut() = new_len as u16;\n \n-            self.node.val_area_mut(self.idx).assume_init_mut()\n+            Handle::new_kv(self.node, self.idx)\n         }\n     }\n }\n@@ -871,30 +910,37 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n-    /// The returned pointer points to the inserted value.\n+    /// Returns a dormant handle to the inserted node which can be reawakened\n+    /// once splitting is complete.\n     fn insert<A: Allocator + Clone>(\n-        mut self,\n+        self,\n         key: K,\n         val: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n+    ) -> (\n+        Option<SplitResult<'a, K, V, marker::Leaf>>,\n+        Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,\n+    ) {\n         if self.node.len() < CAPACITY {\n-            let val_ptr = self.insert_fit(key, val);\n-            (None, val_ptr)\n+            // SAFETY: There is enough space in the node for insertion.\n+            let handle = unsafe { self.insert_fit(key, val) };\n+            (None, handle.dormant())\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let mut result = middle.split(alloc);\n-            let mut insertion_edge = match insertion {\n+            let insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                 },\n                 LeftOrRight::Right(insert_idx) => unsafe {\n                     Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                 },\n             };\n-            let val_ptr = insertion_edge.insert_fit(key, val);\n-            (Some(result), val_ptr)\n+            // SAFETY: We just split the node, so there is enough space for\n+            // insertion.\n+            let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };\n+            (Some(result), handle)\n         }\n     }\n }\n@@ -976,21 +1022,31 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         key: K,\n         value: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::LeafOrInternal>>, *mut V) {\n-        let (mut split, val_ptr) = match self.insert(key, value, alloc.clone()) {\n-            (None, val_ptr) => return (None, val_ptr),\n-            (Some(split), val_ptr) => (split.forget_node_type(), val_ptr),\n+        split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+        let (mut split, handle) = match self.insert(key, value, alloc.clone()) {\n+            // SAFETY: we have finished splitting and can now re-awaken the\n+            // handle to the inserted element.\n+            (None, handle) => return unsafe { handle.awaken() },\n+            (Some(split), handle) => (split.forget_node_type(), handle),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n                 Ok(parent) => {\n                     match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {\n-                        None => return (None, val_ptr),\n+                        // SAFETY: we have finished splitting and can now re-awaken the\n+                        // handle to the inserted element.\n+                        None => return unsafe { handle.awaken() },\n                         Some(split) => split.forget_node_type(),\n                     }\n                 }\n-                Err(root) => return (Some(SplitResult { left: root, ..split }), val_ptr),\n+                Err(root) => {\n+                    split_root(SplitResult { left: root, ..split });\n+                    // SAFETY: we have finished splitting and can now re-awaken the\n+                    // handle to the inserted element.\n+                    return unsafe { handle.awaken() };\n+                }\n             };\n         }\n     }\n@@ -1667,6 +1723,7 @@ pub mod marker {\n \n     pub enum Owned {}\n     pub enum Dying {}\n+    pub enum DormantMut {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n     pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n@@ -1688,6 +1745,7 @@ pub mod marker {\n     impl<'a> BorrowType for Immut<'a> {}\n     impl<'a> BorrowType for Mut<'a> {}\n     impl<'a> BorrowType for ValMut<'a> {}\n+    impl BorrowType for DormantMut {}\n \n     pub enum KV {}\n     pub enum Edge {}"}]}