{"sha": "2947957199c86127731569c36f4852eb9753cf25", "node_id": "C_kwDOAAsO6NoAKDI5NDc5NTcxOTljODYxMjc3MzE1NjljMzZmNDg1MmViOTc1M2NmMjU", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2021-10-01T18:51:55Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2021-10-01T19:24:03Z"}, "message": "feat(assist): add new assist to unwrap the result return type\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "6e3b76c6f85abb574806dddd845c40a3c1c1ffd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e3b76c6f85abb574806dddd845c40a3c1c1ffd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2947957199c86127731569c36f4852eb9753cf25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2947957199c86127731569c36f4852eb9753cf25", "html_url": "https://github.com/rust-lang/rust/commit/2947957199c86127731569c36f4852eb9753cf25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2947957199c86127731569c36f4852eb9753cf25/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b10decb209ca753bb1e623b94ded0e0ff79892f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b10decb209ca753bb1e623b94ded0e0ff79892f", "html_url": "https://github.com/rust-lang/rust/commit/6b10decb209ca753bb1e623b94ded0e0ff79892f"}], "stats": {"total": 959, "additions": 959, "deletions": 0}, "files": [{"sha": "f1b5045e965eaccae2eadf47e46d20a8447da4cc", "filename": "crates/ide_assists/src/handlers/unwrap_result_return_type.rs", "status": "added", "additions": 943, "deletions": 0, "changes": 943, "blob_url": "https://github.com/rust-lang/rust/blob/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=2947957199c86127731569c36f4852eb9753cf25", "patch": "@@ -0,0 +1,943 @@\n+use ide_db::helpers::{for_each_tail_expr, node_ext::walk_expr, FamousDefs};\n+use syntax::{\n+    ast::{self, Expr},\n+    match_ast, AstNode,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unwrap_result_return_type\n+//\n+// Wrap the function's return type into Result.\n+//\n+// ```\n+// # //- minicore: result\n+// fn foo() -> Result<i32>$0 { Ok(42i32) }\n+// ```\n+// ->\n+// ```\n+// fn foo() -> i32 { 42i32 }\n+// ```\n+pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n+    let parent = ret_type.syntax().parent()?;\n+    let body = match_ast! {\n+        match parent {\n+            ast::Fn(func) => func.body()?,\n+            ast::ClosureExpr(closure) => match closure.body()? {\n+                Expr::BlockExpr(block) => block,\n+                // closures require a block when a return type is specified\n+                _ => return None,\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let type_ref = &ret_type.ty()?;\n+    let ty = ctx.sema.resolve_type(type_ref).and_then(|ty| ty.as_adt());\n+    let result_enum =\n+        FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax()).krate()).core_result_Result()?;\n+\n+    if !matches!(ty, Some(hir::Adt::Enum(ret_type)) if ret_type == result_enum) {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"unwrap_result_return_type\", AssistKind::RefactorRewrite),\n+        \"Unwrap Result return type\",\n+        type_ref.syntax().text_range(),\n+        |builder| {\n+            let body = ast::Expr::BlockExpr(body);\n+\n+            let mut exprs_to_unwrap = Vec::new();\n+            let tail_cb = &mut |e: &_| tail_cb_impl(&mut exprs_to_unwrap, e);\n+            walk_expr(&body, &mut |expr| {\n+                if let Expr::ReturnExpr(ret_expr) = expr {\n+                    if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                        for_each_tail_expr(ret_expr_arg, tail_cb);\n+                    }\n+                }\n+            });\n+            for_each_tail_expr(&body, tail_cb);\n+\n+            for ret_expr_arg in exprs_to_unwrap {\n+                let new_ret_expr = ret_expr_arg.to_string();\n+                let new_ret_expr =\n+                    new_ret_expr.trim_start_matches(\"Ok(\").trim_start_matches(\"Err(\");\n+                builder.replace(\n+                    ret_expr_arg.syntax().text_range(),\n+                    new_ret_expr.strip_suffix(')').unwrap_or(new_ret_expr),\n+                )\n+            }\n+\n+            if let Some((_, inner_type)) = type_ref.to_string().split_once('<') {\n+                let inner_type = match inner_type.split_once(',') {\n+                    Some((success_inner_type, _)) => success_inner_type,\n+                    None => inner_type,\n+                };\n+                builder.replace(\n+                    type_ref.syntax().text_range(),\n+                    inner_type.strip_suffix('>').unwrap_or(inner_type),\n+                )\n+            }\n+        },\n+    )\n+}\n+\n+fn tail_cb_impl(acc: &mut Vec<ast::Expr>, e: &ast::Expr) {\n+    match e {\n+        Expr::BreakExpr(break_expr) => {\n+            if let Some(break_expr_arg) = break_expr.expr() {\n+                for_each_tail_expr(&break_expr_arg, &mut |e| tail_cb_impl(acc, e))\n+            }\n+        }\n+        Expr::ReturnExpr(ret_expr) => {\n+            if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                for_each_tail_expr(ret_expr_arg, &mut |e| tail_cb_impl(acc, e));\n+            }\n+        }\n+        e => acc.push(e.clone()),\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i3$02> {\n+    let test = \"test\";\n+    return Ok(42i32);\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_return_type_break_split_tail() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i3$02, String> {\n+    loop {\n+        break if true {\n+            Ok(1)\n+        } else {\n+            Ok(0)\n+        };\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    loop {\n+        break if true {\n+            1\n+        } else {\n+            0\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_closure() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    || -> Result<i32$0> {\n+        let test = \"test\";\n+        return Ok(42i32);\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> i32 {\n+        let test = \"test\";\n+        return 42i32;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_return_type_bad_cursor() {\n+        check_assist_not_applicable(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> i32 {\n+    let test = \"test\";$0\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_return_type_bad_cursor_closure() {\n+        check_assist_not_applicable(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    || -> i32 {\n+        let test = \"test\";$0\n+        return 42i32;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_closure_non_block() {\n+        check_assist_not_applicable(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() { || -> i$032 3; }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_return_type_already_not_result_std() {\n+        check_assist_not_applicable(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> i32$0 {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_return_type_already_not_result_closure() {\n+        check_assist_not_applicable(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    || -> i32$0 {\n+        let test = \"test\";\n+        return 42i32;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() ->$0 Result<i32> {\n+    let test = \"test\";\n+    Ok(42i32)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let test = \"test\";\n+    42i32\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_closure() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    || ->$0 Result<i32, String> {\n+        let test = \"test\";\n+        Ok(42i32)\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> i32 {\n+        let test = \"test\";\n+        42i32\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_only() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> { Ok(42i32) }\n+\"#,\n+            r#\"\n+fn foo() -> i32 { 42i32 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_block_like() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32>$0 {\n+    if true {\n+        Ok(42i32)\n+    } else {\n+        Ok(24i32)\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    if true {\n+        42i32\n+    } else {\n+        24i32\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_without_block_closure() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    || -> Result<i32, String>$0 {\n+        if true {\n+            Ok(42i32)\n+        } else {\n+            Ok(24i32)\n+        }\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> i32 {\n+        if true {\n+            42i32\n+        } else {\n+            24i32\n+        }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_nested_if() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32>$0 {\n+    if true {\n+        if false {\n+            Ok(1)\n+        } else {\n+            Ok(2)\n+        }\n+    } else {\n+        Ok(24i32)\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    if true {\n+        if false {\n+            1\n+        } else {\n+            2\n+        }\n+    } else {\n+        24i32\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_await() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+async fn foo() -> Result<i$032> {\n+    if true {\n+        if false {\n+            Ok(1.await)\n+        } else {\n+            Ok(2.await)\n+        }\n+    } else {\n+        Ok(24i32.await)\n+    }\n+}\n+\"#,\n+            r#\"\n+async fn foo() -> i32 {\n+    if true {\n+        if false {\n+            1.await\n+        } else {\n+            2.await\n+        }\n+    } else {\n+        24i32.await\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_array() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<[i32; 3]$0> { Ok([1, 2, 3]) }\n+\"#,\n+            r#\"\n+fn foo() -> [i32; 3] { [1, 2, 3] }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_cast() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -$0> Result<i32> {\n+    if true {\n+        if false {\n+            Ok(1 as i32)\n+        } else {\n+            Ok(2 as i32)\n+        }\n+    } else {\n+        Ok(24 as i32)\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    if true {\n+        if false {\n+            1 as i32\n+        } else {\n+            2 as i32\n+        }\n+    } else {\n+        24 as i32\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_block_like_match() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => Ok(42i32),\n+        _ => Ok(24i32),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = 5;\n+    match my_var {\n+        5 => 42i32,\n+        _ => 24i32,\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_loop_with_tail() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let my_var = 5;\n+    loop {\n+        println!(\"test\");\n+        5\n+    }\n+    Ok(my_var)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = 5;\n+    loop {\n+        println!(\"test\");\n+        5\n+    }\n+    my_var\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_loop_in_let_stmt() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let my_var = let x = loop {\n+        break 1;\n+    };\n+    Ok(my_var)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = let x = loop {\n+        break 1;\n+    };\n+    my_var\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_block_like_match_return_expr() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32>$0 {\n+    let my_var = 5;\n+    let res = match my_var {\n+        5 => 42i32,\n+        _ => return Ok(24i32),\n+    };\n+    Ok(res)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = 5;\n+    let res = match my_var {\n+        5 => 42i32,\n+        _ => return 24i32,\n+    };\n+    res\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let my_var = 5;\n+    let res = if my_var == 5 {\n+        42i32\n+    } else {\n+        return Ok(24i32);\n+    };\n+    Ok(res)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = 5;\n+    let res = if my_var == 5 {\n+        42i32\n+    } else {\n+        return 24i32;\n+    };\n+    res\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_block_like_match_deeper() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => {\n+            if true {\n+                Ok(42i32)\n+            } else {\n+                Ok(25i32)\n+            }\n+        },\n+        _ => {\n+            let test = \"test\";\n+            if test == \"test\" {\n+                return Ok(bar());\n+            }\n+            Ok(53i32)\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let my_var = 5;\n+    match my_var {\n+        5 => {\n+            if true {\n+                42i32\n+            } else {\n+                25i32\n+            }\n+        },\n+        _ => {\n+            let test = \"test\";\n+            if test == \"test\" {\n+                return bar();\n+            }\n+            53i32\n+        },\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_tail_block_like_early_return() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return Ok(24i32);\n+    }\n+    Ok(53i32)\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return 24i32;\n+    }\n+    53i32\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_closure() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u32$0> {\n+    let true_closure = || { return true; };\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if true_closure() {\n+            return Ok(99);\n+        } else {\n+            return Ok(0);\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    let true_closure = || { return true; };\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if true_closure() {\n+            return 99;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u32$0> {\n+    let true_closure = || {\n+        return true;\n+    };\n+    if the_field < 5 {\n+        let mut i = 0;\n+\n+\n+        if true_closure() {\n+            return Ok(99);\n+        } else {\n+            return Ok(0);\n+        }\n+    }\n+    let t = None;\n+\n+    Ok(t.unwrap_or_else(|| the_field))\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    let true_closure = || {\n+        return true;\n+    };\n+    if the_field < 5 {\n+        let mut i = 0;\n+\n+\n+        if true_closure() {\n+            return 99;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    let t = None;\n+\n+    t.unwrap_or_else(|| the_field)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_result_return_type_simple_with_weird_forms() {\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<i32$0> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return Ok(24i32);\n+    }\n+    let mut i = 0;\n+    loop {\n+        if i == 1 {\n+            break Ok(55);\n+        }\n+        i += 1;\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return 24i32;\n+    }\n+    let mut i = 0;\n+    loop {\n+        if i == 1 {\n+            break 55;\n+        }\n+        i += 1;\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u32$0> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        loop {\n+            if i > 5 {\n+                return Ok(55u32);\n+            }\n+            i += 3;\n+        }\n+        match i {\n+            5 => return Ok(99),\n+            _ => return Ok(0),\n+        };\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        loop {\n+            if i > 5 {\n+                return 55u32;\n+            }\n+            i += 3;\n+        }\n+        match i {\n+            5 => return 99,\n+            _ => return 0,\n+        };\n+    }\n+    the_field\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u32$0> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        match i {\n+            5 => return Ok(99),\n+            _ => return Ok(0),\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        match i {\n+            5 => return 99,\n+            _ => return 0,\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u32$0> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return Ok(99)\n+        } else {\n+            return Ok(0)\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return 99\n+        } else {\n+            return 0\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_result_return_type,\n+            r#\"\n+//- minicore: result\n+fn foo(the_field: u32) -> Result<u3$02> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return Ok(99);\n+        } else {\n+            return Ok(0);\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> u32 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return 99;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "8d254244bc65df54fa3f44cad4bcb590e2cc638c", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=2947957199c86127731569c36f4852eb9753cf25", "patch": "@@ -174,6 +174,7 @@ mod handlers {\n     mod toggle_ignore;\n     mod unmerge_use;\n     mod unwrap_block;\n+    mod unwrap_result_return_type;\n     mod wrap_return_type_in_result;\n \n     pub(crate) fn all() -> &'static [Handler] {\n@@ -251,6 +252,7 @@ mod handlers {\n             toggle_ignore::toggle_ignore,\n             unmerge_use::unmerge_use,\n             unwrap_block::unwrap_block,\n+            unwrap_result_return_type::unwrap_result_return_type,\n             wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities. By default,\n             // priority is determined by the size of the target range (smaller"}, {"sha": "5dbd07dad0bce34aebc64cb53fbfc0a478bfe33f", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2947957199c86127731569c36f4852eb9753cf25/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=2947957199c86127731569c36f4852eb9753cf25", "patch": "@@ -1855,6 +1855,20 @@ fn foo() {\n     )\n }\n \n+#[test]\n+fn doctest_unwrap_result_return_type() {\n+    check_doc_test(\n+        \"unwrap_result_return_type\",\n+        r#####\"\n+//- minicore: result\n+fn foo() -> Result<i32>$0 { Ok(42i32) }\n+\"#####,\n+        r#####\"\n+fn foo() -> i32 { 42i32 }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_wrap_return_type_in_result() {\n     check_doc_test("}]}