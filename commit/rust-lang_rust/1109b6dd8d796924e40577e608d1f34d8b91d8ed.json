{"sha": "1109b6dd8d796924e40577e608d1f34d8b91d8ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMDliNmRkOGQ3OTY5MjRlNDA1NzdlNjA4ZDFmMzRkOGI5MWQ4ZWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-14T14:03:10Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-14T14:03:10Z"}, "message": "Rollup merge of #25398 - nham:E0066_E0069, r=huonw\n\nAdds explanations for E0053, E0066, E0069, E0251, E0252, E0255, E0256, E0368.\r\n\r\ncc #24407", "tree": {"sha": "c79f5f286faee8e3bfa191ddbb56de3c3727e4ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c79f5f286faee8e3bfa191ddbb56de3c3727e4ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1109b6dd8d796924e40577e608d1f34d8b91d8ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1109b6dd8d796924e40577e608d1f34d8b91d8ed", "html_url": "https://github.com/rust-lang/rust/commit/1109b6dd8d796924e40577e608d1f34d8b91d8ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1109b6dd8d796924e40577e608d1f34d8b91d8ed/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff207b7a0526a0ad08a4eef58e47447671eeefcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff207b7a0526a0ad08a4eef58e47447671eeefcd", "html_url": "https://github.com/rust-lang/rust/commit/ff207b7a0526a0ad08a4eef58e47447671eeefcd"}, {"sha": "588777f5471db2d03b5a376efbc21c1dc10fc364", "url": "https://api.github.com/repos/rust-lang/rust/commits/588777f5471db2d03b5a376efbc21c1dc10fc364", "html_url": "https://github.com/rust-lang/rust/commit/588777f5471db2d03b5a376efbc21c1dc10fc364"}], "stats": {"total": 211, "additions": 195, "deletions": 16}, "files": [{"sha": "15ddcbc80749cb38dd430dd2f50aa6833f45d522", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1109b6dd8d796924e40577e608d1f34d8b91d8ed", "patch": "@@ -49,6 +49,88 @@ about what constitutes an Item declaration and what does not:\n http://doc.rust-lang.org/reference.html#statements\n \"##,\n \n+E0251: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0252: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0255: r##\"\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+An example of this error:\n+\n+```\n+use bar::foo; // error, do `use bar::foo as baz` instead\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0256: r##\"\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0259: r##\"\n The name chosen for an external crate conflicts with another external crate that\n has been imported into the current module.\n@@ -122,14 +204,10 @@ http://doc.rust-lang.org/reference.html#types\n register_diagnostics! {\n     E0157,\n     E0153,\n-    E0251, // a named type or value has already been imported in this module\n-    E0252, // a named type or value has already been imported in this module\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n-    E0255, // import conflicts with value in this module\n-    E0256, // import conflicts with type in this module\n-    E0257, // inherent implementations are only allowed on types defined in the current module\n-    E0258, // import conflicts with existing submodule\n+    E0257,\n+    E0258,\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "3cdbaec15284b7e488e423ae208e1aa8b2191781", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1109b6dd8d796924e40577e608d1f34d8b91d8ed", "patch": "@@ -3082,8 +3082,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let mut checked = false;\n           opt_place.as_ref().map(|place| match place.node {\n               ast::ExprPath(None, ref path) => {\n-                  // FIXME(pcwalton): For now we hardcode the two permissible\n-                  // places: the exchange heap and the managed heap.\n+                  // FIXME(pcwalton): For now we hardcode the only permissible\n+                  // place: the exchange heap.\n                   let definition = lookup_full_def(tcx, path.span, place.id);\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n@@ -3097,7 +3097,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,\n-                  \"only the managed heap and exchange heap are currently supported\");\n+                  \"only the exchange heap is currently supported\");\n               fcx.write_ty(id, tcx.types.err);\n           }\n       }\n@@ -3317,7 +3317,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n                                                     result_type, ty::mk_nil(fcx.tcx())) {\n                             span_err!(tcx.sess, expr.span, E0069,\n-                                \"`return;` in function returning non-nil\");\n+                                \"`return;` in a function whose return type is \\\n+                                 not `()`\");\n                         },\n                     Some(ref e) => {\n                         check_expr_coercable_to_type(fcx, &**e, result_type);"}, {"sha": "2e5b389c2850eb179cc4a50fc7080d01dc80cad5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 4, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1109b6dd8d796924e40577e608d1f34d8b91d8ed", "patch": "@@ -64,6 +64,43 @@ impl Foo for Bar {\n ```\n \"##,\n \n+E0053: r##\"\n+For any given method of a trait, the mutabilities of the parameters must match\n+between the trait definition and the implementation.\n+\n+Here's an example where the mutability of the `self` parameter is wrong:\n+\n+```\n+trait Foo { fn foo(&self); }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the signature should be `fn foo(&self)` instead\n+    fn foo(&mut self) { }\n+}\n+\n+fn main() {}\n+```\n+\n+Here's another example, this time for a non-`self` parameter:\n+\n+```\n+trait Foo { fn foo(x: &mut bool) -> bool; }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the type of `x` should be `&mut bool` instead\n+    fn foo(x: &bool) -> bool { *x }\n+}\n+\n+fn main() {}\n+```\n+\n+\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -91,6 +128,16 @@ enum variant, one of the fields was not provided. Each field should be specified\n exactly once.\n \"##,\n \n+E0066: r##\"\n+Box placement expressions (like C++'s \"placement new\") do not yet support any\n+place expression except the exchange heap (i.e. `std::boxed::HEAP`).\n+Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\n+and [RFC 809] for more details.\n+\n+[RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n+[RFC 809]: https://github.com/rust-lang/rfcs/pull/809\n+\"##,\n+\n E0067: r##\"\n The left-hand side of an assignment operator must be an lvalue expression. An\n lvalue expression represents a memory location and includes item paths (ie,\n@@ -108,6 +155,21 @@ LinkedList::new() += 1;\n ```\n \"##,\n \n+E0069: r##\"\n+The compiler found a function whose body contains a `return;` statement but\n+whose return type is not `()`. An example of this is:\n+\n+```\n+// error\n+fn foo() -> u8 {\n+    return;\n+}\n+```\n+\n+Since `return;` is just like `return ();`, there is a mismatch between the\n+function's return type and the value being returned.\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -458,6 +520,48 @@ The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n for types as needed by the compiler, and it is currently disallowed to\n explicitly implement it for a type.\n+\"##,\n+\n+E0368: r##\"\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to the wrong types.\n+\n+A couple examples of this are as follows:\n+\n+```\n+let mut x: u16 = 5;\n+x ^= true; // error, `^=` cannot be applied to types `u16` and `bool`\n+x += ();   // error, `+=` cannot be applied to types `u16` and `()`\n+```\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to types `Foo` and `Foo`\n+}\n+```\n+\n+This is because the binary assignment operators currently do not work off of\n+traits, so it is not possible to overload them. See [RFC 953] for a proposal\n+to change this.\n+\n+[RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n \"##\n \n }\n@@ -478,15 +582,12 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n     E0061,\n-    E0066,\n     E0068,\n-    E0069,\n     E0070,\n     E0071,\n     E0072,\n@@ -606,7 +707,6 @@ register_diagnostics! {\n     E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n-    E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372, // impl Trait for Trait where Trait is not object safe"}, {"sha": "003c6644f7f0229061662a995ecc8ab5eff03ba1", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=1109b6dd8d796924e40577e608d1f34d8b91d8ed", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     box ( () ) 0;\n-    //~^ ERROR: only the managed heap and exchange heap are currently supported\n+    //~^ ERROR: only the exchange heap is currently supported\n }"}, {"sha": "6be98fbd82773ffad6e708af3bddb0559de87276", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1109b6dd8d796924e40577e608d1f34d8b91d8ed/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=1109b6dd8d796924e40577e608d1f34d8b91d8ed", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: `return;` in function returning non-nil\n+// error-pattern: `return;` in a function whose return type is not `()`\n \n fn f() { return; }\n "}]}