{"sha": "16fe8ccce95a9df185404c881c029fb0507e4821", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZmU4Y2NjZTk1YTlkZjE4NTQwNGM4ODFjMDI5ZmIwNTA3ZTQ4MjE=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-04-29T22:32:35Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-05-02T11:02:34Z"}, "message": "Remove the `self.mir` field from `ConstPropagator`", "tree": {"sha": "6bbf9a506c2975e37ea86656dab6b50031ec8004", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bbf9a506c2975e37ea86656dab6b50031ec8004"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16fe8ccce95a9df185404c881c029fb0507e4821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16fe8ccce95a9df185404c881c029fb0507e4821", "html_url": "https://github.com/rust-lang/rust/commit/16fe8ccce95a9df185404c881c029fb0507e4821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16fe8ccce95a9df185404c881c029fb0507e4821/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "758dc9af504e2fe75813bd362619231ecc727898", "url": "https://api.github.com/repos/rust-lang/rust/commits/758dc9af504e2fe75813bd362619231ecc727898", "html_url": "https://github.com/rust-lang/rust/commit/758dc9af504e2fe75813bd362619231ecc727898"}], "stats": {"total": 136, "additions": 80, "deletions": 56}, "files": [{"sha": "2d89f73a95f6913c7dc588445d15aeaf6c867337", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 71, "deletions": 53, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/16fe8ccce95a9df185404c881c029fb0507e4821/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16fe8ccce95a9df185404c881c029fb0507e4821/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=16fe8ccce95a9df185404c881c029fb0507e4821", "patch": "@@ -1,18 +1,19 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-\n use rustc::hir::def::Def;\n-use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind};\n-use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n+use rustc::mir::{\n+    Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n+    NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n+    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n+    SourceScope, SourceScopeLocalData, LocalDecl, Promoted,\n+};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{InterpError, Scalar, GlobalId, EvalResult};\n-use rustc::ty::{self, Instance, Ty, TyCtxt};\n-use syntax::source_map::{Span, DUMMY_SP};\n+use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n+use syntax::source_map::DUMMY_SP;\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n@@ -62,21 +63,33 @@ impl MirPass for ConstProp {\n         let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n         optimization_finder.visit_mir(mir);\n \n+        // put back the data we stole from `mir`\n+        std::mem::replace(\n+            &mut mir.source_scope_local_data,\n+            optimization_finder.source_scope_local_data\n+        );\n+        std::mem::replace(\n+            &mut mir.promoted,\n+            optimization_finder.promoted\n+        );\n+\n         trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n }\n \n-type Const<'tcx> = (OpTy<'tcx>, Span);\n+type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n     param_env: ParamEnv<'tcx>,\n+    source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    promoted: IndexVec<Promoted, Mir<'tcx>>,\n }\n \n impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n@@ -104,20 +117,33 @@ impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n \n impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n-        mir: &'mir Mir<'tcx>,\n+        mir: &mut Mir<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n         let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n+        let can_const_prop = CanConstProp::check(mir);\n+        let source_scope_local_data = std::mem::replace(\n+            &mut mir.source_scope_local_data,\n+            ClearCrossCrate::Clear\n+        );\n+        let promoted = std::mem::replace(\n+            &mut mir.promoted,\n+            IndexVec::new()\n+        );\n+\n         ConstPropagator {\n             ecx,\n-            mir,\n             tcx,\n             source,\n             param_env,\n-            can_const_prop: CanConstProp::check(mir),\n+            can_const_prop,\n             places: IndexVec::from_elem(None, &mir.local_decls),\n+            source_scope_local_data,\n+            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_mir()` needs it\n+            local_decls: mir.local_decls.clone(),\n+            promoted,\n         }\n     }\n \n@@ -130,7 +156,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n         self.ecx.tcx.span = source_info.span;\n-        let lint_root = match self.mir.source_scope_local_data {\n+        let lint_root = match self.source_scope_local_data {\n             ClearCrossCrate::Set(ref ivs) => {\n                 //FIXME(#51314): remove this check\n                 if source_info.scope.index() >= ivs.len() {\n@@ -252,12 +278,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn eval_constant(\n         &mut self,\n         c: &Constant<'tcx>,\n-        source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n-        self.ecx.tcx.span = source_info.span;\n+        self.ecx.tcx.span = c.span;\n         match self.ecx.eval_const_to_op(*c.literal, None) {\n             Ok(op) => {\n-                Some((op, c.span))\n+                Some(op)\n             },\n             Err(error) => {\n                 let err = error_to_const_error(&self.ecx, error);\n@@ -273,11 +298,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n-                    let (base, span) = self.eval_place(&proj.base, source_info)?;\n+                    let base = self.eval_place(&proj.base, source_info)?;\n                     let res = self.use_ecx(source_info, |this| {\n                         this.ecx.operand_field(base, field.index() as u64)\n                     })?;\n-                    Some((res, span))\n+                    Some(res)\n                 },\n                 // We could get more projections by using e.g., `operand_projection`,\n                 // but we do not even have the stack frame set up properly so\n@@ -301,19 +326,19 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n                 let res = self.use_ecx(source_info, |this| {\n-                    let mir = &this.mir.promoted[promoted];\n+                    let mir = &this.promoted[promoted];\n                     eval_promoted(this.tcx, cid, mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some((res.into(), source_info.span))\n+                Some(res.into())\n             },\n             _ => None,\n         }\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c),\n             | Operand::Move(ref place)\n             | Operand::Copy(ref place) => self.eval_place(place, source_info),\n         }\n@@ -337,18 +362,18 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::Discriminant(..) => None,\n \n             Rvalue::Cast(kind, ref operand, _) => {\n-                let (op, span) = self.eval_operand(operand, source_info)?;\n+                let op = self.eval_operand(operand, source_info)?;\n                 self.use_ecx(source_info, |this| {\n                     let dest = this.ecx.allocate(place_layout, MemoryKind::Stack);\n                     this.ecx.cast(op, kind, dest.into())?;\n-                    Ok((dest.into(), span))\n+                    Ok(dest.into())\n                 })\n             }\n \n             // FIXME(oli-obk): evaluate static/constant slice lengths\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n+                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n                     ImmTy {\n                         imm: Immediate::Scalar(\n                             Scalar::Bits {\n@@ -357,9 +382,8 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                             }.into()\n                         ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into(),\n-                    span,\n-                )))\n+                    }.into()\n+                ))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n                 let def_id = if self.tcx.is_closure(self.source.def_id()) {\n@@ -373,7 +397,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     return None;\n                 }\n \n-                let (arg, _) = self.eval_operand(arg, source_info)?;\n+                let arg = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n                     let prim = this.ecx.read_immediate(arg)?;\n                     match op {\n@@ -395,7 +419,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     imm: Immediate::Scalar(val.into()),\n                     layout: place_layout,\n                 };\n-                Some((res.into(), span))\n+                Some(res.into())\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -413,20 +437,20 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(right.0)\n+                    this.ecx.read_immediate(right)\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n-                    let left_ty = left.ty(self.mir, self.tcx);\n+                    let left_ty = left.ty(&self.local_decls, self.tcx);\n                     let left_bits = self\n                         .tcx\n                         .layout_of(self.param_env.and(left_ty))\n                         .unwrap()\n                         .size\n                         .bits();\n-                    let right_size = right.0.layout.size;\n+                    let right_size = right.layout.size;\n                     let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n                     if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n-                        let source_scope_local_data = match self.mir.source_scope_local_data {\n+                        let source_scope_local_data = match self.source_scope_local_data {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n                         };\n@@ -446,7 +470,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(left.0)\n+                    this.ecx.read_immediate(left)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n@@ -469,7 +493,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     imm: val,\n                     layout: place_layout,\n                 };\n-                Some((res.into(), span))\n+                Some(res.into())\n             },\n         }\n     }\n@@ -544,8 +568,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n     ) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        let source_info = *self.mir.source_info(location);\n-        self.eval_constant(constant, source_info);\n+        self.eval_constant(constant);\n     }\n \n     fn visit_statement(\n@@ -556,7 +579,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n             let place_ty: Ty<'tcx> = place\n-                .ty(&self.mir.local_decls, self.tcx)\n+                .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n@@ -574,18 +597,18 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         self.super_statement(statement, location);\n     }\n \n-    fn visit_terminator_kind(\n+    fn visit_terminator(\n         &mut self,\n-        kind: &TerminatorKind<'tcx>,\n+        terminator: &Terminator<'tcx>,\n         location: Location,\n     ) {\n-        self.super_terminator_kind(kind, location);\n-        let source_info = *self.mir.source_info(location);\n-        if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n-            if let Some(value) = self.eval_operand(cond, source_info) {\n+        self.super_terminator(terminator, location);\n+        let source_info = terminator.source_info;;\n+        if let TerminatorKind::Assert { expected, msg, cond, .. } = &terminator.kind {\n+            if let Some(value) = self.eval_operand(&cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                 let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n-                if expected != self.ecx.read_scalar(value.0).unwrap() {\n+                if expected != self.ecx.read_scalar(value).unwrap() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -600,12 +623,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         },\n                         Operand::Constant(_) => {}\n                     }\n-                    let span = self.mir[location.block]\n-                        .terminator\n-                        .as_ref()\n-                        .unwrap()\n-                        .source_info\n-                        .span;\n+                    let span = terminator.source_info.span;\n                     let hir_id = self\n                         .tcx\n                         .hir()\n@@ -621,7 +639,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match self.ecx.read_scalar(len.0) {\n+                            let len = match self.ecx.read_scalar(len) {\n                                 Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n@@ -630,7 +648,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match self.ecx.read_scalar(index.0) {\n+                            let index = match self.ecx.read_scalar(index) {\n                                 Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,"}, {"sha": "429e2ae7600d679aed49d60442425b8428d8c40b", "filename": "src/test/ui/consts/const-err.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16fe8ccce95a9df185404c881c029fb0507e4821/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16fe8ccce95a9df185404c881c029fb0507e4821/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr?ref=16fe8ccce95a9df185404c881c029fb0507e4821", "patch": "@@ -13,11 +13,17 @@ LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const-err.rs:14:15\n+  --> $DIR/const-err.rs:14:16\n    |\n LL |     black_box((FOO, FOO));\n-   |               ^^^^^^^^^^ referenced constant has errors\n+   |                ^^^ referenced constant has errors\n \n-error: aborting due to previous error\n+error[E0080]: erroneous constant used\n+  --> $DIR/const-err.rs:14:21\n+   |\n+LL |     black_box((FOO, FOO));\n+   |                     ^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}