{"sha": "bd009dc4441eff189066dd89447a829f5a190dee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMDA5ZGM0NDQxZWZmMTg5MDY2ZGQ4OTQ0N2E4MjlmNWExOTBkZWU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T02:16:36Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:44Z"}, "message": "Remove fn_ty from FunctionContext", "tree": {"sha": "6f81db6f579ed759b8af0a4aec630c5c33554718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f81db6f579ed759b8af0a4aec630c5c33554718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd009dc4441eff189066dd89447a829f5a190dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd009dc4441eff189066dd89447a829f5a190dee", "html_url": "https://github.com/rust-lang/rust/commit/bd009dc4441eff189066dd89447a829f5a190dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd009dc4441eff189066dd89447a829f5a190dee/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b9b27bb091c98fe4504c24bc62c738411c8c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b9b27bb091c98fe4504c24bc62c738411c8c8d", "html_url": "https://github.com/rust-lang/rust/commit/15b9b27bb091c98fe4504c24bc62c738411c8c8d"}], "stats": {"total": 90, "additions": 40, "deletions": 50}, "files": [{"sha": "76bb1c56af3818aa155be237b4bb5da7292aded4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -598,10 +598,9 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, lldecl, fn_ty);\n-\n+    let fcx = FunctionContext::new(ccx, lldecl);\n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(&fcx, &mir, instance, &sig, abi);\n+    mir::trans_mir(&fcx, fn_ty, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -618,28 +617,28 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, llfndecl, fn_ty);\n+    let fcx = FunctionContext::new(ccx, llfndecl);\n     let bcx = fcx.get_entry_block();\n-    if !fcx.fn_ty.ret.is_ignore() {\n+    if !fn_ty.ret.is_ignore() {\n         // But if there are no nested returns, we skip the indirection\n         // and have a single retslot\n-        let dest = if fcx.fn_ty.ret.is_indirect() {\n+        let dest = if fn_ty.ret.is_indirect() {\n             get_param(fcx.llfn, 0)\n         } else {\n             // We create an alloca to hold a pointer of type `ret.original_ty`\n             // which will hold the pointer to the right alloca which has the\n             // final ret value\n-            fcx.alloca(fcx.fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+            fcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n         };\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+        let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n-            let arg = &fcx.fn_ty.args[arg_idx];\n+            let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &fcx.fn_ty.args[arg_idx];\n+                let meta = &fn_ty.args[arg_idx];\n                 arg_idx += 1;\n                 arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));\n                 meta.store_fn_arg(&bcx, &mut llarg_idx, get_meta(&bcx, lldestptr));\n@@ -649,14 +648,14 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         adt::trans_set_discr(&bcx, sig.output(), dest, disr);\n \n-        if fcx.fn_ty.ret.is_indirect() {\n+        if fn_ty.ret.is_indirect() {\n             bcx.ret_void();\n             return;\n         }\n \n-        if let Some(cast_ty) = fcx.fn_ty.ret.cast {\n+        if let Some(cast_ty) = fn_ty.ret.cast {\n             let load = bcx.load(bcx.pointercast(dest, cast_ty.ptr_to()));\n-            let llalign = llalign_of_min(ccx, fcx.fn_ty.ret.ty);\n+            let llalign = llalign_of_min(ccx, fn_ty.ret.ty);\n             unsafe {\n                 llvm::LLVMSetAlignment(load, llalign);\n             }"}, {"sha": "651cc40f993c2037a2d65d768d4193ad51964652", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -328,7 +328,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n-    let fcx = FunctionContext::new(ccx, lloncefn, fn_ty);\n+    let orig_fn_ty = fn_ty;\n+    let fcx = FunctionContext::new(ccx, lloncefn);\n     let mut bcx = fcx.get_entry_block();\n \n     let callee = Callee {\n@@ -342,7 +343,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let idx = fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &fcx.fn_ty.args[0];\n+    let env_arg = &orig_fn_ty.args[0];\n     let llenv = if env_arg.is_indirect() {\n         llargs[idx]\n     } else {\n@@ -494,12 +495,12 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty);\n+    let fcx = FunctionContext::new(ccx, llfn);\n     let bcx = fcx.get_entry_block();\n \n     let mut llargs = get_params(fcx.llfn);\n \n-    let self_arg = llargs.remove(fcx.fn_ty.ret.is_indirect() as usize);\n+    let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {\n         // the first argument (`self`) will be ptr to the fn pointer\n         if is_by_ref {"}, {"sha": "b9e17c53c0afbe65c9915096415b3e3f7fb123ab", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n-use abi::{Abi, FnType};\n+use abi::Abi;\n use base;\n use builder::Builder;\n use callee::Callee;\n@@ -236,9 +236,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // allocas, so that LLVM will coalesce them into a single alloca call.\n     alloca_insert_pt: Option<ValueRef>,\n \n-    // Describes the return/argument LLVM types and their ABI handling.\n-    pub fn_ty: FnType,\n-\n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n \n@@ -248,15 +245,10 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Create a function context for the given function.\n     /// Call FunctionContext::get_entry_block for the first entry block.\n-    pub fn new(\n-        ccx: &'a CrateContext<'a, 'tcx>,\n-        llfndecl: ValueRef,\n-        fn_ty: FnType,\n-    ) -> FunctionContext<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, llfndecl: ValueRef) -> FunctionContext<'a, 'tcx> {\n         let mut fcx = FunctionContext {\n             llfn: llfndecl,\n             alloca_insert_pt: None,\n-            fn_ty: fn_ty,\n             ccx: ccx,\n             alloca_builder: Builder::with_ccx(ccx),\n         };"}, {"sha": "5fb4a0e088f6293c26390662f45501519c89fdec", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -186,9 +186,9 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'t\n \n pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n     assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n-    let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n+    let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty);\n+    let fcx = FunctionContext::new(ccx, llfn);\n     let bcx = fcx.get_entry_block();\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);"}, {"sha": "e052fa01da05d9bc8f62f7245f3d106b255c06a5", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -878,15 +878,14 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n     let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n-    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n     let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty);\n+    let fcx = FunctionContext::new(ccx, llfn);\n     trans(fcx.get_entry_block());\n     llfn\n }"}, {"sha": "cf50e7be2afb5c1692b3532ec84b0f33d5d1f3ae", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -11,7 +11,6 @@\n use attributes;\n use llvm::{ValueRef, get_params};\n use rustc::traits;\n-use abi::FnType;\n use callee::{Callee, CalleeData};\n use common::*;\n use consts;\n@@ -63,25 +62,20 @@ pub fn get_virtual_method<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                    callee: Callee<'tcx>)\n                                    -> ValueRef {\n-    let tcx = ccx.tcx();\n-\n     debug!(\"trans_object_shim({:?})\", callee);\n \n-    let (sig, abi, function_name) = match callee.ty.sty {\n-        ty::TyFnDef(def_id, substs, f) => {\n+    let function_name = match callee.ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => {\n             let instance = Instance::new(def_id, substs);\n-            (&f.sig, f.abi, instance.symbol_name(ccx.shared()))\n+            instance.symbol_name(ccx.shared())\n         }\n         _ => bug!()\n     };\n \n-    let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty);\n+    let fcx = FunctionContext::new(ccx, llfn);\n     let bcx = fcx.get_entry_block();\n \n     let mut llargs = get_params(fcx.llfn);\n@@ -103,7 +97,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     if fn_ret.0.is_never() {\n         bcx.unreachable();\n     } else {\n-        if fn_ty.ret.is_indirect() || fcx.fn_ty.ret.is_ignore() {\n+        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n             bcx.ret_void();\n         } else {\n             bcx.ret(llret);"}, {"sha": "d36857a8581a8e6af2c00cd1e9241db82aa74860", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Return => {\n-                let ret = bcx.fcx().fn_ty.ret;\n+                let ret = self.fn_ty.ret;\n                 if ret.is_ignore() || ret.is_indirect() {\n                     bcx.ret_void();\n                     return;"}, {"sha": "581e403f4208f94c77485e2cca114149dbe2add6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd009dc4441eff189066dd89447a829f5a190dee/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bd009dc4441eff189066dd89447a829f5a190dee", "patch": "@@ -22,6 +22,7 @@ use base;\n use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n+use abi::FnType;\n use machine;\n use type_of;\n \n@@ -52,6 +53,8 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n+    fn_ty: FnType,\n+\n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n     /// resume instruction. The personality is (afaik) some kind of\n@@ -197,6 +200,7 @@ impl<'tcx> LocalRef<'tcx> {\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n     fcx: &'a FunctionContext<'a, 'tcx>,\n+    fn_ty: FnType,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: &ty::FnSig<'tcx>,\n@@ -224,6 +228,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let mut mircx = MirContext {\n         mir: mir,\n         fcx: fcx,\n+        fn_ty: fn_ty,\n         ccx: fcx.ccx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n@@ -271,7 +276,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 LocalRef::Lvalue(lvalue)\n             } else {\n                 // Temporary or return pointer\n-                if local == mir::RETURN_POINTER && fcx.fn_ty.ret.is_indirect() {\n+                if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(fcx.llfn, 0);\n                     LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n@@ -351,7 +356,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n-    let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n@@ -379,12 +384,12 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n-                let arg = &fcx.fn_ty.args[idx];\n+                let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n                     // We pass fat pointers as two words, but inside the tuple\n                     // they are the two sub-fields of a single aggregate field.\n-                    let meta = &fcx.fn_ty.args[idx];\n+                    let meta = &mircx.fn_ty.args[idx];\n                     idx += 1;\n                     arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, dst));\n                     meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, dst));\n@@ -413,7 +418,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n         }\n \n-        let arg = &fcx.fn_ty.args[idx];\n+        let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n         let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n             // Don't copy an indirect argument to an alloca, the caller\n@@ -442,7 +447,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n             let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &fcx.fn_ty.args[idx];\n+                let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n                 let llmeta = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n@@ -462,7 +467,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in.\n-                let meta = &fcx.fn_ty.args[idx];\n+                let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp));\n                 meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp));"}]}