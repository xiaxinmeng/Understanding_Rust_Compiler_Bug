{"sha": "6c0a486e8b3f9801a408b89946cb6c8245a88061", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMGE0ODZlOGIzZjk4MDFhNDA4Yjg5OTQ2Y2I2YzgyNDVhODgwNjE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-11T21:22:30Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-11T22:18:58Z"}, "message": "Fix FP with `DOC_MARKDOWN` and reference links", "tree": {"sha": "d70030186f18eb8aa5b037304278081972298739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d70030186f18eb8aa5b037304278081972298739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c0a486e8b3f9801a408b89946cb6c8245a88061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0a486e8b3f9801a408b89946cb6c8245a88061", "html_url": "https://github.com/rust-lang/rust/commit/6c0a486e8b3f9801a408b89946cb6c8245a88061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c0a486e8b3f9801a408b89946cb6c8245a88061/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c4ae9295dbcf16a1cabf351149df0d1c0d100ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c4ae9295dbcf16a1cabf351149df0d1c0d100ea", "html_url": "https://github.com/rust-lang/rust/commit/9c4ae9295dbcf16a1cabf351149df0d1c0d100ea"}], "stats": {"total": 112, "additions": 93, "deletions": 19}, "files": [{"sha": "da87b1043417fc9f10cf4944f72fb35f0fdd8704", "filename": "src/doc.rs", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a486e8b3f9801a408b89946cb6c8245a88061/src%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a486e8b3f9801a408b89946cb6c8245a88061/src%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc.rs?ref=6c0a486e8b3f9801a408b89946cb6c8245a88061", "patch": "@@ -84,7 +84,32 @@ fn collect_doc(attrs: &[ast::Attribute]) -> (Cow<str>, Option<Span>) {\n pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute], default_span: Span) {\n     let (doc, span) = collect_doc(attrs);\n     let span = span.unwrap_or(default_span);\n+    check_doc(cx, valid_idents, &doc, span);\n+}\n+\n+macro_rules! jump_to {\n+    // Get the next character\u2019s first byte UTF-8 friendlyly.\n+    (@next_char, $chars: expr, $len: expr) => {{\n+        if let Some(&(pos, _)) = $chars.peek() {\n+            pos\n+        } else {\n+            $len\n+        }\n+    }};\n+\n+    // Jump to the next `$c`. If no such character is found, give up.\n+    ($chars: expr, $c: expr, $len: expr) => {{\n+        if $chars.find(|&(_, c)| c == $c).is_some() {\n+            jump_to!(@next_char, $chars, $len)\n+        }\n+        else {\n+            return;\n+        }\n+    }};\n+}\n \n+#[allow(while_let_loop)] // #362\n+pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -96,19 +121,68 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n     // (_baz_)             \u2192 (<em>baz</em>)\n     // foo _ bar _ baz     \u2192 foo _ bar _ baz\n \n-    let mut in_ticks = false;\n-    for word in doc.split_whitespace() {\n-        let ticks = word.bytes().filter(|&b| b == b'`').count();\n-\n-        if ticks == 2 { // likely to be \u201c`foo`\u201d\n-            continue;\n-        } else if ticks % 2 == 1 {\n-            in_ticks = !in_ticks;\n-            continue; // let\u2019s assume no one will ever write something like \u201c`foo`_bar\u201d\n+    /// Character that can appear in a word\n+    fn is_word_char(c: char) -> bool {\n+        match c {\n+            t if t.is_alphanumeric() => true,\n+            ':' | '_' => true,\n+            _ => false,\n         }\n+    }\n \n-        if !in_ticks {\n-            check_word(cx, valid_idents, word, span);\n+    let len = doc.len();\n+    let mut chars = doc.char_indices().peekable();\n+    let mut current_word_begin = 0;\n+    loop {\n+        match chars.next() {\n+            Some((_, c)) => {\n+                match c {\n+                    c if c.is_whitespace() => {\n+                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    }\n+                    '`' => {\n+                        current_word_begin = jump_to!(chars, '`', len);\n+                    },\n+                    '[' => {\n+                        let end = jump_to!(chars, ']', len);\n+                        let link_text = &doc[current_word_begin+1..end];\n+\n+                        match chars.peek() {\n+                            Some(&(_, c)) => {\n+                                // Trying to parse a link. Let\u2019s ignore the link.\n+\n+                                // FIXME: how does markdown handles such link?\n+                                // https://en.wikipedia.org/w/index.php?title=)\n+                                match c {\n+                                    '(' => { // inline link\n+                                        current_word_begin = jump_to!(chars, ')', len);\n+                                        check_doc(cx, valid_idents, link_text, span);\n+                                    }\n+                                    '[' => { // reference link\n+                                        current_word_begin = jump_to!(chars, ']', len);\n+                                        check_doc(cx, valid_idents, link_text, span);\n+                                    }\n+                                    ':' => { // reference link\n+                                        current_word_begin = jump_to!(chars, '\\n', len);\n+                                    }\n+                                    _ => continue,\n+                                }\n+                            }\n+                            None => return,\n+                        }\n+                    }\n+                    _ => {\n+                        let end = match chars.find(|&(_, c)| !is_word_char(c)) {\n+                            Some((end, _)) => end,\n+                            None => len,\n+                        };\n+\n+                        check_word(cx, valid_idents, &doc[current_word_begin..end], span);\n+                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    }\n+                }\n+            }\n+            None => break,\n         }\n     }\n }\n@@ -136,11 +210,6 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n         s != \"_\" && !s.contains(\"\\\\_\") && s.contains('_')\n     }\n \n-    // Something with a `/` might be a link, don\u2019t warn (see #823):\n-    if word.contains('/') {\n-        return;\n-    }\n-\n     // Trim punctuation as in `some comment (see foo::bar).`\n     //                                                   ^^\n     // Or even as in `_foo bar_` which is emphasized."}, {"sha": "81250b5485a4551c7ca5862b56688b994679f76f", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c0a486e8b3f9801a408b89946cb6c8245a88061/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0a486e8b3f9801a408b89946cb6c8245a88061/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=6c0a486e8b3f9801a408b89946cb6c8245a88061", "patch": "@@ -41,14 +41,19 @@ fn test_emphasis() {\n fn test_units() {\n }\n \n-/// This test has [a link with underscores][chunked-example] inside it. See #823.\n-/// See also [the issue tracker](https://github.com/Manishearth/rust-clippy/search?q=doc_markdown&type=Issues).\n+/// This test has [a link_with_underscores][chunked-example] inside it. See #823.\n+/// See also [the issue tracker](https://github.com/Manishearth/rust-clippy/search?q=doc_markdown&type=Issues). And here is another [inline link][inline_link].\n ///\n-/// [chunked-example]: http://en.wikipedia.org/wiki/Chunked_transfer_encoding#Example\n+/// [chunked-example]: https://en.wikipedia.org/wiki/Chunked_transfer_encoding#Example\n+/// [inline_link]: https://foobar\n \n /// The `main` function is the entry point of the program. Here it only calls the `foo_bar` and\n /// `multiline_ticks` functions.\n+///\n+/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n+/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n fn main() {\n+//~^ ERROR: you should put `link_with_underscores` between ticks\n     foo_bar();\n     multiline_ticks();\n     test_emphasis();"}]}