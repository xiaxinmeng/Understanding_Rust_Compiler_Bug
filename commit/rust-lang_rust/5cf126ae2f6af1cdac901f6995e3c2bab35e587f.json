{"sha": "5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZjEyNmFlMmY2YWYxY2RhYzkwMWY2OTk1ZTNjMmJhYjM1ZTU4N2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-11T00:59:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-31T20:39:14Z"}, "message": "std: Remove #[old_orphan_check] from PartialEq\n\nThis is a deprecated attribute that is slated for removal, and it also affects\nall implementors of the trait. This commit removes the attribute and fixes up\nimplementors accordingly. The primary implementation which was lost was the\nability to compare `&[T]` and `Vec<T>` (in that order).\n\nThis change also modifies the `assert_eq!` macro to not consider both directions\nof equality, only the one given in the left/right forms to the macro. This\nmodification is motivated due to the fact that `&[T] == Vec<T>` no longer\ncompiles, causing hundreds of errors in unit tests in the standard library (and\nlikely throughout the community as well).\n\ncc #19470\n[breaking-change]", "tree": {"sha": "f7e9a256438a06caa8bdc0f881e0f4bbb5a7e4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7e9a256438a06caa8bdc0f881e0f4bbb5a7e4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "html_url": "https://github.com/rust-lang/rust/commit/5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80bf31dd514055177b22c3dc66836d39eb5b1648", "url": "https://api.github.com/repos/rust-lang/rust/commits/80bf31dd514055177b22c3dc66836d39eb5b1648", "html_url": "https://github.com/rust-lang/rust/commit/80bf31dd514055177b22c3dc66836d39eb5b1648"}], "stats": {"total": 163, "additions": 77, "deletions": 86}, "files": [{"sha": "7e19ec94ee745160e4fe01ecbcb47e056b43b81d", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -37,7 +37,7 @@ number of elements.\n \n ```rust\n let x: Vec<u32> = vec![1, 2, 3];\n-# assert_eq!(&[1,2,3], &x);\n+# assert_eq!(x, [1, 2, 3]);\n ```\n \n This can't be an ordinary function, because it takes any number of arguments.\n@@ -51,7 +51,7 @@ let x: Vec<u32> = {\n     temp_vec.push(3);\n     temp_vec\n };\n-# assert_eq!(&[1,2,3], &x);\n+# assert_eq!(x, [1, 2, 3]);\n ```\n \n We can implement this shorthand, using a macro: [^actual]\n@@ -73,7 +73,7 @@ macro_rules! vec {\n     };\n }\n # fn main() {\n-#     assert_eq!([1,2,3], vec![1,2,3]);\n+#     assert_eq!(vec![1,2,3], [1, 2, 3]);\n # }\n ```\n "}, {"sha": "56a811cc4a6f1d325d9456b62df229c7c4bc5f49", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -1079,7 +1079,7 @@ mod test {\n         thread::spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<_>>());\n+            assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n         }).join().ok().unwrap();\n     }\n "}, {"sha": "451565e8feb85a5ee0c0a6835c48303f4cc99b35", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -1533,22 +1533,22 @@ impl<T> Extend<T> for Vec<T> {\n }\n \n __impl_slice_eq1! { Vec<A>, Vec<B> }\n-__impl_slice_eq2! { Vec<A>, &'b [B] }\n-__impl_slice_eq2! { Vec<A>, &'b mut [B] }\n-__impl_slice_eq2! { Cow<'a, [A]>, &'b [B], Clone }\n-__impl_slice_eq2! { Cow<'a, [A]>, &'b mut [B], Clone }\n-__impl_slice_eq2! { Cow<'a, [A]>, Vec<B>, Clone }\n+__impl_slice_eq1! { Vec<A>, &'b [B] }\n+__impl_slice_eq1! { Vec<A>, &'b mut [B] }\n+__impl_slice_eq1! { Cow<'a, [A]>, &'b [B], Clone }\n+__impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B], Clone }\n+__impl_slice_eq1! { Cow<'a, [A]>, Vec<B>, Clone }\n \n macro_rules! array_impls {\n     ($($N: expr)+) => {\n         $(\n             // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq2! { Vec<A>, [B; $N] }\n-            __impl_slice_eq2! { Vec<A>, &'b [B; $N] }\n-            // __impl_slice_eq2! { Vec<A>, &'b mut [B; $N] }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, [B; $N], Clone }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, &'b [B; $N], Clone }\n-            // __impl_slice_eq2! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n+            __impl_slice_eq1! { Vec<A>, [B; $N] }\n+            __impl_slice_eq1! { Vec<A>, &'b [B; $N] }\n+            // __impl_slice_eq1! { Vec<A>, &'b mut [B; $N] }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, [B; $N], Clone }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, &'b [B; $N], Clone }\n+            // __impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n         )+\n     }\n }"}, {"sha": "a748541fca5ce9609670271cb38276dd39000c37", "filename": "src/libcollectionstest/enum_set.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -153,19 +153,19 @@ fn test_iterator() {\n \n     e1.insert(A);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A], elems);\n+    assert_eq!(elems, [A]);\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,C], elems);\n+    assert_eq!(elems, [A,C]);\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,C], elems);\n+    assert_eq!(elems, [A,C]);\n \n     e1.insert(B);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!([A,B,C], elems);\n+    assert_eq!(elems, [A,B,C]);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -183,35 +183,35 @@ fn test_operators() {\n \n     let e_union = e1 | e2;\n     let elems: Vec<_> = e_union.iter().collect();\n-    assert_eq!([A,B,C], elems);\n+    assert_eq!(elems, [A,B,C]);\n \n     let e_intersection = e1 & e2;\n     let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!([C], elems);\n+    assert_eq!(elems, [C]);\n \n     // Another way to express intersection\n     let e_intersection = e1 - (e1 - e2);\n     let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!([C], elems);\n+    assert_eq!(elems, [C]);\n \n     let e_subtract = e1 - e2;\n     let elems: Vec<_> = e_subtract.iter().collect();\n-    assert_eq!([A], elems);\n+    assert_eq!(elems, [A]);\n \n     // Bitwise XOR of two sets, aka symmetric difference\n     let e_symmetric_diff = e1 ^ e2;\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n \n     // Another way to express symmetric difference\n     let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n \n     // Yet another way to express symmetric difference\n     let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!([A,B], elems);\n+    assert_eq!(elems, [A,B]);\n }\n \n #[test]"}, {"sha": "ef3373a359675c8ec9a5caf873722c1397bde628", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -83,7 +83,7 @@ fn test_collect() {\n fn test_into_bytes() {\n     let data = String::from_str(\"asdf\");\n     let buf = data.into_bytes();\n-    assert_eq!(b\"asdf\", buf);\n+    assert_eq!(buf, b\"asdf\");\n }\n \n #[test]"}, {"sha": "f78356fe3923c4d1867a0c03a9f4a601f92eee0b", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -821,7 +821,7 @@ fn test_as_slices() {\n \n         let (left, right) = ring.as_slices();\n         let expected: Vec<_> = (0..i+1).collect();\n-        assert_eq!(left, expected);\n+        assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n@@ -830,8 +830,8 @@ fn test_as_slices() {\n         let (left, right) = ring.as_slices();\n         let expected_left: Vec<_> = (-last..j+1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n-        assert_eq!(left, expected_left);\n-        assert_eq!(right, expected_right);\n+        assert_eq!(left, &expected_left[..]);\n+        assert_eq!(right, &expected_right[..]);\n     }\n \n     assert_eq!(ring.len() as i32, cap);\n@@ -849,7 +849,7 @@ fn test_as_mut_slices() {\n \n         let (left, right) = ring.as_mut_slices();\n         let expected: Vec<_> = (0..i+1).collect();\n-        assert_eq!(left, expected);\n+        assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n@@ -858,8 +858,8 @@ fn test_as_mut_slices() {\n         let (left, right) = ring.as_mut_slices();\n         let expected_left: Vec<_> = (-last..j+1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n-        assert_eq!(left, expected_left);\n-        assert_eq!(right, expected_right);\n+        assert_eq!(left, &expected_left[..]);\n+        assert_eq!(right, &expected_right[..]);\n     }\n \n     assert_eq!(ring.len() as i32, cap);"}, {"sha": "859cab4225eb6fcbcce032a128b00ee6bd0d0c2c", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -64,7 +64,6 @@ use option::Option::{self, Some, None};\n /// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n #[lang=\"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "95dab3d165ad3f99cfa4db8034afa5cc492b0d7d", "filename": "src/libcore/cmp_macros.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fcmp_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fcmp_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp_macros.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -15,8 +15,11 @@\n #[macro_export]\n macro_rules! __impl_slice_eq1 {\n     ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n             #[inline]\n             fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n             #[inline]\n@@ -31,13 +34,7 @@ macro_rules! __impl_slice_eq2 {\n         __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n     };\n     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n-        }\n+        __impl_slice_eq1!($Lhs, $Rhs, $Bound);\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {"}, {"sha": "1495d1d584ec9c26fb33b18bf697c1fe3340e55b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -530,10 +530,9 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let b: Vec<_> = a.iter().cloned().collect();\n-    /// assert_eq!(a, b);\n+    /// let expected = [1, 2, 3, 4, 5];\n+    /// let actual: Vec<_> = expected.iter().cloned().collect();\n+    /// assert_eq!(actual, expected);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -927,8 +926,8 @@ pub trait Iterator {\n     /// # #![feature(core)]\n     /// let a = [(1, 2), (3, 4)];\n     /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n-    /// assert_eq!([1, 3], left);\n-    /// assert_eq!([2, 4], right);\n+    /// assert_eq!(left, [1, 3]);\n+    /// assert_eq!(right, [2, 4]);\n     /// ```\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where"}, {"sha": "e8959299d722924f8af6029eefc48986cae9da72", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -66,10 +66,10 @@ macro_rules! assert {\n     );\n }\n \n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n+/// Asserts that two expressions are equal to each other.\n ///\n-/// On panic, this macro will print the values of the expressions.\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n ///\n /// # Examples\n ///\n@@ -84,10 +84,8 @@ macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n-                // check both directions of equality....\n-                if !((*left_val == *right_val) &&\n-                     (*right_val == *left_val)) {\n-                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                if !(*left_val == *right_val) {\n+                    panic!(\"assertion failed: `(left == right)` \\\n                            (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n                 }\n             }"}, {"sha": "5bc08376d257c5ceff5a7e2b1a722bbcdbc15d45", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -103,7 +103,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert_eq!([76], transmute::<_, Vec<u8>>(\"L\".to_string()));\n+        assert_eq!(transmute::<_, Vec<u8>>(\"L\".to_string()), [76]);\n     }\n }\n "}, {"sha": "a7be6a7fcf07a8550e31481b47fe8cb7049a5e40", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -446,7 +446,7 @@ mod tests {\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n         let parser = Parser::new(fmt);\n-        assert!(p == parser.collect::<Vec<Piece<'static>>>());\n+        assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n     }\n \n     fn fmtdflt() -> FormatSpec<'static> {"}, {"sha": "b0fc5fbcb50b211c541eec2ae17578c02e92cc6f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -808,12 +808,11 @@ fn walk_ty() {\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n-        assert_eq!([uniq_ty,\n-                    tup2_ty,\n-                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                    uint_ty],\n-                   walked);\n+        assert_eq!(walked, [uniq_ty,\n+                            tup2_ty,\n+                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                            uint_ty]);\n     })\n }\n "}, {"sha": "5fbc21797ab5a0442d82ebd5fc2254f54219b9fb", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -1192,7 +1192,7 @@ mod test_set {\n         };\n \n         let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+        assert!(v == ['a', 'b'] || v == ['b', 'a']);\n     }\n \n     #[test]"}, {"sha": "68aa7e4770f067e3cada0738e0256ac7381d242a", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -548,7 +548,7 @@ mod test {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n         w.write_all(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n-        assert_eq!(a, &w.get_ref()[..]);\n+        assert_eq!(&w.get_ref()[..], a);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, &w[..]);"}, {"sha": "a5ecb98334a81f1fc977e17f2ff4d021d7a7b261", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -334,7 +334,7 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n+            assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n         }\n     }\n \n@@ -343,9 +343,9 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!([0, 1], r.read_to_end().unwrap());\n+            assert_eq!(r.read_to_end().unwrap(), [0, 1]);\n         }\n-        assert_eq!([2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [2]);\n     }\n \n     #[test]\n@@ -355,7 +355,7 @@ mod test {\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!([1, 2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [1, 2]);\n         assert_eq!(0, r.limit());\n     }\n \n@@ -364,7 +364,7 @@ mod test {\n         let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n         let mut r = LimitReader::new(r.by_ref(), 1);\n         r.consume(2);\n-        assert_eq!([], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), []);\n     }\n \n     #[test]\n@@ -380,7 +380,7 @@ mod test {\n         let mut s = ZeroReader;\n         let mut buf = vec![1, 2, 3];\n         assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!([0, 0, 0], buf);\n+        assert_eq!(buf, [0, 0, 0]);\n     }\n \n     #[test]\n@@ -423,24 +423,24 @@ mod test {\n         let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n                       MemReader::new(vec!(2, 3)));\n         let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!([0, 1, 2, 3], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n-        assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n+        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n         let (_, w) = r.into_inner();\n-        assert_eq!([0, 1, 2], w);\n+        assert_eq!(w, [0, 1, 2]);\n     }\n \n     #[test]\n     fn test_copy() {\n         let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = Vec::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!([0, 1, 2, 3, 4], w);\n+        assert_eq!(w, [0, 1, 2, 3, 4]);\n     }\n \n     #[test]"}, {"sha": "67190de08c38584f1ee18faab871ad471726c31b", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -126,7 +126,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if b\"..\" == self.repr => {\n+            None if self.repr == b\"..\" => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -186,7 +186,7 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if b\"..\" == self.repr => &self.repr,\n+            None if self.repr == b\"..\" => &self.repr,\n             None => dot_static,\n             Some(0) => &self.repr[..1],\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => &self.repr,\n@@ -196,8 +196,7 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if b\".\" == self.repr ||\n-                b\"..\" == self.repr => None,\n+            None if self.repr == b\".\" || self.repr == b\"..\" => None,\n             None => Some(&self.repr),\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n@@ -207,13 +206,13 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if b\".\" == self.repr => false,\n+            None if self.repr == b\".\" => false,\n             None => {\n                 self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if b\"/\" == self.repr => false,\n+            Some(0) if self.repr == b\"/\" => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n@@ -245,7 +244,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if b\".\" == self.repr {\n+            if self.repr == b\".\" {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != b\"..\""}, {"sha": "1649934f4b10e5d4628d20e9ed26370bb9e5a7f6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -226,13 +226,13 @@ mod test {\n     fn test_move_iter() {\n         let v = SmallVector::zero();\n         let v: Vec<isize> = v.into_iter().collect();\n-        assert_eq!(Vec::new(), v);\n+        assert_eq!(v, Vec::new());\n \n         let v = SmallVector::one(1);\n-        assert_eq!([1], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!(v.into_iter().collect::<Vec<_>>(), [1]);\n \n         let v = SmallVector::many(vec![1, 2, 3]);\n-        assert_eq!([1, 2, 3], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!(v.into_iter().collect::<Vec<_>>(), [1, 2, 3]);\n     }\n \n     #[test]"}, {"sha": "0b35062b186e9227bebbbb35c022fa4454f9df5a", "filename": "src/test/run-fail/assert-eq-macro-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf126ae2f6af1cdac901f6995e3c2bab35e587f/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs?ref=5cf126ae2f6af1cdac901f6995e3c2bab35e587f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14`, right: `15`)\n+// error-pattern:assertion failed: `(left == right)` (left: `14`, right: `15`)\n \n fn main() {\n     assert_eq!(14,15);"}]}