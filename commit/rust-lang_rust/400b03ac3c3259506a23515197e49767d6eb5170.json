{"sha": "400b03ac3c3259506a23515197e49767d6eb5170", "node_id": "C_kwDOAAsO6NoAKDQwMGIwM2FjM2MzMjU5NTA2YTIzNTE1MTk3ZTQ5NzY3ZDZlYjUxNzA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-11T05:45:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-11T05:45:55Z"}, "message": "Rollup merge of #107098 - compiler-errors:pat-mismatch-fn-call, r=lcnr\n\nSuggest function call on pattern type mismatch\n\nFixes #101208\n\nThis could definitely be generalized to support more suggestions in pattern matches. We can't use all of [`FnCtxt::emit_type_mismatch_suggestions`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir_typeck/fn_ctxt/struct.FnCtxt.html#method.emit_type_mismatch_suggestions), but it's on my to-do list to play around with more suggestions that would be productive in this position.", "tree": {"sha": "a1ca1d9444fa71f889a9a554605718395f44002c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1ca1d9444fa71f889a9a554605718395f44002c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/400b03ac3c3259506a23515197e49767d6eb5170", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj5yuTCRBK7hj4Ov3rIwAA65kIAGhgHzRm8r6AOrZdWyb8JqLc\nflx1Wlm7pHMeoREI0DAH+W04CYXLDOnTo7Ja/gsvvHgSJMKNcbfzwp7YSdmQB68J\np+BdFayhG3mCzirwtw3gBL/Qw9Sjmqa247ai2CM4vyfjjrCIafeuJcp7EhEPfbZ8\nDUFNLwew4RY8zdzvPZUyqIL7OEWXNUcqFnWhVQhKj+8Ae+xkUwn15xX8a8zdv7mx\nbSWe2cL6vcwHjRsLi5+BTGVAEsi0WGLBAMskFU34pD7mQ1C1flFo9KVUJMPHhHk3\nPaB+7fjsoXfR6aJ6iNbZBYR0akz27ZSu1jilLHKKGSPUj7SIpaf+XLyGnSnWte4=\n=UFap\n-----END PGP SIGNATURE-----\n", "payload": "tree a1ca1d9444fa71f889a9a554605718395f44002c\nparent 0e8f0b03cd94d9611063daaa516af2ae3489c6b5\nparent 0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1676094355 +0530\ncommitter GitHub <noreply@github.com> 1676094355 +0530\n\nRollup merge of #107098 - compiler-errors:pat-mismatch-fn-call, r=lcnr\n\nSuggest function call on pattern type mismatch\n\nFixes #101208\n\nThis could definitely be generalized to support more suggestions in pattern matches. We can't use all of [`FnCtxt::emit_type_mismatch_suggestions`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir_typeck/fn_ctxt/struct.FnCtxt.html#method.emit_type_mismatch_suggestions), but it's on my to-do list to play around with more suggestions that would be productive in this position.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/400b03ac3c3259506a23515197e49767d6eb5170", "html_url": "https://github.com/rust-lang/rust/commit/400b03ac3c3259506a23515197e49767d6eb5170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/400b03ac3c3259506a23515197e49767d6eb5170/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e8f0b03cd94d9611063daaa516af2ae3489c6b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8f0b03cd94d9611063daaa516af2ae3489c6b5", "html_url": "https://github.com/rust-lang/rust/commit/0e8f0b03cd94d9611063daaa516af2ae3489c6b5"}, {"sha": "0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "html_url": "https://github.com/rust-lang/rust/commit/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d"}], "stats": {"total": 78, "additions": 68, "deletions": 10}, "files": [{"sha": "e19ef2ff3bf481a874445e4e18808061dce0d0b8", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // #55810: Type check patterns first so we get types for all bindings.\n         let scrut_span = scrut.span.find_ancestor_inside(expr.span).unwrap_or(scrut.span);\n         for arm in arms {\n-            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut_span), true);\n+            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut_span), Some(scrut));\n         }\n \n         // Now typecheck the blocks."}, {"sha": "cc515e6c853134c6055f251f9ebedfc5d5ec9300", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -90,7 +90,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n         // Check the pattern.\n         let ty_span = try { inputs_hir?.get(idx)?.span };\n-        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n+        fcx.check_pat_top(&param.pat, param_ty, ty_span, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings"}, {"sha": "9c7a84ce198e8fa9411fde54a60220071f9055c4", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -1330,11 +1330,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Does the expected pattern type originate from an expression and what is the span?\n         let (origin_expr, ty_span) = match (decl.ty, decl.init) {\n-            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (Some(ty), _) => (None, Some(ty.span)), // Bias towards the explicit user type.\n             (_, Some(init)) => {\n-                (true, Some(init.span.find_ancestor_inside(decl.span).unwrap_or(init.span)))\n+                (Some(init), Some(init.span.find_ancestor_inside(decl.span).unwrap_or(init.span)))\n             } // No explicit type; so use the scrutinee.\n-            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+            _ => (None, None), // We have `let $pat;`, so the expected type is unconstrained.\n         };\n \n         // Type check the pattern. Override if necessary to avoid knock-on errors."}, {"sha": "52236ae56eeaac92b5bd15c6f33eca6555940e98", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -46,7 +46,7 @@ struct TopInfo<'tcx> {\n     /// Was the origin of the `span` from a scrutinee expression?\n     ///\n     /// Otherwise there is no scrutinee and it could be e.g. from the type of a formal parameter.\n-    origin_expr: bool,\n+    origin_expr: Option<&'tcx hir::Expr<'tcx>>,\n     /// The span giving rise to the `expected` type, if one could be provided.\n     ///\n     /// If `origin_expr` is `true`, then this is the span of the scrutinee as in:\n@@ -74,7 +74,8 @@ struct TopInfo<'tcx> {\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n     fn pattern_cause(&self, ti: TopInfo<'tcx>, cause_span: Span) -> ObligationCause<'tcx> {\n-        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        let code =\n+            Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr.is_some() };\n         self.cause(cause_span, code)\n     }\n \n@@ -85,7 +86,14 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)\n+        let mut diag =\n+            self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)?;\n+        if let Some(expr) = ti.origin_expr {\n+            self.suggest_fn_call(&mut diag, expr, expected, |output| {\n+                self.can_eq(self.param_env, output, actual).is_ok()\n+            });\n+        }\n+        Some(diag)\n     }\n \n     fn demand_eqtype_pat(\n@@ -127,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         span: Option<Span>,\n-        origin_expr: bool,\n+        origin_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         let info = TopInfo { expected, origin_expr, span };\n         self.check_pat(pat, expected, INITIAL_BM, info);\n@@ -2146,7 +2154,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n         } else if self.autoderef(span, expected_ty)\n             .any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n-            && let (Some(span), true) = (ti.span, ti.origin_expr)\n+            && let Some(span) = ti.span\n+            && let Some(_) = ti.origin_expr\n             && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n         {\n             let ty = self.resolve_vars_if_possible(ti.expected);"}, {"sha": "657dd9c22c21b1a4d3c7ba3f183ea8fa1fedb321", "filename": "tests/ui/suggestions/suggest-call-on-pat-mismatch.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -0,0 +1,16 @@\n+enum E {\n+    One(i32, i32),\n+}\n+\n+fn main() {\n+    let var = E::One;\n+    if let E::One(var1, var2) = var {\n+        //~^ ERROR mismatched types\n+        //~| HELP use parentheses to construct this tuple variant\n+        println!(\"{var1} {var2}\");\n+    }\n+\n+    let Some(x) = Some;\n+    //~^ ERROR mismatched types\n+    //~| HELP use parentheses to construct this tuple variant\n+}"}, {"sha": "7338312bab651eb8ca999ff76830aa00e7c5889d", "filename": "tests/ui/suggestions/suggest-call-on-pat-mismatch.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/400b03ac3c3259506a23515197e49767d6eb5170/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/400b03ac3c3259506a23515197e49767d6eb5170/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr?ref=400b03ac3c3259506a23515197e49767d6eb5170", "patch": "@@ -0,0 +1,33 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-call-on-pat-mismatch.rs:7:12\n+   |\n+LL |     if let E::One(var1, var2) = var {\n+   |            ^^^^^^^^^^^^^^^^^^   --- this expression has type `fn(i32, i32) -> E {E::One}`\n+   |            |\n+   |            expected enum constructor, found `E`\n+   |\n+   = note: expected enum constructor `fn(i32, i32) -> E {E::One}`\n+                          found enum `E`\n+help: use parentheses to construct this tuple variant\n+   |\n+LL |     if let E::One(var1, var2) = var(/* i32 */, /* i32 */) {\n+   |                                    ++++++++++++++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-call-on-pat-mismatch.rs:13:9\n+   |\n+LL |     let Some(x) = Some;\n+   |         ^^^^^^^   ---- this expression has type `fn(_) -> Option<_> {Option::<_>::Some}`\n+   |         |\n+   |         expected enum constructor, found `Option<_>`\n+   |\n+   = note: expected enum constructor `fn(_) -> Option<_> {Option::<_>::Some}`\n+                          found enum `Option<_>`\n+help: use parentheses to construct this tuple variant\n+   |\n+LL |     let Some(x) = Some(/* value */);\n+   |                       +++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}