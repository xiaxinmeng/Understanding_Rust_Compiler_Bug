{"sha": "9cc11ca6a31e05c75cd40097b38d6f735254e12c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzExY2E2YTMxZTA1Yzc1Y2Q0MDA5N2IzOGQ2ZjczNTI1NGUxMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-28T20:46:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-28T20:46:11Z"}, "message": "auto merge of #9577 : alexcrichton/rust/rustdoc, r=cmr\n\nThey're getting smaller each time though!\r\n\r\nThe highlight of this round is source files in documentation. Still trying to figure out the best syntax-highlighting solution.", "tree": {"sha": "e29b8ff7c90a6888373fe052a888109d64d03297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e29b8ff7c90a6888373fe052a888109d64d03297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc11ca6a31e05c75cd40097b38d6f735254e12c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc11ca6a31e05c75cd40097b38d6f735254e12c", "html_url": "https://github.com/rust-lang/rust/commit/9cc11ca6a31e05c75cd40097b38d6f735254e12c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc11ca6a31e05c75cd40097b38d6f735254e12c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c635fba748ace3ad08b97d9ca53366dadabf2028", "url": "https://api.github.com/repos/rust-lang/rust/commits/c635fba748ace3ad08b97d9ca53366dadabf2028", "html_url": "https://github.com/rust-lang/rust/commit/c635fba748ace3ad08b97d9ca53366dadabf2028"}, {"sha": "88866a4c20ebe150b9b72dc361653922f7d497dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88866a4c20ebe150b9b72dc361653922f7d497dd", "html_url": "https://github.com/rust-lang/rust/commit/88866a4c20ebe150b9b72dc361653922f7d497dd"}], "stats": {"total": 449, "additions": 313, "deletions": 136}, "files": [{"sha": "2839106ab8090e1f8dd5831a1d475fa375f99edb", "filename": "mk/docs.mk", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -217,10 +217,6 @@ endif\n # Rustdoc (libstd/extra)\n ######################################################################\n \n-ifeq ($(CFG_PANDOC),)\n-  $(info cfg: no pandoc found, omitting library doc build)\n-else\n-\n # The rustdoc executable\n RUSTDOC = $(HBIN2_H_$(CFG_BUILD_TRIPLE))/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n \n@@ -238,7 +234,6 @@ endef\n \n $(eval $(call libdoc,std,$(STDLIB_CRATE),$(CFG_BUILD_TRIPLE)))\n $(eval $(call libdoc,extra,$(EXTRALIB_CRATE),$(CFG_BUILD_TRIPLE)))\n-endif\n \n \n ifdef CFG_DISABLE_DOCS"}, {"sha": "b4b086f3df0bc1c4a41de9b2423bd50c0245b398", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -84,7 +84,7 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Item {\n     /// Stringified span\n-    source: ~str,\n+    source: Span,\n     /// Not everything has a name. E.g., impls\n     name: Option<~str>,\n     attrs: ~[Attribute],\n@@ -539,9 +539,11 @@ impl Clean<TraitMethod> for ast::trait_method {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::ty_path)\n-    ResolvedPath { path: Path, typarams: Option<~[TyParamBound]>, id: ast::NodeId },\n-    /// Reference to an item in an external crate (fully qualified path)\n-    External(~str, ~str),\n+    ResolvedPath {\n+        path: Path,\n+        typarams: Option<~[TyParamBound]>,\n+        did: ast::DefId\n+    },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n     /// For parameterized types, so the consumer of the JSON don't go looking\n@@ -736,10 +738,28 @@ impl Clean<VariantKind> for ast::variant_kind {\n     }\n }\n \n-impl Clean<~str> for syntax::codemap::Span {\n-    fn clean(&self) -> ~str {\n-        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap;\n-        cm.span_to_str(*self)\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Span {\n+    filename: ~str,\n+    loline: uint,\n+    locol: uint,\n+    hiline: uint,\n+    hicol: uint,\n+}\n+\n+impl Clean<Span> for syntax::codemap::Span {\n+    fn clean(&self) -> Span {\n+        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        let filename = cm.span_to_filename(*self);\n+        let lo = cm.lookup_char_pos(self.lo);\n+        let hi = cm.lookup_char_pos(self.hi);\n+        Span {\n+            filename: filename.to_owned(),\n+            loline: lo.line,\n+            locol: *lo.col,\n+            hiline: hi.line,\n+            hicol: *hi.col,\n+        }\n     }\n }\n \n@@ -1033,7 +1053,7 @@ trait ToSource {\n \n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n-        debug!(\"converting span %s to snippet\", self.clean());\n+        debug!(\"converting span %? to snippet\", self.clean());\n         let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n@@ -1129,39 +1149,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         },\n         x => fail!(\"resolved type maps to a weird def %?\", x),\n     };\n-\n-    if def_id.crate != ast::CRATE_NODE_ID {\n-        use rustc::metadata::decoder::*;\n-\n-        let sess = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess;\n-        let cratedata = ::rustc::metadata::cstore::get_crate_data(sess.cstore, def_id.crate);\n-        let doc = lookup_item(def_id.node, cratedata.data);\n-        let path = syntax::ast_map::path_to_str_with_sep(item_path(doc), \"::\", sess.intr());\n-        let ty = match def_like_to_def(item_to_def_like(doc, def_id, def_id.crate)) {\n-            DefFn(*) => ~\"fn\",\n-            DefTy(*) => ~\"enum\",\n-            DefTrait(*) => ~\"trait\",\n-            DefPrimTy(p) => match p {\n-                ty_str => ~\"str\",\n-                ty_bool => ~\"bool\",\n-                ty_int(t) => match t.to_str() {\n-                    ~\"\" => ~\"i\",\n-                    s => s\n-                },\n-                ty_uint(t) => t.to_str(),\n-                ty_float(t) => t.to_str(),\n-                ty_char => ~\"char\",\n-            },\n-            DefTyParam(*) => ~\"generic\",\n-            DefStruct(*) => ~\"struct\",\n-            DefTyParamBinder(*) => ~\"typaram_binder\",\n-            x => fail!(\"resolved external maps to a weird def %?\", x),\n-        };\n-        let cname = cratedata.name.to_owned();\n-        External(cname + \"::\" + path, ty)\n-    } else {\n-        ResolvedPath {path: path.clone(), typarams: tpbs, id: def_id.node}\n-    }\n+    ResolvedPath{ path: path, typarams: tpbs, did: def_id }\n }\n \n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {"}, {"sha": "076d43e2c127cf1c2ff8f1d7dd532712134057d0", "filename": "src/librustdoc/html/escape.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+pub struct Escape<'self>(&'self str);\n+\n+impl<'self> fmt::Default for Escape<'self> {\n+    fn fmt(s: &Escape<'self>, fmt: &mut fmt::Formatter) {\n+        // Because the internet is always right, turns out there's not that many\n+        // characters to escape: http://stackoverflow.com/questions/7381974\n+        let pile_o_bits = s.as_slice();\n+        let mut last = 0;\n+        for (i, ch) in s.byte_iter().enumerate() {\n+            match ch as char {\n+                '<' | '>' | '&' | '\\'' | '\"' => {\n+                    fmt.buf.write(pile_o_bits.slice(last, i).as_bytes());\n+                    let s = match ch as char {\n+                        '>' => \"&gt;\",\n+                        '<' => \"&lt;\",\n+                        '&' => \"&amp;\",\n+                        '\\'' => \"&#39;\",\n+                        '\"' => \"&quot;\",\n+                        _ => unreachable!()\n+                    };\n+                    fmt.buf.write(s.as_bytes());\n+                    last = i + 1;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        if last < s.len() {\n+            fmt.buf.write(pile_o_bits.slice_from(last).as_bytes());\n+        }\n+    }\n+}"}, {"sha": "66796252770d4adb04048d016657f25cb40c68db", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -97,7 +97,7 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n-fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n+fn resolved_path(w: &mut io::Writer, did: ast::DefId,\n                  path: &clean::Path, print_all: bool) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n@@ -144,9 +144,10 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n \n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n-                match cache.paths.find(&id) {\n+                match cache.paths.find(&did.node) {\n                     // This is a documented path, link to it!\n-                    Some(&(ref fqp, shortty)) => {\n+                    // FIXME(#9539): this is_local check should not exist\n+                    Some(&(ref fqp, shortty)) if ast_util::is_local(did) => {\n                         let fqn = fqp.connect(\"::\");\n                         let same = loc.iter().zip(fqp.iter())\n                                       .take_while(|&(a, b)| *a == *b).len();\n@@ -180,7 +181,7 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n                         write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>{}\",\n                                shortty, url, fqn, last.name, generics);\n                     }\n-                    None => {\n+                    _ => {\n                         if print_all {\n                             let amt = path.segments.len() - 1;\n                             for seg in path.segments.iter().take(amt) {\n@@ -205,8 +206,8 @@ impl fmt::Default for clean::Type {\n                     }\n                 }\n             }\n-            clean::ResolvedPath{id, typarams: ref typarams, path: ref path} => {\n-                resolved_path(f.buf, id, path, false);\n+            clean::ResolvedPath{did, typarams: ref typarams, path: ref path} => {\n+                resolved_path(f.buf, did, path, false);\n                 match *typarams {\n                     Some(ref params) => {\n                         f.buf.write(\"&lt;\".as_bytes());\n@@ -219,10 +220,6 @@ impl fmt::Default for clean::Type {\n                     None => {}\n                 }\n             }\n-            // XXX: this should be a link\n-            clean::External(ref a, _) => {\n-                write!(f.buf, \"{}\", *a);\n-            }\n             clean::Self(*) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n@@ -421,8 +418,8 @@ impl fmt::Default for clean::ViewPath {\n impl fmt::Default for clean::ImportSource {\n     fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n         match v.did {\n-            Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true);\n+            Some(did) => {\n+                resolved_path(f.buf, did, &v.path, true);\n             }\n             _ => {\n                 for (i, seg) in v.path.segments.iter().enumerate() {\n@@ -437,7 +434,7 @@ impl fmt::Default for clean::ImportSource {\n impl fmt::Default for clean::ViewListIdent {\n     fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n         match v.source {\n-            Some(did) if ast_util::is_local(did) => {\n+            Some(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n@@ -446,7 +443,7 @@ impl fmt::Default for clean::ViewListIdent {\n                         types: ~[],\n                     }]\n                 };\n-                resolved_path(f.buf, did.node, &path, false);\n+                resolved_path(f.buf, did, &path, false);\n             }\n             _ => write!(f.buf, \"{}\", v.name),\n         }"}, {"sha": "d29bf5ed55b587384ac92e7e92102e242a3c33c6", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -66,7 +66,8 @@ pub fn render<T: fmt::Default, S: fmt::Default>(\n         </form>\n     </nav>\n \n-    <section class=\\\"content {ty}\\\">{content}</section>\n+    <section id='main' class=\\\"content {ty}\\\">{content}</section>\n+    <section id='search' class=\\\"content hidden\\\"></section>\n \n     <section class=\\\"footer\\\"></section>\n "}, {"sha": "4702cb0f73d86c4d61f150fcf162ab42f63023e3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 166, "deletions": 58, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -12,12 +12,14 @@ use std::cell::Cell;\n use std::comm::{SharedPort, SharedChan};\n use std::comm;\n use std::fmt;\n-use std::hashmap::HashMap;\n+use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::rt::io::buffered::BufferedWriter;\n use std::rt::io::file::{FileInfo, DirectoryInfo};\n use std::rt::io::file;\n use std::rt::io;\n+use std::rt::io::Reader;\n+use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n use std::util;\n@@ -28,11 +30,13 @@ use extra::json::ToJson;\n use extra::sort;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n use syntax::attr;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n+use html::escape::Escape;\n use html::format::{VisSpace, Method, PuritySpace};\n use html::layout;\n use html::markdown::Markdown;\n@@ -44,6 +48,7 @@ pub struct Context {\n     dst: Path,\n     layout: layout::Layout,\n     sidebar: HashMap<~str, ~[~str]>,\n+    include_sources: bool,\n }\n \n enum Implementor {\n@@ -68,6 +73,12 @@ struct Cache {\n     priv search_index: ~[IndexItem],\n }\n \n+struct SourceCollector<'self> {\n+    seen: HashSet<~str>,\n+    dst: Path,\n+    cx: &'self Context,\n+}\n+\n struct Item<'self> { cx: &'self Context, item: &'self clean::Item, }\n struct Sidebar<'self> { cx: &'self Context, item: &'self clean::Item, }\n \n@@ -79,6 +90,8 @@ struct IndexItem {\n     parent: Option<ast::NodeId>,\n }\n \n+struct Source<'self>(&'self str);\n+\n local_data_key!(pub cache_key: RWArc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n@@ -94,6 +107,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n             favicon: ~\"\",\n             crate: crate.name.clone(),\n         },\n+        include_sources: true,\n     };\n     mkdir(&cx.dst);\n \n@@ -107,6 +121,9 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n                     clean::NameValue(~\"html_logo_url\", ref s) => {\n                         cx.layout.logo = s.to_owned();\n                     }\n+                    clean::Word(~\"html_no_source\") => {\n+                        cx.include_sources = false;\n+                    }\n                     _ => {}\n                 }\n             }\n@@ -162,6 +179,19 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         w.flush();\n     }\n \n+    if cx.include_sources {\n+        let dst = cx.dst.push(\"src\");\n+        mkdir(&dst);\n+        let dst = dst.push(crate.name);\n+        mkdir(&dst);\n+        let mut folder = SourceCollector {\n+            dst: dst,\n+            seen: HashSet::new(),\n+            cx: &cx,\n+        };\n+        crate = folder.fold_crate(crate);\n+    }\n+\n     // Now render the whole crate.\n     cx.crate(crate, cache);\n }\n@@ -183,7 +213,80 @@ fn mkdir(path: &Path) {\n     }\n }\n \n-impl<'self> DocFolder for Cache {\n+fn clean_srcpath(src: &str, f: &fn(&str)) {\n+    let p = Path(src);\n+    for c in p.components.iter() {\n+        if \".\" == *c {\n+            loop\n+        }\n+        if \"..\" == *c {\n+            f(\"up\");\n+        } else {\n+            f(c.as_slice())\n+        }\n+    }\n+}\n+\n+impl<'self> DocFolder for SourceCollector<'self> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if !self.seen.contains(&item.source.filename) {\n+            self.emit_source(item.source.filename);\n+            self.seen.insert(item.source.filename.clone());\n+        }\n+        self.fold_item_recur(item)\n+    }\n+}\n+\n+impl<'self> SourceCollector<'self> {\n+    fn emit_source(&self, filename: &str) {\n+        let p = Path(filename);\n+\n+        // Read the contents of the file\n+        let mut contents = ~[];\n+        {\n+            let mut buf = [0, ..1024];\n+            let r = do io::io_error::cond.trap(|_| {}).inside {\n+                p.open_reader(io::Open)\n+            };\n+            // If we couldn't open this file, then just returns because it\n+            // probably means that it's some standard library macro thing and we\n+            // can't have the source to it anyway.\n+            let mut r = match r { Some(r) => r, None => return };\n+\n+            // read everything\n+            loop {\n+                match r.read(buf) {\n+                    Some(n) => contents.push_all(buf.slice_to(n)),\n+                    None => break\n+                }\n+            }\n+        }\n+        let contents = str::from_utf8_owned(contents);\n+\n+        // Create the intermediate directories\n+        let mut cur = self.dst.clone();\n+        let mut root_path = ~\"../../\";\n+        do clean_srcpath(p.pop().to_str()) |component| {\n+            cur = cur.push(component);\n+            mkdir(&cur);\n+            root_path.push_str(\"../\");\n+        }\n+\n+        let dst = cur.push(*p.components.last() + \".html\");\n+        let mut w = dst.open_writer(io::CreateOrTruncate);\n+\n+        let title = format!(\"{} -- source\", *dst.components.last());\n+        let page = layout::Page {\n+            title: title,\n+            ty: \"source\",\n+            root_path: root_path,\n+        };\n+        layout::render(&mut w as &mut io::Writer, &self.cx.layout,\n+                       &page, &(\"\"), &Source(contents.as_slice()));\n+    }\n+}\n+\n+impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types\n@@ -223,7 +326,8 @@ impl<'self> DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    Some(clean::ResolvedPath{ id, _ }) => {\n+                    Some(clean::ResolvedPath{ did, _ }) if is_local(did) => {\n+                        let id = did.node;\n                         let v = do self.implementors.find_or_insert_with(id) |_|{\n                             ~[]\n                         };\n@@ -248,7 +352,9 @@ impl<'self> DocFolder for Cache {\n         match item.name {\n             Some(ref s) => {\n                 let parent = match item.inner {\n-                    clean::TyMethodItem(*) | clean::VariantItem(*) => {\n+                    clean::TyMethodItem(*) |\n+                    clean::StructFieldItem(*) |\n+                    clean::VariantItem(*) => {\n                         Some((Some(*self.parent_stack.last()),\n                               self.stack.slice_to(self.stack.len() - 1)))\n \n@@ -257,8 +363,12 @@ impl<'self> DocFolder for Cache {\n                         if self.parent_stack.len() == 0 {\n                             None\n                         } else {\n-                            Some((Some(*self.parent_stack.last()),\n-                                  self.stack.as_slice()))\n+                            let last = self.parent_stack.last();\n+                            let amt = match self.paths.find(last) {\n+                                Some(&(_, \"trait\")) => self.stack.len() - 1,\n+                                Some(*) | None => self.stack.len(),\n+                            };\n+                            Some((Some(*last), self.stack.slice_to(amt)))\n                         }\n                     }\n                     _ => Some((None, self.stack.as_slice()))\n@@ -299,13 +409,13 @@ impl<'self> DocFolder for Cache {\n \n         // Maintain the parent stack\n         let parent_pushed = match item.inner {\n-            clean::TraitItem(*) | clean::EnumItem(*) => {\n+            clean::TraitItem(*) | clean::EnumItem(*) | clean::StructItem(*) => {\n                 self.parent_stack.push(item.id); true\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n-                    clean::ResolvedPath{ id, _ } => {\n-                        self.parent_stack.push(id); true\n+                    clean::ResolvedPath{ did, _ } if is_local(did) => {\n+                        self.parent_stack.push(did.node); true\n                     }\n                     _ => false\n                 }\n@@ -320,7 +430,8 @@ impl<'self> DocFolder for Cache {\n                 match item.inner {\n                     clean::ImplItem(i) => {\n                         match i.for_ {\n-                            clean::ResolvedPath { id, _ } => {\n+                            clean::ResolvedPath { did, _ } if is_local(did) => {\n+                                let id = did.node;\n                                 let v = do self.impls.find_or_insert_with(id) |_| {\n                                     ~[]\n                                 };\n@@ -374,7 +485,6 @@ impl Context {\n         return ret;\n     }\n \n-    /// Processes\n     fn crate(self, mut crate: clean::Crate, cache: Cache) {\n         enum Work {\n             Die,\n@@ -510,28 +620,6 @@ impl Context {\n                 let dst = self.dst.push(item_path(&item));\n                 let writer = dst.open_writer(io::CreateOrTruncate);\n                 render(writer.unwrap(), self, &item, true);\n-\n-                // recurse if necessary\n-                let name = item.name.get_ref().clone();\n-                match item.inner {\n-                    clean::EnumItem(e) => {\n-                        let mut it = e.variants.move_iter();\n-                        do self.recurse(name) |this| {\n-                            for item in it {\n-                                f(this, item);\n-                            }\n-                        }\n-                    }\n-                    clean::StructItem(s) => {\n-                        let mut it = s.fields.move_iter();\n-                        do self.recurse(name) |this| {\n-                            for item in it {\n-                                f(this, item);\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n             }\n \n             _ => {}\n@@ -581,6 +669,20 @@ impl<'self> fmt::Default for Item<'self> {\n             None => {}\n         }\n \n+        if it.cx.include_sources {\n+            let mut path = ~[];\n+            do clean_srcpath(it.item.source.filename) |component| {\n+                path.push(component.to_owned());\n+            }\n+            write!(fmt.buf,\n+                   \"<a class='source'\n+                       href='{root}src/{crate}/{path}.html\\\\#{line}'>[src]</a>\",\n+                   root = it.cx.root_path,\n+                   crate = it.cx.layout.crate,\n+                   path = path.connect(\"/\"),\n+                   line = it.item.source.loline);\n+        }\n+\n         // Write the breadcrumb trail header for the top\n         write!(fmt.buf, \"<h1 class='fqn'>\");\n         match it.item.inner {\n@@ -613,9 +715,6 @@ impl<'self> fmt::Default for Item<'self> {\n             clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n-            clean::VariantItem(*) => item_variant(fmt.buf, it.cx, it.item),\n-            clean::StructFieldItem(*) => item_struct_field(fmt.buf, it.cx,\n-                                                           it.item),\n             _ => {}\n         }\n     }\n@@ -862,7 +961,8 @@ fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n     document(w, it);\n \n     fn meth(w: &mut io::Writer, m: &clean::TraitMethod) {\n-        write!(w, \"<h3 id='fn.{}' class='method'><code>\",\n+        write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n+               shortty(m.item()),\n                *m.item().name.get_ref());\n         render_method(w, m.item(), false);\n         write!(w, \"</code></h3>\");\n@@ -923,13 +1023,15 @@ fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n            withlink: bool) {\n         write!(w, \"{}fn {withlink, select,\n-                            true{<a href='\\\\#fn.{name}' class='fnname'>{name}</a>}\n+                            true{<a href='\\\\#{ty}.{name}'\n+                                    class='fnname'>{name}</a>}\n                             other{<span class='fnname'>{name}</span>}\n                         }{generics}{decl}\",\n                match purity {\n                    ast::unsafe_fn => \"unsafe \",\n                    _ => \"\",\n                },\n+               ty = shortty(it),\n                name = it.name.get_ref().as_slice(),\n                generics = *g,\n                decl = Method(selfty, d),\n@@ -1014,7 +1116,7 @@ fn render_struct(w: &mut io::Writer, it: &clean::Item,\n             for field in fields.iter() {\n                 match field.inner {\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"    {}<a name='field.{name}'>{name}</a>: \\\n+                        write!(w, \"    {}<a name='structfield.{name}'>{name}</a>: \\\n                                    {},\\n{}\",\n                                VisSpace(field.visibility),\n                                ty.type_,\n@@ -1080,7 +1182,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n         Some(ref ty) => {\n             write!(w, \"{} for \", *ty);\n             match *ty {\n-                clean::ResolvedPath { id, _ } => Some(id),\n+                clean::ResolvedPath { did, _ } => Some(did),\n                 _ => None,\n             }\n         }\n@@ -1089,7 +1191,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n     write!(w, \"{}</code></h3>\", i.for_);\n     write!(w, \"<div class='methods'>\");\n     for meth in i.methods.iter() {\n-        write!(w, \"<h4 id='fn.{}' class='method'><code>\",\n+        write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                *meth.name.get_ref());\n         render_method(w, meth, false);\n         write!(w, \"</code></h4>\\n\");\n@@ -1102,7 +1204,11 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n         }\n \n         // No documentation? Attempt to slurp in the trait's documentation\n-        let trait_id = match trait_id { Some(id) => id, None => loop };\n+        let trait_id = match trait_id {\n+            None => loop,\n+            Some(id) if is_local(id) => loop,\n+            Some(id) => id.node,\n+        };\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n                 let name = meth.name.get_ref().as_slice();\n@@ -1198,20 +1304,22 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     return map;\n }\n \n-fn item_variant(w: &mut io::Writer, cx: &Context, it: &clean::Item) {\n-    write!(w, \"<DOCTYPE html><html><head>\\\n-                <meta http-equiv='refresh' content='0; \\\n-                      url=../enum.{}.html\\\\#variant.{}'>\\\n-               </head><body></body></html>\",\n-           *cx.current.last(),\n-           it.name.get_ref().as_slice());\n-}\n-\n-fn item_struct_field(w: &mut io::Writer, cx: &Context, it: &clean::Item) {\n-    write!(w, \"<DOCTYPE html><html><head>\\\n-                <meta http-equiv='refresh' content='0; \\\n-                      url=../struct.{}.html\\\\#field.{}'>\\\n-               </head><body></body></html>\",\n-           *cx.current.last(),\n-           it.name.get_ref().as_slice());\n+impl<'self> fmt::Default for Source<'self> {\n+    fn fmt(s: &Source<'self>, fmt: &mut fmt::Formatter) {\n+        let lines = s.line_iter().len();\n+        let mut cols = 0;\n+        let mut tmp = lines;\n+        while tmp > 0 {\n+            cols += 1;\n+            tmp /= 10;\n+        }\n+        write!(fmt.buf, \"<pre class='line-numbers'>\");\n+        for i in range(1, lines + 1) {\n+            write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols);\n+        }\n+        write!(fmt.buf, \"</pre>\");\n+        write!(fmt.buf, \"<pre class='rust'>\");\n+        write!(fmt.buf, \"{}\", Escape(s.as_slice()));\n+        write!(fmt.buf, \"</pre>\");\n+    }\n }"}, {"sha": "2366a530a877c1c1872f748114a32b0730a7f329", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -119,6 +119,9 @@ body {\n .content h1, .content h2 { margin-left: -20px; }\n .content pre { padding: 20px; }\n \n+.content pre.line-numbers { float: left; border: none; }\n+.line-numbers span { color: #c67e2d; }\n+\n .content .highlighted {\n     cursor: pointer;\n     color: #000 !important;"}, {"sha": "bf9e9ac8027b9113503905d4f9f40b9b86755a58", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -39,9 +39,15 @@\n         if (e.keyCode === 188 && $('#help').hasClass('hidden')) { // question mark\n             e.preventDefault();\n             $('#help').removeClass('hidden');\n-        } else if (e.keyCode === 27 && !$('#help').hasClass('hidden')) { // esc\n-            e.preventDefault();\n-            $('#help').addClass('hidden');\n+        } else if (e.keyCode === 27) { // esc\n+            if (!$('#help').hasClass('hidden')) {\n+                e.preventDefault();\n+                $('#help').addClass('hidden');\n+            } else if (!$('#search').hasClass('hidden')) {\n+                e.preventDefault();\n+                $('#search').addClass('hidden');\n+                $('#main').removeClass('hidden');\n+            }\n         } else if (e.keyCode === 83) { // S\n             e.preventDefault();\n             $('.search-input').focus();\n@@ -202,7 +208,13 @@\n             var hoverTimeout, $results = $('.search-results .result');\n \n             $results.on('click', function () {\n-                document.location.href = $(this).find('a').prop('href');\n+                var dst = $(this).find('a')[0];\n+                console.log(window.location.pathname, dst.pathname);\n+                if (window.location.pathname == dst.pathname) {\n+                    $('#search').addClass('hidden');\n+                    $('#main').removeClass('hidden');\n+                }\n+                document.location.href = dst.href;\n             }).on('mouseover', function () {\n                 var $el = $(this);\n                 clearTimeout(hoverTimeout);\n@@ -265,25 +277,52 @@\n                     output += '<tr class=\"' + type + ' result\"><td>';\n \n                     if (type === 'mod') {\n-                        output += item.path + '::<a href=\"' + rootPath + item.path.replace(/::/g, '/') + '/' + name + '/index.html\" class=\"' + type + '\">' + name + '</a>';\n+                        output += item.path +\n+                            '::<a href=\"' + rootPath +\n+                                            item.path.replace(/::/g, '/') + '/' +\n+                                            name + '/index.html\" class=\"' +\n+                                            type + '\">' + name + '</a>';\n                     } else if (type === 'static' || type === 'reexport') {\n-                        output += item.path + '::<a href=\"' + rootPath + item.path.replace(/::/g, '/') + '/index.html\" class=\"' + type + '\">' + name + '</a>';\n+                        output += item.path +\n+                            '::<a href=\"' + rootPath +\n+                                            item.path.replace(/::/g, '/') +\n+                                            '/index.html\" class=\"' + type +\n+                                            '\">' + name + '</a>';\n                     } else if (item.parent !== undefined) {\n                         var myparent = allPaths[item.parent];\n-                        output += item.path + '::' + myparent.name + '::<a href=\"' + rootPath + item.path.replace(/::/g, '/') + '/' + myparent.type + '.' + myparent.name + '.html\" class=\"' + type + '\">' + name + '</a>';\n+                        var anchor = '#' + type + '.' + name;\n+                        output += item.path + '::' + myparent.name +\n+                            '::<a href=\"' + rootPath +\n+                                            item.path.replace(/::/g, '/') +\n+                                            '/' + myparent.type +\n+                                            '.' + myparent.name +\n+                                            '.html' + anchor +\n+                                            '\" class=\"' + type +\n+                                            '\">' + name + '</a>';\n                     } else {\n-                        output += item.path + '::<a href=\"' + rootPath + item.path.replace(/::/g, '/') + '/' + type + '.' + name + '.html\" class=\"' + type + '\">' + name + '</a>';\n+                        output += item.path +\n+                            '::<a href=\"' + rootPath +\n+                                            item.path.replace(/::/g, '/') +\n+                                            '/' + type +\n+                                            '.' + name +\n+                                            '.html\" class=\"' + type +\n+                                            '\">' + name + '</a>';\n                     }\n \n-                    output += '</td><td><span class=\"desc\">' + item.desc + '</span></td></tr>';\n+                    output += '</td><td><span class=\"desc\">' + item.desc +\n+                                    '</span></td></tr>';\n                 });\n             } else {\n-                output += 'No results :( <a href=\"https://duckduckgo.com/?q=' + encodeURIComponent('rust ' + query.query) + '\">Try on DuckDuckGo?</a>';\n+                output += 'No results :( <a href=\"https://duckduckgo.com/?q=' +\n+                            encodeURIComponent('rust ' + query.query) +\n+                            '\">Try on DuckDuckGo?</a>';\n             }\n \n             output += \"</p>\";\n-            $('.content').html(output);\n-            $('.search-results .desc').width($('.content').width() - 40 - $('.content td:first-child').first().width());\n+            $('#main.content').addClass('hidden');\n+            $('#search.content').removeClass('hidden').html(output);\n+            $('.search-results .desc').width($('.content').width() - 40 -\n+                    $('.content td:first-child').first().width());\n             initSearchNav();\n         }\n "}, {"sha": "bbb20b31272ad8b9cf03707416d1612841d76e7b", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -13,6 +13,7 @@ use std::uint;\n use std::hashmap::HashSet;\n \n use syntax::ast;\n+use syntax::ast_util::is_local;\n \n use clean;\n use clean::Item;\n@@ -130,8 +131,8 @@ pub fn strip_private(mut crate: clean::Crate) -> plugins::PluginResult {\n             match i.inner {\n                 clean::ImplItem(ref imp) => {\n                     match imp.trait_ {\n-                        Some(clean::ResolvedPath{ id, _ }) => {\n-                            if !self.contains(&id) {\n+                        Some(clean::ResolvedPath{ did, _ }) => {\n+                            if is_local(did) && !self.contains(&did.node) {\n                                 return None;\n                             }\n                         }"}, {"sha": "2405acd76b6cb172fb58901552f4fdd7f575e80b", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc11ca6a31e05c75cd40097b38d6f735254e12c/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=9cc11ca6a31e05c75cd40097b38d6f735254e12c", "patch": "@@ -34,10 +34,11 @@ pub mod core;\n pub mod doctree;\n pub mod fold;\n pub mod html {\n-    pub mod render;\n+    pub mod escape;\n+    pub mod format;\n     pub mod layout;\n     pub mod markdown;\n-    pub mod format;\n+    pub mod render;\n }\n pub mod passes;\n pub mod plugins;"}]}