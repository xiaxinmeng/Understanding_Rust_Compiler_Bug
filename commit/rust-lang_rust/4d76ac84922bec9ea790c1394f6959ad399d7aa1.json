{"sha": "4d76ac84922bec9ea790c1394f6959ad399d7aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNzZhYzg0OTIyYmVjOWVhNzkwYzEzOTRmNjk1OWFkMzk5ZDdhYTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-29T22:00:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-10-02T21:52:30Z"}, "message": "Move platform-specific arg handling to sys::args", "tree": {"sha": "17f2debbe4a921dcfc47cfd13e7f1dc56886d77b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17f2debbe4a921dcfc47cfd13e7f1dc56886d77b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d76ac84922bec9ea790c1394f6959ad399d7aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d76ac84922bec9ea790c1394f6959ad399d7aa1", "html_url": "https://github.com/rust-lang/rust/commit/4d76ac84922bec9ea790c1394f6959ad399d7aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d76ac84922bec9ea790c1394f6959ad399d7aa1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e0235415a42299e4a7467c5edb09a159ec680e", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e0235415a42299e4a7467c5edb09a159ec680e", "html_url": "https://github.com/rust-lang/rust/commit/29e0235415a42299e4a7467c5edb09a159ec680e"}], "stats": {"total": 576, "additions": 294, "deletions": 282}, "files": [{"sha": "e29dbe35c5a59a242c592fd0dc0c3c3c5adb47ab", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -21,6 +21,7 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n+use sys;\n use sys::os as os_imp;\n \n /// Returns the current working directory as a `PathBuf`.\n@@ -557,7 +558,7 @@ pub struct Args { inner: ArgsOs }\n ///\n /// This structure is created through the `std::env::args_os` method.\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct ArgsOs { inner: os_imp::Args }\n+pub struct ArgsOs { inner: sys::args::Args }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n@@ -606,7 +607,7 @@ pub fn args() -> Args {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn args_os() -> ArgsOs {\n-    ArgsOs { inner: os_imp::args() }\n+    ArgsOs { inner: sys::args::args() }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]"}, {"sha": "78d5aa597ba0df01f33a1ae000f70bc9414b7b2a", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -51,7 +51,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         thread_info::set(main_guard, thread);\n \n         // Store our args if necessary in a squirreled away location\n-        sys_common::args::init(argc, argv);\n+        sys::args::init(argc, argv);\n \n         // Let's run some code!\n         let res = panic::catch_unwind(mem::transmute::<_, fn()>(main));"}, {"sha": "b5330463e30c475cdfc45ed19b99dcf8854d6d9c", "filename": "src/libstd/sys/common/args.rs", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -1,100 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Global storage for command line arguments\n-//!\n-//! The current incarnation of the Rust runtime expects for\n-//! the processes `argc` and `argv` arguments to be stored\n-//! in a globally-accessible location for use by the `os` module.\n-//!\n-//! Only valid to call on Linux. Mac and Windows use syscalls to\n-//! discover the command line arguments.\n-//!\n-//! FIXME #7756: Would be nice for this to not exist.\n-\n-#![allow(dead_code)] // different code on OSX/linux/etc\n-\n-/// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n-\n-/// Make a clone of the global arguments.\n-pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\",\n-          target_os = \"emscripten\",\n-          target_os = \"haiku\"))]\n-mod imp {\n-    use libc::c_char;\n-    use mem;\n-    use ffi::CStr;\n-\n-    use sys_common::mutex::Mutex;\n-\n-    static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: Mutex = Mutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let args = (0..argc).map(|i| {\n-            CStr::from_ptr(*argv.offset(i) as *const c_char).to_bytes().to_vec()\n-        }).collect();\n-\n-        LOCK.lock();\n-        let ptr = get_global_ptr();\n-        assert!((*ptr).is_none());\n-        (*ptr) = Some(box args);\n-        LOCK.unlock();\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        LOCK.lock();\n-        *get_global_ptr() = None;\n-        LOCK.unlock();\n-    }\n-\n-    pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        unsafe {\n-            LOCK.lock();\n-            let ptr = get_global_ptr();\n-            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n-            LOCK.unlock();\n-            return ret\n-        }\n-    }\n-\n-    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n-        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n-    }\n-\n-}\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"windows\"))]\n-mod imp {\n-    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n-    }\n-\n-    pub fn cleanup() {\n-    }\n-\n-    pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        panic!()\n-    }\n-}"}, {"sha": "2845f895f1869e30a174b6f3fde86c6ade9f73fd", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -25,7 +25,6 @@ macro_rules! rtassert {\n     })\n }\n \n-pub mod args;\n pub mod at_exit_imp;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n@@ -92,7 +91,7 @@ pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n pub fn cleanup() {\n     static CLEANUP: Once = Once::new();\n     CLEANUP.call_once(|| unsafe {\n-        args::cleanup();\n+        sys::args::cleanup();\n         sys::stack_overflow::cleanup();\n         at_exit_imp::cleanup();\n     });"}, {"sha": "c64db333e5106aee09df833b2a806ff9523a5a91", "filename": "src/libstd/sys/unix/args.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Global initialization and retreival of command line arguments.\n+//!\n+//! On some platforms these are stored during runtime startup,\n+//! and on some they are retrieved from the system on demand.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use ffi::OsString;\n+use marker::PhantomData;\n+use vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"android\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"netbsd\",\n+          target_os = \"openbsd\",\n+          target_os = \"solaris\",\n+          target_os = \"emscripten\",\n+          target_os = \"haiku\"))]\n+mod imp {\n+    use os::unix::prelude::*;\n+    use mem;\n+    use ffi::{CStr, OsString};\n+    use marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    use sys_common::mutex::Mutex;\n+\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let args = (0..argc).map(|i| {\n+            CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n+        }).collect();\n+\n+        LOCK.lock();\n+        let ptr = get_global_ptr();\n+        assert!((*ptr).is_none());\n+        (*ptr) = Some(box args);\n+        LOCK.unlock();\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        LOCK.lock();\n+        *get_global_ptr() = None;\n+        LOCK.unlock();\n+    }\n+\n+    pub fn args() -> Args {\n+        let bytes = clone().unwrap_or(Vec::new());\n+        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+            OsStringExt::from_vec(v)\n+        }).collect();\n+        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+\n+    fn clone() -> Option<Vec<Vec<u8>>> {\n+        unsafe {\n+            LOCK.lock();\n+            let ptr = get_global_ptr();\n+            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n+            LOCK.unlock();\n+            return ret\n+        }\n+    }\n+\n+    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n+        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n+    }\n+\n+}\n+\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"ios\"))]\n+mod imp {\n+    use ffi::CStr;\n+    use marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n+    }\n+\n+    pub fn cleanup() {\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub fn args() -> Args {\n+        use os::unix::prelude::*;\n+        extern {\n+            // These functions are in crt_externs.h.\n+            fn _NSGetArgc() -> *mut libc::c_int;\n+            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;\n+        }\n+\n+        let vec = unsafe {\n+            let (argc, argv) = (*_NSGetArgc() as isize,\n+                                *_NSGetArgv() as *const *const libc::c_char);\n+            (0.. argc as isize).map(|i| {\n+                let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n+                OsStringExt::from_vec(bytes)\n+            }).collect::<Vec<_>>()\n+        };\n+        Args {\n+            iter: vec.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    // As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+    // and use underscores in their names - they're most probably\n+    // are considered private and therefore should be avoided\n+    // Here is another way to get arguments using Objective C\n+    // runtime\n+    //\n+    // In general it looks like:\n+    // res = Vec::new()\n+    // let args = [[NSProcessInfo processInfo] arguments]\n+    // for i in (0..[args count])\n+    //      res.push([args objectAtIndex:i])\n+    // res\n+    #[cfg(target_os = \"ios\")]\n+    pub fn args() -> Args {\n+        use ffi::OsString;\n+        use mem;\n+        use str;\n+\n+        extern {\n+            fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n+            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n+        }\n+\n+        #[link(name = \"Foundation\", kind = \"framework\")]\n+        #[link(name = \"objc\")]\n+        #[cfg(not(cargobuild))]\n+        extern {}\n+\n+        type Sel = *const libc::c_void;\n+        type NsId = *const libc::c_void;\n+\n+        let mut res = Vec::new();\n+\n+        unsafe {\n+            let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n+            let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n+            let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+            let count_sel = sel_registerName(\"count\\0\".as_ptr());\n+            let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+            let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+            let info = objc_msgSend(klass, process_info_sel);\n+            let args = objc_msgSend(info, arguments_sel);\n+\n+            let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n+            for i in 0..cnt {\n+                let tmp = objc_msgSend(args, object_at_sel, i);\n+                let utf_c_str: *const libc::c_char =\n+                    mem::transmute(objc_msgSend(tmp, utf8_sel));\n+                let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n+                res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n+            }\n+        }\n+\n+        Args { iter: res.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+}"}, {"sha": "dc410cba89e04e4bfb4b52a0d39d30b75921ef85", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -30,6 +30,7 @@ use libc;\n #[macro_use]\n pub mod weak;\n \n+pub mod args;\n pub mod android;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;"}, {"sha": "c6118a333b192e5f24d2ce0b1a863c440578bec4", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -347,126 +347,6 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n-}\n-\n-/// Returns the command line arguments\n-///\n-/// Returns a list of the command line arguments.\n-#[cfg(target_os = \"macos\")]\n-pub fn args() -> Args {\n-    extern {\n-        // These functions are in crt_externs.h.\n-        fn _NSGetArgc() -> *mut c_int;\n-        fn _NSGetArgv() -> *mut *mut *mut c_char;\n-    }\n-\n-    let vec = unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as isize,\n-                            *_NSGetArgv() as *const *const c_char);\n-        (0.. argc as isize).map(|i| {\n-            let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n-            OsStringExt::from_vec(bytes)\n-        }).collect::<Vec<_>>()\n-    };\n-    Args {\n-        iter: vec.into_iter(),\n-        _dont_send_or_sync_me: PhantomData,\n-    }\n-}\n-\n-// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n-// and use underscores in their names - they're most probably\n-// are considered private and therefore should be avoided\n-// Here is another way to get arguments using Objective C\n-// runtime\n-//\n-// In general it looks like:\n-// res = Vec::new()\n-// let args = [[NSProcessInfo processInfo] arguments]\n-// for i in (0..[args count])\n-//      res.push([args objectAtIndex:i])\n-// res\n-#[cfg(target_os = \"ios\")]\n-pub fn args() -> Args {\n-    use mem;\n-\n-    extern {\n-        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n-        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n-        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n-    }\n-\n-    #[link(name = \"Foundation\", kind = \"framework\")]\n-    #[link(name = \"objc\")]\n-    #[cfg(not(cargobuild))]\n-    extern {}\n-\n-    type Sel = *const libc::c_void;\n-    type NsId = *const libc::c_void;\n-\n-    let mut res = Vec::new();\n-\n-    unsafe {\n-        let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n-        let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n-        let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n-        let count_sel = sel_registerName(\"count\\0\".as_ptr());\n-        let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n-\n-        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n-        let info = objc_msgSend(klass, process_info_sel);\n-        let args = objc_msgSend(info, arguments_sel);\n-\n-        let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n-        for i in 0..cnt {\n-            let tmp = objc_msgSend(args, object_at_sel, i);\n-            let utf_c_str: *const libc::c_char =\n-                mem::transmute(objc_msgSend(tmp, utf8_sel));\n-            let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n-            res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n-        }\n-    }\n-\n-    Args { iter: res.into_iter(), _dont_send_or_sync_me: PhantomData }\n-}\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\",\n-          target_os = \"nacl\",\n-          target_os = \"emscripten\",\n-          target_os = \"haiku\"))]\n-pub fn args() -> Args {\n-    use sys_common;\n-    let bytes = sys_common::args::clone().unwrap_or(Vec::new());\n-    let v: Vec<OsString> = bytes.into_iter().map(|v| {\n-        OsStringExt::from_vec(v)\n-    }).collect();\n-    Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n-}\n-\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,"}, {"sha": "aa61f9adb824d327e1e98fadcf0fa0323b1c80b1", "filename": "src/libstd/sys/windows/args.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use os::windows::prelude::*;\n+use sys::c;\n+use slice;\n+use ops::Range;\n+use ffi::OsString;\n+use libc::{c_int, c_void};\n+\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n+\n+pub unsafe fn cleanup() { }\n+\n+pub fn args() -> Args {\n+    unsafe {\n+        let mut nArgs: c_int = 0;\n+        let lpCmdLine = c::GetCommandLineW();\n+        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n+\n+        // szArcList can be NULL if CommandLinToArgvW failed,\n+        // but in that case nArgs is 0 so we won't actually\n+        // try to read a null pointer\n+        Args { cur: szArgList, range: 0..(nArgs as isize) }\n+    }\n+}\n+\n+pub struct Args {\n+    range: Range<isize>,\n+    cur: *mut *mut u16,\n+}\n+\n+unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n+    let mut len = 0;\n+    while *ptr.offset(len) != 0 { len += 1; }\n+\n+    // Push it onto the list.\n+    let ptr = ptr as *const u16;\n+    let buf = slice::from_raw_parts(ptr, len as usize);\n+    OsStringExt::from_wide(buf)\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.range.len() }\n+}\n+\n+impl Drop for Args {\n+    fn drop(&mut self) {\n+        // self.cur can be null if CommandLineToArgvW previously failed,\n+        // but LocalFree ignores NULL pointers\n+        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+    }\n+}"}, {"sha": "9cd6e6ca1761dfa23937f2628b27d3820d605eeb", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -18,6 +18,7 @@ use time::Duration;\n \n #[macro_use] pub mod compat;\n \n+pub mod args;\n pub mod backtrace;\n pub mod c;\n pub mod condvar;"}, {"sha": "7e28dd1e259c8c1551e7f73fc97d2daaecc09501", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -18,8 +18,6 @@ use error::Error as StdError;\n use ffi::{OsString, OsStr};\n use fmt;\n use io;\n-use libc::{c_int, c_void};\n-use ops::Range;\n use os::windows::ffi::EncodeWide;\n use path::{self, PathBuf};\n use ptr;\n@@ -272,60 +270,6 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     }).map(|_| ())\n }\n \n-pub struct Args {\n-    range: Range<isize>,\n-    cur: *mut *mut u16,\n-}\n-\n-unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n-    let mut len = 0;\n-    while *ptr.offset(len) != 0 { len += 1; }\n-\n-    // Push it onto the list.\n-    let ptr = ptr as *const u16;\n-    let buf = slice::from_raw_parts(ptr, len as usize);\n-    OsStringExt::from_wide(buf)\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.range.len() }\n-}\n-\n-impl Drop for Args {\n-    fn drop(&mut self) {\n-        // self.cur can be null if CommandLineToArgvW previously failed,\n-        // but LocalFree ignores NULL pointers\n-        unsafe { c::LocalFree(self.cur as *mut c_void); }\n-    }\n-}\n-\n-pub fn args() -> Args {\n-    unsafe {\n-        let mut nArgs: c_int = 0;\n-        let lpCmdLine = c::GetCommandLineW();\n-        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n-\n-        // szArcList can be NULL if CommandLinToArgvW failed,\n-        // but in that case nArgs is 0 so we won't actually\n-        // try to read a null pointer\n-        Args { cur: szArgList, range: 0..(nArgs as isize) }\n-    }\n-}\n-\n pub fn temp_dir() -> PathBuf {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetTempPathW(sz, buf)"}, {"sha": "1d04e8fc8eb7914db8ed267d934537c2117ff71c", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d76ac84922bec9ea790c1394f6959ad399d7aa1/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=4d76ac84922bec9ea790c1394f6959ad399d7aa1", "patch": "@@ -71,7 +71,6 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/libstd/num/f64.rs\",\n     \"src/libstd/thread/local.rs\",\n     \"src/libstd/sys/common/mod.rs\",\n-    \"src/libstd/sys/common/args.rs\",\n     \"src/libstd/sys/common/net.rs\",\n     \"src/libstd/sys/common/util.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test needs it"}]}