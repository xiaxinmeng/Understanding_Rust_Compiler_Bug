{"sha": "7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWQ3ZTFjMmU3NDY0OTE2Njk0ZTU1YmE0ZjMxYmY1YjhmOWE0Zjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T16:52:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T16:52:14Z"}, "message": "auto merge of #5549 : brson/rust/rustdoc, r=brson\n\nr?", "tree": {"sha": "b1a50a1cae4f86751e0ce76f22c4156cdeb9667e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1a50a1cae4f86751e0ce76f22c4156cdeb9667e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "html_url": "https://github.com/rust-lang/rust/commit/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de7d5589441d4f0fe8c4f083b6fa9dbfac451398", "url": "https://api.github.com/repos/rust-lang/rust/commits/de7d5589441d4f0fe8c4f083b6fa9dbfac451398", "html_url": "https://github.com/rust-lang/rust/commit/de7d5589441d4f0fe8c4f083b6fa9dbfac451398"}, {"sha": "4d745c288a01fbc59366b65a65e847efb50353b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d745c288a01fbc59366b65a65e847efb50353b5", "html_url": "https://github.com/rust-lang/rust/commit/4d745c288a01fbc59366b65a65e847efb50353b5"}], "stats": {"total": 245, "additions": 224, "deletions": 21}, "files": [{"sha": "221f7996f1012417d4b4b8d3fd929ab70f331816", "filename": "doc/rust.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -101,4 +101,9 @@ td {\n #TOC ul {\n     list-style: none;\n     padding-left: 0px;\n+}\n+\n+/* Adjust list alignment so rustdoc indexes don't align with blockquotes */\n+div.index ul {\n+    padding-left: 1em;\n }\n\\ No newline at end of file"}, {"sha": "5eecbf58cc6530a534d926ef51f686032e9a0ff3", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -135,6 +135,7 @@ pub struct MethodDoc {\n #[deriving(Eq)]\n pub struct ImplDoc {\n     item: ItemDoc,\n+    bounds_str: Option<~str>,\n     trait_types: ~[~str],\n     self_ty: Option<~str>,\n     methods: ~[MethodDoc]"}, {"sha": "08a5928ac3dfb9bb781e69ed47387eb0e5b756f4", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -277,6 +277,7 @@ fn impldoc_from_impl(\n ) -> doc::ImplDoc {\n     doc::ImplDoc {\n         item: itemdoc,\n+        bounds_str: None,\n         trait_types: ~[],\n         self_ty: None,\n         methods: do vec::map(methods) |method| {"}, {"sha": "4feeed84aa28bbd98612719c5326038a9d66946b", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -143,12 +143,16 @@ fn pandoc_header_id(header: &str) -> ~str {\n         let s = str::replace(s, ~\":\", ~\"\");\n         let s = str::replace(s, ~\"&\", ~\"\");\n         let s = str::replace(s, ~\"^\", ~\"\");\n+        let s = str::replace(s, ~\",\", ~\"\");\n+        let s = str::replace(s, ~\"'\", ~\"\");\n+        let s = str::replace(s, ~\"+\", ~\"\");\n         return s;\n     }\n     fn replace_with_hyphens(s: &str) -> ~str {\n         // Collapse sequences of whitespace to a single dash\n         // XXX: Hacky implementation here that only covers\n         // one or two spaces.\n+        let s = str::trim(s);\n         let s = str::replace(s, ~\"  \", ~\"-\");\n         let s = str::replace(s, ~\" \", ~\"-\");\n         return s;\n@@ -170,6 +174,17 @@ fn should_remove_punctuation_from_headers() {\n         == ~\"impl-of-numnum-for-int\");\n     fail_unless!(pandoc_header_id(~\"impl for & condvar\")\n         == ~\"impl-for-condvar\");\n+    fail_unless!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+                 == ~\"impl-of-selectt-u-for-left-right\");\n+    fail_unless!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+                 == ~\"impl-of-conditionself-t-u\");\n+    fail_unless!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+                 == ~\"impl-of-conditiont-copy-clone\");\n+}\n+\n+#[test]\n+fn should_trim_whitespace_after_removing_punctuation() {\n+    fail_unless!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n }\n \n #[test]"}, {"sha": "fbcf82ade2fd6880bd4a2d5548f9ad5681653963", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -249,6 +249,11 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n       }\n       &doc::ImplTag(ref doc) => {\n         fail_unless!(doc.self_ty.is_some());\n+          let bounds = if (&doc.bounds_str).is_some() {\n+              fmt!(\" where %s\", (&doc.bounds_str).get())\n+          } else {\n+              ~\"\"\n+          };\n         let self_ty = (&doc.self_ty).get();\n         let mut trait_part = ~\"\";\n         for doc.trait_types.eachi |i, trait_type| {\n@@ -259,7 +264,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             }\n             trait_part += *trait_type;\n         }\n-        fmt!(\"%s for %s\", trait_part, self_ty)\n+        fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n       }\n       _ => {\n         doc.name()\n@@ -271,11 +276,18 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n       &doc::ImplTag(ref ImplDoc) => {\n         let header_kind = header_kind(copy doc);\n+          let bounds = if (&ImplDoc.bounds_str).is_some() {\n+              fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n+          } else {\n+              ~\"\"\n+          };\n         let desc = if ImplDoc.trait_types.is_empty() {\n-            fmt!(\"for `%s`\", (&ImplDoc.self_ty).get())\n+            fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n         } else {\n-            fmt!(\"of `%s` for `%s`\", ImplDoc.trait_types[0],\n-                 (&ImplDoc.self_ty).get())\n+            fmt!(\"of `%s` for `%s`%s\",\n+                 ImplDoc.trait_types[0],\n+                 (&ImplDoc.self_ty).get(),\n+                 bounds)\n         };\n         return fmt!(\"%s %s\", header_kind, desc);\n       }\n@@ -424,6 +436,9 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         return;\n     }\n \n+    ctxt.w.put_line(~\"<div class='index'>\");\n+    ctxt.w.put_line(~\"\");\n+\n     for index.entries.each |entry| {\n         let header = header_text_(entry.kind, entry.name);\n         let id = copy entry.link;\n@@ -435,6 +450,8 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         }\n     }\n     ctxt.w.put_line(~\"\");\n+    ctxt.w.put_line(~\"</div>\");\n+    ctxt.w.put_line(~\"\");\n }\n \n #[test]\n@@ -749,6 +766,12 @@ fn should_write_impl_header() {\n     fail_unless!(str::contains(markdown, ~\"## Implementation for `int`\"));\n }\n \n+#[test]\n+fn should_write_impl_header_with_bounds() {\n+    let markdown = test::render(~\"impl <T> int<T> { }\");\n+    fail_unless!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+}\n+\n #[test]\n fn should_write_impl_header_with_trait() {\n     let markdown = test::render(~\"impl j for int { fn a() { } }\");"}, {"sha": "d09182e87f315e83969a5ecc6d1da6ebc931106d", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -39,5 +39,5 @@ pub fn from_str_sess(sess: session::Session, source: ~str) -> @ast::crate {\n }\n \n fn cfg(sess: session::Session, input: driver::input) -> ast::crate_cfg {\n-    driver::default_configuration(sess, ~\"rustdoc\", input)\n+    driver::build_configuration(sess, ~\"rustdoc\", input)\n }"}, {"sha": "b6aebf8b14fe619ba76d49f05b2a9b82039cebb6", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 161, "deletions": 13, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -12,6 +12,9 @@\n \n use core::prelude::*;\n \n+use extract;\n+use syntax::ast;\n+use syntax::ast_map;\n use astsrv;\n use doc;\n use fold::Fold;\n@@ -28,12 +31,73 @@ pub fn mk_pass() -> Pass {\n }\n \n pub fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n+    // First strip private methods out of impls\n+    let fold = Fold {\n+        ctxt: srv.clone(),\n+        fold_impl: fold_impl,\n+        .. fold::default_any_fold(srv.clone())\n+    };\n+    let doc = (fold.fold_doc)(&fold, doc);\n+\n+    // Then strip private items and empty impls\n     let fold = Fold {\n         ctxt: srv.clone(),\n         fold_mod: fold_mod,\n         .. fold::default_any_fold(srv)\n     };\n-    (fold.fold_doc)(&fold, doc)\n+    let doc = (fold.fold_doc)(&fold, doc);\n+\n+    return doc;\n+}\n+\n+fn fold_impl(\n+    fold: &fold::Fold<astsrv::Srv>,\n+    doc: doc::ImplDoc\n+) -> doc::ImplDoc {\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+\n+    do astsrv::exec(fold.ctxt.clone()) |ctxt| {\n+        match ctxt.ast_map.get(&doc.item.id) {\n+            ast_map::node_item(item, _) => {\n+                match item.node {\n+                    ast::item_impl(_, None, _, ref methods) => {\n+                        // Associated impls have complex rules for method visibility\n+                        strip_priv_methods(copy doc, *methods, item.vis)\n+                    }\n+                    ast::item_impl(_, Some(_), _ ,_) => {\n+                        // Trait impls don't\n+                        copy doc\n+                    }\n+                    _ => fail!()\n+                }\n+            }\n+            _ => fail!()\n+        }\n+    }\n+}\n+\n+fn strip_priv_methods(\n+    doc: doc::ImplDoc,\n+    methods: &[@ast::method],\n+    item_vis: ast::visibility\n+) -> doc::ImplDoc {\n+    let methods = do (&doc.methods).filtered |method| {\n+        let ast_method = do methods.find |m| {\n+            extract::to_str(m.ident) == method.name\n+        };\n+        fail_unless!(ast_method.is_some());\n+        let ast_method = ast_method.unwrap();\n+        match ast_method.vis {\n+            ast::public => true,\n+            ast::private => false,\n+            ast::inherited => item_vis == ast::public\n+        }\n+    };\n+\n+    doc::ImplDoc {\n+        methods: methods,\n+        .. doc\n+    }\n }\n \n fn fold_mod(\n@@ -44,28 +108,40 @@ fn fold_mod(\n \n     doc::ModDoc {\n         items: doc.items.filtered(|ItemTag| {\n-            is_visible(fold.ctxt.clone(), ItemTag.item())\n+            match ItemTag {\n+                &doc::ImplTag(ref doc) => {\n+                    if doc.trait_types.is_empty() {\n+                        // This is an associated impl. We have already pruned the\n+                        // non-visible methods. If there are any left then\n+                        // retain the impl, otherwise throw it away\n+                        !doc.methods.is_empty()\n+                    } else {\n+                        // This is a trait implementation, make it visible\n+                        // NOTE: This is not quite right since this could be an impl\n+                        // of a private trait. We can't know that without running\n+                        // resolve though.\n+                        true\n+                    }\n+                }\n+                _ => {\n+                    is_visible(fold.ctxt.clone(), ItemTag.item())\n+                }\n+            }\n         }),\n         .. doc\n     }\n }\n \n fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n-    use syntax::ast_map;\n-    use syntax::ast;\n-\n     let id = doc.id;\n \n     do astsrv::exec(srv) |ctxt| {\n         match ctxt.ast_map.get(&id) {\n             ast_map::node_item(item, _) => {\n-                match item.node {\n-                    ast::item_impl(_, Some(_), _, _) => {\n-                        // This is a trait implementation, make it visible\n-                        // NOTE: This is not quite right since this could be an impl\n-                        // of a private trait. We can't know that without running\n-                        // resolve though.\n-                        true\n+                match &item.node {\n+                    &ast::item_impl(*) => {\n+                        // Impls handled elsewhere\n+                        fail!()\n                     }\n                     _ => {\n                         // Otherwise just look at the visibility\n@@ -85,7 +161,8 @@ fn should_prune_items_without_pub_modifier() {\n }\n \n #[test]\n-fn unless_they_are_trait_impls() {\n+fn should_not_prune_trait_impls() {\n+    // Impls are more complicated\n     let doc = test::mk_doc(\n         ~\" \\\n           trait Foo { } \\\n@@ -94,16 +171,87 @@ fn unless_they_are_trait_impls() {\n     fail_unless!(!doc.cratemod().impls().is_empty());\n }\n \n+#[test]\n+fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n+    let doc = test::mk_doc(\n+        ~\"impl Foo {\\\n+          pub fn bar() { }\\\n+          fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+}\n+\n+#[test]\n+fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n+    let doc = test::mk_doc(\n+        ~\"impl Foo {\\\n+          pub fn bar() { }\\\n+          priv fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+}\n+\n+#[test]\n+fn should_prune_priv_associated_methods_on_pub_impls() {\n+    let doc = test::mk_doc(\n+        ~\"pub impl Foo {\\\n+          fn bar() { }\\\n+          priv fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+}\n+\n+#[test]\n+fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n+    let doc = test::mk_doc(\n+        ~\"priv impl Foo {\\\n+          pub fn bar() { }\\\n+          fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+}\n+\n+#[test]\n+fn should_prune_priv_associated_methods_on_priv_impls() {\n+    let doc = test::mk_doc(\n+        ~\"priv impl Foo {\\\n+          pub fn bar() { }\\\n+          priv fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls()[0].methods.len() == 1);\n+}\n+\n+#[test]\n+fn should_prune_associated_impls_with_no_pub_methods() {\n+    let doc = test::mk_doc(\n+        ~\"priv impl Foo {\\\n+          fn baz() { }\\\n+          }\");\n+    fail_unless!(doc.cratemod().impls().is_empty());\n+}\n+\n+#[test]\n+fn should_not_prune_associated_impls_with_pub_methods() {\n+    let doc = test::mk_doc(\n+        ~\" \\\n+          impl Foo { pub fn bar() { } } \\\n+          \");\n+    fail_unless!(!doc.cratemod().impls().is_empty());\n+}\n+\n+\n #[cfg(test)]\n pub mod test {\n     use astsrv;\n     use doc;\n     use extract;\n+    use tystr_pass;\n     use prune_private_pass::run;\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = tystr_pass::run(srv.clone(), doc);\n             run(srv.clone(), doc)\n         }\n     }"}, {"sha": "50ec41e80bc09b0a6e40964fcfd659b2a7d9daa1", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=7f5d7e1c2e7464916694e55ba4f31bf5b8f9a4f9", "patch": "@@ -274,17 +274,20 @@ fn fold_impl(\n \n     let srv = fold.ctxt.clone();\n \n-    let (trait_types, self_ty) = {\n+    let (bounds, trait_types, self_ty) = {\n         let doc = copy doc;\n         do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n-                    node: ast::item_impl(_, opt_trait_type, self_ty, _), _\n+                    node: ast::item_impl(ref generics, opt_trait_type, self_ty, _), _\n                 }, _) => {\n+                    let bounds = pprust::generics_to_str(generics, extract::interner());\n+                    let bounds = if bounds.is_empty() { None } else { Some(bounds) };\n                     let trait_types = opt_trait_type.map_default(~[], |p| {\n                         ~[pprust::path_to_str(p.path, extract::interner())]\n                     });\n-                    (trait_types,\n+                    (bounds,\n+                     trait_types,\n                      Some(pprust::ty_to_str(\n                          self_ty, extract::interner())))\n                 }\n@@ -294,13 +297,20 @@ fn fold_impl(\n     };\n \n     doc::ImplDoc {\n+        bounds_str: bounds,\n         trait_types: trait_types,\n         self_ty: self_ty,\n         methods: merge_methods(fold.ctxt.clone(), doc.id(), copy doc.methods),\n         .. doc\n     }\n }\n \n+#[test]\n+fn should_add_impl_bounds() {\n+    let doc = test::mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n+    fail_unless!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n+}\n+\n #[test]\n fn should_add_impl_trait_types() {\n     let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");"}]}