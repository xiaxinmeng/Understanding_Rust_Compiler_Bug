{"sha": "e76f44453b00235b7a1b2154c240aedc2e24d3f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NmY0NDQ1M2IwMDIzNWI3YTFiMjE1NGMyNDBhZWRjMmUyNGQzZjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-14T18:47:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-14T18:47:20Z"}, "message": "rustc: First stab at interior string literals, untested as of yet", "tree": {"sha": "72bcc18a5c57622169a2edc492645bfcb42765af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72bcc18a5c57622169a2edc492645bfcb42765af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e76f44453b00235b7a1b2154c240aedc2e24d3f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e76f44453b00235b7a1b2154c240aedc2e24d3f6", "html_url": "https://github.com/rust-lang/rust/commit/e76f44453b00235b7a1b2154c240aedc2e24d3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e76f44453b00235b7a1b2154c240aedc2e24d3f6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4038010bc658c75b8f6efa99790e611c29e84763", "url": "https://api.github.com/repos/rust-lang/rust/commits/4038010bc658c75b8f6efa99790e611c29e84763", "html_url": "https://github.com/rust-lang/rust/commit/4038010bc658c75b8f6efa99790e611c29e84763"}], "stats": {"total": 98, "additions": 86, "deletions": 12}, "files": [{"sha": "094223c9ce66649a9cb3026934b1ac2970adf9a1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e76f44453b00235b7a1b2154c240aedc2e24d3f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e76f44453b00235b7a1b2154c240aedc2e24d3f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e76f44453b00235b7a1b2154c240aedc2e24d3f6", "patch": "@@ -3244,7 +3244,9 @@ fn memmove_ty(&@block_ctxt cx, ValueRef dst, ValueRef src, &ty::t t) ->\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(cx, t);\n         ret call_memmove(llsz.bcx, dst, src, llsz.val);\n-    } else { ret rslt(cx, cx.build.Store(cx.build.Load(src), dst)); }\n+    } else {\n+        ret rslt(cx, cx.build.Store(cx.build.Load(src), dst));\n+    }\n }\n \n // Duplicates any heap-owned memory owned by a value of the given type.\n@@ -3365,7 +3367,65 @@ fn move_val_if_temp(@block_ctxt cx, copy_action action, ValueRef dst,\n     }\n }\n \n-fn trans_lit(&@crate_ctxt cx, &ast::lit lit) -> ValueRef {\n+fn trans_lit_istr(&@block_ctxt cx, str s) -> result {\n+    auto llstackpart = alloca(cx, T_ivec(T_i8()));\n+    auto len = str::byte_len(s);\n+\n+    auto bcx;\n+    if (len < 3u) {     // 3 because of the \\0\n+        cx.build.Store(C_uint(len + 1u),\n+                       cx.build.InBoundsGEP(llstackpart,\n+                                            ~[C_int(0), C_int(0)]));\n+        cx.build.Store(C_int(4),\n+                       cx.build.InBoundsGEP(llstackpart,\n+                                            ~[C_int(0), C_int(1)]));\n+        auto i = 0u;\n+        while (i < len) {\n+            cx.build.Store(C_u8(s.(i) as uint),\n+                           cx.build.InBoundsGEP(llstackpart,\n+                                                ~[C_int(0), C_int(2),\n+                                                  C_uint(i)]));\n+            i += 1u;\n+        }\n+        cx.build.Store(C_u8(0u),\n+                       cx.build.InBoundsGEP(llstackpart,\n+                                            ~[C_int(0), C_int(2),\n+                                              C_uint(len)]));\n+\n+        bcx = cx;\n+    } else {\n+        auto r =\n+            trans_shared_malloc(cx, T_ptr(T_ivec_heap_part(T_i8())),\n+                                llsize_of(T_struct(~[T_int(),\n+                                                     T_array(T_i8(),\n+                                                             len + 1u)])));\n+        bcx = r.bcx;\n+        auto llheappart = r.val;\n+\n+        bcx.build.Store(C_uint(len + 1u),\n+                        bcx.build.InBoundsGEP(llheappart,\n+                                              ~[C_int(0), C_int(0)]));\n+        bcx.build.Store(llvm::LLVMConstString(str::buf(s), len, False),\n+                        bcx.build.InBoundsGEP(llheappart,\n+                                              ~[C_int(0), C_int(1)]));\n+\n+        auto llspilledstackpart = bcx.build.PointerCast(llstackpart,\n+            T_ptr(T_ivec_heap(T_i8())));\n+        bcx.build.Store(C_int(0),\n+                        bcx.build.InBoundsGEP(llspilledstackpart,\n+                                              ~[C_int(0), C_int(0)]));\n+        bcx.build.Store(C_uint(len + 1u),\n+                        bcx.build.InBoundsGEP(llspilledstackpart,\n+                                              ~[C_int(0), C_int(1)]));\n+        bcx.build.Store(llheappart,\n+                        bcx.build.InBoundsGEP(llspilledstackpart,\n+                                              ~[C_int(0), C_int(2)]));\n+    }\n+\n+    ret rslt(bcx, llstackpart);\n+}\n+\n+fn trans_crate_lit(&@crate_ctxt cx, &ast::lit lit) -> ValueRef {\n     alt (lit.node) {\n         case (ast::lit_int(?i)) { ret C_int(i); }\n         case (ast::lit_uint(?u)) { ret C_int(u as int); }\n@@ -3402,7 +3462,17 @@ fn trans_lit(&@crate_ctxt cx, &ast::lit lit) -> ValueRef {\n         }\n         case (ast::lit_bool(?b)) { ret C_bool(b); }\n         case (ast::lit_nil) { ret C_nil(); }\n-        case (ast::lit_str(?s, _)) { ret C_str(cx, s); }\n+        case (ast::lit_str(?s, ast::sk_rc)) { ret C_str(cx, s); }\n+        case (ast::lit_str(?s, ast::sk_unique)) {\n+            cx.sess.span_unimpl(lit.span, \"unique string in this context\");\n+        }\n+    }\n+}\n+\n+fn trans_lit(&@block_ctxt cx, &ast::lit lit) -> result {\n+    alt (lit.node) {\n+      ast::lit_str(?s, ast::sk_unique) { ret trans_lit_istr(cx, s); }\n+      _ { ret rslt(cx, trans_crate_lit(cx.fcx.lcx.ccx, lit)); }\n     }\n }\n \n@@ -6018,9 +6088,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n    result {\n     // FIXME Fill in cx.sp\n     alt (e.node) {\n-        case (ast::expr_lit(?lit)) {\n-            ret rslt(cx, trans_lit(cx.fcx.lcx.ccx, *lit));\n-        }\n+        case (ast::expr_lit(?lit)) { ret trans_lit(cx, *lit); }\n         case (ast::expr_unary(?op, ?x)) {\n             if (op != ast::deref) { ret trans_unary(cx, op, x, e.id); }\n         }\n@@ -8484,7 +8552,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n // that does so later on?\n fn trans_const_expr(&@crate_ctxt cx, @ast::expr e) -> ValueRef {\n     alt (e.node) {\n-        case (ast::expr_lit(?lit)) { ret trans_lit(cx, *lit); }\n+        case (ast::expr_lit(?lit)) { ret trans_crate_lit(cx, *lit); }\n         case (_) {\n             cx.sess.span_unimpl(e.span, \"consts that's not a plain literal\");\n         }"}, {"sha": "9bd453943fb631fd3bfad5054a58dfe08a93fb6b", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e76f44453b00235b7a1b2154c240aedc2e24d3f6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e76f44453b00235b7a1b2154c240aedc2e24d3f6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=e76f44453b00235b7a1b2154c240aedc2e24d3f6", "patch": "@@ -41,10 +41,10 @@ fn opt_eq(&opt a, &opt b) -> bool {\n         }\n     }\n }\n-fn trans_opt(&@crate_ctxt ccx, &opt o) -> ValueRef {\n+fn trans_opt(&@block_ctxt bcx, &opt o) -> result {\n     alt (o) {\n-        lit(?l) { ret trans::trans_lit(ccx, *l); }\n-        var(?id, _) { ret C_int(id as int); }\n+        lit(?l) { ret trans::trans_lit(bcx, *l); }\n+        var(?id, _) { ret rslt(bcx, C_int(id as int)); }\n     }\n }\n \n@@ -344,11 +344,17 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n         auto opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n         alt (kind) {\n             single { bcx.build.Br(opt_cx.llbb); }\n-            switch { llvm::LLVMAddCase(sw, trans_opt(ccx, opt), opt_cx.llbb);}\n+            switch {\n+                auto r = trans_opt(bcx, opt);\n+                bcx = r.bcx;\n+                llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+            }\n             compare {\n+                auto r = trans_opt(bcx, opt);\n+                bcx = r.bcx;\n                 auto t = ty::node_id_to_type(ccx.tcx, pat_id);\n                 auto eq = trans::trans_compare(bcx, ast::eq, t, test_val,\n-                                               trans_opt(ccx, opt));\n+                                               r.val);\n                 bcx = new_sub_block_ctxt(bcx, \"next\");\n                 eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n             }"}]}