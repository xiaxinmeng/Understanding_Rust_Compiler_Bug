{"sha": "424304a14f3d4dd8508006ab349b39b983342cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNDMwNGExNGYzZDRkZDg1MDgwMDZhYjM0OWIzOWI5ODMzNDJjZjE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-06T14:37:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-06T14:37:41Z"}, "message": "Rollup merge of #68788 - Centril:unified-fn-bodies, r=petrochenkov\n\nTowards unified `fn` grammar\n\nPart of https://github.com/rust-lang/rust/pull/68728.\n\n- Syntactically, `fn` items in `extern { ... }` blocks can now have bodies (`fn foo() { ... }` as opposed to `fn foo();`). As above, we use semantic restrictions instead.\n\n- Syntactically, `fn` items in free contexts (directly in a file or a module) can now be without bodies (`fn foo();` as opposed to `fn foo() { ... }`. As above, we use semantic restrictions instead, including for non-ident parameter patterns.\n\n- We move towards unifying the `fn` front matter; this is fully realized in https://github.com/rust-lang/rust/pull/68728.\n\nr? @petrochenkov", "tree": {"sha": "66048d880cc797b7c65801e8c4127a6fd69fd725", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66048d880cc797b7c65801e8c4127a6fd69fd725"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/424304a14f3d4dd8508006ab349b39b983342cf1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJePCS1CRBK7hj4Ov3rIwAAdHIIADf1196jRb85GePPjmFhJRJ3\nH+Afu1hH3I3Qn07YLuOy42nIPtQlgYBd5WwFdf5+8j+u8hJbGs47GlYc/izHIDDj\n0JHY8pfgcYDjzFjSPFSsmIgDM1aVCnoC7rQW4NM1iZyalj8ECUv7cp6sfD99gVjd\n70b0XXI6OLBKafvXLN1BvgUgktovDbmFcwBJVxd1x7fI42tApTdLLjRjS+7E1baQ\n9O5VpaBJ2mcwrS/F3W7MnbAMRLVyH2gS8A60UPSAwNz02s++eHaIpE84xez9dovD\nQWYYAqps1SfXsBd9kac1WODKuuXuMFczqSZlYZiwWfL/TOGwEDGUlYNeVvF6PRQ=\n=US9X\n-----END PGP SIGNATURE-----\n", "payload": "tree 66048d880cc797b7c65801e8c4127a6fd69fd725\nparent bf13861e6cebfedef6d996037bf09babf9dcb600\nparent 9a4eac3944e2e2668b4aea0b5afd3d83b88e992e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580999861 +0100\ncommitter GitHub <noreply@github.com> 1580999861 +0100\n\nRollup merge of #68788 - Centril:unified-fn-bodies, r=petrochenkov\n\nTowards unified `fn` grammar\n\nPart of https://github.com/rust-lang/rust/pull/68728.\n\n- Syntactically, `fn` items in `extern { ... }` blocks can now have bodies (`fn foo() { ... }` as opposed to `fn foo();`). As above, we use semantic restrictions instead.\n\n- Syntactically, `fn` items in free contexts (directly in a file or a module) can now be without bodies (`fn foo();` as opposed to `fn foo() { ... }`. As above, we use semantic restrictions instead, including for non-ident parameter patterns.\n\n- We move towards unifying the `fn` front matter; this is fully realized in https://github.com/rust-lang/rust/pull/68728.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/424304a14f3d4dd8508006ab349b39b983342cf1", "html_url": "https://github.com/rust-lang/rust/commit/424304a14f3d4dd8508006ab349b39b983342cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/424304a14f3d4dd8508006ab349b39b983342cf1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf13861e6cebfedef6d996037bf09babf9dcb600", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf13861e6cebfedef6d996037bf09babf9dcb600", "html_url": "https://github.com/rust-lang/rust/commit/bf13861e6cebfedef6d996037bf09babf9dcb600"}, {"sha": "9a4eac3944e2e2668b4aea0b5afd3d83b88e992e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4eac3944e2e2668b4aea0b5afd3d83b88e992e", "html_url": "https://github.com/rust-lang/rust/commit/9a4eac3944e2e2668b4aea0b5afd3d83b88e992e"}], "stats": {"total": 1714, "additions": 1049, "deletions": 665}, "files": [{"sha": "dab950e23f618ae26202ed0ac067d5cdeb656c27", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::node_id::NodeMap;\n-use syntax::visit::{self, Visitor};\n+use syntax::visit::{self, AssocCtxt, Visitor};\n \n use log::debug;\n use smallvec::{smallvec, SmallVec};\n@@ -81,25 +81,23 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, item: &'a AssocItem) {\n-        self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let hir_item = lctx.lower_trait_item(item);\n-            let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n-            lctx.trait_items.insert(id, hir_item);\n-            lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+    fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n+            AssocCtxt::Trait => {\n+                let hir_item = lctx.lower_trait_item(item);\n+                let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+                lctx.trait_items.insert(id, hir_item);\n+                lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+            }\n+            AssocCtxt::Impl => {\n+                let hir_item = lctx.lower_impl_item(item);\n+                let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+                lctx.impl_items.insert(id, hir_item);\n+                lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+            }\n         });\n \n-        visit::walk_trait_item(self, item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'a AssocItem) {\n-        self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let hir_item = lctx.lower_impl_item(item);\n-            let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n-            lctx.impl_items.insert(id, hir_item);\n-            lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n-        });\n-        visit::walk_impl_item(self, item);\n+        visit::walk_assoc_item(self, item, ctxt);\n     }\n }\n \n@@ -299,20 +297,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n+                    let asyncness = header.asyncness.node;\n                     let body_id =\n-                        this.lower_maybe_async_body(span, &decl, header.asyncness.node, Some(body));\n+                        this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n                     let (generics, decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| {\n-                            this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id, idty)),\n-                                true,\n-                                header.asyncness.node.opt_return_id(),\n-                            )\n+                            let ret_id = asyncness.opt_return_id();\n+                            this.lower_fn_decl(&decl, Some((fn_def_id, idty)), true, ret_id)\n                         },\n                     );\n                     let sig = hir::FnSig { decl, header: this.lower_fn_header(header) };\n@@ -658,7 +653,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n-                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                ForeignItemKind::Fn(ref sig, ref generics, _) => {\n+                    let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n                         generics,\n                         def_id,"}, {"sha": "5816a64fca52c16d8aee328953680e6df14ccde1", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -32,6 +32,7 @@\n \n #![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n+#![recursion_limit = \"256\"]\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n@@ -63,7 +64,7 @@ use syntax::attr;\n use syntax::node_id::NodeMap;\n use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax::visit::{self, Visitor};\n+use syntax::visit::{self, AssocCtxt, Visitor};\n use syntax::walk_list;\n \n use log::{debug, trace};\n@@ -485,25 +486,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 });\n             }\n \n-            fn visit_trait_item(&mut self, item: &'tcx AssocItem) {\n+            fn visit_assoc_item(&mut self, item: &'tcx AssocItem, ctxt: AssocCtxt) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n-\n-                match item.kind {\n-                    AssocItemKind::Fn(_, None) => {\n-                        // Ignore patterns in trait methods without bodies\n-                        self.with_hir_id_owner(None, |this| visit::walk_trait_item(this, item));\n-                    }\n-                    _ => self.with_hir_id_owner(Some(item.id), |this| {\n-                        visit::walk_trait_item(this, item);\n-                    }),\n-                }\n-            }\n-\n-            fn visit_impl_item(&mut self, item: &'tcx AssocItem) {\n-                self.lctx.allocate_hir_id_counter(item.id);\n-                self.with_hir_id_owner(Some(item.id), |this| {\n-                    visit::walk_impl_item(this, item);\n-                });\n+                let owner = match (&item.kind, ctxt) {\n+                    // Ignore patterns in trait methods without bodies.\n+                    (AssocItemKind::Fn(_, None), AssocCtxt::Trait) => None,\n+                    _ => Some(item.id),\n+                };\n+                self.with_hir_id_owner(owner, |this| visit::walk_assoc_item(this, item, ctxt));\n             }\n \n             fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {"}, {"sha": "79ed7f234f72e6ee1e92e7550e168f1f396febd4", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 211, "deletions": 125, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, FatalError};\n+use rustc_errors::{error_code, struct_span_err, Applicability, FatalError};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY;\n use rustc_session::lint::LintBuffer;\n@@ -20,7 +20,7 @@ use std::mem;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::expand::is_proc_macro_attr;\n-use syntax::visit::{self, Visitor};\n+use syntax::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use syntax::walk_list;\n \n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n@@ -49,6 +49,13 @@ impl BoundContext {\n \n struct AstValidator<'a> {\n     session: &'a Session,\n+\n+    /// The span of the `extern` in an `extern { ... }` block, if any.\n+    extern_mod: Option<&'a Item>,\n+\n+    /// Are we inside a trait impl?\n+    in_trait_impl: bool,\n+\n     has_proc_macro_decls: bool,\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n@@ -74,6 +81,12 @@ struct AstValidator<'a> {\n }\n \n impl<'a> AstValidator<'a> {\n+    fn with_in_trait_impl(&mut self, is_in: bool, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.in_trait_impl, is_in);\n+        f(self);\n+        self.in_trait_impl = old;\n+    }\n+\n     fn with_banned_impl_trait(&mut self, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.is_impl_trait_banned, true);\n         f(self);\n@@ -389,13 +402,9 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n-        if body.is_some() {\n-            return;\n-        }\n-\n+    fn error_item_without_body(&self, sp: Span, ctx: &str, msg: &str, sugg: &str) {\n         self.err_handler()\n-            .struct_span_err(sp, &format!(\"associated {} in `impl` without body\", ctx))\n+            .struct_span_err(sp, msg)\n             .span_suggestion(\n                 self.session.source_map().end_point(sp),\n                 &format!(\"provide a definition for the {}\", ctx),\n@@ -405,6 +414,13 @@ impl<'a> AstValidator<'a> {\n             .emit();\n     }\n \n+    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n+        if body.is_none() {\n+            let msg = format!(\"associated {} in `impl` without body\", ctx);\n+            self.error_item_without_body(sp, ctx, &msg, sugg);\n+        }\n+    }\n+\n     fn check_impl_assoc_type_no_bounds(&self, bounds: &[GenericBound]) {\n         let span = match bounds {\n             [] => return,\n@@ -416,8 +432,71 @@ impl<'a> AstValidator<'a> {\n             .emit();\n     }\n \n-    fn check_c_varadic_type(&self, decl: &FnDecl) {\n-        for Param { ty, span, .. } in &decl.inputs {\n+    /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n+    fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n+        let body = match body {\n+            None => return,\n+            Some(body) => body,\n+        };\n+        self.err_handler()\n+            .struct_span_err(ident.span, \"incorrect function inside `extern` block\")\n+            .span_label(ident.span, \"cannot have a body\")\n+            .span_suggestion(\n+                body.span,\n+                \"remove the invalid body\",\n+                \";\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            )\n+            .help(\n+                \"you might have meant to write a function accessible through FFI, \\\n+                which can be done by writing `extern fn` outside of the `extern` block\",\n+            )\n+            .span_label(\n+                self.current_extern_span(),\n+                \"`extern` blocks define existing foreign functions and functions \\\n+                inside of them cannot have a body\",\n+            )\n+            .note(\"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\")\n+            .emit();\n+    }\n+\n+    fn current_extern_span(&self) -> Span {\n+        self.session.source_map().def_span(self.extern_mod.unwrap().span)\n+    }\n+\n+    /// An `fn` in `extern { ... }` cannot have qualfiers, e.g. `async fn`.\n+    fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n+        if header.has_qualifiers() {\n+            self.err_handler()\n+                .struct_span_err(ident.span, \"functions in `extern` blocks cannot have qualifiers\")\n+                .span_label(self.current_extern_span(), \"in this `extern` block\")\n+                .span_suggestion(\n+                    span.until(ident.span.shrink_to_lo()),\n+                    \"remove the qualifiers\",\n+                    \"fn \".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    /// Reject C-varadic type unless the function is foreign,\n+    /// or free and `unsafe extern \"C\"` semantically.\n+    fn check_c_varadic_type(&self, fk: FnKind<'a>) {\n+        match (fk.ctxt(), fk.header()) {\n+            (Some(FnCtxt::Foreign), _) => return,\n+            (Some(FnCtxt::Free), Some(header)) => match header.ext {\n+                Extern::Explicit(StrLit { symbol_unescaped: sym::C, .. }) | Extern::Implicit\n+                    if header.unsafety == Unsafety::Unsafe =>\n+                {\n+                    return;\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        };\n+\n+        for Param { ty, span, .. } in &fk.decl().inputs {\n             if let TyKind::CVarArgs = ty.kind {\n                 self.err_handler()\n                     .struct_span_err(\n@@ -428,6 +507,24 @@ impl<'a> AstValidator<'a> {\n             }\n         }\n     }\n+\n+    /// We currently do not permit const generics in `const fn`,\n+    /// as this is tantamount to allowing compile-time dependent typing.\n+    ///\n+    /// FIXME(const_generics): Is this really true / necessary? Discuss with @varkor.\n+    /// At any rate, the restriction feels too syntactic. Consider moving it to e.g. typeck.\n+    fn check_const_fn_const_generic(&self, span: Span, sig: &FnSig, generics: &Generics) {\n+        if sig.header.constness.node == Constness::Const {\n+            // Look for const generics and error if we find any.\n+            for param in &generics.params {\n+                if let GenericParamKind::Const { .. } = param.kind {\n+                    self.err_handler()\n+                        .struct_span_err(span, \"const parameters are not permitted in `const fn`\")\n+                        .emit();\n+                }\n+            }\n+        }\n+    }\n }\n \n enum GenericPosition {\n@@ -532,9 +629,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match &expr.kind {\n-            ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n-                self.check_fn_decl(fn_decl, SelfSemantic::No);\n-            }\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 struct_span_err!(\n                     self.session,\n@@ -647,31 +741,32 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 generics: _,\n                 of_trait: Some(_),\n                 ref self_ty,\n-                ref items,\n+                items: _,\n             } => {\n-                self.invalid_visibility(&item.vis, None);\n-                if let TyKind::Err = self_ty.kind {\n-                    self.err_handler()\n-                        .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n-                        .help(\"use `auto trait Trait {}` instead\")\n+                self.with_in_trait_impl(true, |this| {\n+                    this.invalid_visibility(&item.vis, None);\n+                    if let TyKind::Err = self_ty.kind {\n+                        this.err_handler()\n+                            .struct_span_err(\n+                                item.span,\n+                                \"`impl Trait for .. {}` is an obsolete syntax\",\n+                            )\n+                            .help(\"use `auto trait Trait {}` instead\")\n+                            .emit();\n+                    }\n+                    if unsafety == Unsafety::Unsafe && polarity == ImplPolarity::Negative {\n+                        struct_span_err!(\n+                            this.session,\n+                            item.span,\n+                            E0198,\n+                            \"negative impls cannot be unsafe\"\n+                        )\n                         .emit();\n-                }\n-                if unsafety == Unsafety::Unsafe && polarity == ImplPolarity::Negative {\n-                    struct_span_err!(\n-                        self.session,\n-                        item.span,\n-                        E0198,\n-                        \"negative impls cannot be unsafe\"\n-                    )\n-                    .emit();\n-                }\n-                for impl_item in items {\n-                    self.invalid_visibility(&impl_item.vis, None);\n-                    if let AssocItemKind::Fn(ref sig, _) = impl_item.kind {\n-                        self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n-                }\n+\n+                    visit::walk_item(this, item);\n+                });\n+                return; // Avoid visiting again.\n             }\n             ItemKind::Impl {\n                 unsafety,\n@@ -712,40 +807,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         .emit();\n                 }\n             }\n-            ItemKind::Fn(ref sig, ref generics, _) => {\n-                self.visit_fn_header(&sig.header);\n-                self.check_fn_decl(&sig.decl, SelfSemantic::No);\n-                // We currently do not permit const generics in `const fn`, as\n-                // this is tantamount to allowing compile-time dependent typing.\n-                if sig.header.constness.node == Constness::Const {\n-                    // Look for const generics and error if we find any.\n-                    for param in &generics.params {\n-                        match param.kind {\n-                            GenericParamKind::Const { .. } => {\n-                                self.err_handler()\n-                                    .struct_span_err(\n-                                        item.span,\n-                                        \"const parameters are not permitted in `const fn`\",\n-                                    )\n-                                    .emit();\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                // Reject C-varadic type unless the function is `unsafe extern \"C\"` semantically.\n-                match sig.header.ext {\n-                    Extern::Explicit(StrLit { symbol_unescaped: sym::C, .. })\n-                    | Extern::Implicit\n-                        if sig.header.unsafety == Unsafety::Unsafe => {}\n-                    _ => self.check_c_varadic_type(&sig.decl),\n+            ItemKind::Fn(ref sig, ref generics, ref body) => {\n+                self.check_const_fn_const_generic(item.span, sig, generics);\n+\n+                if body.is_none() {\n+                    let msg = \"free function without a body\";\n+                    self.error_item_without_body(item.span, \"function\", msg, \" { <body> }\");\n                 }\n             }\n-            ItemKind::ForeignMod(..) => {\n+            ItemKind::ForeignMod(_) => {\n+                let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n                     Some(\"place qualifiers on individual foreign items instead\"),\n                 );\n+                visit::walk_item(self, item);\n+                self.extern_mod = old_item;\n+                return; // Avoid visiting again.\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -796,7 +874,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.with_bound_context(BoundContext::TraitBounds, |this| {\n                     walk_list!(this, visit_param_bound, bounds);\n                 });\n-                walk_list!(self, visit_trait_item, trait_items);\n+                walk_list!(self, visit_assoc_item, trait_items, AssocCtxt::Trait);\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n@@ -820,19 +898,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'a ForeignItem) {\n-        match fi.kind {\n-            ForeignItemKind::Fn(ref decl, _) => {\n-                self.check_fn_decl(decl, SelfSemantic::No);\n-                Self::check_decl_no_pat(decl, |span, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0130,\n-                        \"patterns aren't allowed in foreign function declarations\"\n-                    )\n-                    .span_label(span, \"pattern not allowed in foreign function\")\n-                    .emit();\n-                });\n+        match &fi.kind {\n+            ForeignItemKind::Fn(sig, _, body) => {\n+                self.check_foreign_fn_bodyless(fi.ident, body.as_deref());\n+                self.check_foreign_fn_headerless(fi.ident, fi.span, sig.header);\n             }\n             ForeignItemKind::Static(..) | ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {}\n         }\n@@ -1011,67 +1080,84 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         })\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a AssocItem) {\n-        match &ii.kind {\n-            AssocItemKind::Const(_, body) => {\n-                self.check_impl_item_provided(ii.span, body, \"constant\", \" = <expr>;\");\n-            }\n-            AssocItemKind::Fn(_, body) => {\n-                self.check_impl_item_provided(ii.span, body, \"function\", \" { <body> }\");\n-            }\n-            AssocItemKind::TyAlias(bounds, body) => {\n-                self.check_impl_item_provided(ii.span, body, \"type\", \" = <type>;\");\n-                self.check_impl_assoc_type_no_bounds(bounds);\n-            }\n-            _ => {}\n+    fn visit_fn(&mut self, fk: FnKind<'a>, span: Span, id: NodeId) {\n+        // Only associated `fn`s can have `self` parameters.\n+        let self_semantic = match fk.ctxt() {\n+            Some(FnCtxt::Assoc(_)) => SelfSemantic::Yes,\n+            _ => SelfSemantic::No,\n+        };\n+        self.check_fn_decl(fk.decl(), self_semantic);\n+\n+        self.check_c_varadic_type(fk);\n+\n+        // Functions without bodies cannot have patterns.\n+        if let FnKind::Fn(ctxt, _, sig, _, None) = fk {\n+            Self::check_decl_no_pat(&sig.decl, |span, mut_ident| {\n+                let (code, msg, label) = match ctxt {\n+                    FnCtxt::Foreign => (\n+                        error_code!(E0130),\n+                        \"patterns aren't allowed in foreign function declarations\",\n+                        \"pattern not allowed in foreign function\",\n+                    ),\n+                    _ => (\n+                        error_code!(E0642),\n+                        \"patterns aren't allowed in functions without bodies\",\n+                        \"pattern not allowed in function without body\",\n+                    ),\n+                };\n+                if mut_ident && matches!(ctxt, FnCtxt::Assoc(_)) {\n+                    self.lint_buffer.buffer_lint(PATTERNS_IN_FNS_WITHOUT_BODY, id, span, msg);\n+                } else {\n+                    self.err_handler()\n+                        .struct_span_err(span, msg)\n+                        .span_label(span, label)\n+                        .code(code)\n+                        .emit();\n+                }\n+            });\n         }\n-        visit::walk_impl_item(self, ii);\n+\n+        visit::walk_fn(self, fk, span);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a AssocItem) {\n-        self.invalid_visibility(&ti.vis, None);\n-        self.check_defaultness(ti.span, ti.defaultness);\n-\n-        if let AssocItemKind::Fn(sig, block) = &ti.kind {\n-            self.check_trait_fn_not_async(ti.span, sig.header.asyncness.node);\n-            self.check_trait_fn_not_const(sig.header.constness);\n-            if block.is_none() {\n-                Self::check_decl_no_pat(&sig.decl, |span, mut_ident| {\n-                    if mut_ident {\n-                        self.lint_buffer.buffer_lint(\n-                            PATTERNS_IN_FNS_WITHOUT_BODY,\n-                            ti.id,\n-                            span,\n-                            \"patterns aren't allowed in methods without bodies\",\n-                        );\n-                    } else {\n-                        struct_span_err!(\n-                            self.session,\n-                            span,\n-                            E0642,\n-                            \"patterns aren't allowed in methods without bodies\"\n-                        )\n-                        .emit();\n-                    }\n-                });\n-            }\n+    fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        if ctxt == AssocCtxt::Trait {\n+            self.check_defaultness(item.span, item.defaultness);\n         }\n \n-        visit::walk_trait_item(self, ti);\n-    }\n+        if ctxt == AssocCtxt::Impl {\n+            match &item.kind {\n+                AssocItemKind::Const(_, body) => {\n+                    self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n+                }\n+                AssocItemKind::Fn(_, body) => {\n+                    self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n+                }\n+                AssocItemKind::TyAlias(bounds, body) => {\n+                    self.check_impl_item_provided(item.span, body, \"type\", \" = <type>;\");\n+                    self.check_impl_assoc_type_no_bounds(bounds);\n+                }\n+                _ => {}\n+            }\n+        }\n \n-    fn visit_assoc_item(&mut self, item: &'a AssocItem) {\n-        if let AssocItemKind::Fn(sig, _) = &item.kind {\n-            self.check_fn_decl(&sig.decl, SelfSemantic::Yes);\n-            self.check_c_varadic_type(&sig.decl);\n+        if ctxt == AssocCtxt::Trait || self.in_trait_impl {\n+            self.invalid_visibility(&item.vis, None);\n+            if let AssocItemKind::Fn(sig, _) = &item.kind {\n+                self.check_trait_fn_not_const(sig.header.constness);\n+                self.check_trait_fn_not_async(item.span, sig.header.asyncness.node);\n+            }\n         }\n-        visit::walk_assoc_item(self, item);\n+\n+        self.with_in_trait_impl(false, |this| visit::walk_assoc_item(this, item, ctxt));\n     }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {\n     let mut validator = AstValidator {\n         session,\n+        extern_mod: None,\n+        in_trait_impl: false,\n         has_proc_macro_decls: false,\n         outer_impl_trait: None,\n         bound_context: None,"}, {"sha": "a10ac94d8942bca16cc0b048a4bb7f36c5f997d7", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -8,7 +8,7 @@ use rustc_span::Span;\n use syntax::ast::{self, AssocTyConstraint, AssocTyConstraintKind, NodeId};\n use syntax::ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n use syntax::attr;\n-use syntax::visit::{self, FnKind, Visitor};\n+use syntax::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n \n use log::debug;\n \n@@ -492,25 +492,17 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_pat(self, pattern)\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        fn_kind: FnKind<'a>,\n-        fn_decl: &'a ast::FnDecl,\n-        span: Span,\n-        _node_id: NodeId,\n-    ) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n         if let Some(header) = fn_kind.header() {\n-            // Stability of const fn methods are covered in\n-            // `visit_trait_item` and `visit_impl_item` below; this is\n-            // because default methods don't pass through this point.\n+            // Stability of const fn methods are covered in `visit_assoc_item` below.\n             self.check_extern(header.ext);\n         }\n \n-        if fn_decl.c_variadic() {\n+        if fn_kind.ctxt() != Some(FnCtxt::Foreign) && fn_kind.decl().c_variadic() {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }\n \n-        visit::walk_fn(self, fn_kind, fn_decl, span)\n+        visit::walk_fn(self, fn_kind, span)\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -539,56 +531,35 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_assoc_ty_constraint(self, constraint)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a ast::AssocItem) {\n-        match ti.kind {\n-            ast::AssocItemKind::Fn(ref sig, ref block) => {\n-                if block.is_none() {\n-                    self.check_extern(sig.header.ext);\n-                }\n-                if sig.header.constness.node == ast::Constness::Const {\n-                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n+    fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n+        if i.defaultness == ast::Defaultness::Default {\n+            gate_feature_post!(&self, specialization, i.span, \"specialization is unstable\");\n+        }\n+\n+        match i.kind {\n+            ast::AssocItemKind::Fn(ref sig, _) => {\n+                let constness = sig.header.constness.node;\n+                if let (ast::Constness::Const, AssocCtxt::Trait) = (constness, ctxt) {\n+                    gate_feature_post!(&self, const_fn, i.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::AssocItemKind::TyAlias(_, ref default) => {\n-                if let Some(_) = default {\n+            ast::AssocItemKind::TyAlias(_, ref ty) => {\n+                if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,\n                         associated_type_defaults,\n-                        ti.span,\n+                        i.span,\n                         \"associated type defaults are unstable\"\n                     );\n                 }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_assoc_item(&mut self, ii: &'a ast::AssocItem) {\n-        if ii.defaultness == ast::Defaultness::Default {\n-            gate_feature_post!(&self, specialization, ii.span, \"specialization is unstable\");\n-        }\n-\n-        match ii.kind {\n-            ast::AssocItemKind::Fn(ref sig, _) => {\n-                if sig.decl.c_variadic() {\n-                    gate_feature_post!(\n-                        &self,\n-                        c_variadic,\n-                        ii.span,\n-                        \"C-variadic functions are unstable\"\n-                    );\n-                }\n-            }\n-            ast::AssocItemKind::TyAlias(_, ref ty) => {\n                 if let Some(ty) = ty {\n                     self.check_impl_trait(ty);\n                 }\n-                self.check_gat(&ii.generics, ii.span);\n+                self.check_gat(&i.generics, i.span);\n             }\n             _ => {}\n         }\n-        visit::walk_assoc_item(self, ii)\n+        visit::walk_assoc_item(self, i, ctxt)\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {"}, {"sha": "ed1ccdf6a768ad79a1434c526e12d83224c21bed", "filename": "src/librustc_ast_passes/node_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_passes%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fnode_count.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -67,13 +67,13 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'_>, fd: &FnDecl, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'_>, s: Span, _: NodeId) {\n         self.count += 1;\n-        walk_fn(self, fk, fd, s)\n+        walk_fn(self, fk, s)\n     }\n-    fn visit_assoc_item(&mut self, ti: &AssocItem) {\n+    fn visit_assoc_item(&mut self, ti: &AssocItem, ctxt: AssocCtxt) {\n         self.count += 1;\n-        walk_assoc_item(self, ti)\n+        walk_assoc_item(self, ti, ctxt);\n     }\n     fn visit_trait_ref(&mut self, t: &TraitRef) {\n         self.count += 1;"}, {"sha": "d9077d1606f3a2ea2cb090eb976eed0413bc8bb7", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1020,18 +1020,8 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         match item.kind {\n-            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n-                self.head(\"\");\n-                self.print_fn(\n-                    decl,\n-                    ast::FnHeader::default(),\n-                    Some(item.ident),\n-                    generics,\n-                    &item.vis,\n-                );\n-                self.end(); // end head-ibox\n-                self.s.word(\";\");\n-                self.end(); // end the outer fn box\n+            ast::ForeignItemKind::Fn(ref sig, ref gen, ref body) => {\n+                self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n@@ -1154,11 +1144,8 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref sig, ref param_names, ref body) => {\n-                self.head(\"\");\n-                self.print_fn(&sig.decl, sig.header, Some(item.ident), param_names, &item.vis);\n-                self.s.word(\" \");\n-                self.print_block_with_attrs(body, &item.attrs);\n+            ast::ItemKind::Fn(ref sig, ref gen, ref body) => {\n+                self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n                 self.head(visibility_qualified(&item.vis, \"mod\"));\n@@ -1483,16 +1470,8 @@ impl<'a> State<'a> {\n                 self.print_associated_const(item.ident, ty, expr.as_deref(), &item.vis);\n             }\n             ast::AssocItemKind::Fn(sig, body) => {\n-                if body.is_some() {\n-                    self.head(\"\");\n-                }\n-                self.print_fn(&sig.decl, sig.header, Some(item.ident), &item.generics, &item.vis);\n-                if let Some(body) = body {\n-                    self.nbsp();\n-                    self.print_block_with_attrs(body, &item.attrs);\n-                } else {\n-                    self.s.word(\";\");\n-                }\n+                let body = body.as_deref();\n+                self.print_fn_full(sig, item.ident, &item.generics, &item.vis, body, &item.attrs);\n             }\n             ast::AssocItemKind::TyAlias(bounds, ty) => {\n                 self.print_associated_type(item.ident, bounds, ty.as_deref());\n@@ -2412,6 +2391,27 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_fn_full(\n+        &mut self,\n+        sig: &ast::FnSig,\n+        name: ast::Ident,\n+        generics: &ast::Generics,\n+        vis: &ast::Visibility,\n+        body: Option<&ast::Block>,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        if body.is_some() {\n+            self.head(\"\");\n+        }\n+        self.print_fn(&sig.decl, sig.header, Some(name), generics, vis);\n+        if let Some(body) = body {\n+            self.nbsp();\n+            self.print_block_with_attrs(body, attrs);\n+        } else {\n+            self.s.word(\";\");\n+        }\n+    }\n+\n     crate fn print_fn(\n         &mut self,\n         decl: &ast::FnDecl,\n@@ -2698,13 +2698,9 @@ impl<'a> State<'a> {\n             where_clause: ast::WhereClause { predicates: Vec::new(), span: rustc_span::DUMMY_SP },\n             span: rustc_span::DUMMY_SP,\n         };\n-        self.print_fn(\n-            decl,\n-            ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() },\n-            name,\n-            &generics,\n-            &dummy_spanned(ast::VisibilityKind::Inherited),\n-        );\n+        let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };\n+        let vis = dummy_spanned(ast::VisibilityKind::Inherited);\n+        self.print_fn(decl, header, name, &generics, &vis);\n         self.end();\n     }\n "}, {"sha": "ec0d55b38a73d90595e7708858381c165044e942", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -66,7 +66,7 @@ impl AllocFnFactory<'_, '_> {\n         let decl = self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty));\n         let header = FnHeader { unsafety: Unsafety::Unsafe, ..FnHeader::default() };\n         let sig = FnSig { decl, header };\n-        let kind = ItemKind::Fn(sig, Generics::default(), self.cx.block_expr(output_expr));\n+        let kind = ItemKind::Fn(sig, Generics::default(), Some(self.cx.block_expr(output_expr)));\n         let item = self.cx.item(\n             self.span,\n             self.cx.ident_of(&self.kind.fn_name(method.name), self.span),"}, {"sha": "70f1c0e4e2d7cef1a2fa3b7f099b80ca5d9e0e6e", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -307,7 +307,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     let decl = ecx.fn_decl(vec![], ast::FunctionRetTy::Ty(main_ret_ty));\n     let sig = ast::FnSig { decl, header: ast::FnHeader::default() };\n-    let main = ast::ItemKind::Fn(sig, ast::Generics::default(), main_body);\n+    let main = ast::ItemKind::Fn(sig, ast::Generics::default(), Some(main_body));\n \n     // Honor the reexport_test_harness_main attribute\n     let main_id = match cx.reexport_test_harness_main {"}, {"sha": "e167089b93a356692cd40fea275122b867320326", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -17,7 +17,7 @@ use syntax::mut_visit::{self, MutVisitor};\n use syntax::ptr::P;\n use syntax::token;\n use syntax::tokenstream::{self, TokenStream};\n-use syntax::visit::Visitor;\n+use syntax::visit::{AssocCtxt, Visitor};\n \n use std::default::Default;\n use std::iter;\n@@ -103,8 +103,8 @@ impl Annotatable {\n     pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n         match self {\n             Annotatable::Item(item) => visitor.visit_item(item),\n-            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n-            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::TraitItem(item) => visitor.visit_assoc_item(item, AssocCtxt::Trait),\n+            Annotatable::ImplItem(item) => visitor.visit_assoc_item(item, AssocCtxt::Impl),\n             Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n             Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n             Annotatable::Expr(expr) => visitor.visit_expr(expr),"}, {"sha": "90692fe1ec9dd39e5c22bdfcaa577ee03de6c775", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -25,7 +25,7 @@ use syntax::ptr::P;\n use syntax::token;\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::util::map_in_place::MapInPlace;\n-use syntax::visit::{self, Visitor};\n+use syntax::visit::{self, AssocCtxt, Visitor};\n \n use smallvec::{smallvec, SmallVec};\n use std::io::ErrorKind;\n@@ -39,7 +39,7 @@ macro_rules! ast_fragments {\n         $($Kind:ident($AstTy:ty) {\n             $kind_name:expr;\n             $(one fn $mut_visit_ast:ident; fn $visit_ast:ident;)?\n-            $(many fn $flat_map_ast_elt:ident; fn $visit_ast_elt:ident;)?\n+            $(many fn $flat_map_ast_elt:ident; fn $visit_ast_elt:ident($($args:tt)*);)?\n             fn $make_ast:ident;\n         })*\n     ) => {\n@@ -127,7 +127,7 @@ macro_rules! ast_fragments {\n                     AstFragment::OptExpr(None) => {}\n                     $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n-                        visitor.$visit_ast_elt(ast_elt);\n+                        visitor.$visit_ast_elt(ast_elt, $($args)*);\n                     })?)*\n                 }\n             }\n@@ -147,52 +147,58 @@ ast_fragments! {\n     Pat(P<ast::Pat>) { \"pattern\"; one fn visit_pat; fn visit_pat; fn make_pat; }\n     Ty(P<ast::Ty>) { \"type\"; one fn visit_ty; fn visit_ty; fn make_ty; }\n     Stmts(SmallVec<[ast::Stmt; 1]>) {\n-        \"statement\"; many fn flat_map_stmt; fn visit_stmt; fn make_stmts;\n+        \"statement\"; many fn flat_map_stmt; fn visit_stmt(); fn make_stmts;\n     }\n     Items(SmallVec<[P<ast::Item>; 1]>) {\n-        \"item\"; many fn flat_map_item; fn visit_item; fn make_items;\n+        \"item\"; many fn flat_map_item; fn visit_item(); fn make_items;\n     }\n     TraitItems(SmallVec<[P<ast::AssocItem>; 1]>) {\n-        \"trait item\"; many fn flat_map_trait_item; fn visit_trait_item; fn make_trait_items;\n+        \"trait item\";\n+        many fn flat_map_trait_item;\n+        fn visit_assoc_item(AssocCtxt::Trait);\n+        fn make_trait_items;\n     }\n     ImplItems(SmallVec<[P<ast::AssocItem>; 1]>) {\n-        \"impl item\"; many fn flat_map_impl_item; fn visit_impl_item; fn make_impl_items;\n+        \"impl item\";\n+        many fn flat_map_impl_item;\n+        fn visit_assoc_item(AssocCtxt::Impl);\n+        fn make_impl_items;\n     }\n     ForeignItems(SmallVec<[P<ast::ForeignItem>; 1]>) {\n         \"foreign item\";\n         many fn flat_map_foreign_item;\n-        fn visit_foreign_item;\n+        fn visit_foreign_item();\n         fn make_foreign_items;\n     }\n     Arms(SmallVec<[ast::Arm; 1]>) {\n-        \"match arm\"; many fn flat_map_arm; fn visit_arm; fn make_arms;\n+        \"match arm\"; many fn flat_map_arm; fn visit_arm(); fn make_arms;\n     }\n     Fields(SmallVec<[ast::Field; 1]>) {\n-        \"field expression\"; many fn flat_map_field; fn visit_field; fn make_fields;\n+        \"field expression\"; many fn flat_map_field; fn visit_field(); fn make_fields;\n     }\n     FieldPats(SmallVec<[ast::FieldPat; 1]>) {\n         \"field pattern\";\n         many fn flat_map_field_pattern;\n-        fn visit_field_pattern;\n+        fn visit_field_pattern();\n         fn make_field_patterns;\n     }\n     GenericParams(SmallVec<[ast::GenericParam; 1]>) {\n         \"generic parameter\";\n         many fn flat_map_generic_param;\n-        fn visit_generic_param;\n+        fn visit_generic_param();\n         fn make_generic_params;\n     }\n     Params(SmallVec<[ast::Param; 1]>) {\n-        \"function parameter\"; many fn flat_map_param; fn visit_param; fn make_params;\n+        \"function parameter\"; many fn flat_map_param; fn visit_param(); fn make_params;\n     }\n     StructFields(SmallVec<[ast::StructField; 1]>) {\n         \"field\";\n         many fn flat_map_struct_field;\n-        fn visit_struct_field;\n+        fn visit_struct_field();\n         fn make_struct_fields;\n     }\n     Variants(SmallVec<[ast::Variant; 1]>) {\n-        \"variant\"; many fn flat_map_variant; fn visit_variant; fn make_variants;\n+        \"variant\"; many fn flat_map_variant; fn visit_variant(); fn make_variants;\n     }\n }\n \n@@ -861,7 +867,7 @@ pub fn parse_ast_fragment<'a>(\n         AstFragmentKind::ForeignItems => {\n             let mut items = SmallVec::new();\n             while this.token != token::Eof {\n-                items.push(this.parse_foreign_item(DUMMY_SP)?);\n+                items.push(this.parse_foreign_item()?);\n             }\n             AstFragment::ForeignItems(items)\n         }"}, {"sha": "f024bb0e8b5c8264dac077222c09a5b1ddc330b1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -43,7 +43,7 @@ use rustc_span::{BytePos, Span};\n use syntax::ast::{self, Expr};\n use syntax::attr::{self, HasAttrs};\n use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax::visit::FnKind;\n+use syntax::visit::{FnCtxt, FnKind};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -259,34 +259,22 @@ impl EarlyLintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_fn(\n-        &mut self,\n-        cx: &EarlyContext<'_>,\n-        fk: FnKind<'_>,\n-        _: &ast::FnDecl,\n-        span: Span,\n-        _: ast::NodeId,\n-    ) {\n-        match fk {\n-            FnKind::ItemFn(_, ast::FnHeader { unsafety: ast::Unsafety::Unsafe, .. }, ..) => {\n-                self.report_unsafe(cx, span, \"declaration of an `unsafe` function\")\n-            }\n-\n-            FnKind::Method(_, sig, ..) => {\n-                if sig.header.unsafety == ast::Unsafety::Unsafe {\n-                    self.report_unsafe(cx, span, \"implementation of an `unsafe` method\")\n-                }\n-            }\n-\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, item: &ast::AssocItem) {\n-        if let ast::AssocItemKind::Fn(ref sig, None) = item.kind {\n-            if sig.header.unsafety == ast::Unsafety::Unsafe {\n-                self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n-            }\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fk: FnKind<'_>, span: Span, _: ast::NodeId) {\n+        if let FnKind::Fn(\n+            ctxt,\n+            _,\n+            ast::FnSig { header: ast::FnHeader { unsafety: ast::Unsafety::Unsafe, .. }, .. },\n+            _,\n+            body,\n+        ) = fk\n+        {\n+            let msg = match ctxt {\n+                FnCtxt::Foreign => return,\n+                FnCtxt::Free => \"declaration of an `unsafe` function\",\n+                FnCtxt::Assoc(_) if body.is_none() => \"declaration of an `unsafe` method\",\n+                FnCtxt::Assoc(_) => \"implementation of an `unsafe` method\",\n+            };\n+            self.report_unsafe(cx, span, msg);\n         }\n     }\n }"}, {"sha": "542cbea0c954a74383dd5871d4e791f8ae6bc726", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -116,17 +116,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         ast_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        fk: ast_visit::FnKind<'a>,\n-        decl: &'a ast::FnDecl,\n-        span: Span,\n-        id: ast::NodeId,\n-    ) {\n-        run_early_pass!(self, check_fn, fk, decl, span, id);\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, span: Span, id: ast::NodeId) {\n+        run_early_pass!(self, check_fn, fk, span, id);\n         self.check_id(id);\n-        ast_visit::walk_fn(self, fk, decl, span);\n-        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n+        ast_visit::walk_fn(self, fk, span);\n+        run_early_pass!(self, check_fn_post, fk, span, id);\n     }\n \n     fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n@@ -213,19 +207,18 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         ast_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n-            run_early_pass!(cx, check_trait_item, trait_item);\n-            ast_visit::walk_trait_item(cx, trait_item);\n-            run_early_pass!(cx, check_trait_item_post, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n-            run_early_pass!(cx, check_impl_item, impl_item);\n-            ast_visit::walk_impl_item(cx, impl_item);\n-            run_early_pass!(cx, check_impl_item_post, impl_item);\n+    fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n+        self.with_lint_attrs(item.id, &item.attrs, |cx| match ctxt {\n+            ast_visit::AssocCtxt::Trait => {\n+                run_early_pass!(cx, check_trait_item, item);\n+                ast_visit::walk_assoc_item(cx, item, ctxt);\n+                run_early_pass!(cx, check_trait_item_post, item);\n+            }\n+            ast_visit::AssocCtxt::Impl => {\n+                run_early_pass!(cx, check_impl_item, item);\n+                ast_visit::walk_assoc_item(cx, item, ctxt);\n+                run_early_pass!(cx, check_impl_item_post, item);\n+            }\n         });\n     }\n "}, {"sha": "36de625cafac2e18002786326ef857fc58edae8c", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -179,10 +179,9 @@ macro_rules! early_lint_methods {\n             fn check_where_predicate(a: &ast::WherePredicate);\n             fn check_poly_trait_ref(a: &ast::PolyTraitRef,\n                                     b: &ast::TraitBoundModifier);\n-            fn check_fn(a: syntax::visit::FnKind<'_>, b: &ast::FnDecl, c: Span, d_: ast::NodeId);\n+            fn check_fn(a: syntax::visit::FnKind<'_>, c: Span, d_: ast::NodeId);\n             fn check_fn_post(\n                 a: syntax::visit::FnKind<'_>,\n-                b: &ast::FnDecl,\n                 c: Span,\n                 d: ast::NodeId\n             );"}, {"sha": "7c015c7a1d75de3ed367257e9dd68c96514cb893", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,3 +1,4 @@\n+use super::ty::AllowPlus;\n use super::{BlockMode, Parser, PathStyle, SemiColonMode, SeqSep, TokenExpectType, TokenType};\n \n use rustc_ast_pretty::pprust;\n@@ -693,11 +694,11 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_report_ambiguous_plus(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         impl_dyn_multi: bool,\n         ty: &Ty,\n     ) {\n-        if !allow_plus && impl_dyn_multi {\n+        if matches!(allow_plus, AllowPlus::No) && impl_dyn_multi {\n             let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n             self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n                 .span_suggestion(\n@@ -712,11 +713,11 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_recover_from_bad_type_plus(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         ty: &Ty,\n     ) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n-        if !allow_plus || !self.token.is_like_plus() {\n+        if matches!(allow_plus, AllowPlus::No) || !self.token.is_like_plus() {\n             return Ok(());\n         }\n \n@@ -937,47 +938,6 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Semi).map(drop) // Error unconditionally\n     }\n \n-    pub(super) fn parse_semi_or_incorrect_foreign_fn_body(\n-        &mut self,\n-        ident: &Ident,\n-        extern_sp: Span,\n-    ) -> PResult<'a, ()> {\n-        if self.token != token::Semi {\n-            // This might be an incorrect fn definition (#62109).\n-            let parser_snapshot = self.clone();\n-            match self.parse_inner_attrs_and_block() {\n-                Ok((_, body)) => {\n-                    self.struct_span_err(ident.span, \"incorrect `fn` inside `extern` block\")\n-                        .span_label(ident.span, \"can't have a body\")\n-                        .span_label(body.span, \"this body is invalid here\")\n-                        .span_label(\n-                            extern_sp,\n-                            \"`extern` blocks define existing foreign functions and `fn`s \\\n-                             inside of them cannot have a body\",\n-                        )\n-                        .help(\n-                            \"you might have meant to write a function accessible through ffi, \\\n-                               which can be done by writing `extern fn` outside of the \\\n-                               `extern` block\",\n-                        )\n-                        .note(\n-                            \"for more information, visit \\\n-                               https://doc.rust-lang.org/std/keyword.extern.html\",\n-                        )\n-                        .emit();\n-                }\n-                Err(mut err) => {\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot);\n-                    self.expect_semi()?;\n-                }\n-            }\n-        } else {\n-            self.bump();\n-        }\n-        Ok(())\n-    }\n-\n     /// Consumes alternative await syntaxes like `await!(<expr>)`, `await <expr>`,\n     /// `await? <expr>`, `await(<expr>)`, and `await { <expr> }`.\n     pub(super) fn recover_incorrect_await_syntax("}, {"sha": "d98321416957db33e9b42562860cb5733667e5e8", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,4 +1,5 @@\n use super::pat::{GateOr, PARAM_EXPECTED};\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{BlockMode, Parser, PathStyle, PrevTokenKind, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n@@ -1399,7 +1400,7 @@ impl<'a> Parser<'a> {\n             self.expect_or()?;\n             args\n         };\n-        let output = self.parse_ret_ty(true, true)?;\n+        let output = self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes)?;\n \n         Ok(P(FnDecl { inputs, output }))\n     }"}, {"sha": "07d8bae4725bdc19042440770d5a1b417d0180b4", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,4 +1,5 @@\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n@@ -96,7 +97,6 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.eat_keyword(kw::Extern) {\n-            let extern_sp = self.prev_span;\n             if self.eat_keyword(kw::Crate) {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n@@ -114,7 +114,7 @@ impl<'a> Parser<'a> {\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n-                return Ok(Some(self.parse_item_foreign_mod(lo, abi, vis, attrs, extern_sp)?));\n+                return Ok(Some(self.parse_item_foreign_mod(lo, abi, vis, attrs)?));\n             }\n \n             self.unexpected()?;\n@@ -1045,15 +1045,14 @@ impl<'a> Parser<'a> {\n         abi: Option<StrLit>,\n         visibility: Visibility,\n         mut attrs: Vec<Attribute>,\n-        extern_sp: Span,\n     ) -> PResult<'a, P<Item>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n         attrs.extend(self.parse_inner_attributes()?);\n \n         let mut foreign_items = vec![];\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            foreign_items.push(self.parse_foreign_item(extern_sp)?);\n+            foreign_items.push(self.parse_foreign_item()?);\n         }\n \n         let prev_span = self.prev_span;\n@@ -1063,51 +1062,42 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a foreign item.\n-    pub fn parse_foreign_item(&mut self, extern_sp: Span) -> PResult<'a, P<ForeignItem>> {\n+    pub fn parse_foreign_item(&mut self) -> PResult<'a, P<ForeignItem>> {\n         maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let visibility = self.parse_visibility(FollowedByType::No)?;\n \n+        // FOREIGN TYPE ITEM\n+        if self.check_keyword(kw::Type) {\n+            return self.parse_item_foreign_type(visibility, lo, attrs);\n+        }\n+\n         // FOREIGN STATIC ITEM\n-        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-        if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n-            if self.token.is_keyword(kw::Const) {\n-                let mut err =\n-                    self.struct_span_err(self.token.span, \"extern items cannot be `const`\");\n+        if self.is_static_global() {\n+            self.bump(); // `static`\n+            return self.parse_item_foreign_static(visibility, lo, attrs);\n+        }\n \n-                // The user wrote 'const fn'\n-                if self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe]) {\n-                    err.emit();\n-                    // Consume `const`\n-                    self.bump();\n-                    // Consume `unsafe` if present, since `extern` blocks\n-                    // don't allow it. This will leave behind a plain 'fn'\n-                    self.eat_keyword(kw::Unsafe);\n-                    // Treat 'const fn` as a plain `fn` for error recovery purposes.\n-                    // We've already emitted an error, so compilation is guaranteed\n-                    // to fail\n-                    return Ok(self.parse_item_foreign_fn(visibility, lo, attrs, extern_sp)?);\n-                }\n-                err.span_suggestion(\n-                    self.token.span,\n+        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n+        if self.is_kw_followed_by_ident(kw::Const) {\n+            self.bump(); // `const`\n+            self.struct_span_err(self.prev_span, \"extern items cannot be `const`\")\n+                .span_suggestion(\n+                    self.prev_span,\n                     \"try using a static value\",\n                     \"static\".to_owned(),\n                     Applicability::MachineApplicable,\n-                );\n-                err.emit();\n-            }\n-            self.bump(); // `static` or `const`\n-            return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n+                )\n+                .emit();\n+            return self.parse_item_foreign_static(visibility, lo, attrs);\n         }\n+\n         // FOREIGN FUNCTION ITEM\n-        if self.check_keyword(kw::Fn) {\n-            return Ok(self.parse_item_foreign_fn(visibility, lo, attrs, extern_sp)?);\n-        }\n-        // FOREIGN TYPE ITEM\n-        if self.check_keyword(kw::Type) {\n-            return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n+        const MAY_INTRODUCE_FN: &[Symbol] = &[kw::Const, kw::Async, kw::Unsafe, kw::Extern, kw::Fn];\n+        if MAY_INTRODUCE_FN.iter().any(|&kw| self.check_keyword(kw)) {\n+            return self.parse_item_foreign_fn(visibility, lo, attrs);\n         }\n \n         match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n@@ -1726,30 +1716,29 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         vis: Visibility,\n-        attrs: Vec<Attribute>,\n+        mut attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n         let cfg = ParamCfg { is_name_required: |_| true };\n         let (ident, decl, generics) = self.parse_fn_sig(&cfg)?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let body = self.parse_fn_body(&mut false, &mut attrs)?;\n         let kind = ItemKind::Fn(FnSig { decl, header }, generics, body);\n-        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n+        self.mk_item_with_info(attrs, lo, vis, (ident, kind, None))\n     }\n \n     /// Parses a function declaration from a foreign module.\n     fn parse_item_foreign_fn(\n         &mut self,\n         vis: ast::Visibility,\n         lo: Span,\n-        attrs: Vec<Attribute>,\n-        extern_sp: Span,\n+        mut attrs: Vec<Attribute>,\n     ) -> PResult<'a, P<ForeignItem>> {\n         let cfg = ParamCfg { is_name_required: |_| true };\n-        self.expect_keyword(kw::Fn)?;\n+        let header = self.parse_fn_front_matter()?;\n         let (ident, decl, generics) = self.parse_fn_sig(&cfg)?;\n-        let span = lo.to(self.token.span);\n-        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n-        let kind = ForeignItemKind::Fn(decl, generics);\n+        let body = self.parse_fn_body(&mut false, &mut attrs)?;\n+        let kind = ForeignItemKind::Fn(FnSig { header, decl }, generics, body);\n+        let span = lo.to(self.prev_span);\n         Ok(P(ast::ForeignItem { ident, attrs, kind, id: DUMMY_NODE_ID, span, vis, tokens: None }))\n     }\n \n@@ -1760,45 +1749,40 @@ impl<'a> Parser<'a> {\n         is_name_required: fn(&token::Token) -> bool,\n     ) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n         let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) = self.parse_fn_sig(&ParamCfg { is_name_required })?;\n-        let sig = FnSig { header, decl };\n-        let body = self.parse_assoc_fn_body(at_end, attrs)?;\n-        Ok((ident, AssocItemKind::Fn(sig, body), generics))\n+        let (ident, decl, generics) = self.parse_fn_sig(&&ParamCfg { is_name_required })?;\n+        let body = self.parse_fn_body(at_end, attrs)?;\n+        Ok((ident, AssocItemKind::Fn(FnSig { header, decl }, body), generics))\n     }\n \n-    /// Parse the \"body\" of a method in an associated item definition.\n+    /// Parse the \"body\" of a function.\n     /// This can either be `;` when there's no body,\n-    /// or e.g. a block when the method is a provided one.\n-    fn parse_assoc_fn_body(\n+    /// or e.g. a block when the function is a provided one.\n+    fn parse_fn_body(\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n     ) -> PResult<'a, Option<P<Block>>> {\n-        Ok(match self.token.kind {\n+        let (inner_attrs, body) = match self.token.kind {\n             token::Semi => {\n-                debug!(\"parse_assoc_fn_body(): parsing required method\");\n                 self.bump();\n-                *at_end = true;\n-                None\n+                (Vec::new(), None)\n             }\n             token::OpenDelim(token::Brace) => {\n-                debug!(\"parse_assoc_fn_body(): parsing provided method\");\n-                *at_end = true;\n-                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                attrs.extend(inner_attrs.iter().cloned());\n-                Some(body)\n+                let (attrs, body) = self.parse_inner_attrs_and_block()?;\n+                (attrs, Some(body))\n             }\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtBlock(..) => {\n-                    *at_end = true;\n-                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n+                    let (attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    (attrs, Some(body))\n                 }\n                 _ => return self.expected_semi_or_open_brace(),\n             },\n             _ => return self.expected_semi_or_open_brace(),\n-        })\n+        };\n+        attrs.extend(inner_attrs);\n+        *at_end = true;\n+        Ok(body)\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -1839,7 +1823,7 @@ impl<'a> Parser<'a> {\n     fn parse_fn_sig(&mut self, cfg: &ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n-        let decl = self.parse_fn_decl(cfg, true)?;\n+        let decl = self.parse_fn_decl(cfg, AllowPlus::Yes)?;\n         generics.where_clause = self.parse_where_clause()?;\n         Ok((ident, decl, generics))\n     }\n@@ -1848,11 +1832,11 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_fn_decl(\n         &mut self,\n         cfg: &ParamCfg,\n-        ret_allow_plus: bool,\n+        ret_allow_plus: AllowPlus,\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n             inputs: self.parse_fn_params(cfg)?,\n-            output: self.parse_ret_ty(ret_allow_plus, true)?,\n+            output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?,\n         }))\n     }\n "}, {"sha": "cb14ffb4bd028ef713321868052a27dbb5c22a4b", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,3 +1,4 @@\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_errors::{pluralize, Applicability, PResult};\n@@ -224,7 +225,7 @@ impl<'a> Parser<'a> {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                     let span = ident.span.to(self.prev_span);\n-                    let output = self.parse_ret_ty(false, false)?;\n+                    let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No)?;\n                     ParenthesizedArgs { inputs, output, span }.into()\n                 };\n "}, {"sha": "f3a69729399c1b938e85dd070c0dcef1b2316313", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -199,7 +199,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n+    pub(super) fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n         self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n "}, {"sha": "990661bf6b5b986023c229549b23ec7b74c74e33", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -36,6 +36,25 @@ impl BoundModifiers {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub(super) enum AllowPlus {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(PartialEq)]\n+pub(super) enum RecoverQPath {\n+    Yes,\n+    No,\n+}\n+\n+// Is `...` (`CVarArgs`) legal at this level of type parsing?\n+#[derive(PartialEq)]\n+enum AllowCVariadic {\n+    Yes,\n+    No,\n+}\n+\n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n /// `IDENT<<u8 as Trait>::AssocTy>`.\n ///\n@@ -48,14 +67,14 @@ fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n impl<'a> Parser<'a> {\n     /// Parses a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true, false)\n+        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::No)\n     }\n \n     /// Parse a type suitable for a function or function pointer parameter.\n     /// The difference from `parse_ty` is that this version allows `...`\n     /// (`CVarArgs`) at the top level of the the type.\n     pub(super) fn parse_ty_for_param(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true, true)\n+        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::Yes)\n     }\n \n     /// Parses a type in restricted contexts where `+` is not permitted.\n@@ -65,30 +84,31 @@ impl<'a> Parser<'a> {\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n     pub(super) fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(false, true, false)\n+        self.parse_ty_common(AllowPlus::No, RecoverQPath::Yes, AllowCVariadic::No)\n     }\n \n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     pub(super) fn parse_ret_ty(\n         &mut self,\n-        allow_plus: bool,\n-        allow_qpath_recovery: bool,\n+        allow_plus: AllowPlus,\n+        recover_qpath: RecoverQPath,\n     ) -> PResult<'a, FunctionRetTy> {\n         Ok(if self.eat(&token::RArrow) {\n             // FIXME(Centril): Can we unconditionally `allow_plus`?\n-            FunctionRetTy::Ty(self.parse_ty_common(allow_plus, allow_qpath_recovery, false)?)\n+            let ty = self.parse_ty_common(allow_plus, recover_qpath, AllowCVariadic::No)?;\n+            FunctionRetTy::Ty(ty)\n         } else {\n             FunctionRetTy::Default(self.token.span.shrink_to_lo())\n         })\n     }\n \n     fn parse_ty_common(\n         &mut self,\n-        allow_plus: bool,\n-        allow_qpath_recovery: bool,\n-        // Is `...` (`CVarArgs`) legal in the immediate top level call?\n-        allow_c_variadic: bool,\n+        allow_plus: AllowPlus,\n+        recover_qpath: RecoverQPath,\n+        allow_c_variadic: AllowCVariadic,\n     ) -> PResult<'a, P<Ty>> {\n+        let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n@@ -124,7 +144,7 @@ impl<'a> Parser<'a> {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let parse_plus = allow_plus && self.check_plus();\n+                let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n                 self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(kw::Impl) {\n@@ -144,7 +164,7 @@ impl<'a> Parser<'a> {\n         } else if self.token.is_path_start() {\n             self.parse_path_start_ty(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n-            if allow_c_variadic {\n+            if allow_c_variadic == AllowCVariadic::Yes {\n                 TyKind::CVarArgs\n             } else {\n                 // FIXME(Centril): Should we just allow `...` syntactically\n@@ -172,7 +192,7 @@ impl<'a> Parser<'a> {\n     /// Parses either:\n     /// - `(TYPE)`, a parenthesized type.\n     /// - `(TYPE,)`, a tuple with a single field of type TYPE.\n-    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n         let mut trailing_plus = false;\n         let (ts, trailing) = self.parse_paren_comma_seq(|p| {\n             let ty = p.parse_ty()?;\n@@ -182,7 +202,7 @@ impl<'a> Parser<'a> {\n \n         if ts.len() == 1 && !trailing {\n             let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-            let maybe_bounds = allow_plus && self.token.is_like_plus();\n+            let maybe_bounds = allow_plus == AllowPlus::Yes && self.token.is_like_plus();\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                 TyKind::Path(None, path) if maybe_bounds => {\n@@ -288,7 +308,8 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n-        let decl = self.parse_fn_decl(&ParamCfg { is_name_required: |_| false }, false)?;\n+        let cfg = ParamCfg { is_name_required: |_| false };\n+        let decl = self.parse_fn_decl(&cfg, AllowPlus::No)?;\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params, decl })))\n     }\n \n@@ -326,7 +347,7 @@ impl<'a> Parser<'a> {\n     /// 1. a type macro, `mac!(...)`,\n     /// 2. a bare trait object, `B0 + ... + Bn`,\n     /// 3. or a path, `path::to::MyType`.\n-    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n         // Simple path\n         let path = self.parse_path(PathStyle::Type)?;\n         if self.eat(&token::Not) {\n@@ -336,7 +357,7 @@ impl<'a> Parser<'a> {\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             }))\n-        } else if allow_plus && self.check_plus() {\n+        } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n             self.parse_remaining_bounds(Vec::new(), path, lo, true)\n         } else {\n@@ -359,15 +380,15 @@ impl<'a> Parser<'a> {\n         &mut self,\n         colon_span: Option<Span>,\n     ) -> PResult<'a, GenericBounds> {\n-        self.parse_generic_bounds_common(true, colon_span)\n+        self.parse_generic_bounds_common(AllowPlus::Yes, colon_span)\n     }\n \n     /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n     ///\n     /// See `parse_generic_bound` for the `BOUND` grammar.\n     fn parse_generic_bounds_common(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         colon_span: Option<Span>,\n     ) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n@@ -377,7 +398,7 @@ impl<'a> Parser<'a> {\n                 Ok(bound) => bounds.push(bound),\n                 Err(neg_sp) => negative_bounds.push(neg_sp),\n             }\n-            if !allow_plus || !self.eat_plus() {\n+            if allow_plus == AllowPlus::No || !self.eat_plus() {\n                 break;\n             }\n         }"}, {"sha": "c6c201fa38ec16744bb25a5ff228c17a7d427500", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -302,19 +302,18 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_ty(self, t)\n     }\n \n-    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, fd: &'v ast::FnDecl, s: Span, _: NodeId) {\n-        self.record(\"FnDecl\", Id::None, fd);\n-        ast_visit::walk_fn(self, fk, fd, s)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'v ast::AssocItem) {\n-        self.record(\"TraitItem\", Id::None, ti);\n-        ast_visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v ast::AssocItem) {\n-        self.record(\"ImplItem\", Id::None, ii);\n-        ast_visit::walk_impl_item(self, ii)\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, s: Span, _: NodeId) {\n+        self.record(\"FnDecl\", Id::None, fk.decl());\n+        ast_visit::walk_fn(self, fk, s)\n+    }\n+\n+    fn visit_assoc_item(&mut self, item: &'v ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n+        let label = match ctxt {\n+            ast_visit::AssocCtxt::Trait => \"TraitItem\",\n+            ast_visit::AssocCtxt::Impl => \"ImplItem\",\n+        };\n+        self.record(label, Id::None, item);\n+        ast_visit::walk_assoc_item(self, item, ctxt);\n     }\n \n     fn visit_param_bound(&mut self, bounds: &'v ast::GenericBound) {"}, {"sha": "d6ea737385cdd094e0f6cd800f89dde03c04d1db", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -36,7 +36,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, Nod\n use syntax::ast::{AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n use syntax::ast::{Ident, Name};\n use syntax::token::{self, Token};\n-use syntax::visit::{self, Visitor};\n+use syntax::visit::{self, AssocCtxt, Visitor};\n \n use log::debug;\n use std::cell::Cell;\n@@ -1234,14 +1234,20 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         self.parent_scope.legacy = orig_current_legacy_scope;\n     }\n \n-    fn visit_trait_item(&mut self, item: &'b AssocItem) {\n+    fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {\n         let parent = self.parent_scope.module;\n \n         if let AssocItemKind::Macro(_) = item.kind {\n             self.visit_invoc(item.id);\n             return;\n         }\n \n+        if let AssocCtxt::Impl = ctxt {\n+            self.resolve_visibility(&item.vis);\n+            visit::walk_assoc_item(self, item, ctxt);\n+            return;\n+        }\n+\n         // Add the item to the trait info.\n         let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.kind {\n@@ -1260,16 +1266,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         let expansion = self.parent_scope.expansion;\n         self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n \n-        visit::walk_trait_item(self, item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'b ast::AssocItem) {\n-        if let ast::AssocItemKind::Macro(..) = item.kind {\n-            self.visit_invoc(item.id);\n-        } else {\n-            self.resolve_visibility(&item.vis);\n-            visit::walk_impl_item(self, item);\n-        }\n+        visit::walk_assoc_item(self, item, ctxt);\n     }\n \n     fn visit_token(&mut self, t: Token) {"}, {"sha": "3a26197c1607a159ef16fc8ce12d8d8479e39444", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -125,7 +125,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     &sig.header,\n                     generics,\n                     &sig.decl,\n-                    Some(body),\n+                    body.as_deref(),\n                 );\n             }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) => {\n@@ -213,39 +213,26 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         visit::walk_generic_param(self, param);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a AssocItem) {\n-        let def_data = match ti.kind {\n-            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(ti.ident.name),\n-            AssocItemKind::TyAlias(..) => DefPathData::TypeNs(ti.ident.name),\n-            AssocItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data, ti.span);\n-        self.with_parent(def, |this| visit::walk_trait_item(this, ti));\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'a AssocItem) {\n-        let def_data = match ii.kind {\n-            AssocItemKind::Fn(FnSig { ref header, ref decl }, ref body)\n-                if header.asyncness.node.is_async() =>\n-            {\n+    fn visit_assoc_item(&mut self, i: &'a AssocItem, ctxt: visit::AssocCtxt) {\n+        let def_data = match &i.kind {\n+            AssocItemKind::Fn(FnSig { header, decl }, body) if header.asyncness.node.is_async() => {\n                 return self.visit_async_fn(\n-                    ii.id,\n-                    ii.ident.name,\n-                    ii.span,\n+                    i.id,\n+                    i.ident.name,\n+                    i.span,\n                     header,\n-                    &ii.generics,\n+                    &i.generics,\n                     decl,\n                     body.as_deref(),\n                 );\n             }\n-            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n-            AssocItemKind::TyAlias(..) => DefPathData::TypeNs(ii.ident.name),\n-            AssocItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n+            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(i.ident.name),\n+            AssocItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n+            AssocItemKind::Macro(..) => return self.visit_macro_invoc(i.id),\n         };\n \n-        let def = self.create_def(ii.id, def_data, ii.span);\n-        self.with_parent(def, |this| visit::walk_impl_item(this, ii));\n+        let def = self.create_def(i.id, def_data, i.span);\n+        self.with_parent(def, |this| visit::walk_assoc_item(this, i, ctxt));\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {"}, {"sha": "01a0e568137b2d663482a5abc219823998a01272", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -24,7 +24,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::*;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit::{self, FnKind, Visitor};\n+use syntax::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use syntax::{unwrap_or, walk_list};\n \n use log::debug;\n@@ -437,7 +437,7 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n-            ForeignItemKind::Fn(_, ref generics) => {\n+            ForeignItemKind::Fn(_, ref generics, _) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n@@ -452,13 +452,15 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n     }\n-    fn visit_fn(&mut self, fn_kind: FnKind<'ast>, declaration: &'ast FnDecl, sp: Span, _: NodeId) {\n-        let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n-        debug!(\"(resolving function) entering function\");\n+    fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, _: NodeId) {\n         let rib_kind = match fn_kind {\n-            FnKind::ItemFn(..) => FnItemRibKind,\n-            FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n+            FnKind::Fn(FnCtxt::Foreign, ..) => return visit::walk_fn(self, fn_kind, sp),\n+            FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n+            FnKind::Fn(FnCtxt::Assoc(_), ..) | FnKind::Closure(..) => NormalRibKind,\n         };\n+        let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n+        debug!(\"(resolving function) entering function\");\n+        let declaration = fn_kind.decl();\n \n         // Create a value rib for the function.\n         self.with_rib(ValueNS, rib_kind, |this| {\n@@ -471,8 +473,8 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n \n                 // Resolve the function body, potentially inside the body of an async closure\n                 match fn_kind {\n-                    FnKind::ItemFn(.., body) | FnKind::Method(.., body) => this.visit_block(body),\n-                    FnKind::Closure(body) => this.visit_expr(body),\n+                    FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n+                    FnKind::Closure(_, body) => this.visit_expr(body),\n                 };\n \n                 debug!(\"(resolving function) leaving function\");\n@@ -843,12 +845,16 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                     });\n                                                 }\n                                             }\n-                                            AssocItemKind::Fn(_, _) => {\n-                                                visit::walk_trait_item(this, trait_item)\n-                                            }\n-                                            AssocItemKind::TyAlias(..) => {\n-                                                visit::walk_trait_item(this, trait_item)\n-                                            }\n+                                            AssocItemKind::Fn(_, _) => visit::walk_assoc_item(\n+                                                this,\n+                                                trait_item,\n+                                                AssocCtxt::Trait,\n+                                            ),\n+                                            AssocItemKind::TyAlias(..) => visit::walk_assoc_item(\n+                                                this,\n+                                                trait_item,\n+                                                AssocCtxt::Trait,\n+                                            ),\n                                             AssocItemKind::Macro(_) => {\n                                                 panic!(\"unexpanded macro in resolve!\")\n                                             }\n@@ -1128,7 +1134,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                 );\n \n                                                 this.with_constant_rib(|this| {\n-                                                    visit::walk_impl_item(this, impl_item)\n+                                                    visit::walk_assoc_item(\n+                                                        this,\n+                                                        impl_item,\n+                                                        AssocCtxt::Impl,\n+                                                    )\n                                                 });\n                                             }\n                                             AssocItemKind::Fn(..) => {\n@@ -1139,7 +1149,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                                       impl_item.span,\n                                                     |n, s| MethodNotMemberOfTrait(n, s));\n \n-                                                visit::walk_impl_item(this, impl_item);\n+                                                visit::walk_assoc_item(\n+                                                    this,\n+                                                    impl_item,\n+                                                    AssocCtxt::Impl,\n+                                                )\n                                             }\n                                             AssocItemKind::TyAlias(_, _) => {\n                                                 // If this is a trait impl, ensure the type\n@@ -1149,7 +1163,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                                       impl_item.span,\n                                                     |n, s| TypeNotMemberOfTrait(n, s));\n \n-                                                visit::walk_impl_item(this, impl_item);\n+                                                visit::walk_assoc_item(\n+                                                    this,\n+                                                    impl_item,\n+                                                    AssocCtxt::Impl,\n+                                                )\n                                             }\n                                             AssocItemKind::Macro(_) =>\n                                                 panic!(\"unexpanded macro in resolve!\"),"}, {"sha": "5ce81c104e17c0f05fe1865780d5a4b0446e08e6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -358,7 +358,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         decl: &'l ast::FnDecl,\n         header: &'l ast::FnHeader,\n         ty_params: &'l ast::Generics,\n-        body: &'l ast::Block,\n+        body: Option<&'l ast::Block>,\n     ) {\n         let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n@@ -392,7 +392,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 }\n             }\n \n-            v.visit_block(&body);\n+            walk_list!(v, visit_block, body);\n         });\n     }\n \n@@ -1291,7 +1291,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 }\n             }\n             Fn(ref sig, ref ty_params, ref body) => {\n-                self.process_fn(item, &sig.decl, &sig.header, ty_params, &body)\n+                self.process_fn(item, &sig.decl, &sig.header, ty_params, body.as_deref())\n             }\n             Static(ref typ, _, ref expr) => self.process_static_or_const_item(item, typ, expr),\n             Const(ref typ, ref expr) => self.process_static_or_const_item(item, &typ, &expr),\n@@ -1515,7 +1515,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         match item.kind {\n-            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref sig, ref generics, _) => {\n+                let decl = &sig.decl;\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);\n "}, {"sha": "e32f47443667beb7249b5cc61c7f4b9eb18daa0c", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -133,7 +133,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id))\n         );\n         match item.kind {\n-            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref sig, ref generics, _) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -142,7 +142,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(decl, generics),\n+                    value: make_signature(&sig.decl, generics),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,"}, {"sha": "6401cabdcd5c113f831fc57f95d9637115e49f2b", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -723,7 +723,8 @@ impl Sig for ast::ForeignItem {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n         match self.kind {\n-            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref sig, ref generics, _) => {\n+                let decl = &sig.decl;\n                 let mut text = String::new();\n                 text.push_str(\"fn \");\n "}, {"sha": "b22406124e098b55142cf37d87829a7eb5ae1d0f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -2533,6 +2533,17 @@ pub struct FnHeader {\n     pub ext: Extern,\n }\n \n+impl FnHeader {\n+    /// Does this function header have any qualifiers or is it empty?\n+    pub fn has_qualifiers(&self) -> bool {\n+        let Self { unsafety, asyncness, constness, ext } = self;\n+        matches!(unsafety, Unsafety::Unsafe)\n+            || asyncness.node.is_async()\n+            || matches!(constness.node, Constness::Const)\n+            || !matches!(ext, Extern::None)\n+    }\n+}\n+\n impl Default for FnHeader {\n     fn default() -> FnHeader {\n         FnHeader {\n@@ -2565,7 +2576,7 @@ pub enum ItemKind {\n     /// A function declaration (`fn`).\n     ///\n     /// E.g., `fn foo(bar: usize) -> usize { .. }`.\n-    Fn(FnSig, Generics, P<Block>),\n+    Fn(FnSig, Generics, Option<P<Block>>),\n     /// A module declaration (`mod`).\n     ///\n     /// E.g., `mod foo;` or `mod foo { .. }`.\n@@ -2667,7 +2678,7 @@ pub type ForeignItem = Item<ForeignItemKind>;\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ForeignItemKind {\n     /// A foreign function.\n-    Fn(P<FnDecl>, Generics),\n+    Fn(FnSig, Generics, Option<P<Block>>),\n     /// A foreign static item (`static ext: u8`).\n     Static(P<Ty>, Mutability),\n     /// A foreign type."}, {"sha": "8517f223f92e33d3fbe5cdd5bd8260e5e83600c1", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -901,7 +901,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n         ItemKind::Fn(sig, generics, body) => {\n             visit_fn_sig(sig, vis);\n             vis.visit_generics(generics);\n-            vis.visit_block(body);\n+            visit_opt(body, |body| vis.visit_block(body));\n         }\n         ItemKind::Mod(m) => vis.visit_mod(m),\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n@@ -1044,9 +1044,10 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n     match kind {\n-        ForeignItemKind::Fn(fdec, generics) => {\n-            visitor.visit_fn_decl(fdec);\n+        ForeignItemKind::Fn(sig, generics, body) => {\n+            visit_fn_sig(sig, visitor);\n             visitor.visit_generics(generics);\n+            visit_opt(body, |body| visitor.visit_block(body));\n         }\n         ForeignItemKind::Static(t, _m) => visitor.visit_ty(t),\n         ForeignItemKind::Ty => {}"}, {"sha": "73e731397c329ca7aec8092769d18057d27e4412", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 63, "deletions": 73, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -19,24 +19,47 @@ use crate::tokenstream::{TokenStream, TokenTree};\n \n use rustc_span::Span;\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub enum AssocCtxt {\n+    Trait,\n+    Impl,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum FnCtxt {\n+    Free,\n+    Foreign,\n+    Assoc(AssocCtxt),\n+}\n+\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n-    /// E.g., `fn foo()` or `extern \"Abi\" fn foo()`.\n-    ItemFn(Ident, &'a FnHeader, &'a Visibility, &'a Block),\n-\n-    /// E.g., `fn foo(&self)`.\n-    Method(Ident, &'a FnSig, &'a Visibility, &'a Block),\n+    /// E.g., `fn foo()`, `fn foo(&self)`, or `extern \"Abi\" fn foo()`.\n+    Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),\n \n     /// E.g., `|x, y| body`.\n-    Closure(&'a Expr),\n+    Closure(&'a FnDecl, &'a Expr),\n }\n \n impl<'a> FnKind<'a> {\n     pub fn header(&self) -> Option<&'a FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, header, _, _) => Some(header),\n-            FnKind::Method(_, sig, _, _) => Some(&sig.header),\n-            FnKind::Closure(_) => None,\n+            FnKind::Fn(_, _, sig, _, _) => Some(&sig.header),\n+            FnKind::Closure(_, _) => None,\n+        }\n+    }\n+\n+    pub fn decl(&self) -> &'a FnDecl {\n+        match self {\n+            FnKind::Fn(_, _, sig, _, _) => &sig.decl,\n+            FnKind::Closure(decl, _) => decl,\n+        }\n+    }\n+\n+    pub fn ctxt(&self) -> Option<FnCtxt> {\n+        match self {\n+            FnKind::Fn(ctxt, ..) => Some(*ctxt),\n+            FnKind::Closure(..) => None,\n         }\n     }\n }\n@@ -106,17 +129,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl, s: Span, _: NodeId) {\n-        walk_fn(self, fk, fd, s)\n-    }\n-    fn visit_trait_item(&mut self, i: &'ast AssocItem) {\n-        walk_trait_item(self, i)\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, s: Span, _: NodeId) {\n+        walk_fn(self, fk, s)\n     }\n-    fn visit_impl_item(&mut self, i: &'ast AssocItem) {\n-        walk_impl_item(self, i)\n-    }\n-    fn visit_assoc_item(&mut self, i: &'ast AssocItem) {\n-        walk_assoc_item(self, i)\n+    fn visit_assoc_item(&mut self, i: &'ast AssocItem, ctxt: AssocCtxt) {\n+        walk_assoc_item(self, i, ctxt)\n     }\n     fn visit_trait_ref(&mut self, t: &'ast TraitRef) {\n         walk_trait_ref(self, t)\n@@ -287,13 +304,8 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         }\n         ItemKind::Fn(ref sig, ref generics, ref body) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_fn_header(&sig.header);\n-            visitor.visit_fn(\n-                FnKind::ItemFn(item.ident, &sig.header, &item.vis, body),\n-                &sig.decl,\n-                item.span,\n-                item.id,\n-            )\n+            let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n+            visitor.visit_fn(kind, item.span, item.id)\n         }\n         ItemKind::Mod(ref module) => visitor.visit_mod(module, item.span, &item.attrs, item.id),\n         ItemKind::ForeignMod(ref foreign_module) => {\n@@ -321,17 +333,17 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n-            walk_list!(visitor, visit_impl_item, items);\n+            walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition);\n         }\n-        ItemKind::Trait(.., ref generics, ref bounds, ref methods) => {\n+        ItemKind::Trait(.., ref generics, ref bounds, ref items) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n-            walk_list!(visitor, visit_trait_item, methods);\n+            walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n         }\n         ItemKind::TraitAlias(ref generics, ref bounds) => {\n             visitor.visit_generics(generics);\n@@ -512,21 +524,22 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a ForeignItem) {\n-    visitor.visit_vis(&foreign_item.vis);\n-    visitor.visit_ident(foreign_item.ident);\n+pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n+    visitor.visit_vis(&item.vis);\n+    visitor.visit_ident(item.ident);\n \n-    match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, function_declaration);\n-            visitor.visit_generics(generics)\n+    match item.kind {\n+        ForeignItemKind::Fn(ref sig, ref generics, ref body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(FnCtxt::Foreign, item.ident, sig, &item.vis, body.as_deref());\n+            visitor.visit_fn(kind, item.span, item.id);\n         }\n         ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n         ForeignItemKind::Ty => (),\n         ForeignItemKind::Macro(ref mac) => visitor.visit_mac(mac),\n     }\n \n-    walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n@@ -594,37 +607,21 @@ pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &\n     visitor.visit_fn_ret_ty(&function_declaration.output);\n }\n \n-pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl, _span: Span)\n-where\n-    V: Visitor<'a>,\n-{\n+pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Span) {\n     match kind {\n-        FnKind::ItemFn(_, header, _, body) => {\n-            visitor.visit_fn_header(header);\n-            walk_fn_decl(visitor, declaration);\n-            visitor.visit_block(body);\n-        }\n-        FnKind::Method(_, sig, _, body) => {\n+        FnKind::Fn(_, _, sig, _, body) => {\n             visitor.visit_fn_header(&sig.header);\n-            walk_fn_decl(visitor, declaration);\n-            visitor.visit_block(body);\n+            walk_fn_decl(visitor, &sig.decl);\n+            walk_list!(visitor, visit_block, body);\n         }\n-        FnKind::Closure(body) => {\n-            walk_fn_decl(visitor, declaration);\n+        FnKind::Closure(decl, body) => {\n+            walk_fn_decl(visitor, decl);\n             visitor.visit_expr(body);\n         }\n     }\n }\n \n-pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n-    visitor.visit_assoc_item(item);\n-}\n-\n-pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n-    visitor.visit_assoc_item(item);\n-}\n-\n-pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n+pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n     walk_list!(visitor, visit_attribute, &item.attrs);\n@@ -634,17 +631,9 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem)\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(ref sig, None) => {\n-            visitor.visit_fn_header(&sig.header);\n-            walk_fn_decl(visitor, &sig.decl);\n-        }\n-        AssocItemKind::Fn(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(\n-                FnKind::Method(item.ident, sig, &item.vis, body),\n-                &sig.decl,\n-                item.span,\n-                item.id,\n-            );\n+        AssocItemKind::Fn(ref sig, ref body) => {\n+            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), item.ident, sig, &item.vis, body.as_deref());\n+            visitor.visit_fn(kind, item.span, item.id);\n         }\n         AssocItemKind::TyAlias(ref bounds, ref ty) => {\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -765,8 +754,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprKind::Closure(_, _, _, ref function_declaration, ref body, _decl_span) => visitor\n-            .visit_fn(FnKind::Closure(body), function_declaration, expression.span, expression.id),\n+        ExprKind::Closure(_, _, _, ref decl, ref body, _decl_span) => {\n+            visitor.visit_fn(FnKind::Closure(decl, body), expression.span, expression.id)\n+        }\n         ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);"}, {"sha": "ef234e8afd8ca76fb32a6971f18c28539c681a3e", "filename": "src/test/ui/extern/extern-ffi-fn-with-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,5 +1,5 @@\n extern \"C\" {\n-    fn foo() -> i32 { //~ ERROR incorrect `fn` inside `extern` block\n+    fn foo() -> i32 { //~ ERROR incorrect function inside `extern` block\n         return 0;\n     }\n }"}, {"sha": "079c9cecd8ed450bfbe9cdf6660f48c62be27ce6", "filename": "src/test/ui/extern/extern-ffi-fn-with-body.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-ffi-fn-with-body.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,17 +1,17 @@\n-error: incorrect `fn` inside `extern` block\n+error: incorrect function inside `extern` block\n   --> $DIR/extern-ffi-fn-with-body.rs:2:8\n    |\n LL |   extern \"C\" {\n-   |   ------ `extern` blocks define existing foreign functions and `fn`s inside of them cannot have a body\n+   |   ---------- `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n LL |       fn foo() -> i32 {\n    |  ________^^^__________-\n    | |        |\n-   | |        can't have a body\n+   | |        cannot have a body\n LL | |         return 0;\n LL | |     }\n-   | |_____- this body is invalid here\n+   | |_____- help: remove the invalid body: `;`\n    |\n-   = help: you might have meant to write a function accessible through ffi, which can be done by writing `extern fn` outside of the `extern` block\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n    = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n \n error: aborting due to previous error"}, {"sha": "428856a36b42538077b7e7e7b18857118718c4be", "filename": "src/test/ui/issues/issue-39616.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,5 +1,4 @@\n fn foo(a: [0; 1]) {} //~ ERROR expected type, found `0`\n-//~| ERROR expected one of `)`, `,`, `->`, `where`, or `{`, found `]`\n-// FIXME(jseyfried): avoid emitting the second error (preexisting)\n+//~| ERROR expected `;` or `{`, found `]`\n \n fn main() {}"}, {"sha": "ced582746617baf02f125ee06db6a61f1c69e9f3", "filename": "src/test/ui/issues/issue-39616.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -4,11 +4,11 @@ error: expected type, found `0`\n LL | fn foo(a: [0; 1]) {}\n    |            ^ expected type\n \n-error: expected one of `)`, `,`, `->`, `where`, or `{`, found `]`\n+error: expected `;` or `{`, found `]`\n   --> $DIR/issue-39616.rs:1:16\n    |\n LL | fn foo(a: [0; 1]) {}\n-   |                ^ expected one of `)`, `,`, `->`, `where`, or `{`\n+   |                ^ expected `;` or `{`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "92d1afe1b645a0a800745da5019aba109602db27", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `crate`, `fn`, `pub`, `static`, or `type`, found keyword `let`\n+error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `static`, `type`, or `unsafe`, found keyword `let`\n   --> $DIR/issue-54441.rs:3:9\n    |\n LL |         let\n-   |         ^^^ expected one of `crate`, `fn`, `pub`, `static`, or `type`\n+   |         ^^^ expected one of 9 possible tokens\n ...\n LL |     m!();\n    |     ----- in this macro invocation"}, {"sha": "85b7fc5cdba49cdd9f73046199967772a44020ec", "filename": "src/test/ui/no-patterns-in-args-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args-2.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,9 +1,9 @@\n #![deny(patterns_in_fns_without_body)]\n \n trait Tr {\n-    fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+    fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in functions without bodies\n                         //~^ WARN was previously accepted\n-    fn f2(&arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+    fn f2(&arg: u8); //~ ERROR patterns aren't allowed in functions without bodies\n     fn g1(arg: u8); // OK\n     fn g2(_: u8); // OK\n     #[allow(anonymous_parameters)]"}, {"sha": "21f4439d8900985deff4c04a506b27af796ff58c", "filename": "src/test/ui/no-patterns-in-args-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args-2.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,10 +1,10 @@\n-error[E0642]: patterns aren't allowed in methods without bodies\n+error[E0642]: patterns aren't allowed in functions without bodies\n   --> $DIR/no-patterns-in-args-2.rs:6:11\n    |\n LL |     fn f2(&arg: u8);\n-   |           ^^^^\n+   |           ^^^^ pattern not allowed in function without body\n \n-error: patterns aren't allowed in methods without bodies\n+error: patterns aren't allowed in functions without bodies\n   --> $DIR/no-patterns-in-args-2.rs:4:11\n    |\n LL |     fn f1(mut arg: u8);"}, {"sha": "b5109f9c286962725d4ae9fe8cc6cae82e1eda9f", "filename": "src/test/ui/no-patterns-in-args-macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -6,10 +6,10 @@ macro_rules! m {\n \n         type A = fn($pat: u8);\n \n-        extern {\n+        extern \"C\" {\n             fn foreign_fn($pat: u8);\n         }\n-    }\n+    };\n }\n \n mod good_pat {\n@@ -20,7 +20,7 @@ mod bad_pat {\n     m!((bad, pat));\n     //~^ ERROR patterns aren't allowed in function pointer types\n     //~| ERROR patterns aren't allowed in foreign function declarations\n-    //~| ERROR patterns aren't allowed in methods without bodies\n+    //~| ERROR patterns aren't allowed in functions without bodies\n }\n \n fn main() {}"}, {"sha": "0016c7953f344cca117c9549dadb71719ae58823", "filename": "src/test/ui/no-patterns-in-args-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n-error[E0642]: patterns aren't allowed in methods without bodies\n+error[E0642]: patterns aren't allowed in functions without bodies\n   --> $DIR/no-patterns-in-args-macro.rs:20:8\n    |\n LL |     m!((bad, pat));\n-   |        ^^^^^^^^^^\n+   |        ^^^^^^^^^^ pattern not allowed in function without body\n \n error[E0561]: patterns aren't allowed in function pointer types\n   --> $DIR/no-patterns-in-args-macro.rs:20:8"}, {"sha": "a8f0b7d61b985d988894efd182667e2abc3c3713", "filename": "src/test/ui/parser/duplicate-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expected one of `(`, `fn`, `static`, or `type`\n+// error-pattern: expected one of `(`, `async`, `const`, `extern`, `fn`\n extern {\n     pub pub fn foo();\n }"}, {"sha": "cba4058e4825534287d823eea14140551a57b542", "filename": "src/test/ui/parser/duplicate-visibility.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `fn`, `static`, or `type`, found keyword `pub`\n+error: expected one of `(`, `async`, `const`, `extern`, `fn`, `static`, `type`, or `unsafe`, found keyword `pub`\n   --> $DIR/duplicate-visibility.rs:3:9\n    |\n LL |     pub pub fn foo();\n-   |         ^^^ expected one of `(`, `fn`, `static`, or `type`\n+   |         ^^^ expected one of 8 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "38def05e8f2b32468fc4176b2efd6d3e05599240", "filename": "src/test/ui/parser/fn-body-optional-semantic-fail.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,27 @@\n+// Tests the different rules for `fn` forms requiring the presence or lack of a body.\n+\n+fn main() {\n+    fn f1(); //~ ERROR free function without a body\n+    fn f2() {} // OK.\n+\n+    trait X {\n+        fn f1(); // OK.\n+        fn f2() {} // OK.\n+    }\n+\n+    struct Y;\n+    impl X for Y {\n+        fn f1(); //~ ERROR associated function in `impl` without body\n+        fn f2() {} // OK.\n+    }\n+\n+    impl Y {\n+        fn f3(); //~ ERROR associated function in `impl` without body\n+        fn f4() {} // OK.\n+    }\n+\n+    extern {\n+        fn f5(); // OK.\n+        fn f6() {} //~ ERROR incorrect function inside `extern` block\n+    }\n+}"}, {"sha": "23ce98fb5d787dfdaf99a920252f238cb72c1a95", "filename": "src/test/ui/parser/fn-body-optional-semantic-fail.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-semantic-fail.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,40 @@\n+error: free function without a body\n+  --> $DIR/fn-body-optional-semantic-fail.rs:4:5\n+   |\n+LL |     fn f1();\n+   |     ^^^^^^^-\n+   |            |\n+   |            help: provide a definition for the function: `{ <body> }`\n+\n+error: associated function in `impl` without body\n+  --> $DIR/fn-body-optional-semantic-fail.rs:14:9\n+   |\n+LL |         fn f1();\n+   |         ^^^^^^^-\n+   |                |\n+   |                help: provide a definition for the function: `{ <body> }`\n+\n+error: associated function in `impl` without body\n+  --> $DIR/fn-body-optional-semantic-fail.rs:19:9\n+   |\n+LL |         fn f3();\n+   |         ^^^^^^^-\n+   |                |\n+   |                help: provide a definition for the function: `{ <body> }`\n+\n+error: incorrect function inside `extern` block\n+  --> $DIR/fn-body-optional-semantic-fail.rs:25:12\n+   |\n+LL |     extern {\n+   |     ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+LL |         fn f5(); // OK.\n+LL |         fn f6() {}\n+   |            ^^   -- help: remove the invalid body: `;`\n+   |            |\n+   |            cannot have a body\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e7991c73b4b778a5f1392074c90ed2e936758fea", "filename": "src/test/ui/parser/fn-body-optional-syntactic-pass.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-optional-syntactic-pass.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,31 @@\n+// Ensures that all `fn` forms having or lacking a body are syntactically valid.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    fn f();\n+    fn f() {}\n+\n+    trait X {\n+        fn f();\n+        fn f() {}\n+    }\n+\n+    impl X for Y {\n+        fn f();\n+        fn f() {}\n+    }\n+\n+    impl Y {\n+        fn f();\n+        fn f() {}\n+    }\n+\n+    extern {\n+        fn f();\n+        fn f() {}\n+    }\n+}"}, {"sha": "c2b7e69c80d8ea44378c7c431ed50b3de6487aec", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,57 @@\n+// Ensures that all `fn` forms can have all the function qualifiers syntactically.\n+\n+// edition:2018\n+\n+#![feature(const_extern_fn)]\n+#![feature(const_fn)]\n+\n+fn main() {\n+    async fn ff1() {} // OK.\n+    unsafe fn ff2() {} // OK.\n+    const fn ff3() {} // OK.\n+    extern \"C\" fn ff4() {} // OK.\n+    const /* async */ unsafe extern \"C\" fn ff5() {} // OK.\n+    //^ FIXME(Centril): `async` should be legal syntactically, ensure it's illegal semantically.\n+\n+    trait X {\n+        async fn ft1(); //~ ERROR trait fns cannot be declared `async`\n+        unsafe fn ft2(); // OK.\n+        const fn ft3(); //~ ERROR trait fns cannot be declared const\n+        extern \"C\" fn ft4(); // OK.\n+        /* const */ async unsafe extern \"C\" fn ft5();\n+        //~^ ERROR trait fns cannot be declared `async`\n+        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+    }\n+\n+    struct Y;\n+    impl X for Y {\n+        async fn ft1() {} //~ ERROR trait fns cannot be declared `async`\n+        //~^ ERROR method `ft1` has an incompatible type for trait\n+        unsafe fn ft2() {} // OK.\n+        const fn ft3() {} //~ ERROR trait fns cannot be declared const\n+        extern \"C\" fn ft4() {}\n+        /* const */ async unsafe extern \"C\" fn ft5() {}\n+        //~^ ERROR trait fns cannot be declared `async`\n+        //~| ERROR method `ft5` has an incompatible type for trait\n+        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+    }\n+\n+    impl Y {\n+        async fn fi1() {} // OK.\n+        unsafe fn fi2() {} // OK.\n+        const fn fi3() {} // OK.\n+        extern \"C\" fn fi4() {} // OK.\n+        /* const */ async unsafe extern \"C\" fn fi5() {} // OK.\n+        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+    }\n+\n+    extern {\n+        async fn fe1(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n+        unsafe fn fe2(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n+        const fn fe3(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n+        extern \"C\" fn fe4(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n+        /* const */ async unsafe extern \"C\" fn fe5();\n+        //~^ ERROR functions in `extern` blocks cannot have qualifiers\n+        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+    }\n+}"}, {"sha": "41d2d9b7faaf132017804eacbeec6acbffb13527", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,136 @@\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/fn-header-semantic-fail.rs:17:9\n+   |\n+LL |         async fn ft1();\n+   |         ^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/fn-header-semantic-fail.rs:19:9\n+   |\n+LL |         const fn ft3();\n+   |         ^^^^^ trait fns cannot be const\n+\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/fn-header-semantic-fail.rs:21:21\n+   |\n+LL |         /* const */ async unsafe extern \"C\" fn ft5();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/fn-header-semantic-fail.rs:28:9\n+   |\n+LL |         async fn ft1() {}\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/fn-header-semantic-fail.rs:31:9\n+   |\n+LL |         const fn ft3() {}\n+   |         ^^^^^ trait fns cannot be const\n+\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/fn-header-semantic-fail.rs:33:21\n+   |\n+LL |         /* const */ async unsafe extern \"C\" fn ft5() {}\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/fn-header-semantic-fail.rs:49:18\n+   |\n+LL |     extern {\n+   |     ------ in this `extern` block\n+LL |         async fn fe1();\n+   |         ---------^^^\n+   |         |\n+   |         help: remove the qualifiers: `fn`\n+\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/fn-header-semantic-fail.rs:50:19\n+   |\n+LL |     extern {\n+   |     ------ in this `extern` block\n+LL |         async fn fe1();\n+LL |         unsafe fn fe2();\n+   |         ----------^^^\n+   |         |\n+   |         help: remove the qualifiers: `fn`\n+\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/fn-header-semantic-fail.rs:51:18\n+   |\n+LL |     extern {\n+   |     ------ in this `extern` block\n+...\n+LL |         const fn fe3();\n+   |         ---------^^^\n+   |         |\n+   |         help: remove the qualifiers: `fn`\n+\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/fn-header-semantic-fail.rs:52:23\n+   |\n+LL |     extern {\n+   |     ------ in this `extern` block\n+...\n+LL |         extern \"C\" fn fe4();\n+   |         --------------^^^\n+   |         |\n+   |         help: remove the qualifiers: `fn`\n+\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/fn-header-semantic-fail.rs:53:48\n+   |\n+LL |     extern {\n+   |     ------ in this `extern` block\n+...\n+LL |         /* const */ async unsafe extern \"C\" fn fe5();\n+   |                     ---------------------------^^^\n+   |                     |\n+   |                     help: remove the qualifiers: `fn`\n+\n+error[E0053]: method `ft1` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:28:24\n+   |\n+LL |         async fn ft1();\n+   |                       - type in trait\n+...\n+LL |         async fn ft1() {}\n+   |                        ^\n+   |                        |\n+   |                        the `Output` of this `async fn`'s found opaque type\n+   |                        expected `()`, found opaque type\n+   |\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl std::future::Future`\n+\n+error[E0053]: method `ft5` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:33:54\n+   |\n+LL |         /* const */ async unsafe extern \"C\" fn ft5();\n+   |                                                     - type in trait\n+...\n+LL |         /* const */ async unsafe extern \"C\" fn ft5() {}\n+   |                                                      ^\n+   |                                                      |\n+   |                                                      the `Output` of this `async fn`'s found opaque type\n+   |                                                      expected `()`, found opaque type\n+   |\n+   = note: expected fn pointer `unsafe extern \"C\" fn()`\n+              found fn pointer `unsafe extern \"C\" fn() -> impl std::future::Future`\n+\n+error: aborting due to 13 previous errors\n+\n+Some errors have detailed explanations: E0053, E0379, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "145a208cb249d2f11c9b561a23284df8a2aeb07f", "filename": "src/test/ui/parser/fn-header-syntactic-pass.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,55 @@\n+// Ensures that all `fn` forms can have all the function qualifiers syntactically.\n+\n+// check-pass\n+// edition:2018\n+\n+#![feature(const_extern_fn)]\n+//^ FIXME(Centril): move check to ast_validation.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    async fn f();\n+    unsafe fn f();\n+    const fn f();\n+    extern \"C\" fn f();\n+    const /* async */ unsafe extern \"C\" fn f();\n+    //^ FIXME(Centril): `async` should be legal syntactically.\n+\n+    trait X {\n+        async fn f();\n+        unsafe fn f();\n+        const fn f();\n+        extern \"C\" fn f();\n+        /* const */ async unsafe extern \"C\" fn f();\n+        //^ FIXME(Centril): `const` should be legal syntactically.\n+    }\n+\n+    impl X for Y {\n+        async fn f();\n+        unsafe fn f();\n+        const fn f();\n+        extern \"C\" fn f();\n+        /* const */ async unsafe extern \"C\" fn f();\n+        //^ FIXME(Centril): `const` should be legal syntactically.\n+    }\n+\n+    impl Y {\n+        async fn f();\n+        unsafe fn f();\n+        const fn f();\n+        extern \"C\" fn f();\n+        /* const */ async unsafe extern \"C\" fn f();\n+        //^ FIXME(Centril): `const` should be legal syntactically.\n+    }\n+\n+    extern {\n+        async fn f();\n+        unsafe fn f();\n+        const fn f();\n+        extern \"C\" fn f();\n+        /* const */ async unsafe extern \"C\" fn f();\n+        //^ FIXME(Centril): `const` should be legal syntactically.\n+    }\n+}"}, {"sha": "8b46aa2bf22a173c011606e74b1ee8fcd928cc02", "filename": "src/test/ui/parser/issue-24780.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -3,6 +3,6 @@\n // expected one of ..., `>`, ... found `>`\n \n fn foo() -> Vec<usize>> {\n-    //~^ ERROR expected one of `!`, `+`, `::`, `where`, or `{`, found `>`\n+    //~^ ERROR expected `;` or `{`, found `>`\n     Vec::new()\n }"}, {"sha": "d65a5f448739aa28c9a6be9d90c71550e301a99f", "filename": "src/test/ui/parser/issue-24780.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `!`, `+`, `::`, `where`, or `{`, found `>`\n+error: expected `;` or `{`, found `>`\n   --> $DIR/issue-24780.rs:5:23\n    |\n LL | fn foo() -> Vec<usize>> {\n-   |                       ^ expected one of `!`, `+`, `::`, `where`, or `{`\n+   |                       ^ expected `;` or `{`\n \n error: aborting due to previous error\n "}, {"sha": "7d46b8904f03341956202a6f2392e9076d3e744c", "filename": "src/test/ui/parser/issue-63135.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern: aborting due to 6 previous errors\n+// error-pattern: aborting due to 7 previous errors\n \n fn i(n{...,f #"}, {"sha": "04afae93be0e59f83fe81ce394306c29213c7111", "filename": "src/test/ui/parser/issue-63135.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -43,5 +43,11 @@ error: expected one of `:` or `|`, found `)`\n LL | fn i(n{...,f #\n    |                ^ expected one of `:` or `|`\n \n-error: aborting due to 6 previous errors\n+error: expected `;` or `{`, found `<eof>`\n+  --> $DIR/issue-63135.rs:3:16\n+   |\n+LL | fn i(n{...,f #\n+   |                ^ expected `;` or `{`\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "7c3dd1d5a98c754cc43cae8723f7518bd06c581c", "filename": "src/test/ui/parser/issue-68788-in-trait-item-propagation.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-68788-in-trait-item-propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fissue-68788-in-trait-item-propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68788-in-trait-item-propagation.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -0,0 +1,21 @@\n+// Make sure we don't propagate restrictions on trait impl items to items inside them.\n+\n+// check-pass\n+// edition:2018\n+\n+fn main() {}\n+\n+trait X {\n+    fn foo();\n+}\n+\n+impl X for () {\n+    fn foo() {\n+        struct S;\n+        impl S {\n+            pub const X: u8 = 0;\n+            pub const fn bar() {}\n+            async fn qux() {}\n+        }\n+    }\n+}"}, {"sha": "810dee9571d81e060243a8c47cde30a688a6dd87", "filename": "src/test/ui/parser/missing_right_paren.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,3 +1,3 @@\n // ignore-tidy-trailing-newlines\n-// error-pattern: aborting due to 3 previous errors\n+// error-pattern: aborting due to 4 previous errors\n fn main((\u063c\n\\ No newline at end of file"}, {"sha": "c1ceb81a07c477f738f30da8926fbc0003bb94cd", "filename": "src/test/ui/parser/missing_right_paren.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -22,5 +22,11 @@ error: expected one of `:` or `|`, found `)`\n LL | fn main((\u063c\n    |           ^ expected one of `:` or `|`\n \n-error: aborting due to 3 previous errors\n+error: expected `;` or `{`, found `<eof>`\n+  --> $DIR/missing_right_paren.rs:3:11\n+   |\n+LL | fn main((\u063c\n+   |           ^ expected `;` or `{`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "4cae703a16395cbc066e227a2dd07c8047aaae20", "filename": "src/test/ui/parser/no-const-fn-in-extern-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.rs?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n extern {\n     const fn foo();\n-    //~^ ERROR extern items cannot be `const`\n+    //~^ ERROR functions in `extern` blocks cannot have qualifiers\n     const unsafe fn bar();\n-    //~^ ERROR extern items cannot be `const`\n+    //~^ ERROR functions in `extern` blocks cannot have qualifiers\n }\n \n fn main() {}"}, {"sha": "de653987e406d772f8d01616539236b1183367bd", "filename": "src/test/ui/parser/no-const-fn-in-extern-block.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-const-fn-in-extern-block.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,14 +1,23 @@\n-error: extern items cannot be `const`\n-  --> $DIR/no-const-fn-in-extern-block.rs:2:5\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/no-const-fn-in-extern-block.rs:2:14\n    |\n+LL | extern {\n+   | ------ in this `extern` block\n LL |     const fn foo();\n-   |     ^^^^^\n+   |     ---------^^^\n+   |     |\n+   |     help: remove the qualifiers: `fn`\n \n-error: extern items cannot be `const`\n-  --> $DIR/no-const-fn-in-extern-block.rs:4:5\n+error: functions in `extern` blocks cannot have qualifiers\n+  --> $DIR/no-const-fn-in-extern-block.rs:4:21\n    |\n+LL | extern {\n+   | ------ in this `extern` block\n+...\n LL |     const unsafe fn bar();\n-   |     ^^^^^\n+   |     ----------------^^^\n+   |     |\n+   |     help: remove the qualifiers: `fn`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dce54655fa027de20e967998b4f6624d6e86a169", "filename": "src/test/ui/parser/not-a-pred.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/424304a14f3d4dd8508006ab349b39b983342cf1/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr?ref=424304a14f3d4dd8508006ab349b39b983342cf1", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `->`, `where`, or `{`, found `:`\n+error: expected `;` or `{`, found `:`\n   --> $DIR/not-a-pred.rs:3:26\n    |\n LL | fn f(a: isize, b: isize) : lt(a, b) { }\n-   |                          ^ expected one of `->`, `where`, or `{`\n+   |                          ^ expected `;` or `{`\n \n error: aborting due to previous error\n "}]}