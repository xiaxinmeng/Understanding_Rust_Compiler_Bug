{"sha": "1cfc1874b526fd8a681ebfaf64c554077586c8b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZmMxODc0YjUyNmZkOGE2ODFlYmZhZjY0YzU1NDA3NzU4NmM4YjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-24T16:18:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-24T16:18:32Z"}, "message": "document PartialEq, PartialOrd, Ord requirements more explicitly", "tree": {"sha": "6a24513d46b899abf3073b3f583560fcca22c857", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a24513d46b899abf3073b3f583560fcca22c857"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cfc1874b526fd8a681ebfaf64c554077586c8b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfc1874b526fd8a681ebfaf64c554077586c8b1", "html_url": "https://github.com/rust-lang/rust/commit/1cfc1874b526fd8a681ebfaf64c554077586c8b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cfc1874b526fd8a681ebfaf64c554077586c8b1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf24e6ba00e8a74103fc69a8de25ff955f910ba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf24e6ba00e8a74103fc69a8de25ff955f910ba3", "html_url": "https://github.com/rust-lang/rust/commit/bf24e6ba00e8a74103fc69a8de25ff955f910ba3"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "fc02e3a3a1b5cb814f1f764a1caf85aa78b52640", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1cfc1874b526fd8a681ebfaf64c554077586c8b1/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfc1874b526fd8a681ebfaf64c554077586c8b1/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=1cfc1874b526fd8a681ebfaf64c554077586c8b1", "patch": "@@ -27,12 +27,23 @@ use self::Ordering::*;\n /// Trait for equality comparisons which are [partial equivalence\n /// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n+/// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n+/// We use the easier-to-read infix notation in the remainder of this documentation.\n+///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n ///\n-/// Formally, the equality must be (for all `a`, `b`, `c` of type `A`, `B`,\n-/// `C`):\n+/// Implementations must ensure that `eq` and `ne` are consistent with each other:\n+/// `a != b` if and only if `!(a == b)`.\n+/// This is ensured by the default implementation of `ne`.\n+/// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n+/// be consistent with `PartialEq` (see the documentation of those traits for the exact\n+/// requirememts). It's easy to accidentally make them disagree by deriving some of the traits and\n+/// manually implementing others.\n+///\n+/// The equality relation `==` must satisfy the following conditions\n+/// (for all `a`, `b`, `c` of type `A`, `B`, `C`):\n ///\n /// - **Symmetric**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`\n ///   implies `b == a`**; and\n@@ -53,15 +64,6 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n-/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n-/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n-/// only if `a != b`.\n-///\n-/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n-/// each other. It's easy to accidentally make them disagree by deriving some\n-/// of the traits and manually implementing others.\n-///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -634,7 +636,19 @@ impl<T: Clone> Clone for Reverse<T> {\n /// An order is a total order if it is (for all `a`, `b` and `c`):\n ///\n /// - total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+///\n+/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must* agree with each other (for\n+/// all `a` and `b`):\n+///\n+/// - `a.partial_cmp(b) == Some(a.cmp(b))`\n+/// - `a.cmp(b) == Ordering::Equal` if and only if `a == b`\n+///   (already follows from the above and the requirements of `PartialOrd`)\n+///\n+/// It's easy to accidentally make them disagree by\n+/// deriving some of the traits and manually implementing others.\n+///\n+/// Furthermore, the `max`, `min`, and `clamp` methods of this trait must be consistent with `cmp`.\n ///\n /// ## Derivable\n ///\n@@ -659,12 +673,6 @@ impl<T: Clone> Clone for Reverse<T> {\n /// Then you must define an implementation for [`cmp`]. You may find it useful to use\n /// [`cmp`] on your type's fields.\n ///\n-/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n-/// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n-/// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n-/// all `a` and `b`. It's easy to accidentally make them disagree by\n-/// deriving some of the traits and manually implementing others.\n-///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -824,15 +832,41 @@ impl PartialOrd for Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n+/// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using\n+/// the `<`, `<=`, `>`, and `>=` operators, respectively.\n+///\n+/// The methods of this trait must be consistent with each other and with those of `PartialEq` in\n+/// the following sense:\n+///\n+/// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n+/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`.\n+/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`.\n+/// - `a <= b` if and only if `a < b || a == b`.\n+/// - `a >= b` if and only if `a > b || a == b`.\n+/// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n+///\n+/// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n+/// `partial_cmp` (see the documentation of that trait for the exact requirements). It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// The comparison must satisfy, for all `a`, `b` and `c`:\n ///\n-/// - asymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n /// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - duality: `a < b` if and only if `b > a`.\n ///\n /// Note that these requirements mean that the trait itself must be implemented symmetrically and\n /// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n+/// ## Corollaries\n+///\n+/// The following corollaries follow from the above requirements:\n+///\n+/// - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`\n+/// - transitivity of `>`: if `a > b` and `b > c` then `a > c`\n+/// - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`\n+///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n@@ -850,10 +884,6 @@ impl PartialOrd for Ordering {\n ///\n /// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n-/// easy to accidentally make them disagree by deriving some of the traits and manually\n-/// implementing others.\n-///\n /// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```"}]}