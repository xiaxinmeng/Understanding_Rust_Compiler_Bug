{"sha": "7c092a13bf9779239cc99fe4b473af20b8f95482", "node_id": "C_kwDOAAsO6NoAKDdjMDkyYTEzYmY5Nzc5MjM5Y2M5OWZlNGI0NzNhZjIwYjhmOTU0ODI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T19:47:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T19:47:19Z"}, "message": "Auto merge of #14243 - Veykril:inference-diags, r=Veykril\n\nfeat: Diagnose unresolved field, method call and call expression", "tree": {"sha": "76d910205d8b11fe51a7eaa27926c3d1d7c68edb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d910205d8b11fe51a7eaa27926c3d1d7c68edb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c092a13bf9779239cc99fe4b473af20b8f95482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c092a13bf9779239cc99fe4b473af20b8f95482", "html_url": "https://github.com/rust-lang/rust/commit/7c092a13bf9779239cc99fe4b473af20b8f95482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c092a13bf9779239cc99fe4b473af20b8f95482/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ba876a4a6528a6d1615346776492a41ecf66db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba876a4a6528a6d1615346776492a41ecf66db2", "html_url": "https://github.com/rust-lang/rust/commit/3ba876a4a6528a6d1615346776492a41ecf66db2"}, {"sha": "e7485a04169f79c63333f2b0d39e159d10b92cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7485a04169f79c63333f2b0d39e159d10b92cee", "html_url": "https://github.com/rust-lang/rust/commit/e7485a04169f79c63333f2b0d39e159d10b92cee"}], "stats": {"total": 736, "additions": 628, "deletions": 108}, "files": [{"sha": "22dcea8fcd4518f001adfd8b68270b882d0a499e", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -31,7 +31,7 @@ use hir_def::{\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::name;\n+use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::always;\n@@ -164,12 +164,45 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n-    NoSuchField { expr: ExprId },\n-    PrivateField { expr: ExprId, field: FieldId },\n-    PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n+    NoSuchField {\n+        expr: ExprId,\n+    },\n+    PrivateField {\n+        expr: ExprId,\n+        field: FieldId,\n+    },\n+    PrivateAssocItem {\n+        id: ExprOrPatId,\n+        item: AssocItemId,\n+    },\n+    UnresolvedField {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        method_with_same_name_exists: bool,\n+    },\n+    UnresolvedMethodCall {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        /// Contains the type the field resolves to\n+        field_with_same_name: Option<Ty>,\n+    },\n     // FIXME: Make this proper\n-    BreakOutsideOfLoop { expr: ExprId, is_break: bool, bad_value_break: bool },\n-    MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n+    BreakOutsideOfLoop {\n+        expr: ExprId,\n+        is_break: bool,\n+        bad_value_break: bool,\n+    },\n+    MismatchedArgCount {\n+        call_expr: ExprId,\n+        expected: usize,\n+        found: usize,\n+    },\n+    ExpectedFunction {\n+        call_expr: ExprId,\n+        found: Ty,\n+    },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -505,6 +538,33 @@ impl<'a> InferenceContext<'a> {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n         }\n+        result.diagnostics.retain_mut(|diagnostic| {\n+            if let InferenceDiagnostic::ExpectedFunction { found: ty, .. }\n+            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. }\n+            | InferenceDiagnostic::UnresolvedMethodCall { receiver: ty, .. } = diagnostic\n+            {\n+                *ty = table.resolve_completely(ty.clone());\n+                // FIXME: Remove this when we are on par with rustc in terms of inference\n+                if ty.is_unknown() {\n+                    return false;\n+                }\n+\n+                if let InferenceDiagnostic::UnresolvedMethodCall { field_with_same_name, .. } =\n+                    diagnostic\n+                {\n+                    let clear = if let Some(ty) = field_with_same_name {\n+                        *ty = table.resolve_completely(ty.clone());\n+                        ty.is_unknown()\n+                    } else {\n+                        false\n+                    };\n+                    if clear {\n+                        *field_with_same_name = None;\n+                    }\n+                }\n+            }\n+            true\n+        });\n         for (_, subst) in result.method_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }"}, {"sha": "02024e1ea780e8c0c48f05f9f7bc97aa99b630e1", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 144, "deletions": 71, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -364,7 +364,13 @@ impl<'a> InferenceContext<'a> {\n                         }\n                         (params, ret_ty)\n                     }\n-                    None => (Vec::new(), self.err_ty()), // FIXME diagnostic\n+                    None => {\n+                        self.result.diagnostics.push(InferenceDiagnostic::ExpectedFunction {\n+                            call_expr: tgt_expr,\n+                            found: callee_ty.clone(),\n+                        });\n+                        (Vec::new(), self.err_ty())\n+                    }\n                 };\n                 let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n@@ -546,71 +552,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 ty\n             }\n-            Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-\n-                let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n-                let mut private_field = None;\n-                let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n-                    let (field_id, parameters) = match derefed_ty.kind(Interner) {\n-                        TyKind::Tuple(_, substs) => {\n-                            return name.as_tuple_index().and_then(|idx| {\n-                                substs\n-                                    .as_slice(Interner)\n-                                    .get(idx)\n-                                    .map(|a| a.assert_ty_ref(Interner))\n-                                    .cloned()\n-                            });\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n-                            let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*s).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n-                            let local_id = self.db.union_data(*u).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*u).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        _ => return None,\n-                    };\n-                    let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n-                        .is_visible_from(self.db.upcast(), self.resolver.module());\n-                    if !is_visible {\n-                        if private_field.is_none() {\n-                            private_field = Some(field_id);\n-                        }\n-                        return None;\n-                    }\n-                    // can't have `write_field_resolution` here because `self.table` is borrowed :(\n-                    self.result.field_resolutions.insert(tgt_expr, field_id);\n-                    let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n-                        .clone()\n-                        .substitute(Interner, &parameters);\n-                    Some(ty)\n-                });\n-                let ty = match ty {\n-                    Some(ty) => {\n-                        let adjustments = auto_deref_adjust_steps(&autoderef);\n-                        self.write_expr_adj(*expr, adjustments);\n-                        let ty = self.insert_type_vars(ty);\n-                        let ty = self.normalize_associated_types_in(ty);\n-                        ty\n-                    }\n-                    _ => {\n-                        // Write down the first private field resolution if we found no field\n-                        // This aids IDE features for private fields like goto def\n-                        if let Some(field) = private_field {\n-                            self.result.field_resolutions.insert(tgt_expr, field);\n-                            self.result\n-                                .diagnostics\n-                                .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n-                        }\n-                        self.err_ty()\n-                    }\n-                };\n-                ty\n-            }\n+            Expr::Field { expr, name } => self.infer_field_access(tgt_expr, *expr, name),\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n@@ -1270,6 +1212,118 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    fn lookup_field(\n+        &mut self,\n+        receiver_ty: &Ty,\n+        name: &Name,\n+    ) -> Option<(Ty, Option<FieldId>, Vec<Adjustment>, bool)> {\n+        let mut autoderef = Autoderef::new(&mut self.table, receiver_ty.clone());\n+        let mut private_field = None;\n+        let res = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n+            let (field_id, parameters) = match derefed_ty.kind(Interner) {\n+                TyKind::Tuple(_, substs) => {\n+                    return name.as_tuple_index().and_then(|idx| {\n+                        substs\n+                            .as_slice(Interner)\n+                            .get(idx)\n+                            .map(|a| a.assert_ty_ref(Interner))\n+                            .cloned()\n+                            .map(|ty| (None, ty))\n+                    });\n+                }\n+                TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n+                    let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*s).into(), local_id };\n+                    (field, parameters.clone())\n+                }\n+                TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n+                    let local_id = self.db.union_data(*u).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*u).into(), local_id };\n+                    (field, parameters.clone())\n+                }\n+                _ => return None,\n+            };\n+            let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                .is_visible_from(self.db.upcast(), self.resolver.module());\n+            if !is_visible {\n+                if private_field.is_none() {\n+                    private_field = Some((field_id, parameters));\n+                }\n+                return None;\n+            }\n+            let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                .clone()\n+                .substitute(Interner, &parameters);\n+            Some((Some(field_id), ty))\n+        });\n+\n+        Some(match res {\n+            Some((field_id, ty)) => {\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, field_id, adjustments, true)\n+            }\n+            None => {\n+                let (field_id, subst) = private_field?;\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                    .clone()\n+                    .substitute(Interner, &subst);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, Some(field_id), adjustments, false)\n+            }\n+        })\n+    }\n+\n+    fn infer_field_access(&mut self, tgt_expr: ExprId, receiver: ExprId, name: &Name) -> Ty {\n+        let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none());\n+        match self.lookup_field(&receiver_ty, name) {\n+            Some((ty, field_id, adjustments, is_public)) => {\n+                self.write_expr_adj(receiver, adjustments);\n+                if let Some(field_id) = field_id {\n+                    self.result.field_resolutions.insert(tgt_expr, field_id);\n+                }\n+                if !is_public {\n+                    if let Some(field) = field_id {\n+                        // FIXME: Merge this diagnostic into UnresolvedField?\n+                        self.result\n+                            .diagnostics\n+                            .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                    }\n+                }\n+                ty\n+            }\n+            None => {\n+                // no field found,\n+                let method_with_same_name_exists = {\n+                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n+                    let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n+\n+                    method_resolution::lookup_method(\n+                        self.db,\n+                        &canonicalized_receiver.value,\n+                        self.trait_env.clone(),\n+                        &traits_in_scope,\n+                        VisibleFromModule::Filter(self.resolver.module()),\n+                        name,\n+                    )\n+                    .is_some()\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedField {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty,\n+                    name: name.clone(),\n+                    method_with_same_name_exists,\n+                });\n+                self.err_ty()\n+            }\n+        }\n+    }\n+\n     fn infer_method_call(\n         &mut self,\n         tgt_expr: ExprId,\n@@ -1307,11 +1361,30 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n-            None => (\n-                receiver_ty,\n-                Binders::empty(Interner, self.err_ty()),\n-                Substitution::empty(Interner),\n-            ),\n+            None => {\n+                let field_with_same_name_exists = match self.lookup_field(&receiver_ty, method_name)\n+                {\n+                    Some((ty, field_id, adjustments, _public)) => {\n+                        self.write_expr_adj(receiver, adjustments);\n+                        if let Some(field_id) = field_id {\n+                            self.result.field_resolutions.insert(tgt_expr, field_id);\n+                        }\n+                        Some(ty)\n+                    }\n+                    None => None,\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty.clone(),\n+                    name: method_name.clone(),\n+                    field_with_same_name: field_with_same_name_exists,\n+                });\n+                (\n+                    receiver_ty,\n+                    Binders::empty(Interner, self.err_ty()),\n+                    Substitution::empty(Interner),\n+                )\n+            }\n         };\n         let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);"}, {"sha": "b30c664e24f17ceb7b79676f3c68b74abef2783c", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -31,6 +31,7 @@ macro_rules! diagnostics {\n \n diagnostics![\n     BreakOutsideOfLoop,\n+    ExpectedFunction,\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n@@ -47,8 +48,10 @@ diagnostics![\n     TypeMismatch,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n+    UnresolvedField,\n     UnresolvedImport,\n     UnresolvedMacroCall,\n+    UnresolvedMethodCall,\n     UnresolvedModule,\n     UnresolvedProcMacro,\n ];\n@@ -130,6 +133,28 @@ pub struct PrivateAssocItem {\n     pub item: AssocItem,\n }\n \n+#[derive(Debug)]\n+pub struct ExpectedFunction {\n+    pub call: InFile<AstPtr<ast::Expr>>,\n+    pub found: Type,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedField {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub method_with_same_name_exists: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedMethodCall {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub field_with_same_name: Option<Type>,\n+}\n+\n #[derive(Debug)]\n pub struct PrivateField {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "269c45943e51a0ba96f8b55be4fb02b168a814b1", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 64, "deletions": 26, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -84,12 +84,12 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n-        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1375,46 +1375,35 @@ impl DefWithBody {\n \n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n+        let expr_syntax = |expr| source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n         for d in &infer.diagnostics {\n             match d {\n-                hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(*expr);\n+                &hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n+                    let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n                 &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n                     expr,\n                     is_break,\n                     bad_value_break,\n                 } => {\n-                    let expr = source_map\n-                        .expr_syntax(expr)\n-                        .expect(\"break outside of loop in synthetic syntax\");\n+                    let expr = expr_syntax(expr);\n                     acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(*call_expr) {\n-                        Ok(source_ptr) => acc.push(\n-                            MismatchedArgCount {\n-                                call_expr: source_ptr,\n-                                expected: *expected,\n-                                found: *found,\n-                            }\n+                &hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n+                    acc.push(\n+                        MismatchedArgCount { call_expr: expr_syntax(call_expr), expected, found }\n                             .into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n+                    )\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateField { expr, field } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n+                    let expr = expr_syntax(expr);\n                     let field = field.into();\n                     acc.push(PrivateField { expr, field }.into())\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateAssocItem { id, item } => {\n                     let expr_or_pat = match id {\n-                        ExprOrPatId::ExprId(expr) => source_map\n-                            .expr_syntax(expr)\n-                            .expect(\"unexpected synthetic\")\n-                            .map(Either::Left),\n+                        ExprOrPatId::ExprId(expr) => expr_syntax(expr).map(Either::Left),\n                         ExprOrPatId::PatId(pat) => source_map\n                             .pat_syntax(pat)\n                             .expect(\"unexpected synthetic\")\n@@ -1423,6 +1412,55 @@ impl DefWithBody {\n                     let item = item.into();\n                     acc.push(PrivateAssocItem { expr_or_pat, item }.into())\n                 }\n+                hir_ty::InferenceDiagnostic::ExpectedFunction { call_expr, found } => {\n+                    let call_expr = expr_syntax(*call_expr);\n+\n+                    acc.push(\n+                        ExpectedFunction {\n+                            call: call_expr,\n+                            found: Type::new(db, DefWithBodyId::from(self), found.clone()),\n+                        }\n+                        .into(),\n+                    )\n+                }\n+                hir_ty::InferenceDiagnostic::UnresolvedField {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    method_with_same_name_exists,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedField {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            method_with_same_name_exists: *method_with_same_name_exists,\n+                        }\n+                        .into(),\n+                    )\n+                }\n+                hir_ty::InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    field_with_same_name,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedMethodCall {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            field_with_same_name: field_with_same_name\n+                                .clone()\n+                                .map(|ty| Type::new(db, DefWithBodyId::from(self), ty)),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {"}, {"sha": "0979f6a6dfc7d492e8b5bc619a719d572b9faf8f", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -5,10 +5,7 @@ use ide_db::imports::{\n     insert_use::ImportScope,\n };\n use itertools::Itertools;\n-use syntax::{\n-    ast::{self},\n-    AstNode, SyntaxNode, T,\n-};\n+use syntax::{ast, AstNode, SyntaxNode, T};\n \n use crate::{\n     context::{"}, {"sha": "936354f296134c81fef7282fc82e62f4638580ef", "filename": "crates/ide-db/src/source_change.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -83,6 +83,14 @@ impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n     }\n }\n \n+impl FromIterator<(FileId, TextEdit)> for SourceChange {\n+    fn from_iter<T: IntoIterator<Item = (FileId, TextEdit)>>(iter: T) -> Self {\n+        let mut this = SourceChange::default();\n+        this.extend(iter);\n+        this\n+    }\n+}\n+\n pub struct SourceChangeBuilder {\n     pub edit: TextEditBuilder,\n     pub file_id: FileId,"}, {"sha": "23bc778da290e8f3ce175f5f0c33f1f15e4e2e01", "filename": "crates/ide-diagnostics/src/handlers/expected_function.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -0,0 +1,38 @@\n+use hir::HirDisplay;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: expected-function\n+//\n+// This diagnostic is triggered if a call is made on something that is not callable.\n+pub(crate) fn expected_function(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ExpectedFunction,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"expected-function\",\n+        format!(\"expected function, found {}\", d.found.display(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.call.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let x = 3;\n+    x();\n+ // ^^^ error: expected function, found i32\n+    \"\"();\n+ // ^^^^ error: expected function, found &str\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a0c276cc3328b94bc32c313211f087b2581a836b", "filename": "crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -55,7 +55,18 @@ fn fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::{\n+        tests::{check_diagnostics_with_config, check_fix},\n+        DiagnosticsConfig,\n+    };\n+\n+    #[track_caller]\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let mut config = DiagnosticsConfig::test_sample();\n+        config.disabled.insert(\"inactive-code\".to_string());\n+        config.disabled.insert(\"unresolved-method\".to_string());\n+        check_diagnostics_with_config(config, ra_fixture)\n+    }\n \n     #[test]\n     fn replace_filter_map_next_with_find_map2() {"}, {"sha": "33c39de085d8ebda5180106a607951336c385d04", "filename": "crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -0,0 +1,134 @@\n+use hir::{db::AstDatabase, HirDisplay, InFile};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, AstPtr};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-field\n+//\n+// This diagnostic is triggered if a field does not exist on a given type.\n+pub(crate) fn unresolved_field(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedField,\n+) -> Diagnostic {\n+    let method_suffix = if d.method_with_same_name_exists {\n+        \", but a method with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-field\",\n+        format!(\n+            \"no field `{}` on type `{}`{method_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField) -> Option<Vec<Assist>> {\n+    if d.method_with_same_name_exists {\n+        method_fix(ctx, &d.expr)\n+    } else {\n+        // FIXME: add quickfix\n+\n+        None\n+    }\n+}\n+\n+// FIXME: We should fill out the call here, mvoe the cursor and trigger signature help\n+fn method_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n+) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let FileRange { range, file_id } = ctx.sema.original_range_opt(expr.syntax())?;\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-field-found-method-call-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the method\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_text_edit(\n+            file_id,\n+            TextEdit::insert(range.end(), \"()\".to_owned()),\n+        )),\n+        trigger_signature_help: false,\n+    }])\n+}\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo;\n+ // ^^^^^^ error: no field `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_clash() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self) {}\n+}\n+impl Bar for Foo {}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_2() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self);\n+}\n+impl Bar for Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "0d1f91f02c3b3837a7961c90ecc9ae921b95ecd3", "filename": "crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -0,0 +1,130 @@\n+use hir::{db::AstDatabase, HirDisplay};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, TextRange};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-method\n+//\n+// This diagnostic is triggered if a method does not exist on a given type.\n+pub(crate) fn unresolved_method(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+) -> Diagnostic {\n+    let field_suffix = if d.field_with_same_name.is_some() {\n+        \", but a field with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-method\",\n+        format!(\n+            \"no method `{}` on type `{}`{field_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedMethodCall) -> Option<Vec<Assist>> {\n+    if let Some(ty) = &d.field_with_same_name {\n+        field_fix(ctx, d, ty)\n+    } else {\n+        // FIXME: add quickfix\n+        None\n+    }\n+}\n+\n+fn field_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+    ty: &hir::Type,\n+) -> Option<Vec<Assist>> {\n+    if !ty.impls_fnonce(ctx.sema.db) {\n+        return None;\n+    }\n+    let expr_ptr = &d.expr;\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let (file_id, range) = match expr {\n+        ast::Expr::MethodCallExpr(mcall) => {\n+            let FileRange { range, file_id } =\n+                ctx.sema.original_range_opt(mcall.receiver()?.syntax())?;\n+            let FileRange { range: range2, file_id: file_id2 } =\n+                ctx.sema.original_range_opt(mcall.name_ref()?.syntax())?;\n+            if file_id != file_id2 {\n+                return None;\n+            }\n+            (file_id, TextRange::new(range.start(), range2.end()))\n+        }\n+        _ => return None,\n+    };\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-method-found-field-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the value of the field\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_iter([\n+            (file_id, TextEdit::insert(range.start(), \"(\".to_owned())),\n+            (file_id, TextEdit::insert(range.end(), \")\".to_owned())),\n+        ])),\n+        trigger_signature_help: false,\n+    }])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo();\n+ // ^^^^^^^^ error: no method `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { bar: i32 }\n+fn foo() {\n+    Foo { bar: i32 }.bar();\n+ // ^^^^^^^^^^^^^^^^^^^^^^ error: no method `bar` on type `Foo`, but a field with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn callable_field() {\n+        check_fix(\n+            r#\"\n+//- minicore: fn\n+struct Foo { bar: fn() }\n+fn foo() {\n+    Foo { bar: foo }.b$0ar();\n+}\n+\"#,\n+            r#\"\n+struct Foo { bar: fn() }\n+fn foo() {\n+    (Foo { bar: foo }.bar)();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "c8635ff801102e841b4f41640f03f5390604778b", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c092a13bf9779239cc99fe4b473af20b8f95482/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=7c092a13bf9779239cc99fe4b473af20b8f95482", "patch": "@@ -27,6 +27,7 @@\n \n mod handlers {\n     pub(crate) mod break_outside_of_loop;\n+    pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n@@ -43,6 +44,8 @@ mod handlers {\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n+    pub(crate) mod unresolved_field;\n+    pub(crate) mod unresolved_method;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n@@ -248,6 +251,7 @@ pub fn diagnostics(\n         #[rustfmt::skip]\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n+            AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n@@ -267,6 +271,8 @@ pub fn diagnostics(\n             AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n+            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n \n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,"}]}