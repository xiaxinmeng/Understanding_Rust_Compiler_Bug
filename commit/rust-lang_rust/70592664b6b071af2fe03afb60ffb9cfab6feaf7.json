{"sha": "70592664b6b071af2fe03afb60ffb9cfab6feaf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTkyNjY0YjZiMDcxYWYyZmUwM2FmYjYwZmZiOWNmYWI2ZmVhZjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-06T19:18:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T11:06:27Z"}, "message": "relocate `BorrowData` etc into `borrow_check::borrow_set`", "tree": {"sha": "3422c6022f9751b3cb0c21542c1ba02f7945e857", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3422c6022f9751b3cb0c21542c1ba02f7945e857"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70592664b6b071af2fe03afb60ffb9cfab6feaf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70592664b6b071af2fe03afb60ffb9cfab6feaf7", "html_url": "https://github.com/rust-lang/rust/commit/70592664b6b071af2fe03afb60ffb9cfab6feaf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70592664b6b071af2fe03afb60ffb9cfab6feaf7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c528ce784befb01e569d4743a4c7f6557d83c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c528ce784befb01e569d4743a4c7f6557d83c4d", "html_url": "https://github.com/rust-lang/rust/commit/6c528ce784befb01e569d4743a4c7f6557d83c4d"}], "stats": {"total": 194, "additions": 113, "deletions": 81}, "files": [{"sha": "4d541d0ffd2297f44852832e5a438991894cdf9d", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dataflow::indexes::BorrowIndex;\n+use rustc::mir::{self, Location};\n+use rustc::ty::{Region, RegionKind};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use std::fmt;\n+use syntax_pos::Span;\n+\n+crate struct BorrowSet<'tcx> {\n+    /// The fundamental map relating bitvector indexes to the borrows\n+    /// in the MIR.\n+    crate borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+\n+    /// Each borrow is also uniquely identified in the MIR by the\n+    /// `Location` of the assignment statement in which it appears on\n+    /// the right hand side; we map each such location to the\n+    /// corresponding `BorrowIndex`.\n+    crate location_map: FxHashMap<Location, BorrowIndex>,\n+\n+    /// Locations which activate borrows.\n+    /// NOTE: A given location may activate more than one borrow in the future\n+    /// when more general two-phase borrow support is introduced, but for now we\n+    /// only need to store one borrow index\n+    crate activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n+\n+    /// Every borrow has a region; this maps each such regions back to\n+    /// its borrow-indexes.\n+    crate region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+\n+    /// Map from local to all the borrows on that local\n+    crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+\n+    /// Maps regions to their corresponding source spans\n+    /// Only contains ReScope()s as keys\n+    crate region_span_map: FxHashMap<RegionKind, Span>,\n+}\n+\n+#[derive(Debug)]\n+crate struct BorrowData<'tcx> {\n+    /// Location where the borrow reservation starts.\n+    /// In many cases, this will be equal to the activation location but not always.\n+    crate reserve_location: Location,\n+    /// Location where the borrow is activated. None if this is not a\n+    /// 2-phase borrow.\n+    crate activation_location: Option<Location>,\n+    /// What kind of borrow this is\n+    crate kind: mir::BorrowKind,\n+    /// The region for which this borrow is live\n+    crate region: Region<'tcx>,\n+    /// Place from which we are borrowing\n+    crate borrowed_place: mir::Place<'tcx>,\n+    /// Place to which the borrow was stored\n+    crate assigned_place: mir::Place<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for BorrowData<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        let kind = match self.kind {\n+            mir::BorrowKind::Shared => \"\",\n+            mir::BorrowKind::Unique => \"uniq \",\n+            mir::BorrowKind::Mut { .. } => \"mut \",\n+        };\n+        let region = format!(\"{}\", self.region);\n+        let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n+        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n+    }\n+}\n+"}, {"sha": "8160a3201dac8128f788f1c22b007bebd0e9a39a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -18,7 +18,9 @@ use rustc_data_structures::sync::Lrc;\n \n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{Borrows, BorrowData, FlowAtLocation, MovingOutStatements};\n+use super::borrow_set::BorrowData;\n+\n+use dataflow::{Borrows, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -834,7 +836,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     // Retrieve span of given borrow from the current MIR representation\n-    pub fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+    crate fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n         self.mir.source_info(borrow.reserve_location).span\n     }\n "}, {"sha": "69044a3c83e75336ab372d421aff4c952c746f3e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -37,7 +37,7 @@ use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowResultsConsumer};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n+use dataflow::{Borrows, ReserveOrActivateIndex};\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n@@ -46,10 +46,12 @@ use util::collect_writes::FindAssignments;\n \n use std::iter;\n \n+use self::borrow_set::BorrowData;\n use self::flows::Flows;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod prefixes;"}, {"sha": "b12beb524e20d35919533159ef167d7905a60db6", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -10,7 +10,7 @@\n \n use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n use borrow_check::{Context, MirBorrowckCtxt};\n-use dataflow::BorrowData;\n+use borrow_check::borrow_set::BorrowData;\n use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Mir};\n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "381718234a62fca83c20827db84507dd95e8cbad", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 24, "deletions": 76, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+\n use rustc;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -32,7 +34,6 @@ use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n-use std::fmt;\n use std::hash::Hash;\n use std::rc::Rc;\n \n@@ -49,69 +50,12 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     scope_tree: Lrc<region::ScopeTree>,\n     root_scope: Option<region::Scope>,\n \n-    /// The fundamental map relating bitvector indexes to the borrows\n-    /// in the MIR.\n-    borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-\n-    /// Each borrow is also uniquely identified in the MIR by the\n-    /// `Location` of the assignment statement in which it appears on\n-    /// the right hand side; we map each such location to the\n-    /// corresponding `BorrowIndex`.\n-    location_map: FxHashMap<Location, BorrowIndex>,\n-\n-    /// Locations which activate borrows.\n-    activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n-\n-    /// Every borrow has a region; this maps each such regions back to\n-    /// its borrow-indexes.\n-    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n-\n-    /// Map from local to all the borrows on that local\n-    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-\n-    /// Maps regions to their corresponding source spans\n-    /// Only contains ReScope()s as keys\n-    region_span_map: FxHashMap<RegionKind, Span>,\n+    borrow_set: BorrowSet<'tcx>,\n \n     /// NLL region inference context with which NLL queries should be resolved\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n-// temporarily allow some dead fields: `kind` and `region` will be\n-// needed by borrowck; `borrowed_place` will probably be a MovePathIndex when\n-// that is extended to include borrowed data paths.\n-#[allow(dead_code)]\n-#[derive(Debug)]\n-pub struct BorrowData<'tcx> {\n-    /// Location where the borrow reservation starts.\n-    /// In many cases, this will be equal to the activation location but not always.\n-    pub(crate) reserve_location: Location,\n-    /// Location where the borrow is activated. None if this is not a\n-    /// 2-phase borrow.\n-    pub(crate) activation_location: Option<Location>,\n-    /// What kind of borrow this is\n-    pub(crate) kind: mir::BorrowKind,\n-    /// The region for which this borrow is live\n-    pub(crate) region: Region<'tcx>,\n-    /// Place from which we are borrowing\n-    pub(crate) borrowed_place: mir::Place<'tcx>,\n-    /// Place to which the borrow was stored\n-    pub(crate) assigned_place: mir::Place<'tcx>,\n-}\n-\n-impl<'tcx> fmt::Display for BorrowData<'tcx> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        let kind = match self.kind {\n-            mir::BorrowKind::Shared => \"\",\n-            mir::BorrowKind::Unique => \"uniq \",\n-            mir::BorrowKind::Mut { .. } => \"mut \",\n-        };\n-        let region = format!(\"{}\", self.region);\n-        let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n-    }\n-}\n-\n impl ReserveOrActivateIndex {\n     fn reserved(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new(i.index() * 2) }\n     fn active(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2) + 1) }\n@@ -169,14 +113,16 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n \n         return Borrows { tcx: tcx,\n                          mir: mir,\n-                         borrows: visitor.idx_vec,\n+                         borrow_set: BorrowSet {\n+                             borrows: visitor.idx_vec,\n+                             location_map: visitor.location_map,\n+                             activation_map: visitor.activation_map,\n+                             region_map: visitor.region_map,\n+                             local_map: visitor.local_map,\n+                             region_span_map: visitor.region_span_map,\n+                         },\n                          scope_tree,\n                          root_scope,\n-                         location_map: visitor.location_map,\n-                         activation_map: visitor.activation_map,\n-                         region_map: visitor.region_map,\n-                         local_map: visitor.local_map,\n-                         region_span_map: visitor.region_span_map,\n                          nonlexical_regioncx };\n \n         struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -514,20 +460,20 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         match self.nonlexical_regioncx {\n             Some(_) => None,\n             None => {\n-                match self.region_span_map.get(region) {\n+                match self.borrow_set.region_span_map.get(region) {\n                     Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n                     None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n                 }\n             }\n         }\n     }\n \n-    pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n+    crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n \n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n-        &self.borrows[idx].reserve_location\n+        &self.borrow_set.borrows[idx].reserve_location\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n@@ -548,7 +494,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             // terminator *does* introduce a new loan of the same\n             // region, then setting that gen-bit will override any\n             // potential kill introduced here.\n-            for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n+            for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n                     sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n@@ -562,7 +508,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                              sets: &mut BlockSets<ReserveOrActivateIndex>,\n                              local: &rustc::mir::Local)\n     {\n-        if let Some(borrow_indexes) = self.local_map.get(local) {\n+        if let Some(borrow_indexes) = self.borrow_set.local_map.get(local) {\n             sets.kill_all(borrow_indexes.iter()\n                           .map(|b| ReserveOrActivateIndex::reserved(*b)));\n             sets.kill_all(borrow_indexes.iter()\n@@ -575,7 +521,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n                                        location: Location) {\n         // Handle activations\n-        match self.activation_map.get(&location) {\n+        match self.borrow_set.activation_map.get(&location) {\n             Some(activations) => {\n                 for activated in activations {\n                     debug!(\"activating borrow {:?}\", activated);\n@@ -591,7 +537,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     type Idx = ReserveOrActivateIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n-        self.borrows.len() * 2\n+        self.borrow_set.borrows.len() * 2\n     }\n \n     fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>) {\n@@ -623,7 +569,9 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         match stmt.kind {\n             // EndRegion kills any borrows (reservations and active borrows both)\n             mir::StatementKind::EndRegion(region_scope) => {\n-                if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n+                if let Some(borrow_indexes) =\n+                    self.borrow_set.region_map.get(&ReScope(region_scope))\n+                {\n                     assert!(self.nonlexical_regioncx.is_none());\n                     for idx in borrow_indexes {\n                         sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n@@ -650,7 +598,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n-                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n+                    let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n@@ -661,7 +609,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                         return\n                     }\n \n-                    assert!(self.region_map.get(region).unwrap_or_else(|| {\n+                    assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n                     sets.gen(&ReserveOrActivateIndex::reserved(*index));\n@@ -739,7 +687,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // and hence most of these loans will already be dead -- but, in some cases\n                 // like unwind paths, we do not always emit `EndRegion` statements, so we\n                 // add some kills here as a \"backup\" and to avoid spurious error messages.\n-                for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n+                for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n                     if let ReScope(scope) = borrow_data.region {\n                         // Check that the scope is not actually a scope from a function that is\n                         // a parent of our closure. Note that the CallSite scope itself is"}, {"sha": "72b6f9d54fd66ecd3092e983230ab281ceb48e6d", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n+\n use util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};"}, {"sha": "557799305f9c2aa8ea9c92cc58a106f44f96f3cf", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -29,7 +29,7 @@ pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::borrows::{Borrows, BorrowData};\n+pub use self::impls::borrows::Borrows;\n pub use self::impls::HaveBeenBorrowedLocals;\n pub(crate) use self::impls::borrows::{ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};"}, {"sha": "de3063a575673bc8b6f88e5f7fe5d78b5624f014", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70592664b6b071af2fe03afb60ffb9cfab6feaf7/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=70592664b6b071af2fe03afb60ffb9cfab6feaf7", "patch": "@@ -20,6 +20,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(catch_expr)]\n+#![feature(crate_visibility_modifier)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]"}]}