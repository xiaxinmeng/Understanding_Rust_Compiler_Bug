{"sha": "9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjYyMjcxMTcwY2QxNWE4Y2JmYThkMWQ2MTkyZDEzMDJlOWNjZTI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-29T18:21:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T18:21:17Z"}, "message": "Rollup merge of #72465 - tmiasko:liveness-upvars, r=nikomatsakis\n\nWarn about unused captured variables\n\nInclude captured variables in liveness analysis. Warn when captured variables\nare unused (but possibly read or written to). Warn about dead assignments to\ncaptured variables.\n\nFixes #37707.\nFixes #47128.\nFixes #63220.", "tree": {"sha": "43e1de19c5e80dad5c015005504f12d963c01183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43e1de19c5e80dad5c015005504f12d963c01183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0VKdCRBK7hj4Ov3rIwAAdHIIAJ8MxL69nMvNN/NgKlUHOzKS\nc4T/HfVxV1DF3RmVOsC3RrldQOgQT4EED/nPjK9NI0wP3VW3LnHG+t+juDAJz4iT\nREsHZrvF0fGcA4JPLn1SYV+oICPC6bOjFGGO+3ogpeP7mzT5xLY67uO30J/xrhoh\nP4ydmBU0hfTwQZsfKzMtsML2lhh5z0ndL/Qkht+j0TnPO83uMosDg70BUnZTDptH\nhYxbyCCO6qbm4QZ1XSEft8Cvc+6eNoPu4z6Hf7g2MMIXeAONo8r6aWcsx9YMARAX\nSd3IoNcuQpTajI0amX3hcA1xnbf3cSjB+IcPvHnDWNLExnC1P8yD9QSfTtEmUDk=\n=QiVr\n-----END PGP SIGNATURE-----\n", "payload": "tree 43e1de19c5e80dad5c015005504f12d963c01183\nparent 8bce2404a86fa7f11284a81bc1e7c28e06e6b90e\nparent 4dc56614b27337fe770943760f41a58bbab7c7c6\nauthor Dylan DPC <dylan.dpc@gmail.com> 1590776477 +0200\ncommitter GitHub <noreply@github.com> 1590776477 +0200\n\nRollup merge of #72465 - tmiasko:liveness-upvars, r=nikomatsakis\n\nWarn about unused captured variables\n\nInclude captured variables in liveness analysis. Warn when captured variables\nare unused (but possibly read or written to). Warn about dead assignments to\ncaptured variables.\n\nFixes #37707.\nFixes #47128.\nFixes #63220.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "html_url": "https://github.com/rust-lang/rust/commit/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bce2404a86fa7f11284a81bc1e7c28e06e6b90e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bce2404a86fa7f11284a81bc1e7c28e06e6b90e", "html_url": "https://github.com/rust-lang/rust/commit/8bce2404a86fa7f11284a81bc1e7c28e06e6b90e"}, {"sha": "4dc56614b27337fe770943760f41a58bbab7c7c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc56614b27337fe770943760f41a58bbab7c7c6", "html_url": "https://github.com/rust-lang/rust/commit/4dc56614b27337fe770943760f41a58bbab7c7c6"}], "stats": {"total": 666, "additions": 543, "deletions": 123}, "files": [{"sha": "55978afc59437c74dbfe750d0d1b5530ac82b924", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 208, "deletions": 113, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -76,22 +76,10 @@\n //!   is not just used to generate a new value. For example, `x += 1` is\n //!   a read but not a use. This is used to generate better warnings.\n //!\n-//! ## Special Variables\n+//! ## Special nodes and variables\n //!\n-//! We generate various special variables for various, well, special purposes.\n-//! These are described in the `specials` struct:\n-//!\n-//! - `exit_ln`: a live node that is generated to represent every 'exit' from\n-//!   the function, whether it be by explicit return, panic, or other means.\n-//!\n-//! - `fallthrough_ln`: a live node that represents a fallthrough\n-//!\n-//! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n-//!   fallthrough node. It is only live if the function could converge\n-//!   via means other than an explicit `return` expression. That is, it is\n-//!   only dead if the end of the function's block can never be reached.\n-//!   It is the responsibility of typeck to ensure that there are no\n-//!   `return` expressions in a function declared as diverging.\n+//! We generate various special nodes for various, well, special purposes.\n+//! These are described in the `Specials` struct.\n \n use self::LiveNodeKind::*;\n use self::VarKind::*;\n@@ -140,6 +128,7 @@ enum LiveNodeKind {\n     UpvarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n+    ClosureNode,\n     ExitNode,\n }\n \n@@ -149,6 +138,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n         UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_string(s)),\n         ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_string(s)),\n         VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_string(s)),\n+        ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n }\n@@ -253,7 +243,7 @@ struct LocalInfo {\n enum VarKind {\n     Param(HirId, Symbol),\n     Local(LocalInfo),\n-    CleanExit,\n+    Upvar(HirId, Symbol),\n }\n \n struct IrMaps<'tcx> {\n@@ -306,10 +296,9 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) | Upvar(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             }\n-            CleanExit => {}\n         }\n \n         debug!(\"{:?} is {:?}\", v, vk);\n@@ -328,15 +317,14 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Param(_, name) => name.to_string(),\n-            CleanExit => \"<clean-exit>\".to_owned(),\n+            Local(LocalInfo { name, .. }) | Param(_, name) | Upvar(_, name) => name.to_string(),\n         }\n     }\n \n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Param(..) | CleanExit => false,\n+            Param(..) | Upvar(..) => false,\n         }\n     }\n \n@@ -357,7 +345,7 @@ fn visit_fn<'tcx>(\n     sp: Span,\n     id: hir::HirId,\n ) {\n-    debug!(\"visit_fn\");\n+    debug!(\"visit_fn {:?}\", id);\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n@@ -377,6 +365,14 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n+    if let Some(upvars) = ir.tcx.upvars_mentioned(def_id) {\n+        for (&var_hir_id, _upvar) in upvars {\n+            debug!(\"adding upvar {:?}\", var_hir_id);\n+            let var_name = ir.tcx.hir().name(var_hir_id);\n+            fn_maps.add_variable(Upvar(var_hir_id, var_name));\n+        }\n+    }\n+\n     for param in body.params {\n         let is_shorthand = match param.pat.kind {\n             rustc_hir::PatKind::Struct(..) => true,\n@@ -399,10 +395,12 @@ fn visit_fn<'tcx>(\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, def_id);\n-    let entry_ln = lsets.compute(&body.value);\n+    let entry_ln = lsets.compute(fk, &body, sp, id);\n+    lsets.log_liveness(entry_ln, id);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n+    lsets.warn_about_unused_upvars(entry_ln);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -462,11 +460,8 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         // live nodes required for uses or definitions of variables:\n         hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n             debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n-            if let Res::Local(var_hir_id) = path.res {\n-                let upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n-                if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n-                    ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-                }\n+            if let Res::Local(_var_hir_id) = path.res {\n+                ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n             }\n             intravisit::walk_expr(ir, expr);\n         }\n@@ -482,16 +477,9 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             let mut call_caps = Vec::new();\n             let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = ir.tcx.upvars_mentioned(closure_def_id) {\n-                let parent_upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n-                call_caps.extend(upvars.iter().filter_map(|(&var_id, upvar)| {\n-                    let has_parent =\n-                        parent_upvars.map_or(false, |upvars| upvars.contains_key(&var_id));\n-                    if !has_parent {\n-                        let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n-                        Some(CaptureInfo { ln: upvar_ln, var_hid: var_id })\n-                    } else {\n-                        None\n-                    }\n+                call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n+                    CaptureInfo { ln: upvar_ln, var_hid: var_id }\n                 }));\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n@@ -647,9 +635,13 @@ impl RWUTable {\n \n #[derive(Copy, Clone)]\n struct Specials {\n+    /// A live node representing a point of execution before closure entry &\n+    /// after closure exit. Used to calculate liveness of captured variables\n+    /// through calls to the same closure. Used for Fn & FnMut closures only.\n+    closure_ln: LiveNode,\n+    /// A live node representing every 'exit' from the function, whether it be\n+    /// by explicit return, panic, or other means.\n     exit_ln: LiveNode,\n-    fallthrough_ln: LiveNode,\n-    clean_exit_var: Variable,\n }\n \n const ACC_READ: u32 = 1;\n@@ -673,14 +665,9 @@ struct Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        // Special nodes and variables:\n-        // - exit_ln represents the end of the fn, either by return or panic\n-        // - implicit_ret_var is a pseudo-variable that represents\n-        //   an implicit return\n         let specials = Specials {\n+            closure_ln: ir.add_live_node(ClosureNode),\n             exit_ln: ir.add_live_node(ExitNode),\n-            fallthrough_ln: ir.add_live_node(ExitNode),\n-            clean_exit_var: ir.add_variable(CleanExit),\n         };\n \n         let tables = ir.tcx.typeck_tables_of(def_id);\n@@ -777,12 +764,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn write_vars<F>(&self, wr: &mut dyn Write, ln: LiveNode, mut test: F) -> io::Result<()>\n     where\n-        F: FnMut(usize) -> LiveNode,\n+        F: FnMut(usize) -> bool,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in 0..self.ir.num_vars {\n             let idx = node_base_idx + var_idx;\n-            if test(idx).is_valid() {\n+            if test(idx) {\n                 write!(wr, \" {:?}\", Variable(var_idx as u32))?;\n             }\n         }\n@@ -795,14 +782,31 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx));\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx));\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n+            write!(wr, \"  uses\");\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n+\n             write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n \n+    fn log_liveness(&self, entry_ln: LiveNode, hir_id: hir::HirId) {\n+        // hack to skip the loop unless debug! is enabled:\n+        debug!(\n+            \"^^ liveness computation results for body {} (entry={:?})\",\n+            {\n+                for ln_idx in 0..self.ir.num_live_nodes {\n+                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                }\n+                hir_id\n+            },\n+            entry_ln\n+        );\n+    }\n+\n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[ln.get()] = succ_ln;\n \n@@ -903,30 +907,87 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n-        debug!(\"compute: using id for body, {:?}\", body);\n+    fn compute(\n+        &mut self,\n+        fk: FnKind<'_>,\n+        body: &hir::Body<'_>,\n+        span: Span,\n+        id: hir::HirId,\n+    ) -> LiveNode {\n+        debug!(\"compute: using id for body, {:?}\", body.value);\n+\n+        // # Liveness of captured variables\n+        //\n+        // When computing the liveness for captured variables we take into\n+        // account how variable is captured (ByRef vs ByValue) and what is the\n+        // closure kind (Generator / FnOnce vs Fn / FnMut).\n+        //\n+        // Variables captured by reference are assumed to be used on the exit\n+        // from the closure.\n+        //\n+        // In FnOnce closures, variables captured by value are known to be dead\n+        // on exit since it is impossible to call the closure again.\n+        //\n+        // In Fn / FnMut closures, variables captured by value are live on exit\n+        // if they are live on the entry to the closure, since only the closure\n+        // itself can access them on subsequent calls.\n+\n+        if let Some(upvars) = self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            // Mark upvars captured by reference as used after closure exits.\n+            for (&var_hir_id, upvar) in upvars.iter().rev() {\n+                let upvar_id = ty::UpvarId {\n+                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                    closure_expr_id: self.ir.body_owner.expect_local(),\n+                };\n+                match self.tables.upvar_capture(upvar_id) {\n+                    ty::UpvarCapture::ByRef(_) => {\n+                        let var = self.variable(var_hir_id, upvar.span);\n+                        self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n+                    }\n+                    ty::UpvarCapture::ByValue => {}\n+                }\n+            }\n+        }\n \n-        // the fallthrough exit is only for those cases where we do not\n-        // explicitly return:\n-        let s = self.s;\n-        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+        let succ = self.propagate_through_expr(&body.value, self.s.exit_ln);\n \n-        let entry_ln = self.propagate_through_expr(body, s.fallthrough_ln);\n+        match fk {\n+            FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n+            FnKind::Closure(..) => {}\n+        }\n \n-        // hack to skip the loop unless debug! is enabled:\n-        debug!(\n-            \"^^ liveness computation results for body {} (entry={:?})\",\n-            {\n-                for ln_idx in 0..self.ir.num_live_nodes {\n-                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n-                }\n-                body.hir_id\n+        let ty = self.tables.node_type(id);\n+        match ty.kind {\n+            ty::Closure(_def_id, substs) => match substs.as_closure().kind() {\n+                ty::ClosureKind::Fn => {}\n+                ty::ClosureKind::FnMut => {}\n+                ty::ClosureKind::FnOnce => return succ,\n             },\n-            entry_ln\n-        );\n+            ty::Generator(..) => return succ,\n+            _ => {\n+                span_bug!(span, \"type of closure expr {:?} is not a closure {:?}\", id, ty,);\n+            }\n+        };\n+\n+        // Propagate through calls to the closure.\n+        let mut first_merge = true;\n+        loop {\n+            self.init_from_succ(self.s.closure_ln, succ);\n+            for param in body.params {\n+                param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+                    let var = self.variable(hir_id, ident.span);\n+                    self.define(self.s.closure_ln, var);\n+                })\n+            }\n+\n+            if !self.merge_from_succ(self.s.exit_ln, self.s.closure_ln, first_merge) {\n+                break;\n+            }\n+            first_merge = false;\n+            assert_eq!(succ, self.propagate_through_expr(&body.value, self.s.exit_ln));\n+        }\n \n-        entry_ln\n+        succ\n     }\n \n     fn propagate_through_block(&mut self, blk: &hir::Block<'_>, succ: LiveNode) -> LiveNode {\n@@ -1363,14 +1424,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         acc: u32,\n     ) -> LiveNode {\n         match path.res {\n-            Res::Local(hid) => {\n-                let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n-                if !upvars.map_or(false, |upvars| upvars.contains_key(&hid)) {\n-                    self.access_var(hir_id, hid, succ, acc, path.span)\n-                } else {\n-                    succ\n-                }\n-            }\n+            Res::Local(hid) => self.access_var(hir_id, hid, succ, acc, path.span),\n             _ => succ,\n         }\n     }\n@@ -1529,16 +1583,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n-                    let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n-                    if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hid)) {\n-                        // Assignment to an immutable variable or argument: only legal\n-                        // if there is no later assignment. If this local is actually\n-                        // mutable, then check for a reassignment to flag the mutability\n-                        // as being used.\n-                        let ln = self.live_node(expr.hir_id, expr.span);\n-                        let var = self.variable(var_hid, expr.span);\n-                        self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n-                    }\n+                    // Assignment to an immutable variable or argument: only legal\n+                    // if there is no later assignment. If this local is actually\n+                    // mutable, then check for a reassignment to flag the mutability\n+                    // as being used.\n+                    let ln = self.live_node(expr.hir_id, expr.span);\n+                    let var = self.variable(var_hid, expr.span);\n+                    self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n                 }\n             }\n             _ => {\n@@ -1554,11 +1605,60 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         if name.is_empty() || name.as_bytes()[0] == b'_' { None } else { Some(name) }\n     }\n \n+    fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n+        let upvars = match self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            None => return,\n+            Some(upvars) => upvars,\n+        };\n+        for (&var_hir_id, upvar) in upvars.iter() {\n+            let var = self.variable(var_hir_id, upvar.span);\n+            let upvar_id = ty::UpvarId {\n+                var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                closure_expr_id: self.ir.body_owner.expect_local(),\n+            };\n+            match self.tables.upvar_capture(upvar_id) {\n+                ty::UpvarCapture::ByValue => {}\n+                ty::UpvarCapture::ByRef(..) => continue,\n+            };\n+            if self.used_on_entry(entry_ln, var) {\n+                if self.live_on_entry(entry_ln, var).is_none() {\n+                    if let Some(name) = self.should_warn(var) {\n+                        self.ir.tcx.struct_span_lint_hir(\n+                            lint::builtin::UNUSED_ASSIGNMENTS,\n+                            var_hir_id,\n+                            vec![upvar.span],\n+                            |lint| {\n+                                lint.build(&format!(\"value captured by `{}` is never read\", name))\n+                                    .help(\"did you mean to capture by reference instead?\")\n+                                    .emit();\n+                            },\n+                        );\n+                    }\n+                }\n+            } else {\n+                if let Some(name) = self.should_warn(var) {\n+                    self.ir.tcx.struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        var_hir_id,\n+                        vec![upvar.span],\n+                        |lint| {\n+                            lint.build(&format!(\"unused variable: `{}`\", name))\n+                                .help(\"did you mean to capture by reference instead?\")\n+                                .emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n         for p in body.params {\n             self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n                 if self.live_on_entry(ln, var).is_none() {\n-                    self.report_dead_assign(hir_id, spans, var, true);\n+                    self.report_unsed_assign(hir_id, spans, var, |name| {\n+                        format!(\"value passed to `{}` is never read\", name)\n+                    });\n                 }\n             });\n         }\n@@ -1672,35 +1772,30 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, spans, var, false);\n+            self.report_unsed_assign(hir_id, spans, var, |name| {\n+                format!(\"value assigned to `{}` is never read\", name)\n+            });\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n+    fn report_unsed_assign(\n+        &self,\n+        hir_id: HirId,\n+        spans: Vec<Span>,\n+        var: Variable,\n+        message: impl Fn(&str) -> String,\n+    ) {\n         if let Some(name) = self.should_warn(var) {\n-            if is_param {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value passed to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            } else {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value assigned to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            }\n+            self.ir.tcx.struct_span_lint_hir(\n+                lint::builtin::UNUSED_ASSIGNMENTS,\n+                hir_id,\n+                spans,\n+                |lint| {\n+                    lint.build(&message(&name))\n+                        .help(\"maybe it is overwritten before being read?\")\n+                        .emit();\n+                },\n+            )\n         }\n     }\n }"}, {"sha": "1b0feede34ecfc0a8714e340d58af8985b66f464", "filename": "src/test/ui/closures/closure-immutable-outer-variable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let mut y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "50ec1c6148a046cfe39fc815ee16b9fce849df04", "filename": "src/test/ui/closures/closure-immutable-outer-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "799097889cd30f40e16d8c3cbcd15b7059b94595", "filename": "src/test/ui/closures/closure-immutable-outer-variable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -3,8 +3,8 @@ error[E0594]: cannot assign to `y`, as it is not declared as mutable\n    |\n LL |     let y = true;\n    |         - help: consider changing this to be mutable: `mut y`\n-LL |     foo(Box::new(move || y = false) as Box<_>);\n-   |                          ^^^^^^^^^ cannot assign\n+LL |     foo(Box::new(move || y = !y) as Box<_>);\n+   |                          ^^^^^^ cannot assign\n \n error: aborting due to previous error\n "}, {"sha": "a7af01e25b4e2899512d0d8cc0a00c91bf8c13d1", "filename": "src/test/ui/issues/issue-11958.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -1,10 +1,11 @@\n // run-pass\n-#![forbid(warnings)]\n \n // We shouldn't need to rebind a moved upvar as mut if it's already\n // marked as mut\n \n pub fn main() {\n     let mut x = 1;\n     let _thunk = Box::new(move|| { x = 2; });\n+    //~^ WARN value assigned to `x` is never read\n+    //~| WARN unused variable: `x`\n }"}, {"sha": "25de6ff4c118c033083e9d4cc20b92212726bea8", "filename": "src/test/ui/issues/issue-11958.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -0,0 +1,20 @@\n+warning: value assigned to `x` is never read\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "b2837e74b8c5161668e07a2e27e7b6eae5c69581", "filename": "src/test/ui/liveness/liveness-upvars.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -0,0 +1,108 @@\n+// edition:2018\n+// check-pass\n+#![warn(unused)]\n+#![allow(unreachable_code)]\n+\n+pub fn unintentional_copy_one() {\n+    let mut last = None;\n+    let mut f = move |s| {\n+        last = Some(s); //~  WARN value assigned to `last` is never read\n+                        //~| WARN unused variable: `last`\n+    };\n+    f(\"a\");\n+    f(\"b\");\n+    f(\"c\");\n+    dbg!(last.unwrap());\n+}\n+\n+pub fn unintentional_copy_two() {\n+    let mut sum = 0;\n+    (1..10).for_each(move |x| {\n+        sum += x; //~ WARN unused variable: `sum`\n+    });\n+    dbg!(sum);\n+}\n+\n+pub fn f() {\n+    let mut c = 0;\n+\n+    // Captured by value, but variable is dead on entry.\n+    move || {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+    let _ = async move {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+\n+    // Read and written to, but never actually used.\n+    move || {\n+        c += 1; //~ WARN unused variable: `c`\n+    };\n+    let _ = async move {\n+        c += 1; //~  WARN value assigned to `c` is never read\n+                //~| WARN unused variable: `c`\n+    };\n+\n+    move || {\n+        println!(\"{}\", c);\n+        // Value is read by closure itself on later invocations.\n+        c += 1;\n+    };\n+    let b = Box::new(42);\n+    move || {\n+        println!(\"{}\", c);\n+        // Never read because this is FnOnce closure.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+        drop(b);\n+    };\n+    let _ = async move {\n+        println!(\"{}\", c);\n+        // Never read because this is a generator.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+    };\n+}\n+\n+pub fn nested() {\n+    let mut d = None;\n+    let mut e = None;\n+    || {\n+        || {\n+            d = Some(\"d1\"); //~ WARN value assigned to `d` is never read\n+            d = Some(\"d2\");\n+        };\n+        move || {\n+            e = Some(\"e1\"); //~  WARN value assigned to `e` is never read\n+                            //~| WARN unused variable: `e`\n+            e = Some(\"e2\"); //~  WARN value assigned to `e` is never read\n+        };\n+    };\n+}\n+\n+pub fn g<T: Default>(mut v: T) {\n+    |r| {\n+        if r {\n+            v = T::default(); //~ WARN value assigned to `v` is never read\n+        } else {\n+            drop(v);\n+        }\n+    };\n+}\n+\n+pub fn h<T: Copy + Default + std::fmt::Debug>() {\n+    let mut z = T::default();\n+    move |b| {\n+        loop {\n+            if b {\n+                z = T::default(); //~  WARN value assigned to `z` is never read\n+                                  //~| WARN unused variable: `z`\n+            } else {\n+                return;\n+            }\n+        }\n+        dbg!(z);\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "14fed917864361d0810912e8704066fca84fbcbc", "filename": "src/test/ui/liveness/liveness-upvars.stderr", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -0,0 +1,150 @@\n+warning: value assigned to `last` is never read\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `last`\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `sum`\n+  --> $DIR/liveness-upvars.rs:21:9\n+   |\n+LL |         sum += x;\n+   |         ^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:31:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:35:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:41:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:57:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:63:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `d` is never read\n+  --> $DIR/liveness-upvars.rs:72:13\n+   |\n+LL |             d = Some(\"d1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:78:13\n+   |\n+LL |             e = Some(\"e2\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `e`\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `v` is never read\n+  --> $DIR/liveness-upvars.rs:86:13\n+   |\n+LL |             v = T::default();\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `z` is never read\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `z`\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 17 warnings emitted\n+"}, {"sha": "390386e57fa72db7dca488f0ff1c1c9511ee7c13", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![allow(unused_variables)]\n // Test that we mutate a counter on the stack only when we expect to.\n \n fn call<F>(f: F) where F : FnOnce() {\n@@ -13,7 +12,7 @@ fn main() {\n     call(|| {\n         // Move `y`, but do not move `counter`, even though it is read\n         // by value (note that it is also mutated).\n-        for item in y {\n+        for item in y { //~ WARN unused variable: `item`\n             let v = counter;\n             counter += v;\n         }\n@@ -22,7 +21,8 @@ fn main() {\n \n     call(move || {\n         // this mutates a moved copy, and hence doesn't affect original\n-        counter += 1;\n+        counter += 1; //~  WARN value assigned to `counter` is never read\n+                      //~| WARN unused variable: `counter`\n     });\n     assert_eq!(counter, 88);\n }"}, {"sha": "ba4b3dac6705e0bc41204e16de8bceb09ca10fb5", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -0,0 +1,27 @@\n+warning: unused variable: `item`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:15:13\n+   |\n+LL |         for item in y {\n+   |             ^^^^ help: if this is intentional, prefix it with an underscore: `_item`\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+\n+warning: value assigned to `counter` is never read\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `counter`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "e5b19db78223123f78c73d9cab8feda4aeac7a5e", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -13,11 +13,11 @@ fn set(x: &mut usize) { *x = 42; }\n fn main() {\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;"}, {"sha": "4dfd1bb307574e7d0c94350bbd111d1bb49899a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ef62271170cd15a8cbfa8d1d6192d1302e9cce2/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr?ref=9ef62271170cd15a8cbfa8d1d6192d1302e9cce2", "patch": "@@ -0,0 +1,19 @@\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:16:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:20:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}]}