{"sha": "574830f5730f2cfc3abdb486428d33d541c0abee", "node_id": "C_kwDOAAsO6NoAKDU3NDgzMGY1NzMwZjJjZmMzYWJkYjQ4NjQyOGQzM2Q1NDFjMGFiZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T06:30:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T06:30:29Z"}, "message": "Auto merge of #96094 - Elliot-Roberts:fix_doctests, r=compiler-errors\n\nBegin fixing all the broken doctests in `compiler/`\n\nBegins to fix #95994.\nAll of them pass now but 24 of them I've marked with `ignore HELP (<explanation>)` (asking for help) as I'm unsure how to get them to work / if we should leave them as they are.\nThere are also a few that I marked `ignore` that could maybe be made to work but seem less important.\nEach `ignore` has a rough \"reason\" for ignoring after it parentheses, with\n\n- `(pseudo-rust)` meaning \"mostly rust-like but contains foreign syntax\"\n- `(illustrative)` a somewhat catchall for either a fragment of rust that doesn't stand on its own (like a lone type), or abbreviated rust with ellipses and undeclared types that would get too cluttered if made compile-worthy.\n- `(not-rust)` stuff that isn't rust but benefits from the syntax highlighting, like MIR.\n- `(internal)` uses `rustc_*` code which would be difficult to make work with the testing setup.\n\nThose reason notes are a bit inconsistently applied and messy though. If that's important I can go through them again and try a more principled approach. When I run `rg '```ignore \\(' .` on the repo, there look to be lots of different conventions other people have used for this sort of thing. I could try unifying them all if that would be helpful.\n\nI'm not sure if there was a better existing way to do this but I wrote my own script to help me run all the doctests and wade through the output. If that would be useful to anyone else, I put it here: https://github.com/Elliot-Roberts/rust_doctest_fixing_tool", "tree": {"sha": "5ae5951d8ef6ed2b12910f8035fc457d5193308c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ae5951d8ef6ed2b12910f8035fc457d5193308c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/574830f5730f2cfc3abdb486428d33d541c0abee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/574830f5730f2cfc3abdb486428d33d541c0abee", "html_url": "https://github.com/rust-lang/rust/commit/574830f5730f2cfc3abdb486428d33d541c0abee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/574830f5730f2cfc3abdb486428d33d541c0abee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36aa7c143672af30bfcca01e5924b326f93fd922", "url": "https://api.github.com/repos/rust-lang/rust/commits/36aa7c143672af30bfcca01e5924b326f93fd922", "html_url": "https://github.com/rust-lang/rust/commit/36aa7c143672af30bfcca01e5924b326f93fd922"}, {"sha": "647d0b6dd3008b2d9d3a57a914bd1487da9133cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/647d0b6dd3008b2d9d3a57a914bd1487da9133cf", "html_url": "https://github.com/rust-lang/rust/commit/647d0b6dd3008b2d9d3a57a914bd1487da9133cf"}], "stats": {"total": 1277, "additions": 668, "deletions": 609}, "files": [{"sha": "e8cc9d9d291d2546eab0611e711dbc2fb4df75dc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -573,7 +573,7 @@ pub struct Block {\n     pub span: Span,\n     pub tokens: Option<LazyTokenStream>,\n     /// The following *isn't* a parse error, but will cause multiple errors in following stages.\n-    /// ```\n+    /// ```compile_fail\n     /// let x = {\n     ///     foo: var\n     /// };"}, {"sha": "410ed3f0bdcdd2c581812f76025ede40de542354", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -616,7 +616,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Desugar `<expr>.await` into:\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// match ::std::future::IntoFuture::into_future(<expr>) {\n     ///     mut __awaitee => loop {\n     ///         match unsafe { ::std::future::Future::poll(\n@@ -1363,7 +1363,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// {\n     ///     let result = match IntoIterator::into_iter(<head>) {\n     ///         mut iter => {\n@@ -1474,7 +1474,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// match Try::branch(<expr>) {\n     ///     ControlFlow::Continue(val) => #[allow(unreachable_code)] val,,\n     ///     ControlFlow::Break(residual) =>"}, {"sha": "54b081085cdd7b497d5868d8a471dc2990586f73", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -920,7 +920,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Given an associated type constraint like one of these:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// T: Iterator<Item: Debug>\n     ///             ^^^^^^^^^^^\n     /// T: Iterator<Item = Debug>"}, {"sha": "c93022308a37dd91b46a301dc2bd8ecf6f60b0c3", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -68,20 +68,20 @@\n //! will be made to flow subsequent breaks together onto lines. Inconsistent\n //! is the opposite. Inconsistent breaking example would be, say:\n //!\n-//! ```\n+//! ```ignore (illustrative)\n //! foo(hello, there, good, friends)\n //! ```\n //!\n //! breaking inconsistently to become\n //!\n-//! ```\n+//! ```ignore (illustrative)\n //! foo(hello, there,\n //!     good, friends);\n //! ```\n //!\n //! whereas a consistent breaking would yield:\n //!\n-//! ```\n+//! ```ignore (illustrative)\n //! foo(hello,\n //!     there,\n //!     good,\n@@ -153,14 +153,14 @@ enum IndentStyle {\n     /// Vertically aligned under whatever column this block begins at.\n     ///\n     ///     fn demo(arg1: usize,\n-    ///             arg2: usize);\n+    ///             arg2: usize) {}\n     Visual,\n     /// Indented relative to the indentation level of the previous line.\n     ///\n     ///     fn demo(\n     ///         arg1: usize,\n     ///         arg2: usize,\n-    ///     );\n+    ///     ) {}\n     Block { offset: isize },\n }\n "}, {"sha": "bbb631730d346b3c5add18042c25e9f66d70d72f", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -896,20 +896,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///\n     /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n     /// attempted while a shared borrow is live, then this function will return:\n-    ///\n-    ///     (\"x\", \"\", \"\")\n-    ///\n+    /// ```\n+    /// (\"x\", \"\", \"\")\n+    /// # ;\n+    /// ```\n     /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n     /// a shared borrow of another field `x.y`, then this function will return:\n-    ///\n-    ///     (\"x\", \"x.z\", \"x.y\")\n-    ///\n+    /// ```\n+    /// (\"x\", \"x.z\", \"x.y\")\n+    /// # ;\n+    /// ```\n     /// In the more complex union case, where the union is a field of a struct, then if a mutable\n     /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n     /// another field `x.u.y`, then this function will return:\n-    ///\n-    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n-    ///\n+    /// ```\n+    /// (\"x.u\", \"x.u.z\", \"x.u.y\")\n+    /// # ;\n+    /// ```\n     /// This is used when creating error messages like below:\n     ///\n     /// ```text"}, {"sha": "6f1c8daf42e3f72905546673aa9ecd16b1be5388", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0312\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     ///"}, {"sha": "c4cef5710aecb4a7ce556dccd667bbdb65db78da", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -210,7 +210,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// Suppose we are trying to give a name to the lifetime of the\n     /// reference `x`:\n     ///\n-    /// ```\n+    /// ```ignore (pseudo-rust)\n     /// fn foo(x: &u32) { .. }\n     /// ```\n     ///\n@@ -746,7 +746,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// e.g. given the function:\n     ///\n     /// ```\n-    /// async fn foo() -> i32 {}\n+    /// async fn foo() -> i32 { 2 }\n     /// ```\n     ///\n     /// this function, given the lowered return type of `foo`, an [`OpaqueDef`] that implements `Future<Output=i32>`,"}, {"sha": "f920d9d5c3f574f6fb56eb4e6cc448fbaa5d5b83", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -169,7 +169,7 @@ where\n     /// Returns the \"choice regions\" for a given member\n     /// constraint. This is the `R1..Rn` from a constraint like:\n     ///\n-    /// ```\n+    /// ```text\n     /// R0 member of [R1..Rn]\n     /// ```\n     crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n@@ -195,14 +195,14 @@ where\n ///\n /// Before:\n ///\n-/// ```\n+/// ```text\n /// target_list: A -> B -> C -> (None)\n /// source_list: D -> E -> F -> (None)\n /// ```\n ///\n /// After:\n ///\n-/// ```\n+/// ```text\n /// target_list: A -> B -> C -> D -> E -> F -> (None)\n /// ```\n fn append_list("}, {"sha": "b2fa16ce125af8f7c54826b8653b65b3bb1fd9bf", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -436,14 +436,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// minimum values.\n     ///\n     /// For example:\n-    ///\n-    ///     fn foo<'a, 'b>(..) where 'a: 'b\n-    ///\n+    /// ```\n+    /// fn foo<'a, 'b>( /* ... */ ) where 'a: 'b { /* ... */ }\n+    /// ```\n     /// would initialize two variables like so:\n-    ///\n-    ///     R0 = { CFG, R0 } // 'a\n-    ///     R1 = { CFG, R0, R1 } // 'b\n-    ///\n+    /// ```ignore (illustrative)\n+    /// R0 = { CFG, R0 } // 'a\n+    /// R1 = { CFG, R0, R1 } // 'b\n+    /// ```\n     /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n     /// and (b) any universally quantified regions that it outlives,\n     /// which in this case is just itself. R1 (`'b`) in contrast also\n@@ -1310,9 +1310,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// whether any of the constraints were too strong. In particular,\n     /// we want to check for a case where a universally quantified\n     /// region exceeded its bounds. Consider:\n-    ///\n-    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n-    ///\n+    /// ```compile_fail,E0312\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n     /// In this case, returning `x` requires `&'a u32 <: &'b u32`\n     /// and hence we establish (transitively) a constraint that\n     /// `'a: 'b`. The `propagate_constraints` code above will\n@@ -1366,9 +1366,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// <https://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/>\n     ///\n     /// In the canonical example\n-    ///\n-    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n-    ///\n+    /// ```compile_fail,E0312\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n     /// returning `x` requires `&'a u32 <: &'b u32` and hence we establish (transitively) a\n     /// constraint that `'a: 'b`. It is an error that we have no evidence that this\n     /// constraint holds."}, {"sha": "4b905c23e156a069939798ea253be7aaeb8be9a1", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -971,7 +971,7 @@ pub enum Locations {\n     /// things like the type of the return slot. Consider this\n     /// example:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0515\n     /// fn foo<'a>(x: &'a u32) -> &'a u32 {\n     ///     let y = 22;\n     ///     return &y; // error"}, {"sha": "c06fe881410aee4c441bb8658cc2dc30decc6971", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -187,12 +187,12 @@ pub enum RegionClassification {\n     ///\n     /// Consider this example:\n     ///\n-    /// ```\n+    /// ```ignore (pseudo-rust)\n     /// fn foo<'a, 'b>(a: &'a u32, b: &'b u32, c: &'static u32) {\n     ///   let closure = for<'x> |x: &'x u32| { .. };\n-    ///                 ^^^^^^^ pretend this were legal syntax\n-    ///                         for declaring a late-bound region in\n-    ///                         a closure signature\n+    ///    //           ^^^^^^^ pretend this were legal syntax\n+    ///    //                   for declaring a late-bound region in\n+    ///    //                   a closure signature\n     /// }\n     /// ```\n     ///"}, {"sha": "6151a80a56d58d8a05fb2aa43996b006a808ec4a", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -5,14 +5,14 @@\n //!\n //! For example, a type like:\n //!\n-//! ```\n+//! ```ignore (old code)\n //! #[derive(RustcEncodable, RustcDecodable)]\n //! struct Node { id: usize }\n //! ```\n //!\n //! would generate two implementations like:\n //!\n-//! ```\n+//! ```ignore (old code)\n //! # struct Node { id: usize }\n //! impl<S: Encoder<E>, E> Encodable<S, E> for Node {\n //!     fn encode(&self, s: &mut S) -> Result<(), E> {\n@@ -40,7 +40,7 @@\n //! Other interesting scenarios are when the item has type parameters or\n //! references other non-built-in types. A type definition like:\n //!\n-//! ```\n+//! ```ignore (old code)\n //! # #[derive(RustcEncodable, RustcDecodable)]\n //! # struct Span;\n //! #[derive(RustcEncodable, RustcDecodable)]\n@@ -49,7 +49,7 @@\n //!\n //! would yield functions like:\n //!\n-//! ```\n+//! ```ignore (old code)\n //! # #[derive(RustcEncodable, RustcDecodable)]\n //! # struct Span;\n //! # struct Spanned<T> { node: T, span: Span }"}, {"sha": "0fd23fd281e19efde74f28fb5529c07083c57de8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1006,9 +1006,11 @@ impl<'a> MethodDef<'a> {\n     ///         }\n     ///     }\n     /// }\n-    ///\n-    /// // or if A is repr(packed) - note fields are matched by-value\n-    /// // instead of by-reference.\n+    /// ```\n+    /// or if A is repr(packed) - note fields are matched by-value\n+    /// instead of by-reference.\n+    /// ```\n+    /// # struct A { x: i32, y: i32 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n     ///         match *self {\n@@ -1126,14 +1128,15 @@ impl<'a> MethodDef<'a> {\n     /// // is equivalent to\n     ///\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, other: &A) -> ::bool {\n+    ///     fn eq(&self, other: &A) -> bool {\n+    ///         use A::*;\n     ///         match (&*self, &*other) {\n     ///             (&A1, &A1) => true,\n     ///             (&A2(ref self_0),\n     ///              &A2(ref __arg_1_0)) => (*self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n-    ///                 let __arg_1_vi = match *other { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __self_vi = match *self { A1 => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *other { A1 => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }"}, {"sha": "db8dce804a31beb2fc44f293a632ee940cd0489a", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -249,7 +249,7 @@ fn generate_test_harness(\n ///\n /// By default this expands to\n ///\n-/// ```\n+/// ```ignore UNSOLVED (I think I still need guidance for this one. Is it correct? Do we try to make it run? How do we nicely fill it out?)\n /// #[rustc_main]\n /// pub fn main() {\n ///     extern crate test;"}, {"sha": "d0724baf9e0ac8a3c7a58f81ab7331c41f6715d8", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -394,15 +394,15 @@ impl Drop for Linker<'_> {\n ///\n /// At a high level Thin LTO looks like:\n ///\n-///     1. Prepare a \"summary\" of each LLVM module in question which describes\n-///        the values inside, cost of the values, etc.\n-///     2. Merge the summaries of all modules in question into one \"index\"\n-///     3. Perform some global analysis on this index\n-///     4. For each module, use the index and analysis calculated previously to\n-///        perform local transformations on the module, for example inlining\n-///        small functions from other modules.\n-///     5. Run thin-specific optimization passes over each module, and then code\n-///        generate everything at the end.\n+///    1. Prepare a \"summary\" of each LLVM module in question which describes\n+///       the values inside, cost of the values, etc.\n+///    2. Merge the summaries of all modules in question into one \"index\"\n+///    3. Perform some global analysis on this index\n+///    4. For each module, use the index and analysis calculated previously to\n+///       perform local transformations on the module, for example inlining\n+///       small functions from other modules.\n+///    5. Run thin-specific optimization passes over each module, and then code\n+///       generate everything at the end.\n ///\n /// The summary for each module is intended to be quite cheap, and the global\n /// index is relatively quite cheap to create as well. As a result, the goal of"}, {"sha": "aaec4e68c1743f193212acdf4cfe665c59a67ecc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -27,9 +27,9 @@ The module is thus driven from an outside client with functions like\n Internally the module will try to reuse already created metadata by\n utilizing a cache. The way to get a shared metadata node when needed is\n thus to just call the corresponding function in this module:\n-\n-    let file_metadata = file_metadata(cx, file);\n-\n+```ignore (illustrative)\n+let file_metadata = file_metadata(cx, file);\n+```\n The function will take care of probing the cache for an existing node for\n that exact file path.\n \n@@ -63,7 +63,7 @@ struct List {\n \n will generate the following callstack with a naive DFS algorithm:\n \n-```\n+```ignore (illustrative)\n describe(t = List)\n   describe(t = i32)\n   describe(t = Option<Box<List>>)"}, {"sha": "c81e1b124f0e5f02eb4ddb904e7d97a41856226d", "filename": "compiler/rustc_data_structures/src/frozen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -23,7 +23,8 @@\n //! `computed` does not change accidentally (e.g. somebody might accidentally call\n //! `foo.computed.mutate()`). This is what `Frozen` is for. We can do the following:\n //!\n-//! ```rust\n+//! ```\n+//! # struct Bar {}\n //! use rustc_data_structures::frozen::Frozen;\n //!\n //! struct Foo {"}, {"sha": "74f432a7967f9f585feec2709033b71aafd2aae0", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -202,7 +202,7 @@ impl<O> Node<O> {\n /// with this node.\n ///\n /// The non-`Error` state transitions are as follows.\n-/// ```\n+/// ```text\n /// (Pre-creation)\n ///  |\n ///  |     register_obligation_at() (called by process_obligations() and"}, {"sha": "ed5e566184f12922491d15a83544e0924d93e352", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -25,9 +25,8 @@ of the reference because the backing allocation of the vector does not change.\n This library enables this safe usage by keeping the owner and the reference\n bundled together in a wrapper type that ensure that lifetime constraint:\n \n-```rust\n-# extern crate owning_ref;\n-# use owning_ref::OwningRef;\n+```\n+# use rustc_data_structures::owning_ref::OwningRef;\n # fn main() {\n fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {\n     let v = vec![1, 2, 3, 4];\n@@ -56,8 +55,7 @@ See the documentation around `OwningHandle` for more details.\n ## Basics\n \n ```\n-extern crate owning_ref;\n-use owning_ref::BoxRef;\n+use rustc_data_structures::owning_ref::BoxRef;\n \n fn main() {\n     // Create an array owned by a Box.\n@@ -78,8 +76,7 @@ fn main() {\n ## Caching a reference to a struct field\n \n ```\n-extern crate owning_ref;\n-use owning_ref::BoxRef;\n+use rustc_data_structures::owning_ref::BoxRef;\n \n fn main() {\n     struct Foo {\n@@ -106,8 +103,7 @@ fn main() {\n ## Caching a reference to an entry in a vector\n \n ```\n-extern crate owning_ref;\n-use owning_ref::VecRef;\n+use rustc_data_structures::owning_ref::VecRef;\n \n fn main() {\n     let v = VecRef::new(vec![1, 2, 3, 4, 5]).map(|v| &v[3]);\n@@ -118,8 +114,7 @@ fn main() {\n ## Caching a subslice of a String\n \n ```\n-extern crate owning_ref;\n-use owning_ref::StringRef;\n+use rustc_data_structures::owning_ref::StringRef;\n \n fn main() {\n     let s = StringRef::new(\"hello world\".to_owned())\n@@ -132,8 +127,7 @@ fn main() {\n ## Reference counted slices that share ownership of the backing storage\n \n ```\n-extern crate owning_ref;\n-use owning_ref::RcRef;\n+use rustc_data_structures::owning_ref::RcRef;\n use std::rc::Rc;\n \n fn main() {\n@@ -155,8 +149,7 @@ fn main() {\n ## Atomic reference counted slices that share ownership of the backing storage\n \n ```\n-extern crate owning_ref;\n-use owning_ref::ArcRef;\n+use rustc_data_structures::owning_ref::ArcRef;\n use std::sync::Arc;\n \n fn main() {\n@@ -188,8 +181,7 @@ fn main() {\n ## References into RAII locks\n \n ```\n-extern crate owning_ref;\n-use owning_ref::RefRef;\n+use rustc_data_structures::owning_ref::RefRef;\n use std::cell::{RefCell, Ref};\n \n fn main() {\n@@ -219,8 +211,7 @@ When the owned container implements `DerefMut`, it is also possible to make\n a _mutable owning reference_. (e.g., with `Box`, `RefMut`, `MutexGuard`)\n \n ```\n-extern crate owning_ref;\n-use owning_ref::RefMutRefMut;\n+use rustc_data_structures::owning_ref::RefMutRefMut;\n use std::cell::{RefCell, RefMut};\n \n fn main() {\n@@ -326,8 +317,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRef;\n+    /// use rustc_data_structures::owning_ref::OwningRef;\n     ///\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new(42));\n@@ -362,8 +352,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRef;\n+    /// use rustc_data_structures::owning_ref::OwningRef;\n     ///\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n@@ -390,8 +379,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRef;\n+    /// use rustc_data_structures::owning_ref::OwningRef;\n     ///\n     /// fn main() {\n     ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n@@ -441,8 +429,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::{OwningRef, Erased};\n+    /// use rustc_data_structures::owning_ref::{OwningRef, Erased};\n     ///\n     /// fn main() {\n     ///     // N.B., using the concrete types here for explicitness.\n@@ -460,7 +447,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, i32>\n     ///         = owning_ref_b.map(|a| &a[1].0);\n     ///\n-    ///     let owning_refs: [OwningRef<Box<Erased>, i32>; 2]\n+    ///     let owning_refs: [OwningRef<Box<dyn Erased>, i32>; 2]\n     ///         = [owning_ref_a.erase_owner(), owning_ref_b.erase_owner()];\n     ///\n     ///     assert_eq!(*owning_refs[0], 1);\n@@ -516,8 +503,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRefMut;\n+    /// use rustc_data_structures::owning_ref::OwningRefMut;\n     ///\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new(42));\n@@ -552,8 +538,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRefMut;\n+    /// use rustc_data_structures::owning_ref::OwningRefMut;\n     ///\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n@@ -580,8 +565,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRefMut;\n+    /// use rustc_data_structures::owning_ref::OwningRefMut;\n     ///\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n@@ -608,8 +592,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRefMut;\n+    /// use rustc_data_structures::owning_ref::OwningRefMut;\n     ///\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n@@ -638,8 +621,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::OwningRefMut;\n+    /// use rustc_data_structures::owning_ref::OwningRefMut;\n     ///\n     /// fn main() {\n     ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n@@ -689,8 +671,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///\n     /// # Example\n     /// ```\n-    /// extern crate owning_ref;\n-    /// use owning_ref::{OwningRefMut, Erased};\n+    /// use rustc_data_structures::owning_ref::{OwningRefMut, Erased};\n     ///\n     /// fn main() {\n     ///     // N.B., using the concrete types here for explicitness.\n@@ -708,7 +689,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, i32>\n     ///         = owning_ref_mut_b.map_mut(|a| &mut a[1].0);\n     ///\n-    ///     let owning_refs_mut: [OwningRefMut<Box<Erased>, i32>; 2]\n+    ///     let owning_refs_mut: [OwningRefMut<Box<dyn Erased>, i32>; 2]\n     ///         = [owning_ref_mut_a.erase_owner(), owning_ref_mut_b.erase_owner()];\n     ///\n     ///     assert_eq!(*owning_refs_mut[0], 1);"}, {"sha": "651bc556c9853608d50798b7c894fce88204ee86", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -45,7 +45,8 @@ pub unsafe trait Pointer: Deref {\n     /// case you'll need to manually figure out what the right type to pass to\n     /// align_of is.\n     ///\n-    /// ```rust\n+    /// ```ignore UNSOLVED (what to do about the Self)\n+    /// # use std::ops::Deref;\n     /// std::mem::align_of::<<Self as Deref>::Target>().trailing_zeros() as usize;\n     /// ```\n     const BITS: usize;"}, {"sha": "0ff64969b071c9954b5187adf209450124ee75dd", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -282,7 +282,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     /// (where the relation is encoding the `<=` relation for the lattice).\n     /// So e.g., if the relation is `->` and we have\n     ///\n-    /// ```\n+    /// ```text\n     /// a -> b -> d -> f\n     /// |              ^\n     /// +--> c -> e ---+"}, {"sha": "f83fa68ced00daa6a0e17d615cac38f8a7e79af1", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -100,7 +100,7 @@ pub struct CodeSuggestion {\n     /// `foo.bar` might be replaced with `a.b` or `x.y` by replacing\n     /// `foo` and `bar` on their own:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// vec![\n     ///     Substitution { parts: vec![(0..3, \"a\"), (4..7, \"b\")] },\n     ///     Substitution { parts: vec![(0..3, \"x\"), (4..7, \"y\")] },\n@@ -109,7 +109,7 @@ pub struct CodeSuggestion {\n     ///\n     /// or by replacing the entire span:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// vec![\n     ///     Substitution { parts: vec![(0..7, \"a.b\")] },\n     ///     Substitution { parts: vec![(0..7, \"x.y\")] },"}, {"sha": "8994a2f78919f046bdad82d253460101ebb2cdbf", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -4,7 +4,7 @@\n //!\n //! ## Meta-variables must not be bound twice\n //!\n-//! ```\n+//! ```compile_fail\n //! macro_rules! foo { ($x:tt $x:tt) => { $x }; }\n //! ```\n //!\n@@ -604,9 +604,9 @@ fn check_ops_is_prefix(\n /// Kleene operators of its binder as a prefix.\n ///\n /// Consider $i in the following example:\n-///\n-///     ( $( $i:ident = $($j:ident),+ );* ) => { $($( $i += $j; )+)* }\n-///\n+/// ```ignore (illustrative)\n+/// ( $( $i:ident = $($j:ident),+ );* ) => { $($( $i += $j; )+)* }\n+/// ```\n /// It occurs under the Kleene stack [\"*\", \"+\"] and is bound under [\"*\"] only.\n ///\n /// Arguments:"}, {"sha": "29f354d572802bc0664b0df3ff79732d9e415912", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -320,7 +320,8 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n ///\n /// Then, the tree will have the following shape:\n ///\n-/// ```rust\n+/// ```ignore (private-internal)\n+/// # use NamedMatch::*;\n /// MatchedSeq([\n ///   MatchedSeq([\n ///     MatchedNonterminal(a),"}, {"sha": "db8807bad40b11985c88a37a87edd9831a5e88f7", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -312,6 +312,7 @@ pub enum Res<Id = hir::HirId> {\n     /// HACK(min_const_generics): self types also have an optional requirement to **not** mention\n     /// any generic parameters to allow the following with `min_const_generics`:\n     /// ```\n+    /// # struct Foo;\n     /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] { todo!() } }\n     ///\n     /// struct Bar([u8; baz::<Self>()]);"}, {"sha": "2f379b85b92c7bbb1d6043d9f878b49808e1c94f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -49,15 +49,15 @@ pub enum ParamName {\n     /// Synthetic name generated when user elided a lifetime in an impl header.\n     ///\n     /// E.g., the lifetimes in cases like these:\n-    ///\n-    ///     impl Foo for &u32\n-    ///     impl Foo<'_> for u32\n-    ///\n+    /// ```ignore (fragment)\n+    /// impl Foo for &u32\n+    /// impl Foo<'_> for u32\n+    /// ```\n     /// in that case, we rewrite to\n-    ///\n-    ///     impl<'f> Foo for &'f u32\n-    ///     impl<'f> Foo<'f> for u32\n-    ///\n+    /// ```ignore (fragment)\n+    /// impl<'f> Foo for &'f u32\n+    /// impl<'f> Foo<'f> for u32\n+    /// ```\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n     Fresh(LocalDefId),\n@@ -1082,7 +1082,7 @@ pub enum PatKind<'hir> {\n     /// If `slice` exists, then `after` can be non-empty.\n     ///\n     /// The representation for e.g., `[a, b, .., c, d]` is:\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// PatKind::Slice([Binding(a), Binding(b)], Some(Wild), [Binding(c), Binding(d)])\n     /// ```\n     Slice(&'hir [Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [Pat<'hir>]),\n@@ -2244,7 +2244,7 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n /// wouldn't it be better to make the `ty` field an enum like the\n /// following?\n ///\n-/// ```\n+/// ```ignore (pseudo-rust)\n /// enum TypeBindingKind {\n ///    Equals(...),\n ///    Binding(...),"}, {"sha": "f69ae8ebe410fd6139d7f15e4c8b3ed3b1c4befc", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -22,7 +22,7 @@\n //!\n //! Example:\n //!\n-//! ```\n+//! ```ignore (needs flags)\n //! #[rustc_if_this_changed(Hir)]\n //! fn foo() { }\n //!"}, {"sha": "61b1dd8cb017c57a20652f14ac857ea82035ea1c", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -5,6 +5,7 @@\n //! The user adds annotations to the crate of the following form:\n //!\n //! ```\n+//! # #![feature(rustc_attrs)]\n //! #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n //! #![rustc_partition_codegened(module=\"spike-x\", cfg=\"rpass2\")]\n //! ```"}, {"sha": "39f7d30e81aca096a4289ae588ac000ba002d0c1", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -6,7 +6,7 @@\n //! is always the \"expected\" output from the POV of diagnostics.\n //!\n //! Examples:\n-//!\n+//! ```ignore (fragment)\n //!     infcx.at(cause, param_env).sub(a, b)\n //!     // requires that `a <: b`, with `a` considered the \"expected\" type\n //!\n@@ -15,11 +15,11 @@\n //!\n //!     infcx.at(cause, param_env).eq(a, b)\n //!     // requires that `a == b`, with `a` considered the \"expected\" type\n-//!\n+//! ```\n //! For finer-grained control, you can also do use `trace`:\n-//!\n+//! ```ignore (fragment)\n //!     infcx.at(...).trace(a, b).sub(&c, &d)\n-//!\n+//! ```\n //! This will set `a` and `b` as the \"root\" values for\n //! error-reporting, but actually operate on `c` and `d`. This is\n //! sometimes useful when the types of `c` and `d` are not traceable"}, {"sha": "07e51afd904418db8a86380f9f367bfe23a9947f", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -87,9 +87,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///\n     /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n     /// exists only one possible impl of `Trait`, and it looks like\n-    ///\n-    ///     impl<T> Trait<'static> for T { .. }\n-    ///\n+    /// ```ignore (illustrative)\n+    /// impl<T> Trait<'static> for T { .. }\n+    /// ```\n     /// then we would prepare a query result R that (among other\n     /// things) includes a mapping to `'?0 := 'static`. When\n     /// canonicalizing this query result R, we would leave this"}, {"sha": "aa3f0600cccc850fe1317421fde9738382392f55", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -202,7 +202,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ///\n     /// A good example of this is the following:\n     ///\n-    /// ```rust\n+    /// ```compile_fail,E0308\n     /// #![feature(generic_const_exprs)]\n     ///\n     /// fn bind<const N: usize>(value: [u8; N]) -> [u8; 3 + 4] {"}, {"sha": "ccd860ce2428aa33f3b214ec7abce7aaa01aed73", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -889,7 +889,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// For the following code:\n     ///\n-    /// ```no_run\n+    /// ```ignore (illustrative)\n     /// let x: Foo<Bar<Qux>> = foo::<Bar<Qux>>();\n     /// ```\n     ///\n@@ -1872,7 +1872,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// A possible error is to forget to add `.await` when using futures:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// async fn make_u32() -> u32 {\n     ///     22\n     /// }"}, {"sha": "cb72cb41a7c00540f1a4a490eeb7d891bf43a6a5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///\n     /// Consider a case where we have\n     ///\n-    /// ```no_run\n+    /// ```compile_fail,E0623\n     /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n     ///     x.push(y);\n     /// }"}, {"sha": "e5ae835e81349c84c1e409338508dc1c82447f83", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{self, Region, TyCtxt};\n /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n ///\n /// # Example\n-/// ```\n+/// ```compile_fail,E0623\n /// fn foo(x: &mut Vec<&u8>, y: &u8)\n ///    { x.push(y); }\n /// ```"}, {"sha": "c9121f7d348ce4cadc44ce5fcae76ff6a8ad7e92", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -159,9 +159,9 @@ pub struct InferCtxtInner<'tcx> {\n     /// outlive the lifetime 'a\". These constraints derive from\n     /// instantiated type parameters. So if you had a struct defined\n     /// like\n-    ///\n+    /// ```ignore (illustrative)\n     ///     struct Foo<T:'static> { ... }\n-    ///\n+    /// ```\n     /// then in some expression `let x = Foo { ... }` it will\n     /// instantiate the type parameter `T` with a fresh type `$0`. At\n     /// the same time, it will record a region obligation of"}, {"sha": "d25484efabc5fd613c1eb76817ab68855008177a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -309,14 +309,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the same as generating an outlives constraint on `Tc` itself.\n     /// For example, if we had a function like this:\n     ///\n-    /// ```rust\n+    /// ```\n+    /// # #![feature(type_alias_impl_trait)]\n+    /// # fn main() {}\n+    /// # trait Foo<'a> {}\n+    /// # impl<'a, T> Foo<'a> for (&'a u32, T) {}\n     /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n     ///   (x, y)\n     /// }\n     ///\n     /// // Equivalent to:\n+    /// # mod dummy { use super::*;\n     /// type FooReturn<'a, T> = impl Foo<'a>;\n-    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> FooReturn<'a, T> {\n+    ///   (x, y)\n+    /// }\n+    /// # }\n     /// ```\n     ///\n     /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n@@ -602,17 +610,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n /// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n ///\n /// Example:\n-/// ```rust\n+/// ```ignore UNSOLVED (is this a bug?)\n+/// # #![feature(type_alias_impl_trait)]\n /// pub mod foo {\n ///     pub mod bar {\n-///         pub trait Bar { .. }\n-///\n+///         pub trait Bar { /* ... */ }\n ///         pub type Baz = impl Bar;\n ///\n-///         fn f1() -> Baz { .. }\n+///         # impl Bar for () {}\n+///         fn f1() -> Baz { /* ... */ }\n ///     }\n-///\n-///     fn f2() -> bar::Baz { .. }\n+///     fn f2() -> bar::Baz { /* ... */ }\n /// }\n /// ```\n ///"}, {"sha": "9ddda7b92eb5a57f11b57b1bd37df36993e828c7", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     ///\n     /// Example:\n     ///\n-    /// ```\n+    /// ```ignore (pseudo-rust)\n     /// fn foo<T>() {\n     ///    callback(for<'a> |x: &'a T| {\n     ///         // ^^^^^^^ not legal syntax, but probably should be"}, {"sha": "19d03ffa6964a31171dd859ced1854cc869004bc", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -33,9 +33,9 @@\n //! Consider:\n //!\n //! ```\n-//! fn bar<T>(a: T, b: impl for<'a> Fn(&'a T));\n+//! fn bar<T>(a: T, b: impl for<'a> Fn(&'a T)) {}\n //! fn foo<T>(x: T) {\n-//!     bar(x, |y| { ... })\n+//!     bar(x, |y| { /* ... */})\n //!          // ^ closure arg\n //! }\n //! ```"}, {"sha": "ab565d4396191bd60ecbd2cf7e16072870c02577", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -313,7 +313,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// It will not, however, work for higher-ranked bounds like:\n     ///\n-    /// ```rust\n+    /// ```compile_fail,E0311\n     /// trait Foo<'a, 'b>\n     /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n     /// {"}, {"sha": "efe254387dcc94957934758af86c2c626b8ee3ae", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -174,27 +174,27 @@ pub enum GenericKind<'tcx> {\n /// Describes the things that some `GenericKind` value `G` is known to\n /// outlive. Each variant of `VerifyBound` can be thought of as a\n /// function:\n-///\n-///     fn(min: Region) -> bool { .. }\n-///\n+/// ```ignore (pseudo-rust)\n+/// fn(min: Region) -> bool { .. }\n+/// ```\n /// where `true` means that the region `min` meets that `G: min`.\n /// (False means nothing.)\n ///\n /// So, for example, if we have the type `T` and we have in scope that\n /// `T: 'a` and `T: 'b`, then the verify bound might be:\n-///\n-///     fn(min: Region) -> bool {\n-///        ('a: min) || ('b: min)\n-///     }\n-///\n+/// ```ignore (pseudo-rust)\n+/// fn(min: Region) -> bool {\n+///    ('a: min) || ('b: min)\n+/// }\n+/// ```\n /// This is described with an `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n     /// Given a kind K and a bound B, expands to a function like the\n     /// following, where `G` is the generic for which this verify\n     /// bound was created:\n     ///\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// fn(min) -> bool {\n     ///     if G == K {\n     ///         B(min)\n@@ -218,7 +218,7 @@ pub enum VerifyBound<'tcx> {\n     ///\n     /// So we would compile to a verify-bound like\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n     /// ```\n     ///\n@@ -228,7 +228,7 @@ pub enum VerifyBound<'tcx> {\n \n     /// Given a region `R`, expands to the function:\n     ///\n-    /// ```\n+    /// ```ignore (pseudo-rust)\n     /// fn(min) -> bool {\n     ///     R: min\n     /// }\n@@ -243,7 +243,7 @@ pub enum VerifyBound<'tcx> {\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// fn(min) -> bool {\n     ///     exists (b in B) { b(min) }\n     /// }\n@@ -255,7 +255,7 @@ pub enum VerifyBound<'tcx> {\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// fn(min) -> bool {\n     ///     forall (b in B) { b(min) }\n     /// }"}, {"sha": "a0e2965b605121223fdae8ee08d6749ef7411192", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -73,10 +73,10 @@ pub struct TypeVariableStorage<'tcx> {\n     /// table exists only to help with the occurs check. In particular,\n     /// we want to report constraints like these as an occurs check\n     /// violation:\n-    ///\n-    ///     ?1 <: ?3\n-    ///     Box<?3> <: ?1\n-    ///\n+    /// ``` text\n+    /// ?1 <: ?3\n+    /// Box<?3> <: ?1\n+    /// ```\n     /// Without this second table, what would happen in a case like\n     /// this is that we would instantiate `?1` with a generalized\n     /// type like `Box<?6>`. We would then relate `Box<?3> <: Box<?6>`\n@@ -287,8 +287,9 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     /// related via equality or subtyping will yield the same root\n     /// variable (per the union-find algorithm), so `sub_root_var(a)\n     /// == sub_root_var(b)` implies that:\n-    ///\n-    ///     exists X. (a <: X || X <: a) && (b <: X || X <: b)\n+    /// ```text\n+    /// exists X. (a <: X || X <: a) && (b <: X || X <: b)\n+    /// ```\n     pub fn sub_root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.sub_relations().find(vid)\n     }"}, {"sha": "b8ba65adaa8eeed360772cb30d28bcef8fbcb0c1", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1109,7 +1109,8 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```rust,compile_fail\n+    /// ```compile_fail\n+    /// #![deny(unaligned_references)]\n     /// #[repr(packed)]\n     /// pub struct Foo {\n     ///     field1: u64,"}, {"sha": "20c8b0bb70f8b43c73bf84db0d6ef2cf8e729284", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -737,7 +737,7 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// fn foo(x: usize) -> bool {\n     ///     loop {\n     ///         true  // If `get_return_block` gets passed the `id` corresponding"}, {"sha": "2350a6ab155464f5c8fa710e793f67b2e41a1c8b", "filename": "compiler/rustc_middle/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -10,7 +10,7 @@ use rustc_span::Span;\n /// Requires that `region` must be equal to one of the regions in `choice_regions`.\n /// We often denote this using the syntax:\n ///\n-/// ```\n+/// ```text\n /// R0 member of [O1..On]\n /// ```\n #[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]"}, {"sha": "5564852f305399e6f328b0311b3fc58131499ece", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -770,11 +770,11 @@ impl InitMask {\n         ///\n         /// Note that all examples below are written with 8 (instead of 64) bit blocks for simplicity,\n         /// and with the least significant bit (and lowest block) first:\n-        ///\n-        ///          00000000|00000000\n-        ///          ^      ^ ^      ^\n-        ///   index: 0      7 8      15\n-        ///\n+        /// ```text\n+        ///        00000000|00000000\n+        ///        ^      ^ ^      ^\n+        /// index: 0      7 8      15\n+        /// ```\n         /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n         fn find_bit_fast(\n             init_mask: &InitMask,"}, {"sha": "682f3734d309eb3330267e01b1c8bffd232a356c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -737,14 +737,14 @@ pub enum BorrowKind {\n     /// This is used when lowering matches: when matching on a place we want to\n     /// ensure that place have the same value from the start of the match until\n     /// an arm is selected. This prevents this code from compiling:\n-    ///\n-    ///     let mut x = &Some(0);\n-    ///     match *x {\n-    ///         None => (),\n-    ///         Some(_) if { x = &None; false } => (),\n-    ///         Some(_) => (),\n-    ///     }\n-    ///\n+    /// ```compile_fail,E0510\n+    /// let mut x = &Some(0);\n+    /// match *x {\n+    ///     None => (),\n+    ///     Some(_) if { x = &None; false } => (),\n+    ///     Some(_) => (),\n+    /// }\n+    /// ```\n     /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n     /// should not prevent `if let None = x { ... }`, for example, because the\n     /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n@@ -755,27 +755,30 @@ pub enum BorrowKind {\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure is\n     /// borrowing or mutating a mutable referent, e.g.:\n-    ///\n-    ///     let x: &mut isize = ...;\n-    ///     let y = || *x += 5;\n-    ///\n+    /// ```\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = || *x += 5;\n+    /// ```\n     /// If we were to try to translate this closure into a more explicit\n     /// form, we'd encounter an error with the code as written:\n-    ///\n-    ///     struct Env { x: & &mut isize }\n-    ///     let x: &mut isize = ...;\n-    ///     let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n-    ///     fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    ///\n+    /// ```compile_fail,E0594\n+    /// struct Env<'a> { x: &'a &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n     /// This is then illegal because you cannot mutate an `&mut` found\n     /// in an aliasable location. To solve, you'd have to translate with\n     /// an `&mut` borrow:\n-    ///\n-    ///     struct Env { x: &mut &mut isize }\n-    ///     let x: &mut isize = ...;\n-    ///     let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n-    ///     fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    ///\n+    /// ```compile_fail,E0596\n+    /// struct Env<'a> { x: &'a mut &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n     /// Now the assignment to `**env.x` is legal, but creating a\n     /// mutable pointer to `x` is not because `x` is not mutable. We\n     /// could fix this by declaring `x` as `let mut x`. This is ok in\n@@ -1016,7 +1019,7 @@ pub struct LocalDecl<'tcx> {\n     /// ```\n     /// fn foo(x: &str) {\n     ///     match {\n-    ///         match x.parse().unwrap() {\n+    ///         match x.parse::<u32>().unwrap() {\n     ///             y => y + 2\n     ///         }\n     ///     } {\n@@ -1692,9 +1695,9 @@ pub enum StatementKind<'tcx> {\n \n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n-    ///\n-    ///     let a: T = y;\n-    ///\n+    /// ```ignore (illustrative)\n+    /// let a: T = y;\n+    /// ```\n     /// The effect of this annotation is to relate the type `T_y` of the place `y`\n     /// to the user-given type `T`. The effect depends on the specified variance:\n     ///\n@@ -1987,7 +1990,7 @@ pub enum ProjectionElem<V, T> {\n     /// These indices are generated by slice patterns. Easiest to explain\n     /// by example:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n     /// [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n     /// [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n@@ -3175,7 +3178,7 @@ impl<'tcx> ConstantKind<'tcx> {\n ///\n /// An example:\n ///\n-/// ```rust\n+/// ```ignore (illustrative)\n /// struct S<'a>((i32, &'a str), String);\n /// let S((_, w): (i32, &'static str), _): S = ...;\n /// //    ------  ^^^^^^^^^^^^^^^^^^^ (1)"}, {"sha": "d389fa8c0ebdde82933a106cda01409431368097", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -438,7 +438,7 @@ impl<'tcx> CodegenUnitNameBuilder<'tcx> {\n     ///\n     /// This function will build CGU names of the form:\n     ///\n-    /// ```\n+    /// ```text\n     /// <crate-name>.<crate-disambiguator>[-in-<local-crate-id>](-<component>)*[.<special-suffix>]\n     /// <local-crate-id> = <local-crate-name>.<local-crate-disambiguator>\n     /// ```"}, {"sha": "e6eb63fd3b2b8307556dff18bebe92542b26e055", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -202,15 +202,15 @@ pub enum TerminatorKind<'tcx> {\n     /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n     /// explained by the elaboration:\n     ///\n-    /// ```\n+    /// ```ignore (MIR)\n     /// BB0 {\n     ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n     /// }\n     /// ```\n     ///\n     /// becomes\n     ///\n-    /// ```\n+    /// ```ignore (MIR)\n     /// BB0 {\n     ///   Drop(P, goto BB1, unwind BB2)\n     /// }"}, {"sha": "350bdfdadb25861add366e239bd332126e936358", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -29,7 +29,7 @@\n //!\n //! For example, the `super_basic_block_data` method begins like this:\n //!\n-//! ```rust\n+//! ```ignore (pseudo-rust)\n //! fn super_basic_block_data(&mut self,\n //!                           block: BasicBlock,\n //!                           data: & $($mutability)? BasicBlockData<'tcx>) {\n@@ -1170,10 +1170,10 @@ pub enum NonMutatingUseContext {\n     AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Will not mutate the place.\n     /// For example, the projection `x.y` is not marked as a mutation in these cases:\n-    ///\n-    ///     z = x.y;\n-    ///     f(&x.y);\n-    ///\n+    /// ```ignore (illustrative)\n+    /// z = x.y;\n+    /// f(&x.y);\n+    /// ```\n     Projection,\n }\n \n@@ -1199,10 +1199,10 @@ pub enum MutatingUseContext {\n     AddressOf,\n     /// Used as base for another place, e.g., `x` in `x.y`. Could potentially mutate the place.\n     /// For example, the projection `x.y` is marked as a mutation in these cases:\n-    ///\n-    ///     x.y = ...;\n-    ///     f(&mut x.y);\n-    ///\n+    /// ```ignore (illustrative)\n+    /// x.y = ...;\n+    /// f(&mut x.y);\n+    /// ```\n     Projection,\n     /// Retagging, a \"Stacked Borrows\" shadow state operation\n     Retag,"}, {"sha": "ffde1294ec655ffef3114f31d9d73a70a348b809", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -47,7 +47,8 @@ pub enum Reveal {\n     /// impl. Concretely, that means that the following example will\n     /// fail to compile:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n+    /// #![feature(specialization)]\n     /// trait Assoc {\n     ///     type Output;\n     /// }\n@@ -57,7 +58,7 @@ pub enum Reveal {\n     /// }\n     ///\n     /// fn main() {\n-    ///     let <() as Assoc>::Output = true;\n+    ///     let x: <() as Assoc>::Output = true;\n     /// }\n     /// ```\n     UserFacing,\n@@ -515,7 +516,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// For example, the obligation may be satisfied by a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n /// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n /// impl Clone for i32 { ... }                   // Impl_3"}, {"sha": "ce13825b01696c7af51311dd718f4b946e232ae3", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -180,6 +180,7 @@ pub struct LeafDef {\n     /// Example:\n     ///\n     /// ```\n+    /// #![feature(specialization)]\n     /// trait Tr {\n     ///     fn assoc(&self);\n     /// }"}, {"sha": "d9332f6896af6bc0bcae9a7ea7727a7b90d02050", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -59,7 +59,7 @@ pub enum PointerCast {\n ///    sized struct to a dynamically sized one. E.g., `&[i32; 4]` -> `&[i32]` is\n ///    represented by:\n ///\n-///    ```\n+///    ```ignore (illustrative)\n ///    Deref(None) -> [i32; 4],\n ///    Borrow(AutoBorrow::Ref) -> &[i32; 4],\n ///    Unsize -> &[i32],"}, {"sha": "2e4c16e39eb9671ed0de6557b1bb12f3fbb03f05", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -82,7 +82,7 @@ bitflags! {\n ///\n /// is essentially represented with [`Ty`] as the following pseudocode:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// struct S { x }\n /// ```\n ///"}, {"sha": "c88cac30a1927075f2ee503f841ea7a25413ab68", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -293,7 +293,7 @@ pub struct CaptureInfo {\n     /// let mut t = (0,1);\n     ///\n     /// let c = || {\n-    ///     println!(\"{t}\"); // L1\n+    ///     println!(\"{t:?}\"); // L1\n     ///     t.1 = 4; // L2\n     /// };\n     /// ```\n@@ -309,7 +309,7 @@ pub struct CaptureInfo {\n     /// let x = 5;\n     ///\n     /// let c = || {\n-    ///     let _ = x\n+    ///     let _ = x;\n     /// };\n     /// ```\n     ///\n@@ -373,28 +373,31 @@ pub enum BorrowKind {\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n     /// ```\n-    /// let x: &mut isize = ...;\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n     /// let y = || *x += 5;\n     /// ```\n     ///\n     /// If we were to try to translate this closure into a more explicit\n     /// form, we'd encounter an error with the code as written:\n     ///\n-    /// ```\n-    /// struct Env { x: & &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// ```compile_fail,E0594\n+    /// struct Env<'a> { x: &'a &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n     /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     /// ```\n     ///\n     /// This is then illegal because you cannot mutate a `&mut` found\n     /// in an aliasable location. To solve, you'd have to translate with\n     /// an `&mut` borrow:\n     ///\n-    /// ```\n-    /// struct Env { x: &mut &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// ```compile_fail,E0596\n+    /// struct Env<'a> { x: &'a mut &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n     /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     /// ```\n     ///"}, {"sha": "4d06c95915b3998197f940ea26f11843dd31a6a5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -455,12 +455,13 @@ pub struct TypeckResults<'tcx> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # use std::fmt::Debug;\n     /// fn foo(x: &u32) -> impl Debug { *x }\n     /// ```\n     ///\n     /// The function signature here would be:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// for<'a> fn(&'a u32) -> Foo\n     /// ```\n     ///\n@@ -469,7 +470,7 @@ pub struct TypeckResults<'tcx> {\n     ///\n     /// The *liberated* form of this would be\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// fn(&'a u32) -> u32\n     /// ```\n     ///"}, {"sha": "896a8280551d2e44908165d68b870cf70f21134b", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -41,7 +41,7 @@\n //!\n //! For example, if you have `struct S(Ty, U)` where `S: TypeFoldable` and `U:\n //! TypeFoldable`, and an instance `S(ty, u)`, it would be visited like so:\n-//! ```\n+//! ```text\n //! s.visit_with(visitor) calls\n //! - s.super_visit_with(visitor) calls\n //!   - ty.visit_with(visitor) calls\n@@ -486,13 +486,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             /// traversed. If we encounter a bound region bound by this\n             /// binder or one outer to it, it appears free. Example:\n             ///\n-            /// ```\n-            ///    for<'a> fn(for<'b> fn(), T)\n-            /// ^          ^          ^     ^\n-            /// |          |          |     | here, would be shifted in 1\n-            /// |          |          | here, would be shifted in 2\n-            /// |          | here, would be `INNERMOST` shifted in by 1\n-            /// | here, initially, binder would be `INNERMOST`\n+            /// ```ignore (illustrative)\n+            ///       for<'a> fn(for<'b> fn(), T)\n+            /// // ^          ^          ^     ^\n+            /// // |          |          |     | here, would be shifted in 1\n+            /// // |          |          | here, would be shifted in 2\n+            /// // |          | here, would be `INNERMOST` shifted in by 1\n+            /// // | here, initially, binder would be `INNERMOST`\n             /// ```\n             ///\n             /// You see that, initially, *any* bound value is free,"}, {"sha": "b8088766cca68674d3d960e5e5b5de565c14da7a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -56,7 +56,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     ///\n     /// # Example\n-    /// ```rust\n+    /// ```\n+    /// #![feature(never_type)]\n+    /// # fn main() {}\n     /// enum Void {}\n     /// mod a {\n     ///     pub mod b {\n@@ -67,6 +69,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// }\n     ///\n     /// mod c {\n+    ///     use super::Void;\n     ///     pub struct AlsoSecretlyUninhabited {\n     ///         _priv: Void,\n     ///     }\n@@ -84,7 +87,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// contain `Foo`.\n     ///\n     /// # Example\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// let foo_result: Result<T, Foo> = ... ;\n     /// let Ok(t) = foo_result;\n     /// ```"}, {"sha": "03d3a4a8c5f3c4263ef5d7286c2c5714be3ec35c", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -337,7 +337,7 @@ impl<'tcx> Instance<'tcx> {\n     /// Returns `Ok(None)` if we cannot resolve `Instance` to a specific instance.\n     /// For example, in a context like this,\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// fn foo<T: Debug>(t: T) { ... }\n     /// ```\n     ///"}, {"sha": "d847068b5bfb3e99cefaabc82dc3ab3dd51403e0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1030,9 +1030,9 @@ impl<'tcx> Predicate<'tcx> {\n /// their values.\n ///\n /// Example:\n-///\n-///     struct Foo<T, U: Bar<T>> { ... }\n-///\n+/// ```ignore (illustrative)\n+/// struct Foo<T, U: Bar<T>> { ... }\n+/// ```\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n@@ -1090,9 +1090,9 @@ pub struct OpaqueHiddenType<'tcx> {\n     /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n+    /// ```ignore (pseudo-rust)\n+    /// Foo<'a, T> = ?C\n+    /// ```\n     /// where `?C` is the value of this type variable. =) It may\n     /// naturally refer to the type and lifetime parameters in scope\n     /// in this function, though ultimately it should only reference\n@@ -1133,7 +1133,7 @@ rustc_index::newtype_index! {\n     ///\n     /// To make this more concrete, consider this program:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// struct Foo { }\n     /// fn bar<T>(x: T) {\n     ///   let y: for<'a> fn(&'a u8, Foo) = ...;\n@@ -1172,7 +1172,7 @@ impl UniverseIndex {\n     /// corresponds to entering a `forall` quantifier. So, for\n     /// example, suppose we have this type in universe `U`:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// for<'a> fn(&'a u32)\n     /// ```\n     ///\n@@ -1959,7 +1959,7 @@ pub enum ImplOverlapKind {\n     /// The widely-used version 0.1.0 of the crate `traitobject` had accidentally relied\n     /// that difference, making what reduces to the following set of impls:\n     ///\n-    /// ```\n+    /// ```compile_fail,(E0119)\n     /// trait Trait {}\n     /// impl Trait for dyn Send + Sync {}\n     /// impl Trait for dyn Sync + Send {}"}, {"sha": "7969e7aa151df46a5f6c262db7e0c00f193ede40", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -187,12 +187,14 @@ pub enum TyKind<'tcx> {\n     /// Looking at the following example, the witness for this generator\n     /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:\n     ///\n-    /// ```rust\n+    /// ```ignore UNSOLVED (ask @compiler-errors, should this error? can we just swap the yields?)\n+    /// #![feature(generators)]\n     /// |a| {\n     ///     let x = &vec![3];\n     ///     yield a;\n     ///     yield x[0];\n     /// }\n+    /// # ;\n     /// ```\n     GeneratorWitness(Binder<'tcx, &'tcx List<Ty<'tcx>>>),\n \n@@ -276,9 +278,9 @@ impl<'tcx> TyKind<'tcx> {\n static_assert_size!(TyKind<'_>, 32);\n \n /// A closure can be modeled as a struct that looks like:\n-///\n-///     struct Closure<'l0...'li, T0...Tj, CK, CS, U>(...U);\n-///\n+/// ```ignore (illustrative)\n+/// struct Closure<'l0...'li, T0...Tj, CK, CS, U>(...U);\n+/// ```\n /// where:\n ///\n /// - 'l0...'li and T0...Tj are the generic parameters\n@@ -295,25 +297,25 @@ static_assert_size!(TyKind<'_>, 32);\n ///    and the up-var has the type `Foo`, then that field of U will be `&Foo`).\n ///\n /// So, for example, given this function:\n-///\n-///     fn foo<'a, T>(data: &'a mut T) {\n-///          do(|| data.count += 1)\n-///     }\n-///\n+/// ```ignore (illustrative)\n+/// fn foo<'a, T>(data: &'a mut T) {\n+///      do(|| data.count += 1)\n+/// }\n+/// ```\n /// the type of the closure would be something like:\n-///\n-///     struct Closure<'a, T, U>(...U);\n-///\n+/// ```ignore (illustrative)\n+/// struct Closure<'a, T, U>(...U);\n+/// ```\n /// Note that the type of the upvar is not specified in the struct.\n /// You may wonder how the impl would then be able to use the upvar,\n /// if it doesn't know it's type? The answer is that the impl is\n /// (conceptually) not fully generic over Closure but rather tied to\n /// instances with the expected upvar types:\n-///\n-///     impl<'b, 'a, T> FnMut() for Closure<'a, T, (&'b mut &'a mut T,)> {\n-///         ...\n-///     }\n-///\n+/// ```ignore (illustrative)\n+/// impl<'b, 'a, T> FnMut() for Closure<'a, T, (&'b mut &'a mut T,)> {\n+///     ...\n+/// }\n+/// ```\n /// You can see that the *impl* fully specified the type of the upvar\n /// and thus knows full well that `data` has type `&'b mut &'a mut T`.\n /// (Here, I am assuming that `data` is mut-borrowed.)\n@@ -760,9 +762,9 @@ impl<'tcx> UpvarSubsts<'tcx> {\n }\n \n /// An inline const is modeled like\n-///\n-///     const InlineConst<'l0...'li, T0...Tj, R>: R;\n-///\n+/// ```ignore (illustrative)\n+/// const InlineConst<'l0...'li, T0...Tj, R>: R;\n+/// ```\n /// where:\n ///\n /// - 'l0...'li and T0...Tj are the generic parameters\n@@ -936,9 +938,9 @@ impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where-clause:\n-///\n-///     T: Foo<U>\n-///\n+/// ```ignore (illustrative)\n+/// T: Foo<U>\n+/// ```\n /// This would be represented by a trait-reference where the `DefId` is the\n /// `DefId` for the trait `Foo` and the substs define `T` as parameter 0,\n /// and `U` as parameter 1.\n@@ -1012,9 +1014,9 @@ impl<'tcx> PolyTraitRef<'tcx> {\n \n /// An existential reference to a trait, where `Self` is erased.\n /// For example, the trait object `Trait<'a, 'b, X, Y>` is:\n-///\n-///     exists T. T: Trait<'a, 'b, X, Y>\n-///\n+/// ```ignore (illustrative)\n+/// exists T. T: Trait<'a, 'b, X, Y>\n+/// ```\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n@@ -1434,7 +1436,7 @@ impl<'tcx> fmt::Debug for Region<'tcx> {\n ///\n /// In general, the region lattice looks like\n ///\n-/// ```\n+/// ```text\n /// static ----------+-----...------+       (greatest)\n /// |                |              |\n /// early-bound and  |              |\n@@ -1780,14 +1782,14 @@ impl<'tcx> Region<'tcx> {\n     /// Given an early-bound or free region, returns the `DefId` where it was bound.\n     /// For example, consider the regions in this snippet of code:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// impl<'a> Foo {\n-    ///      ^^ -- early bound, declared on an impl\n+    /// //   ^^ -- early bound, declared on an impl\n     ///\n     ///     fn bar<'b, 'c>(x: &self, y: &'b u32, z: &'c u64) where 'static: 'c\n-    ///            ^^  ^^     ^ anonymous, late-bound\n-    ///            |   early-bound, appears in where-clauses\n-    ///            late-bound, appears only in fn args\n+    /// //         ^^  ^^     ^ anonymous, late-bound\n+    /// //         |   early-bound, appears in where-clauses\n+    /// //         late-bound, appears only in fn args\n     ///     {..}\n     /// }\n     /// ```"}, {"sha": "5063420e975d14663721f6adc9c0229e732130ea", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -687,17 +687,17 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     ///\n     /// ```\n     /// type Func<A> = fn(A);\n-    /// type MetaFunc = for<'a> fn(Func<&'a i32>)\n+    /// type MetaFunc = for<'a> fn(Func<&'a i32>);\n     /// ```\n     ///\n     /// The type `MetaFunc`, when fully expanded, will be\n-    ///\n-    ///     for<'a> fn(fn(&'a i32))\n-    ///             ^~ ^~ ^~~\n-    ///             |  |  |\n-    ///             |  |  DebruijnIndex of 2\n-    ///             Binders\n-    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn(fn(&'a i32))\n+    /// //      ^~ ^~ ^~~\n+    /// //      |  |  |\n+    /// //      |  |  DebruijnIndex of 2\n+    /// //      Binders\n+    /// ```\n     /// Here the `'a` lifetime is bound in the outer function, but appears as an argument of the\n     /// inner one. Therefore, that appearance will have a DebruijnIndex of 2, because we must skip\n     /// over the inner binder (remember that we count De Bruijn indices from 1). However, in the\n@@ -709,17 +709,17 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     ///\n     /// ```\n     /// type FuncTuple<A> = (A,fn(A));\n-    /// type MetaFuncTuple = for<'a> fn(FuncTuple<&'a i32>)\n+    /// type MetaFuncTuple = for<'a> fn(FuncTuple<&'a i32>);\n     /// ```\n     ///\n     /// Here the final type will be:\n-    ///\n-    ///     for<'a> fn((&'a i32, fn(&'a i32)))\n-    ///                 ^~~         ^~~\n-    ///                 |           |\n-    ///          DebruijnIndex of 1 |\n-    ///                      DebruijnIndex of 2\n-    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn((&'a i32, fn(&'a i32)))\n+    /// //          ^~~         ^~~\n+    /// //          |           |\n+    /// //   DebruijnIndex of 1 |\n+    /// //               DebruijnIndex of 2\n+    /// ```\n     /// As indicated in the diagram, here the same type `&'a i32` is substituted once, but in the\n     /// first case we do not increase the De Bruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n@@ -767,7 +767,7 @@ pub struct UserSubsts<'tcx> {\n /// sometimes needed to constrain the type parameters on the impl. For\n /// example, in this code:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// struct Foo<T> { }\n /// impl<A> Foo<A> { fn method() { } }\n /// ```"}, {"sha": "1c8af13ce9ca1f980d4f6a99894c5029fa9c60a7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -973,7 +973,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n     ///\n     /// Examples:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// impl<'a> Foo for &'a T {\n     ///     // Legal declarations:\n     ///     fn method1(self: &&'a T); // ExplicitSelf::ByReference"}, {"sha": "09946f02448d6a5f95d7545b121375089475acbe", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> TypeWalker<'tcx> {\n     ///\n     /// Example: Imagine you are walking `Foo<Bar<i32>, usize>`.\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// let mut iter: TypeWalker = ...;\n     /// iter.next(); // yields Foo\n     /// iter.next(); // yields Bar<i32>"}, {"sha": "7eca49454ba38f784c35f626f298be08e5a8e473", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -42,15 +42,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// We tweak the handling of parameters of unsized type slightly to avoid the need to create a\n     /// local variable of unsized type. For example, consider this program:\n     ///\n-    /// ```rust\n-    /// fn foo(p: dyn Debug) { ... }\n+    /// ```\n+    /// #![feature(unsized_locals, unsized_fn_params)]\n+    /// # use core::fmt::Debug;\n+    /// fn foo(p: dyn Debug) { dbg!(p); }\n     ///\n-    /// fn bar(box_p: Box<dyn Debug>) { foo(*p); }\n+    /// fn bar(box_p: Box<dyn Debug>) { foo(*box_p); }\n     /// ```\n     ///\n     /// Ordinarily, for sized types, we would compile the call `foo(*p)` like so:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// let tmp0 = *box_p; // tmp0 would be the operand returned by this function call\n     /// foo(tmp0)\n     /// ```\n@@ -60,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// that we create *stores the entire box*, and the parameter to the call itself will be\n     /// `*tmp0`:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// let tmp0 = box_p; call foo(*tmp0)\n     /// ```\n     ///"}, {"sha": "fa1bb0622bd11ac36ad3fcdf54430f1fccbae3e9", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -37,15 +37,15 @@ crate enum PlaceBase {\n     ///\n     /// Consider the following example\n     /// ```rust\n-    /// let t = (10, (10, (10, 10)));\n+    /// let t = (((10, 10), 10), 10);\n     ///\n     /// let c = || {\n     ///     println!(\"{}\", t.0.0.0);\n     /// };\n     /// ```\n     /// Here the THIR expression for `t.0.0.0` will be something like\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// * Field(0)\n     ///     * Field(0)\n     ///         * Field(0)"}, {"sha": "8594d0806bbdd9b34c2b02c9b291e13718349edd", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1032,11 +1032,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// exhaustive match, consider:\n     ///\n     /// ```\n+    /// # fn foo(x: (bool, bool)) {\n     /// match x {\n     ///     (true, true) => (),\n     ///     (_, false) => (),\n     ///     (false, true) => (),\n     /// }\n+    /// # }\n     /// ```\n     ///\n     /// For this match, we check if `x.0` matches `true` (for the first\n@@ -1157,7 +1159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// For example, if we have something like this:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// ...\n     /// Some(x) if cond1 => ...\n     /// Some(x) => ...\n@@ -1481,11 +1483,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// ```\n     /// # let (x, y, z) = (true, true, true);\n     /// match (x, y, z) {\n-    ///     (true, _, true) => true,    // (0)\n-    ///     (_, true, _) => true,       // (1)\n-    ///     (false, false, _) => false, // (2)\n-    ///     (true, _, false) => false,  // (3)\n+    ///     (true , _    , true ) => true,  // (0)\n+    ///     (_    , true , _    ) => true,  // (1)\n+    ///     (false, false, _    ) => false, // (2)\n+    ///     (true , _    , false) => false, // (3)\n     /// }\n+    /// # ;\n     /// ```\n     ///\n     /// In that case, after we test on `x`, there are 2 overlapping candidate\n@@ -1502,14 +1505,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// with precisely the reachable arms being reachable - but that problem\n     /// is trivially NP-complete:\n     ///\n-    /// ```rust\n-    ///     match (var0, var1, var2, var3, ...) {\n-    ///         (true, _, _, false, true, ...) => false,\n-    ///         (_, true, true, false, _, ...) => false,\n-    ///         (false, _, false, false, _, ...) => false,\n-    ///         ...\n-    ///         _ => true\n-    ///     }\n+    /// ```ignore (illustrative)\n+    /// match (var0, var1, var2, var3, ...) {\n+    ///     (true , _   , _    , false, true, ...) => false,\n+    ///     (_    , true, true , false, _   , ...) => false,\n+    ///     (false, _   , false, false, _   , ...) => false,\n+    ///     ...\n+    ///     _ => true\n+    /// }\n     /// ```\n     ///\n     /// Here the last arm is reachable only if there is an assignment to\n@@ -1520,7 +1523,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// our simplistic treatment of constants and guards would make it occur\n     /// in very common situations - for example [#29740]:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// match x {\n     ///     \"foo\" if foo_guard => ...,\n     ///     \"bar\" if bar_guard => ...,"}, {"sha": "465bd62406efe92e8eafcabe18e6148f3a02ae6b", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -803,16 +803,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope (which can be larger or smaller).\n     ///\n     /// Consider:\n-    ///\n-    ///     let x = foo(bar(X, Y));\n-    ///\n+    /// ```ignore (illustrative)\n+    /// let x = foo(bar(X, Y));\n+    /// ```\n     /// We wish to pop the storage for X and Y after `bar()` is\n     /// called, not after the whole `let` is completed.\n     ///\n     /// As another example, if the second argument diverges:\n-    ///\n-    ///     foo(Box::new(2), panic!())\n-    ///\n+    /// ```ignore (illustrative)\n+    /// foo(Box::new(2), panic!())\n+    /// ```\n     /// We would allocate the box but then free it on the unwinding\n     /// path; we would also emit a free on the 'success' path from\n     /// panic, but that will turn out to be removed as dead-code.\n@@ -944,7 +944,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// Example: when compiling the call to `foo` here:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// foo(bar(), ...)\n     /// ```\n     ///\n@@ -955,7 +955,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// dropped). However, if no unwind occurs, then `_X` will be\n     /// unconditionally consumed by the `call`:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// bb {\n     ///   ...\n     ///   _R = CALL(foo, _X, ...)"}, {"sha": "60eead69a1b05445f80c696832b7dcb682fa22bb", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -13,7 +13,7 @@\n //! Instead of listing all those constructors (which is intractable), we group those value\n //! constructors together as much as possible. Example:\n //!\n-//! ```\n+//! ```compile_fail,E0004\n //! match (0, false) {\n //!     (0 ..=100, true) => {} // `p_1`\n //!     (50..=150, false) => {} // `p_2`\n@@ -344,13 +344,13 @@ enum IntBorder {\n /// straddles the boundary of one of the inputs.\n ///\n /// The following input:\n-/// ```\n+/// ```text\n ///   |-------------------------| // `self`\n /// |------|  |----------|   |----|\n ///    |-------| |-------|\n /// ```\n /// would be iterated over as follows:\n-/// ```\n+/// ```text\n ///   ||---|--||-|---|---|---|--|\n /// ```\n #[derive(Debug, Clone)]\n@@ -492,14 +492,17 @@ impl Slice {\n ///\n /// Let's look at an example, where we are trying to split the last pattern:\n /// ```\n+/// # fn foo(x: &[bool]) {\n /// match x {\n ///     [true, true, ..] => {}\n ///     [.., false, false] => {}\n ///     [..] => {}\n /// }\n+/// # }\n /// ```\n /// Here are the results of specialization for the first few lengths:\n /// ```\n+/// # fn foo(x: &[bool]) { match x {\n /// // length 0\n /// [] => {}\n /// // length 1\n@@ -520,6 +523,8 @@ impl Slice {\n /// [true, true, _, _,     _    ] => {}\n /// [_,    _,    _, false, false] => {}\n /// [_,    _,    _, _,     _    ] => {}\n+/// # _ => {}\n+/// # }}\n /// ```\n ///\n /// If we went above length 5, we would simply be inserting more columns full of wildcards in the\n@@ -1128,7 +1133,8 @@ impl<'tcx> SplitWildcard<'tcx> {\n /// In the following example `Fields::wildcards` returns `[_, _, _, _]`. Then in\n /// `extract_pattern_arguments` we fill some of the entries, and the result is\n /// `[Some(0), _, _, _]`.\n-/// ```rust\n+/// ```compile_fail,E0004\n+/// # fn foo() -> [Option<u8>; 4] { [None; 4] }\n /// let x: [Option<u8>; 4] = foo();\n /// match x {\n ///     [Some(0), ..] => {}"}, {"sha": "4e96cfd9bbd501191157dc7f64a3fc8ae456dd3c", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -35,23 +35,27 @@\n //! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n //! is useful w.r.t. the patterns above it:\n //! ```rust\n+//! # fn foo(x: Option<i32>) {\n //! match x {\n-//!     Some(_) => ...,\n-//!     None => ..., // reachable: `None` is matched by this but not the branch above\n-//!     Some(0) => ..., // unreachable: all the values this matches are already matched by\n-//!                     // `Some(_)` above\n+//!     Some(_) => {},\n+//!     None => {},    // reachable: `None` is matched by this but not the branch above\n+//!     Some(0) => {}, // unreachable: all the values this matches are already matched by\n+//!                    // `Some(_)` above\n //! }\n+//! # }\n //! ```\n //!\n //! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n //! pattern is _not_ useful w.r.t. the patterns in the match. The values returned by `usefulness`\n //! are used to tell the user which values are missing.\n-//! ```rust\n+//! ```compile_fail,E0004\n+//! # fn foo(x: Option<i32>) {\n //! match x {\n-//!     Some(0) => ...,\n-//!     None => ...,\n+//!     Some(0) => {},\n+//!     None => {},\n //!     // not exhaustive: `_` is useful because it matches `Some(1)`\n //! }\n+//! # }\n //! ```\n //!\n //! The entrypoint of this file is the [`compute_match_usefulness`] function, which computes\n@@ -120,24 +124,29 @@\n //! say from knowing only the first constructor of our candidate value.\n //!\n //! Let's take the following example:\n-//! ```\n+//! ```compile_fail,E0004\n+//! # enum Enum { Variant1(()), Variant2(Option<bool>, u32)}\n+//! # fn foo(x: Enum) {\n //! match x {\n //!     Enum::Variant1(_) => {} // `p1`\n //!     Enum::Variant2(None, 0) => {} // `p2`\n //!     Enum::Variant2(Some(_), 0) => {} // `q`\n //! }\n+//! # }\n //! ```\n //!\n //! We can easily see that if our candidate value `v` starts with `Variant1` it will not match `q`.\n //! If `v = Variant2(v0, v1)` however, whether or not it matches `p2` and `q` will depend on `v0`\n //! and `v1`. In fact, such a `v` will be a witness of usefulness of `q` exactly when the tuple\n //! `(v0, v1)` is a witness of usefulness of `q'` in the following reduced match:\n //!\n-//! ```\n+//! ```compile_fail,E0004\n+//! # fn foo(x: (Option<bool>, u32)) {\n //! match x {\n //!     (None, 0) => {} // `p2'`\n //!     (Some(_), 0) => {} // `q'`\n //! }\n+//! # }\n //! ```\n //!\n //! This motivates a new step in computing usefulness, that we call _specialization_.\n@@ -150,7 +159,7 @@\n //! like a stack. We note a pattern-stack simply with `[p_1 ... p_n]`.\n //! Here's a sequence of specializations of a list of pattern-stacks, to illustrate what's\n //! happening:\n-//! ```\n+//! ```ignore (illustrative)\n //! [Enum::Variant1(_)]\n //! [Enum::Variant2(None, 0)]\n //! [Enum::Variant2(Some(_), 0)]\n@@ -234,7 +243,7 @@\n //!     - We return the concatenation of all the witnesses found, if any.\n //!\n //! Example:\n-//! ```\n+//! ```ignore (illustrative)\n //! [Some(true)] // p_1\n //! [None] // p_2\n //! [Some(_)] // q\n@@ -659,13 +668,15 @@ enum ArmType {\n ///\n /// For example, if we are constructing a witness for the match against\n ///\n-/// ```\n+/// ```compile_fail,E0004\n+/// # #![feature(type_ascription)]\n /// struct Pair(Option<(u32, u32)>, bool);\n-///\n+/// # fn foo(p: Pair) {\n /// match (p: Pair) {\n ///    Pair(None, _) => {}\n ///    Pair(_, false) => {}\n /// }\n+/// # }\n /// ```\n ///\n /// We'll perform the following steps:"}, {"sha": "c9722a6df77dbef683c933f10981d0f5121e29e9", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -37,21 +37,21 @@ pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n ///\n /// ```rust\n /// struct S;\n-/// fn foo(pred: bool) {                       // maybe-init:\n-///                                            // {}\n-///     let a = S; let b = S; let c; let d;    // {a, b}\n+/// fn foo(pred: bool) {                        // maybe-init:\n+///                                             // {}\n+///     let a = S; let mut b = S; let c; let d; // {a, b}\n ///\n ///     if pred {\n-///         drop(a);                           // {   b}\n-///         b = S;                             // {   b}\n+///         drop(a);                            // {   b}\n+///         b = S;                              // {   b}\n ///\n ///     } else {\n-///         drop(b);                           // {a}\n-///         d = S;                             // {a,       d}\n+///         drop(b);                            // {a}\n+///         d = S;                              // {a,       d}\n ///\n-///     }                                      // {a, b,    d}\n+///     }                                       // {a, b,    d}\n ///\n-///     c = S;                                 // {a, b, c, d}\n+///     c = S;                                  // {a, b, c, d}\n /// }\n /// ```\n ///\n@@ -90,21 +90,21 @@ impl<'a, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n ///\n /// ```rust\n /// struct S;\n-/// fn foo(pred: bool) {                       // maybe-uninit:\n-///                                            // {a, b, c, d}\n-///     let a = S; let b = S; let c; let d;    // {      c, d}\n+/// fn foo(pred: bool) {                        // maybe-uninit:\n+///                                             // {a, b, c, d}\n+///     let a = S; let mut b = S; let c; let d; // {      c, d}\n ///\n ///     if pred {\n-///         drop(a);                           // {a,    c, d}\n-///         b = S;                             // {a,    c, d}\n+///         drop(a);                            // {a,    c, d}\n+///         b = S;                              // {a,    c, d}\n ///\n ///     } else {\n-///         drop(b);                           // {   b, c, d}\n-///         d = S;                             // {   b, c   }\n+///         drop(b);                            // {   b, c, d}\n+///         d = S;                              // {   b, c   }\n ///\n-///     }                                      // {a, b, c, d}\n+///     }                                       // {a, b, c, d}\n ///\n-///     c = S;                                 // {a, b,    d}\n+///     c = S;                                  // {a, b,    d}\n /// }\n /// ```\n ///\n@@ -155,21 +155,21 @@ impl<'a, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n ///\n /// ```rust\n /// struct S;\n-/// fn foo(pred: bool) {                       // definite-init:\n-///                                            // {          }\n-///     let a = S; let b = S; let c; let d;    // {a, b      }\n+/// fn foo(pred: bool) {                        // definite-init:\n+///                                             // {          }\n+///     let a = S; let mut b = S; let c; let d; // {a, b      }\n ///\n ///     if pred {\n-///         drop(a);                           // {   b,     }\n-///         b = S;                             // {   b,     }\n+///         drop(a);                            // {   b,     }\n+///         b = S;                              // {   b,     }\n ///\n ///     } else {\n-///         drop(b);                           // {a,        }\n-///         d = S;                             // {a,       d}\n+///         drop(b);                            // {a,        }\n+///         d = S;                              // {a,       d}\n ///\n-///     }                                      // {          }\n+///     }                                       // {          }\n ///\n-///     c = S;                                 // {       c  }\n+///     c = S;                                  // {       c  }\n /// }\n /// ```\n ///\n@@ -210,21 +210,21 @@ impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n ///\n /// ```rust\n /// struct S;\n-/// fn foo(pred: bool) {                       // ever-init:\n-///                                            // {          }\n-///     let a = S; let b = S; let c; let d;    // {a, b      }\n+/// fn foo(pred: bool) {                        // ever-init:\n+///                                             // {          }\n+///     let a = S; let mut b = S; let c; let d; // {a, b      }\n ///\n ///     if pred {\n-///         drop(a);                           // {a, b,     }\n-///         b = S;                             // {a, b,     }\n+///         drop(a);                            // {a, b,     }\n+///         b = S;                              // {a, b,     }\n ///\n ///     } else {\n-///         drop(b);                           // {a, b,      }\n-///         d = S;                             // {a, b,    d }\n+///         drop(b);                            // {a, b,      }\n+///         d = S;                              // {a, b,    d }\n ///\n-///     }                                      // {a, b,    d }\n+///     }                                       // {a, b,    d }\n ///\n-///     c = S;                                 // {a, b, c, d }\n+///     c = S;                                  // {a, b, c, d }\n /// }\n /// ```\n pub struct EverInitializedPlaces<'a, 'tcx> {"}, {"sha": "d5d4bfa255bd98fab46b686ab2fd8c896ac2d047", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -18,13 +18,13 @@\n //!     First upvars are stored\n //!     It is followed by the generator state field.\n //!     Then finally the MIR locals which are live across a suspension point are stored.\n-//!\n+//!     ```ignore (illustrative)\n //!     struct Generator {\n //!         upvars...,\n //!         state: u32,\n //!         mir_locals...,\n //!     }\n-//!\n+//!     ```\n //! This pass computes the meaning of the state field and the MIR locals which are live\n //! across a suspension point. There are however three hardcoded generator states:\n //!     0 - Generator have not been resumed yet"}, {"sha": "7cd7d26328a1a722cee058a6486a40cc7ddd4e92", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -14,7 +14,7 @@ pub struct MatchBranchSimplification;\n ///\n /// For example:\n ///\n-/// ```rust\n+/// ```ignore (MIR)\n /// bb0: {\n ///     switchInt(move _3) -> [42_isize: bb1, otherwise: bb2];\n /// }\n@@ -32,7 +32,7 @@ pub struct MatchBranchSimplification;\n ///\n /// into:\n ///\n-/// ```rust\n+/// ```ignore (MIR)\n /// bb0: {\n ///    _2 = Eq(move _3, const 42_isize);\n ///    goto -> bb3;"}, {"sha": "bbfaace7041ecb77667fc6cdc2f4d93cbe9686fa", "filename": "compiler/rustc_mir_transform/src/simplify_comparison_integral.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -12,15 +12,15 @@ use rustc_middle::{\n /// Pass to convert `if` conditions on integrals into switches on the integral.\n /// For an example, it turns something like\n ///\n-/// ```\n+/// ```ignore (MIR)\n /// _3 = Eq(move _4, const 43i32);\n /// StorageDead(_4);\n /// switchInt(_3) -> [false: bb2, otherwise: bb3];\n /// ```\n ///\n /// into:\n ///\n-/// ```\n+/// ```ignore (MIR)\n /// switchInt(_4) -> [43i32: bb3, otherwise: bb2];\n /// ```\n pub struct SimplifyComparisonIntegral;"}, {"sha": "b3d45c7a22155c19e1a7e96794545b6ea3c73675", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1,10 +1,12 @@\n //! The general point of the optimizations provided here is to simplify something like:\n //!\n //! ```rust\n+//! # fn foo<T, E>(x: Result<T, E>) -> Result<T, E> {\n //! match x {\n //!     Ok(x) => Ok(x),\n //!     Err(x) => Err(x)\n //! }\n+//! # }\n //! ```\n //!\n //! into just `x`.\n@@ -23,7 +25,7 @@ use std::slice::Iter;\n ///\n /// This is done by transforming basic blocks where the statements match:\n ///\n-/// ```rust\n+/// ```ignore (MIR)\n /// _LOCAL_TMP = ((_LOCAL_1 as Variant ).FIELD: TY );\n /// _TMP_2 = _LOCAL_TMP;\n /// ((_LOCAL_0 as Variant).FIELD: TY) = move _TMP_2;\n@@ -32,7 +34,7 @@ use std::slice::Iter;\n ///\n /// into:\n ///\n-/// ```rust\n+/// ```ignore (MIR)\n /// _LOCAL_0 = move _LOCAL_1\n /// ```\n pub struct SimplifyArmIdentity;\n@@ -472,7 +474,7 @@ impl Visitor<'_> for LocalUseCounter {\n }\n \n /// Match on:\n-/// ```rust\n+/// ```ignore (MIR)\n /// _LOCAL_INTO = ((_LOCAL_FROM as Variant).FIELD: TY);\n /// ```\n fn match_get_variant_field<'tcx>(\n@@ -492,7 +494,7 @@ fn match_get_variant_field<'tcx>(\n }\n \n /// Match on:\n-/// ```rust\n+/// ```ignore (MIR)\n /// ((_LOCAL_FROM as Variant).FIELD: TY) = move _LOCAL_INTO;\n /// ```\n fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local, VarField<'tcx>)> {\n@@ -507,7 +509,7 @@ fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local\n }\n \n /// Match on:\n-/// ```rust\n+/// ```ignore (MIR)\n /// discriminant(_LOCAL_TO_SET) = VAR_IDX;\n /// ```\n fn match_set_discr(stmt: &Statement<'_>) -> Option<(Local, VariantIdx)> {\n@@ -690,7 +692,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n     ///\n     /// Statements can be trivially equal if the kinds match.\n     /// But they can also be considered equal in the following case A:\n-    /// ```\n+    /// ```ignore (MIR)\n     /// discriminant(_0) = 0;   // bb1\n     /// _0 = move _1;           // bb2\n     /// ```"}, {"sha": "ee02151152c6f80c1466317b6b5a4cc5d83de89a", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -91,12 +91,13 @@\n //! another function. It suffices to just take a reference in order to introduce\n //! an edge. Consider the following example:\n //!\n-//! ```rust\n+//! ```\n+//! # use core::fmt::Display;\n //! fn print_val<T: Display>(x: T) {\n //!     println!(\"{}\", x);\n //! }\n //!\n-//! fn call_fn(f: &Fn(i32), x: i32) {\n+//! fn call_fn(f: &dyn Fn(i32), x: i32) {\n //!     f(x);\n //! }\n //!"}, {"sha": "2f90a7c54aba6f4454aa182075d2d3b6dcf305f1", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -371,9 +371,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches the following grammar (per RFC 1559).\n-    ///\n-    ///     meta_item : PATH ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n-    ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n+    /// ```ebnf\n+    /// meta_item : PATH ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n+    /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n+    /// ```\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {"}, {"sha": "0f940cffcc46344b0dd51c82b11249e07aad8a28", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -485,15 +485,15 @@ impl<'a> Parser<'a> {\n \n     /// Parses an implementation item.\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// impl<'a, T> TYPE { /* impl items */ }\n     /// impl<'a, T> TRAIT for TYPE { /* impl items */ }\n     /// impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n     /// impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n     /// ```\n     ///\n     /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    /// ```\n+    /// ```ebnf\n     /// \"impl\" GENERICS \"const\"? \"!\"? TYPE \"for\"? (TYPE | \"..\") (\"where\" PREDICATES)? \"{\" BODY \"}\"\n     /// \"impl\" GENERICS \"const\"? \"!\"? TYPE (\"where\" PREDICATES)? \"{\" BODY \"}\"\n     /// ```\n@@ -806,7 +806,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `type` alias with the following grammar:\n-    /// ```\n+    /// ```ebnf\n     /// TypeAlias = \"type\" Ident Generics {\":\" GenericBounds}? {\"=\" Ty}? \";\" ;\n     /// ```\n     /// The `\"type\"` has already been eaten.\n@@ -930,7 +930,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     /// ```\n@@ -1630,7 +1630,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a declarative macro 2.0 definition.\n     /// The `macro` keyword has already been parsed.\n-    /// ```\n+    /// ```ebnf\n     /// MacBody = \"{\" TOKEN_STREAM \"}\" ;\n     /// MacParams = \"(\" TOKEN_STREAM \")\" ;\n     /// DeclMac = \"macro\" Ident MacParams? MacBody ;"}, {"sha": "b0439a5987afa6dd37fc08256932d4005b019053", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -52,7 +52,7 @@ pub(super) enum RecoverQuestionMark {\n /// Signals whether parsing a type should recover `->`.\n ///\n /// More specifically, when parsing a function like:\n-/// ```rust\n+/// ```compile_fail\n /// fn foo() => u8 { 0 }\n /// fn bar(): u8 { 0 }\n /// ```\n@@ -499,12 +499,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a function pointer type (`TyKind::BareFn`).\n-    /// ```\n-    /// [unsafe] [extern \"ABI\"] fn (S) -> T\n-    ///  ^~~~~^          ^~~~^     ^~^    ^\n-    ///    |               |        |     |\n-    ///    |               |        |   Return type\n-    /// Function Style    ABI  Parameter types\n+    /// ```ignore (illustrative)\n+    ///    [unsafe] [extern \"ABI\"] fn (S) -> T\n+    /// //  ^~~~~^          ^~~~^     ^~^    ^\n+    /// //    |               |        |     |\n+    /// //    |               |        |   Return type\n+    /// // Function Style    ABI  Parameter types\n     /// ```\n     /// We actually parse `FnHeader FnDecl`, but we error on `const` and `async` qualifiers.\n     fn parse_ty_bare_fn(\n@@ -707,7 +707,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a bound according to the grammar:\n-    /// ```\n+    /// ```ebnf\n     /// BOUND = TY_BOUND | LT_BOUND\n     /// ```\n     fn parse_generic_bound(&mut self) -> PResult<'a, Result<GenericBound, Span>> {\n@@ -729,7 +729,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a lifetime (\"outlives\") bound, e.g. `'a`, according to:\n-    /// ```\n+    /// ```ebnf\n     /// LT_BOUND = LIFETIME\n     /// ```\n     fn parse_generic_lt_bound(\n@@ -787,7 +787,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// If no modifiers are present, this does not consume any tokens.\n     ///\n-    /// ```\n+    /// ```ebnf\n     /// TY_BOUND_MODIFIERS = [\"~const\"] [\"?\"]\n     /// ```\n     fn parse_ty_bound_modifiers(&mut self) -> PResult<'a, BoundModifiers> {\n@@ -807,7 +807,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a type bound according to:\n-    /// ```\n+    /// ```ebnf\n     /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n     /// TY_BOUND_NOPAREN = [TY_BOUND_MODIFIERS] [for<LT_PARAM_DEFS>] SIMPLE_PATH\n     /// ```"}, {"sha": "f9f3169af69c9e5a18465f6133a36196d4f6e7e0", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -7,9 +7,9 @@ use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n /// nodes. Right now the format is like this:\n-///\n-///     x & y & z\n-///\n+/// ```ignore (illustrative)\n+/// x & y & z\n+/// ```\n /// where the format-string of the dep-node must contain `x`, `y`, and\n /// `z`.\n #[derive(Debug)]"}, {"sha": "95e608da012d53c1896912b7af774e5c49c41fc2", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -2270,16 +2270,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n /// Given a `binding_span` of a binding within a use statement:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// use foo::{a, b, c};\n-///              ^\n+/// //           ^\n /// ```\n ///\n /// then return the span until the next binding or the end of the statement:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// use foo::{a, b, c};\n-///              ^^^\n+/// //           ^^^\n /// ```\n fn find_span_of_binding_until_next_binding(\n     sess: &Session,\n@@ -2323,14 +2323,14 @@ fn find_span_of_binding_until_next_binding(\n /// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n /// binding.\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// use foo::a::{a, b, c};\n-///               ^^--- binding span\n-///               |\n-///               returned span\n+/// //            ^^--- binding span\n+/// //            |\n+/// //            returned span\n ///\n /// use foo::{a, b, c};\n-///           --- binding span\n+/// //        --- binding span\n /// ```\n fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n     let source_map = sess.source_map();\n@@ -2366,15 +2366,15 @@ fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option\n /// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n /// it is a nested use tree.\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// use foo::a::{b, c};\n-///          ^^^^^^^^^^ // false\n+/// //       ^^^^^^^^^^ -- false\n ///\n /// use foo::{a, b, c};\n-///          ^^^^^^^^^^ // true\n+/// //       ^^^^^^^^^^ -- true\n ///\n /// use foo::{a, b::{c, d}};\n-///          ^^^^^^^^^^^^^^^ // true\n+/// //       ^^^^^^^^^^^^^^^ -- true\n /// ```\n fn find_span_immediately_after_crate_name(\n     sess: &Session,"}, {"sha": "030c27af4447dcd47804da0890a48f8a6735284f", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -401,7 +401,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n /// The reason for this separate call is to resolve what would otherwise\n /// be a cycle. Consider this example:\n ///\n-/// ```rust\n+/// ```ignore UNSOLVED (maybe @jackh726 knows what lifetime parameter to give Sub)\n /// trait Base<'a> {\n ///     type BaseItem;\n /// }\n@@ -2546,7 +2546,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// Returns all the late-bound vars that come into scope from supertrait HRTBs, based on the\n     /// associated type name and starting trait.\n     /// For example, imagine we have\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// trait Foo<'a, 'b> {\n     ///   type As;\n     /// }"}, {"sha": "f194cf502111913a8a54f6c9929f3febb7292208", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -686,7 +686,7 @@ impl SyntaxContext {\n     /// context up one macro definition level. That is, if we have a nested macro\n     /// definition as follows:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// macro_rules! f {\n     ///    macro_rules! g {\n     ///        ...\n@@ -710,6 +710,7 @@ impl SyntaxContext {\n     /// For example, consider the following three resolutions of `f`:\n     ///\n     /// ```rust\n+    /// #![feature(decl_macro)]\n     /// mod foo { pub fn f() {} } // `f`'s `SyntaxContext` is empty.\n     /// m!(f);\n     /// macro m($f:ident) {\n@@ -746,7 +747,8 @@ impl SyntaxContext {\n     /// via a glob import with the given `SyntaxContext`.\n     /// For example:\n     ///\n-    /// ```rust\n+    /// ```compile_fail,E0425\n+    /// #![feature(decl_macro)]\n     /// m!(f);\n     /// macro m($i:ident) {\n     ///     mod foo {\n@@ -786,7 +788,7 @@ impl SyntaxContext {\n \n     /// Undo `glob_adjust` if possible:\n     ///\n-    /// ```rust\n+    /// ```ignore (illustrative)\n     /// if let Some(privacy_checking_scope) = self.reverse_glob_adjust(expansion, glob_ctxt) {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n     /// }"}, {"sha": "505c0af953af1e85e0921b636bb35ef799848162", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1058,10 +1058,11 @@ impl SourceMap {\n \n     /// Tries to find the span of the semicolon of a macro call statement.\n     /// The input must be the *call site* span of a statement from macro expansion.\n-    ///\n-    ///           v output\n-    ///     mac!();\n-    ///     ^^^^^^ input\n+    /// ```ignore (illustrative)\n+    /// //       v output\n+    ///    mac!();\n+    /// // ^^^^^^ input\n+    /// ```\n     pub fn mac_call_stmt_semi_span(&self, mac_call: Span) -> Option<Span> {\n         let span = self.span_extend_while(mac_call, char::is_whitespace).ok()?;\n         let span = span.shrink_to_hi().with_hi(BytePos(span.hi().0.checked_add(1)?));"}, {"sha": "5bd49dd21e73ceef324a090b99734188a210308d", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -22,11 +22,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// (*), computes the \"definition type\" for an opaque type\n     /// definition -- that is, the inferred value of `Foo1<'x>` or\n     /// `Foo2<'x>` that we would conceptually use in its definition:\n-    ///\n-    ///     type Foo1<'x> = impl Bar<'x> = AAA; <-- this type AAA\n-    ///     type Foo2<'x> = impl Bar<'x> = BBB; <-- or this type BBB\n-    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///\n+    /// ```ignore (illustrative)\n+    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n+    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    /// ```\n     /// Note that these values are defined in terms of a distinct set of\n     /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n     /// purpose of this function is to do that translation."}, {"sha": "79e9635f90ef6db3dcfeafd8d842f5e082b4e1d6", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -255,9 +255,9 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// `FulfillmentContext` will drive `SelectionContext` to consider that impl before giving up.\n     /// If we were to rely on `FulfillmentContext`s decision, we might end up synthesizing an impl\n     /// like this:\n-    ///\n-    ///     impl<T> Send for Foo<T> where T: IntoIterator\n-    ///\n+    /// ```ignore (illustrative)\n+    /// impl<T> Send for Foo<T> where T: IntoIterator\n+    /// ```\n     /// While it might be technically true that Foo implements Send where `T: IntoIterator`,\n     /// the bound is overly restrictive - it's really only necessary that `T: Iterator`.\n     ///\n@@ -420,10 +420,10 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// two trait predicates that differ only in their region parameters:\n     /// one containing a HRTB lifetime parameter, and one containing a 'normal'\n     /// lifetime parameter. For example:\n-    ///\n-    ///     T as MyTrait<'a>\n-    ///     T as MyTrait<'static>\n-    ///\n+    /// ```ignore (illustrative)\n+    /// T as MyTrait<'a>\n+    /// T as MyTrait<'static>\n+    /// ```\n     /// If we put both of these predicates in our computed `ParamEnv`, we'll\n     /// confuse `SelectionContext`, since it will (correctly) view both as being applicable.\n     ///"}, {"sha": "24110d30a8456e0da2e9ba274d21542e4680c57f", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -547,7 +547,7 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n /// 2. They ground negative reasoning for coherence. If a user wants to\n ///    write both a conditional blanket impl and a specific impl, we need to\n ///    make sure they do not overlap. For example, if we write\n-///    ```\n+///    ```ignore (illustrative)\n ///    impl<T> IntoIterator for Vec<T>\n ///    impl<T: Iterator> IntoIterator for T\n ///    ```"}, {"sha": "e1b6ed92269ca7b1833930bf2f9e95afa8c4a458", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -595,7 +595,7 @@ fn object_ty_for_trait<'tcx>(\n /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n /// - require the following bound:\n ///\n-///   ```\n+///   ```ignore (not-rust)\n ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n ///   ```\n ///\n@@ -621,13 +621,13 @@ fn object_ty_for_trait<'tcx>(\n /// Instead, we fudge a little by introducing a new type parameter `U` such that\n /// `Self: Unsize<U>` and `U: Trait + ?Sized`, and use `U` in place of `dyn Trait`.\n /// Written as a chalk-style query:\n-///\n-///     forall (U: Trait + ?Sized) {\n-///         if (Self: Unsize<U>) {\n-///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n-///         }\n+/// ```ignore (not-rust)\n+/// forall (U: Trait + ?Sized) {\n+///     if (Self: Unsize<U>) {\n+///         Receiver: DispatchFromDyn<Receiver[Self => U]>\n ///     }\n-///\n+/// }\n+/// ```\n /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n /// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`"}, {"sha": "be4d734b964b8fb45d35c70e4ebe87c21ddf3d02", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -158,9 +158,9 @@ pub(super) enum ProjectAndUnifyResult<'tcx> {\n }\n \n /// Evaluates constraints of the form:\n-///\n-///     for<...> <T as Trait>::U == V\n-///\n+/// ```ignore (not-rust)\n+/// for<...> <T as Trait>::U == V\n+/// ```\n /// If successful, this may result in additional obligations. Also returns\n /// the projection cache key used to track these additional obligations.\n ///\n@@ -224,9 +224,9 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n }\n \n /// Evaluates constraints of the form:\n-///\n-///     <T as Trait>::U == V\n-///\n+/// ```ignore (not-rust)\n+/// <T as Trait>::U == V\n+/// ```\n /// If successful, this may result in additional obligations.\n ///\n /// See [poly_project_and_unify_type] for an explanation of the return value.\n@@ -1258,7 +1258,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n /// that the definition of `Foo` has some clues:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// trait Foo {\n ///     type FooT : Bar<BarT=i32>\n /// }"}, {"sha": "771a3072af5d94475aa29de59fbecdeb82a7f852", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -712,9 +712,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// and we desugared it so that the type of the expression is\n     /// `Closure`, and `Closure` expects `i32` as argument. Then it\n     /// is \"as if\" the compiler generated this impl:\n-    ///\n-    ///     impl Fn(i32) for Closure { ... }\n-    ///\n+    /// ```ignore (illustrative)\n+    /// impl Fn(i32) for Closure { ... }\n+    /// ```\n     /// Now imagine our obligation is `Closure: Fn(usize)`. So far\n     /// we have matched the self type `Closure`. At this point we'll\n     /// compare the `i32` to `usize` and generate an error."}, {"sha": "6584d33032a463c88c49e2e87623132a9f64de11", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1891,7 +1891,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// Here are some (simple) examples:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// (i32, u32) -> [i32, u32]\n     /// Foo where struct Foo { x: i32, y: u32 } -> [i32, u32]\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]"}, {"sha": "49c8c56083f0816f75d5fcdbdef13da6bdcb29d4", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -52,7 +52,7 @@ pub struct OverlapError {\n ///\n /// For example, consider the following scenario:\n ///\n-/// ```rust\n+/// ```ignore (illustrative)\n /// trait Foo { ... }\n /// impl<T, U> Foo for (T, U) { ... }  // target impl\n /// impl<V> Foo for (V, V) { ... }     // source impl\n@@ -64,7 +64,7 @@ pub struct OverlapError {\n /// where-clauses add some trickiness here, because they can be used to \"define\"\n /// an argument indirectly:\n ///\n-/// ```rust\n+/// ```ignore (illustrative)\n /// impl<'a, I, T: 'a> Iterator for Cloned<I>\n ///    where I: Iterator<Item = &'a T>, T: Clone\n /// ```"}, {"sha": "de0ade64247dfa2638229bb92746f7ced70a8bf3", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -170,7 +170,7 @@ struct WfPredicates<'a, 'tcx> {\n /// predicates. This is a kind of hack to address #43784. The\n /// underlying problem in that issue was a trait structure like:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// trait Foo: Copy { }\n /// trait Bar: Foo { }\n /// impl<T: Bar> Foo for T { }"}, {"sha": "c63e9c31d535c44cc62698280f26cf5a61ab7dca", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -122,16 +122,16 @@ rustc_index::newtype_index! {\n     /// A [De Bruijn index][dbi] is a standard means of representing\n     /// regions (and perhaps later types) in a higher-ranked setting. In\n     /// particular, imagine a type like this:\n-    ///\n-    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-    ///     ^          ^            |          |           |\n-    ///     |          |            |          |           |\n-    ///     |          +------------+ 0        |           |\n-    ///     |                                  |           |\n-    ///     +----------------------------------+ 1         |\n-    ///     |                                              |\n-    ///     +----------------------------------------------+ 0\n-    ///\n+    /// ```ignore (illustrative)\n+    ///    for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+    /// // ^          ^            |          |           |\n+    /// // |          |            |          |           |\n+    /// // |          +------------+ 0        |           |\n+    /// // |                                  |           |\n+    /// // +----------------------------------+ 1         |\n+    /// // |                                              |\n+    /// // +----------------------------------------------+ 0\n+    /// ```\n     /// In this type, there are two binders (the outer fn and the inner\n     /// fn). We need to be able to determine, for any given region, which\n     /// fn type it is bound by, the inner or the outer one. There are\n@@ -203,7 +203,7 @@ impl DebruijnIndex {\n     /// it will now be bound at INNERMOST. This is an appropriate thing to do\n     /// when moving a region out from inside binders:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n     /// // Binder:  D3           D2        D1            ^^\n     /// ```\n@@ -471,9 +471,9 @@ impl Variance {\n     /// variance with which the argument appears.\n     ///\n     /// Example 1:\n-    ///\n-    ///     *mut Vec<i32>\n-    ///\n+    /// ```ignore (illustrative)\n+    /// *mut Vec<i32>\n+    /// ```\n     /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n     /// invariant with respect to `T`, so the variance in which the\n     /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n@@ -483,9 +483,9 @@ impl Variance {\n     /// (again) in `Invariant`.\n     ///\n     /// Example 2:\n-    ///\n-    ///     fn(*const Vec<i32>, *mut Vec<i32)\n-    ///\n+    /// ```ignore (illustrative)\n+    /// fn(*const Vec<i32>, *mut Vec<i32)\n+    /// ```\n     /// The ambient variance is covariant. A `fn` type is\n     /// contravariant with respect to its parameters, so the variance\n     /// within which both pointer types appear is"}, {"sha": "93f6b4a6b5aa88c3d37df5bf13ef7ca466147ee2", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -294,9 +294,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///\n     /// Example:\n     ///\n-    /// ```\n-    /// T: std::ops::Index<usize, Output = u32>\n-    /// ^1 ^^^^^^^^^^^^^^2 ^^^^3  ^^^^^^^^^^^4\n+    /// ```ignore (illustrative)\n+    ///    T: std::ops::Index<usize, Output = u32>\n+    /// // ^1 ^^^^^^^^^^^^^^2 ^^^^3  ^^^^^^^^^^^4\n     /// ```\n     ///\n     /// 1. The `self_ty` here would refer to the type `T`.\n@@ -310,7 +310,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///\n     /// For (generic) associated types\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// <Vec<u8> as Iterable<u8>>::Iter::<'a>\n     /// ```\n     ///\n@@ -756,7 +756,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///\n     /// Example:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// poly_trait_ref = Iterator<Item = u32>\n     /// self_ty = Foo\n     /// ```\n@@ -1021,10 +1021,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///\n     /// Example:\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// fn foo<T: Bar + Baz>() { }\n-    ///        ^  ^^^^^^^^^ ast_bounds\n-    ///        param_ty\n+    /// //     ^  ^^^^^^^^^ ast_bounds\n+    /// //     param_ty\n     /// ```\n     ///\n     /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be"}, {"sha": "50e55bdc4af30c5ac9e9823f27509c051248e409", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -371,7 +371,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// fn with_closure<F>(_: F)\n     ///   where F: Fn(&u32) -> &u32 { .. }\n     ///"}, {"sha": "c563d57ed96bbc7c988c3c579b177b0c1bb81aed", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -21,7 +21,7 @@\n //! When inferring the generic arguments of functions, the argument\n //! order is relevant, which can lead to the following edge case:\n //!\n-//! ```rust\n+//! ```ignore (illustrative)\n //! fn foo<T>(a: T, b: T) {\n //!     // ...\n //! }\n@@ -1210,7 +1210,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n ///\n /// Example:\n ///\n-/// ```\n+/// ```ignore (illustrative)\n /// let mut coerce = CoerceMany::new(expected_ty);\n /// for expr in exprs {\n ///     let expr_ty = fcx.check_expr_with_expectation(expr, expected);"}, {"sha": "bfd2c32fd7e3c9bbae62bca713eed7cdd6e867a2", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -439,7 +439,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Identify some cases where `as_ref()` would be appropriate and suggest it.\n     ///\n     /// Given the following code:\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// struct Foo;\n     /// fn takes_ref(_: &Foo) {}\n     /// let ref opt = Some(Foo);\n@@ -449,7 +449,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Suggest using `opt.as_ref().map(|param| takes_ref(param));` instead.\n     ///\n     /// It only checks for `Option` and `Result` and won't work with\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n     fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This function is used to determine potential \"simple\" improvements or users' errors and\n     /// provide them useful help. For example:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// fn some_fn(s: &str) {}\n     ///\n     /// let x = \"hey!\".to_owned();"}, {"sha": "15788f410f1951bf92733bd0ad8bfdc8df2fdb49", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -144,6 +144,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// code. The most common case is something like this:\n     ///\n     /// ```rust\n+    /// # fn foo() -> i32 { 4 }\n     /// match foo() {\n     ///     22 => Default::default(), // call this type `?D`\n     ///     _ => return, // return has type `!`\n@@ -168,7 +169,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// fallback to use based on whether there is a coercion pattern\n     /// like this:\n     ///\n-    /// ```\n+    /// ```ignore (not-rust)\n     /// ?Diverging -> ?V\n     /// ?NonDiverging -> ?V\n     /// ?V != ?NonDiverging"}, {"sha": "97d256cab685d4a4cfc8c378fa349a9b2965e2b8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// A common error is to add an extra semicolon:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// fn foo() -> usize {\n     ///     22;\n     /// }"}, {"sha": "bd58a6754481a53e7ae6168ab4439ee4f2b2c5d9", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n     /// the ctor would successfully solve the type mismatch and if so, suggest it:\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// fn foo(x: usize) -> usize { x }\n     /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n     /// ```\n@@ -463,7 +463,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n+    /// # fn bar_that_returns_u32() -> u32 { 4 }\n     /// fn foo() {\n     ///     bar_that_returns_u32()\n     /// }\n@@ -504,7 +505,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// A possible error is to forget to add a return type that is needed:\n     ///\n-    /// ```\n+    /// ```compile_fail,E0308\n+    /// # fn bar_that_returns_u32() -> u32 { 4 }\n     /// fn foo() {\n     ///     bar_that_returns_u32()\n     /// }\n@@ -569,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// check whether the return type is a generic type with a trait bound\n     /// only suggest this if the generic param is not present in the arguments\n     /// if this is true, hint them towards changing the return type to `impl Trait`\n-    /// ```\n+    /// ```compile_fail,E0308\n     /// fn cant_name_it<T: Fn() -> u32>() -> T {\n     ///     || 3\n     /// }"}, {"sha": "df8db0da6448259d24591d2afa036d52c38f5026", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -71,7 +71,7 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// ```\n ///\n /// Rule 3:\n-/// ```rust\n+/// ```compile_fail,E0382\n /// let mut a = (vec![0], vec![0]);\n /// drop(a);\n /// a.1 = vec![1];"}, {"sha": "5cd63cae8ad9b8534cfd3d39a3a98d94241843b3", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -17,11 +17,11 @@ use std::cell::RefCell;\n use std::ops::Deref;\n \n /// Closures defined within the function. For example:\n-///\n-///     fn foo() {\n-///         bar(move|| { ... })\n-///     }\n-///\n+/// ```ignore (illustrative)\n+/// fn foo() {\n+///     bar(move|| { ... })\n+/// }\n+/// ```\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields."}, {"sha": "c7d0f61c601a80f41f5c1a1591cb36bab574eef0", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -201,8 +201,9 @@ pub struct Pick<'tcx> {\n     pub import_ids: SmallVec<[LocalDefId; 1]>,\n \n     /// Indicates that the source expression should be autoderef'd N times\n-    ///\n-    ///     A = expr | *expr | **expr | ...\n+    /// ```ignore (not-rust)\n+    /// A = expr | *expr | **expr | ...\n+    /// ```\n     pub autoderefs: usize,\n \n     /// Indicates that we want to add an autoref (and maybe also unsize it), or if the receiver is\n@@ -1638,7 +1639,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     ///\n     /// Example (`src/test/ui/method-two-trait-defer-resolution-1.rs`):\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// trait Foo { ... }\n     /// impl Foo for Vec<i32> { ... }\n     /// impl Foo for Vec<usize> { ... }"}, {"sha": "cc62144e2b1215c5ac51535d6492330af21674cf", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -890,16 +890,19 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n /// Tupling means that all call-side arguments are packed into a tuple and\n /// passed as a single parameter. For example, if tupling is enabled, this\n /// function:\n-///\n-///     fn f(x: (isize, isize))\n-///\n+/// ```\n+/// fn f(x: (isize, isize)) {}\n+/// ```\n /// Can be called as:\n-///\n-///     f(1, 2);\n-///\n+/// ```ignore UNSOLVED (can this be done in user code?)\n+/// # fn f(x: (isize, isize)) {}\n+/// f(1, 2);\n+/// ```\n /// Instead of:\n-///\n-///     f((1, 2));\n+/// ```\n+/// # fn f(x: (isize, isize)) {}\n+/// f((1, 2));\n+/// ```\n #[derive(Clone, Eq, PartialEq)]\n enum TupleArgumentsFlag {\n     DontTupleArguments,"}, {"sha": "5eba95b495dd70c53f1bd3d80212adcd138ded7b", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -1894,7 +1894,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// Syntactically, these look like `[pat_0, ..., pat_n]`.\n     /// Semantically, we are type checking a pattern with structure:\n-    /// ```\n+    /// ```ignore (not-rust)\n     /// [before_0, ..., before_n, (slice, after_0, ... after_n)?]\n     /// ```\n     /// The type of `slice`, if it is present, depends on the `expected` type."}, {"sha": "20456cc427c52a529f645a7b342b215c77eee9a4", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     ///\n     /// Consider this silly example:\n     ///\n-    /// ```\n+    /// ```ignore UNSOLVED (does replacing @i32 with Box<i32> preserve the desired semantics for the example?)\n     /// fn borrow(x: &i32) -> &i32 {x}\n     /// fn foo(x: @i32) -> i32 {  // block: B\n     ///     let b = borrow(x);    // region: <R0>"}, {"sha": "fee2efd5804f0f0538ab733b339728e424cf8408", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -5,9 +5,9 @@\n //! immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n //! \"escalating\" the kind as needed. The borrow kind proceeds according to\n //! the following lattice:\n-//!\n-//!     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n-//!\n+//! ```ignore (not-rust)\n+//! ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n+//! ```\n //! So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n //! will promote its borrow kind to mutable borrow. If we see an `&mut x`\n //! we'll do the same. Naturally, this applies not just to the upvar, but\n@@ -447,16 +447,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///       the existing min_capture map that is stored in TypeckResults.\n     ///\n     /// Eg:\n-    /// ```rust,no_run\n+    /// ```\n+    /// #[derive(Debug)]\n     /// struct Point { x: i32, y: i32 }\n     ///\n-    /// let s: String;  // hir_id_s\n-    /// let mut p: Point; // his_id_p\n+    /// let s = String::from(\"s\");  // hir_id_s\n+    /// let mut p = Point { x: 2, y: -2 }; // his_id_p\n     /// let c = || {\n-    ///        println!(\"{s}\");  // L1\n+    ///        println!(\"{s:?}\");  // L1\n     ///        p.x += 10;  // L2\n     ///        println!(\"{}\" , p.y); // L3\n-    ///        println!(\"{p}\"); // L4\n+    ///        println!(\"{p:?}\"); // L4\n     ///        drop(s);   // L5\n     /// };\n     /// ```\n@@ -465,7 +466,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// InferBorrowKind results in a structure like this:\n     ///\n-    /// ```text\n+    /// ```ignore (illustrative)\n     /// {\n     ///       Place(base: hir_id_s, projections: [], ....) -> {\n     ///                                                            capture_kind_expr: hir_id_L5,\n@@ -487,10 +488,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///                                                          path_expr_id: hir_id_L4,\n     ///                                                          capture_kind: ByValue\n     ///                                                      },\n+    /// }\n     /// ```\n     ///\n     /// After the min capture analysis, we get:\n-    /// ```text\n+    /// ```ignore (illustrative)\n     /// {\n     ///       hir_id_s -> [\n     ///            Place(base: hir_id_s, projections: [], ....) -> {\n@@ -506,6 +508,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///                                                               capture_kind: ByValue\n     ///                                                           },\n     ///       ],\n+    /// }\n     /// ```\n     fn compute_min_captures(\n         &self,\n@@ -1285,27 +1288,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - Ty(place): Type of place\n     /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_by_move_projs`\n     /// respectively.\n-    /// ```\n+    /// ```ignore (illustrative)\n     ///                  (Ty(w), [ &[p, x], &[c] ])\n-    ///                                 |\n-    ///                    ----------------------------\n-    ///                    |                          |\n-    ///                    v                          v\n+    /// //                              |\n+    /// //                 ----------------------------\n+    /// //                 |                          |\n+    /// //                 v                          v\n     ///        (Ty(w.p), [ &[x] ])          (Ty(w.c), [ &[] ]) // I(1)\n-    ///                    |                          |\n-    ///                    v                          v\n+    /// //                 |                          |\n+    /// //                 v                          v\n     ///        (Ty(w.p), [ &[x] ])                 false\n-    ///                    |\n-    ///                    |\n-    ///          -------------------------------\n-    ///          |                             |\n-    ///          v                             v\n+    /// //                 |\n+    /// //                 |\n+    /// //       -------------------------------\n+    /// //       |                             |\n+    /// //       v                             v\n     ///     (Ty((w.p).x), [ &[] ])     (Ty((w.p).y), []) // IMP 2\n-    ///          |                             |\n-    ///          v                             v\n+    /// //       |                             |\n+    /// //       v                             v\n     ///        false              NeedsSignificantDrop(Ty(w.p.y))\n-    ///                                        |\n-    ///                                        v\n+    /// //                                     |\n+    /// //                                     v\n     ///                                      true\n     /// ```\n     ///\n@@ -1323,7 +1326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// Consider another example:\n     ///\n-    /// ```rust\n+    /// ```ignore (pseudo-rust)\n     /// struct X;\n     /// impl Drop for X {}\n     ///\n@@ -1728,22 +1731,22 @@ struct InferBorrowKind<'a, 'tcx> {\n     /// s.str2 via a MutableBorrow\n     ///\n     /// ```rust,no_run\n-    /// struct SomeStruct { str1: String, str2: String }\n+    /// struct SomeStruct { str1: String, str2: String };\n     ///\n     /// // Assume that the HirId for the variable definition is `V1`\n-    /// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") }\n+    /// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") };\n     ///\n     /// let fix_s = |new_s2| {\n     ///     // Assume that the HirId for the expression `s.str1` is `E1`\n-    ///     println!(\"Updating SomeStruct with str1=\", s.str1);\n+    ///     println!(\"Updating SomeStruct with str1={0}\", s.str1);\n     ///     // Assume that the HirId for the expression `*s.str2` is `E2`\n     ///     s.str2 = new_s2;\n     /// };\n     /// ```\n     ///\n     /// For closure `fix_s`, (at a high level) the map contains\n     ///\n-    /// ```\n+    /// ```ignore (illustrative)\n     /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     /// ```\n@@ -2071,7 +2074,7 @@ fn migration_suggestion_for_2229(\n /// Consider the following example\n /// ```rust,no_run\n /// struct Point { x: i32, y: i32 }\n-/// let mut p: Point { x: 10, y: 10 };\n+/// let mut p = Point { x: 10, y: 10 };\n ///\n /// let c = || {\n ///     p.x     += 10;\n@@ -2217,15 +2220,18 @@ fn determine_place_ancestry_relation<'tcx>(\n ///\n /// Reason we only drop the last deref is because of the following edge case:\n ///\n-/// ```rust\n+/// ```\n+/// # struct A { field_of_a: Box<i32> }\n+/// # struct B {}\n+/// # struct C<'a>(&'a i32);\n /// struct MyStruct<'a> {\n ///    a: &'static A,\n ///    b: B,\n ///    c: C<'a>,\n /// }\n ///\n /// fn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n-///     let c = || drop(&*m.a.field_of_a);\n+///     || drop(&*m.a.field_of_a)\n ///     // Here we really do want to capture `*m.a` because that outlives `'static`\n ///\n ///     // If we capture `m`, then the closure no longer outlives `'static'"}, {"sha": "829485367e0a4ee9481a7fdca20fec61cb987f2c", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -37,7 +37,7 @@ use std::ops::ControlFlow;\n /// Helper type of a temporary returned by `.for_item(...)`.\n /// This is necessary because we can't write the following bound:\n ///\n-/// ```rust\n+/// ```ignore (illustrative)\n /// F: for<'b, 'tcx> where 'tcx FnOnce(FnCtxt<'b, 'tcx>)\n /// ```\n struct CheckWfFcxBuilder<'tcx> {"}, {"sha": "5330d4d74cb073757b0f99e388685d66139dcf02", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -531,7 +531,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n /// In particular, definitions of opaque types can only use other generics as arguments,\n /// and they cannot repeat an argument. Example:\n ///\n-/// ```rust\n+/// ```ignore (illustrative)\n /// type Foo<A, B> = impl Bar<A, B>;\n ///\n /// // Okay -- `Foo` is applied to two distinct, generic types."}, {"sha": "7f2e57e61098f1c306c78851b916582efc47253f", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -109,9 +109,9 @@ pub fn identify_constrained_generic_params<'tcx>(\n /// constrained before it is used, if that is possible, and add the\n /// parameters so constrained to `input_parameters`. For example,\n /// imagine the following impl:\n-///\n-///     impl<T: Debug, U: Iterator<Item = T>> Trait for U\n-///\n+/// ```ignore (illustrative)\n+/// impl<T: Debug, U: Iterator<Item = T>> Trait for U\n+/// ```\n /// The impl's predicates are collected from left to right. Ignoring\n /// the implicit `Sized` bounds, these are\n ///   * T: Debug"}, {"sha": "e69ba99dcef4266b8ced208ef4f1806b83115111", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -698,12 +698,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// In the following example the closures `c` only captures `p.x` even though `incr`\n     /// is a capture of the nested closure\n     ///\n-    /// ```rust,ignore(cannot-test-this-because-pseudo-code)\n-    /// let p = ..;\n+    /// ```\n+    /// struct P { x: i32 }\n+    /// let mut p = P { x: 4 };\n     /// let c = || {\n     ///    let incr = 10;\n     ///    let nested = || p.x += incr;\n-    /// }\n+    /// };\n     /// ```\n     ///\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing"}, {"sha": "22db15f4d4e8e77ceb058aaa75fed098fa1aac9f", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -29,7 +29,7 @@\n //!\n //! Suppose we have the following always applicable impl:\n //!\n-//! ```rust\n+//! ```ignore (illustrative)\n //! impl<T> SpecExtend<T> for std::vec::IntoIter<T> { /* specialized impl */ }\n //! impl<T, I: Iterator<Item=T>> SpecExtend<T> for I { /* default impl */ }\n //! ```"}, {"sha": "3d7b6593a645559c19452d2138e10de5a3c398e2", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -9,12 +9,12 @@\n //! expressions of the following forms (the actual enum has many more\n //! possibilities, naturally, but they are all variants of these base\n //! forms):\n-//!\n-//!     E = rvalue    // some computed rvalue\n-//!       | x         // address of a local variable or argument\n-//!       | *E        // deref of a ptr\n-//!       | E.comp    // access to an interior component\n-//!\n+//! ```ignore (not-rust)\n+//! E = rvalue    // some computed rvalue\n+//!   | x         // address of a local variable or argument\n+//!   | *E        // deref of a ptr\n+//!   | E.comp    // access to an interior component\n+//! ```\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n //! address where the result is to be found. If Expr is a place, then this\n //! is the address of the place. If `Expr` is an rvalue, this is the address of"}, {"sha": "13d22b13ed4f199748b4e6719dc3b0f37d87a77f", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -211,15 +211,15 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n \n /// We also have to check the explicit predicates\n /// declared on the type.\n+/// ```ignore (illustrative)\n+/// struct Foo<'a, T> {\n+///     field1: Bar<T>\n+/// }\n ///\n-///     struct Foo<'a, T> {\n-///         field1: Bar<T>\n-///     }\n-///\n-///     struct Bar<U> where U: 'static, U: Foo {\n-///         ...\n-///     }\n-///\n+/// struct Bar<U> where U: 'static, U: Foo {\n+///     ...\n+/// }\n+/// ```\n /// Here, we should fetch the explicit predicates, which\n /// will give us `U: 'static` and `U: Foo`. The latter we\n /// can ignore, but we will want to process `U: 'static`,"}, {"sha": "87f844fafe67f1001bcbbc3e0a72f9da0879f9cf", "filename": "compiler/rustc_typeck/src/outlives/outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -26,9 +26,9 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// calling that fn, and hence the *callee* can assume that its\n     /// argument types are well-formed. This may imply certain relationships\n     /// between generic parameters. For example:\n-    ///\n-    ///     fn foo<'a,T>(x: &'a T)\n-    ///\n+    /// ```\n+    /// fn foo<'a,T>(x: &'a T) {}\n+    /// ```\n     /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n     /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n     ///"}, {"sha": "690c362d853e77369c1e06882cda6f7d7488920a", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574830f5730f2cfc3abdb486428d33d541c0abee/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=574830f5730f2cfc3abdb486428d33d541c0abee", "patch": "@@ -34,11 +34,11 @@ pub struct Constraint<'a> {\n \n /// To build constraints, we visit one item (type, trait) at a time\n /// and look at its contents. So e.g., if we have\n-///\n-///     struct Foo<T> {\n-///         b: Bar<T>\n-///     }\n-///\n+/// ```ignore (illustrative)\n+/// struct Foo<T> {\n+///     b: Bar<T>\n+/// }\n+/// ```\n /// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n /// the `DefId` and the start of `Foo`'s inferreds.\n pub struct CurrentItem {"}]}