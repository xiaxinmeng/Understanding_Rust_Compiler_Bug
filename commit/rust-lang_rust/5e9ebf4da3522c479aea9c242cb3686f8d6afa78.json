{"sha": "5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOWViZjRkYTM1MjJjNDc5YWVhOWMyNDJjYjM2ODZmOGQ2YWZhNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-17T02:06:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-17T02:06:21Z"}, "message": "Auto merge of #70062 - Centril:rollup-synwle8, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #69811 (resolve: Print import chains on privacy errors)\n - #69870 (expand: Implement something similar to `#[cfg(accessible(path))]`)\n - #69881 (VariantSizeDifferences: bail on SizeOverflow)\n - #70000 (resolve: Fix regression in resolution of raw keywords in paths)\n - #70029 (Bump the bootstrap compiler)\n - #70046 (Use sublice patterns to avoid computing the len)\n - #70049 (Fiddle `ParamEnv` through to a place that used to use `ParamEnv::empty` in a buggy manner)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "47150bc86e4d3d8da7a508a1875f500bd41b42b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47150bc86e4d3d8da7a508a1875f500bd41b42b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "html_url": "https://github.com/rust-lang/rust/commit/5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24252a12cd2b6adf8678255939156a2d178fe2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24252a12cd2b6adf8678255939156a2d178fe2a", "html_url": "https://github.com/rust-lang/rust/commit/e24252a12cd2b6adf8678255939156a2d178fe2a"}, {"sha": "f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "url": "https://api.github.com/repos/rust-lang/rust/commits/f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "html_url": "https://github.com/rust-lang/rust/commit/f118fee02b9b8017f5cd2f71d11ccfb1603e3005"}], "stats": {"total": 950, "additions": 679, "deletions": 271}, "files": [{"sha": "602e4511ea583c82414e7d718406772cf10f61a7", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -725,7 +725,7 @@ impl<'a> Builder<'a> {\n             self.clear_if_dirty(&my_out, &rustdoc);\n         }\n \n-        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd).arg(\"-Zconfig-profile\");\n+        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd);\n \n         let profile_var = |name: &str| {\n             let profile = if self.config.rust_optimize { \"RELEASE\" } else { \"DEV\" };\n@@ -847,13 +847,7 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"-Zforce-unstable-if-unmarked\");\n         }\n \n-        // cfg(bootstrap): the flag was renamed from `-Zexternal-macro-backtrace`\n-        // to `-Zmacro-backtrace`, keep only the latter after beta promotion.\n-        if stage == 0 {\n-            rustflags.arg(\"-Zexternal-macro-backtrace\");\n-        } else {\n-            rustflags.arg(\"-Zmacro-backtrace\");\n-        }\n+        rustflags.arg(\"-Zmacro-backtrace\");\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n "}, {"sha": "be2b0f36d14a7ef0a2d002d3ce1c73cc5df68bc4", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.43.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.44.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "36641284a769b00a8f234153a9bf1ec3fbc9a776", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1105,29 +1105,6 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Box<T> {}\n \n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume(Pin::new(&mut *self))\n-    }\n-}\n-\n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume((*self).as_mut())\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n     type Yield = G::Yield;\n@@ -1138,7 +1115,6 @@ impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n     }\n }\n \n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n     type Yield = G::Yield;"}, {"sha": "a922d4f118b5afa893beccb3dea507a802b34160", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1569,7 +1569,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n-#[cfg_attr(not(bootstrap), repr(no_niche))] // rust-lang/rust#68303.\n+#[repr(no_niche)] // rust-lang/rust#68303.\n pub struct UnsafeCell<T: ?Sized> {\n     value: T,\n }"}, {"sha": "5a731766054bda150c93b3bcdcfa2c796b5217c5", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -140,7 +140,7 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n-#![cfg_attr(not(bootstrap), feature(no_niche))] // rust-lang/rust#68303\n+#![feature(no_niche)] // rust-lang/rust#68303\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "a0873fe6b625d2158457805239dabeea915ad5e8", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1404,6 +1404,18 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n+    #[cfg(not(bootstrap))]\n+    #[unstable(\n+        feature = \"cfg_accessible\",\n+        issue = \"64797\",\n+        reason = \"`cfg_accessible` is not fully implemented\"\n+    )]\n+    #[rustc_builtin_macro]\n+    pub macro cfg_accessible($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4f23620b92b806067b336ac4fa76a5f3a7c96459", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -67,7 +67,7 @@ pub enum GeneratorState<Y, R> {\n #[lang = \"generator\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]\n-pub trait Generator<#[cfg(not(bootstrap))] R = ()> {\n+pub trait Generator<R = ()> {\n     /// The type of value this generator yields.\n     ///\n     /// This associated type corresponds to the `yield` expression and the\n@@ -110,35 +110,9 @@ pub trait Generator<#[cfg(not(bootstrap))] R = ()> {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(\n-        self: Pin<&mut Self>,\n-        #[cfg(not(bootstrap))] arg: R,\n-    ) -> GeneratorState<Self::Yield, Self::Return>;\n+    fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume((*self).as_mut())\n-    }\n-}\n-\n-#[cfg(bootstrap)]\n-#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n-    type Yield = G::Yield;\n-    type Return = G::Return;\n-\n-    fn resume(mut self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return> {\n-        G::resume(Pin::new(&mut *self))\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<&mut G> {\n     type Yield = G::Yield;\n@@ -149,7 +123,6 @@ impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<&mut G> {\n     }\n }\n \n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for &mut G {\n     type Yield = G::Yield;"}, {"sha": "c91370b2719929bef21884c043872fd08623fd9e", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -67,3 +67,12 @@ pub use crate::{\n pub use crate::macros::builtin::{\n     bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_accessible\",\n+    issue = \"64797\",\n+    reason = \"`cfg_accessible` is not fully implemented\"\n+)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::cfg_accessible;"}, {"sha": "b166c4dea0c850f1e50259a2044cbdc3fed74c95", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -90,30 +90,46 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ```\n     /// This code should only compile in modules where the uninhabitedness of Foo is\n     /// visible.\n-    pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n+    pub fn is_ty_uninhabited_from(\n+        self,\n+        module: DefId,\n+        ty: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n         // To check whether this type is uninhabited at all (not just from the\n         // given node), you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n-        ty.uninhabited_from(self).contains(self, module)\n+        ty.uninhabited_from(self, param_env).contains(self, module)\n     }\n \n-    pub fn is_ty_uninhabited_from_any_module(self, ty: Ty<'tcx>) -> bool {\n-        !ty.uninhabited_from(self).is_empty()\n+    pub fn is_ty_uninhabited_from_any_module(\n+        self,\n+        ty: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        !ty.uninhabited_from(self, param_env).is_empty()\n     }\n }\n \n impl<'tcx> AdtDef {\n     /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n+    fn uninhabited_from(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n         } else {\n             DefIdForest::intersection(\n                 tcx,\n-                self.variants.iter().map(|v| v.uninhabited_from(tcx, substs, self.adt_kind())),\n+                self.variants\n+                    .iter()\n+                    .map(|v| v.uninhabited_from(tcx, substs, self.adt_kind(), param_env)),\n             )\n         }\n     }\n@@ -126,6 +142,7 @@ impl<'tcx> VariantDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n@@ -140,7 +157,7 @@ impl<'tcx> VariantDef {\n         } else {\n             DefIdForest::union(\n                 tcx,\n-                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum)),\n+                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum, param_env)),\n             )\n         }\n     }\n@@ -153,8 +170,9 @@ impl<'tcx> FieldDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest {\n-        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx);\n+        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // `Visibility::Invisible` so we need to override `self.vis` if we're\n         // dealing with an enum.\n@@ -176,20 +194,21 @@ impl<'tcx> FieldDef {\n \n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n         match self.kind {\n-            Adt(def, substs) => def.uninhabited_from(tcx, substs),\n+            Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n             Never => DefIdForest::full(tcx),\n \n-            Tuple(ref tys) => {\n-                DefIdForest::union(tcx, tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx)))\n-            }\n+            Tuple(ref tys) => DefIdForest::union(\n+                tcx,\n+                tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n+            ),\n \n-            Array(ty, len) => match len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+            Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n-                Some(n) if n != 0 => ty.uninhabited_from(tcx),\n+                Some(n) if n != 0 => ty.uninhabited_from(tcx, param_env),\n                 _ => DefIdForest::empty(),\n             },\n "}, {"sha": "3607a4d0d15b6238d09033a5fbec15b66671e43d", "filename": "src/librustc_builtin_macros/cfg_accessible.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,54 @@\n+//! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n+\n+use rustc_ast::ast;\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_feature::AttributeTemplate;\n+use rustc_parse::validate_attr;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+crate struct Expander;\n+\n+fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n+    match mi.meta_item_list() {\n+        None => {}\n+        Some([]) => ecx.span_err(mi.span, \"`cfg_accessible` path is not specified\"),\n+        Some([_, .., l]) => ecx.span_err(l.span(), \"multiple `cfg_accessible` paths are specified\"),\n+        Some([nmi]) => match nmi.meta_item() {\n+            None => ecx.span_err(nmi.span(), \"`cfg_accessible` path cannot be a literal\"),\n+            Some(mi) => {\n+                if !mi.is_word() {\n+                    ecx.span_err(mi.span, \"`cfg_accessible` path cannot accept arguments\");\n+                }\n+                return Some(&mi.path);\n+            }\n+        },\n+    }\n+    None\n+}\n+\n+impl MultiItemModifier for Expander {\n+    fn expand(\n+        &self,\n+        ecx: &mut ExtCtxt<'_>,\n+        _span: Span,\n+        meta_item: &ast::MetaItem,\n+        item: Annotatable,\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n+        let attr = &ecx.attribute(meta_item.clone());\n+        validate_attr::check_builtin_attribute(ecx.parse_sess, attr, sym::cfg_accessible, template);\n+\n+        let path = match validate_input(ecx, meta_item) {\n+            Some(path) => path,\n+            None => return ExpandResult::Ready(Vec::new()),\n+        };\n+\n+        let failure_msg = \"cannot determine whether the path is accessible or not\";\n+        match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {\n+            Ok(true) => ExpandResult::Ready(vec![item]),\n+            Ok(false) => ExpandResult::Ready(Vec::new()),\n+            Err(_) => ExpandResult::Retry(item, failure_msg.into()),\n+        }\n+    }\n+}"}, {"sha": "b5ad67abf620106daefcee76e66de633e7b77017", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast::{self, ItemKind, MetaItem};\n use rustc_ast::ptr::P;\n-use rustc_expand::base::{Annotatable, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n@@ -48,13 +48,13 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n         let span = ecx.with_def_site_ctxt(span);\n         let mut items = Vec::new();\n         (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}, {"sha": "26a59c6b1bedb6be72ee9a87741d1360c83be0ca", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -22,6 +22,7 @@ use rustc_span::symbol::sym;\n mod asm;\n mod assert;\n mod cfg;\n+mod cfg_accessible;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -85,6 +86,7 @@ pub fn register_builtin_macros(resolver: &mut dyn Resolver, edition: Edition) {\n \n     register_attr! {\n         bench: test::expand_bench,\n+        cfg_accessible: cfg_accessible::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "b486eadd1a8bee4fcfff332e61255dfb3777c6c8", "filename": "src/librustc_builtin_macros/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_builtin_macros%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Futil.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -6,7 +6,7 @@ use rustc_span::Symbol;\n \n pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n     // All the built-in macro attributes are \"words\" at the moment.\n-    let template = AttributeTemplate::only_word();\n+    let template = AttributeTemplate { word: true, ..Default::default() };\n     let attr = ecx.attribute(meta_item.clone());\n     validate_attr::check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n }"}, {"sha": "edeb4f83c7d7e6f1bbf0fb388be057f81d7f211f", "filename": "src/librustc_data_structures/box_region.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -25,22 +25,6 @@ pub struct PinnedGenerator<I, A, R> {\n }\n \n impl<I, A, R> PinnedGenerator<I, A, R> {\n-    #[cfg(bootstrap)]\n-    pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n-        generator: T,\n-    ) -> (I, Self) {\n-        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n-\n-        // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume() {\n-            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n-            _ => panic!(),\n-        };\n-\n-        (init, result)\n-    }\n-\n-    #[cfg(not(bootstrap))]\n     pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n         generator: T,\n     ) -> (I, Self) {\n@@ -55,19 +39,6 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n         (init, result)\n     }\n \n-    #[cfg(bootstrap)]\n-    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        BOX_REGION_ARG.with(|i| {\n-            i.set(Action::Access(AccessAction(closure)));\n-        });\n-\n-        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n-        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume() {\n-            panic!()\n-        }\n-    }\n-\n-    #[cfg(not(bootstrap))]\n     pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n         BOX_REGION_ARG.with(|i| {\n             i.set(Action::Access(AccessAction(closure)));\n@@ -79,16 +50,6 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n         }\n     }\n \n-    #[cfg(bootstrap)]\n-    pub fn complete(&mut self) -> R {\n-        // Tell the generator we want it to complete, consuming it and yielding a result\n-        BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n-\n-        let result = Pin::new(&mut self.generator).resume();\n-        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n-    }\n-\n-    #[cfg(not(bootstrap))]\n     pub fn complete(&mut self) -> R {\n         // Tell the generator we want it to complete, consuming it and yielding a result\n         BOX_REGION_ARG.with(|i| i.set(Action::Complete));"}, {"sha": "f5f2a5ed43f2c66207e6ebba755d6ee2e78f84a3", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -258,37 +258,39 @@ impl Annotatable {\n     }\n }\n \n-// `meta_item` is the annotation, and `item` is the item being modified.\n-// FIXME Decorators should follow the same pattern too.\n+/// Result of an expansion that may need to be retried.\n+/// Consider using this for non-`MultiItemModifier` expanders as well.\n+pub enum ExpandResult<T, U> {\n+    /// Expansion produced a result (possibly dummy).\n+    Ready(T),\n+    /// Expansion could not produce a result and needs to be retried.\n+    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n+    Retry(U, String),\n+}\n+\n+// `meta_item` is the attribute, and `item` is the item being modified.\n pub trait MultiItemModifier {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable>;\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n-impl<F, T> MultiItemModifier for F\n+impl<F> MultiItemModifier for F\n where\n-    F: Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, Annotatable) -> T,\n-    T: Into<Vec<Annotatable>>,\n+    F: Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, Annotatable) -> Vec<Annotatable>,\n {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n-        (*self)(ecx, span, meta_item, item).into()\n-    }\n-}\n-\n-impl Into<Vec<Annotatable>> for Annotatable {\n-    fn into(self) -> Vec<Annotatable> {\n-        vec![self]\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n }\n \n@@ -895,6 +897,7 @@ pub trait Resolver {\n \n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n     fn add_derive_copy(&mut self, expn_id: ExpnId);\n+    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n #[derive(Clone)]"}, {"sha": "4d0548f3f868ad412583534ecb87baa48d11a6c0", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 103, "deletions": 42, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let invoc = if let Some(invoc) = invocations.pop() {\n+            let (invoc, res) = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -420,30 +420,51 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue;\n             };\n \n-            let eager_expansion_root =\n-                if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let res = match self.cx.resolver.resolve_macro_invocation(\n-                &invoc,\n-                eager_expansion_root,\n-                force,\n-            ) {\n-                Ok(res) => res,\n-                Err(Indeterminate) => {\n-                    undetermined_invocations.push(invoc);\n-                    continue;\n+            let res = match res {\n+                Some(res) => res,\n+                None => {\n+                    let eager_expansion_root = if self.monotonic {\n+                        invoc.expansion_data.id\n+                    } else {\n+                        orig_expansion_data.id\n+                    };\n+                    match self.cx.resolver.resolve_macro_invocation(\n+                        &invoc,\n+                        eager_expansion_root,\n+                        force,\n+                    ) {\n+                        Ok(res) => res,\n+                        Err(Indeterminate) => {\n+                            // Cannot resolve, will retry this invocation later.\n+                            undetermined_invocations.push((invoc, None));\n+                            continue;\n+                        }\n+                    }\n                 }\n             };\n \n-            progress = true;\n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = match res {\n-                InvocationRes::Single(ext) => {\n-                    let fragment = self.expand_invoc(invoc, &ext.kind);\n-                    self.collect_invocations(fragment, &[])\n-                }\n+                InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n+                    ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n+                    ExpandResult::Retry(invoc, explanation) => {\n+                        if force {\n+                            // We are stuck, stop retrying and produce a dummy fragment.\n+                            let span = invoc.span();\n+                            self.cx.span_err(span, &explanation);\n+                            let fragment = invoc.fragment_kind.dummy(span);\n+                            self.collect_invocations(fragment, &[])\n+                        } else {\n+                            // Cannot expand, will retry this invocation later.\n+                            undetermined_invocations\n+                                .push((invoc, Some(InvocationRes::Single(ext))));\n+                            continue;\n+                        }\n+                    }\n+                },\n                 InvocationRes::DeriveContainer(_exts) => {\n                     // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n                     // instead of enqueuing the derives to be resolved again later.\n@@ -463,21 +484,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     for path in derives {\n                         let expn_id = ExpnId::fresh(None);\n                         derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                        invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { path, item: item.clone() },\n-                            fragment_kind: invoc.fragment_kind,\n-                            expansion_data: ExpansionData {\n-                                id: expn_id,\n-                                ..invoc.expansion_data.clone()\n+                        invocations.push((\n+                            Invocation {\n+                                kind: InvocationKind::Derive { path, item: item.clone() },\n+                                fragment_kind: invoc.fragment_kind,\n+                                expansion_data: ExpansionData {\n+                                    id: expn_id,\n+                                    ..invoc.expansion_data.clone()\n+                                },\n                             },\n-                        });\n+                            None,\n+                        ));\n                     }\n                     let fragment =\n                         invoc.fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n             };\n \n+            progress = true;\n             if expanded_fragments.len() < depth {\n                 expanded_fragments.push(Vec::new());\n             }\n@@ -535,7 +560,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         mut fragment: AstFragment,\n         extra_placeholders: &[NodeId],\n-    ) -> (AstFragment, Vec<Invocation>) {\n+    ) -> (AstFragment, Vec<(Invocation, Option<InvocationRes>)>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n \n@@ -635,13 +660,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.trace_macros_diag();\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+    fn expand_invoc(\n+        &mut self,\n+        invoc: Invocation,\n+        ext: &SyntaxExtensionKind,\n+    ) -> ExpandResult<AstFragment, Invocation> {\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             self.error_recursion_limit_reached();\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n-        match invoc.kind {\n+        ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n@@ -663,7 +692,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Attr { attr, mut item, .. } => match ext {\n+            InvocationKind::Attr { attr, mut item, derives, after_derive } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n@@ -679,8 +708,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(self.cx.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let item = expander.expand(self.cx, span, &meta, item);\n-                            fragment_kind.expect_from_annotatables(item)\n+                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                                ExpandResult::Ready(items) => items,\n+                                ExpandResult::Retry(item, explanation) => {\n+                                    // Reassemble the original invocation for retrying.\n+                                    return ExpandResult::Retry(\n+                                        Invocation {\n+                                            kind: InvocationKind::Attr {\n+                                                attr,\n+                                                item,\n+                                                derives,\n+                                                after_derive,\n+                                            },\n+                                            ..invoc\n+                                        },\n+                                        explanation,\n+                                    );\n+                                }\n+                            };\n+                            fragment_kind.expect_from_annotatables(items)\n                         }\n                         Err(mut err) => {\n                             err.emit();\n@@ -702,19 +748,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if !item.derive_allowed() {\n-                        return fragment_kind.dummy(span);\n+                        return ExpandResult::Ready(fragment_kind.dummy(span));\n                     }\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n-                    let items = expander.expand(self.cx, span, &meta, item);\n+                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                        ExpandResult::Ready(items) => items,\n+                        ExpandResult::Retry(item, explanation) => {\n+                            // Reassemble the original invocation for retrying.\n+                            return ExpandResult::Retry(\n+                                Invocation {\n+                                    kind: InvocationKind::Derive { path: meta.path, item },\n+                                    ..invoc\n+                                },\n+                                explanation,\n+                            );\n+                        }\n+                    };\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n                 _ => unreachable!(),\n             },\n             InvocationKind::DeriveContainer { .. } => unreachable!(),\n-        }\n+        })\n     }\n \n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n@@ -933,7 +991,7 @@ pub fn ensure_complete_parse<'a>(\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n-    invocations: Vec<Invocation>,\n+    invocations: Vec<(Invocation, Option<InvocationRes>)>,\n     monotonic: bool,\n }\n \n@@ -955,15 +1013,18 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         };\n         let expn_id = ExpnId::fresh(expn_data);\n         let vis = kind.placeholder_visibility();\n-        self.invocations.push(Invocation {\n-            kind,\n-            fragment_kind,\n-            expansion_data: ExpansionData {\n-                id: expn_id,\n-                depth: self.cx.current_expansion.depth + 1,\n-                ..self.cx.current_expansion.clone()\n+        self.invocations.push((\n+            Invocation {\n+                kind,\n+                fragment_kind,\n+                expansion_data: ExpansionData {\n+                    id: expn_id,\n+                    depth: self.cx.current_expansion.depth + 1,\n+                    ..self.cx.current_expansion.clone()\n+                },\n             },\n-        });\n+            None,\n+        ));\n         placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id), vis)\n     }\n "}, {"sha": "cb9afa4cd4f0287c324cc0129d9476e66873c233", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -79,7 +79,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let item = match item {\n             Annotatable::Arm(..)\n             | Annotatable::Field(..)\n@@ -99,7 +99,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         };\n         match item.kind {\n@@ -110,7 +110,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         }\n \n@@ -158,7 +158,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             FatalError.raise();\n         }\n \n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}, {"sha": "eaebdd9fb95a25f77f299cafc586ca463c415905", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -85,19 +85,13 @@ impl AttributeGate {\n \n /// A template that the attribute input must match.\n /// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Default)]\n pub struct AttributeTemplate {\n     pub word: bool,\n     pub list: Option<&'static str>,\n     pub name_value_str: Option<&'static str>,\n }\n \n-impl AttributeTemplate {\n-    pub fn only_word() -> Self {\n-        Self { word: true, list: None, name_value_str: None }\n-    }\n-}\n-\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`."}, {"sha": "4949c93d45eede1a5fc50469f826c6feda2eb31c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1032,10 +1032,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             let ty = cx.tcx.erase_regions(&t);\n             let layout = match cx.layout_of(ty) {\n                 Ok(layout) => layout,\n-                Err(ty::layout::LayoutError::Unknown(_)) => return,\n-                Err(err @ ty::layout::LayoutError::SizeOverflow(_)) => {\n-                    bug!(\"failed to get layout for `{}`: {}\", t, err);\n-                }\n+                Err(ty::layout::LayoutError::Unknown(_))\n+                | Err(ty::layout::LayoutError::SizeOverflow(_)) => return,\n             };\n             let (variants, tag) = match layout.variants {\n                 layout::Variants::Multiple {"}, {"sha": "2ac461a0eb264dc6cf323346fd10ceafb5efd56a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -124,7 +124,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post: &str,\n             plural_len: usize,\n         ) -> bool {\n-            if ty.is_unit() || cx.tcx.is_ty_uninhabited_from(cx.tcx.parent_module(expr.hir_id), ty)\n+            if ty.is_unit()\n+                || cx.tcx.is_ty_uninhabited_from(\n+                    cx.tcx.parent_module(expr.hir_id),\n+                    ty,\n+                    cx.param_env,\n+                )\n             {\n                 return true;\n             }"}, {"sha": "aea4f5f1b3ac90d099332e0a9b4944cbf352d7db", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -209,7 +209,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     i == variant_index || {\n                         self.hir.tcx().features().exhaustive_patterns\n                             && !v\n-                                .uninhabited_from(self.hir.tcx(), substs, adt_def.adt_kind())\n+                                .uninhabited_from(\n+                                    self.hir.tcx(),\n+                                    substs,\n+                                    adt_def.adt_kind(),\n+                                    self.hir.param_env,\n+                                )\n                                 .is_empty()\n                     }\n                 }) && (adt_def.did.is_local()"}, {"sha": "486dd3579d293d8f3807973874b4d94c076385c5", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.features().exhaustive_patterns {\n-            self.tcx.is_ty_uninhabited_from(self.module, ty)\n+            self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)\n         } else {\n             false\n         }\n@@ -1267,7 +1267,7 @@ fn all_constructors<'a, 'tcx>(\n                 def.variants\n                     .iter()\n                     .filter(|v| {\n-                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n                             .contains(cx.tcx, cx.module)\n                     })\n                     .map(|v| Variant(v.def_id))"}, {"sha": "d7208a00e0938e31cfbc883615f28984e0746b1f", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -398,7 +398,7 @@ fn visit_fn<'tcx>(\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, body_id);\n+    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n@@ -658,6 +658,7 @@ const ACC_USE: u32 = 4;\n struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     rwu_table: RWUTable,\n@@ -670,7 +671,7 @@ struct Liveness<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'tcx>, def_id: DefId) -> Liveness<'a, 'tcx> {\n         // Special nodes and variables:\n         // - exit_ln represents the end of the fn, either by return or panic\n         // - implicit_ret_var is a pseudo-variable that represents\n@@ -681,14 +682,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             clean_exit_var: ir.add_variable(CleanExit),\n         };\n \n-        let tables = ir.tcx.body_tables(body);\n+        let tables = ir.tcx.typeck_tables_of(def_id);\n+        let param_env = ir.tcx.param_env(def_id);\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n \n         Liveness {\n             ir,\n             tables,\n+            param_env,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n@@ -1126,7 +1129,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Call(ref f, ref args) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id);\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n+                    m,\n+                    self.tables.expr_ty(expr),\n+                    self.param_env,\n+                ) {\n                     self.s.exit_ln\n                 } else {\n                     succ\n@@ -1137,7 +1144,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id);\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n+                    m,\n+                    self.tables.expr_ty(expr),\n+                    self.param_env,\n+                ) {\n                     self.s.exit_ln\n                 } else {\n                     succ"}, {"sha": "7571dabcf7ef4bcf65dca6aa2ab1adf7444d3d51", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,4 +1,5 @@\n use std::cmp::Reverse;\n+use std::ptr;\n \n use log::debug;\n use rustc::bug;\n@@ -918,50 +919,81 @@ impl<'a> Resolver<'a> {\n         err.emit();\n     }\n \n-    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n-        let PrivacyError { ident, binding, .. } = *privacy_error;\n-        let session = &self.session;\n-        let mk_struct_span_error = |is_constructor| {\n-            let mut descr = binding.res().descr().to_string();\n-            if is_constructor {\n-                descr += \" constructor\";\n-            }\n-            if binding.is_import() {\n-                descr += \" import\";\n-            }\n-\n-            let mut err =\n-                struct_span_err!(session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n-\n-            err.span_label(ident.span, &format!(\"this {} is private\", descr));\n-            err.span_note(\n-                session.source_map().def_span(binding.span),\n-                &format!(\"the {} `{}` is defined here\", descr, ident),\n-            );\n-\n-            err\n-        };\n-\n-        let mut err = if let NameBindingKind::Res(\n+    /// If the binding refers to a tuple struct constructor with fields,\n+    /// returns the span of its fields.\n+    fn ctor_fields_span(&self, binding: &NameBinding<'_>) -> Option<Span> {\n+        if let NameBindingKind::Res(\n             Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n             _,\n         ) = binding.kind\n         {\n             let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n             if let Some(fields) = self.field_names.get(&def_id) {\n-                let mut err = mk_struct_span_error(true);\n                 let first_field = fields.first().expect(\"empty field list in the map\");\n-                err.span_label(\n-                    fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n-                    \"a constructor is private if any of the fields is private\",\n-                );\n-                err\n-            } else {\n-                mk_struct_span_error(false)\n+                return Some(fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)));\n             }\n-        } else {\n-            mk_struct_span_error(false)\n-        };\n+        }\n+        None\n+    }\n+\n+    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+        let PrivacyError { ident, binding, .. } = *privacy_error;\n+\n+        let res = binding.res();\n+        let ctor_fields_span = self.ctor_fields_span(binding);\n+        let plain_descr = res.descr().to_string();\n+        let nonimport_descr =\n+            if ctor_fields_span.is_some() { plain_descr + \" constructor\" } else { plain_descr };\n+        let import_descr = nonimport_descr.clone() + \" import\";\n+        let get_descr =\n+            |b: &NameBinding<'_>| if b.is_import() { &import_descr } else { &nonimport_descr };\n+\n+        // Print the primary message.\n+        let descr = get_descr(binding);\n+        let mut err =\n+            struct_span_err!(self.session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+        err.span_label(ident.span, &format!(\"this {} is private\", descr));\n+        if let Some(span) = ctor_fields_span {\n+            err.span_label(span, \"a constructor is private if any of the fields is private\");\n+        }\n+\n+        // Print the whole import chain to make it easier to see what happens.\n+        let first_binding = binding;\n+        let mut next_binding = Some(binding);\n+        let mut next_ident = ident;\n+        while let Some(binding) = next_binding {\n+            let name = next_ident;\n+            next_binding = match binding.kind {\n+                _ if res == Res::Err => None,\n+                NameBindingKind::Import { binding, import, .. } => match import.kind {\n+                    _ if binding.span.is_dummy() => None,\n+                    ImportKind::Single { source, .. } => {\n+                        next_ident = source;\n+                        Some(binding)\n+                    }\n+                    ImportKind::Glob { .. } | ImportKind::MacroUse => Some(binding),\n+                    ImportKind::ExternCrate { .. } => None,\n+                },\n+                _ => None,\n+            };\n+\n+            let first = ptr::eq(binding, first_binding);\n+            let descr = get_descr(binding);\n+            let msg = format!(\n+                \"{and_refers_to}the {item} `{name}`{which} is defined here{dots}\",\n+                and_refers_to = if first { \"\" } else { \"...and refers to \" },\n+                item = descr,\n+                name = name,\n+                which = if first { \"\" } else { \" which\" },\n+                dots = if next_binding.is_some() { \"...\" } else { \"\" },\n+            );\n+            let def_span = self.session.source_map().def_span(binding.span);\n+            let mut note_span = MultiSpan::from_span(def_span);\n+            if !first && binding.vis == ty::Visibility::Public {\n+                note_span.push_span_label(def_span, \"consider importing it directly\".into());\n+            }\n+            err.span_note(note_span, &msg);\n+        }\n \n         err.emit();\n     }"}, {"sha": "1ad4fb78e0820e8dd89adc2b1da8d88cc985e783", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -2188,11 +2188,8 @@ impl<'a> Resolver<'a> {\n                                     Applicability::MaybeIncorrect,\n                                 )),\n                             )\n-                        } else if !ident.is_reserved() {\n-                            (format!(\"maybe a missing crate `{}`?\", ident), None)\n                         } else {\n-                            // the parser will already have complained about the keyword being used\n-                            return PathResult::NonModule(PartialRes::new(Res::Err));\n+                            (format!(\"maybe a missing crate `{}`?\", ident), None)\n                         }\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)"}, {"sha": "6c2a9cd8b10d99c4f1a5157b491284937d26312d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -345,6 +345,42 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn add_derive_copy(&mut self, expn_id: ExpnId) {\n         self.containers_deriving_copy.insert(expn_id);\n     }\n+\n+    // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n+    // Returns true if the path can certainly be resolved in one of three namespaces,\n+    // returns false if the path certainly cannot be resolved in any of the three namespaces.\n+    // Returns `Indeterminate` if we cannot give a certain answer yet.\n+    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate> {\n+        let span = path.span;\n+        let path = &Segment::from_path(path);\n+        let parent_scope = self.invocation_parent_scopes[&expn_id];\n+\n+        let mut indeterminate = false;\n+        for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n+            match self.resolve_path(path, Some(ns), &parent_scope, false, span, CrateLint::No) {\n+                PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n+                PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                    return Ok(true);\n+                }\n+                PathResult::Indeterminate => indeterminate = true,\n+                // FIXME: `resolve_path` is not ready to report partially resolved paths\n+                // correctly, so we just report an error if the path was reported as unresolved.\n+                // This needs to be fixed for `cfg_accessible` to be useful.\n+                PathResult::NonModule(..) | PathResult::Failed { .. } => {}\n+                PathResult::Module(_) => panic!(\"unexpected path resolution\"),\n+            }\n+        }\n+\n+        if indeterminate {\n+            return Err(Indeterminate);\n+        }\n+\n+        self.session\n+            .struct_span_err(span, \"not sure whether the path is accessible or not\")\n+            .span_note(span, \"`cfg_accessible` is not fully implemented\")\n+            .emit();\n+        Ok(false)\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "f349f88b8942880a75948a5eca7b6dbea98351c9", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -182,6 +182,7 @@ symbols! {\n         caller_location,\n         cdylib,\n         cfg,\n+        cfg_accessible,\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,"}, {"sha": "c1ca6771326cb73ed89725363cec789b9fcbe73f", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -41,10 +41,7 @@ impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n         let _guard = unsafe { set_task_context(cx) };\n-        match gen.resume(\n-            #[cfg(not(bootstrap))]\n-            (),\n-        ) {\n+        match gen.resume(()) {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         }"}, {"sha": "1f122b02b6a29b1398c4df5b301f615256db5894", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -240,6 +240,7 @@\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n+#![cfg_attr(not(bootstrap), feature(cfg_accessible))]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]"}, {"sha": "6712f5ba5808c4f14c361a34021cf92d8c33adf3", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -53,6 +53,15 @@ pub use core::prelude::v1::{\n     PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n };\n \n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_accessible\",\n+    issue = \"64797\",\n+    reason = \"`cfg_accessible` is not fully implemented\"\n+)]\n+#[doc(hidden)]\n+pub use core::prelude::v1::cfg_accessible;\n+\n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports"}, {"sha": "498950e68210148756370bf56965385560c2a32e", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -599,24 +599,16 @@ impl Wtf8 {\n \n     #[inline]\n     fn final_lead_surrogate(&self) -> Option<u16> {\n-        let len = self.len();\n-        if len < 3 {\n-            return None;\n-        }\n-        match self.bytes[(len - 3)..] {\n-            [0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),\n+        match self.bytes {\n+            [.., 0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),\n             _ => None,\n         }\n     }\n \n     #[inline]\n     fn initial_trail_surrogate(&self) -> Option<u16> {\n-        let len = self.len();\n-        if len < 3 {\n-            return None;\n-        }\n-        match self.bytes[..3] {\n-            [0xED, b2 @ 0xB0..=0xBF, b3] => Some(decode_surrogate(b2, b3)),\n+        match self.bytes {\n+            [0xED, b2 @ 0xB0..=0xBF, b3, ..] => Some(decode_surrogate(b2, b3)),\n             _ => None,\n         }\n     }"}, {"sha": "4d9a91e38b33c5b551e5585c3342638991b9aecc", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2020-02-29\n+date: 2020-03-12\n rustc: beta\n cargo: beta\n "}, {"sha": "4bd8efeaa3b97514c6573170bbb7540b6c09c4f5", "filename": "src/test/rustdoc-ui/issue-61732.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-61732.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,4 +1,4 @@\n // This previously triggered an ICE.\n \n pub(in crate::r#mod) fn main() {}\n-//~^ ERROR expected module, found unresolved item\n+//~^ ERROR failed to resolve: maybe a missing crate `r#mod`"}, {"sha": "8213422491120fd6b410ea2121f0be8a99bf1ff3", "filename": "src/test/rustdoc-ui/issue-61732.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,11 +1,11 @@\n-error[E0577]: expected module, found unresolved item `crate::r#mod`\n-  --> $DIR/issue-61732.rs:3:8\n+error[E0433]: failed to resolve: maybe a missing crate `r#mod`?\n+  --> $DIR/issue-61732.rs:3:15\n    |\n LL | pub(in crate::r#mod) fn main() {}\n-   |        ^^^^^^^^^^^^ not a module\n+   |               ^^^^^ maybe a missing crate `r#mod`?\n \n error: Compilation failed, aborting rustdoc\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0577`.\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "c51c908a4262e2cd49d6b32a8ef7fef9704c72aa", "filename": "src/test/ui/conditional-compilation/cfg_accessible-input-validation.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,24 @@\n+#![feature(cfg_accessible)]\n+\n+#[cfg_accessible] //~ ERROR malformed `cfg_accessible` attribute input\n+struct S1;\n+\n+#[cfg_accessible = \"value\"] //~ ERROR malformed `cfg_accessible` attribute input\n+struct S2;\n+\n+#[cfg_accessible()] //~ ERROR `cfg_accessible` path is not specified\n+struct S3;\n+\n+#[cfg_accessible(std, core)] //~ ERROR multiple `cfg_accessible` paths are specified\n+struct S4;\n+\n+#[cfg_accessible(\"std\")] //~ ERROR `cfg_accessible` path cannot be a literal\n+struct S5;\n+\n+#[cfg_accessible(std = \"value\")] //~ ERROR `cfg_accessible` path cannot accept arguments\n+struct S6;\n+\n+#[cfg_accessible(std(value))] //~ ERROR `cfg_accessible` path cannot accept arguments\n+struct S7;\n+\n+fn main() {}"}, {"sha": "86706c766356ea651094422e992e72abaf14bd72", "filename": "src/test/ui/conditional-compilation/cfg_accessible-input-validation.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,44 @@\n+error: malformed `cfg_accessible` attribute input\n+  --> $DIR/cfg_accessible-input-validation.rs:3:1\n+   |\n+LL | #[cfg_accessible]\n+   | ^^^^^^^^^^^^^^^^^ help: must be of the form: `#[cfg_accessible(path)]`\n+\n+error: malformed `cfg_accessible` attribute input\n+  --> $DIR/cfg_accessible-input-validation.rs:6:1\n+   |\n+LL | #[cfg_accessible = \"value\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[cfg_accessible(path)]`\n+\n+error: `cfg_accessible` path is not specified\n+  --> $DIR/cfg_accessible-input-validation.rs:9:1\n+   |\n+LL | #[cfg_accessible()]\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: multiple `cfg_accessible` paths are specified\n+  --> $DIR/cfg_accessible-input-validation.rs:12:23\n+   |\n+LL | #[cfg_accessible(std, core)]\n+   |                       ^^^^\n+\n+error: `cfg_accessible` path cannot be a literal\n+  --> $DIR/cfg_accessible-input-validation.rs:15:18\n+   |\n+LL | #[cfg_accessible(\"std\")]\n+   |                  ^^^^^\n+\n+error: `cfg_accessible` path cannot accept arguments\n+  --> $DIR/cfg_accessible-input-validation.rs:18:18\n+   |\n+LL | #[cfg_accessible(std = \"value\")]\n+   |                  ^^^^^^^^^^^^^\n+\n+error: `cfg_accessible` path cannot accept arguments\n+  --> $DIR/cfg_accessible-input-validation.rs:21:18\n+   |\n+LL | #[cfg_accessible(std(value))]\n+   |                  ^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "8bc93fa324378391446dee53883b51c7e4b39ecc", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,9 @@\n+#![feature(cfg_accessible)]\n+\n+#[cfg_accessible(Z)] //~ ERROR cannot determine whether the path is accessible or not\n+struct S;\n+\n+#[cfg_accessible(S)] //~ ERROR cannot determine whether the path is accessible or not\n+struct Z;\n+\n+fn main() {}"}, {"sha": "9641441a819b0cb0d2d38ff35d80698a5bb7e15e", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,14 @@\n+error: cannot determine whether the path is accessible or not\n+  --> $DIR/cfg_accessible-stuck.rs:6:1\n+   |\n+LL | #[cfg_accessible(S)]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot determine whether the path is accessible or not\n+  --> $DIR/cfg_accessible-stuck.rs:3:1\n+   |\n+LL | #[cfg_accessible(Z)]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e9247e67a2a26638675fa241f5f169604e879faa", "filename": "src/test/ui/conditional-compilation/cfg_accessible-unstable.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,2 @@\n+#[cfg_accessible(std)] //~ ERROR use of unstable library feature 'cfg_accessible'\n+fn main() {}"}, {"sha": "2f55b9559c78fdefa3dbe2da6db01e1cd1bbb7af", "filename": "src/test/ui/conditional-compilation/cfg_accessible-unstable.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: use of unstable library feature 'cfg_accessible': `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible-unstable.rs:1:3\n+   |\n+LL | #[cfg_accessible(std)]\n+   |   ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #64797 <https://github.com/rust-lang/rust/issues/64797> for more information\n+   = help: add `#![feature(cfg_accessible)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "07b0be5b1ae2606e37576b693db30c9ad125f09a", "filename": "src/test/ui/conditional-compilation/cfg_accessible.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,43 @@\n+#![feature(cfg_accessible)]\n+\n+mod m {\n+    pub struct ExistingPublic;\n+    struct ExistingPrivate;\n+}\n+\n+#[cfg_accessible(m::ExistingPublic)]\n+struct ExistingPublic;\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(m::ExistingPrivate)] //~ ERROR not sure whether the path is accessible or not\n+struct ExistingPrivate;\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(m::NonExistent)] //~ ERROR not sure whether the path is accessible or not\n+struct ExistingPrivate;\n+\n+#[cfg_accessible(n::AccessibleExpanded)] // OK, `cfg_accessible` can wait and retry.\n+struct AccessibleExpanded;\n+\n+macro_rules! generate_accessible_expanded {\n+    () => {\n+        mod n {\n+            pub struct AccessibleExpanded;\n+        }\n+    };\n+}\n+\n+generate_accessible_expanded!();\n+\n+struct S {\n+    field: u8,\n+}\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(S::field)] //~ ERROR not sure whether the path is accessible or not\n+struct Field;\n+\n+fn main() {\n+    ExistingPublic;\n+    AccessibleExpanded;\n+}"}, {"sha": "167765cd66ee6d045cdce7d7bc23b88e7e7ea0a8", "filename": "src/test/ui/conditional-compilation/cfg_accessible.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,38 @@\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:12:18\n+   |\n+LL | #[cfg_accessible(m::ExistingPrivate)]\n+   |                  ^^^^^^^^^^^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:12:18\n+   |\n+LL | #[cfg_accessible(m::ExistingPrivate)]\n+   |                  ^^^^^^^^^^^^^^^^^^\n+\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:16:18\n+   |\n+LL | #[cfg_accessible(m::NonExistent)]\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:16:18\n+   |\n+LL | #[cfg_accessible(m::NonExistent)]\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:37:18\n+   |\n+LL | #[cfg_accessible(S::field)]\n+   |                  ^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:37:18\n+   |\n+LL | #[cfg_accessible(S::field)]\n+   |                  ^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "490c08446b5a800d8d4ec4416d09b39f88466fcd", "filename": "src/test/ui/imports/issue-55884-2.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -4,11 +4,26 @@ error[E0603]: struct import `ParseOptions` is private\n LL | pub use parser::ParseOptions;\n    |                 ^^^^^^^^^^^^ this struct import is private\n    |\n-note: the struct import `ParseOptions` is defined here\n+note: the struct import `ParseOptions` is defined here...\n   --> $DIR/issue-55884-2.rs:9:9\n    |\n LL |     use ParseOptions;\n    |         ^^^^^^^^^^^^\n+note: ...and refers to the struct import `ParseOptions` which is defined here...\n+  --> $DIR/issue-55884-2.rs:12:9\n+   |\n+LL | pub use parser::ParseOptions;\n+   |         ^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n+note: ...and refers to the struct import `ParseOptions` which is defined here...\n+  --> $DIR/issue-55884-2.rs:6:13\n+   |\n+LL |     pub use options::*;\n+   |             ^^^^^^^^^^ consider importing it directly\n+note: ...and refers to the struct `ParseOptions` which is defined here\n+  --> $DIR/issue-55884-2.rs:2:5\n+   |\n+LL |     pub struct ParseOptions {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n \n error: aborting due to previous error\n "}, {"sha": "d63fbc7ec6781d6c378f7e6e6a60d7dc31c734f9", "filename": "src/test/ui/imports/reexports.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Freexports.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -16,23 +16,33 @@ error[E0603]: module import `foo` is private\n LL |     use b::a::foo::S;\n    |               ^^^ this module import is private\n    |\n-note: the module import `foo` is defined here\n+note: the module import `foo` is defined here...\n   --> $DIR/reexports.rs:21:17\n    |\n LL |         pub use super::foo; // This is OK since the value `foo` is visible enough.\n    |                 ^^^^^^^^^^\n+note: ...and refers to the module `foo` which is defined here\n+  --> $DIR/reexports.rs:16:5\n+   |\n+LL |     mod foo {\n+   |     ^^^^^^^\n \n error[E0603]: module import `foo` is private\n   --> $DIR/reexports.rs:34:15\n    |\n LL |     use b::b::foo::S as T;\n    |               ^^^ this module import is private\n    |\n-note: the module import `foo` is defined here\n+note: the module import `foo` is defined here...\n   --> $DIR/reexports.rs:26:17\n    |\n LL |         pub use super::*; // This is also OK since the value `foo` is visible enough.\n    |                 ^^^^^^^^\n+note: ...and refers to the module `foo` which is defined here\n+  --> $DIR/reexports.rs:16:5\n+   |\n+LL |     mod foo {\n+   |     ^^^^^^^\n \n warning: glob import doesn't reexport anything because no candidate is public enough\n   --> $DIR/reexports.rs:9:17"}, {"sha": "a46ce67d40d5a709d60fbba06c2e7a3adc612286", "filename": "src/test/ui/keyword/extern/keyword-extern-as-identifier-use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,3 +1,4 @@\n use extern::foo; //~ ERROR expected identifier, found keyword `extern`\n+                 //~| ERROR unresolved import `r#extern`\n \n fn main() {}"}, {"sha": "edbb36452b6ce0139ff8239a8f962323af289e68", "filename": "src/test/ui/keyword/extern/keyword-extern-as-identifier-use.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -9,5 +9,12 @@ help: you can escape reserved keywords to use them as identifiers\n LL | use r#extern::foo;\n    |     ^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0432]: unresolved import `r#extern`\n+  --> $DIR/keyword-extern-as-identifier-use.rs:1:5\n+   |\n+LL | use extern::foo;\n+   |     ^^^^^^ maybe a missing crate `r#extern`?\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "49d489d9168379c7c372914211d81ea0574d6717", "filename": "src/test/ui/lint/issue-69485-var-size-diffs-too-large.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,10 @@\n+// build-fail\n+// only-x86_64\n+\n+fn main() {\n+    Bug::V([0; !0]); //~ ERROR is too big for the current\n+}\n+\n+enum Bug {\n+    V([u8; !0]),\n+}"}, {"sha": "d31ce9cfe0c2b88e38cfed3bbb355907bf7e7faa", "filename": "src/test/ui/lint/issue-69485-var-size-diffs-too-large.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,8 @@\n+error: the type `[u8; 18446744073709551615]` is too big for the current architecture\n+  --> $DIR/issue-69485-var-size-diffs-too-large.rs:5:12\n+   |\n+LL |     Bug::V([0; !0]);\n+   |            ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b10c3a5265971c6ce14fedcf765f92c267486dbf", "filename": "src/test/ui/privacy/privacy2.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -10,11 +10,16 @@ error[E0603]: function import `foo` is private\n LL |     use bar::glob::foo;\n    |                    ^^^ this function import is private\n    |\n-note: the function import `foo` is defined here\n+note: the function import `foo` is defined here...\n   --> $DIR/privacy2.rs:10:13\n    |\n LL |         use foo;\n    |             ^^^\n+note: ...and refers to the function `foo` which is defined here\n+  --> $DIR/privacy2.rs:14:1\n+   |\n+LL | pub fn foo() {}\n+   | ^^^^^^^^^^^^ consider importing it directly\n \n error: requires `sized` lang_item\n "}, {"sha": "1bcbef594374103c48081eb7dab0af0e6121deb6", "filename": "src/test/ui/resolve/raw-ident-in-path.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,5 @@\n+// Regression test for issue #63882.\n+\n+type A = crate::r#break; //~ ERROR cannot find type `r#break` in module `crate`\n+\n+fn main() {}"}, {"sha": "f2efcbc8e85863e7318fc33664ba908ee22ae675", "filename": "src/test/ui/resolve/raw-ident-in-path.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fraw-ident-in-path.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `r#break` in module `crate`\n+  --> $DIR/raw-ident-in-path.rs:3:17\n+   |\n+LL | type A = crate::r#break;\n+   |                 ^^^^^^^ not found in `crate`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "2244f3a46b266b3e05851f5f4da883795993863b", "filename": "src/test/ui/shadowed/shadowed-use-visibility.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -4,23 +4,33 @@ error[E0603]: module import `bar` is private\n LL |     use foo::bar::f as g;\n    |              ^^^ this module import is private\n    |\n-note: the module import `bar` is defined here\n+note: the module import `bar` is defined here...\n   --> $DIR/shadowed-use-visibility.rs:4:9\n    |\n LL |     use foo as bar;\n    |         ^^^^^^^^^^\n+note: ...and refers to the module `foo` which is defined here\n+  --> $DIR/shadowed-use-visibility.rs:1:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error[E0603]: module import `f` is private\n   --> $DIR/shadowed-use-visibility.rs:15:10\n    |\n LL | use bar::f::f;\n    |          ^ this module import is private\n    |\n-note: the module import `f` is defined here\n+note: the module import `f` is defined here...\n   --> $DIR/shadowed-use-visibility.rs:11:9\n    |\n LL |     use foo as f;\n    |         ^^^^^^^^\n+note: ...and refers to the module `foo` which is defined here\n+  --> $DIR/shadowed-use-visibility.rs:1:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}