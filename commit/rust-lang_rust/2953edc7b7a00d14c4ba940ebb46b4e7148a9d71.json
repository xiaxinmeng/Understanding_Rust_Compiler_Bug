{"sha": "2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "node_id": "C_kwDOAAsO6NoAKDI5NTNlZGM3YjdhMDBkMTRjNGJhOTQwZWJiNDZiNGU3MTQ4YTlkNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T21:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T21:40:10Z"}, "message": "Auto merge of #98475 - notriddle:notriddle/index-fn-signatures, r=GuillaumeGomez\n\nrustdoc: reference function signature types from the `p` array\n\nThis reduces the size of the function signature index, because it's common to have many functions that operate on the same types.\n\n    $ wc -c search-index-old.js search-index-new.js\n    5224374 search-index-old.js\n    3932314 search-index-new.js\n\nBy my math, this reduces the uncompressed size of the search index by 32%.\nOn compressed signatures, the wins are less drastic, a mere 8%:\n\n    $ wc -c search-index-old.js.gz search-index-new.js.gz\n    404532 search-index-old.js.gz\n    371635 search-index-new.js.gz", "tree": {"sha": "cf271f0749d00431e79bb72c88d7e20127d7964d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf271f0749d00431e79bb72c88d7e20127d7964d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "html_url": "https://github.com/rust-lang/rust/commit/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "830880640304ba8699c5f9a0c4665c38a3271963", "url": "https://api.github.com/repos/rust-lang/rust/commits/830880640304ba8699c5f9a0c4665c38a3271963", "html_url": "https://github.com/rust-lang/rust/commit/830880640304ba8699c5f9a0c4665c38a3271963"}, {"sha": "33cf9ea4a2aebb015e81071968659bd51218c5af", "url": "https://api.github.com/repos/rust-lang/rust/commits/33cf9ea4a2aebb015e81071968659bd51218c5af", "html_url": "https://github.com/rust-lang/rust/commit/33cf9ea4a2aebb015e81071968659bd51218c5af"}], "stats": {"total": 526, "additions": 380, "deletions": 146}, "files": [{"sha": "81aa8c6cf8e19053cd23b51a12e1105e4d6b8772", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -1671,10 +1671,6 @@ impl Type {\n         matches!(self, Type::ImplTrait(_))\n     }\n \n-    pub(crate) fn is_primitive(&self) -> bool {\n-        self.primitive_type().is_some()\n-    }\n-\n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath { self_type, trait_, assoc, .. } = self {\n             Some((self_type, trait_.def_id(), *assoc.clone()))"}, {"sha": "9cb3327d7c781146891b141509b12d2353aa8024", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -48,7 +48,6 @@ pub(crate) enum ItemType {\n     ProcAttribute = 23,\n     ProcDerive = 24,\n     TraitAlias = 25,\n-    Generic = 26,\n }\n \n impl Serialize for ItemType {\n@@ -175,7 +174,6 @@ impl ItemType {\n             ItemType::ProcAttribute => \"attr\",\n             ItemType::ProcDerive => \"derive\",\n             ItemType::TraitAlias => \"traitalias\",\n-            ItemType::Generic => \"generic\",\n         }\n     }\n }"}, {"sha": "1ef41d62e5eb0a1a54b49b355d3f4256842a6355", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -110,63 +110,72 @@ pub(crate) struct IndexItem {\n /// A type used for the search index.\n #[derive(Debug)]\n pub(crate) struct RenderType {\n-    name: Option<String>,\n-    generics: Option<Vec<TypeWithKind>>,\n+    id: Option<RenderTypeId>,\n+    generics: Option<Vec<RenderType>>,\n }\n \n-/// Full type of functions/methods in the search index.\n-#[derive(Debug)]\n-pub(crate) struct IndexItemFunctionType {\n-    inputs: Vec<TypeWithKind>,\n-    output: Vec<TypeWithKind>,\n-}\n-\n-impl Serialize for IndexItemFunctionType {\n+impl Serialize for RenderType {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n     where\n         S: Serializer,\n     {\n-        // If we couldn't figure out a type, just write `null`.\n-        let has_missing = self.inputs.iter().chain(self.output.iter()).any(|i| i.ty.name.is_none());\n-        if has_missing {\n-            serializer.serialize_none()\n-        } else {\n+        let id = match &self.id {\n+            // 0 is a sentinel, everything else is one-indexed\n+            None => 0,\n+            Some(RenderTypeId::Index(idx)) => idx + 1,\n+            _ => panic!(\"must convert render types to indexes before serializing\"),\n+        };\n+        if let Some(generics) = &self.generics {\n             let mut seq = serializer.serialize_seq(None)?;\n-            seq.serialize_element(&self.inputs)?;\n-            match self.output.as_slice() {\n-                [] => {}\n-                [one] => seq.serialize_element(one)?,\n-                all => seq.serialize_element(all)?,\n-            }\n+            seq.serialize_element(&id)?;\n+            seq.serialize_element(generics)?;\n             seq.end()\n+        } else {\n+            id.serialize(serializer)\n         }\n     }\n }\n \n-#[derive(Debug)]\n-pub(crate) struct TypeWithKind {\n-    ty: RenderType,\n-    kind: ItemType,\n+#[derive(Clone, Debug)]\n+pub(crate) enum RenderTypeId {\n+    DefId(DefId),\n+    Primitive(clean::PrimitiveType),\n+    Index(usize),\n }\n \n-impl From<(RenderType, ItemType)> for TypeWithKind {\n-    fn from(x: (RenderType, ItemType)) -> TypeWithKind {\n-        TypeWithKind { ty: x.0, kind: x.1 }\n-    }\n+/// Full type of functions/methods in the search index.\n+#[derive(Debug)]\n+pub(crate) struct IndexItemFunctionType {\n+    inputs: Vec<RenderType>,\n+    output: Vec<RenderType>,\n }\n \n-impl Serialize for TypeWithKind {\n+impl Serialize for IndexItemFunctionType {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n     where\n         S: Serializer,\n     {\n-        let mut seq = serializer.serialize_seq(None)?;\n-        seq.serialize_element(&self.ty.name)?;\n-        seq.serialize_element(&self.kind)?;\n-        if let Some(generics) = &self.ty.generics {\n-            seq.serialize_element(generics)?;\n+        // If we couldn't figure out a type, just write `0`.\n+        let has_missing = self\n+            .inputs\n+            .iter()\n+            .chain(self.output.iter())\n+            .any(|i| i.id.is_none() && i.generics.is_none());\n+        if has_missing {\n+            0.serialize(serializer)\n+        } else {\n+            let mut seq = serializer.serialize_seq(None)?;\n+            match &self.inputs[..] {\n+                [one] if one.generics.is_none() => seq.serialize_element(one)?,\n+                _ => seq.serialize_element(&self.inputs)?,\n+            }\n+            match &self.output[..] {\n+                [] => {}\n+                [one] if one.generics.is_none() => seq.serialize_element(one)?,\n+                _ => seq.serialize_element(&self.output)?,\n+            }\n+            seq.end()\n         }\n-        seq.end()\n     }\n }\n \n@@ -2517,7 +2526,6 @@ fn item_ty_to_section(ty: ItemType) -> ItemSection {\n         ItemType::ProcAttribute => ItemSection::AttributeMacros,\n         ItemType::ProcDerive => ItemSection::DeriveMacros,\n         ItemType::TraitAlias => ItemSection::TraitAliases,\n-        ItemType::Generic => unreachable!(),\n     }\n }\n "}, {"sha": "d672f0bb5992b8017d941d7424ee1a7fd635ce77", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 148, "deletions": 67, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -3,24 +3,27 @@ use std::collections::BTreeMap;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::def_id::LOCAL_CRATE;\n+use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n+use crate::clean::types::{\n+    FnRetTy, Function, GenericBound, Generics, ItemId, Type, WherePredicate,\n+};\n use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n-use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n+use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, RenderTypeId};\n \n /// Builds the search index from the collected metadata\n pub(crate) fn build_index<'tcx>(\n     krate: &clean::Crate,\n     cache: &mut Cache,\n     tcx: TyCtxt<'tcx>,\n ) -> String {\n-    let mut defid_to_pathid = FxHashMap::default();\n+    let mut itemid_to_pathid = FxHashMap::default();\n     let mut crate_paths = vec![];\n \n     // Attach all orphan items to the type's definition if the type\n@@ -48,22 +51,20 @@ pub(crate) fn build_index<'tcx>(\n         .doc_value()\n         .map_or_else(String::new, |s| short_markdown_summary(&s, &krate.module.link_names(cache)));\n \n-    let Cache { ref mut search_index, ref paths, .. } = *cache;\n-\n     // Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     // we need the alias element to have an array of items.\n     let mut aliases: BTreeMap<String, Vec<usize>> = BTreeMap::new();\n \n     // Sort search index items. This improves the compressibility of the search index.\n-    search_index.sort_unstable_by(|k1, k2| {\n+    cache.search_index.sort_unstable_by(|k1, k2| {\n         // `sort_unstable_by_key` produces lifetime errors\n         let k1 = (&k1.path, &k1.name, &k1.ty, &k1.parent);\n         let k2 = (&k2.path, &k2.name, &k2.ty, &k2.parent);\n         std::cmp::Ord::cmp(&k1, &k2)\n     });\n \n     // Set up alias indexes.\n-    for (i, item) in search_index.iter().enumerate() {\n+    for (i, item) in cache.search_index.iter().enumerate() {\n         for alias in &item.aliases[..] {\n             aliases.entry(alias.as_str().to_lowercase()).or_default().push(i);\n         }\n@@ -74,24 +75,99 @@ pub(crate) fn build_index<'tcx>(\n     let mut lastpath = \"\";\n     let mut lastpathid = 0usize;\n \n+    // First, on function signatures\n+    let mut search_index = std::mem::replace(&mut cache.search_index, Vec::new());\n+    for item in search_index.iter_mut() {\n+        fn convert_render_type(\n+            ty: &mut RenderType,\n+            cache: &mut Cache,\n+            itemid_to_pathid: &mut FxHashMap<ItemId, usize>,\n+            lastpathid: &mut usize,\n+            crate_paths: &mut Vec<(ItemType, Symbol)>,\n+        ) {\n+            if let Some(generics) = &mut ty.generics {\n+                for item in generics {\n+                    convert_render_type(item, cache, itemid_to_pathid, lastpathid, crate_paths);\n+                }\n+            }\n+            let Cache { ref paths, ref external_paths, .. } = *cache;\n+            let Some(id) = ty.id.clone() else {\n+                assert!(ty.generics.is_some());\n+                return;\n+            };\n+            let (itemid, path, item_type) = match id {\n+                RenderTypeId::DefId(defid) => {\n+                    if let Some(&(ref fqp, item_type)) =\n+                        paths.get(&defid).or_else(|| external_paths.get(&defid))\n+                    {\n+                        (ItemId::DefId(defid), *fqp.last().unwrap(), item_type)\n+                    } else {\n+                        ty.id = None;\n+                        return;\n+                    }\n+                }\n+                RenderTypeId::Primitive(primitive) => (\n+                    ItemId::Primitive(primitive, LOCAL_CRATE),\n+                    primitive.as_sym(),\n+                    ItemType::Primitive,\n+                ),\n+                RenderTypeId::Index(_) => return,\n+            };\n+            match itemid_to_pathid.entry(itemid) {\n+                Entry::Occupied(entry) => ty.id = Some(RenderTypeId::Index(*entry.get())),\n+                Entry::Vacant(entry) => {\n+                    let pathid = *lastpathid;\n+                    entry.insert(pathid);\n+                    *lastpathid += 1;\n+                    crate_paths.push((item_type, path));\n+                    ty.id = Some(RenderTypeId::Index(pathid));\n+                }\n+            }\n+        }\n+        if let Some(search_type) = &mut item.search_type {\n+            for item in &mut search_type.inputs {\n+                convert_render_type(\n+                    item,\n+                    cache,\n+                    &mut itemid_to_pathid,\n+                    &mut lastpathid,\n+                    &mut crate_paths,\n+                );\n+            }\n+            for item in &mut search_type.output {\n+                convert_render_type(\n+                    item,\n+                    cache,\n+                    &mut itemid_to_pathid,\n+                    &mut lastpathid,\n+                    &mut crate_paths,\n+                );\n+            }\n+        }\n+    }\n+\n+    let Cache { ref paths, .. } = *cache;\n+\n+    // Then, on parent modules\n     let crate_items: Vec<&IndexItem> = search_index\n         .iter_mut()\n         .map(|item| {\n-            item.parent_idx = item.parent.and_then(|defid| match defid_to_pathid.entry(defid) {\n-                Entry::Occupied(entry) => Some(*entry.get()),\n-                Entry::Vacant(entry) => {\n-                    let pathid = lastpathid;\n-                    entry.insert(pathid);\n-                    lastpathid += 1;\n+            item.parent_idx =\n+                item.parent.and_then(|defid| match itemid_to_pathid.entry(ItemId::DefId(defid)) {\n+                    Entry::Occupied(entry) => Some(*entry.get()),\n+                    Entry::Vacant(entry) => {\n+                        let pathid = lastpathid;\n+                        entry.insert(pathid);\n+                        lastpathid += 1;\n \n-                    if let Some(&(ref fqp, short)) = paths.get(&defid) {\n-                        crate_paths.push((short, *fqp.last().unwrap()));\n-                        Some(pathid)\n-                    } else {\n-                        None\n+                        if let Some(&(ref fqp, short)) = paths.get(&defid) {\n+                            crate_paths.push((short, *fqp.last().unwrap()));\n+                            Some(pathid)\n+                        } else {\n+                            None\n+                        }\n                     }\n-                }\n-            });\n+                });\n \n             // Omit the parent path if it is same to that of the prior item.\n             if lastpath == &item.path {\n@@ -151,13 +227,40 @@ pub(crate) fn build_index<'tcx>(\n                             \"`{}` is missing idx\",\n                             item.name\n                         );\n+                        // 0 is a sentinel, everything else is one-indexed\n                         item.parent_idx.map(|x| x + 1).unwrap_or(0)\n                     })\n                     .collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"f\",\n-                &self.items.iter().map(|item| &item.search_type).collect::<Vec<_>>(),\n+                &self\n+                    .items\n+                    .iter()\n+                    .map(|item| {\n+                        // Fake option to get `0` out as a sentinel instead of `null`.\n+                        // We want to use `0` because it's three less bytes.\n+                        enum FunctionOption<'a> {\n+                            Function(&'a IndexItemFunctionType),\n+                            None,\n+                        }\n+                        impl<'a> Serialize for FunctionOption<'a> {\n+                            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+                            where\n+                                S: Serializer,\n+                            {\n+                                match self {\n+                                    FunctionOption::None => 0.serialize(serializer),\n+                                    FunctionOption::Function(ty) => ty.serialize(serializer),\n+                                }\n+                            }\n+                        }\n+                        match &item.search_type {\n+                            Some(ty) => FunctionOption::Function(ty),\n+                            None => FunctionOption::None,\n+                        }\n+                    })\n+                    .collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"p\",\n@@ -202,36 +305,33 @@ pub(crate) fn get_function_type_for_search<'tcx>(\n         _ => return None,\n     };\n \n-    inputs.retain(|a| a.ty.name.is_some());\n-    output.retain(|a| a.ty.name.is_some());\n+    inputs.retain(|a| a.id.is_some() || a.generics.is_some());\n+    output.retain(|a| a.id.is_some() || a.generics.is_some());\n \n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type, generics: Vec<TypeWithKind>) -> RenderType {\n+fn get_index_type(clean_type: &clean::Type, generics: Vec<RenderType>) -> RenderType {\n     RenderType {\n-        name: get_index_type_name(clean_type).map(|s| s.as_str().to_ascii_lowercase()),\n+        id: get_index_type_id(clean_type),\n         generics: if generics.is_empty() { None } else { Some(generics) },\n     }\n }\n \n-fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n+fn get_index_type_id(clean_type: &clean::Type) -> Option<RenderTypeId> {\n     match *clean_type {\n-        clean::Type::Path { ref path, .. } => {\n-            let path_segment = path.segments.last().unwrap();\n-            Some(path_segment.name)\n-        }\n+        clean::Type::Path { ref path, .. } => Some(RenderTypeId::DefId(path.def_id())),\n         clean::DynTrait(ref bounds, _) => {\n             let path = &bounds[0].trait_;\n-            Some(path.segments.last().unwrap().name)\n+            Some(RenderTypeId::DefId(path.def_id()))\n         }\n-        // We return an empty name because we don't care about the generic name itself.\n-        clean::Generic(_) | clean::ImplTrait(_) => Some(kw::Empty),\n-        clean::Primitive(ref p) => Some(p.as_sym()),\n+        clean::Primitive(p) => Some(RenderTypeId::Primitive(p)),\n         clean::BorrowedRef { ref type_, .. } | clean::RawPointer(_, ref type_) => {\n-            get_index_type_name(type_)\n+            get_index_type_id(type_)\n         }\n         clean::BareFunction(_)\n+        | clean::Generic(_)\n+        | clean::ImplTrait(_)\n         | clean::Tuple(_)\n         | clean::Slice(_)\n         | clean::Array(_, _)\n@@ -254,16 +354,10 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n     arg: &'a Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n-    res: &mut Vec<TypeWithKind>,\n+    res: &mut Vec<RenderType>,\n     cache: &Cache,\n ) {\n-    fn insert_ty(\n-        res: &mut Vec<TypeWithKind>,\n-        tcx: TyCtxt<'_>,\n-        ty: Type,\n-        mut generics: Vec<TypeWithKind>,\n-        cache: &Cache,\n-    ) {\n+    fn insert_ty(res: &mut Vec<RenderType>, ty: Type, mut generics: Vec<RenderType>) {\n         // generics and impl trait are both identified by their generics,\n         // rather than a type name itself\n         let anonymous = ty.is_full_generic() || ty.is_impl_trait();\n@@ -316,20 +410,11 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n                 return;\n             }\n         }\n-        let mut index_ty = get_index_type(&ty, generics);\n-        if index_ty.name.as_ref().map(|s| s.is_empty() && generics_empty).unwrap_or(true) {\n+        let index_ty = get_index_type(&ty, generics);\n+        if index_ty.id.is_none() && generics_empty {\n             return;\n         }\n-        if anonymous {\n-            // We remove the name of the full generic because we have no use for it.\n-            index_ty.name = Some(String::new());\n-            res.push(TypeWithKind::from((index_ty, ItemType::Generic)));\n-        } else if let Some(kind) = ty.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n-            res.push(TypeWithKind::from((index_ty, kind)));\n-        } else if ty.is_primitive() {\n-            // This is a primitive, let's store it as such.\n-            res.push(TypeWithKind::from((index_ty, ItemType::Primitive)));\n-        }\n+        res.push(index_ty);\n     }\n \n     if recurse >= 10 {\n@@ -379,7 +464,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, arg.clone(), ty_generics);\n         }\n         // Otherwise we check if the trait bounds are \"inlined\" like `T: Option<u32>`...\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n@@ -398,7 +483,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n                     );\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, arg.clone(), ty_generics);\n         }\n     } else if let Type::ImplTrait(ref bounds) = *arg {\n         let mut ty_generics = Vec::new();\n@@ -416,7 +501,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n                 );\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+        insert_ty(res, arg.clone(), ty_generics);\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n         // looking at `Option`, we enter this \"else\" condition, otherwise if it's `T`, we don't.\n@@ -437,7 +522,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n                 );\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+        insert_ty(res, arg.clone(), ty_generics);\n     }\n }\n \n@@ -450,7 +535,7 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_generics: Option<&(clean::Type, clean::Generics)>,\n     cache: &Cache,\n-) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n+) -> (Vec<RenderType>, Vec<RenderType>) {\n     let decl = &func.decl;\n \n     let combined_generics;\n@@ -478,9 +563,7 @@ fn get_fn_inputs_and_outputs<'tcx>(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) = arg.type_.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n-                all_types.push(TypeWithKind::from((get_index_type(&arg.type_, vec![]), kind)));\n-            }\n+            all_types.push(get_index_type(&arg.type_, vec![]));\n         }\n     }\n \n@@ -497,9 +580,7 @@ fn get_fn_inputs_and_outputs<'tcx>(\n                 cache,\n             );\n             if ret_types.is_empty() {\n-                if let Some(kind) = return_type.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n-                    ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));\n-                }\n+                ret_types.push(get_index_type(return_type, vec![]));\n             }\n         }\n         _ => {}"}, {"sha": "ecbe15a59da3c6ff518d110d58f76dabad8f4d12", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -81,3 +81,62 @@ let ResultsTable;\n  * }}\n  */\n let Results;\n+\n+/**\n+ * A pair of [inputs, outputs], or 0 for null. This is stored in the search index.\n+ * The JavaScript deserializes this into FunctionSearchType.\n+ *\n+ * Numeric IDs are *ONE-indexed* into the paths array (`p`). Zero is used as a sentinel for `null`\n+ * because `null` is four bytes while `0` is one byte.\n+ *\n+ * An input or output can be encoded as just a number if there is only one of them, AND\n+ * it has no generics. The no generics rule exists to avoid ambiguity: imagine if you had\n+ * a function with a single output, and that output had a single generic:\n+ *\n+ *     fn something() -> Result<usize, usize>\n+ *\n+ * If output was allowed to be any RawFunctionType, it would look like this\n+ *\n+ *     [[], [50, [3, 3]]]\n+ *\n+ * The problem is that the above output could be interpreted as either a type with ID 50 and two\n+ * generics, or it could be interpreted as a pair of types, the first one with ID 50 and the second\n+ * with ID 3 and a single generic parameter that is also ID 3. We avoid this ambiguity by choosing\n+ * in favor of the pair of types interpretation. This is why the `(number|Array<RawFunctionType>)`\n+ * is used instead of `(RawFunctionType|Array<RawFunctionType>)`.\n+ *\n+ * @typedef {(\n+ *     0 |\n+ *     [(number|Array<RawFunctionType>)] |\n+ *     [(number|Array<RawFunctionType>), (number|Array<RawFunctionType>)]\n+ * )}\n+ */\n+let RawFunctionSearchType;\n+\n+/**\n+ * A single function input or output type. This is either a single path ID, or a pair of\n+ * [path ID, generics].\n+ *\n+ * Numeric IDs are *ONE-indexed* into the paths array (`p`). Zero is used as a sentinel for `null`\n+ * because `null` is four bytes while `0` is one byte.\n+ *\n+ * @typedef {number | [number, Array<RawFunctionType>]}\n+ */\n+let RawFunctionType;\n+\n+/**\n+ * @typedef {{\n+ *     inputs: Array<FunctionType>,\n+ *     outputs: Array<FunctionType>,\n+ * }}\n+ */\n+let FunctionSearchType;\n+\n+/**\n+ * @typedef {{\n+ *     name: (null|string),\n+ *     ty: (null|number),\n+ *     generics: Array<FunctionType>,\n+ * }}\n+ */\n+let FunctionType;"}, {"sha": "75c7bd45a294923575e89e888548f67da87c5154", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 128, "deletions": 35, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -114,10 +114,6 @@ function levenshtein(s1, s2) {\n function initSearch(rawSearchIndex) {\n     const MAX_LEV_DISTANCE = 3;\n     const MAX_RESULTS = 200;\n-    const GENERICS_DATA = 2;\n-    const NAME = 0;\n-    const INPUTS_DATA = 0;\n-    const OUTPUT_DATA = 1;\n     const NO_TYPE_FILTER = -1;\n     /**\n      *  @type {Array<Row>}\n@@ -895,21 +891,18 @@ function initSearch(rawSearchIndex) {\n          * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n          */\n         function checkGenerics(row, elem, defaultLev) {\n-            if (row.length <= GENERICS_DATA || row[GENERICS_DATA].length === 0) {\n-                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n-            } else if (row[GENERICS_DATA].length > 0 && row[GENERICS_DATA][0][NAME] === \"\") {\n-                if (row.length > GENERICS_DATA) {\n-                    return checkGenerics(row[GENERICS_DATA][0], elem, defaultLev);\n-                }\n+            if (row.generics.length === 0) {\n                 return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+            } else if (row.generics.length > 0 && row.generics[0].name === null) {\n+                return checkGenerics(row.generics[0], elem, defaultLev);\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n             let elem_name;\n-            if (elem.generics.length > 0 && row[GENERICS_DATA].length >= elem.generics.length) {\n+            if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n                 const elems = Object.create(null);\n-                for (const entry of row[GENERICS_DATA]) {\n-                    elem_name = entry[NAME];\n+                for (const entry of row.generics) {\n+                    elem_name = entry.name;\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n                         if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n@@ -963,7 +956,7 @@ function initSearch(rawSearchIndex) {\n           */\n         function checkIfInGenerics(row, elem) {\n             let lev = MAX_LEV_DISTANCE + 1;\n-            for (const entry of row[GENERICS_DATA]) {\n+            for (const entry of row.generics) {\n                 lev = Math.min(checkType(entry, elem, true), lev);\n                 if (lev === 0) {\n                     break;\n@@ -984,23 +977,22 @@ function initSearch(rawSearchIndex) {\n           *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n           */\n         function checkType(row, elem, literalSearch) {\n-            if (row[NAME].length === 0) {\n+            if (row.name === null) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n-                if (row.length > GENERICS_DATA) {\n+                if (row.generics.length > 0) {\n                     return checkIfInGenerics(row, elem);\n                 }\n                 return MAX_LEV_DISTANCE + 1;\n             }\n \n-            let lev = levenshtein(row[NAME], elem.name);\n+            let lev = levenshtein(row.name, elem.name);\n             if (literalSearch) {\n                 if (lev !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n                     if (elem.generics.length === 0) {\n-                        const checkGeneric = (row.length > GENERICS_DATA &&\n-                            row[GENERICS_DATA].length > 0);\n-                        if (checkGeneric && row[GENERICS_DATA]\n-                            .findIndex(tmp_elem => tmp_elem[NAME] === elem.name) !== -1) {\n+                        const checkGeneric = row.generics.length > 0;\n+                        if (checkGeneric && row.generics\n+                            .findIndex(tmp_elem => tmp_elem.name === elem.name) !== -1) {\n                             return 0;\n                         }\n                     }\n@@ -1009,7 +1001,7 @@ function initSearch(rawSearchIndex) {\n                     return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n                 }\n                 return 0;\n-            } else if (row.length > GENERICS_DATA) {\n+            } else if (row.generics.length > 0) {\n                 if (elem.generics.length === 0) {\n                     if (lev === 0) {\n                         return 0;\n@@ -1059,9 +1051,9 @@ function initSearch(rawSearchIndex) {\n         function findArg(row, elem, typeFilter) {\n             let lev = MAX_LEV_DISTANCE + 1;\n \n-            if (row && row.type && row.type[INPUTS_DATA] && row.type[INPUTS_DATA].length > 0) {\n-                for (const input of row.type[INPUTS_DATA]) {\n-                    if (!typePassesFilter(typeFilter, input[1])) {\n+            if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n+                for (const input of row.type.inputs) {\n+                    if (!typePassesFilter(typeFilter, input.ty)) {\n                         continue;\n                     }\n                     lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n@@ -1086,13 +1078,10 @@ function initSearch(rawSearchIndex) {\n         function checkReturned(row, elem, typeFilter) {\n             let lev = MAX_LEV_DISTANCE + 1;\n \n-            if (row && row.type && row.type.length > OUTPUT_DATA) {\n-                let ret = row.type[OUTPUT_DATA];\n-                if (typeof ret[0] === \"string\") {\n-                    ret = [ret];\n-                }\n+            if (row && row.type && row.type.output.length > 0) {\n+                const ret = row.type.output;\n                 for (const ret_ty of ret) {\n-                    if (!typePassesFilter(typeFilter, ret_ty[1])) {\n+                    if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n                         continue;\n                     }\n                     lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n@@ -1836,6 +1825,97 @@ function initSearch(rawSearchIndex) {\n             filterCrates);\n     }\n \n+    /**\n+     * Convert a list of RawFunctionType / ID to object-based FunctionType.\n+     *\n+     * Crates often have lots of functions in them, and it's common to have a large number of\n+     * functions that operate on a small set of data types, so the search index compresses them\n+     * by encoding function parameter and return types as indexes into an array of names.\n+     *\n+     * Even when a general-purpose compression algorithm is used, this is still a win. I checked.\n+     * https://github.com/rust-lang/rust/pull/98475#issue-1284395985\n+     *\n+     * The format for individual function types is encoded in\n+     * librustdoc/html/render/mod.rs: impl Serialize for RenderType\n+     *\n+     * @param {null|Array<RawFunctionType>} types\n+     * @param {Array<{name: string, ty: number}>} lowercasePaths\n+     *\n+     * @return {Array<FunctionSearchType>}\n+     */\n+    function buildItemSearchTypeAll(types, lowercasePaths) {\n+        const PATH_INDEX_DATA = 0;\n+        const GENERICS_DATA = 1;\n+        return types.map(type => {\n+            let pathIndex, generics;\n+            if (typeof type === \"number\") {\n+                pathIndex = type;\n+                generics = [];\n+            } else {\n+                pathIndex = type[PATH_INDEX_DATA];\n+                generics = buildItemSearchTypeAll(type[GENERICS_DATA], lowercasePaths);\n+            }\n+            return {\n+                // `0` is used as a sentinel because it's fewer bytes than `null`\n+                name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n+                generics: generics,\n+            };\n+        });\n+    }\n+\n+    /**\n+     * Convert from RawFunctionSearchType to FunctionSearchType.\n+     *\n+     * Crates often have lots of functions in them, and function signatures are sometimes complex,\n+     * so rustdoc uses a pretty tight encoding for them. This function converts it to a simpler,\n+     * object-based encoding so that the actual search code is more readable and easier to debug.\n+     *\n+     * The raw function search type format is generated using serde in\n+     * librustdoc/html/render/mod.rs: impl Serialize for IndexItemFunctionType\n+     *\n+     * @param {RawFunctionSearchType} functionSearchType\n+     * @param {Array<{name: string, ty: number}>} lowercasePaths\n+     *\n+     * @return {null|FunctionSearchType}\n+     */\n+    function buildFunctionSearchType(functionSearchType, lowercasePaths) {\n+        const INPUTS_DATA = 0;\n+        const OUTPUT_DATA = 1;\n+        // `0` is used as a sentinel because it's fewer bytes than `null`\n+        if (functionSearchType === 0) {\n+            return null;\n+        }\n+        let inputs, output;\n+        if (typeof functionSearchType[INPUTS_DATA] === \"number\") {\n+            const pathIndex = functionSearchType[INPUTS_DATA];\n+            inputs = [{\n+                name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n+                generics: [],\n+            }];\n+        } else {\n+            inputs = buildItemSearchTypeAll(functionSearchType[INPUTS_DATA], lowercasePaths);\n+        }\n+        if (functionSearchType.length > 1) {\n+            if (typeof functionSearchType[OUTPUT_DATA] === \"number\") {\n+                const pathIndex = functionSearchType[OUTPUT_DATA];\n+                output = [{\n+                    name: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].name,\n+                    ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n+                    generics: [],\n+                }];\n+            } else {\n+                output = buildItemSearchTypeAll(functionSearchType[OUTPUT_DATA], lowercasePaths);\n+            }\n+        } else {\n+            output = [];\n+        }\n+        return {\n+            inputs, output,\n+        };\n+    }\n+\n     function buildIndex(rawSearchIndex) {\n         searchIndex = [];\n         /**\n@@ -1862,14 +1942,22 @@ function initSearch(rawSearchIndex) {\n              * q[i] contains the full path of the item, or an empty string indicating\n              * \"same as q[i-1]\".\n              *\n-             * i[i], f[i] are a mystery.\n+             * i[i] contains an item's parent, usually a module. For compactness,\n+             * it is a set of indexes into the `p` array.\n+             *\n+             * f[i] contains function signatures, or `0` if the item isn't a function.\n+             * Functions are themselves encoded as arrays. The first item is a list of\n+             * types representing the function's inputs, and the second list item is a list\n+             * of types representing the function's output. Tuples are flattened.\n+             * Types are also represented as arrays; the first item is an index into the `p`\n+             * array, while the second is a list of types representing any generic parameters.\n              *\n              * `a` defines aliases with an Array of pairs: [name, offset], where `offset`\n              * points into the n/t/d/q/i/f arrays.\n              *\n              * `doc` contains the description of the crate.\n              *\n-             * `p` is a mystery and isn't the same length as n/t/d/q/i/f.\n+             * `p` is a list of path/type pairs. It is used for parents and function parameters.\n              *\n              * @type {{\n              *   doc: string,\n@@ -1879,7 +1967,7 @@ function initSearch(rawSearchIndex) {\n              *   d: Array<string>,\n              *   q: Array<string>,\n              *   i: Array<Number>,\n-             *   f: Array<Array<?>>,\n+             *   f: Array<RawFunctionSearchType>,\n              *   p: Array<Object>,\n              * }}\n              */\n@@ -1923,9 +2011,14 @@ function initSearch(rawSearchIndex) {\n             //             [Number] index to items]\n             const aliases = crateCorpus.a;\n \n+            // an array of [{name: String, ty: Number}]\n+            const lowercasePaths = [];\n+\n             // convert `rawPaths` entries into object form\n+            // generate normalizedPaths for function search mode\n             let len = paths.length;\n             for (i = 0; i < len; ++i) {\n+                lowercasePaths.push({ty: paths[i][0], name: paths[i][1].toLowerCase()});\n                 paths[i] = {ty: paths[i][0], name: paths[i][1]};\n             }\n \n@@ -1955,7 +2048,7 @@ function initSearch(rawSearchIndex) {\n                     path: itemPaths[i] ? itemPaths[i] : lastPath,\n                     desc: itemDescs[i],\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n-                    type: itemFunctionSearchTypes[i],\n+                    type: buildFunctionSearchType(itemFunctionSearchTypes[i], lowercasePaths),\n                     id: id,\n                     normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),\n                 };"}, {"sha": "afc84cc0a97aaf995340cc1df4fbd86c29d2191e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "patch": "@@ -761,7 +761,6 @@ impl FromWithTcx<ItemType> for ItemKind {\n             TraitAlias => ItemKind::TraitAlias,\n             ProcAttribute => ItemKind::ProcAttribute,\n             ProcDerive => ItemKind::ProcDerive,\n-            Generic => unreachable!(),\n         }\n     }\n }"}]}