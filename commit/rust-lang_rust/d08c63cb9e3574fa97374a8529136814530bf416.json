{"sha": "d08c63cb9e3574fa97374a8529136814530bf416", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGM2M2NiOWUzNTc0ZmE5NzM3NGE4NTI5MTM2ODE0NTMwYmY0MTY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-05-20T21:51:20Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-04T17:33:01Z"}, "message": "Add an ImportMap", "tree": {"sha": "385c05e8531fccb567ca7ca688de761f4a08edb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385c05e8531fccb567ca7ca688de761f4a08edb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08c63cb9e3574fa97374a8529136814530bf416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08c63cb9e3574fa97374a8529136814530bf416", "html_url": "https://github.com/rust-lang/rust/commit/d08c63cb9e3574fa97374a8529136814530bf416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08c63cb9e3574fa97374a8529136814530bf416/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c19496f845a4adcd7e0f48f5dcb5b405bbc63dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c19496f845a4adcd7e0f48f5dcb5b405bbc63dfc", "html_url": "https://github.com/rust-lang/rust/commit/c19496f845a4adcd7e0f48f5dcb5b405bbc63dfc"}], "stats": {"total": 374, "additions": 360, "deletions": 14}, "files": [{"sha": "e7868268b1e552cddc0a85e134a5417ee5ea97e3", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -11,8 +11,8 @@ use ra_syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n pub use crate::{\n     cancellation::Canceled,\n     input::{\n-        CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource, ExternSourceId,\n-        FileId, ProcMacroId, SourceRoot, SourceRootId,\n+        CrateData, CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource,\n+        ExternSourceId, FileId, ProcMacroId, SourceRoot, SourceRootId,\n     },\n };\n pub use relative_path::{RelativePath, RelativePathBuf};"}, {"sha": "a23d65371fb6aef7ab9405bd85c104c37a48421d", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     docs::Documentation,\n     find_path,\n     generics::GenericParams,\n+    import_map::ImportMap,\n     item_scope::ItemInNs,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n@@ -122,6 +123,9 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n \n     #[salsa::invoke(find_path::find_path_inner_query)]\n     fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n+\n+    #[salsa::invoke(ImportMap::import_map_query)]\n+    fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "088e8dd32ff1d8dd6c54e24e3a9a5f563c234b7d", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -36,17 +36,6 @@ impl ModPath {\n         let first_segment = self.segments.first();\n         first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n-\n-    fn len(&self) -> usize {\n-        self.segments.len()\n-            + match self.kind {\n-                PathKind::Plain => 0,\n-                PathKind::Super(i) => i as usize,\n-                PathKind::Crate => 1,\n-                PathKind::Abs => 0,\n-                PathKind::DollarCrate(_) => 1,\n-            }\n-    }\n }\n \n pub(crate) fn find_path_inner_query(\n@@ -192,9 +181,17 @@ fn find_importable_locations(\n ) -> Vec<(ModuleId, Name)> {\n     let crate_graph = db.crate_graph();\n     let mut result = Vec::new();\n+\n     // We only look in the crate from which we are importing, and the direct\n     // dependencies. We cannot refer to names from transitive dependencies\n     // directly (only through reexports in direct dependencies).\n+\n+    // For the crate from which we're importing, we have to check whether any\n+    // module visible to `from` exports the item we're looking for.\n+    // For dependencies of the crate only `pub` items reachable through `pub`\n+    // modules from the crate root are relevant. For that we precompute an\n+    // import map that tells us the shortest path to any importable item with a\n+    // single lookup.\n     for krate in Some(from.krate)\n         .into_iter()\n         .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))"}, {"sha": "7dae64efa74184928e1a0a984df6df20541ff251", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -0,0 +1,323 @@\n+//! A map of all publicly exported items in a crate.\n+\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    path::{ModPath, PathKind},\n+    visibility::Visibility,\n+    ModuleDefId, ModuleId,\n+};\n+use ra_db::CrateId;\n+use rustc_hash::FxHashMap;\n+use std::{collections::hash_map::Entry, sync::Arc};\n+\n+/// A map from publicly exported items to the path needed to import/name them from a downstream\n+/// crate.\n+///\n+/// Reexports of items are taken into account, ie. if something is exported under multiple\n+/// names, the one with the shortest import path will be used.\n+///\n+/// Note that all paths are relative to the containing crate's root, so the crate name still needs\n+/// to be prepended to the `ModPath` before the path is valid.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct ImportMap {\n+    map: FxHashMap<ItemInNs, ModPath>,\n+}\n+\n+impl ImportMap {\n+    pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = ra_prof::profile(\"import_map_query\");\n+        let def_map = db.crate_def_map(krate);\n+        let mut import_map = FxHashMap::with_capacity_and_hasher(64, Default::default());\n+\n+        // We look only into modules that are public(ly reexported), starting with the crate root.\n+        let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n+        let root = ModuleId { krate, local_id: def_map.root };\n+        let mut worklist = vec![(root, empty)];\n+        while let Some((module, mod_path)) = worklist.pop() {\n+            let ext_def_map;\n+            let mod_data = if module.krate == krate {\n+                &def_map[module.local_id]\n+            } else {\n+                // The crate might reexport a module defined in another crate.\n+                ext_def_map = db.crate_def_map(module.krate);\n+                &ext_def_map[module.local_id]\n+            };\n+\n+            let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+                let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+                if per_ns.is_none() {\n+                    None\n+                } else {\n+                    Some((name, per_ns))\n+                }\n+            });\n+\n+            for (name, per_ns) in visible_items {\n+                let mk_path = || {\n+                    let mut path = mod_path.clone();\n+                    path.segments.push(name.clone());\n+                    path\n+                };\n+\n+                for item in per_ns.iter_items() {\n+                    let path = mk_path();\n+                    match import_map.entry(item) {\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(path);\n+                        }\n+                        Entry::Occupied(mut entry) => {\n+                            // If the new path is shorter, prefer that one.\n+                            if path.len() < entry.get().len() {\n+                                *entry.get_mut() = path;\n+                            } else {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n+                    // If we've just added a path to a module, descend into it.\n+                    if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                        worklist.push((mod_id, mk_path()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        Arc::new(Self { map: import_map })\n+    }\n+\n+    /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n+    pub fn path_of(&self, item: ItemInNs) -> Option<&ModPath> {\n+        self.map.get(&item)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_db::TestDB;\n+    use insta::assert_snapshot;\n+    use ra_db::fixture::WithFixture;\n+    use ra_db::SourceDatabase;\n+\n+    fn import_map(ra_fixture: &str) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+\n+        let import_maps: Vec<_> = crate_graph\n+            .iter()\n+            .filter_map(|krate| {\n+                let cdata = &crate_graph[krate];\n+                let name = cdata.display_name.as_ref()?;\n+\n+                let map = db.import_map(krate);\n+\n+                let mut importable_paths: Vec<_> = map\n+                    .map\n+                    .iter()\n+                    .map(|(item, modpath)| {\n+                        let ns = match item {\n+                            ItemInNs::Types(_) => \"t\",\n+                            ItemInNs::Values(_) => \"v\",\n+                            ItemInNs::Macros(_) => \"m\",\n+                        };\n+                        format!(\"- {} ({})\", modpath, ns)\n+                    })\n+                    .collect();\n+\n+                importable_paths.sort();\n+                let importable_paths = importable_paths.join(\"\\n\");\n+\n+                Some(format!(\"{}:\\n{}\", name, importable_paths))\n+            })\n+            .collect();\n+\n+        import_maps.join(\"\\n\")\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+\n+            mod private {\n+                pub use lib::Pub;\n+                pub struct InPrivateModule;\n+            }\n+\n+            pub mod publ1 {\n+                use lib::Pub;\n+            }\n+\n+            pub mod real_pub {\n+                pub use lib::Pub;\n+            }\n+            pub mod real_pu2 { // same path length as above\n+                pub use lib::Pub;\n+            }\n+\n+            //- /lib.rs crate:lib\n+            pub struct Pub {}\n+            pub struct Pub2; // t + v\n+            struct Priv;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - publ1 (t)\n+        - real_pu2 (t)\n+        - real_pub (t)\n+        - real_pub::Pub (t)\n+        lib:\n+        - Pub (t)\n+        - Pub2 (t)\n+        - Pub2 (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn prefers_shortest_path() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main\n+\n+            pub mod sub {\n+                pub mod subsub {\n+                    pub struct Def {}\n+                }\n+\n+                pub use super::sub::subsub::Def;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - sub (t)\n+        - sub::Def (t)\n+        - sub::subsub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn type_reexport_cross_crate() {\n+        // Reexports need to be visible from a crate, even if the original crate exports the item\n+        // at a shorter path.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::S;\n+            }\n+            //- /lib.rs crate:lib\n+            pub struct S;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::S (t)\n+        - m::S (v)\n+        lib:\n+        - S (t)\n+        - S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn macro_reexport() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::pub_macro;\n+            }\n+            //- /lib.rs crate:lib\n+            #[macro_export]\n+            macro_rules! pub_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::pub_macro (m)\n+        lib:\n+        - pub_macro (m)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn module_reexport() {\n+        // Reexporting modules from a dependency adds all contents to the import map.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub use lib::module as reexported_module;\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - reexported_module (t)\n+        - reexported_module::S (t)\n+        - reexported_module::S (v)\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn cyclic_module_reexport() {\n+        // Reexporting modules from a dependency adds all contents to the import map.\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+                pub use super::sub::*;\n+            }\n+\n+            pub mod sub {\n+                pub use super::module;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        - sub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn private_macro() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            macro_rules! private_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        \"###);\n+    }\n+}"}, {"sha": "de490fcc58af295ec07d424046ebc7ba1e1c9e48", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -43,6 +43,7 @@ pub mod child_by_source;\n \n pub mod visibility;\n pub mod find_path;\n+pub mod import_map;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "bfa921de2220aafc92f24626cc07f3a24e13cc35", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -76,6 +76,19 @@ impl ModPath {\n         }\n     }\n \n+    /// Returns the number of segments in the path (counting special segments like `$crate` and\n+    /// `super`).\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+            + match self.kind {\n+                PathKind::Plain => 0,\n+                PathKind::Super(i) => i as usize,\n+                PathKind::Crate => 1,\n+                PathKind::Abs => 0,\n+                PathKind::DollarCrate(_) => 1,\n+            }\n+    }\n+\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }"}, {"sha": "74665c58851c909417bbd2efe9a24b180b1a39dc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08c63cb9e3574fa97374a8529136814530bf416/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=d08c63cb9e3574fa97374a8529136814530bf416", "patch": "@@ -5,7 +5,7 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::{visibility::Visibility, ModuleDefId};\n+use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n@@ -84,4 +84,12 @@ impl PerNs {\n             macros: self.macros.or(other.macros),\n         }\n     }\n+\n+    pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n+        self.types\n+            .map(|it| ItemInNs::Types(it.0))\n+            .into_iter()\n+            .chain(self.values.map(|it| ItemInNs::Values(it.0)).into_iter())\n+            .chain(self.macros.map(|it| ItemInNs::Macros(it.0)).into_iter())\n+    }\n }"}]}