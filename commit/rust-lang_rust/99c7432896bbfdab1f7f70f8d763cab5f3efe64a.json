{"sha": "99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5Yzc0MzI4OTZiYmZkYWIxZjdmNzBmOGQ3NjNjYWI1ZjNlZmU2NGE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-06T18:02:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:57Z"}, "message": "hygiene: Introduce a helper method for creating new expansions\n\nCreating a fresh expansion and immediately generating a span from it is the most common scenario.\n\nAlso avoid allocating `allow_internal_unstable` lists for derive markers repeatedly.\nAnd rename `ExpnInfo::with_unstable` to `ExpnInfo::allow_unstable`, seems to be a better fitting name.", "tree": {"sha": "a2865fec34b7b001c5353c498706cf991a7befc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2865fec34b7b001c5353c498706cf991a7befc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "html_url": "https://github.com/rust-lang/rust/commit/99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1949b1ab01dbd482008f64af54161cc43bb0991", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1949b1ab01dbd482008f64af54161cc43bb0991", "html_url": "https://github.com/rust-lang/rust/commit/d1949b1ab01dbd482008f64af54161cc43bb0991"}], "stats": {"total": 197, "additions": 80, "deletions": 117}, "files": [{"sha": "7e7bb5f61a3241ad91cf53000dec3ff92a46f718", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -60,7 +60,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n use syntax::std_inject;\n@@ -875,13 +875,11 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n+        span.fresh_expansion(Mark::root(), ExpnInfo {\n             def_site: span,\n             allow_internal_unstable,\n             ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n-        });\n-        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+        })\n     }\n \n     fn with_anonymous_lifetime_mode<R>("}, {"sha": "d0be13a711117c9f576b6d40e3d19806bc8af524", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -588,41 +588,40 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n \n         let expn_info_tag = u8::decode(self)?;\n \n-        let ctxt = match expn_info_tag {\n+        // FIXME(mw): This method does not restore `MarkData::parent` or\n+        // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n+        // don't seem to be used after HIR lowering, so everything should be fine\n+        // as long as incremental compilation does not kick in before that.\n+        let location = || Span::new(lo, hi, SyntaxContext::empty());\n+        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n+            let span = location().fresh_expansion(Mark::root(), expn_info);\n+            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+            span\n+        };\n+        Ok(match expn_info_tag {\n             TAG_NO_EXPANSION_INFO => {\n-                SyntaxContext::empty()\n+                location()\n             }\n             TAG_EXPANSION_INFO_INLINE => {\n-                let pos = AbsoluteBytePos::new(self.opaque.position());\n-                let expn_info: ExpnInfo = Decodable::decode(self)?;\n-                let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n-                ctxt\n+                let expn_info = Decodable::decode(self)?;\n+                recover_from_expn_info(\n+                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+                )\n             }\n             TAG_EXPANSION_INFO_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos\n-                                      .borrow()\n-                                      .get(&pos)\n-                                      .cloned();\n-\n-                if let Some(ctxt) = cached_ctxt {\n-                    ctxt\n+                if let Some(cached_ctxt) = self.synthetic_expansion_infos.borrow().get(&pos) {\n+                    Span::new(lo, hi, *cached_ctxt)\n                 } else {\n-                    let expn_info = self.with_position(pos.to_usize(), |this| {\n-                         ExpnInfo::decode(this)\n-                    })?;\n-                    let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                    self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n-                    ctxt\n+                    let expn_info =\n+                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n+                    recover_from_expn_info(self, expn_info, pos)\n                 }\n             }\n             _ => {\n                 unreachable!()\n             }\n-        };\n-\n-        Ok(Span::new(lo, hi, ctxt))\n+        })\n     }\n }\n "}, {"sha": "9803ee99f1a47714f4412fb70ded9142bd574b12", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n         base::{ExtCtxt, MacroKind, Resolver},\n         build::AstBuilder,\n         expand::ExpansionConfig,\n-        hygiene::{Mark, SyntaxContext},\n+        hygiene::Mark,\n     },\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n@@ -84,16 +84,12 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n         }\n         self.found = true;\n \n-        // Create a fresh Mark for the new macro expansion we are about to do\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo::with_unstable(\n+        // Create a new expansion for the generated allocator code.\n+        let span = item.span.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n-            &[sym::rustc_attrs],\n+            [sym::rustc_attrs][..].into(),\n         ));\n \n-        // Tie the span to the macro expansion info we just created\n-        let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-\n         // Create an expansion config\n         let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n "}, {"sha": "6f276e04a5a39df3bd30fcd07d14045fd7deedd3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -17,7 +17,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark};\n+use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n@@ -148,7 +148,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let mark = Mark::fresh(Mark::root());\n+        let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::default(\n+            ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n+        ));\n+        let mark = span.ctxt().outer();\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n         self.definitions.set_invocation_parent(mark, module.def_id().unwrap().index);\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {"}, {"sha": "37d5885db60c3c3d81b649b72df15261c6902cc1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -721,6 +721,7 @@ pub struct ExtCtxt<'a> {\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n+    pub allow_derive_markers: Lrc<[Symbol]>,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -740,6 +741,7 @@ impl<'a> ExtCtxt<'a> {\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n             },\n             expansions: FxHashMap::default(),\n+            allow_derive_markers: [sym::rustc_attrs, sym::structural_match][..].into(),\n         }\n     }\n "}, {"sha": "1c15deab37377fb5391adbcfcd5d1ebcfa486463", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -8,7 +8,6 @@ use crate::symbol::{Symbol, sym};\n use crate::errors::Applicability;\n \n use syntax_pos::Span;\n-use syntax_pos::hygiene::{Mark, SyntaxContext};\n use rustc_data_structures::fx::FxHashSet;\n \n pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n@@ -55,13 +54,11 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n \n-    let mark = Mark::fresh(cx.current_expansion.mark);\n-    mark.set_expn_info(ExpnInfo::with_unstable(\n+    let span = span.fresh_expansion(cx.current_expansion.mark, ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n-        cx.parse_sess.edition, &[sym::rustc_attrs, sym::structural_match],\n+        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n     ));\n \n-    let span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n     item.visit_attrs(|attrs| {\n         if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n             let meta = cx.meta_word(span, sym::structural_match);"}, {"sha": "39a8a7af2a3017ea212f1b3a484e5d52cc55dbd2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let mark = Mark::fresh(self.cx.current_expansion.mark);\n+                    let mark = Mark::fresh(self.cx.current_expansion.mark, None);\n                     derives.push(mark);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive {\n@@ -847,7 +847,7 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        let mark = Mark::fresh(self.cx.current_expansion.mark);\n+        let mark = Mark::fresh(self.cx.current_expansion.mark, None);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,"}, {"sha": "d86b76f71eca7d155ae79f701555c6a091a5fda1", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -1,27 +1,15 @@\n use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n-use crate::ext::hygiene::{Mark, SyntaxContext, MacroKind};\n+use crate::ext::hygiene::{Mark, MacroKind};\n use crate::symbol::{Ident, Symbol, kw, sym};\n use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n \n use std::cell::Cell;\n use std::iter;\n-use syntax_pos::{DUMMY_SP, Span};\n-\n-/// Craft a span that will be ignored by the stability lint's\n-/// call to source_map's `is_internal` check.\n-/// The expanded code uses the unstable `#[prelude_import]` attribute.\n-fn ignored_span(sp: Span, edition: Edition) -> Span {\n-    let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo::with_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, Symbol::intern(\"std_inject\")), sp, edition,\n-        &[sym::prelude_import],\n-    ));\n-    sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-}\n+use syntax_pos::DUMMY_SP;\n \n pub fn injected_crate_name() -> Option<&'static str> {\n     INJECTED_CRATE_NAME.with(|name| name.get())\n@@ -87,7 +75,11 @@ pub fn maybe_inject_crates_ref(\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let span = ignored_span(DUMMY_SP, edition);\n+    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n+        [sym::prelude_import][..].into(),\n+    ));\n+\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,"}, {"sha": "799d64a9962371070fc5ba68223ce07ed1714388", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -43,7 +43,6 @@ struct TestCtxt<'a> {\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n-    ctxt: SyntaxContext,\n     features: &'a Features,\n     test_runner: Option<ast::Path>,\n \n@@ -259,8 +258,6 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     cleaner.visit_crate(krate);\n \n-    let mark = Mark::fresh(Mark::root());\n-\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n@@ -274,30 +271,17 @@ fn generate_test_harness(sess: &ParseSess,\n         is_libtest: attr::find_crate_name(&krate.attrs)\n             .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n-        ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,\n         test_runner\n     };\n \n-    mark.set_expn_info(ExpnInfo::with_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, sess.edition,\n-        &[sym::main, sym::test, sym::rustc_attrs],\n-    ));\n-\n     TestHarnessGenerator {\n         cx,\n         tests: Vec::new(),\n         tested_submods: Vec::new(),\n     }.visit_crate(krate);\n }\n \n-/// Craft a span that will be ignored by the stability lint's\n-/// call to source_map's `is_internal` check.\n-/// The expanded code calls some unstable functions in the test crate.\n-fn ignored_span(cx: &TestCtxt<'_>, sp: Span) -> Span {\n-    sp.with_ctxt(cx.ctxt)\n-}\n-\n enum HasTestSignature {\n     Yes,\n     No(BadTestSignature),\n@@ -314,12 +298,15 @@ enum BadTestSignature {\n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n-    // Writing this out by hand with 'ignored_span':\n+    // Writing this out by hand:\n     //        pub fn main() {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = ignored_span(cx, DUMMY_SP);\n+    let sp = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n+        [sym::main, sym::test, sym::rustc_attrs][..].into(),\n+    ));\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::with_empty_ctxt(sym::test);\n "}, {"sha": "2f78644dff2aa89e2673fcce79f0a3d4e5c069e9", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -346,12 +346,10 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo::with_unstable(\n+    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n-        &[sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")],\n+        [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));\n-    let span = DUMMY_SP.apply_mark(mark);\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);"}, {"sha": "f060bf356f6d723d84e630987213888bf6700ea8", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -82,11 +82,8 @@ pub enum Transparency {\n }\n \n impl Mark {\n-    pub fn fresh(parent: Mark) -> Self {\n-        HygieneData::with(|data| {\n-            data.marks.push(MarkData { parent, expn_info: None });\n-            Mark(data.marks.len() as u32 - 1)\n-        })\n+    pub fn fresh(parent: Mark, expn_info: Option<ExpnInfo>) -> Self {\n+        HygieneData::with(|data| data.fresh_mark(parent, expn_info))\n     }\n \n     /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -180,6 +177,11 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n+    fn fresh_mark(&mut self, parent: Mark, expn_info: Option<ExpnInfo>) -> Mark {\n+        self.marks.push(MarkData { parent, expn_info });\n+        Mark(self.marks.len() as u32 - 1)\n+    }\n+\n     fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n         self.marks[mark.0 as usize].expn_info.as_ref()\n     }\n@@ -396,33 +398,6 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n-    // deserializing Spans from the incr. comp. cache.\n-    // FIXME(mw): This method does not restore MarkData::parent or\n-    // SyntaxContextData::prev_ctxt or SyntaxContextData::opaque. These things\n-    // don't seem to be used after HIR lowering, so everything should be fine\n-    // as long as incremental compilation does not kick in before that.\n-    pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n-        HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n-                parent: Mark::root(),\n-                expn_info: Some(expansion_info),\n-            });\n-\n-            let mark = Mark(data.marks.len() as u32 - 1);\n-\n-            data.syntax_contexts.push(SyntaxContextData {\n-                outer_mark: mark,\n-                transparency: Transparency::SemiTransparent,\n-                prev_ctxt: SyntaxContext::empty(),\n-                opaque: SyntaxContext::empty(),\n-                opaque_and_semitransparent: SyntaxContext::empty(),\n-                dollar_crate_name: kw::DollarCrate,\n-            });\n-            SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n-        })\n-    }\n-\n     /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, mark))\n@@ -615,6 +590,20 @@ impl fmt::Debug for SyntaxContext {\n     }\n }\n \n+impl Span {\n+    /// Creates a fresh expansion with given properties.\n+    /// Expansions are normally created by macros, but in some cases expansions are created for\n+    /// other compiler-generated code to set per-span properties like allowed unstable features.\n+    /// The returned span belongs to the created expansion and has the new properties,\n+    /// but its location is inherited from the current span.\n+    pub fn fresh_expansion(self, parent: Mark, expn_info: ExpnInfo) -> Span {\n+        HygieneData::with(|data| {\n+            let mark = data.fresh_mark(parent, Some(expn_info));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), mark))\n+        })\n+    }\n+}\n+\n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n@@ -669,10 +658,10 @@ impl ExpnInfo {\n         }\n     }\n \n-    pub fn with_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n-                         allow_internal_unstable: &[Symbol]) -> ExpnInfo {\n+    pub fn allow_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n+                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnInfo {\n         ExpnInfo {\n-            allow_internal_unstable: Some(allow_internal_unstable.into()),\n+            allow_internal_unstable: Some(allow_internal_unstable),\n             ..ExpnInfo::default(kind, call_site, edition)\n         }\n     }"}, {"sha": "581fd47c4b3b582f8668065373f0cde443e762c4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c7432896bbfdab1f7f70f8d763cab5f3efe64a/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=99c7432896bbfdab1f7f70f8d763cab5f3efe64a", "patch": "@@ -508,6 +508,7 @@ symbols! {\n         proc_macro_expr,\n         proc_macro_gen,\n         proc_macro_hygiene,\n+        proc_macro_internals,\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n@@ -631,6 +632,7 @@ symbols! {\n         static_nobundle,\n         static_recursion,\n         std,\n+        std_inject,\n         str,\n         stringify,\n         stmt,"}]}