{"sha": "b37e78974c282abe2bcf2fd1f8101d587973dfc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzN2U3ODk3NGMyODJhYmUyYmNmMmZkMWY4MTAxZDU4Nzk3M2RmYzc=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-12-16T04:51:29Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-12-16T04:51:29Z"}, "message": "Merge pull request #703 from JanLikar/cargo-fmt\n\nAdd cargo-fmt binary", "tree": {"sha": "8e83acf474a733693d9e72b82a30c6a4a7796f5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e83acf474a733693d9e72b82a30c6a4a7796f5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b37e78974c282abe2bcf2fd1f8101d587973dfc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b37e78974c282abe2bcf2fd1f8101d587973dfc7", "html_url": "https://github.com/rust-lang/rust/commit/b37e78974c282abe2bcf2fd1f8101d587973dfc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b37e78974c282abe2bcf2fd1f8101d587973dfc7/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d42383e3ed83d053765cc7f6d5a4c8b2680efbfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d42383e3ed83d053765cc7f6d5a4c8b2680efbfb", "html_url": "https://github.com/rust-lang/rust/commit/d42383e3ed83d053765cc7f6d5a4c8b2680efbfb"}, {"sha": "1e5e290e392adbf3e16f964bacb47a853cff3bdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5e290e392adbf3e16f964bacb47a853cff3bdf", "html_url": "https://github.com/rust-lang/rust/commit/1e5e290e392adbf3e16f964bacb47a853cff3bdf"}], "stats": {"total": 173, "additions": 169, "deletions": 4}, "files": [{"sha": "70f7f796baf9eb42cd0dfea6b4f3e89ab12c91a0", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b37e78974c282abe2bcf2fd1f8101d587973dfc7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b37e78974c282abe2bcf2fd1f8101d587973dfc7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b37e78974c282abe2bcf2fd1f8101d587973dfc7", "patch": "@@ -9,6 +9,10 @@ readme = \"README.md\"\n license = \"Apache-2.0/MIT\"\n include = [\"src/*.rs\", \"Cargo.toml\"]\n \n+[features]\n+default = [\"cargo-fmt\"]\n+cargo-fmt = []\n+\n [dependencies]\n toml = \"0.1.20\"\n rustc-serialize = \"0.3.14\""}, {"sha": "f8dab7ec97fff65f84176c222bea2a63fef22b59", "filename": "README.md", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b37e78974c282abe2bcf2fd1f8101d587973dfc7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b37e78974c282abe2bcf2fd1f8101d587973dfc7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b37e78974c282abe2bcf2fd1f8101d587973dfc7", "patch": "@@ -21,14 +21,21 @@ or if you're using [`multirust`](https://github.com/brson/multirust)\n multirust run nightly cargo install --git https://github.com/rust-lang-nursery/rustfmt\n ```\n \n+Usually cargo-fmt, which enables usage of Cargo subcommand `cargo fmt`, is\n+installed alongside rustfmt. To only install rustfmt run\n+\n+```\n+cargo install --no-default-features --git https://github.com/rust-lang-nursery/rustfmt\n+```\n \n ## Running\n \n-You can run Rustfmt by just typing `rustfmt filename` if you used `Cargo\n+You can run Rustfmt by just typing `rustfmt filename` if you used `cargo\n install`. This runs rustfmt on the given file, if the file includes out of line\n modules, then we reformat those too. So to run on a whole module or crate, you\n just need to run on the root file (usually mod.rs or lib.rs). Rustfmt can also\n-read data from stdin.\n+read data from stdin. Alternatively, you can use `cargo fmt` to format all\n+binary and library targets of your crate.\n \n You'll probably want to specify the write mode. Currently, there are modes for\n replace, overwrite, display, and coverage. The replace mode is the default\n@@ -42,6 +49,7 @@ screen, for example.\n \n You can run `rustfmt --help` for more information.\n \n+`cargo fmt` uses `--write-mode=overwrite` by default.\n \n ## Running Rustfmt from your editor\n \n@@ -59,8 +67,8 @@ First make sure you've got Rust **1.4.0** or greater available, then:\n \n `cargo test` to run all tests.\n \n-To run rustfmt after this, use `cargo run -- filename`. See the notes above on\n-running rustfmt.\n+To run rustfmt after this, use `cargo run --bin rustfmt -- filename`. See the\n+notes above on running rustfmt.\n \n \n ## What style does Rustfmt use?"}, {"sha": "f79899ff5b1b8ccb034a0a0e54c975d51d4ef752", "filename": "src/bin/cargo-fmt.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b37e78974c282abe2bcf2fd1f8101d587973dfc7/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37e78974c282abe2bcf2fd1f8101d587973dfc7/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=b37e78974c282abe2bcf2fd1f8101d587973dfc7", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Inspired by Paul Woolcock's cargo-fmt (https://github.com/pwoolcoc/cargo-fmt/)\n+\n+#![cfg(not(test))]\n+#![cfg(feature=\"cargo-fmt\")]\n+\n+extern crate getopts;\n+extern crate rustc_serialize;\n+\n+use std::path::PathBuf;\n+use std::process::Command;\n+use std::env;\n+use std::str;\n+\n+use getopts::Options;\n+use rustc_serialize::json::Json;\n+\n+fn main() {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+\n+    let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n+        Ok(m) => m,\n+        Err(e) => {\n+            print_usage(&opts, &e.to_string());\n+            return;\n+        }\n+    };\n+\n+    if matches.opt_present(\"h\") {\n+        print_usage(&opts, \"\");\n+    } else {\n+        format_crate(&opts);\n+    }\n+}\n+\n+fn print_usage(opts: &Options, reason: &str) {\n+    let msg = format!(\"{}\\nusage: cargo fmt [options]\", reason);\n+    println!(\"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n+              Arguments after `--` are passes to rustfmt.\",\n+             opts.usage(&msg));\n+}\n+\n+fn format_crate(opts: &Options) {\n+    let targets = match get_targets() {\n+        Ok(t) => t,\n+        Err(e) => {\n+            print_usage(opts, &e.to_string());\n+            return;\n+        }\n+    };\n+\n+    // Currently only bin and lib files get formatted\n+    let files: Vec<_> = targets.into_iter()\n+                               .filter(|t| t.kind.is_lib() | t.kind.is_bin())\n+                               .map(|t| t.path)\n+                               .collect();\n+\n+    format_files(&files, &get_fmt_args()).unwrap_or_else(|e| print_usage(opts, &e.to_string()));\n+}\n+\n+fn get_fmt_args() -> Vec<String> {\n+    let mut args = vec![\"--write-mode=overwrite\".to_string()];\n+    // All arguments after -- are passed to rustfmt\n+    args.extend(env::args().skip_while(|a| a != \"--\").skip(1));\n+\n+    args\n+}\n+\n+#[derive(Debug)]\n+enum TargetKind {\n+    Lib, // dylib, staticlib, lib\n+    Bin, // bin\n+    Other, // test, plugin,...\n+}\n+\n+impl TargetKind {\n+    fn is_lib(&self) -> bool {\n+        match self {\n+            &TargetKind::Lib => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_bin(&self) -> bool {\n+        match self {\n+            &TargetKind::Bin => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Target {\n+    path: PathBuf,\n+    kind: TargetKind,\n+}\n+\n+// Returns a vector of all compile targets of a crate\n+fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n+    let mut targets: Vec<Target> = vec![];\n+    let output = try!(Command::new(\"cargo\").arg(\"read-manifest\").output());\n+    if output.status.success() {\n+        // None of the unwraps should fail if output of `cargo read-manifest` is correct\n+        let data = &String::from_utf8(output.stdout).unwrap();\n+        let json = Json::from_str(data).unwrap();\n+        let jtargets = json.find(\"targets\").unwrap().as_array().unwrap();\n+        for jtarget in jtargets {\n+            targets.push(target_from_json(jtarget));\n+        }\n+\n+        Ok(targets)\n+    } else {\n+        // This happens when cargo-fmt is not used inside a crate\n+        Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n+                                str::from_utf8(&output.stderr).unwrap()))\n+    }\n+}\n+\n+fn target_from_json(jtarget: &Json) -> Target {\n+    let jtarget = jtarget.as_object().unwrap();\n+    let path = PathBuf::from(jtarget.get(\"src_path\").unwrap().as_string().unwrap());\n+    let kinds = jtarget.get(\"kind\").unwrap().as_array().unwrap();\n+    let kind = match kinds[0].as_string().unwrap() {\n+        \"bin\" => TargetKind::Bin,\n+        \"lib\" | \"dylib\" | \"staticlib\" => TargetKind::Lib,\n+        _ => TargetKind::Other,\n+    };\n+\n+    Target {\n+        path: path,\n+        kind: kind,\n+    }\n+}\n+\n+fn format_files(files: &Vec<PathBuf>, fmt_args: &Vec<String>) -> Result<(), std::io::Error> {\n+    let mut command = try!(Command::new(\"rustfmt\")\n+                               .args(files)\n+                               .args(fmt_args)\n+                               .spawn());\n+    try!(command.wait());\n+\n+    Ok(())\n+}"}]}