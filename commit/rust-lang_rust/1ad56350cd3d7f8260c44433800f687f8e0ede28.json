{"sha": "1ad56350cd3d7f8260c44433800f687f8e0ede28", "node_id": "C_kwDOAAsO6NoAKDFhZDU2MzUwY2QzZDdmODI2MGM0NDQzMzgwMGY2ODdmOGUwZWRlMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T01:10:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T01:10:08Z"}, "message": "Auto merge of #100123 - matthiaskrgr:rollup-aylwvyc, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #98877 (Set llvm configs when building lld)\n - #100068 (Fix backwards-compatibility check for tests with `+whole-archive`)\n - #100083 (rustdoc: use a more compact encoding for source-files.js)\n - #100102 (Fix typo)\n - #100104 (Remove more Clean trait implementations)\n - #100105 (Add regression test for #90871)\n - #100107 (fix trailing whitespace in error message)\n - #100111 (Provide suggestion on missing `let` in binding statement)\n - #100119 (FilesTimes support does not build for ESP-IDF)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "99246f0e01b4dcd72606be3f2d465bdc2c2bdca0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99246f0e01b4dcd72606be3f2d465bdc2c2bdca0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ad56350cd3d7f8260c44433800f687f8e0ede28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad56350cd3d7f8260c44433800f687f8e0ede28", "html_url": "https://github.com/rust-lang/rust/commit/1ad56350cd3d7f8260c44433800f687f8e0ede28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ad56350cd3d7f8260c44433800f687f8e0ede28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59d99f56d8888b0e5a5866d6418df3ca1bb90013", "url": "https://api.github.com/repos/rust-lang/rust/commits/59d99f56d8888b0e5a5866d6418df3ca1bb90013", "html_url": "https://github.com/rust-lang/rust/commit/59d99f56d8888b0e5a5866d6418df3ca1bb90013"}, {"sha": "a44532c13ce87907eef00a1906d5498a8fb3c098", "url": "https://api.github.com/repos/rust-lang/rust/commits/a44532c13ce87907eef00a1906d5498a8fb3c098", "html_url": "https://github.com/rust-lang/rust/commit/a44532c13ce87907eef00a1906d5498a8fb3c098"}], "stats": {"total": 302, "additions": 208, "deletions": 94}, "files": [{"sha": "6e33c261a03b0c06c3c0491f80197a300ca646c5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -2,7 +2,7 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_feature::{Features, GateIssue};\n use rustc_session::parse::{feature_err, feature_err_issue};\n@@ -577,6 +577,32 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n     }\n \n+    fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n+        if let ast::StmtKind::Semi(expr) = &stmt.kind\n+            && let ast::ExprKind::Assign(lhs, _, _) = &expr.kind\n+            && let ast::ExprKind::Type(..) = lhs.kind\n+            && self.sess.parse_sess.span_diagnostic.err_count() == 0\n+            && !self.features.type_ascription\n+            && !lhs.span.allows_unstable(sym::type_ascription)\n+        {\n+            // When we encounter a statement of the form `foo: Ty = val;`, this will emit a type\n+            // ascription error, but the likely intention was to write a `let` statement. (#78907).\n+            feature_err_issue(\n+                &self.sess.parse_sess,\n+                sym::type_ascription,\n+                lhs.span,\n+                GateIssue::Language,\n+                \"type ascription is experimental\",\n+            ).span_suggestion_verbose(\n+                lhs.span.shrink_to_lo(),\n+                \"you might have meant to introduce a new binding\",\n+                \"let \".to_string(),\n+                Applicability::MachineApplicable,\n+            ).emit();\n+        }\n+        visit::walk_stmt(self, stmt);\n+    }\n+\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         match e.kind {\n             ast::ExprKind::Box(_) => {\n@@ -795,8 +821,6 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n     // checks if `#![feature]` has been used to enable any lang feature\n     // does not check the same for lib features unless there's at least one\n     // declared lang feature\n-    use rustc_errors::Applicability;\n-\n     if !sess.opts.unstable_features.is_nightly_build() {\n         let lang_features = &sess.features_untracked().declared_lang_features;\n         if lang_features.len() == 0 {"}, {"sha": "8c23756db33130641d24f8611d0aaf33ae7d71fe", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -2736,7 +2736,7 @@ impl<'b, 'v> Visitor<'v> for ConditionVisitor<'b> {\n                                 self.errors.push((\n                                     e.span,\n                                     format!(\n-                                        \"if the `for` loop runs 0 times, {} is not initialized \",\n+                                        \"if the `for` loop runs 0 times, {} is not initialized\",\n                                         self.name\n                                     ),\n                                 ));"}, {"sha": "326dce8011eae6c7c55b335abbad645d64d92a56", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -2267,7 +2267,7 @@ fn add_local_native_libraries(\n                     // be added explicitly if necessary, see the error in `fn link_rlib`) compiled\n                     // as an executable due to `--test`. Use whole-archive implicitly, like before\n                     // the introduction of native lib modifiers.\n-                    || (bundle != Some(false) && sess.opts.test)\n+                    || (whole_archive == None && bundle != Some(false) && sess.opts.test)\n                 {\n                     cmd.link_whole_staticlib(\n                         name,"}, {"sha": "d0d9efe152cc04109799f78aa8df246f6db4a191", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     ///\n     /// This is implemented by first entering a new universe.\n     /// We then replace all bound variables in `sup` with placeholders,\n-    /// and all bound variables in `sup` with inference vars.\n+    /// and all bound variables in `sub` with inference vars.\n     /// We can then just relate the two resulting types as normal.\n     ///\n     /// Note: this is a subtle algorithm. For a full explanation, please see"}, {"sha": "b5cc8038ca44f817ddb6c971224aa5e29fed4625", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -544,9 +544,11 @@ impl Default for FileTimes {\n     fn default() -> Self {\n         // Redox doesn't appear to support `UTIME_OMIT`, so we stub it out here, and always return\n         // an error in `set_times`.\n-        #[cfg(target_os = \"redox\")]\n+        // ESP-IDF does not support `futimens` at all and the behavior for that OS is therefore\n+        // the same as for Redox.\n+        #[cfg(any(target_os = \"redox\", target_os = \"espidf\"))]\n         let omit = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n-        #[cfg(not(target_os = \"redox\"))]\n+        #[cfg(not(any(target_os = \"redox\", target_os = \"espidf\")))]\n         let omit = libc::timespec { tv_sec: 0, tv_nsec: libc::UTIME_OMIT as _ };\n         Self([omit; 2])\n     }\n@@ -1077,8 +1079,10 @@ impl File {\n \n     pub fn set_times(&self, times: FileTimes) -> io::Result<()> {\n         cfg_if::cfg_if! {\n-            if #[cfg(target_os = \"redox\")] {\n+            if #[cfg(any(target_os = \"redox\", target_os = \"espidf\"))] {\n                 // Redox doesn't appear to support `UTIME_OMIT`.\n+                // ESP-IDF does not support `futimens` at all and the behavior for that OS is therefore\n+                // the same as for Redox.\n                 drop(times);\n                 Err(io::const_io_error!(\n                     io::ErrorKind::Unsupported,"}, {"sha": "4d548dbb6387530d98c3bab7a0385f1f9fbed237", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -345,13 +345,6 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n         }\n \n-        if builder.config.llvm_thin_lto {\n-            cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n-            if !target.contains(\"apple\") {\n-                cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n-            }\n-        }\n-\n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space\n         // for the tools. We don't do this on every platform as it doesn't work\n@@ -463,15 +456,8 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n         }\n \n-        if let Some(ref linker) = builder.config.llvm_use_linker {\n-            cfg.define(\"LLVM_USE_LINKER\", linker);\n-        }\n-\n-        if builder.config.llvm_allow_old_toolchain {\n-            cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n-        }\n-\n         configure_cmake(builder, target, &mut cfg, true, ldflags);\n+        configure_llvm(builder, target, &mut cfg);\n \n         for (key, val) in &builder.config.llvm_build_config {\n             cfg.define(key, val);\n@@ -731,6 +717,25 @@ fn configure_cmake(\n     }\n }\n \n+fn configure_llvm(builder: &Builder<'_>, target: TargetSelection, cfg: &mut cmake::Config) {\n+    // ThinLTO is only available when building with LLVM, enabling LLD is required.\n+    // Apple's linker ld64 supports ThinLTO out of the box though, so don't use LLD on Darwin.\n+    if builder.config.llvm_thin_lto {\n+        cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n+        if !target.contains(\"apple\") {\n+            cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n+        }\n+    }\n+\n+    if let Some(ref linker) = builder.config.llvm_use_linker {\n+        cfg.define(\"LLVM_USE_LINKER\", linker);\n+    }\n+\n+    if builder.config.llvm_allow_old_toolchain {\n+        cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n+    }\n+}\n+\n // Adapted from https://github.com/alexcrichton/cc-rs/blob/fba7feded71ee4f63cfe885673ead6d7b4f2f454/src/lib.rs#L2347-L2365\n fn get_var(var_base: &str, host: &str, target: &str) -> Option<OsString> {\n     let kind = if host == target { \"HOST\" } else { \"TARGET\" };\n@@ -794,6 +799,7 @@ impl Step for Lld {\n         }\n \n         configure_cmake(builder, target, &mut cfg, true, ldflags);\n+        configure_llvm(builder, target, &mut cfg);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n@@ -825,10 +831,6 @@ impl Step for Lld {\n             .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n-        if builder.config.llvm_allow_old_toolchain {\n-            cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n-        }\n-\n         // While we're using this horrible workaround to shim the execution of\n         // llvm-config, let's just pile on more. I can't seem to figure out how\n         // to build LLD as a standalone project and also cross-compile it at the"}, {"sha": "5e81db363ee5c1668e5153650521b567c55def06", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -247,30 +247,28 @@ pub(crate) fn clean_middle_const<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::Region<'tcx> {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n-        match **self {\n-            ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n-                if name != kw::UnderscoreLifetime { Some(Lifetime(name)) } else { None }\n-            }\n-            ty::ReEarlyBound(ref data) => {\n-                if data.name != kw::UnderscoreLifetime {\n-                    Some(Lifetime(data.name))\n-                } else {\n-                    None\n-                }\n-            }\n-            ty::ReLateBound(..)\n-            | ty::ReFree(..)\n-            | ty::ReVar(..)\n-            | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n-            | ty::ReErased => {\n-                debug!(\"cannot clean region {:?}\", self);\n+pub(crate) fn clean_middle_region<'tcx>(region: ty::Region<'tcx>) -> Option<Lifetime> {\n+    match *region {\n+        ty::ReStatic => Some(Lifetime::statik()),\n+        ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n+            if name != kw::UnderscoreLifetime { Some(Lifetime(name)) } else { None }\n+        }\n+        ty::ReEarlyBound(ref data) => {\n+            if data.name != kw::UnderscoreLifetime {\n+                Some(Lifetime(data.name))\n+            } else {\n                 None\n             }\n         }\n+        ty::ReLateBound(..)\n+        | ty::ReFree(..)\n+        | ty::ReVar(..)\n+        | ty::RePlaceholder(..)\n+        | ty::ReEmpty(_)\n+        | ty::ReErased => {\n+            debug!(\"cannot clean region {:?}\", region);\n+            None\n+        }\n     }\n }\n \n@@ -321,7 +319,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n             ty::PredicateKind::Trait(pred) => {\n                 clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n             }\n-            ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred, cx),\n+            ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n             ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n             ty::PredicateKind::Projection(pred) => Some(clean_projection_predicate(pred, cx)),\n             ty::PredicateKind::ConstEvaluatable(..) => None,\n@@ -358,7 +356,6 @@ fn clean_poly_trait_predicate<'tcx>(\n \n fn clean_region_outlives_predicate<'tcx>(\n     pred: ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>,\n-    cx: &mut DocContext<'tcx>,\n ) -> Option<WherePredicate> {\n     let ty::OutlivesPredicate(a, b) = pred;\n \n@@ -367,8 +364,10 @@ fn clean_region_outlives_predicate<'tcx>(\n     }\n \n     Some(WherePredicate::RegionPredicate {\n-        lifetime: a.clean(cx).expect(\"failed to clean lifetime\"),\n-        bounds: vec![GenericBound::Outlives(b.clean(cx).expect(\"failed to clean bounds\"))],\n+        lifetime: clean_middle_region(a).expect(\"failed to clean lifetime\"),\n+        bounds: vec![GenericBound::Outlives(\n+            clean_middle_region(b).expect(\"failed to clean bounds\"),\n+        )],\n     })\n }\n \n@@ -384,7 +383,9 @@ fn clean_type_outlives_predicate<'tcx>(\n \n     Some(WherePredicate::BoundPredicate {\n         ty: clean_middle_ty(ty, cx, None),\n-        bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))],\n+        bounds: vec![GenericBound::Outlives(\n+            clean_middle_region(lt).expect(\"failed to clean lifetimes\"),\n+        )],\n         bound_params: Vec::new(),\n     })\n }\n@@ -999,15 +1000,6 @@ impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, bool> for hir::IsAuto {\n-    fn clean(&self, _: &mut DocContext<'tcx>) -> bool {\n-        match *self {\n-            hir::IsAuto::Yes => true,\n-            hir::IsAuto::No => false,\n-        }\n-    }\n-}\n-\n impl<'tcx> Clean<'tcx, Path> for hir::TraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         let path = clean_path(self.path, cx);\n@@ -1597,7 +1589,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n         }\n         ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(clean_middle_ty(mt.ty, cx, None))),\n         ty::Ref(r, ty, mutbl) => BorrowedRef {\n-            lifetime: r.clean(cx),\n+            lifetime: clean_middle_region(r),\n             mutability: mutbl,\n             type_: Box::new(clean_middle_ty(ty, cx, None)),\n         },\n@@ -1644,7 +1636,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n \n             inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n-            let lifetime = reg.clean(cx);\n+            let lifetime = clean_middle_region(*reg);\n             let mut bounds = vec![];\n \n             for did in dids {\n@@ -1710,7 +1702,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                     let trait_ref = match bound_predicate.skip_binder() {\n                         ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n                         ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                            if let Some(r) = reg.clean(cx) {\n+                            if let Some(r) = clean_middle_region(reg) {\n                                 regions.push(GenericBound::Outlives(r));\n                             }\n                             return None;"}, {"sha": "43e71e90a6f5bde9418371a70038e74afd5b18c7", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -2,9 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n-    clean_middle_const, clean_middle_ty, inline, Clean, Crate, ExternalCrate, Generic, GenericArg,\n-    GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path, PathSegment, Primitive,\n-    PrimitiveType, Type, TypeBinding, Visibility,\n+    clean_middle_const, clean_middle_region, clean_middle_ty, inline, Clean, Crate, ExternalCrate,\n+    Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path, PathSegment,\n+    Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -86,7 +86,7 @@ pub(crate) fn substs_to_args<'tcx>(\n         Vec::with_capacity(substs.len().saturating_sub(if skip_first { 1 } else { 0 }));\n     ret_val.extend(substs.iter().filter_map(|kind| match kind.unpack() {\n         GenericArgKind::Lifetime(lt) => {\n-            Some(GenericArg::Lifetime(lt.clean(cx).unwrap_or(Lifetime::elided())))\n+            Some(GenericArg::Lifetime(clean_middle_region(lt).unwrap_or(Lifetime::elided())))\n         }\n         GenericArgKind::Type(_) if skip_first => {\n             skip_first = false;"}, {"sha": "6fb41ff327916a104e3e2afa6192cc227ec40366", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -366,13 +366,15 @@ pub(super) fn write_shared(\n                 .collect::<Vec<_>>();\n             files.sort_unstable();\n             let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n-            let dirs =\n-                if subs.is_empty() { String::new() } else { format!(\",\\\"dirs\\\":[{}]\", subs) };\n+            let dirs = if subs.is_empty() && files.is_empty() {\n+                String::new()\n+            } else {\n+                format!(\",[{}]\", subs)\n+            };\n             let files = files.join(\",\");\n-            let files =\n-                if files.is_empty() { String::new() } else { format!(\",\\\"files\\\":[{}]\", files) };\n+            let files = if files.is_empty() { String::new() } else { format!(\",[{}]\", files) };\n             format!(\n-                \"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n+                \"[\\\"{name}\\\"{dirs}{files}]\",\n                 name = self.elem.to_str().expect(\"invalid osstring conversion\"),\n                 dirs = dirs,\n                 files = files\n@@ -411,18 +413,23 @@ pub(super) fn write_shared(\n         let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n         let make_sources = || {\n             let (mut all_sources, _krates) =\n-                try_err!(collect(&dst, krate.name(cx.tcx()).as_str(), \"sourcesIndex\"), &dst);\n+                try_err!(collect_json(&dst, krate.name(cx.tcx()).as_str()), &dst);\n             all_sources.push(format!(\n-                \"sourcesIndex[\\\"{}\\\"] = {};\",\n+                r#\"\"{}\":{}\"#,\n                 &krate.name(cx.tcx()),\n-                hierarchy.to_json_string()\n+                hierarchy\n+                    .to_json_string()\n+                    // All these `replace` calls are because we have to go through JS string for JSON content.\n+                    .replace('\\\\', r\"\\\\\")\n+                    .replace('\\'', r\"\\'\")\n+                    // We need to escape double quotes for the JSON.\n+                    .replace(\"\\\\\\\"\", \"\\\\\\\\\\\"\")\n             ));\n             all_sources.sort();\n-            Ok(format!(\n-                \"var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n-                all_sources.join(\"\\n\")\n-            )\n-            .into_bytes())\n+            let mut v = String::from(\"var sourcesIndex = JSON.parse('{\\\\\\n\");\n+            v.push_str(&all_sources.join(\",\\\\\\n\"));\n+            v.push_str(\"\\\\\\n}');\\ncreateSourceSidebar();\\n\");\n+            Ok(v.into_bytes())\n         };\n         write_crate(\"source-files.js\", &make_sources)?;\n     }"}, {"sha": "c45d614293a85d64c7c520ee50359730d7645414", "filename": "src/librustdoc/html/static/js/source-script.js", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -12,6 +12,10 @@\n const rootPath = document.getElementById(\"rustdoc-vars\").attributes[\"data-root-path\"].value;\n let oldScrollPosition = 0;\n \n+const NAME_OFFSET = 0;\n+const DIRS_OFFSET = 1;\n+const FILES_OFFSET = 2;\n+\n function closeSidebarIfMobile() {\n     if (window.innerWidth < window.RUSTDOC_MOBILE_BREAKPOINT) {\n         updateLocalStorage(\"source-sidebar-show\", \"false\");\n@@ -24,15 +28,15 @@ function createDirEntry(elem, parent, fullPath, hasFoundFile) {\n \n     dirEntry.className = \"dir-entry\";\n \n-    fullPath += elem[\"name\"] + \"/\";\n+    fullPath += elem[NAME_OFFSET] + \"/\";\n \n-    summary.innerText = elem[\"name\"];\n+    summary.innerText = elem[NAME_OFFSET];\n     dirEntry.appendChild(summary);\n \n     const folders = document.createElement(\"div\");\n     folders.className = \"folders\";\n-    if (elem.dirs) {\n-        for (const dir of elem.dirs) {\n+    if (elem[DIRS_OFFSET]) {\n+        for (const dir of elem[DIRS_OFFSET]) {\n             if (createDirEntry(dir, folders, fullPath, false)) {\n                 dirEntry.open = true;\n                 hasFoundFile = true;\n@@ -43,8 +47,8 @@ function createDirEntry(elem, parent, fullPath, hasFoundFile) {\n \n     const files = document.createElement(\"div\");\n     files.className = \"files\";\n-    if (elem.files) {\n-        for (const file_text of elem.files) {\n+    if (elem[FILES_OFFSET]) {\n+        for (const file_text of elem[FILES_OFFSET]) {\n             const file = document.createElement(\"a\");\n             file.innerText = file_text;\n             file.href = rootPath + \"src/\" + fullPath + file_text + \".html\";\n@@ -125,7 +129,7 @@ function createSourceSidebar() {\n     title.innerText = \"Files\";\n     sidebar.appendChild(title);\n     Object.keys(sourcesIndex).forEach(key => {\n-        sourcesIndex[key].name = key;\n+        sourcesIndex[key][NAME_OFFSET] = key;\n         hasFoundFile = createDirEntry(sourcesIndex[key], sidebar, \"\",\n             hasFoundFile);\n     });"}, {"sha": "967cb065cad1aaeae17d0d20c31911b665b296ea", "filename": "src/test/run-make/native-link-modifier-whole-archive/Makefile", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2FMakefile?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -1,7 +1,7 @@\n # ignore-cross-compile -- compiling C++ code does not work well when cross-compiling\n \n-# This test case makes sure that native libraries are linked with --whole-archive semantics\n-# when the `-bundle,+whole-archive` modifiers are applied to them.\n+# This test case makes sure that native libraries are linked with appropriate semantics\n+# when the `[+-]bundle,[+-]whole-archive` modifiers are applied to them.\n #\n # The test works by checking that the resulting executables produce the expected output,\n # part of which is emitted by otherwise unreferenced C code. If +whole-archive didn't work\n@@ -10,15 +10,28 @@\n \n -include ../../run-make-fulldeps/tools.mk\n \n-all: $(TMPDIR)/$(call BIN,directly_linked) $(TMPDIR)/$(call BIN,indirectly_linked) $(TMPDIR)/$(call BIN,indirectly_linked_via_attr)\n+all: $(TMPDIR)/$(call BIN,directly_linked) \\\n+     $(TMPDIR)/$(call BIN,directly_linked_test_plus_whole_archive) \\\n+     $(TMPDIR)/$(call BIN,directly_linked_test_minus_whole_archive) \\\n+     $(TMPDIR)/$(call BIN,indirectly_linked) \\\n+     $(TMPDIR)/$(call BIN,indirectly_linked_via_attr)\n \t$(call RUN,directly_linked) | $(CGREP) 'static-initializer.directly_linked.'\n+\t$(call RUN,directly_linked_test_plus_whole_archive) --nocapture | $(CGREP) 'static-initializer.'\n+\t$(call RUN,directly_linked_test_minus_whole_archive) --nocapture | $(CGREP) -v 'static-initializer.'\n \t$(call RUN,indirectly_linked) | $(CGREP) 'static-initializer.indirectly_linked.'\n \t$(call RUN,indirectly_linked_via_attr) | $(CGREP) 'static-initializer.native_lib_in_src.'\n \n # Native lib linked directly into executable\n $(TMPDIR)/$(call BIN,directly_linked): $(call NATIVE_STATICLIB,c_static_lib_with_constructor)\n \t$(RUSTC) directly_linked.rs -l static:+whole-archive=c_static_lib_with_constructor\n \n+# Native lib linked into test executable, +whole-archive\n+$(TMPDIR)/$(call BIN,directly_linked_test_plus_whole_archive): $(call NATIVE_STATICLIB,c_static_lib_with_constructor)\n+\t$(RUSTC) directly_linked_test_plus_whole_archive.rs --test -l static:+whole-archive=c_static_lib_with_constructor\n+# Native lib linked into test executable, -whole-archive\n+$(TMPDIR)/$(call BIN,directly_linked_test_minus_whole_archive): $(call NATIVE_STATICLIB,c_static_lib_with_constructor)\n+\t$(RUSTC) directly_linked_test_minus_whole_archive.rs --test -l static:-whole-archive=c_static_lib_with_constructor\n+\n # Native lib linked into RLIB via `-l static:-bundle,+whole-archive`, RLIB linked into executable\n $(TMPDIR)/$(call BIN,indirectly_linked): $(TMPDIR)/librlib_with_cmdline_native_lib.rlib\n \t$(RUSTC) indirectly_linked.rs"}, {"sha": "20ed8d9d4cd1091316e226a696838bedede69b01", "filename": "src/test/run-make/native-link-modifier-whole-archive/directly_linked_test_minus_whole_archive.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_minus_whole_archive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_minus_whole_archive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_minus_whole_archive.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,7 @@\n+use std::io::Write;\n+\n+#[test]\n+fn test_thing() {\n+    print!(\"ran the test\");\n+    std::io::stdout().flush().unwrap();\n+}"}, {"sha": "20ed8d9d4cd1091316e226a696838bedede69b01", "filename": "src/test/run-make/native-link-modifier-whole-archive/directly_linked_test_plus_whole_archive.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_plus_whole_archive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_plus_whole_archive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fnative-link-modifier-whole-archive%2Fdirectly_linked_test_plus_whole_archive.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,7 @@\n+use std::io::Write;\n+\n+#[test]\n+fn test_thing() {\n+    print!(\"ran the test\");\n+    std::io::stdout().flush().unwrap();\n+}"}, {"sha": "fc1a44c3ca04ef4baf5a4757dfc94ce93b8589b9", "filename": "src/test/ui/borrowck/borrowck-for-loop-uninitialized-binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-uninitialized-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-uninitialized-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-uninitialized-binding.stderr?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -4,7 +4,7 @@ error[E0381]: used binding `x` is possibly-uninitialized\n LL |     let mut x: isize;\n    |         ----- binding declared here but left uninitialized\n LL |     for _ in 0..0 { x = 10; }\n-   |              ---- if the `for` loop runs 0 times, `x` is not initialized \n+   |              ---- if the `for` loop runs 0 times, `x` is not initialized\n LL |     return x;\n    |            ^ `x` used here but it is possibly-uninitialized\n "}, {"sha": "9c70bbc85acfab96b5d79c0fdf61647951913308", "filename": "src/test/ui/closures/issue-90871.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    2: n([u8; || 1])\n+    //~^ ERROR cannot find type `n` in this scope\n+    //~| ERROR mismatched types\n+}"}, {"sha": "1e102cc9805bd6879debae5b68465b804caa84af", "filename": "src/test/ui/closures/issue-90871.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,23 @@\n+error[E0412]: cannot find type `n` in this scope\n+  --> $DIR/issue-90871.rs:2:8\n+   |\n+LL |     2: n([u8; || 1])\n+   |        ^ expecting a type here because of type ascription\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-90871.rs:2:15\n+   |\n+LL |     2: n([u8; || 1])\n+   |               ^^^^ expected `usize`, found closure\n+   |\n+   = note: expected type `usize`\n+           found closure `[closure@$DIR/issue-90871.rs:2:15: 2:17]`\n+help: use parentheses to call this closure\n+   |\n+LL |     2: n([u8; (|| 1)()])\n+   |               +    +++\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0412.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "d1787688950ac3498482e7f75043efbd2a86a870", "filename": "src/test/ui/type/missing-let-in-binding.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.fixed?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let mut _foo: i32 = 1;\n+    let _foo: i32 = 4; //~ ERROR type ascription is experimental\n+}"}, {"sha": "ca42f2e6eaccca3aace1e76edf3a849dc93b6f84", "filename": "src/test/ui/type/missing-let-in-binding.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.rs?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let mut _foo: i32 = 1;\n+    _foo: i32 = 4; //~ ERROR type ascription is experimental\n+}"}, {"sha": "12759c5096e233fae769f67977b585be0beeabf1", "filename": "src/test/ui/type/missing-let-in-binding.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ad56350cd3d7f8260c44433800f687f8e0ede28/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fmissing-let-in-binding.stderr?ref=1ad56350cd3d7f8260c44433800f687f8e0ede28", "patch": "@@ -0,0 +1,16 @@\n+error[E0658]: type ascription is experimental\n+  --> $DIR/missing-let-in-binding.rs:4:5\n+   |\n+LL |     _foo: i32 = 4;\n+   |     ^^^^^^^^^\n+   |\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let _foo: i32 = 4;\n+   |     +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}