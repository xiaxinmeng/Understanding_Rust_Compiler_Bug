{"sha": "12d82687cd600ec81bf3027661135e5f0d4ad4bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDgyNjg3Y2Q2MDBlYzgxYmYzMDI3NjYxMTM1ZTVmMGQ0YWQ0YmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-14T14:29:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-14T14:29:22Z"}, "message": "Merge #4273\n\n4273: Trigger add_vis assist on paths/record fields as well r=flodiebold a=TimoFreiberg\n\nResolves #4037.\r\n\r\n- [x] Function defs\r\n- [x] ADT defs\r\n- [x] Enum variants\r\n- [x] Consts\r\n- [x] Statics\r\n- [x] Traits\r\n- [x] Type aliases\r\n- [x] Modules\r\n- [x] Record fields (using different implementation)\r\n    - [x] struct fields\r\n    - [x] enum variant fields\r\n    - :x:  union fields (`Semantics::resolve_record_field` seems to not work for union fields, so I think this can be handled in a future PR)\r\n- [x] More tests? \r\n- [x] Improve test fixture code and documentation a bit (see [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/resolve_path.20between.20fixture.20files))\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>", "tree": {"sha": "851e7be2f0fdd6239d95e9a8f2773b4e2b51dc66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/851e7be2f0fdd6239d95e9a8f2773b4e2b51dc66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d82687cd600ec81bf3027661135e5f0d4ad4bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJevVXCCRBK7hj4Ov3rIwAAdHIIAFfCUWMkiPMiTPvpZtXSoMsR\nO+bddVtUepxrwAUvr4NV5yK1GGuMb92Gz2/viFtbeenVqiyq2rdKbSq8bzwcQ29a\nWuZmRReZ5nqp159cVBjYxjjwEjtMTMU9NL7eCayZTmz+3HKHViXygrI63aI/SKKK\nVcx4aeMm7kISeZMHsYwoa84DBSsLb9eOqX+fkKmQo5lIr48z/KxBqZNVgBdn33+v\nBjog7bDFeheohyOwjybtKK2p8XXbcGyXigf1gcY4vH9LIqUhse0FPK7OwYIQ0Dp7\nzoT496cMukaaKbwgWqKjIWgTwF8SQPipcVse0mYK00rgV2V24KpAvTVjpQgBnG8=\n=f8Ga\n-----END PGP SIGNATURE-----\n", "payload": "tree 851e7be2f0fdd6239d95e9a8f2773b4e2b51dc66\nparent 87470e8f13252c12f3720a9d4235e7e5242b48dc\nparent e17193dc510b4a4e238db28c529289a1f4beccff\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589466562 +0000\ncommitter GitHub <noreply@github.com> 1589466562 +0000\n\nMerge #4273\n\n4273: Trigger add_vis assist on paths/record fields as well r=flodiebold a=TimoFreiberg\n\nResolves #4037.\r\n\r\n- [x] Function defs\r\n- [x] ADT defs\r\n- [x] Enum variants\r\n- [x] Consts\r\n- [x] Statics\r\n- [x] Traits\r\n- [x] Type aliases\r\n- [x] Modules\r\n- [x] Record fields (using different implementation)\r\n    - [x] struct fields\r\n    - [x] enum variant fields\r\n    - :x:  union fields (`Semantics::resolve_record_field` seems to not work for union fields, so I think this can be handled in a future PR)\r\n- [x] More tests? \r\n- [x] Improve test fixture code and documentation a bit (see [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/resolve_path.20between.20fixture.20files))\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d82687cd600ec81bf3027661135e5f0d4ad4bd", "html_url": "https://github.com/rust-lang/rust/commit/12d82687cd600ec81bf3027661135e5f0d4ad4bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d82687cd600ec81bf3027661135e5f0d4ad4bd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87470e8f13252c12f3720a9d4235e7e5242b48dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/87470e8f13252c12f3720a9d4235e7e5242b48dc", "html_url": "https://github.com/rust-lang/rust/commit/87470e8f13252c12f3720a9d4235e7e5242b48dc"}, {"sha": "e17193dc510b4a4e238db28c529289a1f4beccff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e17193dc510b4a4e238db28c529289a1f4beccff", "html_url": "https://github.com/rust-lang/rust/commit/e17193dc510b4a4e238db28c529289a1f4beccff"}], "stats": {"total": 536, "additions": 532, "deletions": 4}, "files": [{"sha": "40cf4b42299fa8a3e24a9f8b72f49601ac86b8f3", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 515, "deletions": 1, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=12d82687cd600ec81bf3027661135e5f0d4ad4bd", "patch": "@@ -5,11 +5,14 @@ use ra_syntax::{\n         ATTR, COMMENT, CONST_DEF, ENUM_DEF, FN_DEF, MODULE, STRUCT_DEF, TRAIT_DEF, VISIBILITY,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextSize, T,\n+    SyntaxNode, TextRange, TextSize, T,\n };\n+\n+use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n use test_utils::tested_by;\n \n use crate::{AssistContext, AssistId, Assists};\n+use ra_db::FileId;\n \n // Assist: change_visibility\n //\n@@ -27,6 +30,8 @@ pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return change_vis(acc, vis);\n     }\n     add_vis(acc, ctx)\n+        .or_else(|| add_vis_to_referenced_module_def(acc, ctx))\n+        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n }\n \n fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -72,6 +77,143 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     })\n }\n \n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let path_res = ctx.sema.resolve_path(&path)?;\n+    let def = match path_res {\n+        PathResolution::Def(def) => def,\n+        _ => return None,\n+    };\n+\n+    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n+    let target_module = def.module(ctx.db)?;\n+\n+    let vis = target_module.visibility_of(ctx.db, &def)?;\n+    if vis.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    };\n+\n+    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+\n+    let assist_label = match target_name {\n+        None => format!(\"Change visibility to {}\", missing_visibility),\n+        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+    };\n+\n+    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset);\n+    })\n+}\n+\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n+\n+    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let visibility = record_field_def.visibility(ctx.db);\n+    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    }\n+\n+    let parent = record_field_def.parent_def(ctx.db);\n+    let parent_name = parent.name(ctx.db);\n+    let target_module = parent.module(ctx.db);\n+\n+    let in_file_source = record_field_def.source(ctx.db);\n+    let (offset, target) = match in_file_source.value {\n+        hir::FieldSource::Named(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+        hir::FieldSource::Pos(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+    };\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+    let target_file = in_file_source.file_id.original_file(ctx.db);\n+\n+    let target_name = record_field_def.name(ctx.db);\n+    let assist_label =\n+        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+\n+    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset)\n+    })\n+}\n+\n+fn target_data_for_def(\n+    db: &dyn HirDatabase,\n+    def: hir::ModuleDef,\n+) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+    fn offset_target_and_file_id<S, Ast>(\n+        db: &dyn HirDatabase,\n+        x: S,\n+    ) -> (TextSize, TextRange, FileId)\n+    where\n+        S: HasSource<Ast = Ast>,\n+        Ast: AstNode,\n+    {\n+        let source = x.source(db);\n+        let in_file_syntax = source.syntax();\n+        let file_id = in_file_syntax.file_id;\n+        let syntax = in_file_syntax.value;\n+        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+    }\n+\n+    let target_name;\n+    let (offset, target, target_file) = match def {\n+        hir::ModuleDef::Function(f) => {\n+            target_name = Some(f.name(db));\n+            offset_target_and_file_id(db, f)\n+        }\n+        hir::ModuleDef::Adt(adt) => {\n+            target_name = Some(adt.name(db));\n+            match adt {\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n+            }\n+        }\n+        hir::ModuleDef::Const(c) => {\n+            target_name = c.name(db);\n+            offset_target_and_file_id(db, c)\n+        }\n+        hir::ModuleDef::Static(s) => {\n+            target_name = s.name(db);\n+            offset_target_and_file_id(db, s)\n+        }\n+        hir::ModuleDef::Trait(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::TypeAlias(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::Module(m) => {\n+            target_name = m.name(db);\n+            let in_file_source = m.declaration_source(db)?;\n+            let file_id = in_file_source.file_id.original_file(db.upcast());\n+            let syntax = in_file_source.value.syntax();\n+            (vis_offset(syntax), syntax.text_range(), file_id)\n+        }\n+        // Enum variants can't be private, we can't modify builtin types\n+        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n+    };\n+\n+    Some((offset, target, target_file, target_name))\n+}\n+\n fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .skip_while(|it| match it.kind() {\n@@ -191,6 +333,378 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    fn change_visibility_of_fn_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+            r\"mod foo { <|>pub(crate) fn foo() {} }\n+              fn main() { foo::foo() } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+        )\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_adt_in_submodule_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) struct Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) enum Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) union Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_adt_in_other_file_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"\n+              //- /main.rs\n+              mod foo;\n+              fn main() { foo::Foo<|> }\n+\n+              //- /foo.rs\n+              struct Foo;\n+              \",\n+            r\"<|>pub(crate) struct Foo;\n+\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_struct_field_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { pub struct Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub struct Foo { <|>pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { bar: () }\n+              \",\n+            r\"pub struct Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_enum_variant_field_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n+              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n+            r\"mod foo { pub enum Foo { Bar { <|>pub(crate) bar: () } } }\n+              fn main() { foo::Foo::Bar { bar: () }; } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo::Bar { <|>bar: () }; }\n+              //- /foo.rs\n+              pub enum Foo { Bar { bar: () } }\n+              \",\n+            r\"pub enum Foo { Bar { <|>pub(crate) bar: () } }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n+    fn change_visibility_of_union_field_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { pub union Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub union Foo { <|>pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { bar: () }\n+              \",\n+            r\"pub union Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub union Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_enum_variants() {\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub enum Foo {Foo1} }\n+              fn main() { foo::Foo::Foo1<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_const_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { <|>pub(crate) const FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_static_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { <|>pub(crate) static FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_trait_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::<|>Foo; } \",\n+            r\"mod foo { <|>pub(crate) trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_type_alias_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+            r\"mod foo { <|>pub(crate) type Foo = (); }\n+              fn main() { let x: foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_module_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { mod bar { fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+            r\"mod foo { <|>pub(crate) mod bar { fn bar() {} } }\n+              fn main() { foo::bar::bar(); } \",\n+        );\n+\n+        check_assist(\n+            change_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar {\n+                pub fn baz() {}\n+            }\n+            \",\n+            r\"<|>pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\n+\",\n+        );\n+\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub mod bar { pub fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_inline_module_in_other_file_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar;\n+\n+            //- /foo/bar.rs\n+            pub fn baz() {}\n+            }\n+            \",\n+            r\"<|>pub(crate) mod bar;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_module_declaration_in_other_file_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"//- /main.rs\n+              mod foo;\n+              fn main() { foo::bar<|>>::baz(); }\n+\n+              //- /foo.rs\n+              mod bar {\n+                  pub fn baz() {}\n+              }\",\n+            r\"<|>pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME handle reexports properly\n+    fn change_visibility_of_reexport() {\n+        check_assist(\n+            change_visibility,\n+            r\"\n+            mod foo {\n+                use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz<|>\n+            \",\n+            r\"\n+            mod foo {\n+                <|>pub(crate) use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn adds_pub_when_target_is_in_another_crate() {\n+        check_assist(\n+            change_visibility,\n+            r\"//- /main.rs crate:a deps:foo\n+              foo::Bar<|>\n+              //- /lib.rs crate:foo\n+              struct Bar;\",\n+            r\"<|>pub struct Bar;\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn change_visibility_target() {\n         check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");"}, {"sha": "f8f7670919c28d1f886df868aeab9f13adbdede6", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=12d82687cd600ec81bf3027661135e5f0d4ad4bd", "patch": "@@ -2,7 +2,7 @@\n //! A fixture without metadata is parsed into a single source file.\n //! Use this to test functionality local to one file.\n //!\n-//! Example:\n+//! Simple Example:\n //! ```\n //! r#\"\n //! fn main() {\n@@ -15,7 +15,7 @@\n //! The basic form is specifying filenames,\n //! which is also how to define multiple files in a single test fixture\n //!\n-//! Example:\n+//! Example using two files in the same crate:\n //! ```\n //! \"\n //! //- /main.rs\n@@ -29,14 +29,28 @@\n //! \"\n //! ```\n //!\n+//! Example using two crates with one file each, with one crate depending on the other:\n+//! ```\n+//! r#\"\n+//! //- /main.rs crate:a deps:b\n+//! fn main() {\n+//!     b::foo();\n+//! }\n+//! //- /lib.rs crate:b\n+//! pub fn b() {\n+//!     println!(\"Hello World\")\n+//! }\n+//! \"#\n+//! ```\n+//!\n //! Metadata allows specifying all settings and variables\n //! that are available in a real rust project:\n //! - crate names via `crate:cratename`\n //! - dependencies via `deps:dep1,dep2`\n //! - configuration settings via `cfg:dbg=false,opt_level=2`\n //! - environment variables via `env:PATH=/bin,RUST_LOG=debug`\n //!\n-//! Example:\n+//! Example using all available metadata:\n //! ```\n //! \"\n //! //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo"}]}