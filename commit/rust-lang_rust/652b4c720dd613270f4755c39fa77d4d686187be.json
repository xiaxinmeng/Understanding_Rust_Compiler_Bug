{"sha": "652b4c720dd613270f4755c39fa77d4d686187be", "node_id": "C_kwDOAAsO6NoAKDY1MmI0YzcyMGRkNjEzMjcwZjQ3NTVjMzlmYTc3ZDRkNjg2MTg3YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T22:07:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T22:07:58Z"}, "message": "Auto merge of #10616 - y21:missing_field_in_debug, r=Alexendoo\n\nnew lint: `missing_fields_in_debug`\n\nFixes #10429\n\nThis PR adds a new lint that looks for manual `Debug` implementations that do not \"use\" all of the fields.\nThis often happens when adding a new field to a struct.\nIt also acts as a style lint in case leaving out a field was intentional. In that case, it's preferred to use [`DebugStruct::finish_non_exhaustive`](https://doc.rust-lang.org/stable/std/fmt/struct.DebugStruct.html#method.finish_non_exhaustive), which indicates that there are more fields that were explicitly not shown.\n\n```\nchangelog: [`missing_fields_in_debug`]: missing fields in manual `Debug` implementation\n```", "tree": {"sha": "90a4f10494e289dd51f9bf3277ed6ef6b81aabbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90a4f10494e289dd51f9bf3277ed6ef6b81aabbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/652b4c720dd613270f4755c39fa77d4d686187be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/652b4c720dd613270f4755c39fa77d4d686187be", "html_url": "https://github.com/rust-lang/rust/commit/652b4c720dd613270f4755c39fa77d4d686187be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/652b4c720dd613270f4755c39fa77d4d686187be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "594a2cba93d8c78f522bdb15de6aeebeebf50a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/594a2cba93d8c78f522bdb15de6aeebeebf50a8a", "html_url": "https://github.com/rust-lang/rust/commit/594a2cba93d8c78f522bdb15de6aeebeebf50a8a"}, {"sha": "a859b0e6dfae12169d6a239e2a63aef8227e1dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/a859b0e6dfae12169d6a239e2a63aef8227e1dce", "html_url": "https://github.com/rust-lang/rust/commit/a859b0e6dfae12169d6a239e2a63aef8227e1dce"}], "stats": {"total": 504, "additions": 504, "deletions": 0}, "files": [{"sha": "8b609b47d8192424898cdd006a6b138a7e11081b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -4963,6 +4963,7 @@ Released 2018-09-13\n [`missing_docs_in_private_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n [`missing_enforced_import_renames`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_enforced_import_renames\n [`missing_errors_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc\n+[`missing_fields_in_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_fields_in_debug\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`missing_panics_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc"}, {"sha": "a7067d8b86aafb1a651affab9d40e552b2703903", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -430,6 +430,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::missing_const_for_fn::MISSING_CONST_FOR_FN_INFO,\n     crate::missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS_INFO,\n     crate::missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES_INFO,\n+    crate::missing_fields_in_debug::MISSING_FIELDS_IN_DEBUG_INFO,\n     crate::missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS_INFO,\n     crate::missing_trait_methods::MISSING_TRAIT_METHODS_INFO,\n     crate::mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION_INFO,"}, {"sha": "a0a89e4967b8fd16784b0c9e908c2da14ca80592", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -203,6 +203,7 @@ mod missing_assert_message;\n mod missing_const_for_fn;\n mod missing_doc;\n mod missing_enforced_import_rename;\n+mod missing_fields_in_debug;\n mod missing_inline;\n mod missing_trait_methods;\n mod mixed_read_write_in_expression;\n@@ -994,6 +995,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(ref_patterns::RefPatterns));\n     store.register_late_pass(|_| Box::new(default_constructed_unit_structs::DefaultConstructedUnitStructs));\n     store.register_early_pass(|| Box::new(needless_else::NeedlessElse));\n+    store.register_late_pass(|_| Box::new(missing_fields_in_debug::MissingFieldsInDebug));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "8332d638f92abfdec22ab2f117b215e8f1642482", "filename": "clippy_lints/src/missing_fields_in_debug.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -0,0 +1,234 @@\n+use std::ops::ControlFlow;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then,\n+    is_path_lang_item, paths,\n+    ty::match_type,\n+    visitors::{for_each_expr, Visitable},\n+};\n+use rustc_ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::Block;\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    Expr, ImplItemKind, LangItem, Node,\n+};\n+use rustc_hir::{ExprKind, Impl, ItemKind, QPath, TyKind};\n+use rustc_hir::{ImplItem, Item, VariantData};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_middle::ty::TypeckResults;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for manual [`core::fmt::Debug`](https://doc.rust-lang.org/core/fmt/trait.Debug.html) implementations that do not use all fields.\n+    ///\n+    /// ### Why is this bad?\n+    /// A common mistake is to forget to update manual `Debug` implementations when adding a new field\n+    /// to a struct or a new variant to an enum.\n+    ///\n+    /// At the same time, it also acts as a style lint to suggest using [`core::fmt::DebugStruct::finish_non_exhaustive`](https://doc.rust-lang.org/core/fmt/struct.DebugStruct.html#method.finish_non_exhaustive)\n+    /// for the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details).\n+    ///\n+    /// ### Known problems\n+    /// This lint works based on the `DebugStruct` helper types provided by the `Formatter`,\n+    /// so this won't detect `Debug` impls that use the `write!` macro.\n+    /// Oftentimes there is more logic to a `Debug` impl if it uses `write!` macro, so it tries\n+    /// to be on the conservative side and not lint in those cases in an attempt to prevent false positives.\n+    ///\n+    /// This lint also does not look through function calls, so calling a function does not consider fields\n+    /// used inside of that function as used by the `Debug` impl.\n+    ///\n+    /// Lastly, it also ignores tuple structs as their `DebugTuple` formatter does not have a `finish_non_exhaustive`\n+    /// method, as well as enums because their exhaustiveness is already checked by the compiler when matching on the enum,\n+    /// making it much less likely to accidentally forget to update the `Debug` impl when adding a new variant.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::fmt;\n+    /// struct Foo {\n+    ///     data: String,\n+    ///     // implementation detail\n+    ///     hidden_data: i32\n+    /// }\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         formatter\n+    ///             .debug_struct(\"Foo\")\n+    ///             .field(\"data\", &self.data)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    /// struct Foo {\n+    ///     data: String,\n+    ///     // implementation detail\n+    ///     hidden_data: i32\n+    /// }\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         formatter\n+    ///             .debug_struct(\"Foo\")\n+    ///             .field(\"data\", &self.data)\n+    ///             .finish_non_exhaustive()\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub MISSING_FIELDS_IN_DEBUG,\n+    pedantic,\n+    \"missing fields in manual `Debug` implementation\"\n+}\n+declare_lint_pass!(MissingFieldsInDebug => [MISSING_FIELDS_IN_DEBUG]);\n+\n+fn report_lints(cx: &LateContext<'_>, span: Span, span_notes: Vec<(Span, &'static str)>) {\n+    span_lint_and_then(\n+        cx,\n+        MISSING_FIELDS_IN_DEBUG,\n+        span,\n+        \"manual `Debug` impl does not include all fields\",\n+        |diag| {\n+            for (span, note) in span_notes {\n+                diag.span_note(span, note);\n+            }\n+            diag.help(\"consider including all fields in this `Debug` impl\")\n+                .help(\"consider calling `.finish_non_exhaustive()` if you intend to ignore fields\");\n+        },\n+    );\n+}\n+\n+/// Checks if we should lint in a block of code\n+///\n+/// The way we check for this condition is by checking if there is\n+/// a call to `Formatter::debug_struct` but no call to `.finish_non_exhaustive()`.\n+fn should_lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    block: impl Visitable<'tcx>,\n+) -> bool {\n+    // Is there a call to `DebugStruct::finish_non_exhaustive`? Don't lint if there is.\n+    let mut has_finish_non_exhaustive = false;\n+    // Is there a call to `DebugStruct::debug_struct`? Do lint if there is.\n+    let mut has_debug_struct = false;\n+\n+    for_each_expr(block, |expr| {\n+        if let ExprKind::MethodCall(path, recv, ..) = &expr.kind {\n+            let recv_ty = typeck_results.expr_ty(recv).peel_refs();\n+\n+            if path.ident.name == sym::debug_struct && match_type(cx, recv_ty, &paths::FORMATTER) {\n+                has_debug_struct = true;\n+            } else if path.ident.name == sym!(finish_non_exhaustive) && match_type(cx, recv_ty, &paths::DEBUG_STRUCT) {\n+                has_finish_non_exhaustive = true;\n+            }\n+        }\n+        ControlFlow::<!, _>::Continue(())\n+    });\n+\n+    !has_finish_non_exhaustive && has_debug_struct\n+}\n+\n+/// Checks if the given expression is a call to `DebugStruct::field`\n+/// and the first argument to it is a string literal and if so, returns it\n+///\n+/// Example: `.field(\"foo\", ....)` returns `Some(\"foo\")`\n+fn as_field_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    expr: &Expr<'_>,\n+) -> Option<Symbol> {\n+    if let ExprKind::MethodCall(path, recv, [debug_field, _], _) = &expr.kind\n+        && let recv_ty = typeck_results.expr_ty(recv).peel_refs()\n+        && match_type(cx, recv_ty, &paths::DEBUG_STRUCT)\n+        && path.ident.name == sym::field\n+        && let ExprKind::Lit(lit) = &debug_field.kind\n+        && let LitKind::Str(sym, ..) = lit.node\n+    {\n+        Some(sym)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Attempts to find unused fields assuming that the item is a struct\n+fn check_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    block: &'tcx Block<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    item: &'tcx Item<'tcx>,\n+    data: &VariantData<'_>,\n+) {\n+    // Is there a \"direct\" field access anywhere (i.e. self.foo)?\n+    // We don't want to lint if there is not, because the user might have\n+    // a newtype struct and use fields from the wrapped type only.\n+    let mut has_direct_field_access = false;\n+    let mut field_accesses = FxHashSet::default();\n+\n+    for_each_expr(block, |expr| {\n+        if let ExprKind::Field(target, ident) = expr.kind\n+            && let target_ty = typeck_results.expr_ty_adjusted(target).peel_refs()\n+            && target_ty == self_ty\n+        {\n+            field_accesses.insert(ident.name);\n+            has_direct_field_access = true;\n+        } else if let Some(sym) = as_field_call(cx, typeck_results, expr) {\n+            field_accesses.insert(sym);\n+        }\n+        ControlFlow::<!, _>::Continue(())\n+    });\n+\n+    let span_notes = data\n+        .fields()\n+        .iter()\n+        .filter_map(|field| {\n+            if field_accesses.contains(&field.ident.name) || is_path_lang_item(cx, field.ty, LangItem::PhantomData) {\n+                None\n+            } else {\n+                Some((field.span, \"this field is unused\"))\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    // only lint if there's also at least one direct field access to allow patterns\n+    // where one might have a newtype struct and uses fields from the wrapped type\n+    if !span_notes.is_empty() && has_direct_field_access {\n+        report_lints(cx, item.span, span_notes);\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for MissingFieldsInDebug {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx rustc_hir::Item<'tcx>) {\n+        // is this an `impl Debug for X` block?\n+        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), self_ty, items, .. }) = item.kind\n+            && let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res\n+            && let TyKind::Path(QPath::Resolved(_, self_path)) = &self_ty.kind\n+            && cx.match_def_path(trait_def_id, &[sym::core, sym::fmt, sym::Debug])\n+            // don't trigger if this impl was derived\n+            && !cx.tcx.has_attr(item.owner_id, sym::automatically_derived)\n+            && !item.span.from_expansion()\n+            // find `Debug::fmt` function\n+            && let Some(fmt_item) = items.iter().find(|i| i.ident.name == sym::fmt)\n+            && let ImplItem { kind: ImplItemKind::Fn(_, body_id), .. } = cx.tcx.hir().impl_item(fmt_item.id)\n+            && let body = cx.tcx.hir().body(*body_id)\n+            && let ExprKind::Block(block, _) = body.value.kind\n+            // inspect `self`\n+            && let self_ty = cx.tcx.type_of(self_path.res.def_id()).0.peel_refs()\n+            && let Some(self_adt) = self_ty.ty_adt_def()\n+            && let Some(self_def_id) = self_adt.did().as_local()\n+            && let Some(Node::Item(self_item)) = cx.tcx.hir().find_by_def_id(self_def_id)\n+            // NB: can't call cx.typeck_results() as we are not in a body\n+            && let typeck_results = cx.tcx.typeck_body(*body_id)\n+            && should_lint(cx, typeck_results, block)\n+        {\n+            // we intentionally only lint structs, see lint description\n+            if let ItemKind::Struct(data, _) = &self_item.kind {\n+                check_struct(cx, typeck_results, block, self_ty, item, data);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3a2b0a72a3de0f3981985ee4c2ca02c04eae7d62", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -163,3 +163,5 @@ pub const VEC_IS_EMPTY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"is_empty\"];\n pub const VEC_POP: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"pop\"];\n pub const OPTION_UNWRAP: [&str; 4] = [\"core\", \"option\", \"Option\", \"unwrap\"];\n pub const OPTION_EXPECT: [&str; 4] = [\"core\", \"option\", \"Option\", \"expect\"];\n+pub const FORMATTER: [&str; 3] = [\"core\", \"fmt\", \"Formatter\"];\n+pub const DEBUG_STRUCT: [&str; 4] = [\"core\", \"fmt\", \"builders\", \"DebugStruct\"];"}, {"sha": "c156d394eceaaf8c045fe9a551f1b698d4b22b60", "filename": "tests/ui/missing_fields_in_debug.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/tests%2Fui%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/tests%2Fui%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.rs?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -0,0 +1,191 @@\n+#![allow(unused)]\n+#![warn(clippy::missing_fields_in_debug)]\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::ops::Deref;\n+\n+struct NamedStruct1Ignored {\n+    data: u8,\n+    hidden: u32,\n+}\n+\n+impl fmt::Debug for NamedStruct1Ignored {\n+    // unused field: hidden\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStruct1Ignored\")\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n+struct NamedStructMultipleIgnored {\n+    data: u8,\n+    hidden: u32,\n+    hidden2: String,\n+    hidden3: Vec<Vec<i32>>,\n+    hidden4: ((((u8), u16), u32), u64),\n+}\n+\n+impl fmt::Debug for NamedStructMultipleIgnored {\n+    // unused fields: hidden, hidden2, hidden4\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStructMultipleIgnored\")\n+            .field(\"data\", &self.data)\n+            .field(\"hidden3\", &self.hidden3)\n+            .finish()\n+    }\n+}\n+\n+struct Unit;\n+\n+// ok\n+impl fmt::Debug for Unit {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.debug_struct(\"Unit\").finish()\n+    }\n+}\n+\n+struct UnnamedStruct1Ignored(String);\n+\n+impl fmt::Debug for UnnamedStruct1Ignored {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.debug_tuple(\"UnnamedStruct1Ignored\").finish()\n+    }\n+}\n+\n+struct UnnamedStructMultipleIgnored(String, Vec<u8>, i32);\n+\n+// tuple structs are not linted\n+impl fmt::Debug for UnnamedStructMultipleIgnored {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_tuple(\"UnnamedStructMultipleIgnored\")\n+            .field(&self.1)\n+            .finish()\n+    }\n+}\n+\n+struct NamedStructNonExhaustive {\n+    a: u8,\n+    b: String,\n+}\n+\n+// ok\n+impl fmt::Debug for NamedStructNonExhaustive {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStructNonExhaustive\")\n+            .field(\"a\", &self.a)\n+            .finish_non_exhaustive() // should not warn here\n+    }\n+}\n+\n+struct MultiExprDebugImpl {\n+    a: u8,\n+    b: String,\n+}\n+\n+// ok\n+impl fmt::Debug for MultiExprDebugImpl {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut f = formatter.debug_struct(\"MultiExprDebugImpl\");\n+        f.field(\"a\", &self.a);\n+        f.finish()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct DerivedStruct {\n+    a: u8,\n+    b: i32,\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1166846953\n+\n+struct Inner {\n+    a: usize,\n+    b: usize,\n+}\n+\n+struct HasInner {\n+    inner: Inner,\n+}\n+\n+impl HasInner {\n+    fn get(&self) -> &Inner {\n+        &self.inner\n+    }\n+}\n+\n+impl fmt::Debug for HasInner {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let inner = self.get();\n+\n+        f.debug_struct(\"HasInner\")\n+            .field(\"a\", &inner.a)\n+            .field(\"b\", &inner.b)\n+            .finish()\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1170306053\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+impl fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Foo\").field(\"a\", &self.a).field(\"b\", &()).finish()\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1175473620\n+mod comment1175473620 {\n+    use super::*;\n+\n+    struct Inner {\n+        a: usize,\n+        b: usize,\n+    }\n+    struct Wrapper(Inner);\n+\n+    impl Deref for Wrapper {\n+        type Target = Inner;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+\n+    impl fmt::Debug for Wrapper {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Wrapper\")\n+                .field(\"a\", &self.a)\n+                .field(\"b\", &self.b)\n+                .finish()\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1175488757\n+// PhantomData is an exception and does not need to be included\n+struct WithPD {\n+    a: u8,\n+    b: u8,\n+    c: PhantomData<String>,\n+}\n+\n+impl fmt::Debug for WithPD {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"WithPD\")\n+            .field(\"a\", &self.a)\n+            .field(\"b\", &self.b)\n+            .finish()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ef9d02abab7dbf1ff2bee7120560bc5dadf030b3", "filename": "tests/ui/missing_fields_in_debug.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/652b4c720dd613270f4755c39fa77d4d686187be/tests%2Fui%2Fmissing_fields_in_debug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/652b4c720dd613270f4755c39fa77d4d686187be/tests%2Fui%2Fmissing_fields_in_debug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.stderr?ref=652b4c720dd613270f4755c39fa77d4d686187be", "patch": "@@ -0,0 +1,73 @@\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:13:1\n+   |\n+LL | / impl fmt::Debug for NamedStruct1Ignored {\n+LL | |     // unused field: hidden\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         formatter\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:10:5\n+   |\n+LL |     hidden: u32,\n+   |     ^^^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+   = note: `-D clippy::missing-fields-in-debug` implied by `-D warnings`\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:31:1\n+   |\n+LL | / impl fmt::Debug for NamedStructMultipleIgnored {\n+LL | |     // unused fields: hidden, hidden2, hidden4\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         formatter\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:25:5\n+   |\n+LL |     hidden: u32,\n+   |     ^^^^^^^^^^^\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:26:5\n+   |\n+LL |     hidden2: String,\n+   |     ^^^^^^^^^^^^^^^\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:28:5\n+   |\n+LL |     hidden4: ((((u8), u16), u32), u64),\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:92:1\n+   |\n+LL | / impl fmt::Debug for MultiExprDebugImpl {\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         let mut f = formatter.debug_struct(\"MultiExprDebugImpl\");\n+LL | |         f.field(\"a\", &self.a);\n+LL | |         f.finish()\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:88:5\n+   |\n+LL |     b: String,\n+   |     ^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: aborting due to 3 previous errors\n+"}]}