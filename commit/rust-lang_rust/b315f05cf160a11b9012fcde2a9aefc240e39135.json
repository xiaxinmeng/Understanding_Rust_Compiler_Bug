{"sha": "b315f05cf160a11b9012fcde2a9aefc240e39135", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMTVmMDVjZjE2MGExMWI5MDEyZmNkZTJhOWFlZmMyNDBlMzkxMzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-22T14:32:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-22T14:32:10Z"}, "message": "Move data to a single file", "tree": {"sha": "ced460568980b0bd71ad95267c89f320ce324ba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ced460568980b0bd71ad95267c89f320ce324ba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b315f05cf160a11b9012fcde2a9aefc240e39135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b315f05cf160a11b9012fcde2a9aefc240e39135", "html_url": "https://github.com/rust-lang/rust/commit/b315f05cf160a11b9012fcde2a9aefc240e39135", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b315f05cf160a11b9012fcde2a9aefc240e39135/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "html_url": "https://github.com/rust-lang/rust/commit/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14"}], "stats": {"total": 467, "additions": 213, "deletions": 254}, "files": [{"sha": "b73e0d0a7c855e86cea2abafd13eae448fb13585", "filename": "crates/ra_hir_def/src/data.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=b315f05cf160a11b9012fcde2a9aefc240e39135", "patch": "@@ -0,0 +1,206 @@\n+use std::sync::Arc;\n+\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    AstId,\n+};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+\n+use crate::{\n+    db::DefDatabase2,\n+    type_ref::{Mutability, TypeRef},\n+    AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionId, FunctionLoc, HasSource, ImplId,\n+    Intern, Lookup, TraitId, TypeAliasId, TypeAliasLoc,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FunctionData {\n+    pub name: Name,\n+    pub params: Vec<TypeRef>,\n+    pub ret_type: TypeRef,\n+    /// True if the first param is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub has_self_param: bool,\n+}\n+\n+impl FunctionData {\n+    pub(crate) fn fn_data_query(db: &impl DefDatabase2, func: FunctionId) -> Arc<FunctionData> {\n+        let src = func.lookup(db).source(db);\n+        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = src.value.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n+            TypeRef::from_ast(type_ref)\n+        } else {\n+            TypeRef::unit()\n+        };\n+\n+        let sig = FunctionData { name, params, ret_type, has_self_param };\n+        Arc::new(sig)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAliasData {\n+    pub name: Name,\n+    pub type_ref: Option<TypeRef>,\n+}\n+\n+impl TypeAliasData {\n+    pub(crate) fn type_alias_data_query(\n+        db: &impl DefDatabase2,\n+        typ: TypeAliasId,\n+    ) -> Arc<TypeAliasData> {\n+        let node = typ.lookup(db).source(db).value;\n+        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n+        let type_ref = node.type_ref().map(TypeRef::from_ast);\n+        Arc::new(TypeAliasData { name, type_ref })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Option<Name>,\n+    pub items: Vec<AssocItemId>,\n+    pub auto: bool,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n+        let src = tr.source(db);\n+        let name = src.value.name().map(|n| n.as_name());\n+        let auto = src.value.is_auto();\n+        let ast_id_map = db.ast_id_map(src.file_id);\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => FunctionLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::ConstDef(it) => ConstLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items, auto })\n+    }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|item| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    target_trait: Option<TypeRef>,\n+    target_type: TypeRef,\n+    items: Vec<AssocItemId>,\n+    negative: bool,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n+        let src = id.source(db);\n+        let items = db.ast_id_map(src.file_id);\n+\n+        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let negative = src.value.is_negative();\n+\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => {\n+                        let def = FunctionLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let def = ConstLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let def = TypeAliasLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let res = ImplData { target_trait, target_type, items, negative };\n+        Arc::new(res)\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.target_type\n+    }\n+\n+    pub fn items(&self) -> &[AssocItemId] {\n+        &self.items\n+    }\n+\n+    pub fn is_negative(&self) -> bool {\n+        self.negative\n+    }\n+}"}, {"sha": "8c1784ec9d5e085a346d6ba097fad25ebe54b1af", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=b315f05cf160a11b9012fcde2a9aefc240e39135", "patch": "@@ -8,15 +8,12 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n-    function::FunctionData,\n+    data::{FunctionData, ImplData, TraitData, TypeAliasData},\n     generics::GenericParams,\n-    impls::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    traits::TraitData,\n-    type_alias::TypeAliasData,\n     DefWithBodyId, EnumId, FunctionId, GenericDefId, ImplId, ItemLoc, StructOrUnionId, TraitId,\n     TypeAliasId,\n };"}, {"sha": "33265275e2f27ee81e0d0f165ec83272d650e1b3", "filename": "crates/ra_hir_def/src/function.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffunction.rs?ref=78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "patch": "@@ -1,61 +0,0 @@\n-use std::sync::Arc;\n-\n-use hir_expand::name::{self, AsName, Name};\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n-\n-use crate::{\n-    db::DefDatabase2,\n-    type_ref::{Mutability, TypeRef},\n-    FunctionId, HasSource, Lookup,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct FunctionData {\n-    pub name: Name,\n-    pub params: Vec<TypeRef>,\n-    pub ret_type: TypeRef,\n-    /// True if the first param is `self`. This is relevant to decide whether this\n-    /// can be called as a method.\n-    pub has_self_param: bool,\n-}\n-\n-impl FunctionData {\n-    pub(crate) fn fn_data_query(db: &impl DefDatabase2, func: FunctionId) -> Arc<FunctionData> {\n-        let src = func.lookup(db).source(db);\n-        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = src.value.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let sig = FunctionData { name, params, ret_type, has_self_param };\n-        Arc::new(sig)\n-    }\n-}"}, {"sha": "750a869f256fa9cc02e5669ec5094d91bb7a716e", "filename": "crates/ra_hir_def/src/impls.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "patch": "@@ -1,86 +0,0 @@\n-//! Defines hir-level representation of impls.\n-//!\n-//! The handling is similar, but is not quite the same as for other items,\n-//! because `impl`s don't have names.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::AstId;\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstLoc, ContainerId,\n-    FunctionLoc, ImplId, Intern, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImplData {\n-    target_trait: Option<TypeRef>,\n-    target_type: TypeRef,\n-    items: Vec<AssocItemId>,\n-    negative: bool,\n-}\n-\n-impl ImplData {\n-    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n-        let src = id.source(db);\n-        let items = db.ast_id_map(src.file_id);\n-\n-        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n-        let negative = src.value.is_negative();\n-\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let def = FunctionLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let def = ConstLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let def = TypeAliasLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-\n-        let res = ImplData { target_trait, target_type, items, negative };\n-        Arc::new(res)\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.target_trait.as_ref()\n-    }\n-\n-    pub fn target_type(&self) -> &TypeRef {\n-        &self.target_type\n-    }\n-\n-    pub fn items(&self) -> &[AssocItemId] {\n-        &self.items\n-    }\n-\n-    pub fn is_negative(&self) -> bool {\n-        self.negative\n-    }\n-}"}, {"sha": "3a0420da0c7757488c03dc2693fe461c169caf2c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=b315f05cf160a11b9012fcde2a9aefc240e39135", "patch": "@@ -13,15 +13,12 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n-pub mod impls;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n pub mod generics;\n-pub mod traits;\n pub mod resolver;\n-pub mod type_alias;\n-pub mod function;\n+pub mod data;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "6c2d5b2a9f7be9bbdb1aa293ad054dc99bf55977", "filename": "crates/ra_hir_def/src/traits.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "patch": "@@ -1,66 +0,0 @@\n-//! HIR for trait definitions.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::{\n-    name::{AsName, Name},\n-    AstId,\n-};\n-\n-use ra_syntax::ast::{self, NameOwner};\n-\n-use crate::{\n-    db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n-    TypeAliasId, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitData {\n-    pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n-    pub auto: bool,\n-}\n-\n-impl TraitData {\n-    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n-        let auto = src.value.is_auto();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TraitData { name, items, auto })\n-    }\n-\n-    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n-            AssocItemId::TypeAliasId(t) => Some(*t),\n-            _ => None,\n-        })\n-    }\n-}"}, {"sha": "c0b49aa7cc7e69ade47e86ae334ff53db87ade35", "filename": "crates/ra_hir_def/src/type_alias.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs?ref=78f3b0627cf4a5d34aaf63c7b5a2e1b744a11b14", "patch": "@@ -1,27 +0,0 @@\n-//! HIR for type aliases (i.e. the `type` keyword).\n-\n-use std::sync::Arc;\n-\n-use hir_expand::name::{AsName, Name};\n-\n-use ra_syntax::ast::NameOwner;\n-\n-use crate::{db::DefDatabase2, type_ref::TypeRef, HasSource, Lookup, TypeAliasId};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TypeAliasData {\n-    pub name: Name,\n-    pub type_ref: Option<TypeRef>,\n-}\n-\n-impl TypeAliasData {\n-    pub(crate) fn type_alias_data_query(\n-        db: &impl DefDatabase2,\n-        typ: TypeAliasId,\n-    ) -> Arc<TypeAliasData> {\n-        let node = typ.lookup(db).source(db).value;\n-        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.type_ref().map(TypeRef::from_ast);\n-        Arc::new(TypeAliasData { name, type_ref })\n-    }\n-}"}, {"sha": "896ad15173db17d620cd2b9524ffe1497774b549", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b315f05cf160a11b9012fcde2a9aefc240e39135/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=b315f05cf160a11b9012fcde2a9aefc240e39135", "patch": "@@ -224,12 +224,11 @@ impl Completions {\n             && ctx.db.feature_flags.get(\"completion.insertion.add-call-parenthesis\")\n         {\n             tested_by!(inserts_parens_for_function_calls);\n-            let (snippet, label) =\n-                if params.is_empty() || has_self_param && params.len() == 1 {\n-                    (format!(\"{}()$0\", func_name), format!(\"{}()\", name))\n-                } else {\n-                    (format!(\"{}($0)\", func_name), format!(\"{}(\u2026)\", name))\n-                };\n+            let (snippet, label) = if params.is_empty() || has_self_param && params.len() == 1 {\n+                (format!(\"{}()$0\", func_name), format!(\"{}()\", name))\n+            } else {\n+                (format!(\"{}($0)\", func_name), format!(\"{}(\u2026)\", name))\n+            };\n             builder = builder.lookup_by(name).label(label).insert_snippet(snippet);\n         }\n "}]}