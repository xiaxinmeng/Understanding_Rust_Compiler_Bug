{"sha": "657ec3616f076c85e21d82feba0397690e836bd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1N2VjMzYxNmYwNzZjODVlMjFkODJmZWJhMDM5NzY5MGU4MzZiZDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-02T13:32:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-02T13:32:06Z"}, "message": "Merge #7335 #7691\n\n7335: added region folding r=matklad a=LucianoBestia\n\nRegions of code that you'd like to be folded can be wrapped with  `// #region` and `// #endregion` line comments.\r\nThis is called \"Region Folding\". It is originally available for many languages in VSCode. But Rust-analyzer has its own folding function and this is missing.\r\nWith this Pull Request I am suggesting a simple solution. \r\nThe regions are a special kind of comments, so I added a bit of code in the comment folding function.\r\nThe regex to match are: `^\\s*//\\s*#?region\\b` and `^\\s*//\\s*#?endregion\\b`.\r\nThe number of space characters is not important. There is an optional # character. The line can end with a name of the region.\r\nExample:\r\n```rust\r\n// 1. some normal comment\r\n// region: test\r\n// 2. some normal comment\r\ncalling_function(x,y);\r\n// endregion: test\r\n```\r\nI added a test for this new functionality in `folding_ranges.rs`.\r\nPlease, take a look and comment. \r\nI found that these exact regexes are already present in the file `language-configuration.json`, but I don't find a way to read this configuration. So my regex is hardcoded in the code.\n\n7691: Suggest name in extract variable r=matklad a=cpud36\n\nGenerate better default name in extract variable assist as was mentioned in issue #1587\r\n\r\n# Currently supported\r\n(in order of declining precedence)\r\n1. Expr is argument to a function; use corresponding parameter name\r\n2. Expr is result of a function or method call; use this function/method's name\r\n3. Use expr type name (if possible)\r\n4. Fallback to `var_name` otherwise\r\n\r\n# Showcase\r\n\r\n![generate_derive_variable_name_from_method](https://user-images.githubusercontent.com/4218373/108013304-72105400-701c-11eb-9f13-eec52e74d0cc.gif)\r\n![generate_derive_variable_name_from_param](https://user-images.githubusercontent.com/4218373/108013305-72a8ea80-701c-11eb-957e-2214f7f005de.gif)\r\n\r\n# Questions\r\n\r\n* Should we more aggressively strip known types? E.g. we already strip `&T -> T`; should we strip `Option<T> -> T`, `Result<T, E> -> T`, and others?\r\n* Integers and floats use `var_name` by default. Should we introduce a name, like `i`, `f` etc?\r\n* Can we return a list and suggest a name when renaming(like IntelliJ does)?\r\n* Should we add counters to remove duplicate variables? E.g. `type`, `type1`, type2`, etc.\r\n\n\nCo-authored-by: Luciano Bestia <LucianoBestia@gmail.com>\nCo-authored-by: Luciano <31509965+LucianoBestia@users.noreply.github.com>\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>", "tree": {"sha": "16b40b68f89a5964c039b1de8220d71bbaebe5e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b40b68f89a5964c039b1de8220d71bbaebe5e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/657ec3616f076c85e21d82feba0397690e836bd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPj5WCRBK7hj4Ov3rIwAAdHIIACiRrv7deon5OoQMkrG0i6yg\n4A7MrDBFZr3DkP05Qdc96zzhQyH4yAt+YhUa+8SgHhpWTn6ChJDwXPDvhZVhtwZU\ny+fNpptRYmcD37QG55FVP+D0b8ZTreJdcQ3jLliXKOu4pjmSNkgZ2PfX8gXZWWQo\n8mhtl6adtqod2RriCiYlNV/7dn/sZSwCamITdRsoQ6ZxPY13lrM9LgF87877n+k9\nG1iXi5Ud5H1YS/taIobL3xZdH8wBRvxPMWwnesnzOckY+U6NyDz6p062dGBL/rD7\nIBfeTrhNO53WgQiEoi0gPbQWbZXh6sqBmEzqGeWUbX9L2fZHJNcjyzITiEqsZgs=\n=BGRO\n-----END PGP SIGNATURE-----\n", "payload": "tree 16b40b68f89a5964c039b1de8220d71bbaebe5e2\nparent 91bf5fa827b2c4ef74cb68c172c79127115e394f\nparent 864fb063a000a38ce28c8c1d0153dc080faf1cdb\nparent 7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614691926 +0000\ncommitter GitHub <noreply@github.com> 1614691926 +0000\n\nMerge #7335 #7691\n\n7335: added region folding r=matklad a=LucianoBestia\n\nRegions of code that you'd like to be folded can be wrapped with  `// #region` and `// #endregion` line comments.\r\nThis is called \"Region Folding\". It is originally available for many languages in VSCode. But Rust-analyzer has its own folding function and this is missing.\r\nWith this Pull Request I am suggesting a simple solution. \r\nThe regions are a special kind of comments, so I added a bit of code in the comment folding function.\r\nThe regex to match are: `^\\s*//\\s*#?region\\b` and `^\\s*//\\s*#?endregion\\b`.\r\nThe number of space characters is not important. There is an optional # character. The line can end with a name of the region.\r\nExample:\r\n```rust\r\n// 1. some normal comment\r\n// region: test\r\n// 2. some normal comment\r\ncalling_function(x,y);\r\n// endregion: test\r\n```\r\nI added a test for this new functionality in `folding_ranges.rs`.\r\nPlease, take a look and comment. \r\nI found that these exact regexes are already present in the file `language-configuration.json`, but I don't find a way to read this configuration. So my regex is hardcoded in the code.\n\n7691: Suggest name in extract variable r=matklad a=cpud36\n\nGenerate better default name in extract variable assist as was mentioned in issue #1587\r\n\r\n# Currently supported\r\n(in order of declining precedence)\r\n1. Expr is argument to a function; use corresponding parameter name\r\n2. Expr is result of a function or method call; use this function/method's name\r\n3. Use expr type name (if possible)\r\n4. Fallback to `var_name` otherwise\r\n\r\n# Showcase\r\n\r\n![generate_derive_variable_name_from_method](https://user-images.githubusercontent.com/4218373/108013304-72105400-701c-11eb-9f13-eec52e74d0cc.gif)\r\n![generate_derive_variable_name_from_param](https://user-images.githubusercontent.com/4218373/108013305-72a8ea80-701c-11eb-957e-2214f7f005de.gif)\r\n\r\n# Questions\r\n\r\n* Should we more aggressively strip known types? E.g. we already strip `&T -> T`; should we strip `Option<T> -> T`, `Result<T, E> -> T`, and others?\r\n* Integers and floats use `var_name` by default. Should we introduce a name, like `i`, `f` etc?\r\n* Can we return a list and suggest a name when renaming(like IntelliJ does)?\r\n* Should we add counters to remove duplicate variables? E.g. `type`, `type1`, type2`, etc.\r\n\n\nCo-authored-by: Luciano Bestia <LucianoBestia@gmail.com>\nCo-authored-by: Luciano <31509965+LucianoBestia@users.noreply.github.com>\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/657ec3616f076c85e21d82feba0397690e836bd9", "html_url": "https://github.com/rust-lang/rust/commit/657ec3616f076c85e21d82feba0397690e836bd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/657ec3616f076c85e21d82feba0397690e836bd9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91bf5fa827b2c4ef74cb68c172c79127115e394f", "url": "https://api.github.com/repos/rust-lang/rust/commits/91bf5fa827b2c4ef74cb68c172c79127115e394f", "html_url": "https://github.com/rust-lang/rust/commit/91bf5fa827b2c4ef74cb68c172c79127115e394f"}, {"sha": "864fb063a000a38ce28c8c1d0153dc080faf1cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/864fb063a000a38ce28c8c1d0153dc080faf1cdb", "html_url": "https://github.com/rust-lang/rust/commit/864fb063a000a38ce28c8c1d0153dc080faf1cdb"}, {"sha": "7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "html_url": "https://github.com/rust-lang/rust/commit/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba"}], "stats": {"total": 1190, "additions": 1174, "deletions": 16}, "files": [{"sha": "4b1b2456283f5b4b3d59bc4863084e35103422a3", "filename": "crates/ide/src/folding_ranges.rs", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffolding_ranges.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -6,7 +6,7 @@ use syntax::{\n     ast::{self, AstNode, AstToken, VisibilityOwner},\n     Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, *},\n-    SyntaxNode, TextRange,\n+    SyntaxNode, TextRange, TextSize,\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -16,6 +16,7 @@ pub enum FoldKind {\n     Mods,\n     Block,\n     ArgList,\n+    Region,\n }\n \n #[derive(Debug)]\n@@ -29,6 +30,8 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     let mut visited_comments = FxHashSet::default();\n     let mut visited_imports = FxHashSet::default();\n     let mut visited_mods = FxHashSet::default();\n+    // regions can be nested, here is a LIFO buffer\n+    let mut regions_starts: Vec<TextSize> = vec![];\n \n     for element in file.syntax().descendants_with_tokens() {\n         // Fold items that span multiple lines\n@@ -48,10 +51,25 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n                 // Fold groups of comments\n                 if let Some(comment) = ast::Comment::cast(token) {\n                     if !visited_comments.contains(&comment) {\n-                        if let Some(range) =\n-                            contiguous_range_for_comment(comment, &mut visited_comments)\n-                        {\n-                            res.push(Fold { range, kind: FoldKind::Comment })\n+                        // regions are not real comments\n+                        if comment.text().trim().starts_with(\"// region:\") {\n+                            regions_starts.push(comment.syntax().text_range().start());\n+                        } else if comment.text().trim().starts_with(\"// endregion\") {\n+                            if let Some(region) = regions_starts.pop() {\n+                                res.push(Fold {\n+                                    range: TextRange::new(\n+                                        region,\n+                                        comment.syntax().text_range().end(),\n+                                    ),\n+                                    kind: FoldKind::Region,\n+                                })\n+                            }\n+                        } else {\n+                            if let Some(range) =\n+                                contiguous_range_for_comment(comment, &mut visited_comments)\n+                            {\n+                                res.push(Fold { range, kind: FoldKind::Comment })\n+                            }\n                         }\n                     }\n                 }\n@@ -175,9 +193,16 @@ fn contiguous_range_for_comment(\n                 }\n                 if let Some(c) = ast::Comment::cast(token) {\n                     if c.kind() == group_kind {\n-                        visited.insert(c.clone());\n-                        last = c;\n-                        continue;\n+                        // regions are not real comments\n+                        if c.text().trim().starts_with(\"// region:\")\n+                            || c.text().trim().starts_with(\"// endregion\")\n+                        {\n+                            break;\n+                        } else {\n+                            visited.insert(c.clone());\n+                            last = c;\n+                            continue;\n+                        }\n                     }\n                 }\n                 // The comment group ends because either:\n@@ -224,6 +249,7 @@ mod tests {\n                 FoldKind::Mods => \"mods\",\n                 FoldKind::Block => \"block\",\n                 FoldKind::ArgList => \"arglist\",\n+                FoldKind::Region => \"region\",\n             };\n             assert_eq!(kind, &attr.unwrap());\n         }\n@@ -415,6 +441,19 @@ fn foo<fold arglist>(\n     x: i32,\n     y: String,\n )</fold> {}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fold_region() {\n+        check(\n+            r#\"\n+// 1. some normal comment\n+<fold region>// region: test\n+// 2. some normal comment\n+calling_function(x,y);\n+// endregion: test</fold>\n \"#,\n         )\n     }"}, {"sha": "312ac7ac4268064ebb4b255940b3419f26d3656b", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 202, "deletions": 6, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n };\n use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::suggest_name, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: extract_variable\n //\n@@ -54,7 +54,7 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             let var_name = match &field_shorthand {\n                 Some(it) => it.to_string(),\n-                None => \"var_name\".to_string(),\n+                None => suggest_name::variable(&to_extract, &ctx.sema),\n             };\n             let expr_range = match &field_shorthand {\n                 Some(it) => it.syntax().text_range().cover(to_extract.syntax().text_range()),\n@@ -274,8 +274,8 @@ fn foo() {\n \"#,\n             r#\"\n fn foo() {\n-    let $0var_name = bar(1 + 1);\n-    var_name\n+    let $0bar = bar(1 + 1);\n+    bar\n }\n \"#,\n         )\n@@ -401,8 +401,8 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let $0var_name = bar.foo();\n-    let v = var_name;\n+    let $0foo = bar.foo();\n+    let v = foo;\n }\n \",\n         );\n@@ -556,6 +556,202 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn extract_var_name_from_type() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct Test(i32);\n+\n+fn foo() -> Test {\n+    $0{ Test(10) }$0\n+}\n+\"#,\n+            r#\"\n+struct Test(i32);\n+\n+fn foo() -> Test {\n+    let $0test = { Test(10) };\n+    test\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_parameter() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    bar(1, $01+1$0);\n+}\n+\"#,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    let $0size = 1+1;\n+    bar(1, size);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_parameter_name_has_precedence_over_type() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct TextSize(u32);\n+fn bar(test: u32, size: TextSize)\n+\n+fn foo() {\n+    bar(1, $0{ TextSize(1+1) }$0);\n+}\n+\"#,\n+            r#\"\n+struct TextSize(u32);\n+fn bar(test: u32, size: TextSize)\n+\n+fn foo() {\n+    let $0size = { TextSize(1+1) };\n+    bar(1, size);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_function() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn is_required(test: u32, size: u32) -> bool\n+\n+fn foo() -> bool {\n+    $0is_required(1, 2)$0\n+}\n+\"#,\n+            r#\"\n+fn is_required(test: u32, size: u32) -> bool\n+\n+fn foo() -> bool {\n+    let $0is_required = is_required(1, 2);\n+    is_required\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_method() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32) -> u32 { n }\n+}\n+\n+fn foo() -> u32 {\n+    $0S.bar(1)$0\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32) -> u32 { n }\n+}\n+\n+fn foo() -> u32 {\n+    let $0bar = S.bar(1);\n+    bar\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_method_param() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    S.bar($01 + 1$0, 2)\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    let $0n = 1 + 1;\n+    S.bar(n, 2)\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_ufcs_method_param() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    S::bar(&S, $01 + 1$0, 2)\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    let $0n = 1 + 1;\n+    S::bar(&S, n, 2)\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_parameter_name_has_precedence_over_function() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    bar(1, $0symbol_size(1, 2)$0);\n+}\n+\"#,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    let $0size = symbol_size(1, 2);\n+    bar(1, size);\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn test_extract_var_for_return_not_applicable() {\n         check_assist_not_applicable(extract_variable, \"fn foo() { $0return$0; } \");"}, {"sha": "66820058b6a54f70aa4ec7756cad39b72229951f", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n     RootDatabase,\n };\n use stdx::{format_to, trim_indent};\n-use syntax::TextRange;\n+use syntax::{ast, AstNode, TextRange};\n use test_utils::{assert_eq_text, extract_offset};\n \n use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n@@ -180,6 +180,50 @@ fn labels(assists: &[Assist]) -> String {\n     labels.into_iter().collect::<String>()\n }\n \n+pub(crate) type NameSuggestion = fn(&ast::Expr, &Semantics<'_, RootDatabase>) -> Option<String>;\n+\n+#[track_caller]\n+pub(crate) fn check_name_suggestion(\n+    suggestion: NameSuggestion,\n+    ra_fixture: &str,\n+    suggested_name: &str,\n+) {\n+    check_name(suggestion, ra_fixture, Some(suggested_name));\n+}\n+\n+#[track_caller]\n+pub(crate) fn check_name_suggestion_not_applicable(suggestion: NameSuggestion, ra_fixture: &str) {\n+    check_name(suggestion, ra_fixture, None);\n+}\n+\n+#[track_caller]\n+fn check_name(suggestion: NameSuggestion, ra_fixture: &str, expected: Option<&str>) {\n+    let (db, file_with_carret_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);\n+    let frange = FileRange { file_id: file_with_carret_id, range: range_or_offset.into() };\n+\n+    let sema = Semantics::new(&db);\n+    let source_file = sema.parse(frange.file_id);\n+    let element = source_file.syntax().covering_element(frange.range);\n+    let expr =\n+        element.ancestors().find_map(ast::Expr::cast).expect(\"selection is not an expression\");\n+    assert_eq!(\n+        expr.syntax().text_range(),\n+        frange.range,\n+        \"selection is not an expression(yet contained in one)\"\n+    );\n+\n+    let name = suggestion(&expr, &sema);\n+\n+    match (name, expected) {\n+        (Some(name), Some(expected_name)) => {\n+            assert_eq_text!(&name, expected_name);\n+        }\n+        (Some(_), None) => panic!(\"name suggestion should not be applicable\"),\n+        (None, Some(_)) => panic!(\"name suggestion is not applicable\"),\n+        (None, None) => (),\n+    }\n+}\n+\n #[test]\n fn assist_order_field_struct() {\n     let before = \"struct Foo { $0bar: u32 }\";"}, {"sha": "62f959082ecf238ff1203643ccf4161931fcbcae", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -1,5 +1,7 @@\n //! Assorted functions shared by several assists.\n \n+pub(crate) mod suggest_name;\n+\n use std::ops;\n \n use ast::TypeBoundsOwner;"}, {"sha": "d37c62642911e2a930a59938184e958b2e59f076", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "added", "additions": 877, "deletions": 0, "changes": 877, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -0,0 +1,877 @@\n+//! This module contains functions to suggest names for expressions, functions and other items\n+\n+use hir::Semantics;\n+use ide_db::RootDatabase;\n+use itertools::Itertools;\n+use stdx::to_lower_snake_case;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    match_ast, AstNode,\n+};\n+\n+/// Trait names, that will be ignored when in `impl Trait` and `dyn Trait`\n+const USELESS_TRAITS: &[&str] = &[\"Send\", \"Sync\", \"Copy\", \"Clone\", \"Eq\", \"PartialEq\"];\n+/// Identifier names that won't be suggested, ever\n+///\n+/// **NOTE**: they all must be snake lower case\n+const USELESS_NAMES: &[&str] =\n+    &[\"new\", \"default\", \"option\", \"some\", \"none\", \"ok\", \"err\", \"str\", \"string\"];\n+/// Generic types replaced by their first argument\n+///\n+/// # Examples\n+/// `Option<Name>` -> `Name`\n+/// `Result<User, Error>` -> `User`\n+const WRAPPER_TYPES: &[&str] = &[\"Box\", \"Option\", \"Result\"];\n+/// Prefixes to strip from methods names\n+///\n+/// # Examples\n+/// `vec.as_slice()` -> `slice`\n+/// `args.into_config()` -> `config`\n+/// `bytes.to_vec()` -> `vec`\n+const USELESS_METHOD_PREFIXES: &[&str] = &[\"into_\", \"as_\", \"to_\"];\n+/// Useless methods that are stripped from expression\n+///\n+/// # Examples\n+/// `var.name().to_string()` -> `var.name()`\n+const USELESS_METHODS: &[&str] = &[\n+    \"to_string\",\n+    \"as_str\",\n+    \"to_owned\",\n+    \"as_ref\",\n+    \"clone\",\n+    \"cloned\",\n+    \"expect\",\n+    \"expect_none\",\n+    \"unwrap\",\n+    \"unwrap_none\",\n+    \"unwrap_or\",\n+    \"unwrap_or_default\",\n+    \"unwrap_or_else\",\n+    \"unwrap_unchecked\",\n+    \"iter\",\n+    \"into_iter\",\n+    \"iter_mut\",\n+];\n+\n+/// Suggest name of variable for given expression\n+///\n+/// **NOTE**: it is caller's responsibility to guarantee uniqueness of the name.\n+/// I.e. it doesn't look for names in scope.\n+///\n+/// # Current implementation\n+///\n+/// In current implementation, the function tries to get the name from\n+/// the following sources:\n+///\n+/// * if expr is an argument to function/method, use paramter name\n+/// * if expr is a function/method call, use function name\n+/// * expression type name if it exists (E.g. `()`, `fn() -> ()` or `!` do not have names)\n+/// * fallback: `var_name`\n+///\n+/// It also applies heuristics to filter out less informative names\n+///\n+/// Currently it sticks to the first name found.\n+pub(crate) fn variable(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> String {\n+    // `from_param` does not benifit from stripping\n+    // it need the largest context possible\n+    // so we check firstmost\n+    if let Some(name) = from_param(expr, sema) {\n+        return name;\n+    }\n+\n+    let mut next_expr = Some(expr.clone());\n+    while let Some(expr) = next_expr {\n+        let name = from_call(&expr).or_else(|| from_type(&expr, sema));\n+        if let Some(name) = name {\n+            return name;\n+        }\n+\n+        match expr {\n+            ast::Expr::RefExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::BoxExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::AwaitExpr(inner) => next_expr = inner.expr(),\n+            // ast::Expr::BlockExpr(block) => expr = block.tail_expr(),\n+            ast::Expr::CastExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::MethodCallExpr(method) if is_useless_method(&method) => {\n+                next_expr = method.receiver();\n+            }\n+            ast::Expr::ParenExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::TryExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(ast::PrefixOp::Deref) => {\n+                next_expr = prefix.expr()\n+            }\n+            _ => break,\n+        }\n+    }\n+\n+    \"var_name\".to_string()\n+}\n+\n+fn normalize(name: &str) -> Option<String> {\n+    let name = to_lower_snake_case(name);\n+\n+    if USELESS_NAMES.contains(&name.as_str()) {\n+        return None;\n+    }\n+\n+    if !is_valid_name(&name) {\n+        return None;\n+    }\n+\n+    Some(name)\n+}\n+\n+fn is_valid_name(name: &str) -> bool {\n+    match syntax::lex_single_syntax_kind(name) {\n+        Some((syntax::SyntaxKind::IDENT, _error)) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn is_useless_method(method: &ast::MethodCallExpr) -> bool {\n+    let ident = method.name_ref().and_then(|it| it.ident_token());\n+\n+    if let Some(ident) = ident {\n+        USELESS_METHODS.contains(&ident.text())\n+    } else {\n+        false\n+    }\n+}\n+\n+fn from_call(expr: &ast::Expr) -> Option<String> {\n+    from_func_call(expr).or_else(|| from_method_call(expr))\n+}\n+\n+fn from_func_call(expr: &ast::Expr) -> Option<String> {\n+    let call = match expr {\n+        ast::Expr::CallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let func = match call.expr()? {\n+        ast::Expr::PathExpr(path) => path,\n+        _ => return None,\n+    };\n+    let ident = func.path()?.segment()?.name_ref()?.ident_token()?;\n+    normalize(ident.text())\n+}\n+\n+fn from_method_call(expr: &ast::Expr) -> Option<String> {\n+    let method = match expr {\n+        ast::Expr::MethodCallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let ident = method.name_ref()?.ident_token()?;\n+    let mut name = ident.text();\n+\n+    if USELESS_METHODS.contains(&name) {\n+        return None;\n+    }\n+\n+    for prefix in USELESS_METHOD_PREFIXES {\n+        if let Some(suffix) = name.strip_prefix(prefix) {\n+            name = suffix;\n+            break;\n+        }\n+    }\n+\n+    normalize(&name)\n+}\n+\n+fn from_param(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n+    let arg_list = expr.syntax().parent().and_then(ast::ArgList::cast)?;\n+    let args_parent = arg_list.syntax().parent()?;\n+    let func = match_ast! {\n+        match args_parent {\n+            ast::CallExpr(call) => {\n+                let func = call.expr()?;\n+                let func_ty = sema.type_of_expr(&func)?;\n+                func_ty.as_callable(sema.db)?\n+            },\n+            ast::MethodCallExpr(method) => sema.resolve_method_call_as_callable(&method)?,\n+            _ => return None,\n+        }\n+    };\n+\n+    let (idx, _) = arg_list.args().find_position(|it| it == expr).unwrap();\n+    let (pat, _) = func.params(sema.db).into_iter().nth(idx)?;\n+    let pat = match pat? {\n+        either::Either::Right(pat) => pat,\n+        _ => return None,\n+    };\n+    let name = var_name_from_pat(&pat)?;\n+    normalize(&name.to_string())\n+}\n+\n+fn var_name_from_pat(pat: &ast::Pat) -> Option<ast::Name> {\n+    match pat {\n+        ast::Pat::IdentPat(var) => var.name(),\n+        ast::Pat::RefPat(ref_pat) => var_name_from_pat(&ref_pat.pat()?),\n+        ast::Pat::BoxPat(box_pat) => var_name_from_pat(&box_pat.pat()?),\n+        _ => None,\n+    }\n+}\n+\n+fn from_type(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n+    let ty = sema.type_of_expr(expr)?;\n+    let ty = ty.remove_ref().unwrap_or(ty);\n+\n+    name_of_type(&ty, sema.db)\n+}\n+\n+fn name_of_type(ty: &hir::Type, db: &RootDatabase) -> Option<String> {\n+    let name = if let Some(adt) = ty.as_adt() {\n+        let name = adt.name(db).to_string();\n+\n+        if WRAPPER_TYPES.contains(&name.as_str()) {\n+            let inner_ty = ty.type_parameters().next()?;\n+            return name_of_type(&inner_ty, db);\n+        }\n+\n+        name\n+    } else if let Some(trait_) = ty.as_dyn_trait() {\n+        trait_name(&trait_, db)?\n+    } else if let Some(traits) = ty.as_impl_traits(db) {\n+        let mut iter = traits.into_iter().filter_map(|t| trait_name(&t, db));\n+        let name = iter.next()?;\n+        if iter.next().is_some() {\n+            return None;\n+        }\n+        name\n+    } else {\n+        return None;\n+    };\n+    normalize(&name)\n+}\n+\n+fn trait_name(trait_: &hir::Trait, db: &RootDatabase) -> Option<String> {\n+    let name = trait_.name(db).to_string();\n+    if USELESS_TRAITS.contains(&name.as_str()) {\n+        return None;\n+    }\n+    Some(name)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::check_name_suggestion;\n+\n+    mod from_func_call {\n+        use super::*;\n+\n+        #[test]\n+        fn no_args() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar()$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn single_arg() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar(1)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn many_args() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn path() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0i32::bar(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_params() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar::<i32>(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+    }\n+\n+    mod from_method_call {\n+        use super::*;\n+\n+        #[test]\n+        fn no_args() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar.frobnicate()$0\n+                }\"#,\n+                \"frobnicate\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_params() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar.frobnicate::<i32, u32>()$0\n+                }\"#,\n+                \"frobnicate\",\n+            );\n+        }\n+\n+        #[test]\n+        fn to_name() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                struct Args;\n+                struct Config;\n+                impl Args {\n+                    fn to_config(&self) -> Config {}\n+                }\n+                fn foo() {\n+                    $0Args.to_config()$0;\n+                }\"#,\n+                \"config\",\n+            );\n+        }\n+    }\n+\n+    mod from_param {\n+        use crate::tests::check_name_suggestion_not_applicable;\n+\n+        use super::*;\n+\n+        #[test]\n+        fn plain_func() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(n: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn mut_param() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(mut n: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn func_does_not_exist() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn unnamed_param() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar(_: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn tuple_pat() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar((n, k): (i32, i32), m: u32);\n+                fn foo() {\n+                    bar($0(1, 2)$0, 3)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn ref_pat() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(&n: &i32, m: u32);\n+                fn foo() {\n+                    bar($0&1$0, 3)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_pat() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(box n: &i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 3)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn param_out_of_index() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar(n: i32, m: u32);\n+                fn foo() {\n+                    bar(1, 2, $03$0)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_param_resolved() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar<T>(n: T, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_param_unresolved() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar<T>(n: T, m: u32);\n+                fn foo<T>(x: T) {\n+                    bar($0x$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S.bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method_ufcs() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar(&S, $01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method_self() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar($0&S$0, 1, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn method_self_named() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(strukt: &Self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar($0&S$0, 1, 2)\n+                }\"#,\n+                \"strukt\",\n+            );\n+        }\n+    }\n+\n+    mod from_type {\n+        use crate::tests::check_name_suggestion_not_applicable;\n+\n+        use super::*;\n+\n+        #[test]\n+        fn i32() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: i32 = $01$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn u64() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: u64 = $01$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn bool() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: bool = $0true$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_unit() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed;\n+                fn foo() {\n+                    let _ = $0Seed$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_unit_to_snake() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct SeedState;\n+                fn foo() {\n+                    let _ = $0SeedState$0;\n+                }\"#,\n+                \"seed_state\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_single_arg() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed(u32);\n+                fn foo() {\n+                    let _ = $0Seed(0)$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_with_fields() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed { value: u32 }\n+                fn foo() {\n+                    let _ = $0Seed { value: 0 }$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind { A, B }\n+                fn foo() {\n+                    let _ = $0Kind::A$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_generic_resolved() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind<T> { A(T), B }\n+                fn foo() {\n+                    let _ = $0Kind::A(1)$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_generic_unresolved() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind<T> { A(T), B }\n+                fn foo<T>(x: T) {\n+                    let _ = $0Kind::A(x)$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn dyn_trait() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait DynHandler {}\n+                fn bar() -> dyn DynHandler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"dyn_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                fn bar() -> impl StaticHandler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_clone() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                trait Clone {}\n+                fn bar() -> impl StaticHandler + Clone {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_lifetime() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                trait Clone {}\n+                fn bar<'a>(&'a i32) -> impl StaticHandler + 'a {}\n+                fn foo() {\n+                    $0bar(&1)$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_trait() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                trait Handler {}\n+                trait StaticHandler {}\n+                fn bar() -> impl StaticHandler + Handler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn ref_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed;\n+                fn bar() -> &Seed {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Box<T>(*const T);\n+                struct Seed;\n+                fn bar() -> Box<Seed> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_generic() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                struct Box<T>(*const T);\n+                fn bar<T>() -> Box<T> {}\n+                fn foo<T>() {\n+                    $0bar::<T>()$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn option_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Option<T> { Some(T) }\n+                struct Seed;\n+                fn bar() -> Option<Seed> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn result_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Result<T, E> { Ok(T), Err(E) }\n+                struct Seed;\n+                struct Error;\n+                fn bar() -> Result<Seed, Error> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+    }\n+\n+    mod variable {\n+        use super::*;\n+\n+        #[test]\n+        fn ref_call() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0&bar(1, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn name_to_string() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0function.name().to_string()$0\n+                }\"#,\n+                \"name\",\n+            );\n+        }\n+\n+        #[test]\n+        fn nested_useless_method() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0function.name().as_ref().unwrap().to_string()$0\n+                }\"#,\n+                \"name\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "c1ca88df67a3ee8474d0b8356d55d458b5913bce", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657ec3616f076c85e21d82feba0397690e836bd9/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=657ec3616f076c85e21d82feba0397690e836bd9", "patch": "@@ -474,7 +474,7 @@ pub(crate) fn folding_range(\n     let kind = match fold.kind {\n         FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n         FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n-        FoldKind::Mods | FoldKind::Block | FoldKind::ArgList => None,\n+        FoldKind::Mods | FoldKind::Block | FoldKind::ArgList | FoldKind::Region => None,\n     };\n \n     let range = range(line_index, fold.range);"}]}