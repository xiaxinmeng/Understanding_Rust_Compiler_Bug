{"sha": "e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YjI4ZjlhYzNmNmExYTY0NDFlMGQ0N2M1NmM2NjBkN2ExMGFiZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-20T12:01:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-20T12:01:31Z"}, "message": "auto merge of #15797 : brson/rust/taskstab, r=alexcrichton\n\nSummary:\r\n\r\n* alloc::rc module stable\r\n* Rc type stable\r\n* Functions relating to weak references experimental\r\n* core::cmp module stable\r\n* PartialEq/Eq/PartialOrd/Ord unstable because trait reform will make them change again\r\n* Equiv experimental because there may be better sol'ns\r\n* lexical_ordering deprecated because it can be done trivially with the Ord trait\r\n* min/max stable\r\n* std::task module stable\r\n* TaskBuilder::stdout/stderr experimental because we aren't certain we want to configure the environment this way\r\n* try_future experimental because Future is experimental\r\n* try unstable because the error type might change\r\n* deschedule/failing unstable\r\n\r\nThe major thing I did differently than previously-discussed is that I made `try` experimental: there's been discussion that the error type `Box<Any + Send>` is not sufficient.\r\n\r\n\r\nPer https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-07-16.md.", "tree": {"sha": "53b0fb06db65591df1f878f8de78236521ef018c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53b0fb06db65591df1f878f8de78236521ef018c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "html_url": "https://github.com/rust-lang/rust/commit/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "343a52f6b5e567516abeb2af500ed8933dcb6085", "url": "https://api.github.com/repos/rust-lang/rust/commits/343a52f6b5e567516abeb2af500ed8933dcb6085", "html_url": "https://github.com/rust-lang/rust/commit/343a52f6b5e567516abeb2af500ed8933dcb6085"}, {"sha": "0b946f0a9099c8a116d2f51473a48d0e16b43037", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b946f0a9099c8a116d2f51473a48d0e16b43037", "html_url": "https://github.com/rust-lang/rust/commit/0b946f0a9099c8a116d2f51473a48d0e16b43037"}], "stats": {"total": 111, "additions": 88, "deletions": 23}, "files": [{"sha": "8d4e788bc8035a0a5181fabd544ce95ce2a535d0", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "patch": "@@ -148,6 +148,8 @@ fn main() {\n \n */\n \n+#![stable]\n+\n use core::mem::transmute;\n use core::cell::Cell;\n use core::clone::Clone;\n@@ -171,6 +173,7 @@ struct RcBox<T> {\n \n /// Immutable reference counted pointer type\n #[unsafe_no_drop_flag]\n+#[stable]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -179,6 +182,7 @@ pub struct Rc<T> {\n     _noshare: marker::NoShare\n }\n \n+#[stable]\n impl<T> Rc<T> {\n     /// Construct a new reference-counted box\n     pub fn new(value: T) -> Rc<T> {\n@@ -203,6 +207,7 @@ impl<T> Rc<T> {\n \n impl<T> Rc<T> {\n     /// Downgrade the reference-counted pointer to a weak reference\n+    #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak {\n@@ -238,6 +243,7 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+#[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Rc<T> {\n     /// Borrow the value contained in the reference-counted box\n     #[inline(always)]\n@@ -247,6 +253,7 @@ impl<T> Deref<T> for Rc<T> {\n }\n \n #[unsafe_destructor]\n+#[experimental = \"Drop is experimental.\"]\n impl<T> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -269,7 +276,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[unstable]\n+#[unstable = \"Clone is unstable.\"]\n impl<T> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n@@ -278,22 +285,26 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n+#[stable]\n impl<T: Default> Default for Rc<T> {\n     #[inline]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n+#[unstable = \"PartialEq is unstable.\"]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n+#[unstable = \"Eq is unstable.\"]\n impl<T: Eq> Eq for Rc<T> {}\n \n+#[unstable = \"PartialOrd is unstable.\"]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n@@ -313,11 +324,13 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n+#[unstable = \"Ord is unstable.\"]\n impl<T: Ord> Ord for Rc<T> {\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n+#[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n@@ -326,6 +339,7 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n \n /// Weak reference to a reference-counted box\n #[unsafe_no_drop_flag]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -334,6 +348,7 @@ pub struct Weak<T> {\n     _noshare: marker::NoShare\n }\n \n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Weak<T> {\n     /// Upgrade a weak reference to a strong reference\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n@@ -347,6 +362,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -364,6 +380,7 @@ impl<T> Drop for Weak<T> {\n }\n \n #[unstable]\n+#[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {"}, {"sha": "8db59bd370e76bcfd292139bca09518ac09a7336", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "patch": "@@ -37,6 +37,8 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n+#![stable]\n+\n use option::{Option, Some};\n \n /// Trait for values that can be compared for equality and inequality.\n@@ -53,6 +55,7 @@ use option::{Option, Some};\n /// Eventually, this will be implemented by default for types that implement\n /// `Eq`.\n #[lang=\"eq\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialEq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     fn eq(&self, other: &Self) -> bool;\n@@ -71,6 +74,7 @@ pub trait PartialEq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Eq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -86,6 +90,7 @@ pub trait Eq: PartialEq {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[deriving(Clone, PartialEq, Show)]\n+#[stable]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    Less = -1i,\n@@ -104,6 +109,7 @@ pub enum Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Ord: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -118,15 +124,18 @@ pub trait Ord: Eq + PartialOrd {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n+#[unstable = \"Trait is unstable.\"]\n impl Eq for Ordering {}\n \n+#[unstable = \"Trait is unstable.\"]\n impl Ord for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n+#[unstable = \"Trait is unstable.\"]\n impl PartialOrd for Ordering {\n     #[inline]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n@@ -140,6 +149,7 @@ impl PartialOrd for Ordering {\n /// If the first ordering is different, the first ordering is all that must be returned.\n /// If the first ordering is equal, then second ordering is returned.\n #[inline]\n+#[deprecated = \"Just call .cmp() on an Ordering\"]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n         Equal => o2,\n@@ -157,6 +167,7 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialOrd: PartialEq {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n@@ -202,19 +213,22 @@ pub trait PartialOrd: PartialEq {\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `String` keys.\n+#[experimental = \"Better solutions may be discovered.\"]\n pub trait Equiv<T> {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;\n }\n \n /// Compare and return the minimum of two values.\n #[inline]\n+#[stable]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n+#[stable]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -227,6 +241,7 @@ mod impls {\n \n     macro_rules! eq_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -236,6 +251,7 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -247,6 +263,7 @@ mod impls {\n \n     macro_rules! totaleq_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl Eq for $t {}\n         )*)\n     )\n@@ -255,6 +272,7 @@ mod impls {\n \n     macro_rules! ord_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -277,13 +295,15 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -295,6 +315,7 @@ mod impls {\n \n     macro_rules! totalord_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -306,11 +327,13 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -321,12 +344,14 @@ mod impls {\n     totalord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n@@ -341,19 +366,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a T {}\n \n     // &mut pointers\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n@@ -368,9 +397,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a mut T {}\n }"}, {"sha": "70780515dec9d943ed0f4358afc64049ad20ac1a", "filename": "src/libcore/default.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "patch": "@@ -10,6 +10,8 @@\n \n //! The `Default` trait for types which may have meaningful default values\n \n+#![stable]\n+\n /// A trait that types which have a useful default value should implement.\n pub trait Default {\n     /// Return the \"default value\" for a type."}, {"sha": "4b8c15a0152a39f2316070c172c82a578267131e", "filename": "src/libstd/task.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=e6b28f9ac3f6a1a6441e0d47c56c660d7a10abf9", "patch": "@@ -91,7 +91,7 @@\n //! # }\n //! ```\n \n-#![experimental]\n+#![stable]\n \n use any::Any;\n use comm::channel;\n@@ -104,7 +104,9 @@ use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n+use string::String;\n use sync::Future;\n+use to_str::ToString;\n \n /// A means of spawning a task\n pub trait Spawner {\n@@ -172,6 +174,7 @@ impl TaskBuilder<SiblingSpawner> {\n impl<S: Spawner> TaskBuilder<S> {\n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in failure messages.\n+    #[unstable = \"IntoMaybeOwned will probably change.\"]\n     pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n         self.name = Some(name.into_maybe_owned());\n         self\n@@ -184,12 +187,14 @@ impl<S: Spawner> TaskBuilder<S> {\n     }\n \n     /// Redirect task-local stdout.\n+    #[experimental = \"May not want to make stdio overridable here.\"]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect task-local stderr.\n+    #[experimental = \"May not want to make stdio overridable here.\"]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> {\n         self.stderr = Some(stderr);\n         self\n@@ -288,6 +293,7 @@ impl<S: Spawner> TaskBuilder<S> {\n     /// future returns `result::Ok` containing the value returned by the\n     /// function. If the child task fails then the future returns `result::Err`\n     /// containing the argument to `fail!(...)` as an `Any` trait object.\n+    #[experimental = \"Futures are experimental.\"]\n     pub fn try_future<T:Send>(self, f: proc():Send -> T)\n                               -> Future<Result<T, Box<Any + Send>>> {\n         // currently, the on_exit proc provided by librustrt only works for unit\n@@ -308,6 +314,7 @@ impl<S: Spawner> TaskBuilder<S> {\n \n     /// Execute a function in a newly-spawnedtask and block until the task\n     /// completes or fails. Equivalent to `.try_future(f).unwrap()`.\n+    #[unstable = \"Error type may change.\"]\n     pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n         self.try_future(f).unwrap()\n     }\n@@ -329,6 +336,7 @@ pub fn spawn(f: proc(): Send) {\n /// value of the function or an error if the task failed.\n ///\n /// This is equivalent to `TaskBuilder::new().try`.\n+#[unstable = \"Error type may change.\"]\n pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n     TaskBuilder::new().try(f)\n }\n@@ -337,6 +345,7 @@ pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n /// task's result.\n ///\n /// This is equivalent to `TaskBuilder::new().try_future`.\n+#[experimental = \"Futures are experimental.\"]\n pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n     TaskBuilder::new().try_future(f)\n }\n@@ -345,6 +354,7 @@ pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Sen\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n+#[deprecated = \"Use `task::name()`.\"]\n pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n@@ -355,7 +365,20 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     }\n }\n \n+/// Read the name of the current task.\n+#[stable]\n+pub fn name() -> Option<String> {\n+    use rt::task::Task;\n+\n+    let task = Local::borrow(None::<Task>);\n+    match task.name {\n+        Some(ref name) => Some(name.as_slice().to_string()),\n+        None => None\n+    }\n+}\n+\n /// Yield control to the task scheduler.\n+#[unstable = \"Name will change.\"]\n pub fn deschedule() {\n     use rt::local::Local;\n \n@@ -366,6 +389,7 @@ pub fn deschedule() {\n \n /// True if the running task is currently failing (e.g. will return `true` inside a\n /// destructor that is run while unwinding the stack after a call to `fail!()`).\n+#[unstable = \"May move to a different module.\"]\n pub fn failing() -> bool {\n     use rt::task::Task;\n     Local::borrow(None::<Task>).unwinder.unwinding()\n@@ -377,7 +401,6 @@ mod test {\n     use boxed::BoxAny;\n     use result;\n     use result::{Ok, Err};\n-    use str::StrAllocating;\n     use string::String;\n     use std::io::{ChanReader, ChanWriter};\n     use prelude::*;\n@@ -388,38 +411,30 @@ mod test {\n \n     #[test]\n     fn test_unnamed_task() {\n-        spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.is_none());\n-            })\n-        })\n+        try(proc() {\n+            assert!(name().is_none());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\").try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]"}]}