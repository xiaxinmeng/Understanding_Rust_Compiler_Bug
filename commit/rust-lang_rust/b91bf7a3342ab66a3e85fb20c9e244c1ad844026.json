{"sha": "b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MWJmN2EzMzQyYWI2NmEzZTg1ZmIyMGM5ZTI0NGMxYWQ4NDQwMjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-25T21:00:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-25T21:00:58Z"}, "message": "miri: couple ret place and ret block together (they both exist or both don't)", "tree": {"sha": "0069d077faa199d65f97cff73c0b8b3a12d95b21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0069d077faa199d65f97cff73c0b8b3a12d95b21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "html_url": "https://github.com/rust-lang/rust/commit/b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "419d3fcf5466c5b02e77bcc736e0ff925e9a8a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/419d3fcf5466c5b02e77bcc736e0ff925e9a8a59", "html_url": "https://github.com/rust-lang/rust/commit/419d3fcf5466c5b02e77bcc736e0ff925e9a8a59"}], "stats": {"total": 132, "additions": 65, "deletions": 67}, "files": [{"sha": "640b5fbdff31e983d25722218a353c377c023dea", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "patch": "@@ -323,8 +323,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock> // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n@@ -337,8 +336,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, dest)? {\n-                    ecx.return_to_block(ret)?; // callee is fully evaluated and done\n+                return if ecx.hook_panic_fn(instance, args, ret)? {\n                     Ok(None)\n                 } else {\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)\n@@ -364,8 +362,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: !,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<mir::BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         match fn_val {}\n     }\n@@ -375,11 +373,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(span, instance, args, dest)? {\n+        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n             return Ok(());\n         }\n         // An intrinsic that we do not support"}, {"sha": "623e8680a5f6593510f2c468fd010304b0b8042e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "patch": "@@ -9,8 +9,10 @@ use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::ty::subst::SubstsRef;\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc::mir::BinOp;\n-use rustc::mir::interpret::{InterpResult, Scalar, GlobalId, ConstValue};\n+use rustc::mir::{\n+    self, BinOp,\n+    interpret::{InterpResult, Scalar, GlobalId, ConstValue}\n+};\n \n use super::{\n     Machine, PlaceTy, OpTy, InterpCx, ImmTy,\n@@ -91,13 +93,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n \n         // We currently do not handle any diverging intrinsics.\n-        let dest = match dest {\n-            Some(dest) => dest,\n+        let (dest, ret) = match ret {\n+            Some(p) => p,\n             None => return Ok(false)\n         };\n         let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n@@ -268,34 +270,39 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see the Miri code, `src/operator.rs`).\n-                if a.is_bits() && b.is_bits() {\n+                //\n+                // Control flow is weird because we cannot early-return (to reach the\n+                // `go_to_block` at the end).\n+                let done = if a.is_bits() && b.is_bits() {\n                     let a = a.to_machine_usize(self)?;\n                     let b = b.to_machine_usize(self)?;\n                     if a == b && a != 0 {\n                         self.write_scalar(Scalar::from_int(0, isize_layout.size), dest)?;\n-                        return Ok(true);\n-                    }\n-                }\n+                        true\n+                    } else { false }\n+                } else { false };\n \n-                // General case: we need two pointers.\n-                let a = self.force_ptr(a)?;\n-                let b = self.force_ptr(b)?;\n-                if a.alloc_id != b.alloc_id {\n-                    throw_ub_format!(\n-                        \"ptr_offset_from cannot compute offset of pointers into different \\\n-                        allocations.\",\n-                    );\n+                if !done {\n+                    // General case: we need two pointers.\n+                    let a = self.force_ptr(a)?;\n+                    let b = self.force_ptr(b)?;\n+                    if a.alloc_id != b.alloc_id {\n+                        throw_ub_format!(\n+                            \"ptr_offset_from cannot compute offset of pointers into different \\\n+                            allocations.\",\n+                        );\n+                    }\n+                    let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                    let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n+                    let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n+                    let (val, _overflowed, _ty) = self.overflowing_binary_op(\n+                        BinOp::Sub, a_offset, b_offset,\n+                    )?;\n+                    let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                    let val = ImmTy::from_scalar(val, isize_layout);\n+                    let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                    self.exact_div(val, size, dest)?;\n                 }\n-                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n-                let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n-                let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n-                let (val, _overflowed, _ty) = self.overflowing_binary_op(\n-                    BinOp::Sub, a_offset, b_offset,\n-                )?;\n-                let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                let val = ImmTy::from_scalar(val, isize_layout);\n-                let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n-                self.exact_div(val, size, dest)?;\n             }\n \n             \"transmute\" => {\n@@ -350,6 +357,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n+        self.dump_place(*dest);\n+        self.go_to_block(ret);\n         Ok(true)\n     }\n \n@@ -360,7 +369,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        _dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        _ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n         if Some(def_id) == self.tcx.lang_items().panic_fn() {"}, {"sha": "d2ea55a5d3c8875a94474fbe0b13b4814c557075", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "patch": "@@ -150,9 +150,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n-        unwind: Option<mir::BasicBlock>\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n@@ -161,8 +160,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: Self::ExtraFnVal,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n     /// Directly process an intrinsic without pushing a stack frame. It is the hook's\n@@ -172,8 +171,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n "}, {"sha": "daa0a5e1bc4dd13729574e9d691723fb06dec523", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "patch": "@@ -59,11 +59,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref cleanup,\n                 ..\n             } => {\n-                let (dest, ret) = match *destination {\n-                    Some((ref lv, target)) => (Some(self.eval_place(lv)?), Some(target)),\n-                    None => (None, None),\n-                };\n-\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -81,12 +76,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n+                let ret = match destination {\n+                    Some((dest, ret)) => Some((self.eval_place(dest)?, *ret)),\n+                    None => None,\n+                };\n                 self.eval_fn_call(\n                     fn_val,\n                     terminator.source_info.span,\n                     abi,\n                     &args[..],\n-                    dest,\n                     ret,\n                     *cleanup\n                 )?;\n@@ -238,16 +236,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n         let instance = match fn_val {\n             FnVal::Instance(instance) => instance,\n             FnVal::Other(extra) => {\n-                return M::call_extra_fn(self, extra, args, dest, ret);\n+                return M::call_extra_fn(self, extra, args, ret, unwind);\n             }\n         };\n \n@@ -278,7 +275,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n-                return M::call_intrinsic(self, span, instance, args, dest, ret, unwind);\n+                return M::call_intrinsic(self, span, instance, args, ret, unwind);\n             }\n             ty::InstanceDef::VtableShim(..) |\n             ty::InstanceDef::ReifyShim(..) |\n@@ -288,7 +285,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body = match M::find_fn(self, instance, args, dest, ret, unwind)? {\n+                let body = match M::find_fn(self, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };\n@@ -297,8 +294,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     instance,\n                     span,\n                     body,\n-                    dest,\n-                    StackPopCleanup::Goto { ret, unwind }\n+                    ret.map(|p| p.0),\n+                    StackPopCleanup::Goto { ret: ret.map(|p| p.1), unwind }\n                 )?;\n \n                 // We want to pop this frame again in case there was an error, to put\n@@ -381,7 +378,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         throw_unsup!(FunctionArgCountMismatch)\n                     }\n                     // Don't forget to check the return type!\n-                    if let Some(caller_ret) = dest {\n+                    if let Some((caller_ret, _)) = ret {\n                         let callee_ret = self.eval_place(\n                             &mir::Place::return_place()\n                         )?;\n@@ -447,7 +444,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret, unwind)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, ret, unwind)\n             }\n         }\n     }\n@@ -487,8 +484,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             span,\n             Abi::Rust,\n             &[arg.into()],\n-            Some(dest.into()),\n-            Some(target),\n+            Some((dest.into(), target)),\n             unwind\n         )\n     }"}, {"sha": "1114694d2e335aebcc5bef3e231bd8724bbeaa3d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91bf7a3342ab66a3e85fb20c9e244c1ad844026/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b91bf7a3342ab66a3e85fb20c9e244c1ad844026", "patch": "@@ -144,8 +144,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n@@ -155,8 +154,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: !,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n         match fn_val {}\n     }\n@@ -166,8 +165,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n         throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");"}]}