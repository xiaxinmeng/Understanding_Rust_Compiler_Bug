{"sha": "be1b4034a523081cfeea1c7a1d61130d5d1778e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMWI0MDM0YTUyMzA4MWNmZWVhMWM3YTFkNjExMzBkNWQxNzc4ZTE=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-17T09:28:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:25Z"}, "message": "Infer pattern types for lambdas and loops", "tree": {"sha": "3fe6d410c51b01ebdc89260f9c241edf8c90bda3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe6d410c51b01ebdc89260f9c241edf8c90bda3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be1b4034a523081cfeea1c7a1d61130d5d1778e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be1b4034a523081cfeea1c7a1d61130d5d1778e1", "html_url": "https://github.com/rust-lang/rust/commit/be1b4034a523081cfeea1c7a1d61130d5d1778e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be1b4034a523081cfeea1c7a1d61130d5d1778e1/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06d16a18f632711de588ccd12a6a1ed6f2b9ad69", "url": "https://api.github.com/repos/rust-lang/rust/commits/06d16a18f632711de588ccd12a6a1ed6f2b9ad69", "html_url": "https://github.com/rust-lang/rust/commit/06d16a18f632711de588ccd12a6a1ed6f2b9ad69"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "75794b732f308f2b2142aa7e88297d6ada3f3dda", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be1b4034a523081cfeea1c7a1d61130d5d1778e1/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1b4034a523081cfeea1c7a1d61130d5d1778e1/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=be1b4034a523081cfeea1c7a1d61130d5d1778e1", "patch": "@@ -33,6 +33,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     Def, DefId, Module, Function, Struct, Enum, EnumVariant, Path, Name, ImplBlock,\n     FnSignature, FnScopes,\n+    adt::StructField,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n@@ -872,7 +873,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    fn resolve_fields(&self, path: Option<&Path>) -> Option<(Ty, Vec<crate::adt::StructField>)> {\n+    fn resolve_fields(&self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n         let def = path\n             .and_then(|path| self.module.resolve_path(self.db, &path).take_types())\n             .map(|def_id| def_id.resolve(self.db));\n@@ -916,13 +917,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n \n         for (&sub_pat, field) in sub_pats.iter().zip(fields.iter()) {\n-            let sub_ty = Ty::from_hir(\n-                self.db,\n-                &self.module,\n-                self.impl_block.as_ref(),\n-                &field.type_ref,\n-            );\n-\n+            let sub_ty = self.make_ty(&field.type_ref);\n             self.infer_pat(sub_pat, &Expectation::has_type(sub_ty));\n         }\n \n@@ -941,7 +936,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n             if let Some(field) = matching_field {\n                 let typeref = &field.type_ref;\n-                let sub_ty = Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), typeref);\n+                let sub_ty = self.make_ty(typeref);\n                 self.infer_pat(sub_pat.pat, &Expectation::has_type(sub_ty));\n             }\n         }\n@@ -1031,14 +1026,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n-            Expr::For { iterable, body, .. } => {\n+            Expr::For {\n+                iterable,\n+                body,\n+                pat,\n+            } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                // TODO write type for pat\n+                self.infer_pat(*pat, &Expectation::none());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n-            Expr::Lambda { body, .. } => {\n-                // TODO write types for args, infer lambda type etc.\n+            Expr::Lambda {\n+                body,\n+                args,\n+                arg_types,\n+            } => {\n+                assert_eq!(args.len(), arg_types.len());\n+\n+                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n+                    let expected = if let Some(tyref) = arg_type {\n+                        let ty = self.make_ty(tyref);\n+                        Expectation::has_type(ty)\n+                    } else {\n+                        Expectation::none()\n+                    };\n+                    self.infer_pat(*arg_pat, &expected);\n+                }\n+\n+                // TODO: infer lambda type etc.\n                 let _body_ty = self.infer_expr(*body, &Expectation::none());\n                 Ty::Unknown\n             }\n@@ -1174,8 +1189,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let cast_ty =\n-                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref);\n+                let cast_ty = self.make_ty(type_ref);\n                 let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO check the cast...\n                 cast_ty"}, {"sha": "dfc83bb17a903956097d5f40eaf55c8b67cd7912", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be1b4034a523081cfeea1c7a1d61130d5d1778e1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1b4034a523081cfeea1c7a1d61130d5d1778e1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=be1b4034a523081cfeea1c7a1d61130d5d1778e1", "patch": "@@ -367,6 +367,16 @@ fn test(x: &i32) {\n     let &z = x;\n     let a = z;\n     let (c, d) = (1, \"hello\");\n+\n+    for (e, f) in some_iter {\n+        let g = e;\n+    }\n+\n+    if let [val] = opt {\n+        let h = val;\n+    }\n+\n+    let lambda = |a: u64, b, c: i32| { a + b; c };\n }\n \"#,\n         \"pattern.txt\","}]}