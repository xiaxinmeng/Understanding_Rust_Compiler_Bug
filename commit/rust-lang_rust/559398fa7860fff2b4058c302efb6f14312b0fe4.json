{"sha": "559398fa7860fff2b4058c302efb6f14312b0fe4", "node_id": "C_kwDOAAsO6NoAKDU1OTM5OGZhNzg2MGZmZjJiNDA1OGMzMDJlZmI2ZjE0MzEyYjBmZTQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-05T00:21:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T23:02:50Z"}, "message": "Fix some inconsistencies.\n\nThis makes `cs_cmp`, `cs_partial_cmp`, and `cs_op` (for `PartialEq`)\nmore similar. It also fixes some out of date comments.", "tree": {"sha": "5655d1303ba9a59e3e2a8e22b538da2c40f1e9e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5655d1303ba9a59e3e2a8e22b538da2c40f1e9e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/559398fa7860fff2b4058c302efb6f14312b0fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/559398fa7860fff2b4058c302efb6f14312b0fe4", "html_url": "https://github.com/rust-lang/rust/commit/559398fa7860fff2b4058c302efb6f14312b0fe4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/559398fa7860fff2b4058c302efb6f14312b0fe4/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d0bfbca569b91eec6199b4629bc53db417efed", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d0bfbca569b91eec6199b4629bc53db417efed", "html_url": "https://github.com/rust-lang/rust/commit/65d0bfbca569b91eec6199b4629bc53db417efed"}], "stats": {"total": 89, "additions": 31, "deletions": 58}, "files": [{"sha": "1856be87a20ddfd5afd8d9691e978019de0a8b6e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=559398fa7860fff2b4058c302efb6f14312b0fe4", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -40,43 +39,25 @@ pub fn expand_deriving_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn ordering_collapsed(\n-    cx: &mut ExtCtxt<'_>,\n-    span: Span,\n-    self_arg_tags: &[Ident],\n-) -> P<ast::Expr> {\n-    let lft = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[0]));\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n-    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n-}\n-\n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n-    // ::std::cmp::Ordering::Equal =>\n-    // match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n-    // ::std::cmp::Ordering::Equal => {\n-    // ...\n-    // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n+    // match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n+    //     ::std::cmp::Ordering::Equal =>\n+    //         ::core::cmp::Ord::cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_expr, other_selflike_exprs| {\n             // match new {\n-            //     ::std::cmp::Ordering::Equal => old,\n+            //     ::core::cmp::Ordering::Equal => old,\n             //     cmp => cmp\n             // }\n             let new = {\n@@ -90,7 +71,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n-            let eq_arm = cx.arm(span, cx.pat_path(span, equals_path.clone()), old);\n+            let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), old);\n             let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n@@ -110,13 +91,16 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n \n                 new\n             }\n-            None => cx.expr_path(equals_path.clone()),\n+            None => cx.expr_path(equal_path.clone()),\n         },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n             } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n+                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n+                cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n             }\n         }),\n         cx,"}, {"sha": "e4af0166577e15229009272f6fc4c910ee2369d1", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=559398fa7860fff2b4058c302efb6f14312b0fe4", "patch": "@@ -36,18 +36,16 @@ pub fn expand_deriving_partial_eq(\n \n         let expr = cs_fold(\n             true, // use foldl\n-            |cx, span, subexpr, self_expr, other_selflike_exprs| {\n+            |cx, span, old, self_expr, other_selflike_exprs| {\n                 let eq = op(cx, span, self_expr, other_selflike_exprs);\n-                cx.expr_binary(span, combiner, subexpr, eq)\n+                cx.expr_binary(span, combiner, old, eq)\n             },\n-            |cx, args| {\n-                match args {\n-                    Some((span, self_expr, other_selflike_exprs)) => {\n-                        // Special-case the base case to generate cleaner code.\n-                        op(cx, span, self_expr, other_selflike_exprs)\n-                    }\n-                    None => cx.expr_bool(span, base),\n+            |cx, args| match args {\n+                Some((span, self_expr, other_selflike_exprs)) => {\n+                    // Special-case the base case to generate cleaner code.\n+                    op(cx, span, self_expr, other_selflike_exprs)\n                 }\n+                None => cx.expr_bool(span, base),\n             },\n             Box::new(|cx, span, _| cx.expr_bool(span, !base)),\n             cx,"}, {"sha": "bf52c63fad4b75aa782989a462171b7febfd69e6", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/559398fa7860fff2b4058c302efb6f14312b0fe4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=559398fa7860fff2b4058c302efb6f14312b0fe4", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -50,34 +49,25 @@ pub fn expand_deriving_partial_ord(\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-    let ordering_expr = cx.expr_path(ordering.clone());\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n-    // ...\n-    // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n+    // match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n+    //     ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+    //         ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_expr, other_selflike_exprs| {\n             // match new {\n-            //     Some(::std::cmp::Ordering::Equal) => old,\n+            //     Some(::core::cmp::Ordering::Equal) => old,\n             //     cmp => cmp\n             // }\n-\n             let new = {\n                 let [other_expr] = other_selflike_exprs else {\n                     cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n@@ -91,12 +81,13 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 cx.expr_call_global(span, partial_cmp_path.clone(), args)\n             };\n \n-            let eq_arm = cx.arm(span, cx.pat_some(span, cx.pat_path(span, ordering.clone())), old);\n+            let eq_arm =\n+                cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), old);\n             let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n-        |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n+        |cx, args| match args {\n             Some((span, self_expr, other_selflike_exprs)) => {\n                 let new = {\n                     let [other_expr] = other_selflike_exprs else {\n@@ -111,7 +102,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n \n                 new\n             }\n-            None => cx.expr_some(span, ordering_expr.clone()),\n+            None => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n         },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {"}]}