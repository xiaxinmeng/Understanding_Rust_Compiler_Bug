{"sha": "f841369fee0f49125c83046340b228b032ebc702", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NDEzNjlmZWUwZjQ5MTI1YzgzMDQ2MzQwYjIyOGIwMzJlYmM3MDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:11:53Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:11:53Z"}, "message": "internal: switch some tests to minicore", "tree": {"sha": "c165c15099a73638f6082a5c3ceef62654cdcc0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c165c15099a73638f6082a5c3ceef62654cdcc0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f841369fee0f49125c83046340b228b032ebc702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f841369fee0f49125c83046340b228b032ebc702", "html_url": "https://github.com/rust-lang/rust/commit/f841369fee0f49125c83046340b228b032ebc702", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f841369fee0f49125c83046340b228b032ebc702/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f521e4185323699cd5d063b2704367a319583982", "url": "https://api.github.com/repos/rust-lang/rust/commits/f521e4185323699cd5d063b2704367a319583982", "html_url": "https://github.com/rust-lang/rust/commit/f521e4185323699cd5d063b2704367a319583982"}], "stats": {"total": 206, "additions": 88, "deletions": 118}, "files": [{"sha": "58d454a0f87bd48e0ac6830d63bfa6236077b99e", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 81, "deletions": 116, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f841369fee0f49125c83046340b228b032ebc702/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841369fee0f49125c83046340b228b032ebc702/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=f841369fee0f49125c83046340b228b032ebc702", "patch": "@@ -122,60 +122,52 @@ fn infer_let_stmt_coerce() {\n fn infer_custom_coerce_unsized() {\n     check_infer(\n         r#\"\n-        struct A<T: ?Sized>(*const T);\n-        struct B<T: ?Sized>(*const T);\n-        struct C<T: ?Sized> { inner: *const T }\n-\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n+//- minicore: coerce_unsized\n+use core::{marker::Unsize, ops::CoerceUnsized};\n \n-        fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n-        fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n-        fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n+struct A<T: ?Sized>(*const T);\n+struct B<T: ?Sized>(*const T);\n+struct C<T: ?Sized> { inner: *const T }\n \n-        fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n-            let d = foo1(a);\n-            let e = foo2(b);\n-            let f = foo3(c);\n-        }\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n \n+fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n+fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n+fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n \n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n+    let d = foo1(a);\n+    let e = foo2(b);\n+    let f = foo3(c);\n+}\n+\"#,\n         expect![[r#\"\n-            257..258 'x': A<[T]>\n-            278..283 '{ x }': A<[T]>\n-            280..281 'x': A<[T]>\n-            295..296 'x': B<[T]>\n-            316..321 '{ x }': B<[T]>\n-            318..319 'x': B<[T]>\n-            333..334 'x': C<[T]>\n-            354..359 '{ x }': C<[T]>\n-            356..357 'x': C<[T]>\n-            369..370 'a': A<[u8; 2]>\n-            384..385 'b': B<[u8; 2]>\n-            399..400 'c': C<[u8; 2]>\n-            414..480 '{     ...(c); }': ()\n-            424..425 'd': A<[{unknown}]>\n-            428..432 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n-            428..435 'foo1(a)': A<[{unknown}]>\n-            433..434 'a': A<[u8; 2]>\n-            445..446 'e': B<[u8]>\n-            449..453 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n-            449..456 'foo2(b)': B<[u8]>\n-            454..455 'b': B<[u8; 2]>\n-            466..467 'f': C<[u8]>\n-            470..474 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n-            470..477 'foo3(c)': C<[u8]>\n-            475..476 'c': C<[u8; 2]>\n+            306..307 'x': A<[T]>\n+            327..332 '{ x }': A<[T]>\n+            329..330 'x': A<[T]>\n+            344..345 'x': B<[T]>\n+            365..370 '{ x }': B<[T]>\n+            367..368 'x': B<[T]>\n+            382..383 'x': C<[T]>\n+            403..408 '{ x }': C<[T]>\n+            405..406 'x': C<[T]>\n+            418..419 'a': A<[u8; 2]>\n+            433..434 'b': B<[u8; 2]>\n+            448..449 'c': C<[u8; 2]>\n+            463..529 '{     ...(c); }': ()\n+            473..474 'd': A<[{unknown}]>\n+            477..481 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n+            477..484 'foo1(a)': A<[{unknown}]>\n+            482..483 'a': A<[u8; 2]>\n+            494..495 'e': B<[u8]>\n+            498..502 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n+            498..505 'foo2(b)': B<[u8]>\n+            503..504 'b': B<[u8; 2]>\n+            515..516 'f': C<[u8]>\n+            519..523 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n+            519..526 'foo3(c)': C<[u8]>\n+            524..525 'c': C<[u8; 2]>\n         \"#]],\n     );\n }\n@@ -184,21 +176,16 @@ fn infer_custom_coerce_unsized() {\n fn infer_if_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test() {\n-            let x = if true {\n-                foo(&[1])\n-            } else {\n-                &[1]\n-            };\n-        }\n-\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        \"#,\n+//- minicore: unsize\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        foo(&[1])\n+    } else {\n+        &[1]\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -226,25 +213,16 @@ fn infer_if_coerce() {\n fn infer_if_else_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test() {\n-            let x = if true {\n-                &[1]\n-            } else {\n-                foo(&[1])\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        &[1]\n+    } else {\n+        foo(&[1])\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -272,20 +250,16 @@ fn infer_if_else_coerce() {\n fn infer_match_first_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test(i: i32) {\n-            let x = match i {\n-                2 => foo(&[2]),\n-                1 => &[1],\n-                _ => &[3],\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        \"#,\n+//- minicore: unsize\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        2 => foo(&[2]),\n+        1 => &[1],\n+        _ => &[3],\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]\n@@ -320,25 +294,16 @@ fn infer_match_first_coerce() {\n fn infer_match_second_coerce() {\n     check_infer(\n         r#\"\n-        fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-        fn test(i: i32) {\n-            let x = match i {\n-                1 => &[1],\n-                2 => foo(&[2]),\n-                _ => &[3],\n-            };\n-        }\n-\n-        #[lang = \"sized\"]\n-        pub trait Sized {}\n-        #[lang = \"unsize\"]\n-        pub trait Unsize<T: ?Sized> {}\n-        #[lang = \"coerce_unsized\"]\n-        pub trait CoerceUnsized<T> {}\n-\n-        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n-        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n-        \"#,\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        1 => &[1],\n+        2 => foo(&[2]),\n+        _ => &[3],\n+    };\n+}\n+\"#,\n         expect![[r#\"\n             10..11 'x': &[T]\n             27..38 '{ loop {} }': &[T]"}, {"sha": "8f8f1c9f8b58553d085057397c98ab3d3920add2", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f841369fee0f49125c83046340b228b032ebc702/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841369fee0f49125c83046340b228b032ebc702/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=f841369fee0f49125c83046340b228b032ebc702", "patch": "@@ -9,18 +9,21 @@\n //!\n //! Available flags:\n //!     sized:\n-//!     coerce_unsized: sized\n+//!     unsize: sized\n+//!     coerce_unsized: unsize\n \n pub mod marker {\n     // region:sized\n     #[lang = \"sized\"]\n     #[fundamental]\n     #[rustc_specialization_trait]\n     pub trait Sized {}\n+    // endregion:sized\n \n+    // region:unsize\n     #[lang = \"unsize\"]\n     pub trait Unsize<T: ?Sized> {}\n-    // endregion:sized\n+    // endregion:unsize\n }\n \n pub mod ops {\n@@ -44,6 +47,8 @@ pub mod ops {\n         impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n         // endregion:coerce_unsized\n     }\n+\n+    pub use self::unsize::CoerceUnsized; // :coerce_unsized\n }\n \n pub mod prelude {"}]}