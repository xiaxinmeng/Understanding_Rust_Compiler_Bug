{"sha": "ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZmQwODMxMjUyMmI4NWE1YjQwODVhYTBhMmJmNmZiOWI5ODczZDc=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-18T00:28:40Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move Chain and ChainState to own module", "tree": {"sha": "b9cb55d0eb3d48b6df5df62a826bd7de186adc05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9cb55d0eb3d48b6df5df62a826bd7de186adc05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "html_url": "https://github.com/rust-lang/rust/commit/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "520e8b001ef7c49dcf1ad8f1f7817f2b16ad709b", "url": "https://api.github.com/repos/rust-lang/rust/commits/520e8b001ef7c49dcf1ad8f1f7817f2b16ad709b", "html_url": "https://github.com/rust-lang/rust/commit/520e8b001ef7c49dcf1ad8f1f7817f2b16ad709b"}], "stats": {"total": 509, "additions": 258, "deletions": 251}, "files": [{"sha": "5defb857d50d0682b7b10dc20f028e3a90d2b209", "filename": "src/libcore/iter/adapters/chain.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "patch": "@@ -0,0 +1,255 @@\n+use ops::Try;\n+use usize;\n+use super::super::{Iterator, DoubleEndedIterator, FusedIterator, TrustedLen};\n+\n+/// An iterator that strings two iterators together.\n+///\n+/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`chain`]: trait.Iterator.html#method.chain\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chain<A, B> {\n+    pub(in super::super) a: A,\n+    pub(in super::super) b: B,\n+    pub(in super::super) state: ChainState,\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone, Debug)]\n+pub(in super::super) enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(self) -> usize {\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_fold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Back = self.state {\n+            accum = self.b.try_fold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match self.state {\n+            ChainState::Both => match self.a.find(&mut predicate) {\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.find(predicate)\n+                }\n+                v => v\n+            },\n+            ChainState::Front => self.a.find(predicate),\n+            ChainState::Back => self.b.find(predicate),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => {\n+                // Must exhaust a before b.\n+                let a_last = self.a.last();\n+                let b_last = self.b.last();\n+                b_last.or(a_last)\n+            },\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = a_lower.saturating_add(b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => x.checked_add(y),\n+            _ => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n+        }\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_rfold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Front = self.state {\n+            accum = self.a.try_rfold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+}\n+\n+// Note: *both* must be fused to handle double-ended iterators.\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Chain<A, B>\n+    where A: FusedIterator,\n+          B: FusedIterator<Item=A::Item>,\n+{}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Chain<A, B>\n+    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n+{}\n+"}, {"sha": "67c7c7a0566d6bae983dfa50dfd7bbd093c43b1e", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 3, "deletions": 251, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "patch": "@@ -6,9 +6,12 @@ use intrinsics;\n use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n use super::LoopState;\n \n+mod chain;\n mod zip;\n \n+pub use self::chain::Chain;\n pub use self::zip::Zip;\n+pub(super) use self::chain::ChainState;\n pub(super) use self::zip::ZipImpl;\n pub(crate) use self::zip::TrustedRandomAccess;\n \n@@ -457,257 +460,6 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n \n-/// An iterator that strings two iterators together.\n-///\n-/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`chain`]: trait.Iterator.html#method.chain\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Chain<A, B> {\n-    pub(super) a: A,\n-    pub(super) b: B,\n-    pub(super) state: ChainState,\n-}\n-\n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-pub(super) enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Chain<A, B> where\n-    A: Iterator,\n-    B: Iterator<Item = A::Item>\n-{\n-    type Item = A::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x)\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            ChainState::Back => {}\n-        }\n-        if let ChainState::Back = self.state {\n-            self.b.nth(n)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n-                // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n-                b_last.or(a_last)\n-            },\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last()\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = a_lower.saturating_add(b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Chain<A, B> where\n-    A: DoubleEndedIterator,\n-    B: DoubleEndedIterator<Item=A::Item>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n-        }\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-}\n-\n-// Note: *both* must be fused to handle double-ended iterators.\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Chain<A, B>\n-    where A: FusedIterator,\n-          B: FusedIterator<Item=A::Item>,\n-{}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Chain<A, B>\n-    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n-{}\n-\n /// An iterator that maps the values of `iter` with `f`.\n ///\n /// This `struct` is created by the [`map`] method on [`Iterator`]. See its"}]}