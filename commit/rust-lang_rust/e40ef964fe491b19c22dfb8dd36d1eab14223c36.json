{"sha": "e40ef964fe491b19c22dfb8dd36d1eab14223c36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MGVmOTY0ZmU0OTFiMTljMjJkZmI4ZGQzNmQxZWFiMTQyMjNjMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-14T00:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-14T00:40:10Z"}, "message": "Auto merge of #42644 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #42408, #42428, #42496, #42597, #42636, #42638\n- Failed merges: #42612", "tree": {"sha": "03f28fa7e4ab70baca8217f633446e0811f3a32b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f28fa7e4ab70baca8217f633446e0811f3a32b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e40ef964fe491b19c22dfb8dd36d1eab14223c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e40ef964fe491b19c22dfb8dd36d1eab14223c36", "html_url": "https://github.com/rust-lang/rust/commit/e40ef964fe491b19c22dfb8dd36d1eab14223c36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e40ef964fe491b19c22dfb8dd36d1eab14223c36/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03abb1bd70ac56e4aba0684bab819892a0157843", "url": "https://api.github.com/repos/rust-lang/rust/commits/03abb1bd70ac56e4aba0684bab819892a0157843", "html_url": "https://github.com/rust-lang/rust/commit/03abb1bd70ac56e4aba0684bab819892a0157843"}, {"sha": "9242f22666e44d525e57a6f4ade91be450f0ee2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9242f22666e44d525e57a6f4ade91be450f0ee2e", "html_url": "https://github.com/rust-lang/rust/commit/9242f22666e44d525e57a6f4ade91be450f0ee2e"}], "stats": {"total": 319, "additions": 233, "deletions": 86}, "files": [{"sha": "b278b5dbb2ca6dfdd5b5763a18c458ca452c5836", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -165,6 +165,7 @@\n     - [n16](library-features/n16.md)\n     - [never_type_impls](library-features/never-type-impls.md)\n     - [nonzero](library-features/nonzero.md)\n+    - [ord_max_min](library-features/ord-max-min.md)\n     - [offset_to](library-features/offset-to.md)\n     - [once_poison](library-features/once-poison.md)\n     - [oom](library-features/oom.md)"}, {"sha": "564cd1ac30b26514f88772c53915876d0f54397f", "filename": "src/doc/unstable-book/src/library-features/ord-max-min.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ford-max-min.md", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ford-max-min.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ford-max-min.md?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -0,0 +1,7 @@\n+# `ord-max-min`\n+\n+The tracking issue for this feature is: [#25663]\n+\n+[#25663]: https://github.com/rust-lang/rust/issues/25663\n+\n+------------------------"}, {"sha": "91652bfdf2467046f5e35083be2a81933b587de3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -126,7 +126,7 @@ while    { return WHILE; }\n {ident}  { return IDENT; }\n \n 0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n+0o[0-7_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n 0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n [0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n [0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }"}, {"sha": "c6f0b4436bb3179d361e8ac3b920b4f44b6b3081", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -24,6 +24,7 @@\n #![feature(repr_align)]\n #![feature(slice_rotate)]\n #![feature(splice)]\n+#![feature(str_checked_slicing)]\n #![feature(str_escape)]\n #![feature(test)]\n #![feature(unboxed_closures)]"}, {"sha": "9d8ca38b20e48c822af8beb5f756c25c88ad5d7e", "filename": "src/libcollections/tests/str.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcollections%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcollections%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fstr.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -358,6 +358,48 @@ fn test_slice_fail() {\n     &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n }\n \n+#[test]\n+#[should_panic]\n+fn test_str_slice_rangetoinclusive_max_panics() {\n+    &\"hello\"[...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slice_rangeinclusive_max_panics() {\n+    &\"hello\"[1...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slicemut_rangetoinclusive_max_panics() {\n+    let mut s = \"hello\".to_owned();\n+    let s: &mut str = &mut s;\n+    &mut s[...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slicemut_rangeinclusive_max_panics() {\n+    let mut s = \"hello\".to_owned();\n+    let s: &mut str = &mut s;\n+    &mut s[1...usize::max_value()];\n+}\n+\n+#[test]\n+fn test_str_get_maxinclusive() {\n+    let mut s = \"hello\".to_owned();\n+    {\n+        let s: &str = &s;\n+        assert_eq!(s.get(...usize::max_value()), None);\n+        assert_eq!(s.get(1...usize::max_value()), None);\n+    }\n+    {\n+        let s: &mut str = &mut s;\n+        assert_eq!(s.get(...usize::max_value()), None);\n+        assert_eq!(s.get(1...usize::max_value()), None);\n+    }\n+}\n \n #[test]\n fn test_is_char_boundary() {"}, {"sha": "6f35d0417f18b1986f6db9042df62c09b625fa2b", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -443,6 +443,42 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n+\n+    /// Compares and returns the maximum of two values.\n+    ///\n+    /// Returns the second argument if the comparison determines them to be equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ord_max_min)]\n+    ///\n+    /// assert_eq!(2, 1.max(2));\n+    /// assert_eq!(2, 2.max(2));\n+    /// ```\n+    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n+    fn max(self, other: Self) -> Self\n+    where Self: Sized {\n+        if other >= self { other } else { self }\n+    }\n+\n+    /// Compares and returns the minimum of two values.\n+    ///\n+    /// Returns the first argument if the comparison determines them to be equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ord_max_min)]\n+    ///\n+    /// assert_eq!(1, 1.min(2));\n+    /// assert_eq!(2, 2.min(2));\n+    /// ```\n+    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n+    fn min(self, other: Self) -> Self\n+    where Self: Sized {\n+        if self <= other { self } else { other }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -678,6 +714,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n+/// Internally uses an alias to `Ord::min`.\n+///\n /// # Examples\n ///\n /// ```\n@@ -689,13 +727,15 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n-    if v1 <= v2 { v1 } else { v2 }\n+    v1.min(v2)\n }\n \n /// Compares and returns the maximum of two values.\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///\n+/// Internally uses an alias to `Ord::max`.\n+///\n /// # Examples\n ///\n /// ```\n@@ -707,7 +747,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n-    if v2 >= v1 { v2 } else { v1 }\n+    v1.max(v2)\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types"}, {"sha": "34aca592b1e95434d598a990930dcad2d004cd1f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -1617,12 +1617,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeTo<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1636,12 +1631,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeTo<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_mut_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1657,12 +1647,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                unsafe { self.slice_unchecked(index.start, self.len()) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1676,13 +1661,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                let len = self.len();\n-                unsafe { self.slice_mut_unchecked(index.start, len) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1724,9 +1703,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index(index.start .. index.end+1)\n+            index.index(self)\n         }\n     }\n \n@@ -1738,9 +1715,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index(.. index.end+1)\n+            index.index(self)\n         }\n     }\n \n@@ -1750,9 +1725,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index_mut(index.start .. index.end+1)\n+            index.index_mut(self)\n         }\n     }\n     #[unstable(feature = \"inclusive_range\",\n@@ -1761,9 +1734,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index_mut(.. index.end+1)\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1886,6 +1857,7 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n@@ -1932,6 +1904,7 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n@@ -1945,11 +1918,19 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            (self.start..self.end+1).get(slice)\n+            if let Some(end) = self.end.checked_add(1) {\n+                (self.start..end).get(slice)\n+            } else {\n+                None\n+            }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            (self.start..self.end+1).get_mut(slice)\n+            if let Some(end) = self.end.checked_add(1) {\n+                (self.start..end).get_mut(slice)\n+            } else {\n+                None\n+            }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -1961,10 +1942,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             (self.start..self.end+1).index_mut(slice)\n         }\n     }\n@@ -1976,15 +1961,15 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.end + 1) {\n+            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.end + 1) {\n+            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -2002,11 +1987,15 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             let end = self.end + 1;\n             self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             if slice.is_char_boundary(self.end) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {"}, {"sha": "8c5179f59932bba13ef4636260099ae16aabed1c", "filename": "src/libcore/tests/cmp.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -28,6 +28,16 @@ fn test_mut_int_totalord() {\n     assert_eq!((&mut 12).cmp(&&mut -5), Greater);\n }\n \n+#[test]\n+fn test_ord_max_min() {\n+    assert_eq!(1.max(2), 2);\n+    assert_eq!(2.max(1), 2);\n+    assert_eq!(1.min(2), 1);\n+    assert_eq!(2.min(1), 1);\n+    assert_eq!(1.max(1), 1);\n+    assert_eq!(1.min(1), 1);\n+}\n+\n #[test]\n fn test_ordering_reverse() {\n     assert_eq!(Less.reverse(), Greater);"}, {"sha": "77a9307f43ecf97375ea03c0cf4d1b85ccd8bf19", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -26,6 +26,7 @@\n #![feature(iter_rfind)]\n #![feature(libc)]\n #![feature(nonzero)]\n+#![feature(ord_max_min)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(sip_hash_13)]"}, {"sha": "3034242b59408dbc8363ace84eb98fa8337c7f96", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! This module implements some validity checks for attributes.\n+//! In particular it verifies that `#[inline]` and `#[repr]` attributes are\n+//! attached to items that actually support them and if there are\n+//! conflicts between multiple such attributes attached to the same\n+//! item.\n+\n use session::Session;\n \n use syntax::ast;\n@@ -40,6 +46,18 @@ struct CheckAttrVisitor<'a> {\n }\n \n impl<'a> CheckAttrVisitor<'a> {\n+    /// Check any attribute.\n+    fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n+        if let Some(name) = attr.name() {\n+            match &*name.as_str() {\n+                \"inline\" => self.check_inline(attr, target),\n+                \"repr\" => self.check_repr(attr, target),\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    /// Check if an `#[inline]` is applied to a function.\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n             struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n@@ -48,6 +66,7 @@ impl<'a> CheckAttrVisitor<'a> {\n         }\n     }\n \n+    /// Check if an `#[repr]` attr is valid.\n     fn check_repr(&self, attr: &ast::Attribute, target: Target) {\n         let words = match attr.meta_item_list() {\n             Some(words) => words,\n@@ -135,16 +154,6 @@ impl<'a> CheckAttrVisitor<'a> {\n                              \"conflicting packed and align representation hints\").emit();\n         }\n     }\n-\n-    fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        if let Some(name) = attr.name() {\n-            match &*name.as_str() {\n-                \"inline\" => self.check_inline(attr, target),\n-                \"repr\" => self.check_repr(attr, target),\n-                _ => (),\n-            }\n-        }\n-    }\n }\n \n impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {"}, {"sha": "c12df083c30e6875da3d06f8cf9b777b8a0df607", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -2553,42 +2553,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // We also need to make sure we at least write the ty of the other\n         // arguments which we skipped above.\n         if variadic {\n+            fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n+                type_error_struct!(s, span, t, E0617,\n+                                   \"can't pass `{}` to variadic function, cast to `{}`\",\n+                                   t, cast_ty).emit();\n+            }\n+\n             for arg in args.iter().skip(expected_arg_count) {\n                 let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs\n                 // in C but we just error out instead and require explicit casts.\n-                let arg_ty = self.structurally_resolved_type(arg.span,\n-                                                             arg_ty);\n+                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n                 match arg_ty.sty {\n                     ty::TyFloat(ast::FloatTy::F32) => {\n-                        self.type_error_message(arg.span, |t| {\n-                            format!(\"can't pass an `{}` to variadic \\\n-                                     function, cast to `c_double`\", t)\n-                        }, arg_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n                     }\n                     ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n-                        self.type_error_message(arg.span, |t| {\n-                            format!(\"can't pass `{}` to variadic \\\n-                                     function, cast to `c_int`\",\n-                                           t)\n-                        }, arg_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n                     }\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n-                        self.type_error_message(arg.span, |t| {\n-                            format!(\"can't pass `{}` to variadic \\\n-                                     function, cast to `c_uint`\",\n-                                           t)\n-                        }, arg_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n                     ty::TyFnDef(.., f) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(f);\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n-                        self.type_error_message(arg.span,\n-                                                |t| {\n-                            format!(\"can't pass `{}` to variadic \\\n-                                     function, cast to `{}`\", t, ptr_ty)\n-                        }, arg_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, &format!(\"{}\", ptr_ty));\n                     }\n                     _ => {}\n                 }"}, {"sha": "76c664d7997a4fe69652ccf9d07798998f6351b7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -4152,6 +4152,27 @@ println!(\"x: {}, y: {}\", variable.x, variable.y);\n For more information see The Rust Book: https://doc.rust-lang.org/book/\n \"##,\n \n+E0617: r##\"\n+Attempted to pass an invalid type of variable into a variadic function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0617\n+extern {\n+    fn printf(c: *const i8, ...);\n+}\n+\n+unsafe {\n+    printf(::std::ptr::null(), 0f32);\n+    // error: can't pass an `f32` to variadic function, cast to `c_double`\n+}\n+```\n+\n+To fix this error, you need to pass variables corresponding to C types as much\n+as possible. For better explanations, see The Rust Book:\n+https://doc.rust-lang.org/book/\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "dda11e50380f516f6a031ebd18f6411c5f68ee80", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -787,12 +787,16 @@ pub fn park_timeout_ms(ms: u32) {\n ///\n /// let timeout = Duration::from_secs(2);\n /// let beginning_park = Instant::now();\n-/// park_timeout(timeout);\n ///\n-/// while beginning_park.elapsed() < timeout {\n-///     println!(\"restarting park_timeout after {:?}\", beginning_park.elapsed());\n-///     let timeout = timeout - beginning_park.elapsed();\n-///     park_timeout(timeout);\n+/// let mut timeout_remaining = timeout;\n+/// loop {\n+///     park_timeout(timeout_remaining);\n+///     let elapsed = beginning_park.elapsed();\n+///     if elapsed >= timeout {\n+///         break;\n+///     }\n+///     println!(\"restarting park_timeout after {:?}\", elapsed);\n+///     timeout_remaining = timeout - elapsed;\n /// }\n /// ```\n ///"}, {"sha": "7b769ff4ae2e09f8d956f87ebe73939e03bdb6dc", "filename": "src/test/compile-fail/E0617.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Ftest%2Fcompile-fail%2FE0617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Ftest%2Fcompile-fail%2FE0617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0617.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+extern {\n+    fn printf(c: *const i8, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        printf(::std::ptr::null(), 0f32);\n+        //~^ ERROR can't pass `f32` to variadic function, cast to `c_double` [E0617]\n+        printf(::std::ptr::null(), 0i8);\n+        //~^ ERROR can't pass `i8` to variadic function, cast to `c_int` [E0617]\n+        printf(::std::ptr::null(), 0i16);\n+        //~^ ERROR can't pass `i16` to variadic function, cast to `c_int` [E0617]\n+        printf(::std::ptr::null(), 0u8);\n+        //~^ ERROR can't pass `u8` to variadic function, cast to `c_uint` [E0617]\n+        printf(::std::ptr::null(), 0u16);\n+        //~^ ERROR can't pass `u16` to variadic function, cast to `c_uint` [E0617]\n+        printf(::std::ptr::null(), printf);\n+        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function, cast to `unsafe extern \"C\" fn(*const i8, ...)` [E0617]\n+    }\n+}"}, {"sha": "fb102027180f0d997cc6189421dfa0675c4e8ced", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40ef964fe491b19c22dfb8dd36d1eab14223c36/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=e40ef964fe491b19c22dfb8dd36d1eab14223c36", "patch": "@@ -35,11 +35,11 @@ fn main() {\n         //~| found type `extern \"C\" fn(isize, u8) {bar}`\n         //~| NOTE: expected variadic fn, found non-variadic function\n \n-        foo(1, 2, 3f32); //~ ERROR: can't pass an `f32` to variadic function, cast to `c_double`\n-        foo(1, 2, true); //~ ERROR: can't pass `bool` to variadic function, cast to `c_int`\n-        foo(1, 2, 1i8); //~ ERROR: can't pass `i8` to variadic function, cast to `c_int`\n-        foo(1, 2, 1u8); //~ ERROR: can't pass `u8` to variadic function, cast to `c_uint`\n-        foo(1, 2, 1i16); //~ ERROR: can't pass `i16` to variadic function, cast to `c_int`\n-        foo(1, 2, 1u16); //~ ERROR: can't pass `u16` to variadic function, cast to `c_uint`\n+        foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function, cast to `c_double`\n+        foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function, cast to `c_int`\n+        foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function, cast to `c_int`\n+        foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function, cast to `c_uint`\n+        foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function, cast to `c_int`\n+        foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function, cast to `c_uint`\n     }\n }"}]}