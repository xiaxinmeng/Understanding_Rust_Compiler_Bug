{"sha": "da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "node_id": "C_kwDOAAsO6NoAKGRhM2VjYjA5ZDhkZGE1MjkzNTY5ZWJmNGUxM2FkZTNmN2UyODI1ZjA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-22T05:11:24Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-23T16:53:23Z"}, "message": "Use proper InferCtxt when probing for associated types in astconv", "tree": {"sha": "69e3b3268e4df2f7f7f0f2c0591090a567b88472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69e3b3268e4df2f7f7f0f2c0591090a567b88472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "html_url": "https://github.com/rust-lang/rust/commit/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7"}], "stats": {"total": 143, "additions": 97, "deletions": 46}, "files": [{"sha": "d23368e9bae5a268b2673681343822ecf057911a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "patch": "@@ -27,7 +27,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -37,7 +37,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -54,7 +54,7 @@ use std::slice;\n pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn item_def_id(&self) -> DefId;\n \n@@ -131,6 +131,8 @@ pub trait AstConv<'tcx> {\n     {\n         self\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>>;\n }\n \n #[derive(Debug)]\n@@ -2132,48 +2134,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     )\n                     .emit() // Already reported in an earlier stage.\n                 } else {\n-                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n-                    // associated type, so that we suggest the right one.\n-                    let infcx = tcx.infer_ctxt().build();\n-                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n-                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n-                    let param_env = ty::ParamEnv::empty();\n-                    let traits: Vec<_> = self\n-                        .tcx()\n-                        .all_traits()\n-                        .filter(|trait_def_id| {\n-                            // Consider only traits with the associated type\n-                            tcx.associated_items(*trait_def_id)\n-                                .in_definition_order()\n-                                .any(|i| {\n-                                    i.kind.namespace() == Namespace::TypeNS\n-                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n-                                        && matches!(i.kind, ty::AssocKind::Type)\n-                                })\n-                            // Consider only accessible traits\n-                            && tcx.visibility(*trait_def_id)\n-                                .is_accessible_from(self.item_def_id(), tcx)\n-                            && tcx.all_impls(*trait_def_id)\n-                                .any(|impl_def_id| {\n-                                    let trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                                    trait_ref.map_or(false, |trait_ref| {\n-                                        let impl_ = trait_ref.subst(\n-                                            tcx,\n-                                            infcx.fresh_substs_for_item(span, impl_def_id),\n-                                        );\n-                                        infcx\n-                                            .can_eq(\n-                                                param_env,\n-                                                tcx.erase_regions(impl_.self_ty()),\n-                                                tcx.erase_regions(qself_ty),\n-                                            )\n-                                            .is_ok()\n-                                    })\n-                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n-                                })\n-                        })\n-                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n-                        .collect();\n+                    let traits: Vec<_> =\n+                        self.probe_traits_that_match_assoc_ty(qself_ty, assoc_ident);\n \n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n@@ -2232,6 +2194,60 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn probe_traits_that_match_assoc_ty(\n+        &self,\n+        qself_ty: Ty<'tcx>,\n+        assoc_ident: Ident,\n+    ) -> Vec<String> {\n+        let tcx = self.tcx();\n+\n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = if let Some(infcx) = self.infcx() {\n+            infcx\n+        } else {\n+            assert!(!qself_ty.needs_infer());\n+            infcx_ = tcx.infer_ctxt().build();\n+            &infcx_\n+        };\n+\n+        tcx.all_traits()\n+            .filter(|trait_def_id| {\n+                // Consider only traits with the associated type\n+                tcx.associated_items(*trait_def_id)\n+                        .in_definition_order()\n+                        .any(|i| {\n+                            i.kind.namespace() == Namespace::TypeNS\n+                                && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                && matches!(i.kind, ty::AssocKind::Type)\n+                        })\n+                    // Consider only accessible traits\n+                    && tcx.visibility(*trait_def_id)\n+                        .is_accessible_from(self.item_def_id(), tcx)\n+                    && tcx.all_impls(*trait_def_id)\n+                        .any(|impl_def_id| {\n+                            let trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                            trait_ref.map_or(false, |trait_ref| {\n+                                let impl_ = trait_ref.subst(\n+                                    tcx,\n+                                    infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n+                                );\n+                                infcx\n+                                    .can_eq(\n+                                        ty::ParamEnv::empty(),\n+                                        tcx.erase_regions(impl_.self_ty()),\n+                                        tcx.erase_regions(qself_ty),\n+                                    )\n+                                    .is_ok()\n+                            })\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                        })\n+            })\n+            .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+            .collect()\n+    }\n+\n     fn lookup_assoc_ty(\n         &self,\n         ident: Ident,"}, {"sha": "c3ea867785b1461f1fdb2eb41409895ee7342a74", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "patch": "@@ -25,7 +25,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericParamKind, Node};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::query::Providers;\n@@ -517,6 +517,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n         // There's no place to record types from signatures?\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>> {\n+        None\n+    }\n }\n \n /// Synthesize a new lifetime name that doesn't clash with any of the lifetimes already present."}, {"sha": "2747dabc2368fab1ab9e5b6789b6774e367e15b3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "patch": "@@ -324,6 +324,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n         self.write_ty(hir_id, ty)\n     }\n+\n+    fn infcx(&self) -> Option<&infer::InferCtxt<'tcx>> {\n+        Some(&self.infcx)\n+    }\n }\n \n /// Represents a user-provided type in the raw form (never normalized)."}, {"sha": "135cdf19e3e3e417b81bd27465df5e5b365d252a", "filename": "tests/ui/typeck/issue-107087.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/tests%2Fui%2Ftypeck%2Fissue-107087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/tests%2Fui%2Ftypeck%2Fissue-107087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107087.rs?ref=da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "patch": "@@ -0,0 +1,18 @@\n+struct A<T>(T);\n+\n+trait Foo {\n+    type B;\n+}\n+\n+impl Foo for A<u32> {\n+    type B = i32;\n+}\n+\n+impl Foo for A<i32> {\n+    type B = i32;\n+}\n+\n+fn main() {\n+    A::B::<>::C\n+    //~^ ERROR ambiguous associated type\n+}"}, {"sha": "70f19320802b91142d13e676f132f3f47ce9a3b8", "filename": "tests/ui/typeck/issue-107087.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/tests%2Fui%2Ftypeck%2Fissue-107087.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da3ecb09d8dda5293569ebf4e13ade3f7e2825f0/tests%2Fui%2Ftypeck%2Fissue-107087.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107087.stderr?ref=da3ecb09d8dda5293569ebf4e13ade3f7e2825f0", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/issue-107087.rs:16:5\n+   |\n+LL |     A::B::<>::C\n+   |     ^^^^^^^^ help: use the fully-qualified path: `<A<_> as Foo>::B`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}]}