{"sha": "6ab0e292d2f8302d4e051cdaa49dd440855c1348", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYjBlMjkyZDJmODMwMmQ0ZTA1MWNkYWE0OWRkNDQwODU1YzEzNDg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-29T22:35:57Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-04T18:14:22Z"}, "message": "Refactor a bit", "tree": {"sha": "f20d8e994bbd3d419285d834a3d08e2f8a15763c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20d8e994bbd3d419285d834a3d08e2f8a15763c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ab0e292d2f8302d4e051cdaa49dd440855c1348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab0e292d2f8302d4e051cdaa49dd440855c1348", "html_url": "https://github.com/rust-lang/rust/commit/6ab0e292d2f8302d4e051cdaa49dd440855c1348", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ab0e292d2f8302d4e051cdaa49dd440855c1348/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538147bf94b4c52a945c975b67e8d557998f9052", "url": "https://api.github.com/repos/rust-lang/rust/commits/538147bf94b4c52a945c975b67e8d557998f9052", "html_url": "https://github.com/rust-lang/rust/commit/538147bf94b4c52a945c975b67e8d557998f9052"}], "stats": {"total": 120, "additions": 62, "deletions": 58}, "files": [{"sha": "45a01679ce2fd7dcfed1d19589bb7721e9b2d62a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6ab0e292d2f8302d4e051cdaa49dd440855c1348/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab0e292d2f8302d4e051cdaa49dd440855c1348/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6ab0e292d2f8302d4e051cdaa49dd440855c1348", "patch": "@@ -522,6 +522,8 @@ struct InferenceContext<'a, D: HirDatabase> {\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    /// The return type of the function being inferred.\n+    return_ty: Ty,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -534,7 +536,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceContext {\n             type_of: FxHashMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n-            self_param: None, // set during parameter typing\n+            self_param: None,       // set during parameter typing\n+            return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             scopes,\n             module,\n@@ -555,6 +558,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n     }\n \n+    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    }\n+\n+    fn make_ty_opt(&self, type_ref: Option<&TypeRef>) -> Cancelable<Ty> {\n+        Ty::from_hir_opt(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    }\n+\n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         match (ty1, ty2) {\n             (Ty::Unknown, ..) => true,\n@@ -952,78 +963,71 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.write_ty(node.syntax(), ty.clone());\n         Ok(ty)\n     }\n-}\n-\n-pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n-    let function = Function::new(def_id); // TODO: consts also need inference\n-    let scopes = function.scopes(db);\n-    let module = function.module(db)?;\n-    let impl_block = function.impl_block(db)?;\n-    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n \n-    let syntax = function.syntax(db);\n-    let node = syntax.borrowed();\n-\n-    if let Some(param_list) = node.param_list() {\n-        if let Some(self_param) = param_list.self_param() {\n-            let self_type = if let Some(impl_block) = &ctx.impl_block {\n-                if let Some(type_ref) = self_param.type_ref() {\n-                    let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n-                    ctx.insert_type_vars(ty)\n+    fn collect_fn_signature(&mut self, node: ast::FnDef) -> Cancelable<()> {\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.type_ref() {\n+                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+                    self.insert_type_vars(ty)\n                 } else {\n                     // TODO this should be handled by desugaring during HIR conversion\n-                    let ty = Ty::from_hir(\n-                        db,\n-                        &ctx.module,\n-                        ctx.impl_block.as_ref(),\n-                        impl_block.target(),\n-                    )?;\n+                    let ty = self.make_ty_opt(self.impl_block.as_ref().map(|i| i.target()))?;\n                     let ty = match self_param.flavor() {\n                         ast::SelfParamFlavor::Owned => ty,\n                         ast::SelfParamFlavor::Ref => Ty::Ref(Arc::new(ty), Mutability::Shared),\n                         ast::SelfParamFlavor::MutRef => Ty::Ref(Arc::new(ty), Mutability::Mut),\n                     };\n-                    ctx.insert_type_vars(ty)\n+                    self.insert_type_vars(ty)\n+                };\n+                if let Some(self_kw) = self_param.self_kw() {\n+                    let self_param = LocalSyntaxPtr::new(self_kw.syntax());\n+                    self.self_param = Some(self_param);\n+                    self.type_of.insert(self_param, self_type);\n                 }\n-            } else {\n-                log::debug!(\n-                    \"No impl block found, but self param for function {:?}\",\n-                    def_id\n-                );\n-                ctx.new_type_var()\n-            };\n-            if let Some(self_kw) = self_param.self_kw() {\n-                let self_param = LocalSyntaxPtr::new(self_kw.syntax());\n-                ctx.self_param = Some(self_param);\n-                ctx.type_of.insert(self_param, self_type);\n+            }\n+            for param in param_list.params() {\n+                let pat = if let Some(pat) = param.pat() {\n+                    pat\n+                } else {\n+                    continue;\n+                };\n+                let ty = if let Some(type_ref) = param.type_ref() {\n+                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+                    self.insert_type_vars(ty)\n+                } else {\n+                    // missing type annotation\n+                    self.new_type_var()\n+                };\n+                self.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n             }\n         }\n-        for param in param_list.params() {\n-            let pat = if let Some(pat) = param.pat() {\n-                pat\n-            } else {\n-                continue;\n-            };\n-            let ty = if let Some(type_ref) = param.type_ref() {\n-                let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n-                ctx.insert_type_vars(ty)\n-            } else {\n-                // missing type annotation\n-                ctx.new_type_var()\n-            };\n-            ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n-        }\n+\n+        self.return_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n+            let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n+            self.insert_type_vars(ty)\n+        } else {\n+            Ty::unit()\n+        };\n+\n+        Ok(())\n     }\n+}\n \n-    let ret_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n-        let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n-        ctx.insert_type_vars(ty)\n-    } else {\n-        Ty::unit()\n-    };\n+pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+    let function = Function::new(def_id); // TODO: consts also need inference\n+    let scopes = function.scopes(db);\n+    let module = function.module(db)?;\n+    let impl_block = function.impl_block(db)?;\n+    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n+\n+    let syntax = function.syntax(db);\n+    let node = syntax.borrowed();\n+\n+    ctx.collect_fn_signature(node)?;\n \n     if let Some(block) = node.body() {\n-        ctx.infer_block(block, &Expectation::has_type(ret_ty))?;\n+        ctx.infer_block(block, &Expectation::has_type(ctx.return_ty.clone()))?;\n     }\n \n     Ok(Arc::new(ctx.resolve_all()))"}]}