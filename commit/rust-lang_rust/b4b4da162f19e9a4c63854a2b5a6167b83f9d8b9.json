{"sha": "b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjRkYTE2MmYxOWU5YTRjNjM4NTRhMmI1YTYxNjdiODNmOWQ4Yjk=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-06-10T03:51:23Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-09-24T21:02:05Z"}, "message": "Introduce Start and StartKind", "tree": {"sha": "fc2022daa609b3ccef781cdc8d676f4e8ccd87ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc2022daa609b3ccef781cdc8d676f4e8ccd87ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "html_url": "https://github.com/rust-lang/rust/commit/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1026b42f0694eb9239b5cebe80be743d5ded0da5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1026b42f0694eb9239b5cebe80be743d5ded0da5", "html_url": "https://github.com/rust-lang/rust/commit/1026b42f0694eb9239b5cebe80be743d5ded0da5"}], "stats": {"total": 67, "additions": 53, "deletions": 14}, "files": [{"sha": "157dff59d4491ff81d88162002555b8d195c5298", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "patch": "@@ -818,13 +818,29 @@ impl Offset {\n             sign: OffsetSign::Positive,\n         }\n     }\n+\n+    fn empty() -> Self {\n+        Self::positive(\"0\".into())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n }\n \n struct IndexExpr<'hir> {\n     base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n     idx_offset: Offset,\n }\n \n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n+}\n+\n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.kind() {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n@@ -845,35 +861,54 @@ fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     }\n }\n \n-fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, start: HirId) -> Option<Offset> {\n-    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, start: HirId) -> Option<String> {\n+fn get_offset<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn extract_start<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &Expr<'_>,\n+        starts: &[Start<'tcx>],\n+    ) -> Option<StartKind<'tcx>> {\n+        starts.iter().find(|var| same_var(cx, expr, var.id)).map(|v| v.kind)\n+    }\n+\n+    fn extract_offset<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        e: &Expr<'_>,\n+        starts: &[Start<'tcx>],\n+    ) -> Option<String> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n-            ExprKind::Path(..) if !same_var(cx, e, start) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if extract_start(cx, e, starts).is_none() => {\n+                Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into()))\n+            },\n             _ => None,\n         }\n     }\n \n     match idx.kind {\n         ExprKind::Binary(op, lhs, rhs) => match op.node {\n             BinOpKind::Add => {\n-                let offset_opt = if same_var(cx, lhs, start) {\n-                    extract_offset(cx, rhs, start)\n-                } else if same_var(cx, rhs, start) {\n-                    extract_offset(cx, lhs, start)\n+                let offset_opt = if let Some(s) = extract_start(cx, lhs, starts) {\n+                    extract_offset(cx, rhs, starts).map(|o| (s, o))\n+                } else if let Some(s) = extract_start(cx, rhs, starts) {\n+                    extract_offset(cx, lhs, starts).map(|o| (s, o))\n                 } else {\n                     None\n                 };\n \n-                offset_opt.map(Offset::positive)\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n             },\n-            BinOpKind::Sub if same_var(cx, lhs, start) => extract_offset(cx, rhs, start).map(Offset::negative),\n+            BinOpKind::Sub => extract_start(cx, lhs, starts)\n+                .and_then(|s| extract_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o)))),\n             _ => None,\n         },\n-        ExprKind::Path(..) if same_var(cx, idx, start) => Some(Offset::positive(\"0\".into())),\n+        ExprKind::Path(..) => extract_start(cx, idx, starts).map(|s| (s, Offset::empty())),\n         _ => None,\n     }\n }\n@@ -1008,6 +1043,10 @@ fn detect_manual_memcpy<'tcx>(\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n             let big_sugg = get_assignments(body)\n@@ -1019,14 +1058,14 @@ fn detect_manual_memcpy<'tcx>(\n                             if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n                             if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n                                 && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n-                            if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n-                            if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n+                            if let Some((start_left, offset_left)) = get_offset(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_offset(cx, &idx_right, &starts);\n \n                             // Source and destination must be different\n                             if var_def_id(cx, base_left) != var_def_id(cx, base_right);\n                             then {\n-                                Some((IndexExpr { base: base_left, idx_offset: offset_left },\n-                                    IndexExpr { base: base_right, idx_offset: offset_right }))\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n                             } else {\n                                 None\n                             }"}]}