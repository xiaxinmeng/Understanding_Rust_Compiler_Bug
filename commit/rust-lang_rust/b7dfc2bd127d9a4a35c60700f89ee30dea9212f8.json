{"sha": "b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGZjMmJkMTI3ZDlhNGEzNWM2MDcwMGY4OWVlMzBkZWE5MjEyZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-18T19:45:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-18T19:45:53Z"}, "message": "Auto merge of #37776 - nrc:save-double-angle, r=@brson\n\nsave-analysis: handle << and >> operators inside [] in types\n\nFixes #37700", "tree": {"sha": "3844bd6fa0d5a6d75ab2b68952bc540260d3b47e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3844bd6fa0d5a6d75ab2b68952bc540260d3b47e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "html_url": "https://github.com/rust-lang/rust/commit/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "195c42c426456e0aa1fe1a8f620e25c9c295754d", "url": "https://api.github.com/repos/rust-lang/rust/commits/195c42c426456e0aa1fe1a8f620e25c9c295754d", "html_url": "https://github.com/rust-lang/rust/commit/195c42c426456e0aa1fe1a8f620e25c9c295754d"}, {"sha": "8a949dfea2c26d55aad036cf2b4000a2d45f5159", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a949dfea2c26d55aad036cf2b4000a2d45f5159", "html_url": "https://github.com/rust-lang/rust/commit/8a949dfea2c26d55aad036cf2b4000a2d45f5159"}], "stats": {"total": 62, "additions": 48, "deletions": 14}, "files": [{"sha": "9ec764b82f869bf1c9c90795b717dd8303e9a024", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "patch": "@@ -177,25 +177,44 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     // Return the span for the last ident before a `<` and outside any\n-    // brackets, or the last span.\n+    // angle brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n         let mut result = None;\n+\n+        // We keep track of the following two counts - the depth of nesting of\n+        // angle brackets, and the depth of nesting of square brackets. For the\n+        // angle bracket count, we only count tokens which occur outside of any\n+        // square brackets (i.e. bracket_count == 0). The intutition here is\n+        // that we want to count angle brackets in the type, but not any which\n+        // could be in expression context (because these could mean 'less than',\n+        // etc.).\n+        let mut angle_count = 0;\n         let mut bracket_count = 0;\n         loop {\n             let next = toks.real_token();\n \n-            if (next.tok == token::Lt || next.tok == token::Colon) && bracket_count == 0 &&\n+            if (next.tok == token::Lt || next.tok == token::Colon) &&\n+               angle_count == 0 &&\n+               bracket_count == 0 &&\n                prev.tok.is_ident() {\n                 result = Some(prev.sp);\n             }\n \n+            if bracket_count == 0 {\n+                angle_count += match prev.tok {\n+                    token::Lt => 1,\n+                    token::Gt => -1,\n+                    token::BinOp(token::Shl) => 2,\n+                    token::BinOp(token::Shr) => -2,\n+                    _ => 0,\n+                };\n+            }\n+\n             bracket_count += match prev.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shl) => 2,\n-                token::BinOp(token::Shr) => -2,\n+                token::OpenDelim(token::Bracket) => 1,\n+                token::CloseDelim(token::Bracket) => -1,\n                 _ => 0,\n             };\n \n@@ -204,7 +223,7 @@ impl<'a> SpanUtils<'a> {\n             }\n             prev = next;\n         }\n-        if bracket_count != 0 {\n+        if angle_count != 0 || bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             span_bug!(span,\n                       \"Mis-counted brackets when breaking path? Parsing '{}' \\\n@@ -213,7 +232,7 @@ impl<'a> SpanUtils<'a> {\n                       loc.file.name,\n                       loc.line);\n         }\n-        if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n+        if result.is_none() && prev.tok.is_ident() && angle_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n         }\n         self.make_sub_span(span, result)\n@@ -222,19 +241,20 @@ impl<'a> SpanUtils<'a> {\n     // Reparse span and return an owned vector of sub spans of the first limit\n     // identifier tokens in the given nesting level.\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of brackets: [Foo]\n-    // Nesting = 1: idents within one level of brackets: [Bar, Bar]\n+    // Nesting = 0: all idents outside of angle brackets: [Foo]\n+    // Nesting = 1: idents within one level of angle brackets: [Bar, Bar]\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec![];\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n+        let mut angle_count: isize = 0;\n         let mut bracket_count: isize = 0;\n         let mut found_ufcs_sep = false;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n-                if bracket_count != 0 {\n+                if angle_count != 0 || bracket_count != 0 {\n                     if generated_code(span) {\n                         return vec![];\n                     }\n@@ -252,6 +272,14 @@ impl<'a> SpanUtils<'a> {\n                 return result;\n             }\n             bracket_count += match ts.tok {\n+                token::OpenDelim(token::Bracket) => 1,\n+                token::CloseDelim(token::Bracket) => -1,\n+                _ => 0,\n+            };\n+            if bracket_count > 0 {\n+                continue;\n+            }\n+            angle_count += match ts.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n                 token::BinOp(token::Shl) => 2,\n@@ -269,11 +297,11 @@ impl<'a> SpanUtils<'a> {\n             // path, trying to pull out the non-nested idents (e.g., avoiding 'a\n             // in `<A as B<'a>>::C`). So we end up with a span for `B>::C` from\n             // the start of the first ident to the end of the path.\n-            if !found_ufcs_sep && bracket_count == -1 {\n+            if !found_ufcs_sep && angle_count == -1 {\n                 found_ufcs_sep = true;\n-                bracket_count += 1;\n+                angle_count += 1;\n             }\n-            if ts.tok.is_ident() && bracket_count == nesting {\n+            if ts.tok.is_ident() && angle_count == nesting {\n                 result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n             }\n         }"}, {"sha": "e8b69729af673d6675a793b271e3e8c83a496cfc", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7dfc2bd127d9a4a35c60700f89ee30dea9212f8/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=b7dfc2bd127d9a4a35c60700f89ee30dea9212f8", "patch": "@@ -57,6 +57,12 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n     let y = x.1;\n }\n \n+// Issue #37700\n+const LUT_BITS: usize = 3;\n+pub struct HuffmanTable {\n+    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n+}\n+\n struct TupStruct(isize, isize, Box<str>);\n \n fn test_tup_struct(x: TupStruct) -> isize {"}]}