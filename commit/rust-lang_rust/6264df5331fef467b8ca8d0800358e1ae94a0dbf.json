{"sha": "6264df5331fef467b8ca8d0800358e1ae94a0dbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjRkZjUzMzFmZWY0NjdiOGNhOGQwODAwMzU4ZTFhZTk0YTBkYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-28T05:29:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-28T05:29:09Z"}, "message": "auto merge of #6777 : alexcrichton/rust/less-memory, r=graydon\n\nVia my super-accurate timing (`/usr/bin/time -l`), I get 2431119360 => 1884430336 == ~520MB\r\n\r\nCloses #6637.", "tree": {"sha": "0aa812b0a77dd202d3c30e78c8626701d085f132", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa812b0a77dd202d3c30e78c8626701d085f132"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6264df5331fef467b8ca8d0800358e1ae94a0dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6264df5331fef467b8ca8d0800358e1ae94a0dbf", "html_url": "https://github.com/rust-lang/rust/commit/6264df5331fef467b8ca8d0800358e1ae94a0dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6264df5331fef467b8ca8d0800358e1ae94a0dbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26fb16e36fe5843b745fa1f3a1b333352300798c", "url": "https://api.github.com/repos/rust-lang/rust/commits/26fb16e36fe5843b745fa1f3a1b333352300798c", "html_url": "https://github.com/rust-lang/rust/commit/26fb16e36fe5843b745fa1f3a1b333352300798c"}, {"sha": "ae7df57c5aa40a247306c887159d466922f9be7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7df57c5aa40a247306c887159d466922f9be7e", "html_url": "https://github.com/rust-lang/rust/commit/ae7df57c5aa40a247306c887159d466922f9be7e"}], "stats": {"total": 352, "additions": 192, "deletions": 160}, "files": [{"sha": "96ccb2999ae15fab74d040203a4e3beba3c6d419", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 126, "deletions": 117, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/6264df5331fef467b8ca8d0800358e1ae94a0dbf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6264df5331fef467b8ca8d0800358e1ae94a0dbf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=6264df5331fef467b8ca8d0800358e1ae94a0dbf", "patch": "@@ -299,7 +299,7 @@ struct Context {\n     // Others operate directly on @ast::item structures (or similar). Finally,\n     // others still are added to the Session object via `add_lint`, and these\n     // are all passed with the lint_session visitor.\n-    visitors: ~[visit::vt<()>],\n+    visitors: ~[visit::vt<@mut Context>],\n }\n \n impl Context {\n@@ -416,20 +416,20 @@ impl Context {\n         }\n     }\n \n-    fn add_lint(&mut self, v: visit::vt<()>) {\n+    fn add_lint(&mut self, v: visit::vt<@mut Context>) {\n         self.visitors.push(item_stopping_visitor(v));\n     }\n \n-    fn process(&self, n: AttributedNode) {\n+    fn process(@mut self, n: AttributedNode) {\n         match n {\n             Item(it) => {\n                 for self.visitors.each |v| {\n-                    visit::visit_item(it, (), *v);\n+                    visit::visit_item(it, self, *v);\n                 }\n             }\n             Crate(c) => {\n                 for self.visitors.each |v| {\n-                    visit::visit_crate(c, (), *v);\n+                    visit::visit_crate(c, self, *v);\n                 }\n             }\n             // Can't use visit::visit_method_helper because the\n@@ -439,7 +439,7 @@ impl Context {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n                 for self.visitors.each |v| {\n                     visit::visit_fn(&fk, &m.decl, &m.body, m.span, m.id,\n-                                    (), *v);\n+                                    self, *v);\n                 }\n             }\n         }\n@@ -499,9 +499,9 @@ fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {visit_ty: |_t, _e, _v| { },.. **v})\n }\n \n-fn lint_while_true(cx: @mut Context) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: |e: @ast::expr| {\n+fn lint_while_true() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, cx: @mut Context, vt| {\n             match e.node {\n                 ast::expr_while(cond, _) => {\n                     match cond.node {\n@@ -517,12 +517,13 @@ fn lint_while_true(cx: @mut Context) -> visit::vt<()> {\n                 }\n                 _ => ()\n             }\n+            visit::visit_expr(e, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_type_limits(cx: @mut Context) -> visit::vt<()> {\n+fn lint_type_limits() -> visit::vt<@mut Context> {\n     fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n@@ -568,7 +569,7 @@ fn lint_type_limits(cx: @mut Context) -> visit::vt<()> {\n         }\n     }\n \n-    fn check_limits(cx: @mut Context, binop: ast::binop, l: &ast::expr,\n+    fn check_limits(cx: &Context, binop: ast::binop, l: &ast::expr,\n                     r: &ast::expr) -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::expr_lit(_), _) => (l, r, true),\n@@ -621,26 +622,26 @@ fn lint_type_limits(cx: @mut Context) -> visit::vt<()> {\n         }\n     }\n \n-    let visit_expr: @fn(@ast::expr) = |e| {\n-        match e.node {\n-            ast::expr_binary(ref binop, @ref l, @ref r) => {\n-                if is_comparison(*binop)\n-                    && !check_limits(cx, *binop, l, r) {\n-                    cx.span_lint(type_limits, e.span,\n-                                 \"comparison is useless due to type limits\");\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, cx: @mut Context, vt| {\n+            match e.node {\n+                ast::expr_binary(ref binop, @ref l, @ref r) => {\n+                    if is_comparison(*binop)\n+                        && !check_limits(cx, *binop, l, r) {\n+                        cx.span_lint(type_limits, e.span,\n+                                     \"comparison is useless due to type limits\");\n+                    }\n                 }\n+                _ => ()\n             }\n-            _ => ()\n-        }\n-    };\n+            visit::visit_expr(e, cx, vt);\n+        },\n \n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: visit_expr,\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn check_item_default_methods(cx: @mut Context, item: @ast::item) {\n+fn check_item_default_methods(cx: &Context, item: @ast::item) {\n     match item.node {\n         ast::item_trait(_, _, ref methods) => {\n             for methods.each |method| {\n@@ -657,9 +658,9 @@ fn check_item_default_methods(cx: @mut Context, item: @ast::item) {\n     }\n }\n \n-fn check_item_ctypes(cx: @mut Context, it: @ast::item) {\n+fn check_item_ctypes(cx: &Context, it: @ast::item) {\n \n-    fn check_foreign_fn(cx: @mut Context, decl: &ast::fn_decl) {\n+    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -699,7 +700,7 @@ fn check_item_ctypes(cx: @mut Context, it: @ast::item) {\n     }\n }\n \n-fn check_type_for_lint(cx: @mut Context, lint: lint, span: span, ty: ty::t) {\n+fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n     if cx.get_level(lint) == allow { return }\n \n     let mut n_box = 0;\n@@ -726,13 +727,13 @@ fn check_type_for_lint(cx: @mut Context, lint: lint, span: span, ty: ty::t) {\n     }\n }\n \n-fn check_type(cx: @mut Context, span: span, ty: ty::t) {\n+fn check_type(cx: &Context, span: span, ty: ty::t) {\n     for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n         check_type_for_lint(cx, *lint, span, ty);\n     }\n }\n \n-fn check_item_heap(cx: @mut Context, it: @ast::item) {\n+fn check_item_heap(cx: &Context, it: @ast::item) {\n     match it.node {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n@@ -756,19 +757,20 @@ fn check_item_heap(cx: @mut Context, it: @ast::item) {\n     }\n }\n \n-fn lint_heap(cx: @mut Context) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: |e| {\n+fn lint_heap() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, cx: @mut Context, vt| {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n+            visit::visit_expr(e, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_path_statement(cx: @mut Context) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_stmt: |s| {\n+fn lint_path_statement() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_stmt: |s, cx: @mut Context, vt| {\n             match s.node {\n                 ast::stmt_semi(\n                     @ast::expr { node: ast::expr_path(_), _ },\n@@ -779,12 +781,13 @@ fn lint_path_statement(cx: @mut Context) -> visit::vt<()> {\n                 }\n                 _ => ()\n             }\n+            visit::visit_stmt(s, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n+fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n@@ -808,7 +811,7 @@ fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n         }\n     }\n \n-    fn check_case(cx: @mut Context, ident: ast::ident, span: span) {\n+    fn check_case(cx: &Context, ident: ast::ident, span: span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(non_camel_case_types, span,\n                          \"type, variant, or trait should have \\\n@@ -831,27 +834,26 @@ fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n     }\n }\n \n-fn lint_unused_unsafe(cx: @mut Context) -> visit::vt<()> {\n-    let visit_expr: @fn(@ast::expr) = |e| {\n-        match e.node {\n-            ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n-                if !cx.tcx.used_unsafe.contains(&blk.node.id) {\n-                    cx.span_lint(unused_unsafe, blk.span,\n-                                 \"unnecessary `unsafe` block\");\n+fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, cx: @mut Context, vt| {\n+            match e.node {\n+                ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n+                    if !cx.tcx.used_unsafe.contains(&blk.node.id) {\n+                        cx.span_lint(unused_unsafe, blk.span,\n+                                     \"unnecessary `unsafe` block\");\n+                    }\n                 }\n+                _ => ()\n             }\n-            _ => ()\n-        }\n-    };\n-\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: visit_expr,\n-        .. *visit::default_simple_visitor()\n+            visit::visit_expr(e, cx, vt);\n+        },\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_unused_mut(cx: @mut Context) -> visit::vt<()> {\n-    let check_pat: @fn(@ast::pat) = |p| {\n+fn lint_unused_mut() -> visit::vt<@mut Context> {\n+    fn check_pat(cx: &Context, p: @ast::pat) {\n         let mut used = false;\n         let mut bindings = 0;\n         do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n@@ -866,37 +868,48 @@ fn lint_unused_mut(cx: @mut Context) -> visit::vt<()> {\n             };\n             cx.span_lint(unused_mut, p.span, msg);\n         }\n-    };\n+    }\n \n-    let visit_fn_decl: @fn(&ast::fn_decl) = |fd| {\n+    fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n         for fd.inputs.each |arg| {\n             if arg.is_mutbl {\n-                check_pat(arg.pat);\n+                check_pat(cx, arg.pat);\n             }\n         }\n-    };\n+    }\n \n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_local: |l| {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_local: |l, cx: @mut Context, vt| {\n             if l.node.is_mutbl {\n-                check_pat(l.node.pat);\n+                check_pat(cx, l.node.pat);\n             }\n+            visit::visit_local(l, cx, vt);\n+        },\n+        visit_fn: |a, fd, b, c, d, cx, vt| {\n+            visit_fn_decl(cx, fd);\n+            visit::visit_fn(a, fd, b, c, d, cx, vt);\n+        },\n+        visit_ty_method: |tm, cx, vt| {\n+            visit_fn_decl(cx, &tm.decl);\n+            visit::visit_ty_method(tm, cx, vt);\n         },\n-        visit_fn: |_, fd, _, _, _| visit_fn_decl(fd),\n-        visit_ty_method: |tm| visit_fn_decl(&tm.decl),\n-        visit_struct_method: |sm| visit_fn_decl(&sm.decl),\n-        visit_trait_method: |tm| {\n+        visit_struct_method: |sm, cx, vt| {\n+            visit_fn_decl(cx, &sm.decl);\n+            visit::visit_struct_method(sm, cx, vt);\n+        },\n+        visit_trait_method: |tm, cx, vt| {\n             match *tm {\n-                ast::required(ref tm) => visit_fn_decl(&tm.decl),\n-                ast::provided(m) => visit_fn_decl(&m.decl),\n+                ast::required(ref tm) => visit_fn_decl(cx, &tm.decl),\n+                ast::provided(m) => visit_fn_decl(cx, &m.decl)\n             }\n+            visit::visit_trait_method(tm, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_session(cx: @mut Context) -> visit::vt<()> {\n-    ast_util::id_visitor(|id| {\n+fn lint_session() -> visit::vt<@mut Context> {\n+    ast_util::id_visitor(|id, cx: @mut Context| {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n@@ -908,10 +921,10 @@ fn lint_session(cx: @mut Context) -> visit::vt<()> {\n     })\n }\n \n-fn lint_unnecessary_allocations(cx: @mut Context) -> visit::vt<()> {\n+fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(cx: @mut Context, e: @ast::expr) {\n+    fn check(cx: &Context, e: @ast::expr) {\n         match e.node {\n             ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n             ast::expr_vstore(e2, ast::expr_vstore_box) => {\n@@ -938,19 +951,18 @@ fn lint_unnecessary_allocations(cx: @mut Context) -> visit::vt<()> {\n         }\n     }\n \n-    let visit_expr: @fn(@ast::expr) = |e| {\n-        check(cx, e);\n-    };\n-\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: visit_expr,\n-        .. *visit::default_simple_visitor()\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, cx: @mut Context, vt| {\n+            check(cx, e);\n+            visit::visit_expr(e, cx, vt);\n+        },\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_missing_struct_doc(cx: @mut Context) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_struct_field: |field| {\n+fn lint_missing_struct_doc() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_struct_field: |field, cx: @mut Context, vt| {\n             let relevant = match field.node.kind {\n                 ast::named_field(_, vis) => vis != ast::private,\n                 ast::unnamed_field => false,\n@@ -969,14 +981,16 @@ fn lint_missing_struct_doc(cx: @mut Context) -> visit::vt<()> {\n                                                                   for a field.\");\n                 }\n             }\n+\n+            visit::visit_struct_field(field, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n-fn lint_missing_trait_doc(cx: @mut Context) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_trait_method: |method| {\n+fn lint_missing_trait_doc() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_trait_method: |method, cx: @mut Context, vt| {\n             let mut has_doc = false;\n             let span = match copy *method {\n                 ast::required(m) => {\n@@ -1006,8 +1020,9 @@ fn lint_missing_trait_doc(cx: @mut Context) -> visit::vt<()> {\n                 cx.span_lint(missing_trait_doc, span, \"missing documentation \\\n                                                        for a method.\");\n             }\n+            visit::visit_trait_method(method, cx, vt);\n         },\n-        .. *visit::default_simple_visitor()\n+        .. *visit::default_visitor()\n     })\n }\n \n@@ -1031,39 +1046,33 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n \n     // Register each of the lint passes with the context\n-    cx.add_lint(lint_while_true(cx));\n-    cx.add_lint(lint_path_statement(cx));\n-    cx.add_lint(lint_heap(cx));\n-    cx.add_lint(lint_type_limits(cx));\n-    cx.add_lint(lint_unused_unsafe(cx));\n-    cx.add_lint(lint_unused_mut(cx));\n-    cx.add_lint(lint_session(cx));\n-    cx.add_lint(lint_unnecessary_allocations(cx));\n-    cx.add_lint(lint_missing_struct_doc(cx));\n-    cx.add_lint(lint_missing_trait_doc(cx));\n-\n-    // type inference doesn't like this being declared below, we need to tell it\n-    // what the type of this first function is...\n-    let visit_item:\n-        @fn(@ast::item, @mut Context, visit::vt<@mut Context>) =\n-    |it, cx, vt| {\n-        do cx.with_lint_attrs(it.attrs) {\n-            check_item_ctypes(cx, it);\n-            check_item_non_camel_case_types(cx, it);\n-            check_item_default_methods(cx, it);\n-            check_item_heap(cx, it);\n-\n-            cx.process(Item(it));\n-            visit::visit_item(it, cx, vt);\n-        }\n-    };\n+    cx.add_lint(lint_while_true());\n+    cx.add_lint(lint_path_statement());\n+    cx.add_lint(lint_heap());\n+    cx.add_lint(lint_type_limits());\n+    cx.add_lint(lint_unused_unsafe());\n+    cx.add_lint(lint_unused_mut());\n+    cx.add_lint(lint_session());\n+    cx.add_lint(lint_unnecessary_allocations());\n+    cx.add_lint(lint_missing_struct_doc());\n+    cx.add_lint(lint_missing_trait_doc());\n \n     // Actually perform the lint checks (iterating the ast)\n     do cx.with_lint_attrs(crate.node.attrs) {\n         cx.process(Crate(crate));\n \n         visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n-            visit_item: visit_item,\n+            visit_item: |it, cx: @mut Context, vt| {\n+                do cx.with_lint_attrs(it.attrs) {\n+                    check_item_ctypes(cx, it);\n+                    check_item_non_camel_case_types(cx, it);\n+                    check_item_default_methods(cx, it);\n+                    check_item_heap(cx, it);\n+\n+                    cx.process(Item(it));\n+                    visit::visit_item(it, cx, vt);\n+                }\n+            },\n             visit_fn: |fk, decl, body, span, id, cx, vt| {\n                 match *fk {\n                     visit::fk_method(_, _, m) => {"}, {"sha": "8d5af682d6205e872adaa5c76c8c47308fb4cf2c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6264df5331fef467b8ca8d0800358e1ae94a0dbf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6264df5331fef467b8ca8d0800358e1ae94a0dbf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=6264df5331fef467b8ca8d0800358e1ae94a0dbf", "patch": "@@ -386,103 +386,126 @@ pub impl id_range {\n     }\n }\n \n-pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n-    let visit_generics: @fn(&Generics) = |generics| {\n+pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n+    let visit_generics: @fn(&Generics, T) = |generics, t| {\n         for generics.ty_params.each |p| {\n-            vfn(p.id);\n+            vfn(p.id, t);\n         }\n         for generics.lifetimes.each |p| {\n-            vfn(p.id);\n+            vfn(p.id, t);\n         }\n     };\n-    visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_mod: |_m, _sp, id| vfn(id),\n+    visit::mk_vt(@visit::Visitor {\n+        visit_mod: |m, sp, id, t, vt| {\n+            vfn(id, t);\n+            visit::visit_mod(m, sp, id, t, vt);\n+        },\n \n-        visit_view_item: |vi| {\n+        visit_view_item: |vi, t, vt| {\n             match vi.node {\n-              view_item_extern_mod(_, _, id) => vfn(id),\n+              view_item_extern_mod(_, _, id) => vfn(id, t),\n               view_item_use(ref vps) => {\n                   for vps.each |vp| {\n                       match vp.node {\n-                          view_path_simple(_, _, id) => vfn(id),\n-                          view_path_glob(_, id) => vfn(id),\n+                          view_path_simple(_, _, id) => vfn(id, t),\n+                          view_path_glob(_, id) => vfn(id, t),\n                           view_path_list(_, ref paths, id) => {\n-                              vfn(id);\n+                              vfn(id, t);\n                               for paths.each |p| {\n-                                  vfn(p.node.id);\n+                                  vfn(p.node.id, t);\n                               }\n                           }\n                       }\n                   }\n               }\n             }\n+            visit::visit_view_item(vi, t, vt);\n         },\n \n-        visit_foreign_item: |ni| vfn(ni.id),\n+        visit_foreign_item: |ni, t, vt| {\n+            vfn(ni.id, t);\n+            visit::visit_foreign_item(ni, t, vt);\n+        },\n \n-        visit_item: |i| {\n-            vfn(i.id);\n+        visit_item: |i, t, vt| {\n+            vfn(i.id, t);\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.each |v| { vfn(v.node.id); },\n+                for (*enum_definition).variants.each |v| { vfn(v.node.id, t); },\n               _ => ()\n             }\n+            visit::visit_item(i, t, vt);\n         },\n \n-        visit_local: |l| vfn(l.node.id),\n-        visit_block: |b| vfn(b.node.id),\n-        visit_stmt: |s| vfn(ast_util::stmt_id(s)),\n-        visit_arm: |_| {},\n-        visit_pat: |p| vfn(p.id),\n-        visit_decl: |_| {},\n-\n-        visit_expr: |e| {\n-            vfn(e.callee_id);\n-            vfn(e.id);\n+        visit_local: |l, t, vt| {\n+            vfn(l.node.id, t);\n+            visit::visit_local(l, t, vt);\n+        },\n+        visit_block: |b, t, vt| {\n+            vfn(b.node.id, t);\n+            visit::visit_block(b, t, vt);\n+        },\n+        visit_stmt: |s, t, vt| {\n+            vfn(ast_util::stmt_id(s), t);\n+            visit::visit_stmt(s, t, vt);\n+        },\n+        visit_pat: |p, t, vt| {\n+            vfn(p.id, t);\n+            visit::visit_pat(p, t, vt);\n         },\n \n-        visit_expr_post: |_| {},\n+        visit_expr: |e, t, vt| {\n+            vfn(e.callee_id, t);\n+            vfn(e.id, t);\n+            visit::visit_expr(e, t, vt);\n+        },\n \n-        visit_ty: |t| {\n-            match t.node {\n-              ty_path(_, id) => vfn(id),\n+        visit_ty: |ty, t, vt| {\n+            match ty.node {\n+              ty_path(_, id) => vfn(id, t),\n               _ => { /* fall through */ }\n             }\n+            visit::visit_ty(ty, t, vt);\n         },\n \n-        visit_generics: visit_generics,\n+        visit_generics: |generics, t, vt| {\n+            visit_generics(generics, t);\n+            visit::visit_generics(generics, t, vt);\n+        },\n \n-        visit_fn: |fk, d, _, _, id| {\n-            vfn(id);\n+        visit_fn: |fk, d, a, b, id, t, vt| {\n+            vfn(id, t);\n \n             match *fk {\n                 visit::fk_item_fn(_, generics, _, _) => {\n-                    visit_generics(generics);\n+                    visit_generics(generics, t);\n                 }\n                 visit::fk_method(_, generics, m) => {\n-                    vfn(m.self_id);\n-                    visit_generics(generics);\n+                    vfn(m.self_id, t);\n+                    visit_generics(generics, t);\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n                 }\n             }\n \n             for d.inputs.each |arg| {\n-                vfn(arg.id)\n+                vfn(arg.id, t)\n             }\n+            visit::visit_fn(fk, d, a, b, id, t, vt);\n+        },\n+\n+        visit_struct_field: |f, t, vt| {\n+            vfn(f.node.id, t);\n+            visit::visit_struct_field(f, t, vt);\n         },\n \n-        visit_ty_method: |_| {},\n-        visit_trait_method: |_| {},\n-        visit_struct_def: |_, _, _, _| {},\n-        visit_struct_field: |f| vfn(f.node.id),\n-        visit_struct_method: |_| {}\n+        .. *visit::default_visitor()\n     })\n }\n \n pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n-    item.accept((), id_visitor(vfn));\n+    item.accept((), id_visitor(|id, ()| vfn(id)));\n }\n \n pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {"}]}