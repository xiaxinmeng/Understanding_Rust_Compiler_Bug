{"sha": "1b33f39126c56192e7e35bc943bee9cca6960abd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMzNmMzkxMjZjNTYxOTJlN2UzNWJjOTQzYmVlOWNjYTY5NjBhYmQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-14T12:22:51Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:06:35Z"}, "message": "Handle trait/projection predicates with bound regions correctly", "tree": {"sha": "a9d330c371d7d19c252cdd9bbd3df27799275f2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d330c371d7d19c252cdd9bbd3df27799275f2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b33f39126c56192e7e35bc943bee9cca6960abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b33f39126c56192e7e35bc943bee9cca6960abd", "html_url": "https://github.com/rust-lang/rust/commit/1b33f39126c56192e7e35bc943bee9cca6960abd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b33f39126c56192e7e35bc943bee9cca6960abd/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a33b5915467259b4487adbc451422134003f223", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a33b5915467259b4487adbc451422134003f223", "html_url": "https://github.com/rust-lang/rust/commit/9a33b5915467259b4487adbc451422134003f223"}], "stats": {"total": 202, "additions": 132, "deletions": 70}, "files": [{"sha": "a6f2fe78d28cc4c3eac90d498a3aab7791a4834e", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 131, "deletions": 69, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/1b33f39126c56192e7e35bc943bee9cca6960abd/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b33f39126c56192e7e35bc943bee9cca6960abd/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=1b33f39126c56192e7e35bc943bee9cca6960abd", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n-use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n+use rustc_infer::traits::{PolyTraitObligation, TraitEngine, TraitEngineExt as _};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::{self, Binder, Const, ToPredicate, Ty, TypeFoldable};\n@@ -20,6 +20,7 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::project::PolyProjectionObligation;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n@@ -318,65 +319,50 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         let infcx = self.selcx.infcx();\n \n         match obligation.predicate.kint(infcx.tcx) {\n-            ty::PredicateKint::ForAll(binder) => {\n-                let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n-                ProcessResult::Changed(mk_pending(vec![\n-                    obligation.with(pred.to_predicate(infcx.tcx)),\n-                ]))\n-            }\n-            ty::PredicateKint::Trait(ref data, _) => {\n-                let trait_obligation = obligation.with(Binder::dummy(*data));\n-\n-                if obligation.predicate.is_global() {\n-                    // no type variables present, can use evaluation for better caching.\n-                    // FIXME: consider caching errors too.\n-                    if infcx.predicate_must_hold_considering_regions(&obligation) {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} evaluated to holds\",\n-                            data, obligation.recursion_depth\n-                        );\n-                        return ProcessResult::Changed(vec![]);\n-                    }\n+            ty::PredicateKint::ForAll(binder) => match binder.skip_binder() {\n+                // Evaluation will discard candidates using the leak check.\n+                // This means we need to pass it the bound version of our\n+                // predicate.\n+                rustc_middle::ty::PredicateKint::Trait(trait_ref, _constness) => {\n+                    let trait_obligation = obligation.with(Binder::bind(*trait_ref));\n+\n+                    self.process_trait_obligation(\n+                        obligation,\n+                        trait_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n                 }\n+                rustc_middle::ty::PredicateKint::Projection(projection) => {\n+                    let project_obligation = obligation.with(Binder::bind(*projection));\n \n-                match self.selcx.select(&trait_obligation) {\n-                    Ok(Some(impl_source)) => {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                            data, obligation.recursion_depth\n-                        );\n-                        ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n-                    }\n-                    Ok(None) => {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                            data, obligation.recursion_depth\n-                        );\n-\n-                        // This is a bit subtle: for the most part, the\n-                        // only reason we can fail to make progress on\n-                        // trait selection is because we don't have enough\n-                        // information about the types in the trait.\n-                        pending_obligation.stalled_on =\n-                            trait_ref_infer_vars(self.selcx, data.trait_ref);\n-\n-                        debug!(\n-                            \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                            infcx.resolve_vars_if_possible(obligation),\n-                            pending_obligation.stalled_on\n-                        );\n-\n-                        ProcessResult::Unchanged\n-                    }\n-                    Err(selection_err) => {\n-                        info!(\n-                            \"selecting trait `{:?}` at depth {} yielded Err\",\n-                            data, obligation.recursion_depth\n-                        );\n-\n-                        ProcessResult::Error(CodeSelectionError(selection_err))\n-                    }\n+                    self.process_projection_obligation(\n+                        project_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n                 }\n+                rustc_middle::ty::PredicateKint::RegionOutlives(_)\n+                | rustc_middle::ty::PredicateKint::TypeOutlives(_)\n+                | rustc_middle::ty::PredicateKint::WellFormed(_)\n+                | rustc_middle::ty::PredicateKint::ObjectSafe(_)\n+                | rustc_middle::ty::PredicateKint::ClosureKind(..)\n+                | rustc_middle::ty::PredicateKint::Subtype(_)\n+                | rustc_middle::ty::PredicateKint::ConstEvaluatable(..)\n+                | rustc_middle::ty::PredicateKint::ConstEquate(..)\n+                | rustc_middle::ty::PredicateKint::ForAll(_) => {\n+                    let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n+                    ProcessResult::Changed(mk_pending(vec![\n+                        obligation.with(pred.to_predicate(infcx.tcx)),\n+                    ]))\n+                }\n+            },\n+            ty::PredicateKint::Trait(ref data, _) => {\n+                let trait_obligation = obligation.with(Binder::dummy(*data));\n+\n+                self.process_trait_obligation(\n+                    obligation,\n+                    trait_obligation,\n+                    &mut pending_obligation.stalled_on,\n+                )\n             }\n \n             &ty::PredicateKint::RegionOutlives(data) => {\n@@ -399,17 +385,11 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n             ty::PredicateKint::Projection(ref data) => {\n                 let project_obligation = obligation.with(Binder::dummy(*data));\n-                match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n-                    Ok(None) => {\n-                        pending_obligation.stalled_on = trait_ref_infer_vars(\n-                            self.selcx,\n-                            data.projection_ty.trait_ref(infcx.tcx),\n-                        );\n-                        ProcessResult::Unchanged\n-                    }\n-                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n-                    Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n-                }\n+\n+                self.process_projection_obligation(\n+                    project_obligation,\n+                    &mut pending_obligation.stalled_on,\n+                )\n             }\n \n             &ty::PredicateKint::ObjectSafe(trait_def_id) => {\n@@ -569,14 +549,96 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n+impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n+    fn process_trait_obligation(\n+        &mut self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_obligation: PolyTraitObligation<'tcx>,\n+        stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n+    ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n+        let infcx = self.selcx.infcx();\n+        if obligation.predicate.is_global() {\n+            // no type variables present, can use evaluation for better caching.\n+            // FIXME: consider caching errors too.\n+            if infcx.predicate_must_hold_considering_regions(obligation) {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                    obligation.predicate, obligation.recursion_depth\n+                );\n+                return ProcessResult::Changed(vec![]);\n+            }\n+        }\n+\n+        match self.selcx.select(&trait_obligation) {\n+            Ok(Some(impl_source)) => {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+                ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n+            }\n+            Ok(None) => {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+\n+                // This is a bit subtle: for the most part, the\n+                // only reason we can fail to make progress on\n+                // trait selection is because we don't have enough\n+                // information about the types in the trait.\n+                *stalled_on = trait_ref_infer_vars(\n+                    self.selcx,\n+                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref),\n+                );\n+\n+                debug!(\n+                    \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                    infcx.resolve_vars_if_possible(obligation),\n+                    stalled_on\n+                );\n+\n+                ProcessResult::Unchanged\n+            }\n+            Err(selection_err) => {\n+                info!(\n+                    \"selecting trait `{:?}` at depth {} yielded Err\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+\n+                ProcessResult::Error(CodeSelectionError(selection_err))\n+            }\n+        }\n+    }\n+\n+    fn process_projection_obligation(\n+        &mut self,\n+        project_obligation: PolyProjectionObligation<'tcx>,\n+        stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n+    ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n+        match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n+            Ok(None) => {\n+                *stalled_on = trait_ref_infer_vars(\n+                    self.selcx,\n+                    project_obligation.predicate.to_poly_trait_ref(self.selcx.tcx()),\n+                );\n+                ProcessResult::Unchanged\n+            }\n+            Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+            Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n+        }\n+    }\n+}\n+\n /// Returns the set of inference variables contained in a trait ref.\n fn trait_ref_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n         .resolve_vars_if_possible(&trait_ref)\n+        .skip_binder()\n         .substs\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that"}, {"sha": "b1625536d420204fcb2e3640903ba01b1160a0eb", "filename": "src/test/ui/issues/issue-26217.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b33f39126c56192e7e35bc943bee9cca6960abd/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b33f39126c56192e7e35bc943bee9cca6960abd/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr?ref=1b33f39126c56192e7e35bc943bee9cca6960abd", "patch": "@@ -4,7 +4,7 @@ error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n LL |     foo::<&'a i32>();\n    |     ^^^^^^^^^^^^^^\n    |\n-   = note: type must satisfy the static lifetime\n+   = note: type must outlive any other region\n \n error: aborting due to previous error\n "}]}