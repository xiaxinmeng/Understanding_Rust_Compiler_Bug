{"sha": "2fb33285e6169552e58d10197c11cd2f8702291f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYjMzMjg1ZTYxNjk1NTJlNThkMTAxOTdjMTFjZDJmODcwMjI5MWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T01:36:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:28Z"}, "message": "libextra: Stop using `@mut MemWriter` in the EBML module", "tree": {"sha": "a0aa83d25cda1b73187584732255aebe6f02727a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0aa83d25cda1b73187584732255aebe6f02727a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fb33285e6169552e58d10197c11cd2f8702291f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb33285e6169552e58d10197c11cd2f8702291f", "html_url": "https://github.com/rust-lang/rust/commit/2fb33285e6169552e58d10197c11cd2f8702291f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fb33285e6169552e58d10197c11cd2f8702291f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f5a380a48262e10e2d7c53e679351c5aedbf5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f5a380a48262e10e2d7c53e679351c5aedbf5a", "html_url": "https://github.com/rust-lang/rust/commit/82f5a380a48262e10e2d7c53e679351c5aedbf5a"}], "stats": {"total": 271, "additions": 148, "deletions": 123}, "files": [{"sha": "27d7a1dee99227e48b0e343f5158e8dcf5399948", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=2fb33285e6169552e58d10197c11cd2f8702291f", "patch": "@@ -593,22 +593,13 @@ pub mod writer {\n     use std::io::extensions::u64_to_be_bytes;\n \n     // ebml writing\n-    pub struct Encoder {\n+    pub struct Encoder<'a> {\n         // FIXME(#5665): this should take a trait object\n-        writer: @mut MemWriter,\n+        writer: &'a mut MemWriter,\n         priv size_positions: ~[uint],\n     }\n \n-    impl Clone for Encoder {\n-        fn clone(&self) -> Encoder {\n-            Encoder {\n-                writer: self.writer,\n-                size_positions: self.size_positions.clone(),\n-            }\n-        }\n-    }\n-\n-    fn write_sized_vuint(w: @mut MemWriter, n: uint, size: uint) {\n+    fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -620,15 +611,15 @@ pub mod writer {\n         };\n     }\n \n-    fn write_vuint(w: @mut MemWriter, n: uint) {\n+    fn write_vuint(w: &mut MemWriter, n: uint) {\n         if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n         fail!(\"vint to write too big: {}\", n);\n     }\n \n-    pub fn Encoder(w: @mut MemWriter) -> Encoder {\n+    pub fn Encoder<'a>(w: &'a mut MemWriter) -> Encoder<'a> {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n@@ -637,7 +628,15 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    impl Encoder {\n+    impl<'a> Encoder<'a> {\n+        /// XXX(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n+            Encoder {\n+                writer: cast::transmute_copy(&self.writer),\n+                size_positions: self.size_positions.clone(),\n+            }\n+        }\n+\n         pub fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag {}\", tag_id);\n \n@@ -739,7 +738,7 @@ pub mod writer {\n     // Totally lame approach.\n     static DEBUG: bool = true;\n \n-    impl Encoder {\n+    impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n             assert!(v <= 0xFFFF_FFFF_u);\n@@ -755,17 +754,15 @@ pub mod writer {\n             // try and check failures more quickly.\n             if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n         }\n-    }\n \n-    impl Encoder {\n         pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();\n         }\n     }\n \n-    impl ::serialize::Encoder for Encoder {\n+    impl<'a> ::serialize::Encoder for Encoder<'a> {\n         fn emit_nil(&mut self) {}\n \n         fn emit_uint(&mut self, v: uint) {\n@@ -820,7 +817,7 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self, name: &str, f: |&mut Encoder|) {\n+        fn emit_enum(&mut self, name: &str, f: |&mut Encoder<'a>|) {\n             self._emit_label(name);\n             self.start_tag(EsEnum as uint);\n             f(self);\n@@ -831,98 +828,103 @@ pub mod writer {\n                              _: &str,\n                              v_id: uint,\n                              _: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.start_tag(EsEnumBody as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder|) {\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder<'a>|) {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant(&mut self,\n                                     v_name: &str,\n                                     v_id: uint,\n                                     cnt: uint,\n-                                    f: |&mut Encoder|) {\n+                                    f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n         fn emit_enum_struct_variant_field(&mut self,\n                                           _: &str,\n                                           idx: uint,\n-                                          f: |&mut Encoder|) {\n+                                          f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self, _: &str, _len: uint, f: |&mut Encoder|) {\n+        fn emit_struct(&mut self,\n+                       _: &str,\n+                       _len: uint,\n+                       f: |&mut Encoder<'a>|) {\n             f(self)\n         }\n \n         fn emit_struct_field(&mut self,\n                              name: &str,\n                              _: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self._emit_label(name);\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct(&mut self,\n                              _: &str,\n                              len: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 idx: uint,\n+                                 f: |&mut Encoder<'a>|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self, f: |&mut Encoder|) {\n+        fn emit_option(&mut self, f: |&mut Encoder<'a>|) {\n             self.emit_enum(\"Option\", f);\n         }\n         fn emit_option_none(&mut self) {\n             self.emit_enum_variant(\"None\", 0, 0, |_| ())\n         }\n-        fn emit_option_some(&mut self, f: |&mut Encoder|) {\n+        fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_seq(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsVec as uint);\n             self._emit_tagged_uint(EsVecLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsVecElt as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_map(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMap as uint);\n             self._emit_tagged_uint(EsMapLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMapKey as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMapVal as uint);\n             f(self);\n             self.end_tag();\n@@ -948,9 +950,11 @@ mod tests {\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {:?}\", v);\n-            let wr = @mut MemWriter::new();\n-            let mut ebml_w = writer::Encoder(wr);\n-            v.encode(&mut ebml_w);\n+            let mut wr = MemWriter::new();\n+            {\n+                let mut ebml_w = writer::Encoder(&mut wr);\n+                v.encode(&mut ebml_w);\n+            }\n             let ebml_doc = reader::Doc(*wr.inner_ref());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);"}, {"sha": "214dc41bf2db66353ca2f5c102c05811d7e7e148", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2fb33285e6169552e58d10197c11cd2f8702291f", "patch": "@@ -1293,11 +1293,16 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n fn my_visit_expr(_e:@Expr) { }\n \n-fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n-                 ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n+fn my_visit_item(i: @item,\n+                 items: ast_map::map,\n+                 ebml_w: &mut writer::Encoder,\n+                 ecx_ptr: *int,\n+                 index: @mut ~[entry<i64>]) {\n     match items.get_copy(&i.id) {\n         ast_map::node_item(_, pt) => {\n-            let mut ebml_w = ebml_w.clone();\n+            let mut ebml_w = unsafe {\n+                ebml_w.unsafe_clone()\n+            };\n             // See above\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n@@ -1306,8 +1311,11 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n     }\n }\n \n-fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::Encoder,\n-                         ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n+fn my_visit_foreign_item(ni: @foreign_item,\n+                         items: ast_map::map,\n+                         ebml_w: &mut writer::Encoder,\n+                         ecx_ptr:*int,\n+                         index: @mut ~[entry<i64>]) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n@@ -1316,9 +1324,11 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n                        token::get_ident_interner()),\n                    token::ident_to_str(&ni.ident));\n \n-            let mut ebml_w = ebml_w.clone();\n+            let mut ebml_w = unsafe {\n+                ebml_w.unsafe_clone()\n+            };\n             // See above\n-            let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+            let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_info_for_foreign_item(ecx,\n                                          &mut ebml_w,\n                                          ni,\n@@ -1331,15 +1341,14 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n     }\n }\n \n-struct EncodeVisitor {\n-    ebml_w_for_visit_item: writer::Encoder,\n-    ebml_w_for_visit_foreign_item: writer::Encoder,\n+struct EncodeVisitor<'a,'b> {\n+    ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n     items: ast_map::map,\n     index: @mut ~[entry<i64>],\n }\n \n-impl visit::Visitor<()> for EncodeVisitor {\n+impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n         visit::walk_expr(self, ex, ());\n         my_visit_expr(ex);\n@@ -1348,15 +1357,15 @@ impl visit::Visitor<()> for EncodeVisitor {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n                       self.items,\n-                      &self.ebml_w_for_visit_item,\n+                      self.ebml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni:@foreign_item, _:()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n                               self.items,\n-                              &self.ebml_w_for_visit_foreign_item,\n+                              self.ebml_w_for_visit_item,\n                               self.ecx_ptr,\n                               self.index);\n     }\n@@ -1380,15 +1389,16 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n     let ecx_ptr : *int = unsafe { cast::transmute(ecx) };\n-    let mut visitor = EncodeVisitor {\n-        index: index,\n-        items: items,\n-        ecx_ptr: ecx_ptr,\n-        ebml_w_for_visit_item: (*ebml_w).clone(),\n-        ebml_w_for_visit_foreign_item: (*ebml_w).clone(),\n-    };\n+    {\n+        let mut visitor = EncodeVisitor {\n+            index: index,\n+            items: items,\n+            ecx_ptr: ecx_ptr,\n+            ebml_w_for_visit_item: &mut *ebml_w,\n+        };\n \n-    visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n \n     ebml_w.end_tag();\n     return /*bad*/(*index).clone();\n@@ -1417,7 +1427,7 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: |@mut MemWriter, &T|) {\n+                write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n@@ -1447,7 +1457,7 @@ fn encode_index<T:'static>(\n     ebml_w.end_tag();\n }\n \n-fn write_i64(writer: @mut MemWriter, &n: &i64) {\n+fn write_i64(writer: &mut MemWriter, &n: &i64) {\n     let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n     wr.write_be_u32(n as u32);\n@@ -1623,12 +1633,12 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-struct ImplVisitor<'a> {\n+struct ImplVisitor<'a,'b> {\n     ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut writer::Encoder,\n+    ebml_w: &'a mut writer::Encoder<'b>,\n }\n \n-impl<'a> Visitor<()> for ImplVisitor<'a> {\n+impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n     fn visit_item(&mut self, item: @item, _: ()) {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), _, _) => {\n@@ -1781,51 +1791,51 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n-    let mut i = wr.tell();\n+    let mut i = ebml_w.writer.tell();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = wr.tell() - i;\n+    ecx.stats.attr_bytes = ebml_w.writer.tell() - i;\n \n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = wr.tell() - i;\n+    ecx.stats.dep_bytes = ebml_w.writer.tell() - i;\n \n     // Encode the language items.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = wr.tell() - i;\n+    ecx.stats.lang_item_bytes = ebml_w.writer.tell() - i;\n \n     // Encode the native libraries used\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_native_libraries(&ecx, &mut ebml_w);\n-    ecx.stats.native_lib_bytes = wr.tell() - i;\n+    ecx.stats.native_lib_bytes = ebml_w.writer.tell() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes = wr.tell() - i;\n+    ecx.stats.impl_bytes = ebml_w.writer.tell() - i;\n \n     // Encode miscellaneous info.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes = wr.tell() - i;\n+    ecx.stats.misc_bytes = ebml_w.writer.tell() - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = wr.tell() - i;\n+    ecx.stats.item_bytes = ebml_w.writer.tell() - i;\n \n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes = wr.tell() - i;\n+    ecx.stats.index_bytes = ebml_w.writer.tell() - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = wr.tell();\n+    ecx.stats.total_bytes = ebml_w.writer.tell();\n \n     if (tcx.sess.meta_stats()) {\n-        for e in wr.inner_ref().iter() {\n+        for e in ebml_w.writer.inner_ref().iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n@@ -1847,11 +1857,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-    wr.write(&[0u8, 0u8, 0u8, 0u8]);\n+    ebml_w.writer.write(&[0u8, 0u8, 0u8, 0u8]);\n \n     // This is a horrible thing to do to the outer MemWriter, but thankfully we\n     // don't use it again so... it's ok right?\n-    return util::replace(wr.inner_mut_ref(), ~[]);\n+    return util::replace(ebml_w.writer.inner_mut_ref(), ~[]);\n }\n \n // Get the encoded string for a type"}, {"sha": "8ad9784df1b6b89fdc46580cc26786df72979d1b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2fb33285e6169552e58d10197c11cd2f8702291f", "patch": "@@ -53,11 +53,11 @@ pub enum abbrev_ctxt {\n     ac_use_abbrevs(@mut HashMap<ty::t, ty_abbrev>),\n }\n \n-fn mywrite(w: @mut MemWriter, fmt: &fmt::Arguments) {\n+fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n-pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n           let result_str_opt;\n@@ -70,7 +70,7 @@ pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n           let result_str = match result_str_opt {\n             Some(s) => s,\n             None => {\n-                let wr = @mut MemWriter::new();\n+                let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n                 let s = str::from_utf8(*wr.inner_ref()).to_managed();\n                 let mut short_names_cache = cx.tcx\n@@ -111,37 +111,37 @@ pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n     }\n }\n \n-fn enc_mutability(w: @mut MemWriter, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut MemWriter, mt: ast::Mutability) {\n     match mt {\n         MutImmutable => (),\n         MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: &mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n+fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {\n             mywrite!(w, \"s\");\n-            enc_f(v);\n+            enc_f(w, v);\n         }\n     }\n }\n \n-fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n+fn enc_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n-    enc_opt(w, substs.self_ty, |t| enc_ty(w, cx, t));\n+    enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     match *substs {\n         ty::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -156,7 +156,7 @@ fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     }\n }\n \n-fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n@@ -190,7 +190,7 @@ fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -206,7 +206,7 @@ fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n+pub fn enc_vstore(w: &mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     mywrite!(w, \"/\");\n     match v {\n         ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n@@ -219,12 +219,12 @@ pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-pub fn enc_trait_ref(w: @mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref(w: &mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: &mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n         ty::BoxTraitStore => mywrite!(w, \"@\"),\n@@ -235,7 +235,7 @@ pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n+fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     match *st {\n         ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bot => mywrite!(w, \"z\"),\n@@ -335,23 +335,23 @@ fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_sigil(w: @mut MemWriter, sigil: Sigil) {\n+fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n     match sigil {\n         ManagedSigil => mywrite!(w, \"@\"),\n         OwnedSigil => mywrite!(w, \"~\"),\n         BorrowedSigil => mywrite!(w, \"&\"),\n     }\n }\n \n-fn enc_purity(w: @mut MemWriter, p: purity) {\n+fn enc_purity(w: &mut MemWriter, p: purity) {\n     match p {\n         impure_fn => mywrite!(w, \"i\"),\n         unsafe_fn => mywrite!(w, \"u\"),\n         extern_fn => mywrite!(w, \"c\")\n     }\n }\n \n-fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n+fn enc_abi_set(w: &mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"[\");\n     abis.each(|abi| {\n         mywrite!(w, \"{},\", abi.name());\n@@ -360,20 +360,20 @@ fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: @mut MemWriter, o: Onceness) {\n+fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n     match o {\n         Once => mywrite!(w, \"o\"),\n         Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n@@ -384,7 +384,7 @@ fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig(w: &mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n     mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -398,7 +398,7 @@ fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: &mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -417,7 +417,7 @@ fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: @mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def(w: &mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|\", cx.tcx.sess.str_of(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n }"}, {"sha": "eefd99824e61e5a1a68e089900288227cc9ed7ea", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb33285e6169552e58d10197c11cd2f8702291f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2fb33285e6169552e58d10197c11cd2f8702291f", "patch": "@@ -788,7 +788,7 @@ trait ebml_writer_helpers {\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml_writer_helpers for writer::Encoder {\n+impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         self.emit_opaque(|this| e::write_type(ecx, this, ty))\n     }\n@@ -840,8 +840,10 @@ trait write_tag_and_id {\n     fn id(&mut self, id: ast::NodeId);\n }\n \n-impl write_tag_and_id for writer::Encoder {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut writer::Encoder|) {\n+impl<'a> write_tag_and_id for writer::Encoder<'a> {\n+    fn tag(&mut self,\n+           tag_id: c::astencode_tag,\n+           f: |&mut writer::Encoder<'a>|) {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();\n@@ -852,18 +854,23 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-struct SideTableEncodingIdVisitor {\n+struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n-    new_ebml_w: writer::Encoder,\n+    new_ebml_w: &'a mut writer::Encoder<'b>,\n     maps: Maps,\n }\n \n-impl ast_util::IdVisitingOperation for SideTableEncodingIdVisitor {\n+impl<'a,'b> ast_util::IdVisitingOperation for\n+        SideTableEncodingIdVisitor<'a,'b> {\n     fn visit_id(&self, id: ast::NodeId) {\n         // Note: this will cause a copy of ebml_w, which is bad as\n         // it is mutable. But I believe it's harmless since we generate\n         // balanced EBML.\n-        let mut new_ebml_w = self.new_ebml_w.clone();\n+        //\n+        // XXX(pcwalton): Don't copy this way.\n+        let mut new_ebml_w = unsafe {\n+            self.new_ebml_w.unsafe_clone()\n+        };\n         // See above\n         let ecx: &e::EncodeContext = unsafe {\n             cast::transmute(self.ecx_ptr)\n@@ -877,7 +884,9 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n-    let new_ebml_w = (*ebml_w).clone();\n+    let mut new_ebml_w = unsafe {\n+        ebml_w.unsafe_clone()\n+    };\n \n     // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n     // ecx directly, but /I/ know that it'll be fine since the lifetime is\n@@ -886,7 +895,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n         ecx_ptr: unsafe {\n             cast::transmute(ecx)\n         },\n-        new_ebml_w: new_ebml_w,\n+        new_ebml_w: &mut new_ebml_w,\n         maps: maps,\n     });\n     ebml_w.end_tag();\n@@ -1360,9 +1369,11 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     use std::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n-    let wr = @mut MemWriter::new();\n-    let mut ebml_w = writer::Encoder(wr);\n-    encode_item_ast(&mut ebml_w, in_item);\n+    let mut wr = MemWriter::new();\n+    {\n+        let mut ebml_w = writer::Encoder(&mut wr);\n+        encode_item_ast(&mut ebml_w, in_item);\n+    }\n     let ebml_doc = reader::Doc(wr.inner_ref().as_slice());\n     let out_item = decode_item_ast(ebml_doc);\n "}]}