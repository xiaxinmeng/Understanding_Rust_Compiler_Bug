{"sha": "4450365ec8743fa583758dfa74e3f276b114e7af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTAzNjVlYzg3NDNmYTU4Mzc1OGRmYTc0ZTNmMjc2YjExNGU3YWY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-15T19:28:30Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-15T19:28:30Z"}, "message": "Simplify", "tree": {"sha": "8c824801f7205715252563bf8f3b18426c11b6a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c824801f7205715252563bf8f3b18426c11b6a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4450365ec8743fa583758dfa74e3f276b114e7af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4450365ec8743fa583758dfa74e3f276b114e7af", "html_url": "https://github.com/rust-lang/rust/commit/4450365ec8743fa583758dfa74e3f276b114e7af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4450365ec8743fa583758dfa74e3f276b114e7af/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed734609719b0b18906c500c8ce91fc14a61cb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed734609719b0b18906c500c8ce91fc14a61cb19", "html_url": "https://github.com/rust-lang/rust/commit/ed734609719b0b18906c500c8ce91fc14a61cb19"}], "stats": {"total": 223, "additions": 111, "deletions": 112}, "files": [{"sha": "0fc922125ca932da7fc2b8e86b249a095f3e829a", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=4450365ec8743fa583758dfa74e3f276b114e7af", "patch": "@@ -105,31 +105,24 @@ fn impls_for_trait_item(\n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check(ra_fixture: &str) {\n-        let (analysis, position, annotations) = fixture::annotations(ra_fixture);\n+        let (analysis, position, expected) = fixture::annotations(ra_fixture);\n \n         let navs = analysis.goto_implementation(position).unwrap().unwrap().info;\n \n-        let key = |frange: &FileRange| (frange.file_id, frange.range.start());\n+        let cmp = |frange: &FileRange| (frange.file_id, frange.range.start());\n \n-        let mut expected = annotations\n-            .into_iter()\n-            .map(|(range, data)| {\n-                assert!(data.is_empty());\n-                range\n-            })\n-            .collect::<Vec<_>>();\n-        expected.sort_by_key(key);\n-\n-        let mut actual = navs\n+        let actual = navs\n             .into_iter()\n             .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n+            .sorted_by_key(cmp)\n             .collect::<Vec<_>>();\n-        actual.sort_by_key(key);\n-\n+        let expected =\n+            expected.into_iter().map(|(range, _)| range).sorted_by_key(cmp).collect::<Vec<_>>();\n         assert_eq!(expected, actual);\n     }\n "}, {"sha": "ac23ed8bd2f7843f921329f2442e49a8bcc1b822", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=4450365ec8743fa583758dfa74e3f276b114e7af", "patch": "@@ -1,6 +1,6 @@\n-//! rust-analyzer is lazy and doesn't not compute anything unless asked. This\n+//! rust-analyzer is lazy and doesn't compute anything unless asked. This\n //! sometimes is counter productive when, for example, the first goto definition\n-//! request takes longer to compute. This modules implemented prepopulating of\n+//! request takes longer to compute. This modules implemented prepopulation of\n //! various caches, it's not really advanced at the moment.\n \n use hir::db::DefDatabase;\n@@ -27,7 +27,7 @@ pub(crate) fn prime_caches(db: &RootDatabase, cb: &(dyn Fn(PrimeCachesProgress)\n     let topo = &graph.crates_in_topological_order();\n \n     cb(PrimeCachesProgress::Started);\n-    // Take care to emit the finish signal  even when the computation is canceled.\n+    // Take care to emit the finish signal even when the computation is canceled.\n     let _d = stdx::defer(|| cb(PrimeCachesProgress::Finished));\n \n     // FIXME: This would be easy to parallelize, since it's in the ideal ordering for that."}, {"sha": "305836f79d83223108821b3b00249979c51df6f9", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=4450365ec8743fa583758dfa74e3f276b114e7af", "patch": "@@ -13,7 +13,7 @@ use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::{ReferenceAccess, SearchScope},\n+    search::{ReferenceAccess, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n use rustc_hash::FxHashMap;\n@@ -56,48 +56,20 @@ pub(crate) fn find_all_refs(\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    let (def, is_literal_search) =\n-        if let Some(name) = get_name_of_item_declaration(&syntax, position) {\n-            (\n-                match NameClass::classify(sema, &name)? {\n-                    NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                    NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n-                        Definition::Field(field_ref)\n-                    }\n-                },\n-                true,\n-            )\n-        } else {\n-            (find_def(sema, &syntax, position.offset)?, false)\n-        };\n-\n-    let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n-    if is_literal_search {\n-        // filter for constructor-literals\n-        let refs = usages.references.values_mut();\n-        match def {\n-            Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(enum_))) => {\n-                refs.for_each(|it| {\n-                    it.retain(|reference| {\n-                        reference\n-                            .name\n-                            .as_name_ref()\n-                            .map_or(false, |name_ref| is_enum_lit_name_ref(sema, enum_, name_ref))\n-                    })\n-                });\n-                usages.references.retain(|_, it| !it.is_empty());\n-            }\n-            Definition::ModuleDef(hir::ModuleDef::Adt(_) | hir::ModuleDef::Variant(_)) => {\n-                refs.for_each(|it| {\n-                    it.retain(|reference| {\n-                        reference.name.as_name_ref().map_or(false, is_lit_name_ref)\n-                    })\n-                });\n-                usages.references.retain(|_, it| !it.is_empty());\n+    let mut is_literal_search = false;\n+    let def = if let Some(name) = name_for_constructor_search(&syntax, position) {\n+        is_literal_search = true;\n+        match NameClass::classify(sema, &name)? {\n+            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n+                Definition::Field(field_ref)\n             }\n-            _ => {}\n         }\n-    }\n+    } else {\n+        find_def(sema, &syntax, position.offset)?\n+    };\n+\n+    let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n     let declaration = match def {\n         Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n             Some(NavigationTarget::from_module_to_decl(sema.db, module))\n@@ -108,6 +80,10 @@ pub(crate) fn find_all_refs(\n         let decl_range = nav.focus_or_full_range();\n         Declaration { nav, access: decl_access(&def, &syntax, decl_range) }\n     });\n+    if is_literal_search {\n+        retain_adt_literal_usages(&mut usages, def, sema);\n+    }\n+\n     let references = usages\n         .into_iter()\n         .map(|(file_id, refs)| {\n@@ -174,7 +150,37 @@ pub(crate) fn decl_access(\n     None\n }\n \n-fn get_name_of_item_declaration(syntax: &SyntaxNode, position: FilePosition) -> Option<ast::Name> {\n+/// Filter out all non-literal usages for adt-defs\n+fn retain_adt_literal_usages(\n+    usages: &mut UsageSearchResult,\n+    def: Definition,\n+    sema: &Semantics<RootDatabase>,\n+) {\n+    let refs = usages.references.values_mut();\n+    match def {\n+        Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(enum_))) => {\n+            refs.for_each(|it| {\n+                it.retain(|reference| {\n+                    reference\n+                        .name\n+                        .as_name_ref()\n+                        .map_or(false, |name_ref| is_enum_lit_name_ref(sema, enum_, name_ref))\n+                })\n+            });\n+            usages.references.retain(|_, it| !it.is_empty());\n+        }\n+        Definition::ModuleDef(hir::ModuleDef::Adt(_) | hir::ModuleDef::Variant(_)) => {\n+            refs.for_each(|it| {\n+                it.retain(|reference| reference.name.as_name_ref().map_or(false, is_lit_name_ref))\n+            });\n+            usages.references.retain(|_, it| !it.is_empty());\n+        }\n+        _ => {}\n+    }\n+}\n+\n+/// Returns `Some` if the cursor is at a position for an item to search for all its constructor/literal usages\n+fn name_for_constructor_search(syntax: &SyntaxNode, position: FilePosition) -> Option<ast::Name> {\n     let token = syntax.token_at_offset(position.offset).right_biased()?;\n     let token_parent = token.parent()?;\n     let kind = token.kind();"}, {"sha": "b8e62a1a860dc00f0b23b8b9876d7b4e539efbeb", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4450365ec8743fa583758dfa74e3f276b114e7af/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=4450365ec8743fa583758dfa74e3f276b114e7af", "patch": "@@ -17,7 +17,7 @@ use ide_db::{RootDatabase, SymbolKind};\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, HasFormatSpecifier},\n-    AstNode, AstToken, Direction, NodeOrToken,\n+    match_ast, AstNode, AstToken, Direction, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, TextRange, WalkEvent, T,\n };\n@@ -159,15 +159,16 @@ pub(crate) fn highlight(\n     // Determine the root based on the given range.\n     let (root, range_to_highlight) = {\n         let source_file = sema.parse(file_id);\n+        let source_file = source_file.syntax();\n         match range_to_highlight {\n             Some(range) => {\n-                let node = match source_file.syntax().covering_element(range) {\n+                let node = match source_file.covering_element(range) {\n                     NodeOrToken::Node(it) => it,\n-                    NodeOrToken::Token(it) => it.parent().unwrap(),\n+                    NodeOrToken::Token(it) => it.parent().unwrap_or_else(|| source_file.clone()),\n                 };\n                 (node, range)\n             }\n-            None => (source_file.syntax().clone(), source_file.syntax().text_range()),\n+            None => (source_file.clone(), source_file.text_range()),\n         }\n     };\n \n@@ -211,62 +212,61 @@ fn traverse(\n             continue;\n         }\n \n-        // Track \"inside macro\" state\n-        match event.clone().map(|it| it.into_node().and_then(ast::MacroCall::cast)) {\n-            WalkEvent::Enter(Some(mc)) => {\n-                if let Some(range) = macro_call_range(&mc) {\n-                    hl.add(HlRange {\n-                        range,\n-                        highlight: HlTag::Symbol(SymbolKind::Macro).into(),\n-                        binding_hash: None,\n-                    });\n-                }\n-                current_macro_call = Some(mc.clone());\n-                continue;\n-            }\n-            WalkEvent::Leave(Some(mc)) => {\n-                assert_eq!(current_macro_call, Some(mc));\n-                current_macro_call = None;\n-            }\n-            _ => (),\n-        }\n-        match event.clone().map(|it| it.into_node().and_then(ast::Item::cast)) {\n-            WalkEvent::Enter(Some(item)) => {\n-                if sema.is_attr_macro_call(&item) {\n-                    current_attr_macro_call = Some(item);\n+        match event.clone() {\n+            WalkEvent::Enter(NodeOrToken::Node(node)) => {\n+                match_ast! {\n+                    match node {\n+                        ast::MacroCall(mcall) => {\n+                            if let Some(range) = macro_call_range(&mcall) {\n+                                hl.add(HlRange {\n+                                    range,\n+                                    highlight: HlTag::Symbol(SymbolKind::Macro).into(),\n+                                    binding_hash: None,\n+                                });\n+                            }\n+                            current_macro_call = Some(mcall);\n+                            continue;\n+                        },\n+                        ast::Macro(mac) => {\n+                            macro_highlighter.init();\n+                            current_macro = Some(mac);\n+                            continue;\n+                        },\n+                        ast::Item(item) => {\n+                            if sema.is_attr_macro_call(&item) {\n+                                current_attr_macro_call = Some(item);\n+                            }\n+                        },\n+                        ast::Attr(__) => inside_attribute = true,\n+                        _ => ()\n+                    }\n                 }\n             }\n-            WalkEvent::Leave(Some(item)) => {\n-                if current_attr_macro_call == Some(item) {\n-                    current_attr_macro_call = None;\n+            WalkEvent::Leave(NodeOrToken::Node(node)) => {\n+                match_ast! {\n+                    match node {\n+                        ast::MacroCall(mcall) => {\n+                            assert_eq!(current_macro_call, Some(mcall));\n+                            current_macro_call = None;\n+                        },\n+                        ast::Macro(mac) => {\n+                            assert_eq!(current_macro, Some(mac));\n+                            current_macro = None;\n+                            macro_highlighter = MacroHighlighter::default();\n+                        },\n+                        ast::Item(item) => {\n+                            if current_attr_macro_call == Some(item) {\n+                                current_attr_macro_call = None;\n+                            }\n+                        },\n+                        ast::Attr(__) => inside_attribute = false,\n+                        _ => ()\n+                    }\n                 }\n             }\n             _ => (),\n         }\n \n-        match event.clone().map(|it| it.into_node().and_then(ast::Macro::cast)) {\n-            WalkEvent::Enter(Some(mac)) => {\n-                macro_highlighter.init();\n-                current_macro = Some(mac);\n-                continue;\n-            }\n-            WalkEvent::Leave(Some(mac)) => {\n-                assert_eq!(current_macro, Some(mac));\n-                current_macro = None;\n-                macro_highlighter = MacroHighlighter::default();\n-            }\n-            _ => (),\n-        }\n-        match &event {\n-            WalkEvent::Enter(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n-                inside_attribute = true\n-            }\n-            WalkEvent::Leave(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n-                inside_attribute = false\n-            }\n-            _ => (),\n-        }\n-\n         let element = match event {\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(it) => {"}]}