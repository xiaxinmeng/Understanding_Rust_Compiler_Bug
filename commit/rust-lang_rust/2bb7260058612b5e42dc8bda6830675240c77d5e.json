{"sha": "2bb7260058612b5e42dc8bda6830675240c77d5e", "node_id": "C_kwDOAAsO6NoAKDJiYjcyNjAwNTg2MTJiNWU0MmRjOGJkYTY4MzA2NzUyNDBjNzdkNWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-06T20:16:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-06T20:16:43Z"}, "message": "Rollup merge of #107731 - RalfJung:interpret-discriminant, r=cjgillot\n\ninterpret: move discriminant reading and writing to separate file\n\nThis is quite different from the otherwise fairly general read and write functions in place.rs and operand.rs, and also it's nice to have these two functions close together as they are basically inverses of each other.", "tree": {"sha": "df49a4dffed460432d217f5cf403841192057e4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df49a4dffed460432d217f5cf403841192057e4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bb7260058612b5e42dc8bda6830675240c77d5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj4WArCRBK7hj4Ov3rIwAAnksIADGaUNX4QTDtnLF5my0g/+a0\nBTFT0K3hwXSL2qkmPkdp6RxiS8WgDxEzv7Ll+DFBfqO8jk8vJIyLsykZtgtqpoP8\n4bBfjTSgwsJz4wvqd2Q4/KLjfKrVyA+Kpeb4XAYg0eUUlThj3AJ6uE8Ki00v64Xi\ncnrdKkAVL69Rb4EvnPMjtktAsMCR5ypB7FfwE8GQZK0JMzohQ/9okhYsEga/a2lT\ndUVjftydcqY5h5JxiLbh7wvnNIA3nQ/1YxDD3NHkB+MppNtJKLR6/0n26aFQxzQX\nF6EwgPWdzbsIuS1Ic8t5xg7eVDjHHI7Tlh+Vl5c77yWQY6y5LQDzvCXsgM9MA/c=\n=tJll\n-----END PGP SIGNATURE-----\n", "payload": "tree df49a4dffed460432d217f5cf403841192057e4c\nparent 4e163af1e5c6300ebf04a0e70a44ab0f379898e5\nparent e1926b21102059dbedc67e9906a02049ef8ad839\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675714603 +0100\ncommitter GitHub <noreply@github.com> 1675714603 +0100\n\nRollup merge of #107731 - RalfJung:interpret-discriminant, r=cjgillot\n\ninterpret: move discriminant reading and writing to separate file\n\nThis is quite different from the otherwise fairly general read and write functions in place.rs and operand.rs, and also it's nice to have these two functions close together as they are basically inverses of each other.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb7260058612b5e42dc8bda6830675240c77d5e", "html_url": "https://github.com/rust-lang/rust/commit/2bb7260058612b5e42dc8bda6830675240c77d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bb7260058612b5e42dc8bda6830675240c77d5e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e163af1e5c6300ebf04a0e70a44ab0f379898e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e163af1e5c6300ebf04a0e70a44ab0f379898e5", "html_url": "https://github.com/rust-lang/rust/commit/4e163af1e5c6300ebf04a0e70a44ab0f379898e5"}, {"sha": "e1926b21102059dbedc67e9906a02049ef8ad839", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1926b21102059dbedc67e9906a02049ef8ad839", "html_url": "https://github.com/rust-lang/rust/commit/e1926b21102059dbedc67e9906a02049ef8ad839"}], "stats": {"total": 479, "additions": 245, "deletions": 234}, "files": [{"sha": "557e721249d7f0c653fdabce5aa2fd4e4d6b0580", "filename": "compiler/rustc_const_eval/src/interpret/discriminant.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs?ref=2bb7260058612b5e42dc8bda6830675240c77d5e", "patch": "@@ -0,0 +1,238 @@\n+//! Functions for reading and writing discriminants of multi-variant layouts (enums and generators).\n+\n+use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt};\n+use rustc_middle::{mir, ty};\n+use rustc_target::abi::{self, TagEncoding};\n+use rustc_target::abi::{VariantIdx, Variants};\n+\n+use super::{ImmTy, InterpCx, InterpResult, Machine, OpTy, PlaceTy, Scalar};\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// Writes the discriminant of the given variant.\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn write_discriminant(\n+        &mut self,\n+        variant_index: VariantIdx,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        // Layout computation excludes uninhabited variants from consideration\n+        // therefore there's no way to represent those variants in the given layout.\n+        // Essentially, uninhabited variants do not have a tag that corresponds to their\n+        // discriminant, so we cannot do anything here.\n+        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n+        // dead code, so we cannot ICE here.\n+        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n+            throw_ub!(UninhabitedEnumVariantWritten)\n+        }\n+\n+        match dest.layout.variants {\n+            abi::Variants::Single { index } => {\n+                assert_eq!(index, variant_index);\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding: TagEncoding::Direct,\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                let discr_val =\n+                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n+\n+                // raw discriminants for enums are isize or bigger during\n+                // their computation, but the in-memory tag is the smallest possible\n+                // representation\n+                let size = tag_layout.size(self);\n+                let tag_val = size.truncate(discr_val);\n+\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding:\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                if variant_index != untagged_variant {\n+                    let variants_start = niche_variants.start().as_u32();\n+                    let variant_index_relative = variant_index\n+                        .as_u32()\n+                        .checked_sub(variants_start)\n+                        .expect(\"overflow computing relative variant idx\");\n+                    // We need to use machine arithmetic when taking into account `niche_start`:\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                    let variant_index_relative_val =\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n+                        mir::BinOp::Add,\n+                        &variant_index_relative_val,\n+                        &niche_start_val,\n+                    )?;\n+                    // Write result.\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, &niche_dest)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Read discriminant, return the runtime value as well as the variant index.\n+    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn read_discriminant(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n+\n+        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n+            Variants::Single { index } => {\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        assert_eq!(discr.ty, discr_layout.ty);\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, variant is 0.\n+                        assert_eq!(index.as_u32(), 0);\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n+            }\n+            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n+            }\n+        };\n+\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n+        //   the `Scalar` we return.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n+\n+        // Get layout for tag.\n+        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n+\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        trace!(\"tag value: {}\", tag_val);\n+\n+        // Figure out which discriminant and variant this corresponds to.\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let scalar = tag_val.to_scalar();\n+                // Generate a specific error if `tag_val` is not an integer.\n+                // (`tag_bits` itself is only used for error messages below.)\n+                let tag_bits = scalar\n+                    .try_to_int()\n+                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n+                    .assert_bits(tag_layout.size);\n+                // Cast bits from tag layout to discriminant layout.\n+                // After the checks we did above, this cannot fail, as\n+                // discriminants are int-like.\n+                let discr_val =\n+                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n+                let index = match *op.layout.ty.kind() {\n+                    ty::Adt(adt, _) => {\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    ty::Generator(def_id, substs, _) => {\n+                        let substs = substs.as_generator();\n+                        substs\n+                            .discriminants(def_id, *self.tcx)\n+                            .find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n+                }\n+                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n+                // Return the cast value, and the index.\n+                (discr_val, index.0)\n+            }\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n+                let tag_val = tag_val.to_scalar();\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n+                let variants_start = niche_variants.start().as_u32();\n+                let variants_end = niche_variants.end().as_u32();\n+                let variant = match tag_val.try_to_int() {\n+                    Err(dbg_val) => {\n+                        // So this is a pointer then, and casting to an int failed.\n+                        // Can only happen during CTFE.\n+                        // The niche must be just 0, and the ptr not null, then we know this is\n+                        // okay. Everything else, we conservatively reject.\n+                        let ptr_valid = niche_start == 0\n+                            && variants_start == variants_end\n+                            && !self.scalar_may_be_null(tag_val)?;\n+                        if !ptr_valid {\n+                            throw_ub!(InvalidTag(dbg_val))\n+                        }\n+                        untagged_variant\n+                    }\n+                    Ok(tag_bits) => {\n+                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n+                        // We need to use machine arithmetic to get the relative variant idx:\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                        let variant_index_relative_val =\n+                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n+                        let variant_index_relative =\n+                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n+                        // Check if this is in the range that indicates an actual discriminant.\n+                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n+                            let variant_index_relative = u32::try_from(variant_index_relative)\n+                                .expect(\"we checked that this fits into a u32\");\n+                            // Then computing the absolute variant idx should not overflow any more.\n+                            let variant_index = variants_start\n+                                .checked_add(variant_index_relative)\n+                                .expect(\"overflow computing absolute variant idx\");\n+                            let variants_len = op\n+                                .layout\n+                                .ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants()\n+                                .len();\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n+                            VariantIdx::from_u32(variant_index)\n+                        } else {\n+                            untagged_variant\n+                        }\n+                    }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n+            }\n+        })\n+    }\n+}"}, {"sha": "86de4e4e32c2a5961c1871f420a9c92859ef7d04", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=2bb7260058612b5e42dc8bda6830675240c77d5e", "patch": "@@ -1,6 +1,7 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n+mod discriminant;\n mod eval_context;\n mod intern;\n mod intrinsics;"}, {"sha": "52613d5ca1f9b43c2ed532f398a368da5fabc6ea", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 151, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=2bb7260058612b5e42dc8bda6830675240c77d5e", "patch": "@@ -4,13 +4,12 @@\n use either::{Either, Left, Right};\n \n use rustc_hir::def::Namespace;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n use rustc_middle::ty::{ConstInt, Ty, ValTree};\n use rustc_middle::{mir, ty};\n use rustc_span::Span;\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n-use rustc_target::abi::{VariantIdx, Variants};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size};\n \n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n@@ -657,154 +656,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n-\n-    /// Read discriminant, return the runtime value as well as the variant index.\n-    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n-    pub fn read_discriminant(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", op.layout);\n-        // Get type and layout of the discriminant.\n-        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n-        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n-\n-        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n-        // This is not to be confused with its \"variant index\", which is just determining its position in the\n-        // declared list of variants -- they can differ with explicitly assigned discriminants.\n-        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n-        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n-            Variants::Single { index } => {\n-                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n-                    Some(discr) => {\n-                        // This type actually has discriminants.\n-                        assert_eq!(discr.ty, discr_layout.ty);\n-                        Scalar::from_uint(discr.val, discr_layout.size)\n-                    }\n-                    None => {\n-                        // On a type without actual discriminants, variant is 0.\n-                        assert_eq!(index.as_u32(), 0);\n-                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n-                    }\n-                };\n-                return Ok((discr, index));\n-            }\n-            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n-                (tag, tag_encoding, tag_field)\n-            }\n-        };\n-\n-        // There are *three* layouts that come into play here:\n-        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n-        //   the `Scalar` we return.\n-        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n-        //   and used to interpret the value we read from the tag field.\n-        //   For the return value, a cast to `discr_layout` is performed.\n-        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n-        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n-\n-        // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n-\n-        // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n-        assert_eq!(tag_layout.size, tag_val.layout.size);\n-        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n-        trace!(\"tag value: {}\", tag_val);\n-\n-        // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_encoding {\n-            TagEncoding::Direct => {\n-                let scalar = tag_val.to_scalar();\n-                // Generate a specific error if `tag_val` is not an integer.\n-                // (`tag_bits` itself is only used for error messages below.)\n-                let tag_bits = scalar\n-                    .try_to_int()\n-                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n-                    .assert_bits(tag_layout.size);\n-                // Cast bits from tag layout to discriminant layout.\n-                // After the checks we did above, this cannot fail, as\n-                // discriminants are int-like.\n-                let discr_val =\n-                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n-                let discr_bits = discr_val.assert_bits(discr_layout.size);\n-                // Convert discriminant to variant index, and catch invalid discriminants.\n-                let index = match *op.layout.ty.kind() {\n-                    ty::Adt(adt, _) => {\n-                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    ty::Generator(def_id, substs, _) => {\n-                        let substs = substs.as_generator();\n-                        substs\n-                            .discriminants(def_id, *self.tcx)\n-                            .find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n-                }\n-                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n-                // Return the cast value, and the index.\n-                (discr_val, index.0)\n-            }\n-            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                let tag_val = tag_val.to_scalar();\n-                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n-                // discriminant (encoded in niche/tag) and variant index are the same.\n-                let variants_start = niche_variants.start().as_u32();\n-                let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.try_to_int() {\n-                    Err(dbg_val) => {\n-                        // So this is a pointer then, and casting to an int failed.\n-                        // Can only happen during CTFE.\n-                        // The niche must be just 0, and the ptr not null, then we know this is\n-                        // okay. Everything else, we conservatively reject.\n-                        let ptr_valid = niche_start == 0\n-                            && variants_start == variants_end\n-                            && !self.scalar_may_be_null(tag_val)?;\n-                        if !ptr_valid {\n-                            throw_ub!(InvalidTag(dbg_val))\n-                        }\n-                        untagged_variant\n-                    }\n-                    Ok(tag_bits) => {\n-                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n-                        // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = tag_val - niche_start_val\n-                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                        let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n-                        let variant_index_relative =\n-                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n-                        // Check if this is in the range that indicates an actual discriminant.\n-                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n-                            let variant_index_relative = u32::try_from(variant_index_relative)\n-                                .expect(\"we checked that this fits into a u32\");\n-                            // Then computing the absolute variant idx should not overflow any more.\n-                            let variant_index = variants_start\n-                                .checked_add(variant_index_relative)\n-                                .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = op\n-                                .layout\n-                                .ty\n-                                .ty_adt_def()\n-                                .expect(\"tagged layout for non adt\")\n-                                .variants()\n-                                .len();\n-                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            VariantIdx::from_u32(variant_index)\n-                        } else {\n-                            untagged_variant\n-                        }\n-                    }\n-                };\n-                // Compute the size of the scalar we need to return.\n-                // No need to cast, because the variant index directly serves as discriminant and is\n-                // encoded in the tag.\n-                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n-            }\n-        })\n-    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "f82a41078d153a4485c9585ef1b85257568e3c63", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb7260058612b5e42dc8bda6830675240c77d5e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=2bb7260058612b5e42dc8bda6830675240c77d5e", "patch": "@@ -7,8 +7,8 @@ use either::{Either, Left, Right};\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding, VariantIdx};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, VariantIdx};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n@@ -767,87 +767,8 @@ where\n         MPlaceTy { mplace, layout, align: layout.align.abi }\n     }\n \n-    /// Writes the discriminant of the given variant.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn write_discriminant(\n-        &mut self,\n-        variant_index: VariantIdx,\n-        dest: &PlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx> {\n-        // Layout computation excludes uninhabited variants from consideration\n-        // therefore there's no way to represent those variants in the given layout.\n-        // Essentially, uninhabited variants do not have a tag that corresponds to their\n-        // discriminant, so we cannot do anything here.\n-        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n-        // dead code, so we cannot ICE here.\n-        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n-            throw_ub!(UninhabitedEnumVariantWritten)\n-        }\n-\n-        match dest.layout.variants {\n-            abi::Variants::Single { index } => {\n-                assert_eq!(index, variant_index);\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding: TagEncoding::Direct,\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                let discr_val =\n-                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n-\n-                // raw discriminants for enums are isize or bigger during\n-                // their computation, but the in-memory tag is the smallest possible\n-                // representation\n-                let size = tag_layout.size(self);\n-                let tag_val = size.truncate(discr_val);\n-\n-                let tag_dest = self.place_field(dest, tag_field)?;\n-                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding:\n-                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                if variant_index != untagged_variant {\n-                    let variants_start = niche_variants.start().as_u32();\n-                    let variant_index_relative = variant_index\n-                        .as_u32()\n-                        .checked_sub(variants_start)\n-                        .expect(\"overflow computing relative variant idx\");\n-                    // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // tag_val = variant_index_relative + niche_start_val\n-                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                    let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, tag_layout);\n-                    let tag_val = self.binary_op(\n-                        mir::BinOp::Add,\n-                        &variant_index_relative_val,\n-                        &niche_start_val,\n-                    )?;\n-                    // Write result.\n-                    let niche_dest = self.place_field(dest, tag_field)?;\n-                    self.write_immediate(*tag_val, &niche_dest)?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Writes the discriminant of the given variant.\n-    #[instrument(skip(self), level = \"debug\")]\n+    /// Writes the aggregate to the destination.\n+    #[instrument(skip(self), level = \"trace\")]\n     pub fn write_aggregate(\n         &mut self,\n         kind: &mir::AggregateKind<'tcx>,"}]}