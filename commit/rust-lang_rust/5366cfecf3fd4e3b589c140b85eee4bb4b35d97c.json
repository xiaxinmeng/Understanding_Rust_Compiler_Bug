{"sha": "5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNjZjZmVjZjNmZDRlM2I1ODljMTQwYjg1ZWVlNGJiNGIzNWQ5N2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T14:00:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T14:00:57Z"}, "message": "auto merge of #17438 : alexcrichton/rust/string-stable, r=aturon\n\n# Rationale\r\n\r\nWhen dealing with strings, many functions deal with either a `char` (unicode\r\ncodepoint) or a byte (utf-8 encoding related). There is often an inconsistent\r\nway in which methods are referred to as to whether they contain \"byte\", \"char\",\r\nor nothing in their name.  There are also issues open to rename *all* methods to\r\nreflect that they operate on utf8 encodings or bytes (e.g. utf8_len() or\r\nbyte_len()).\r\n\r\nThe current state of String seems to largely be what is desired, so this PR\r\nproposes the following rationale for methods dealing with bytes or characters:\r\n\r\n> When constructing a string, the input encoding *must* be mentioned (e.g.\r\n> from_utf8). This makes it clear what exactly the input type is expected to be\r\n> in terms of encoding.\r\n>\r\n> When a method operates on anything related to an *index* within the string\r\n> such as length, capacity, position, etc, the method *implicitly* operates on\r\n> bytes. It is an understood fact that String is a utf-8 encoded string, and\r\n> burdening all methods with \"bytes\" would be redundant.\r\n>\r\n> When a method operates on the *contents* of a string, such as push() or pop(),\r\n> then \"char\" is the default type. A String can loosely be thought of as being a\r\n> collection of unicode codepoints, but not all collection-related operations\r\n> make sense because some can be woefully inefficient.\r\n\r\n# Method stabilization\r\n\r\nThe following methods have been marked #[stable]\r\n\r\n* The String type itself\r\n* String::new\r\n* String::with_capacity\r\n* String::from_utf16_lossy\r\n* String::into_bytes\r\n* String::as_bytes\r\n* String::len\r\n* String::clear\r\n* String::as_slice\r\n\r\nThe following methods have been marked #[unstable]\r\n\r\n* String::from_utf8 - The error type in the returned `Result` may change to\r\n                      provide a nicer message when it's `unwrap()`'d\r\n* String::from_utf8_lossy - The returned `MaybeOwned` type still needs\r\n                            stabilization\r\n* String::from_utf16 - The return type may change to become a `Result` which\r\n                       includes more contextual information like where the error\r\n                       occurred.\r\n* String::from_chars - This is equivalent to iter().collect(), but currently not\r\n                       as ergonomic.\r\n* String::from_char - This method is the equivalent of Vec::from_elem, and has\r\n                      been marked #[unstable] becuase it can be seen as a\r\n                      duplicate of iterator-based functionality as well as\r\n                      possibly being renamed.\r\n* String::push_str - This *can* be emulated with .extend(foo.chars()), but is\r\n                     less efficient because of decoding/encoding. Due to the\r\n                     desire to minimize API surface this may be able to be\r\n                     removed in the future for something possibly generic with\r\n                     no loss in performance.\r\n* String::grow - This is a duplicate of iterator-based functionality, which may\r\n                 become more ergonomic in the future.\r\n* String::capacity - This function was just added.\r\n* String::push - This function was just added.\r\n* String::pop - This function was just added.\r\n* String::truncate - The failure conventions around String methods and byte\r\n                     indices isn't totally clear at this time, so the failure\r\n                     semantics and return value of this method are subject to\r\n                     change.\r\n* String::as_mut_vec - the naming of this method may change.\r\n* string::raw::* - these functions are all waiting on [an RFC][2]\r\n\r\n[2]: rust-lang/rfcs#240\r\n\r\nThe following method have been marked #[experimental]\r\n\r\n* String::from_str - This function only exists as it's more efficient than\r\n                     to_string(), but having a less ergonomic function for\r\n                     performance reasons isn't the greatest reason to keep it\r\n                     around. Like Vec::push_all, this has been marked\r\n                     experimental for now.\r\n\r\nThe following methods have been #[deprecated]\r\n\r\n* String::append - This method has been deprecated to remain consistent with the\r\n                   deprecation of Vec::append. While convenient, it is one of\r\n                   the only functional-style apis on String, and requires more\r\n                   though as to whether it belongs as a first-class method or\r\n                   now (and how it relates to other collections).\r\n* String::from_byte - This is fairly rare functionality and can be emulated with\r\n                      str::from_utf8 plus an assert plus a call to to_string().\r\n                      Additionally, String::from_char could possibly be used.\r\n* String::byte_capacity - Renamed to String::capacity due to the rationale\r\n                          above.\r\n* String::push_char - Renamed to String::push due to the rationale above.\r\n* String::pop_char - Renamed to String::pop due to the rationale above.\r\n* String::push_bytes - There are a number of `unsafe` functions on the `String`\r\n                       type which allow bypassing utf-8 checks. These have all\r\n                       been deprecated in favor of calling `.as_mut_vec()` and\r\n                       then operating directly on the vector returned. These\r\n                       methods were deprecated because naming them with relation\r\n                       to other methods was difficult to rationalize and it's\r\n                       arguably more composable to call .as_mut_vec().\r\n* String::as_mut_bytes - See push_bytes\r\n* String::push_byte - See push_bytes\r\n* String::pop_byte - See push_bytes\r\n* String::shift_byte - See push_bytes\r\n\r\n# Reservation methods\r\n\r\nThis commit does not yet touch the methods for reserving bytes. The methods on\r\nVec have also not yet been modified. These methods are discussed in the upcoming\r\n[Collections reform RFC][1]\r\n\r\n[1]: https://github.com/aturon/rfcs/blob/collections-conventions/active/0000-collections-conventions.md#implicit-growth", "tree": {"sha": "405879681639d626a980cbb3cb0b09a60d357722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/405879681639d626a980cbb3cb0b09a60d357722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "html_url": "https://github.com/rust-lang/rust/commit/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cad720879a09ec996cf688caaeba8f0b5aad2ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cad720879a09ec996cf688caaeba8f0b5aad2ff", "html_url": "https://github.com/rust-lang/rust/commit/8cad720879a09ec996cf688caaeba8f0b5aad2ff"}, {"sha": "50375139e2bc69920786411f7b1e05866898ed7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/50375139e2bc69920786411f7b1e05866898ed7a", "html_url": "https://github.com/rust-lang/rust/commit/50375139e2bc69920786411f7b1e05866898ed7a"}], "stats": {"total": 342, "additions": 248, "deletions": 94}, "files": [{"sha": "268a6020a10a5f9cdc56911a20e1d3ee3e14b2d6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -444,7 +444,8 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                      \"-nx\".to_string(),\n                      format!(\"-command={}\", debugger_script.as_str().unwrap()));\n \n-            let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n+            let mut gdb_path = tool_path;\n+            gdb_path.push_str(\"/bin/arm-linux-androideabi-gdb\");\n             let procsrv::Result {\n                 out,\n                 err,"}, {"sha": "d198e948ac83845837f2f04450714c371397f092", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -698,7 +698,7 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_default(|c| out.push_char(c));\n+            c.escape_default(|c| out.push(c));\n         }\n         out\n     }\n@@ -708,7 +708,7 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_unicode(|c| out.push_char(c));\n+            c.escape_unicode(|c| out.push(c));\n         }\n         out\n     }"}, {"sha": "6843996a9e1454a746a3fc44b0a54d4e3e5d0baa", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 194, "deletions": 45, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -31,6 +31,7 @@ use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[stable]\n pub struct String {\n     vec: Vec<u8>,\n }\n@@ -44,6 +45,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -60,6 +62,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -75,6 +78,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[experimental = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n         String { vec: string.as_bytes().to_vec() }\n     }\n@@ -111,6 +115,7 @@ impl String {\n     /// assert_eq!(s, Err(vec![240, 144, 128]));\n     /// ```\n     #[inline]\n+    #[unstable = \"error type may change\"]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n         if str::is_utf8(vec.as_slice()) {\n             Ok(String { vec: vec })\n@@ -129,6 +134,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n     /// ```\n+    #[unstable = \"return type may change\"]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         if str::is_utf8(v) {\n             return MaybeOwnedSlice(unsafe { mem::transmute(v) })\n@@ -153,7 +159,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.push_bytes(v.slice_to(i))\n+                res.as_mut_vec().push_all(v.slice_to(i))\n             };\n         }\n \n@@ -170,10 +176,10 @@ impl String {\n             macro_rules! error(() => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.push_bytes(v.slice(subseqidx, i_));\n+                        res.as_mut_vec().push_all(v.slice(subseqidx, i_));\n                     }\n                     subseqidx = i;\n-                    res.push_bytes(REPLACEMENT);\n+                    res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n             }))\n \n@@ -239,7 +245,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.push_bytes(v.slice(subseqidx, total))\n+                res.as_mut_vec().push_all(v.slice(subseqidx, total))\n             };\n         }\n         Owned(res.into_string())\n@@ -260,11 +266,12 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert_eq!(String::from_utf16(v), None);\n     /// ```\n+    #[unstable = \"error value in return may change\"]\n     pub fn from_utf16(v: &[u16]) -> Option<String> {\n         let mut s = String::with_capacity(v.len() / 2);\n         for c in str::utf16_items(v) {\n             match c {\n-                str::ScalarValue(c) => s.push_char(c),\n+                str::ScalarValue(c) => s.push(c),\n                 str::LoneSurrogate(_) => return None\n             }\n         }\n@@ -284,6 +291,7 @@ impl String {\n     /// assert_eq!(String::from_utf16_lossy(v),\n     ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n     /// ```\n+    #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -298,6 +306,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[unstable = \"may be removed in favor of .collect()\"]\n     pub fn from_chars(chs: &[char]) -> String {\n         chs.iter().map(|c| *c).collect()\n     }\n@@ -312,6 +321,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -322,13 +332,15 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let s = String::from_str(\"hello\");\n     /// let big = s.append(\" \").append(\"world\").append(\"!\");\n     /// // s has now been moved and cannot be used\n     ///\n     /// assert_eq!(big.as_slice(), \"hello world!\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"use .push_str() instead\"]\n     pub fn append(mut self, second: &str) -> String {\n         self.push_str(second);\n         self\n@@ -343,17 +355,19 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"aaaaa\");\n     /// ```\n     #[inline]\n+    #[unstable = \"may be replaced with iterators, questionable usability, and \\\n+                  the name may change\"]\n     pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n             return String::new()\n         }\n \n         let mut buf = String::new();\n-        buf.push_char(ch);\n+        buf.push(ch);\n         let size = buf.len() * length;\n         buf.reserve(size);\n         for _ in range(1, length) {\n-            buf.push_char(ch)\n+            buf.push(ch)\n         }\n         buf\n     }\n@@ -367,9 +381,11 @@ impl String {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// let s = String::from_byte(104);\n     /// assert_eq!(s.as_slice(), \"h\");\n     /// ```\n+    #[deprecated = \"use str::from_utf8 with a slice of one byte instead\"]\n     pub fn from_byte(b: u8) -> String {\n         assert!(b < 128u8);\n         String::from_char(1, b as char)\n@@ -385,6 +401,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n+    #[unstable = \"extra variants of `push`, could possibly be based on iterators\"]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -399,9 +416,10 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n     /// ```\n     #[inline]\n+    #[unstable = \"duplicate of iterator-based functionality\"]\n     pub fn grow(&mut self, count: uint, ch: char) {\n         for _ in range(0, count) {\n-            self.push_char(ch)\n+            self.push(ch)\n         }\n     }\n \n@@ -410,23 +428,39 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let s = String::with_capacity(10);\n     /// assert!(s.byte_capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[deprecated = \"renamed to .capacity()\"]\n     pub fn byte_capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n \n+    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::with_capacity(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"just implemented, needs to prove itself\"]\n+    pub fn capacity(&self) -> uint {\n+        self.vec.capacity()\n+    }\n+\n     /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::with_capacity(10);\n-    /// let before = s.byte_capacity();\n+    /// let before = s.capacity();\n     /// s.reserve_additional(100);\n-    /// assert!(s.byte_capacity() - before >= 100);\n+    /// assert!(s.capacity() - before >= 100);\n     /// ```\n     #[inline]\n     pub fn reserve_additional(&mut self, extra: uint) {\n@@ -440,7 +474,7 @@ impl String {\n     /// ```\n     /// let mut s = String::new();\n     /// s.reserve(10);\n-    /// assert!(s.byte_capacity() >= 10);\n+    /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n     pub fn reserve(&mut self, capacity: uint) {\n@@ -454,7 +488,7 @@ impl String {\n     /// ```\n     /// let mut s = String::new();\n     /// s.reserve_exact(10);\n-    /// assert_eq!(s.byte_capacity(), 10);\n+    /// assert_eq!(s.capacity(), 10);\n     /// ```\n     #[inline]\n     pub fn reserve_exact(&mut self, capacity: uint) {\n@@ -468,28 +502,36 @@ impl String {\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n     /// s.reserve(100);\n-    /// assert!(s.byte_capacity() >= 100);\n+    /// assert!(s.capacity() >= 100);\n     /// s.shrink_to_fit();\n-    /// assert_eq!(s.byte_capacity(), 3);\n+    /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n \n+    /// Deprecated, use .push() instead.\n+    #[inline]\n+    #[deprecated = \"renamed to .push()\"]\n+    pub fn push_char(&mut self, ch: char) {\n+        self.push(ch)\n+    }\n+\n     /// Adds the given character to the end of the string.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"abc\");\n-    /// s.push_char('1');\n-    /// s.push_char('2');\n-    /// s.push_char('3');\n+    /// s.push('1');\n+    /// s.push('2');\n+    /// s.push('3');\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    pub fn push_char(&mut self, ch: char) {\n+    #[stable = \"function just renamed from push\"]\n+    pub fn push(&mut self, ch: char) {\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n         self.vec.reserve_additional(4);\n@@ -513,13 +555,15 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::new();\n     /// unsafe {\n     ///     s.push_bytes([104, 101, 108, 108, 111]);\n     /// }\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec() and push onto that\"]\n     pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n         self.vec.push_all(bytes)\n     }\n@@ -534,6 +578,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -546,6 +591,7 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"hello\");\n     /// unsafe {\n     ///     let bytes = s.as_mut_bytes();\n@@ -557,6 +603,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"h3ll0\")\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().as_mut_slice() instead\"]\n     pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n         self.vec.as_mut_slice()\n     }\n@@ -575,6 +622,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n+    #[unstable = \"the failure conventions for strings are under development\"]\n     pub fn truncate(&mut self, len: uint) {\n         assert!(self.as_slice().is_char_boundary(len));\n         self.vec.truncate(len)\n@@ -588,13 +636,15 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"hell\");\n     /// unsafe {\n     ///     s.push_byte(111);\n     /// }\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().push() instead\"]\n     pub unsafe fn push_byte(&mut self, byte: u8) {\n         self.vec.push(byte)\n     }\n@@ -608,6 +658,7 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"foo\");\n     /// unsafe {\n     ///     assert_eq!(s.pop_byte(), Some(111));\n@@ -617,6 +668,7 @@ impl String {\n     /// }\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().pop() instead\"]\n     pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n         let len = self.len();\n         if len == 0 {\n@@ -628,20 +680,26 @@ impl String {\n         Some(byte)\n     }\n \n+    /// Deprecated. Renamed to `pop`.\n+    #[inline]\n+    #[deprecated = \"renamed to .pop()\"]\n+    pub fn pop_char(&mut self) -> Option<char> { self.pop() }\n+\n     /// Removes the last character from the string buffer and returns it.\n     /// Returns `None` if this string buffer is empty.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.pop_char(), Some('o'));\n-    /// assert_eq!(s.pop_char(), Some('o'));\n-    /// assert_eq!(s.pop_char(), Some('f'));\n-    /// assert_eq!(s.pop_char(), None);\n+    /// assert_eq!(s.pop(), Some('o'));\n+    /// assert_eq!(s.pop(), Some('o'));\n+    /// assert_eq!(s.pop(), Some('f'));\n+    /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    pub fn pop_char(&mut self) -> Option<char> {\n+    #[unstable = \"this function was just renamed from pop_char\"]\n+    pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n             return None\n@@ -663,6 +721,7 @@ impl String {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"foo\");\n     /// unsafe {\n     ///     assert_eq!(s.shift_byte(), Some(102));\n@@ -671,41 +730,86 @@ impl String {\n     ///     assert_eq!(s.shift_byte(), None);\n     /// }\n     /// ```\n+    #[deprecated = \"call .as_mut_vec().remove(0)\"]\n     pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n         self.vec.remove(0)\n     }\n \n-    /// Removes the first character from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n+    /// Deprecated, call `remove(0)` instead\n+    #[deprecated = \"call .remove(0) instead\"]\n+    pub fn shift_char(&mut self) -> Option<char> {\n+        self.remove(0)\n+    }\n+\n+    /// Removes the character from the string buffer at byte position `idx` and\n+    /// returns it. Returns `None` if `idx` is out of bounds.\n     ///\n     /// # Warning\n     ///\n-    /// This is a O(n) operation as it requires copying every element in the buffer.\n+    /// This is a O(n) operation as it requires copying every element in the\n+    /// buffer.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `idx` does not lie on a character boundary, then this function will\n+    /// fail.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.shift_char(), Some('f'));\n-    /// assert_eq!(s.shift_char(), Some('o'));\n-    /// assert_eq!(s.shift_char(), Some('o'));\n-    /// assert_eq!(s.shift_char(), None);\n+    /// assert_eq!(s.remove(0), Some('f'));\n+    /// assert_eq!(s.remove(1), Some('o'));\n+    /// assert_eq!(s.remove(0), Some('o'));\n+    /// assert_eq!(s.remove(0), None);\n     /// ```\n-    pub fn shift_char(&mut self) -> Option<char> {\n+    #[unstable = \"the failure semantics of this function and return type \\\n+                  may change\"]\n+    pub fn remove(&mut self, idx: uint) -> Option<char> {\n         let len = self.len();\n-        if len == 0 {\n-            return None\n-        }\n+        if idx >= len { return None }\n \n-        let CharRange {ch, next} = self.as_slice().char_range_at(0);\n-        let new_len = len - next;\n+        let CharRange { ch, next } = self.as_slice().char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr(), self.vec.as_ptr().offset(next as int), new_len);\n-            self.vec.set_len(new_len);\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+                             self.vec.as_ptr().offset(next as int),\n+                             len - next);\n+            self.vec.set_len(len - (next - idx));\n         }\n         Some(ch)\n     }\n \n+    /// Insert a character into the string buffer at byte position `idx`.\n+    ///\n+    /// # Warning\n+    ///\n+    /// This is a O(n) operation as it requires copying every element in the\n+    /// buffer.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `idx` does not lie on a character boundary or is out of bounds, then\n+    /// this function will fail.\n+    #[unstable = \"the failure semantics of this function are uncertain\"]\n+    pub fn insert(&mut self, idx: uint, ch: char) {\n+        let len = self.len();\n+        assert!(idx <= len);\n+        assert!(self.as_slice().is_char_boundary(idx));\n+        self.vec.reserve_additional(4);\n+        let mut bits = [0, ..4];\n+        let amt = ch.encode_utf8(bits).unwrap();\n+\n+        unsafe {\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as int),\n+                             self.vec.as_ptr().offset(idx as int),\n+                             len - idx);\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+                             bits.as_ptr(),\n+                             amt);\n+            self.vec.set_len(len + amt);\n+        }\n+    }\n+\n     /// Views the string buffer as a mutable sequence of bytes.\n     ///\n     /// This is unsafe because it does not check\n@@ -722,25 +826,31 @@ impl String {\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n+    #[unstable = \"the name of this method may be changed\"]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n }\n \n+#[experimental = \"collection traits will probably be removed\"]\n impl Collection for String {\n     #[inline]\n+    #[stable]\n     fn len(&self) -> uint {\n         self.vec.len()\n     }\n }\n \n+#[experimental = \"collection traits will probably be removed\"]\n impl Mutable for String {\n     #[inline]\n+    #[stable]\n     fn clear(&mut self) {\n         self.vec.clear()\n     }\n }\n \n+#[experimental = \"waiting on FromIterator stabilization\"]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -749,56 +859,65 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[experimental = \"waiting on Extendable stabilization\"]\n impl Extendable<char> for String {\n     fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n         for ch in iterator {\n-            self.push_char(ch)\n+            self.push(ch)\n         }\n     }\n }\n \n+#[experimental = \"waiting on Str stabilization\"]\n impl Str for String {\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe {\n             mem::transmute(self.vec.as_slice())\n         }\n     }\n }\n \n+#[experimental = \"waiting on StrAllocating stabilization\"]\n impl StrAllocating for String {\n     #[inline]\n     fn into_string(self) -> String {\n         self\n     }\n }\n \n+#[stable]\n impl Default for String {\n     fn default() -> String {\n         String::new()\n     }\n }\n \n+#[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }\n }\n \n+#[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n+#[experimental = \"waiting on Equiv stabilization\"]\n impl<'a, S: Str> Equiv<S> for String {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[experimental = \"waiting on Add stabilization\"]\n impl<S: Str> Add<S, String> for String {\n     fn add(&self, other: &S) -> String {\n         let mut s = String::from_str(self.as_slice());\n@@ -808,6 +927,7 @@ impl<S: Str> Add<S, String> for String {\n }\n \n /// Unsafe operations\n+#[unstable = \"waiting on raw module conventions\"]\n pub mod raw {\n     use core::mem;\n     use core::ptr::RawPtr;\n@@ -1060,13 +1180,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_push_char() {\n+    fn test_push() {\n         let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        data.push_char('\u534e');\n-        data.push_char('b'); // 1 byte\n-        data.push_char('\u00a2'); // 2 byte\n-        data.push_char('\u20ac'); // 3 byte\n-        data.push_char('\ud852\udf62'); // 4 byte\n+        data.push('\u534e');\n+        data.push('b'); // 1 byte\n+        data.push('\u00a2'); // 2 byte\n+        data.push('\u20ac'); // 3 byte\n+        data.push('\ud852\udf62'); // 4 byte\n         assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n     }\n \n@@ -1141,6 +1261,35 @@ mod tests {\n         assert_eq!(b.as_slice(), \"1234522\");\n     }\n \n+    #[test]\n+    fn remove() {\n+        let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n+        assert_eq!(s.remove(0), Some('\u0e28'));\n+        assert_eq!(s.len(), 33);\n+        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+        assert_eq!(s.remove(33), None);\n+        assert_eq!(s.remove(300), None);\n+        assert_eq!(s.remove(17), Some('\u1ec7'));\n+        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+    }\n+\n+    #[test] #[should_fail]\n+    fn remove_bad() {\n+        \"\u0e28\".to_string().remove(1);\n+    }\n+\n+    #[test]\n+    fn insert() {\n+        let mut s = \"foobar\".to_string();\n+        s.insert(0, '\u1ec7');\n+        assert_eq!(s.as_slice(), \"\u1ec7foobar\");\n+        s.insert(6, '\u0e22');\n+        assert_eq!(s.as_slice(), \"\u1ec7foo\u0e22bar\");\n+    }\n+\n+    #[test] #[should_fail] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n+    #[test] #[should_fail] fn insert_bad2() { \"\u1ec7\".to_string().insert(1, 't'); }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "80eb152c09104bf6bc991fad4adc314609539f82", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -685,9 +685,9 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         match short_name.len() {\n             0 => {}\n             1 => {\n-                row.push_char('-');\n+                row.push('-');\n                 row.push_str(short_name.as_slice());\n-                row.push_char(' ');\n+                row.push(' ');\n             }\n             _ => fail!(\"the short name should only be 1 ascii char long\"),\n         }\n@@ -698,7 +698,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             _ => {\n                 row.push_str(\"--\");\n                 row.push_str(long_name.as_slice());\n-                row.push_char(' ');\n+                row.push(' ');\n             }\n         }\n \n@@ -707,9 +707,9 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             No => {}\n             Yes => row.push_str(hint.as_slice()),\n             Maybe => {\n-                row.push_char('[');\n+                row.push('[');\n                 row.push_str(hint.as_slice());\n-                row.push_char(']');\n+                row.push(']');\n             }\n         }\n \n@@ -718,7 +718,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         let rowlen = row.as_slice().char_len();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n-                row.push_char(' ');\n+                row.push(' ');\n             }\n         } else {\n             row.push_str(desc_sep.as_slice())\n@@ -728,7 +728,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         let mut desc_normalized_whitespace = String::new();\n         for word in desc.as_slice().words() {\n             desc_normalized_whitespace.push_str(word);\n-            desc_normalized_whitespace.push_char(' ');\n+            desc_normalized_whitespace.push(' ');\n         }\n \n         // FIXME: #5516 should be graphemes not codepoints\n@@ -755,31 +755,31 @@ fn format_option(opt: &OptGroup) -> String {\n     let mut line = String::new();\n \n     if opt.occur != Req {\n-        line.push_char('[');\n+        line.push('[');\n     }\n \n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n-        line.push_char('-');\n+        line.push('-');\n         line.push_str(opt.short_name.as_slice());\n     } else {\n         line.push_str(\"--\");\n         line.push_str(opt.long_name.as_slice());\n     }\n \n     if opt.hasarg != No {\n-        line.push_char(' ');\n+        line.push(' ');\n         if opt.hasarg == Maybe {\n-            line.push_char('[');\n+            line.push('[');\n         }\n         line.push_str(opt.hint.as_slice());\n         if opt.hasarg == Maybe {\n-            line.push_char(']');\n+            line.push(']');\n         }\n     }\n \n     if opt.occur != Req {\n-        line.push_char(']');\n+        line.push(']');\n     }\n     if opt.occur == Multi {\n         line.push_str(\"..\");"}, {"sha": "4ae7f882212f012a1e3ad42d463ce3b40b9bf255", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -426,7 +426,7 @@ impl<'a> LabelText<'a> {\n     fn escape_str(s: &str) -> String {\n         let mut out = String::with_capacity(s.len());\n         for c in s.chars() {\n-            LabelText::escape_char(c, |c| out.push_char(c));\n+            LabelText::escape_char(c, |c| out.push(c));\n         }\n         out\n     }\n@@ -461,9 +461,11 @@ impl<'a> LabelText<'a> {\n \n     /// Puts `suffix` on a line below this label, with a blank line separator.\n     pub fn suffix_line(self, suffix: LabelText) -> LabelText<'static> {\n-        let prefix = self.pre_escaped_content().into_string();\n+        let mut prefix = self.pre_escaped_content().into_string();\n         let suffix = suffix.pre_escaped_content();\n-        EscStr(str::Owned(prefix.append(r\"\\n\\n\").append(suffix.as_slice())))\n+        prefix.push_str(r\"\\n\\n\");\n+        prefix.push_str(suffix.as_slice());\n+        EscStr(str::Owned(prefix))\n     }\n }\n "}, {"sha": "c3e195af6f90ff896db5997271f90e1f6171fbca", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -104,7 +104,7 @@ impl Program {\n         let mut pre = String::with_capacity(5);\n         for inst in c.insts.slice_from(1).iter() {\n             match *inst {\n-                OneChar(c, FLAG_EMPTY) => pre.push_char(c),\n+                OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break\n             }\n         }"}, {"sha": "0b5aeb215e66c390be753b89c1cd3dde603e520e", "filename": "src/libregex/re.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -26,9 +26,9 @@ pub fn quote(text: &str) -> String {\n     let mut quoted = String::with_capacity(text.len());\n     for c in text.chars() {\n         if parse::is_punct(c) {\n-            quoted.push_char('\\\\')\n+            quoted.push('\\\\')\n         }\n-        quoted.push_char(c);\n+        quoted.push(c);\n     }\n     quoted\n }\n@@ -503,7 +503,8 @@ impl Regex {\n             new.push_str(rep.reg_replace(&cap).as_slice());\n             last_match = e;\n         }\n-        new.append(text.slice(last_match, text.len()))\n+        new.push_str(text.slice(last_match, text.len()));\n+        return new;\n     }\n \n     /// Returns the original string of this regex."}, {"sha": "5ac7baaa6d10a266f6230089e6ced9766a9ae2c4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -1961,9 +1961,9 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n             (b as char).escape_default(|c| {\n-                res.push_char(c);\n+                res.push(c);\n             });\n-            res.push_char('\\'');\n+            res.push('\\'');\n             res\n         },\n         ast::LitChar(c) => format!(\"'{}'\", c),"}, {"sha": "08fb94a801c3e2e38ee2f96d27a4ed6f2add2b46", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -64,7 +64,7 @@ pub fn load_external_files(names: &[String]) -> Option<String> {\n     let mut out = String::new();\n     for name in names.iter() {\n         out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n-        out.push_char('\\n');\n+        out.push('\\n');\n     }\n     Some(out)\n }"}, {"sha": "fe7b1be3eca6837f08bf7aa3dcb40a08a3315cdb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -1080,7 +1080,8 @@ impl Context {\n             let mut json_out = BufferedWriter::new(try!(File::create(json_dst)));\n             try!(stability.encode(&mut json::Encoder::new(&mut json_out)));\n \n-            let title = stability.name.clone().append(\" - Stability dashboard\");\n+            let mut title = stability.name.clone();\n+            title.push_str(\" - Stability dashboard\");\n             let desc = format!(\"API stability overview for the Rust `{}` crate.\",\n                                this.layout.krate);\n             let page = layout::Page {"}, {"sha": "3c66a7c785094ff35440126918ef46f3079c3fea", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -276,7 +276,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                     clean::NameValue(ref x, ref s)\n                             if \"doc\" == x.as_slice() => {\n                         docstr.push_str(s.as_slice());\n-                        docstr.push_char('\\n');\n+                        docstr.push('\\n');\n                     },\n                     _ => ()\n                 }"}, {"sha": "4d9bb87d133a445a37324c6b8404de227adfbdd4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -1514,14 +1514,14 @@ impl<T: Iterator<char>> Parser<T> {\n \n             if escape {\n                 match self.ch_or_null() {\n-                    '\"' => res.push_char('\"'),\n-                    '\\\\' => res.push_char('\\\\'),\n-                    '/' => res.push_char('/'),\n-                    'b' => res.push_char('\\x08'),\n-                    'f' => res.push_char('\\x0c'),\n-                    'n' => res.push_char('\\n'),\n-                    'r' => res.push_char('\\r'),\n-                    't' => res.push_char('\\t'),\n+                    '\"' => res.push('\"'),\n+                    '\\\\' => res.push('\\\\'),\n+                    '/' => res.push('/'),\n+                    'b' => res.push('\\x08'),\n+                    'f' => res.push('\\x0c'),\n+                    'n' => res.push('\\n'),\n+                    'r' => res.push('\\r'),\n+                    't' => res.push('\\t'),\n                     'u' => match try!(self.decode_hex_escape()) {\n                         0xDC00 .. 0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n \n@@ -1535,13 +1535,13 @@ impl<T: Iterator<char>> Parser<T> {\n \n                             let buf = [n1, try!(self.decode_hex_escape())];\n                             match str::utf16_items(buf.as_slice()).next() {\n-                                Some(ScalarValue(c)) => res.push_char(c),\n+                                Some(ScalarValue(c)) => res.push(c),\n                                 _ => return self.error(LoneLeadingSurrogateInHexEscape),\n                             }\n                         }\n \n                         n => match char::from_u32(n as u32) {\n-                            Some(c) => res.push_char(c),\n+                            Some(c) => res.push(c),\n                             None => return self.error(InvalidUnicodeCodePoint),\n                         },\n                     },\n@@ -1556,7 +1556,7 @@ impl<T: Iterator<char>> Parser<T> {\n                         self.bump();\n                         return Ok(res);\n                     },\n-                    Some(c) => res.push_char(c),\n+                    Some(c) => res.push(c),\n                     None => unreachable!()\n                 }\n             }"}, {"sha": "803db4848ada522a0be704eabcdec69d8b9c354d", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366cfecf3fd4e3b589c140b85eee4bb4b35d97c/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5366cfecf3fd4e3b589c140b85eee4bb4b35d97c", "patch": "@@ -212,7 +212,7 @@ impl GenericPathUnsafe for Path {\n             None if \"..\" == self.repr.as_slice() => {\n                 let mut s = String::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n-                s.push_char(SEP);\n+                s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -222,7 +222,7 @@ impl GenericPathUnsafe for Path {\n             Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n                 s.push_str(self.repr.as_slice().slice_to(end));\n-                s.push_char(SEP);\n+                s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -235,7 +235,7 @@ impl GenericPathUnsafe for Path {\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n                 s.push_str(self.repr.as_slice().slice_to(idxb));\n-                s.push_char(SEP);\n+                s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -299,7 +299,7 @@ impl GenericPathUnsafe for Path {\n             match me.prefix {\n                 Some(DiskPrefix) if me.repr.len() == plen => (),\n                 _ if !(me.repr.len() > plen && me.repr.as_bytes()[me.repr.len()-1] == SEP_BYTE) => {\n-                    s.push_char(SEP);\n+                    s.push(SEP);\n                 }\n                 _ => ()\n             }\n@@ -745,7 +745,7 @@ impl Path {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n                     let mut s = String::from_str(s);\n-                    s.push_char(SEP);\n+                    s.push(SEP);\n                     Some(s)\n                 }\n                 _ => None\n@@ -815,20 +815,20 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push_char(prefix_.as_bytes()[0].to_ascii()\n+                                s.push(prefix_.as_bytes()[0].to_ascii()\n                                                    .to_uppercase().to_char());\n-                                s.push_char(':');\n+                                s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n-                                s.push_char(prefix_.as_bytes()[4].to_ascii()\n+                                s.push(prefix_.as_bytes()[4].to_ascii()\n                                                    .to_uppercase().to_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n                                 s.push_str(prefix_.slice(2, a+2));\n-                                s.push_char(SEP);\n+                                s.push(SEP);\n                                 s.push_str(prefix_.slice(3+a, 3+a+b));\n                             }\n                             Some(_) => s.push_str(prefix_),\n@@ -842,7 +842,7 @@ impl Path {\n                             }\n                         }\n                         for comp in it {\n-                            s.push_char(SEP);\n+                            s.push(SEP);\n                             s.push_str(comp);\n                         }\n                         Some(s)"}]}