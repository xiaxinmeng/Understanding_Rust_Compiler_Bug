{"sha": "5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYmJmYmJmYTkzMTlkMzhkMGY5YWNmNTRiM2ZmYWM2N2Q2YzMxMzY=", "commit": {"author": {"name": "Julian Wollersberger", "email": "24991778+Julian-Wollersberger@users.noreply.github.com", "date": "2020-05-29T15:37:16Z"}, "committer": {"name": "Julian Wollersberger", "email": "24991778+Julian-Wollersberger@users.noreply.github.com", "date": "2020-06-01T20:01:19Z"}, "message": "Simplify raw string error reporting.\nThis makes `UnvalidatedRawStr` and `ValidatedRawStr` unnecessary and removes 70 lines.", "tree": {"sha": "c8236a7d10fc73cbc455c74fa820ef4bb252fff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8236a7d10fc73cbc455c74fa820ef4bb252fff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "html_url": "https://github.com/rust-lang/rust/commit/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/comments", "author": {"login": "Julian-Wollersberger", "id": 24991778, "node_id": "MDQ6VXNlcjI0OTkxNzc4", "avatar_url": "https://avatars.githubusercontent.com/u/24991778?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Julian-Wollersberger", "html_url": "https://github.com/Julian-Wollersberger", "followers_url": "https://api.github.com/users/Julian-Wollersberger/followers", "following_url": "https://api.github.com/users/Julian-Wollersberger/following{/other_user}", "gists_url": "https://api.github.com/users/Julian-Wollersberger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Julian-Wollersberger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Julian-Wollersberger/subscriptions", "organizations_url": "https://api.github.com/users/Julian-Wollersberger/orgs", "repos_url": "https://api.github.com/users/Julian-Wollersberger/repos", "events_url": "https://api.github.com/users/Julian-Wollersberger/events{/privacy}", "received_events_url": "https://api.github.com/users/Julian-Wollersberger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Julian-Wollersberger", "id": 24991778, "node_id": "MDQ6VXNlcjI0OTkxNzc4", "avatar_url": "https://avatars.githubusercontent.com/u/24991778?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Julian-Wollersberger", "html_url": "https://github.com/Julian-Wollersberger", "followers_url": "https://api.github.com/users/Julian-Wollersberger/followers", "following_url": "https://api.github.com/users/Julian-Wollersberger/following{/other_user}", "gists_url": "https://api.github.com/users/Julian-Wollersberger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Julian-Wollersberger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Julian-Wollersberger/subscriptions", "organizations_url": "https://api.github.com/users/Julian-Wollersberger/orgs", "repos_url": "https://api.github.com/users/Julian-Wollersberger/repos", "events_url": "https://api.github.com/users/Julian-Wollersberger/events{/privacy}", "received_events_url": "https://api.github.com/users/Julian-Wollersberger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85e3fe010413b8c528d4de593d912a5ba024653", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85e3fe010413b8c528d4de593d912a5ba024653", "html_url": "https://github.com/rust-lang/rust/commit/b85e3fe010413b8c528d4de593d912a5ba024653"}], "stats": {"total": 301, "additions": 85, "deletions": 216}, "files": [{"sha": "cf90c6d838635b12c85465930e371c5419668ba7", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 45, "deletions": 105, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "patch": "@@ -29,7 +29,7 @@ mod tests;\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n-use std::convert::TryInto;\n+use std::convert::TryFrom;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -142,84 +142,24 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr(UnvalidatedRawStr),\n+    RawStr { n_hashes: u16, err: Option<RawStrError> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr(UnvalidatedRawStr),\n-}\n-\n-/// Represents something that looks like a raw string, but may have some\n-/// problems. Use `.validate()` to convert it into something\n-/// usable.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct UnvalidatedRawStr {\n-    /// The prefix (`r###\"`) is valid\n-    valid_start: bool,\n-\n-    /// The postfix (`\"###`) is valid\n-    valid_end: bool,\n-\n-    /// The number of leading `#`\n-    n_start_hashes: usize,\n-    /// The number of trailing `#`. `n_end_hashes` <= `n_start_hashes`\n-    n_end_hashes: usize,\n-    /// The offset starting at `r` or `br` where the user may have intended to end the string.\n-    /// Currently, it is the longest sequence of pattern `\"#+\"`.\n-    possible_terminator_offset: Option<usize>,\n+    RawByteStr { n_hashes: u16, err: Option<RawStrError> },\n }\n \n /// Error produced validating a raw string. Represents cases like:\n-/// - `r##~\"abcde\"##`: `LexRawStrError::InvalidStarter`\n-/// - `r###\"abcde\"##`: `LexRawStrError::NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n-/// - Too many `#`s (>65536): `TooManyDelimiters`\n+/// - `r##~\"abcde\"##`: `InvalidStarter`\n+/// - `r###\"abcde\"##`: `NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n+/// - Too many `#`s (>65535): `TooManyDelimiters`\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub enum LexRawStrError {\n+pub enum RawStrError {\n     /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n-    InvalidStarter,\n+    InvalidStarter { bad_char: char },\n     /// The string was never terminated. `possible_terminator_offset` is the number of characters after `r` or `br` where they\n     /// may have intended to terminate it.\n     NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n-    /// More than 65536 `#`s exist.\n-    TooManyDelimiters,\n-}\n-\n-/// Raw String that contains a valid prefix (`#+\"`) and postfix (`\"#+`) where\n-/// there are a matching number of `#` characters in both. Note that this will\n-/// not consume extra trailing `#` characters: `r###\"abcde\"####` is lexed as a\n-/// `ValidatedRawString { n_hashes: 3 }` followed by a `#` token.\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub struct ValidatedRawStr {\n-    n_hashes: u16,\n-}\n-\n-impl ValidatedRawStr {\n-    pub fn num_hashes(&self) -> u16 {\n-        self.n_hashes\n-    }\n-}\n-\n-impl UnvalidatedRawStr {\n-    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n-        if !self.valid_start {\n-            return Err(LexRawStrError::InvalidStarter);\n-        }\n-\n-        // Only up to 65535 `#`s are allowed in raw strings\n-        let n_start_safe: u16 =\n-            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n-\n-        if self.n_start_hashes > self.n_end_hashes || !self.valid_end {\n-            Err(LexRawStrError::NoTerminator {\n-                expected: self.n_start_hashes,\n-                found: self.n_end_hashes,\n-                possible_terminator_offset: self.possible_terminator_offset,\n-            })\n-        } else {\n-            // Since the lexer should never produce a literal with n_end > n_start, if n_start <= n_end,\n-            // they must be equal.\n-            debug_assert_eq!(self.n_start_hashes, self.n_end_hashes);\n-            Ok(ValidatedRawStr { n_hashes: n_start_safe })\n-        }\n-    }\n+    /// More than 65535 `#`s exist.\n+    TooManyDelimiters { found: usize },\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -354,12 +294,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let raw_str_i = self.raw_double_quoted_string(1);\n+                    let (n_hashes, err) = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n+                    if err.is_none() {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr(raw_str_i);\n+                    let kind = RawStr { n_hashes, err };\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -389,14 +329,12 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let raw_str_i = self.raw_double_quoted_string(2);\n+                    let (n_hashes, err) = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n-                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n-                    if terminated {\n+                    if err.is_none() {\n                         self.eat_literal_suffix();\n                     }\n-\n-                    let kind = RawByteStr(raw_str_i);\n+                    let kind = RawByteStr { n_hashes, err };\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -692,27 +630,34 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns an `UnvalidatedRawStr`.\n-    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n+    /// Eats the double-quoted string and returns `n_hashes` and an error if encountered.\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> (u16, Option<RawStrError>) {\n+        // Wrap the actual function to handle the error with too many hashes.\n+        // This way, it eats the whole raw string.\n+        let (n_hashes, err) = self.raw_string_unvalidated(prefix_len);\n+        // Only up to 65535 `#`s are allowed in raw strings\n+        match u16::try_from(n_hashes) {\n+            Ok(num) => (num, err),\n+            // We lie about the number of hashes here :P\n+            Err(_) => (0, Some(RawStrError::TooManyDelimiters { found: n_hashes })),\n+        }\n+    }\n+\n+    fn raw_string_unvalidated(&mut self, prefix_len: usize) -> (usize, Option<RawStrError>) {\n         debug_assert!(self.prev() == 'r');\n-        let mut valid_start: bool = false;\n         let start_pos = self.len_consumed();\n-        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n+        let mut possible_terminator_offset = None;\n+        let mut max_hashes = 0;\n \n         // Count opening '#' symbols.\n         let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => valid_start = true,\n-            _ => {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: false,\n-                    n_start_hashes,\n-                    n_end_hashes: 0,\n-                    possible_terminator_offset,\n-                };\n+            Some('\"') => (),\n+            c => {\n+                let c = c.unwrap_or(EOF_CHAR);\n+                return (n_start_hashes, Some(RawStrError::InvalidStarter { bad_char: c }));\n             }\n         }\n \n@@ -722,13 +667,14 @@ impl Cursor<'_> {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: false,\n+                return (\n                     n_start_hashes,\n-                    n_end_hashes: max_hashes,\n-                    possible_terminator_offset,\n-                };\n+                    Some(RawStrError::NoTerminator {\n+                        expected: n_start_hashes,\n+                        found: max_hashes,\n+                        possible_terminator_offset,\n+                    }),\n+                );\n             }\n \n             // Eat closing double quote.\n@@ -737,7 +683,7 @@ impl Cursor<'_> {\n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n             // Note that this will not consume extra trailing `#` characters:\n-            // `r###\"abcde\"####` is lexed as a `LexedRawString { n_hashes: 3 }`\n+            // `r###\"abcde\"####` is lexed as a `RawStr { n_hashes: 3 }`\n             // followed by a `#` token.\n             let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n@@ -751,13 +697,7 @@ impl Cursor<'_> {\n             let n_end_hashes = self.eat_while(is_closing_hash);\n \n             if n_end_hashes == n_start_hashes {\n-                return UnvalidatedRawStr {\n-                    valid_start,\n-                    valid_end: true,\n-                    n_start_hashes,\n-                    n_end_hashes,\n-                    possible_terminator_offset: None,\n-                };\n+                return (n_start_hashes, None);\n             } else if n_end_hashes > max_hashes {\n                 // Keep track of possible terminators to give a hint about\n                 // where there might be a missing terminator"}, {"sha": "e6acc26ec2f343e6645755f6032eff88e8e385d3", "filename": "src/librustc_lexer/src/tests.rs", "status": "modified", "additions": 16, "deletions": 84, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "patch": "@@ -2,92 +2,46 @@\n mod tests {\n     use crate::*;\n \n-    fn check_raw_str(\n-        s: &str,\n-        expected: UnvalidatedRawStr,\n-        validated: Result<ValidatedRawStr, LexRawStrError>,\n-    ) {\n+    fn check_raw_str(s: &str, expected_hashes: u16, expected_err: Option<RawStrError>) {\n         let s = &format!(\"r{}\", s);\n         let mut cursor = Cursor::new(s);\n         cursor.bump();\n-        let tok = cursor.raw_double_quoted_string(0);\n-        assert_eq!(tok, expected);\n-        assert_eq!(tok.validate(), validated);\n+        let (n_hashes, err) = cursor.raw_double_quoted_string(0);\n+        assert_eq!(n_hashes, expected_hashes);\n+        assert_eq!(err, expected_err);\n     }\n \n     #[test]\n     fn test_naked_raw_str() {\n-        check_raw_str(\n-            r#\"\"abc\"\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 0 }),\n-        );\n+        check_raw_str(r#\"\"abc\"\"#, 0, None);\n     }\n \n     #[test]\n     fn test_raw_no_start() {\n-        check_raw_str(\n-            r##\"\"abc\"#\"##,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 0 }),\n-        );\n+        check_raw_str(r##\"\"abc\"#\"##, 0, None);\n     }\n \n     #[test]\n     fn test_too_many_terminators() {\n         // this error is handled in the parser later\n-        check_raw_str(\n-            r###\"#\"abc\"##\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 1,\n-                valid_end: true,\n-                valid_start: true,\n-                possible_terminator_offset: None,\n-            },\n-            Ok(ValidatedRawStr { n_hashes: 1 }),\n-        );\n+        check_raw_str(r###\"#\"abc\"##\"###, 1, None);\n     }\n \n     #[test]\n     fn test_unterminated() {\n         check_raw_str(\n             r#\"#\"abc\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 0,\n-                valid_end: false,\n-                valid_start: true,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            1,\n+            Some(RawStrError::NoTerminator {\n                 expected: 1,\n                 found: 0,\n                 possible_terminator_offset: None,\n             }),\n         );\n         check_raw_str(\n             r###\"##\"abc\"#\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 2,\n-                n_end_hashes: 1,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: Some(7),\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            2,\n+            Some(RawStrError::NoTerminator {\n                 expected: 2,\n                 found: 1,\n                 possible_terminator_offset: Some(7),\n@@ -96,14 +50,8 @@ mod tests {\n         // We're looking for \"# not just any #\n         check_raw_str(\n             r###\"##\"abc#\"###,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 2,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            2,\n+            Some(RawStrError::NoTerminator {\n                 expected: 2,\n                 found: 0,\n                 possible_terminator_offset: None,\n@@ -113,32 +61,16 @@ mod tests {\n \n     #[test]\n     fn test_invalid_start() {\n-        check_raw_str(\n-            r##\"#~\"abc\"#\"##,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 1,\n-                n_end_hashes: 0,\n-                valid_start: false,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::InvalidStarter),\n-        );\n+        check_raw_str(r##\"#~\"abc\"#\"##, 1, Some(RawStrError::InvalidStarter { bad_char: '~' }));\n     }\n \n     #[test]\n     fn test_unterminated_no_pound() {\n         // https://github.com/rust-lang/rust/issues/70677\n         check_raw_str(\n             r#\"\"\"#,\n-            UnvalidatedRawStr {\n-                n_start_hashes: 0,\n-                n_end_hashes: 0,\n-                valid_start: true,\n-                valid_end: false,\n-                possible_terminator_offset: None,\n-            },\n-            Err(LexRawStrError::NoTerminator {\n+            0,\n+            Some(RawStrError::NoTerminator {\n                 expected: 0,\n                 found: 0,\n                 possible_terminator_offset: None,"}, {"sha": "f8a5db26d3231e05764e202b666711d313b3fd93", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=5fbbfbbfa9319d38d0f9acf54b3ffac67d6c3136", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n use rustc_lexer::Base;\n-use rustc_lexer::{unescape, LexRawStrError, UnvalidatedRawStr, ValidatedRawStr};\n+use rustc_lexer::{unescape, RawStrError};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Pos, Span};\n@@ -359,15 +359,13 @@ impl<'a> StringReader<'a> {\n                 }\n                 (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n             }\n-            rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n-                let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n-                let n_hashes = valid_raw_str.num_hashes();\n+            rustc_lexer::LiteralKind::RawStr { n_hashes, err } => {\n+                self.report_raw_str_error(start, err);\n                 let n = u32::from(n_hashes);\n                 (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n             }\n-            rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n-                let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n-                let n_hashes = validated_raw_str.num_hashes();\n+            rustc_lexer::LiteralKind::RawByteStr { n_hashes, err } => {\n+                self.report_raw_str_error(start, err);\n                 let n = u32::from(n_hashes);\n                 (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n             }\n@@ -459,28 +457,21 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    fn validate_and_report_errors(\n-        &self,\n-        start: BytePos,\n-        unvalidated_raw_str: UnvalidatedRawStr,\n-    ) -> ValidatedRawStr {\n-        match unvalidated_raw_str.validate() {\n-            Err(LexRawStrError::InvalidStarter) => self.report_non_started_raw_string(start),\n-            Err(LexRawStrError::NoTerminator { expected, found, possible_terminator_offset }) => {\n-                self.report_unterminated_raw_string(\n-                    start,\n-                    expected,\n-                    possible_terminator_offset,\n-                    found,\n-                )\n+    fn report_raw_str_error(&self, start: BytePos, opt_err: Option<RawStrError>) {\n+        match opt_err {\n+            Some(RawStrError::InvalidStarter { bad_char }) => {\n+                self.report_non_started_raw_string(start, bad_char)\n+            }\n+            Some(RawStrError::NoTerminator { expected, found, possible_terminator_offset }) => self\n+                .report_unterminated_raw_string(start, expected, possible_terminator_offset, found),\n+            Some(RawStrError::TooManyDelimiters { found }) => {\n+                self.report_too_many_hashes(start, found)\n             }\n-            Err(LexRawStrError::TooManyDelimiters) => self.report_too_many_hashes(start),\n-            Ok(valid) => valid,\n+            None => (),\n         }\n     }\n \n-    fn report_non_started_raw_string(&self, start: BytePos) -> ! {\n-        let bad_char = self.str_from(start).chars().last().unwrap();\n+    fn report_non_started_raw_string(&self, start: BytePos, bad_char: char) -> ! {\n         self.struct_fatal_span_char(\n             start,\n             self.pos,\n@@ -530,11 +521,17 @@ impl<'a> StringReader<'a> {\n         FatalError.raise()\n     }\n \n-    fn report_too_many_hashes(&self, start: BytePos) -> ! {\n+    /// Note: It was decided to not add a test case, because it would be to big.\n+    /// https://github.com/rust-lang/rust/pull/50296#issuecomment-392135180\n+    fn report_too_many_hashes(&self, start: BytePos, found: usize) -> ! {\n         self.fatal_span_(\n             start,\n             self.pos,\n-            \"too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+            &format!(\n+                \"too many `#` symbols: raw strings may be delimited \\\n+                by up to 65535 `#` symbols, but found {}\",\n+                found\n+            ),\n         )\n         .raise();\n     }"}]}