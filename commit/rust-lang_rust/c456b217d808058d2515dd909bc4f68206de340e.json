{"sha": "c456b217d808058d2515dd909bc4f68206de340e", "node_id": "C_kwDOAAsO6NoAKGM0NTZiMjE3ZDgwODA1OGQyNTE1ZGQ5MDliYzRmNjgyMDZkZTM0MGU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-25T19:13:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-25T19:13:56Z"}, "message": "Merge #11117\n\n11117: internal: replace TreeSink with a data structure  r=matklad a=matklad\n\nThe general theme of this is to make parser a better independent\r\nlibrary.\r\n\r\nThe specific thing we do here is replacing callback based TreeSink with\r\na data structure. That is, rather than calling user-provided tree\r\nconstruction methods, the parser now spits out a very bare-bones tree,\r\neffectively a log of a DFS traversal.\r\n\r\nThis makes the parser usable without any *specifc* tree sink, and allows\r\nus to, eg, move tests into this crate.\r\n\r\nNow, it's also true that this is a distinction without a difference, as\r\nthe old and the new interface are equivalent in expressiveness. Still,\r\nthis new thing seems somewhat simpler. But yeah, I admit I don't have a\r\nsuuper strong motivation here, just a hunch that this is better.\r\n\r\ncc #10765 \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ec765ea710e0ce32b341429c709f2a78a57b05f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec765ea710e0ce32b341429c709f2a78a57b05f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c456b217d808058d2515dd909bc4f68206de340e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhx210CRBK7hj4Ov3rIwAAfHMIAI2xoz+1xytTT1xwN+vNKdVP\nCJ/4/82TrE8q8F412DK3HI1O3Cc9ibFeSKVc1GZdK0kDRJhofcxMFj6giuUMTrXy\nmM/FPgwkZO645sfBMXQIz2AkwDCsAuP7mf0LvVoHbhRNBBcEgbdMdg4JtFXIPTtF\naL/ngAfR2t18UQNaBBpMGaSC3UN61/KguFNh7SHn+BIj2J0lUZ69GpcLt7EouseP\n6EKN8h4wMs9DN5xldxtZ3Sl3i9iuSwk005rUOdrsgbaBIIENhzwyfGh8fd5QuYtD\npTiX4ZSg4FNug68hKpaoUVkZLhgu3jgIMgIMm4Wnijtuu6GCsMJIi5PqpvCeUhA=\n=CdDw\n-----END PGP SIGNATURE-----\n", "payload": "tree ec765ea710e0ce32b341429c709f2a78a57b05f5\nparent 2f63558dc5523005fd84dc272864a37bb3c1fa90\nparent f692fafee8bf90d603c36668f43b151e5e111ec3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640459636 +0000\ncommitter GitHub <noreply@github.com> 1640459636 +0000\n\nMerge #11117\n\n11117: internal: replace TreeSink with a data structure  r=matklad a=matklad\n\nThe general theme of this is to make parser a better independent\r\nlibrary.\r\n\r\nThe specific thing we do here is replacing callback based TreeSink with\r\na data structure. That is, rather than calling user-provided tree\r\nconstruction methods, the parser now spits out a very bare-bones tree,\r\neffectively a log of a DFS traversal.\r\n\r\nThis makes the parser usable without any *specifc* tree sink, and allows\r\nus to, eg, move tests into this crate.\r\n\r\nNow, it's also true that this is a distinction without a difference, as\r\nthe old and the new interface are equivalent in expressiveness. Still,\r\nthis new thing seems somewhat simpler. But yeah, I admit I don't have a\r\nsuuper strong motivation here, just a hunch that this is better.\r\n\r\ncc #10765 \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c456b217d808058d2515dd909bc4f68206de340e", "html_url": "https://github.com/rust-lang/rust/commit/c456b217d808058d2515dd909bc4f68206de340e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c456b217d808058d2515dd909bc4f68206de340e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f63558dc5523005fd84dc272864a37bb3c1fa90", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f63558dc5523005fd84dc272864a37bb3c1fa90", "html_url": "https://github.com/rust-lang/rust/commit/2f63558dc5523005fd84dc272864a37bb3c1fa90"}, {"sha": "f692fafee8bf90d603c36668f43b151e5e111ec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f692fafee8bf90d603c36668f43b151e5e111ec3", "html_url": "https://github.com/rust-lang/rust/commit/f692fafee8bf90d603c36668f43b151e5e111ec3"}], "stats": {"total": 444, "additions": 259, "deletions": 185}, "files": [{"sha": "5e14a3fb590264a75b84770996e02a88aa872a56", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -10,7 +10,7 @@ mod parser;\n mod expander;\n mod syntax_bridge;\n mod tt_iter;\n-mod to_parser_tokens;\n+mod to_parser_input;\n \n #[cfg(test)]\n mod benchmark;"}, {"sha": "f0c1f806ffae9c9354da9eb1cb633fb354c321ca", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -1,6 +1,5 @@\n //! Conversions between [`SyntaxNode`] and [`tt::TokenTree`].\n \n-use parser::{ParseError, TreeSink};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     ast::{self, make::tokens::doc_comment},\n@@ -11,7 +10,7 @@ use syntax::{\n use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::{\n-    to_parser_tokens::to_parser_tokens, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n+    to_parser_input::to_parser_input, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n };\n \n /// Convert the syntax node to a `TokenTree` (what macro\n@@ -55,9 +54,19 @@ pub fn token_tree_to_syntax_node(\n         }\n         _ => TokenBuffer::from_subtree(tt),\n     };\n-    let parser_tokens = to_parser_tokens(&buffer);\n+    let parser_input = to_parser_input(&buffer);\n+    let parser_output = parser::parse(&parser_input, entry_point);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n-    parser::parse(&parser_tokens, &mut tree_sink, entry_point);\n+    for event in parser_output.iter() {\n+        match event {\n+            parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n+                tree_sink.token(kind, n_raw_tokens)\n+            }\n+            parser::Step::Enter { kind } => tree_sink.start_node(kind),\n+            parser::Step::Exit => tree_sink.finish_node(),\n+            parser::Step::Error { msg } => tree_sink.error(msg.to_string()),\n+        }\n+    }\n     if tree_sink.roots.len() != 1 {\n         return Err(ExpandError::ConversionError);\n     }\n@@ -643,7 +652,7 @@ fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> &'static str {\n     &texts[idx..texts.len() - (1 - idx)]\n }\n \n-impl<'a> TreeSink for TtTreeSink<'a> {\n+impl<'a> TtTreeSink<'a> {\n     fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n         if kind == LIFETIME_IDENT {\n             n_tokens = 2;\n@@ -741,7 +750,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         *self.roots.last_mut().unwrap() -= 1;\n     }\n \n-    fn error(&mut self, error: ParseError) {\n+    fn error(&mut self, error: String) {\n         self.inner.error(error, self.text_pos)\n     }\n }"}, {"sha": "6faa147218e1d14f96c2da53dc2d10216dd40839", "filename": "crates/mbe/src/to_parser_input.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -4,8 +4,8 @@\n use syntax::{SyntaxKind, SyntaxKind::*, T};\n use tt::buffer::TokenBuffer;\n \n-pub(crate) fn to_parser_tokens(buffer: &TokenBuffer) -> parser::Tokens {\n-    let mut res = parser::Tokens::default();\n+pub(crate) fn to_parser_input(buffer: &TokenBuffer) -> parser::Input {\n+    let mut res = parser::Input::default();\n \n     let mut current = buffer.begin();\n ", "previous_filename": "crates/mbe/src/to_parser_tokens.rs"}, {"sha": "2d2dbd8994f6419aa1ce025994be158839ed08ad", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -1,11 +1,10 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n-use crate::{to_parser_tokens::to_parser_tokens, ExpandError, ExpandResult, ParserEntryPoint};\n+use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult, ParserEntryPoint};\n \n-use parser::TreeSink;\n use syntax::SyntaxKind;\n-use tt::buffer::{Cursor, TokenBuffer};\n+use tt::buffer::TokenBuffer;\n \n macro_rules! err {\n     () => {\n@@ -94,34 +93,28 @@ impl<'a> TtIter<'a> {\n         &mut self,\n         entry_point: ParserEntryPoint,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n-        struct OffsetTokenSink<'a> {\n-            cursor: Cursor<'a>,\n-            error: bool,\n-        }\n-\n-        impl<'a> TreeSink for OffsetTokenSink<'a> {\n-            fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n-                if kind == SyntaxKind::LIFETIME_IDENT {\n-                    n_tokens = 2;\n-                }\n-                for _ in 0..n_tokens {\n-                    self.cursor = self.cursor.bump_subtree();\n+        let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n+        let parser_input = to_parser_input(&buffer);\n+        let tree_traversal = parser::parse(&parser_input, entry_point);\n+\n+        let mut cursor = buffer.begin();\n+        let mut error = false;\n+        for step in tree_traversal.iter() {\n+            match step {\n+                parser::Step::Token { kind, mut n_input_tokens } => {\n+                    if kind == SyntaxKind::LIFETIME_IDENT {\n+                        n_input_tokens = 2;\n+                    }\n+                    for _ in 0..n_input_tokens {\n+                        cursor = cursor.bump_subtree();\n+                    }\n                 }\n-            }\n-            fn start_node(&mut self, _kind: SyntaxKind) {}\n-            fn finish_node(&mut self) {}\n-            fn error(&mut self, _error: parser::ParseError) {\n-                self.error = true;\n+                parser::Step::Enter { .. } | parser::Step::Exit => (),\n+                parser::Step::Error { .. } => error = true,\n             }\n         }\n \n-        let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n-        let parser_tokens = to_parser_tokens(&buffer);\n-        let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n-\n-        parser::parse(&parser_tokens, &mut sink, entry_point);\n-\n-        let mut err = if !sink.cursor.is_root() || sink.error {\n+        let mut err = if !cursor.is_root() || error {\n             Some(err!(\"expected {:?}\", entry_point))\n         } else {\n             None\n@@ -130,8 +123,8 @@ impl<'a> TtIter<'a> {\n         let mut curr = buffer.begin();\n         let mut res = vec![];\n \n-        if sink.cursor.is_root() {\n-            while curr != sink.cursor {\n+        if cursor.is_root() {\n+            while curr != cursor {\n                 if let Some(token) = curr.token_tree() {\n                     res.push(token);\n                 }"}, {"sha": "b0e70e794303c6219e70eb582d0e019c75ad61d0", "filename": "crates/parser/src/event.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fevent.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -10,9 +10,8 @@\n use std::mem;\n \n use crate::{\n-    ParseError,\n+    output::Output,\n     SyntaxKind::{self, *},\n-    TreeSink,\n };\n \n /// `Parser` produces a flat list of `Event`s.\n@@ -77,7 +76,7 @@ pub(crate) enum Event {\n     },\n \n     Error {\n-        msg: ParseError,\n+        msg: String,\n     },\n }\n \n@@ -88,7 +87,8 @@ impl Event {\n }\n \n /// Generate the syntax tree with the control of events.\n-pub(super) fn process(sink: &mut dyn TreeSink, mut events: Vec<Event>) {\n+pub(super) fn process(mut events: Vec<Event>) -> Output {\n+    let mut res = Output::default();\n     let mut forward_parents = Vec::new();\n \n     for i in 0..events.len() {\n@@ -117,15 +117,17 @@ pub(super) fn process(sink: &mut dyn TreeSink, mut events: Vec<Event>) {\n \n                 for kind in forward_parents.drain(..).rev() {\n                     if kind != TOMBSTONE {\n-                        sink.start_node(kind);\n+                        res.enter_node(kind);\n                     }\n                 }\n             }\n-            Event::Finish => sink.finish_node(),\n+            Event::Finish => res.leave_node(),\n             Event::Token { kind, n_raw_tokens } => {\n-                sink.token(kind, n_raw_tokens);\n+                res.token(kind, n_raw_tokens);\n             }\n-            Event::Error { msg } => sink.error(msg),\n+            Event::Error { msg } => res.error(msg),\n         }\n     }\n+\n+    res\n }"}, {"sha": "9504bd4d9ec83f6dda167aafab091dfeec60e8f3", "filename": "crates/parser/src/input.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Finput.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -1,26 +1,26 @@\n-//! Input for the parser -- a sequence of tokens.\n-//!\n-//! As of now, parser doesn't have access to the *text* of the tokens, and makes\n-//! decisions based solely on their classification. Unlike `LexerToken`, the\n-//! `Tokens` doesn't include whitespace and comments.\n+//! See [`Input`].\n \n use crate::SyntaxKind;\n \n #[allow(non_camel_case_types)]\n type bits = u64;\n \n-/// Main input to the parser.\n+/// Input for the parser -- a sequence of tokens.\n ///\n-/// A sequence of tokens represented internally as a struct of arrays.\n+/// As of now, parser doesn't have access to the *text* of the tokens, and makes\n+/// decisions based solely on their classification. Unlike `LexerToken`, the\n+/// `Tokens` doesn't include whitespace and comments. Main input to the parser.\n+///\n+/// Struct of arrays internally, but this shouldn't really matter.\n #[derive(Default)]\n-pub struct Tokens {\n+pub struct Input {\n     kind: Vec<SyntaxKind>,\n     joint: Vec<bits>,\n     contextual_kind: Vec<SyntaxKind>,\n }\n \n /// `pub` impl used by callers to create `Tokens`.\n-impl Tokens {\n+impl Input {\n     #[inline]\n     pub fn push(&mut self, kind: SyntaxKind) {\n         self.push_impl(kind, SyntaxKind::EOF)\n@@ -63,7 +63,7 @@ impl Tokens {\n }\n \n /// pub(crate) impl used by the parser to consume `Tokens`.\n-impl Tokens {\n+impl Input {\n     pub(crate) fn kind(&self, idx: usize) -> SyntaxKind {\n         self.kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)\n     }\n@@ -76,7 +76,7 @@ impl Tokens {\n     }\n }\n \n-impl Tokens {\n+impl Input {\n     fn bit_index(&self, n: usize) -> (usize, usize) {\n         let idx = n / (bits::BITS as usize);\n         let b_idx = n % (bits::BITS as usize);", "previous_filename": "crates/parser/src/tokens.rs"}, {"sha": "f17aae1d3140a35f953ac006696ba178a76f227e", "filename": "crates/parser/src/lexed_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Flexed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Flexed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flexed_str.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -122,8 +122,8 @@ impl<'a> LexedStr<'a> {\n         self.error.iter().map(|it| (it.token as usize, it.msg.as_str()))\n     }\n \n-    pub fn to_tokens(&self) -> crate::Tokens {\n-        let mut res = crate::Tokens::default();\n+    pub fn to_input(&self) -> crate::Input {\n+        let mut res = crate::Input::default();\n         let mut was_joint = false;\n         for i in 0..self.len() {\n             let kind = self.kind(i);"}, {"sha": "da78889f350040bf31b15454c342bb535d84e19e", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -24,32 +24,20 @@ mod syntax_kind;\n mod event;\n mod parser;\n mod grammar;\n-mod tokens;\n+mod input;\n+mod output;\n \n #[cfg(test)]\n mod tests;\n \n pub(crate) use token_set::TokenSet;\n \n-pub use crate::{lexed_str::LexedStr, syntax_kind::SyntaxKind, tokens::Tokens};\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParseError(pub Box<String>);\n-\n-/// `TreeSink` abstracts details of a particular syntax tree implementation.\n-pub trait TreeSink {\n-    /// Adds new token to the current branch.\n-    fn token(&mut self, kind: SyntaxKind, n_tokens: u8);\n-\n-    /// Start new branch and make it current.\n-    fn start_node(&mut self, kind: SyntaxKind);\n-\n-    /// Finish current branch and restore previous\n-    /// branch as current.\n-    fn finish_node(&mut self);\n-\n-    fn error(&mut self, error: ParseError);\n-}\n+pub use crate::{\n+    input::Input,\n+    lexed_str::LexedStr,\n+    output::{Output, Step},\n+    syntax_kind::SyntaxKind,\n+};\n \n /// rust-analyzer parser allows you to choose one of the possible entry points.\n ///\n@@ -74,11 +62,19 @@ pub enum ParserEntryPoint {\n }\n \n /// Parse given tokens into the given sink as a rust file.\n-pub fn parse_source_file(tokens: &Tokens, tree_sink: &mut dyn TreeSink) {\n-    parse(tokens, tree_sink, ParserEntryPoint::SourceFile);\n+pub fn parse_source_file(inp: &Input) -> Output {\n+    parse(inp, ParserEntryPoint::SourceFile)\n }\n \n-pub fn parse(tokens: &Tokens, tree_sink: &mut dyn TreeSink, entry_point: ParserEntryPoint) {\n+/// Parses the given [`Input`] into [`Output`] assuming that the top-level\n+/// syntactic construct is the given [`ParserEntryPoint`].\n+///\n+/// Both input and output here are fairly abstract. The overall flow is that the\n+/// caller has some \"real\" tokens, converts them to [`Input`], parses them to\n+/// [`Output`], and then converts that into a \"real\" tree. The \"real\" tree is\n+/// made of \"real\" tokens, so this all hinges on rather tight coordination of\n+/// indices between the four stages.\n+pub fn parse(inp: &Input, entry_point: ParserEntryPoint) -> Output {\n     let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n         ParserEntryPoint::SourceFile => grammar::entry_points::source_file,\n         ParserEntryPoint::Path => grammar::entry_points::path,\n@@ -96,10 +92,10 @@ pub fn parse(tokens: &Tokens, tree_sink: &mut dyn TreeSink, entry_point: ParserE\n         ParserEntryPoint::Attr => grammar::entry_points::attr,\n     };\n \n-    let mut p = parser::Parser::new(tokens);\n+    let mut p = parser::Parser::new(inp);\n     entry_point(&mut p);\n     let events = p.finish();\n-    event::process(tree_sink, events);\n+    event::process(events)\n }\n \n /// A parsing function for a specific braced-block.\n@@ -119,11 +115,11 @@ impl Reparser {\n     ///\n     /// Tokens must start with `{`, end with `}` and form a valid brace\n     /// sequence.\n-    pub fn parse(self, tokens: &Tokens, tree_sink: &mut dyn TreeSink) {\n+    pub fn parse(self, tokens: &Input) -> Output {\n         let Reparser(r) = self;\n         let mut p = parser::Parser::new(tokens);\n         r(&mut p);\n         let events = p.finish();\n-        event::process(tree_sink, events);\n+        event::process(events)\n     }\n }"}, {"sha": "b613df029f8206097f0449a6ef41b3ba5a0f2496", "filename": "crates/parser/src/output.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Foutput.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -0,0 +1,76 @@\n+//! See [`Output`]\n+\n+use crate::SyntaxKind;\n+\n+/// Output of the parser -- a DFS traversal of a concrete syntax tree.\n+///\n+/// Use the [`Output::iter`] method to iterate over traversal steps and consume\n+/// a syntax tree.\n+///\n+/// In a sense, this is just a sequence of [`SyntaxKind`]-colored parenthesis\n+/// interspersed into the original [`crate::Input`]. The output is fundamentally\n+/// coordinated with the input and `n_input_tokens` refers to the number of\n+/// times [`crate::Input::push`] was called.\n+#[derive(Default)]\n+pub struct Output {\n+    /// 32-bit encoding of events. If LSB is zero, then that's an index into the\n+    /// error vector. Otherwise, it's one of the thee other variants, with data encoded as\n+    ///\n+    ///     |16 bit kind|8 bit n_input_tokens|4 bit tag|4 bit leftover|\n+    ///\n+    event: Vec<u32>,\n+    error: Vec<String>,\n+}\n+\n+pub enum Step<'a> {\n+    Token { kind: SyntaxKind, n_input_tokens: u8 },\n+    Enter { kind: SyntaxKind },\n+    Exit,\n+    Error { msg: &'a str },\n+}\n+\n+impl Output {\n+    pub fn iter(&self) -> impl Iterator<Item = Step<'_>> {\n+        self.event.iter().map(|&event| {\n+            if event & 0b1 == 0 {\n+                return Step::Error { msg: self.error[(event as usize) >> 1].as_str() };\n+            }\n+            let tag = ((event & 0x0000_00F0) >> 4) as u8;\n+            match tag {\n+                0 => {\n+                    let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n+                    let n_input_tokens = ((event & 0x0000_FF00) >> 8) as u8;\n+                    Step::Token { kind, n_input_tokens }\n+                }\n+                1 => {\n+                    let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n+                    Step::Enter { kind }\n+                }\n+                2 => Step::Exit,\n+                _ => unreachable!(),\n+            }\n+        })\n+    }\n+\n+    pub(crate) fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+        let e = ((kind as u16 as u32) << 16) | ((n_tokens as u32) << 8) | (0 << 4) | 1;\n+        self.event.push(e)\n+    }\n+\n+    pub(crate) fn enter_node(&mut self, kind: SyntaxKind) {\n+        let e = ((kind as u16 as u32) << 16) | (1 << 4) | 1;\n+        self.event.push(e)\n+    }\n+\n+    pub(crate) fn leave_node(&mut self) {\n+        let e = 2 << 4 | 1;\n+        self.event.push(e)\n+    }\n+\n+    pub(crate) fn error(&mut self, error: String) {\n+        let idx = self.error.len();\n+        self.error.push(error);\n+        let e = (idx as u32) << 1;\n+        self.event.push(e);\n+    }\n+}"}, {"sha": "d4aecf9b446a36216f7a9afec4a2af848395b27d", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -7,8 +7,7 @@ use limit::Limit;\n \n use crate::{\n     event::Event,\n-    tokens::Tokens,\n-    ParseError,\n+    input::Input,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n     TokenSet, T,\n };\n@@ -23,7 +22,7 @@ use crate::{\n /// \"start expression, consume number literal,\n /// finish expression\". See `Event` docs for more.\n pub(crate) struct Parser<'t> {\n-    tokens: &'t Tokens,\n+    inp: &'t Input,\n     pos: usize,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n@@ -32,8 +31,8 @@ pub(crate) struct Parser<'t> {\n static PARSER_STEP_LIMIT: Limit = Limit::new(15_000_000);\n \n impl<'t> Parser<'t> {\n-    pub(super) fn new(tokens: &'t Tokens) -> Parser<'t> {\n-        Parser { tokens, pos: 0, events: Vec::new(), steps: Cell::new(0) }\n+    pub(super) fn new(inp: &'t Input) -> Parser<'t> {\n+        Parser { inp, pos: 0, events: Vec::new(), steps: Cell::new(0) }\n     }\n \n     pub(crate) fn finish(self) -> Vec<Event> {\n@@ -56,7 +55,7 @@ impl<'t> Parser<'t> {\n         assert!(PARSER_STEP_LIMIT.check(steps as usize).is_ok(), \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.tokens.kind(self.pos + n)\n+        self.inp.kind(self.pos + n)\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -92,7 +91,7 @@ impl<'t> Parser<'t> {\n             T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n             T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n \n-            _ => self.tokens.kind(self.pos + n) == kind,\n+            _ => self.inp.kind(self.pos + n) == kind,\n         }\n     }\n \n@@ -131,17 +130,17 @@ impl<'t> Parser<'t> {\n     }\n \n     fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n-        self.tokens.kind(self.pos + n) == k1\n-            && self.tokens.kind(self.pos + n + 1) == k2\n-            && self.tokens.is_joint(self.pos + n)\n+        self.inp.kind(self.pos + n) == k1\n+            && self.inp.kind(self.pos + n + 1) == k2\n+            && self.inp.is_joint(self.pos + n)\n     }\n \n     fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n-        self.tokens.kind(self.pos + n) == k1\n-            && self.tokens.kind(self.pos + n + 1) == k2\n-            && self.tokens.kind(self.pos + n + 2) == k3\n-            && self.tokens.is_joint(self.pos + n)\n-            && self.tokens.is_joint(self.pos + n + 1)\n+        self.inp.kind(self.pos + n) == k1\n+            && self.inp.kind(self.pos + n + 1) == k2\n+            && self.inp.kind(self.pos + n + 2) == k3\n+            && self.inp.is_joint(self.pos + n)\n+            && self.inp.is_joint(self.pos + n + 1)\n     }\n \n     /// Checks if the current token is in `kinds`.\n@@ -151,7 +150,7 @@ impl<'t> Parser<'t> {\n \n     /// Checks if the current token is contextual keyword with text `t`.\n     pub(crate) fn at_contextual_kw(&self, kw: SyntaxKind) -> bool {\n-        self.tokens.contextual_kind(self.pos) == kw\n+        self.inp.contextual_kind(self.pos) == kw\n     }\n \n     /// Starts a new node in the syntax tree. All nodes and tokens\n@@ -196,7 +195,7 @@ impl<'t> Parser<'t> {\n     /// structured errors with spans and notes, like rustc\n     /// does.\n     pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n-        let msg = ParseError(Box::new(message.into()));\n+        let msg = message.into();\n         self.push_event(Event::Error { msg });\n     }\n "}, {"sha": "20c7101a0324cfa1d9d350e6a77b99c8ae09dcd1", "filename": "crates/syntax/src/parsing.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -4,24 +4,18 @@\n mod text_tree_sink;\n mod reparsing;\n \n-use parser::SyntaxKind;\n-use text_tree_sink::TextTreeSink;\n-\n-use crate::{syntax_node::GreenNode, AstNode, SyntaxError, SyntaxNode};\n+use crate::{\n+    parsing::text_tree_sink::build_tree, syntax_node::GreenNode, AstNode, SyntaxError, SyntaxNode,\n+};\n \n pub(crate) use crate::parsing::reparsing::incremental_reparse;\n \n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let lexed = parser::LexedStr::new(text);\n-    let parser_tokens = lexed.to_tokens();\n-\n-    let mut tree_sink = TextTreeSink::new(lexed);\n-\n-    parser::parse_source_file(&parser_tokens, &mut tree_sink);\n-\n-    let (tree, parser_errors) = tree_sink.finish();\n-\n-    (tree, parser_errors)\n+    let parser_input = lexed.to_input();\n+    let parser_output = parser::parse_source_file(&parser_input);\n+    let (node, errors, _eof) = build_tree(lexed, parser_output, false);\n+    (node, errors)\n }\n \n /// Returns `text` parsed as a `T` provided there are no parse errors.\n@@ -33,21 +27,13 @@ pub(crate) fn parse_text_as<T: AstNode>(\n     if lexed.errors().next().is_some() {\n         return Err(());\n     }\n-    let parser_tokens = lexed.to_tokens();\n-\n-    let mut tree_sink = TextTreeSink::new(lexed);\n-\n-    // TextTreeSink assumes that there's at least some root node to which it can attach errors and\n-    // tokens. We arbitrarily give it a SourceFile.\n-    use parser::TreeSink;\n-    tree_sink.start_node(SyntaxKind::SOURCE_FILE);\n-    parser::parse(&parser_tokens, &mut tree_sink, entry_point);\n-    tree_sink.finish_node();\n+    let parser_input = lexed.to_input();\n+    let parser_output = parser::parse(&parser_input, entry_point);\n+    let (node, errors, eof) = build_tree(lexed, parser_output, true);\n \n-    let (tree, parser_errors, eof) = tree_sink.finish_eof();\n-    if !parser_errors.is_empty() || !eof {\n+    if !errors.is_empty() || !eof {\n         return Err(());\n     }\n \n-    SyntaxNode::new_root(tree).first_child().and_then(T::cast).ok_or(())\n+    SyntaxNode::new_root(node).first_child().and_then(T::cast).ok_or(())\n }"}, {"sha": "a6abe3cccf3f3dce5b4dc93db659ebd2582379e1", "filename": "crates/syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -10,7 +10,7 @@ use parser::Reparser;\n use text_edit::Indel;\n \n use crate::{\n-    parsing::text_tree_sink::TextTreeSink,\n+    parsing::text_tree_sink::build_tree,\n     syntax_node::{GreenNode, GreenToken, NodeOrToken, SyntaxElement, SyntaxNode},\n     SyntaxError,\n     SyntaxKind::*,\n@@ -89,16 +89,14 @@ fn reparse_block(\n     let text = get_text_after_edit(node.clone().into(), edit);\n \n     let lexed = parser::LexedStr::new(text.as_str());\n-    let parser_tokens = lexed.to_tokens();\n+    let parser_input = lexed.to_input();\n     if !is_balanced(&lexed) {\n         return None;\n     }\n \n-    let mut tree_sink = TextTreeSink::new(lexed);\n+    let tree_traversal = reparser.parse(&parser_input);\n \n-    reparser.parse(&parser_tokens, &mut tree_sink);\n-\n-    let (green, new_parser_errors) = tree_sink.finish();\n+    let (green, new_parser_errors, _eof) = build_tree(lexed, tree_traversal, false);\n \n     Some((node.replace_with(green), new_parser_errors, node.text_range()))\n }"}, {"sha": "f40c549e3d7bcedb12ec44a97a5ffb7a543216c5", "filename": "crates/syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 63, "deletions": 48, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -2,7 +2,7 @@\n \n use std::mem;\n \n-use parser::{LexedStr, ParseError, TreeSink};\n+use parser::LexedStr;\n \n use crate::{\n     ast,\n@@ -12,10 +12,37 @@ use crate::{\n     SyntaxTreeBuilder, TextRange,\n };\n \n-/// Bridges the parser with our specific syntax tree representation.\n-///\n-/// `TextTreeSink` also handles attachment of trivia (whitespace) to nodes.\n-pub(crate) struct TextTreeSink<'a> {\n+pub(crate) fn build_tree(\n+    lexed: LexedStr<'_>,\n+    parser_output: parser::Output,\n+    synthetic_root: bool,\n+) -> (GreenNode, Vec<SyntaxError>, bool) {\n+    let mut builder = Builder::new(lexed);\n+\n+    if synthetic_root {\n+        builder.enter(SyntaxKind::SOURCE_FILE);\n+    }\n+\n+    for event in parser_output.iter() {\n+        match event {\n+            parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n+                builder.token(kind, n_raw_tokens)\n+            }\n+            parser::Step::Enter { kind } => builder.enter(kind),\n+            parser::Step::Exit => builder.exit(),\n+            parser::Step::Error { msg } => {\n+                let text_pos = builder.lexed.text_start(builder.pos).try_into().unwrap();\n+                builder.inner.error(msg.to_string(), text_pos);\n+            }\n+        }\n+    }\n+    if synthetic_root {\n+        builder.exit()\n+    }\n+    builder.build()\n+}\n+\n+struct Builder<'a> {\n     lexed: LexedStr<'a>,\n     pos: usize,\n     state: State,\n@@ -28,7 +55,35 @@ enum State {\n     PendingFinish,\n }\n \n-impl<'a> TreeSink for TextTreeSink<'a> {\n+impl<'a> Builder<'a> {\n+    fn new(lexed: parser::LexedStr<'a>) -> Self {\n+        Self { lexed, pos: 0, state: State::PendingStart, inner: SyntaxTreeBuilder::default() }\n+    }\n+\n+    fn build(mut self) -> (GreenNode, Vec<SyntaxError>, bool) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingFinish => {\n+                self.eat_trivias();\n+                self.inner.finish_node();\n+            }\n+            State::PendingStart | State::Normal => unreachable!(),\n+        }\n+\n+        let (node, mut errors) = self.inner.finish_raw();\n+        for (i, err) in self.lexed.errors() {\n+            let text_range = self.lexed.text_range(i);\n+            let text_range = TextRange::new(\n+                text_range.start.try_into().unwrap(),\n+                text_range.end.try_into().unwrap(),\n+            );\n+            errors.push(SyntaxError::new(err, text_range))\n+        }\n+\n+        let is_eof = self.pos == self.lexed.len();\n+\n+        (node, errors, is_eof)\n+    }\n+\n     fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => unreachable!(),\n@@ -39,7 +94,7 @@ impl<'a> TreeSink for TextTreeSink<'a> {\n         self.do_token(kind, n_tokens as usize);\n     }\n \n-    fn start_node(&mut self, kind: SyntaxKind) {\n+    fn enter(&mut self, kind: SyntaxKind) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => {\n                 self.inner.start_node(kind);\n@@ -63,54 +118,14 @@ impl<'a> TreeSink for TextTreeSink<'a> {\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish_node(&mut self) {\n+    fn exit(&mut self) {\n         match mem::replace(&mut self.state, State::PendingFinish) {\n             State::PendingStart => unreachable!(),\n             State::PendingFinish => self.inner.finish_node(),\n             State::Normal => (),\n         }\n     }\n \n-    fn error(&mut self, error: ParseError) {\n-        let text_pos = self.lexed.text_start(self.pos).try_into().unwrap();\n-        self.inner.error(error, text_pos);\n-    }\n-}\n-\n-impl<'a> TextTreeSink<'a> {\n-    pub(super) fn new(lexed: parser::LexedStr<'a>) -> Self {\n-        Self { lexed, pos: 0, state: State::PendingStart, inner: SyntaxTreeBuilder::default() }\n-    }\n-\n-    pub(super) fn finish_eof(mut self) -> (GreenNode, Vec<SyntaxError>, bool) {\n-        match mem::replace(&mut self.state, State::Normal) {\n-            State::PendingFinish => {\n-                self.eat_trivias();\n-                self.inner.finish_node();\n-            }\n-            State::PendingStart | State::Normal => unreachable!(),\n-        }\n-\n-        let (node, mut errors) = self.inner.finish_raw();\n-        for (i, err) in self.lexed.errors() {\n-            let text_range = self.lexed.text_range(i);\n-            let text_range = TextRange::new(\n-                text_range.start.try_into().unwrap(),\n-                text_range.end.try_into().unwrap(),\n-            );\n-            errors.push(SyntaxError::new(err, text_range))\n-        }\n-\n-        let is_eof = self.pos == self.lexed.len();\n-\n-        (node, errors, is_eof)\n-    }\n-\n-    pub(super) fn finish(self) -> (GreenNode, Vec<SyntaxError>) {\n-        let (node, errors, _eof) = self.finish_eof();\n-        (node, errors)\n-    }\n-\n     fn eat_trivias(&mut self) {\n         while self.pos < self.lexed.len() {\n             let kind = self.lexed.kind(self.pos);"}, {"sha": "b96f10c1730e6ddef99209dab0bcb13831657209", "filename": "crates/syntax/src/syntax_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c456b217d808058d2515dd909bc4f68206de340e/crates%2Fsyntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fsyntax_node.rs?ref=c456b217d808058d2515dd909bc4f68206de340e", "patch": "@@ -69,7 +69,7 @@ impl SyntaxTreeBuilder {\n         self.inner.finish_node();\n     }\n \n-    pub fn error(&mut self, error: parser::ParseError, text_pos: TextSize) {\n-        self.errors.push(SyntaxError::new_at_offset(*error.0, text_pos));\n+    pub fn error(&mut self, error: String, text_pos: TextSize) {\n+        self.errors.push(SyntaxError::new_at_offset(error, text_pos));\n     }\n }"}]}