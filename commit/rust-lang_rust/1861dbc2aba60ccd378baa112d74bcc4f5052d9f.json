{"sha": "1861dbc2aba60ccd378baa112d74bcc4f5052d9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjFkYmMyYWJhNjBjY2QzNzhiYWExMTJkNzRiY2M0ZjUwNTJkOWY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-28T23:43:23Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-28T23:43:23Z"}, "message": "Update for changes in rustc master.", "tree": {"sha": "87534ae2ee72107a49b423b65f7dbf0a05643b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87534ae2ee72107a49b423b65f7dbf0a05643b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1861dbc2aba60ccd378baa112d74bcc4f5052d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1861dbc2aba60ccd378baa112d74bcc4f5052d9f", "html_url": "https://github.com/rust-lang/rust/commit/1861dbc2aba60ccd378baa112d74bcc4f5052d9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1861dbc2aba60ccd378baa112d74bcc4f5052d9f/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62294d0c427708f4452ac948baf30f666f8c6cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/62294d0c427708f4452ac948baf30f666f8c6cea", "html_url": "https://github.com/rust-lang/rust/commit/62294d0c427708f4452ac948baf30f666f8c6cea"}], "stats": {"total": 56, "additions": 46, "deletions": 10}, "files": [{"sha": "969a0fad4d0b5caf9c20fdd46edbc1b9056203b2", "filename": "src/interpreter.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1861dbc2aba60ccd378baa112d74bcc4f5052d9f/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1861dbc2aba60ccd378baa112d74bcc4f5052d9f/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=1861dbc2aba60ccd378baa112d74bcc4f5052d9f", "patch": "@@ -1,12 +1,13 @@\n use arena::TypedArena;\n+use rustc::infer;\n use rustc::middle::const_eval;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::infer;\n-use rustc::middle::subst::{self, Subst, Substs};\n-use rustc::middle::traits;\n-use rustc::middle::ty::{self, TyCtxt};\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n+use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n@@ -195,8 +196,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n             -> EvalResult<TerminatorTarget> {\n-        use rustc::mir::repr::Terminator::*;\n-        let target = match *terminator {\n+        use rustc::mir::repr::TerminatorKind::*;\n+        let target = match terminator.kind {\n             Return => TerminatorTarget::Return,\n \n             Goto { target } => TerminatorTarget::Block(target),\n@@ -632,7 +633,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Slice { .. } => unimplemented!(),\n-            InlineAsm(_) => unimplemented!(),\n+            InlineAsm { .. } => unimplemented!(),\n         }\n \n         Ok(())\n@@ -973,7 +974,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n-        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables);\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n         let obligation = traits::Obligation::new(\n@@ -997,7 +998,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n     /// Trait method, which has to be resolved to an impl method.\n     pub fn trait_method(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n-            -> (DefId, &'tcx Substs<'tcx>) {\n+        -> (DefId, &'tcx Substs<'tcx>)\n+    {\n         let method_item = self.tcx.impl_or_trait_item(def_id);\n         let trait_id = method_item.container().id();\n         let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n@@ -1009,7 +1011,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 // and those from the method:\n                 let impl_substs = vtable_impl.substs.with_method_from(substs);\n                 let substs = self.tcx.mk_substs(impl_substs);\n-                let mth = self.tcx.get_impl_method(impl_did, substs, mname);\n+                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n \n                 (mth.method.def_id, mth.substs)\n             }\n@@ -1072,6 +1074,40 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct ImplMethod<'tcx> {\n+    pub method: Rc<ty::Method<'tcx>>,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub is_provided: bool,\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub fn get_impl_method<'tcx>(\n+    tcx: &TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+    name: ast::Name,\n+) -> ImplMethod<'tcx> {\n+    assert!(!substs.types.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+\n+    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            ImplMethod {\n+                method: node_item.item,\n+                substs: traits::translate_substs(&infcx, impl_def_id, substs, node_item.node),\n+                is_provided: node_item.node.is_from_trait(),\n+            }\n+        }\n+        None => {\n+            tcx.sess.bug(&format!(\"method {:?} not found in {:?}\", name, impl_def_id))\n+        }\n+    }\n+}\n+\n pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n     /// Print the given allocation and all allocations it depends on.\n     fn print_allocation_tree(memory: &Memory, alloc_id: memory::AllocId) {"}]}