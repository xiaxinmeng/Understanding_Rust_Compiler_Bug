{"sha": "5da0d415b66733f9a146bbdd6c6cce81430e77c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYTBkNDE1YjY2NzMzZjlhMTQ2YmJkZDZjNmNjZTgxNDMwZTc3YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-28T03:57:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-28T03:57:07Z"}, "message": "Auto merge of #26601 - alexcrichton:xp, r=brson\n\nThis series of commits (currently rebased on https://github.com/rust-lang/rust/pull/26569 to avoid conflicts) adds support for the standard library to run on Windows XP. The main motivation behind this PR is that to enable any Rust code in Firefox we need to support Windows XP.\r\n\r\nThis PR doesn't yet intend to be a move to make Windows XP an officially supported platform, but instead simply get Rust code running on it. APIs like condition variables and RWLocks will immediately panic currently on XP, and it's unclear if that story wants to change much. Additionally, we may bind APIs like IOCP which aren't available on XP and would be *very* difficult to provide a fallback implementation. Essentially this PR enables running Rust on XP, but you still have to be careful to avoid non-XP portions of the standard library.\r\n\r\nThe major components of this PR are:\r\n\r\n* Support for a new `i686-pc-windows-msvc` triple. This primarily involves a lot of build system hackery, but there are also a number of floating point functions which had to get switched up a bit.\r\n* All APIs not available on Windows are now accessed through our dynamic-detection mechanism\r\n* Mutexes on Windows were rewritten to use SRWLOCK as an optimization but can fall back to CRITICAL_SECTION.", "tree": {"sha": "538dbf67a23dbd8297576319f4bb0011bb633a65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/538dbf67a23dbd8297576319f4bb0011bb633a65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5da0d415b66733f9a146bbdd6c6cce81430e77c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5da0d415b66733f9a146bbdd6c6cce81430e77c2", "html_url": "https://github.com/rust-lang/rust/commit/5da0d415b66733f9a146bbdd6c6cce81430e77c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5da0d415b66733f9a146bbdd6c6cce81430e77c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa2185e0babe71699b2c372f8399c27effecd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa2185e0babe71699b2c372f8399c27effecd92", "html_url": "https://github.com/rust-lang/rust/commit/8fa2185e0babe71699b2c372f8399c27effecd92"}, {"sha": "10b103af48368c5df644fa61dc417a36083922c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b103af48368c5df644fa61dc417a36083922c8", "html_url": "https://github.com/rust-lang/rust/commit/10b103af48368c5df644fa61dc417a36083922c8"}], "stats": {"total": 998, "additions": 677, "deletions": 321}, "files": [{"sha": "5d4a017b6fbfaa8f9624dd5f1c76dc7b975b7abb", "filename": "configure", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -1114,7 +1114,7 @@ do\n             fi\n             ;;\n \n-        x86_64-*-msvc)\n+        *-msvc)\n             # Currently the build system is not configured to build jemalloc\n             # with MSVC, so we omit this optional dependency.\n             step_msg \"targeting MSVC, disabling jemalloc\"\n@@ -1154,22 +1154,45 @@ do\n             CFG_MSVC_ROOT=$(echo \"$install\" | grep InstallDir | sed 's/.*REG_SZ[ ]*//')\n             CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n             CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n-            CFG_MSVC_CL=\"${CFG_MSVC_ROOT}/VC/bin/amd64/cl.exe\"\n-            CFG_MSVC_LIB=\"${CFG_MSVC_ROOT}/VC/bin/amd64/lib.exe\"\n-            CFG_MSVC_LINK=\"${CFG_MSVC_ROOT}/VC/bin/amd64/link.exe\"\n+            putvar CFG_MSVC_ROOT\n+\n+            case $i in\n+                x86_64-*)\n+                    bits=x86_64\n+                    msvc_part=amd64\n+                    ;;\n+                i686-*)\n+                    bits=i386\n+                    msvc_part=\n+                    ;;\n+                *)\n+                    err \"can only target x86 targets for MSVC\"\n+                    ;;\n+            esac\n+            bindir=\"${CFG_MSVC_ROOT}/VC/bin\"\n+            if [ ! -z \"$msvc_part\" ]; then\n+                bindir=\"$bindir/$msvc_part\"\n+            fi\n+            eval CFG_MSVC_BINDIR_$bits=\"\\\"$bindir\\\"\"\n+            eval CFG_MSVC_CL_$bits=\"\\\"$bindir/cl.exe\\\"\"\n+            eval CFG_MSVC_LIB_$bits=\"\\\"$bindir/lib.exe\\\"\"\n+            eval CFG_MSVC_LINK_$bits=\"\\\"$bindir/link.exe\\\"\"\n \n             vcvarsall=\"${CFG_MSVC_ROOT}/VC/vcvarsall.bat\"\n-            CFG_MSVC_INCLUDE_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %INCLUDE%\")\n+            include_path=$(cmd /c \"\\\"$vcvarsall\\\" $msvc_part && cmd /c echo %INCLUDE%\")\n             need_ok \"failed to learn about MSVC's INCLUDE\"\n-            CFG_MSVC_LIB_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %LIB%\")\n+            lib_path=$(cmd /c \"\\\"$vcvarsall\\\" $msvc_part && cmd /c echo %LIB%\")\n             need_ok \"failed to learn about MSVC's LIB\"\n \n-            putvar CFG_MSVC_ROOT\n-            putvar CFG_MSVC_CL\n-            putvar CFG_MSVC_LIB\n-            putvar CFG_MSVC_LINK\n-            putvar CFG_MSVC_INCLUDE_PATH\n-            putvar CFG_MSVC_LIB_PATH\n+            eval CFG_MSVC_INCLUDE_PATH_${bits}=\"\\\"$include_path\\\"\"\n+            eval CFG_MSVC_LIB_PATH_${bits}=\"\\\"$lib_path\\\"\"\n+\n+            putvar CFG_MSVC_BINDIR_${bits}\n+            putvar CFG_MSVC_CL_${bits}\n+            putvar CFG_MSVC_LIB_${bits}\n+            putvar CFG_MSVC_LINK_${bits}\n+            putvar CFG_MSVC_INCLUDE_PATH_${bits}\n+            putvar CFG_MSVC_LIB_PATH_${bits}\n             ;;\n \n         *)\n@@ -1408,8 +1431,19 @@ do\n \n         msg \"configuring LLVM with:\"\n         msg \"$CMAKE_ARGS\"\n+        case \"$t\" in\n+            x86_64-*)\n+                generator=\"Visual Studio 12 2013 Win64\"\n+                ;;\n+            i686-*)\n+                generator=\"Visual Studio 12 2013\"\n+                ;;\n+            *)\n+                err \"can only build LLVM for x86 platforms\"\n+                ;;\n+        esac\n         (cd $LLVM_BUILD_DIR && \"$CFG_CMAKE\" $CFG_LLVM_SRC_DIR \\\n-                                            -G \"Visual Studio 12 2013 Win64\" \\\n+                                            -G \"$generator\" \\\n                                             $CMAKE_ARGS)\n         need_ok \"LLVM cmake configure failed\"\n     fi"}, {"sha": "bb1280688a7168dd96f5a66025e080ab68fe117f", "filename": "mk/cfg/i686-pc-windows-msvc.mk", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fcfg%2Fi686-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fcfg%2Fi686-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-msvc.mk?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -0,0 +1,29 @@\n+# i686-pc-windows-msvc configuration\n+CC_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+LINK_i686-pc-windows-msvc=\"$(CFG_MSVC_LINK_i386)\" -nologo\n+CXX_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+CPP_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+AR_i686-pc-windows-msvc=\"$(CFG_MSVC_LIB_i386)\" -nologo\n+CFG_LIB_NAME_i686-pc-windows-msvc=$(1).dll\n+CFG_STATIC_LIB_NAME_i686-pc-windows-msvc=$(1).lib\n+CFG_LIB_GLOB_i686-pc-windows-msvc=$(1)-*.{dll,lib}\n+CFG_LIB_DSYM_GLOB_i686-pc-windows-msvc=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_i686-pc-windows-msvc :=\n+CFG_GCCISH_CFLAGS_i686-pc-windows-msvc := -MD\n+CFG_GCCISH_CXXFLAGS_i686-pc-windows-msvc := -MD\n+CFG_GCCISH_LINK_FLAGS_i686-pc-windows-msvc :=\n+CFG_GCCISH_DEF_FLAG_i686-pc-windows-msvc :=\n+CFG_LLC_FLAGS_i686-pc-windows-msvc :=\n+CFG_INSTALL_NAME_i686-pc-windows-msvc =\n+CFG_EXE_SUFFIX_i686-pc-windows-msvc := .exe\n+CFG_WINDOWSY_i686-pc-windows-msvc := 1\n+CFG_UNIXY_i686-pc-windows-msvc :=\n+CFG_LDPATH_i686-pc-windows-msvc :=\n+CFG_RUN_i686-pc-windows-msvc=$(2)\n+CFG_RUN_TARG_i686-pc-windows-msvc=$(call CFG_RUN_i686-pc-windows-msvc,,$(2))\n+CFG_GNU_TRIPLE_i686-pc-windows-msvc := i686-pc-win32\n+\n+# All windows nightiles are currently a GNU triple, so this MSVC triple is not\n+# bootstrapping from itself. This is relevant during stage0, and other parts of\n+# the build system take this into account.\n+BOOTSTRAP_FROM_i686-pc-windows-msvc := i686-pc-windows-gnu"}, {"sha": "6f12836f05624fd52561fb585a0d21d2517ad33f", "filename": "mk/cfg/x86_64-pc-windows-msvc.mk", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -1,9 +1,9 @@\n # x86_64-pc-windows-msvc configuration\n-CC_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-LINK_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LINK)\" -nologo\n-CXX_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-CPP_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-AR_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LIB)\" -nologo\n+CC_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+LINK_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LINK_x86_64)\" -nologo\n+CXX_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+CPP_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+AR_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LIB_x86_64)\" -nologo\n CFG_LIB_NAME_x86_64-pc-windows-msvc=$(1).dll\n CFG_STATIC_LIB_NAME_x86_64-pc-windows-msvc=$(1).lib\n CFG_LIB_GLOB_x86_64-pc-windows-msvc=$(1)-*.{dll,lib}"}, {"sha": "60fe22cb32ee695a4a749d0af0a677b727a2cf0a", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -239,23 +239,6 @@ endef\n $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call CFG_MAKE_TOOLCHAIN,$(target))))\n \n-# These two environment variables are scraped by the `./configure` script and\n-# are necessary for `cl.exe` to find standard headers (the INCLUDE variable) and\n-# for `link.exe` to find standard libraries (the LIB variable).\n-ifdef CFG_MSVC_INCLUDE_PATH\n-export INCLUDE := $(CFG_MSVC_INCLUDE_PATH)\n-endif\n-ifdef CFG_MSVC_LIB_PATH\n-export LIB := $(CFG_MSVC_LIB_PATH)\n-endif\n-\n-# Unfortunately `link.exe` is also a program in `/usr/bin` on MinGW installs,\n-# but it's not the one that we want. As a result we make sure that our detected\n-# `link.exe` shows up in PATH first.\n-ifdef CFG_MSVC_LINK\n-export PATH := $(CFG_MSVC_ROOT)/VC/bin/amd64:$(PATH)\n-endif\n-\n # There are more comments about this available in the target specification for\n # Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n # instead of `lib.exe` for assembling archives, so we need to inject this custom\n@@ -307,3 +290,4 @@ endef\n \n $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call ADD_RUSTC_LLVM_DEF_TO_MSVC,$(target))))\n+"}, {"sha": "c70f9e8a37addfd80a78855c85de180943602719", "filename": "mk/rt.mk", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -55,7 +55,11 @@ NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n ifeq ($$(findstring msvc,$(1)),msvc)\n+ifeq ($$(findstring i686,$(1)),i686)\n+NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_32.ll\n+else\n NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_64.ll\n+endif\n else\n NATIVE_DEPS_rustrt_native_$(1) += rust_try.ll\n endif\n@@ -93,6 +97,17 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.S $$(MKFILE_DEPS) \\\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n+\n+# On MSVC targets the compiler's default include path (e.g. where to find system\n+# headers) is specified by the INCLUDE environment variable. This may not be set\n+# so the ./configure script scraped the relevant values and this is the location\n+# that we put them into cl.exe's environment.\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+$$(RT_OUTPUT_DIR_$(1))/%.o: \\\n+\texport INCLUDE := $$(CFG_MSVC_INCLUDE_PATH_$$(HOST_$(1)))\n+$(1)/rustllvm/%.o: \\\n+\texport INCLUDE := $$(CFG_MSVC_INCLUDE_PATH_$$(HOST_$(1)))\n+endif\n endef\n \n $(foreach target,$(CFG_TARGET),$(eval $(call NATIVE_LIBRARIES,$(target))))\n@@ -240,8 +255,12 @@ COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1))\n ifeq ($$(findstring msvc,$(1)),msvc)\n COMPRT_CC_$(1) := gcc\n COMPRT_AR_$(1) := ar\n+ifeq ($$(findstring i686,$(1)),i686)\n+COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1)) -m32\n+else\n COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1)) -m64\n endif\n+endif\n \n $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: compiler-rt)"}, {"sha": "c398950965f54765968d26d5630d0836d4e7a04e", "filename": "mk/target.mk", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -220,3 +220,40 @@ $(foreach target,$(CFG_TARGET), \\\n  $(foreach crate,$(CRATES), \\\n   $(foreach tool,$(NATIVE_TOOL_DEPS_$(crate)_T_$(target)), \\\n    $(eval $(call MOVE_TOOLS_TO_SNAPSHOT_HOST_DIR,0,$(target),$(BOOTSTRAP_FROM_$(target)),$(crate),$(tool))))))\n+\n+# For MSVC targets we need to set up some environment variables for the linker\n+# to work correctly when building Rust crates. These two variables are:\n+#\n+# - LIB tells the linker the default search path for finding system libraries,\n+#   for example kernel32.dll\n+# - PATH needs to be modified to ensure that MSVC's link.exe is first in the\n+#   path instead of MinGW's /usr/bin/link.exe (entirely unrelated)\n+#\n+# The values for these variables are detected by the configure script.\n+define SETUP_LIB_MSVC_ENV_VARS\n+ifeq ($$(findstring msvc,$(2)),msvc)\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n+\texport LIB := $$(CFG_MSVC_LIB_PATH_$$(HOST_$(2)))\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n+\texport PATH := $$(CFG_MSVC_BINDIR_$$(HOST_$(2))):$$(PATH)\n+endif\n+endef\n+define SETUP_TOOL_MSVC_ENV_VARS\n+ifeq ($$(findstring msvc,$(2)),msvc)\n+$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n+\texport LIB := $$(CFG_MSVC_LIB_PATH_$$(HOST_$(2)))\n+$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n+\texport PATH := $$(CFG_MSVC_BINDIR_$$(HOST_$(2))):$$(PATH)\n+endif\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach stage,$(STAGES), \\\n+   $(foreach crate,$(CRATES), \\\n+    $(eval $(call SETUP_LIB_MSVC_ENV_VARS,$(stage),$(target),$(host),$(crate)))))))\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach stage,$(STAGES), \\\n+   $(foreach tool,$(TOOLS), \\\n+    $(eval $(call SETUP_TOOL_MSVC_ENV_VARS,$(stage),$(target),$(host),$(tool)))))))"}, {"sha": "c8f95a3672d4a3d3e66cb821cd927f85fd117e80", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -215,13 +215,37 @@ impl Float for f32 {\n     /// Rounds towards minus infinity.\n     #[inline]\n     fn floor(self) -> f32 {\n-        unsafe { intrinsics::floorf32(self) }\n+        return floorf(self);\n+\n+        // On MSVC LLVM will lower many math intrinsics to a call to the\n+        // corresponding function. On MSVC, however, many of these functions\n+        // aren't actually available as symbols to call, but rather they are all\n+        // `static inline` functions in header files. This means that from a C\n+        // perspective it's \"compatible\", but not so much from an ABI\n+        // perspective (which we're worried about).\n+        //\n+        // The inline header functions always just cast to a f64 and do their\n+        // operation, so we do that here as well, but only for MSVC targets.\n+        //\n+        // Note that there are many MSVC-specific float operations which\n+        // redirect to this comment, so `floorf` is just one case of a missing\n+        // function on MSVC, but there are many others elsewhere.\n+        #[cfg(target_env = \"msvc\")]\n+        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n     }\n \n     /// Rounds towards plus infinity.\n     #[inline]\n     fn ceil(self) -> f32 {\n-        unsafe { intrinsics::ceilf32(self) }\n+        return ceilf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n     }\n \n     /// Rounds to nearest integer. Rounds half-way cases away from zero.\n@@ -299,7 +323,13 @@ impl Float for f32 {\n \n     #[inline]\n     fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n+        return powf(self, n);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n     }\n \n     #[inline]\n@@ -317,7 +347,13 @@ impl Float for f32 {\n     /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f32 {\n-        unsafe { intrinsics::expf32(self) }\n+        return expf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n     }\n \n     /// Returns 2 raised to the power of the number.\n@@ -329,7 +365,13 @@ impl Float for f32 {\n     /// Returns the natural logarithm of the number.\n     #[inline]\n     fn ln(self) -> f32 {\n-        unsafe { intrinsics::logf32(self) }\n+        return logf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -345,7 +387,13 @@ impl Float for f32 {\n     /// Returns the base 10 logarithm of the number.\n     #[inline]\n     fn log10(self) -> f32 {\n-        unsafe { intrinsics::log10f32(self) }\n+        return log10f(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n     }\n \n     /// Converts to degrees, assuming the number is in radians."}, {"sha": "9a22fe3a493f12eba582c940e79833d5f2afd7c7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -419,26 +419,40 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Rem for $t {\n-            type Output = $t;\n+rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n-            #[inline]\n-            fn rem(self, other: $t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(self, other) }\n-            }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f32 {\n+    type Output = f32;\n+\n+    // see notes in `core::f32::Float::floor`\n+    #[inline]\n+    #[cfg(target_env = \"msvc\")]\n+    fn rem(self, other: f32) -> f32 {\n+        (self as f64).rem(other as f64) as f32\n+    }\n \n-        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    #[inline]\n+    #[cfg(not(target_env = \"msvc\"))]\n+    fn rem(self, other: f32) -> f32 {\n+        extern { fn fmodf(a: f32, b: f32) -> f32; }\n+        unsafe { fmodf(self, other) }\n     }\n }\n \n-rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n-rem_float_impl! { f32, fmodf }\n-rem_float_impl! { f64, fmod }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f64 {\n+    type Output = f64;\n+\n+    #[inline]\n+    fn rem(self, other: f64) -> f64 {\n+        extern { fn fmod(a: f64, b: f64) -> f64; }\n+        unsafe { fmod(self, other) }\n+    }\n+}\n+\n+forward_ref_binop! { impl Rem, rem for f64, f64 }\n+forward_ref_binop! { impl Rem, rem for f32, f32 }\n \n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///"}, {"sha": "d71aa1526660e13846828924fa93ee0978902fa1", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::windows_msvc_base::opts();\n+    base.cpu = \"i686\".to_string();\n+\n+    Target {\n+        data_layout: \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string(),\n+        llvm_target: \"i686-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "a42f861d19056d6d55d00ec613d243ede9a58693", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -381,7 +381,8 @@ impl Target {\n             x86_64_pc_windows_gnu,\n             i686_pc_windows_gnu,\n \n-            x86_64_pc_windows_msvc\n+            x86_64_pc_windows_msvc,\n+            i686_pc_windows_msvc\n         );\n \n "}, {"sha": "a17d121e60a2a834c4928480d6d2d9191ec6d962", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -263,7 +263,7 @@ mod dl {\n     use sys::os;\n     use os::windows::prelude::*;\n     use ptr;\n-    use sys::c::compat::kernel32::SetThreadErrorMode;\n+    use sys::c::SetThreadErrorMode;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog."}, {"sha": "c2fb2fa417598a0bf0ef620403310c582ebabfef", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -18,6 +18,7 @@\n use prelude::v1::*;\n \n use core::num;\n+#[cfg(not(target_env = \"msvc\"))]\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n@@ -33,12 +34,7 @@ mod cmath {\n     use libc::{c_float, c_int};\n \n     extern {\n-        pub fn acosf(n: c_float) -> c_float;\n-        pub fn asinf(n: c_float) -> c_float;\n-        pub fn atanf(n: c_float) -> c_float;\n-        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n         pub fn cbrtf(n: c_float) -> c_float;\n-        pub fn coshf(n: c_float) -> c_float;\n         pub fn erff(n: c_float) -> c_float;\n         pub fn erfcf(n: c_float) -> c_float;\n         pub fn expm1f(n: c_float) -> c_float;\n@@ -51,32 +47,77 @@ mod cmath {\n         pub fn log1pf(n: c_float) -> c_float;\n         pub fn ilogbf(n: c_float) -> c_int;\n         pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;\n-        pub fn sinhf(n: c_float) -> c_float;\n-        pub fn tanf(n: c_float) -> c_float;\n-        pub fn tanhf(n: c_float) -> c_float;\n         pub fn tgammaf(n: c_float) -> c_float;\n \n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgammaf_r\")]\n         pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"_hypotf\")]\n         pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+    }\n \n-        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n+    // See the comments in `core::float::Float::floor` for why MSVC is special\n+    // here.\n+    #[cfg(not(target_env = \"msvc\"))]\n+    extern {\n+        pub fn acosf(n: c_float) -> c_float;\n+        pub fn asinf(n: c_float) -> c_float;\n+        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n+        pub fn atanf(n: c_float) -> c_float;\n+        pub fn coshf(n: c_float) -> c_float;\n         pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n-        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n         pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n+        pub fn sinhf(n: c_float) -> c_float;\n+        pub fn tanf(n: c_float) -> c_float;\n+        pub fn tanhf(n: c_float) -> c_float;\n     }\n \n-    #[cfg(all(windows, target_env = \"msvc\"))]\n-    pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n-        f64::ldexp(x as f64, n as isize) as c_float\n-    }\n+    #[cfg(target_env = \"msvc\")]\n+    pub use self::shims::*;\n+    #[cfg(target_env = \"msvc\")]\n+    mod shims {\n+        use libc::{c_float, c_int};\n+\n+        pub unsafe fn acosf(n: c_float) -> c_float {\n+            f64::acos(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn asinf(n: c_float) -> c_float {\n+            f64::asin(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn atan2f(n: c_float, b: c_float) -> c_float {\n+            f64::atan2(n as f64, b as f64) as c_float\n+        }\n+\n+        pub unsafe fn atanf(n: c_float) -> c_float {\n+            f64::atan(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn coshf(n: c_float) -> c_float {\n+            f64::cosh(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n+            let (a, b) = f64::frexp(x as f64);\n+            *value = b as c_int;\n+            a as c_float\n+        }\n+\n+        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n+            f64::ldexp(x as f64, n as isize) as c_float\n+        }\n+\n+        pub unsafe fn sinhf(n: c_float) -> c_float {\n+            f64::sinh(n as f64) as c_float\n+        }\n \n-    #[cfg(all(windows, target_env = \"msvc\"))]\n-    pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n-        let (a, b) = f64::frexp(x as f64);\n-        *value = b as c_int;\n-        a as c_float\n+        pub unsafe fn tanf(n: c_float) -> c_float {\n+            f64::tan(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn tanhf(n: c_float) -> c_float {\n+            f64::tanh(n as f64) as c_float\n+        }\n     }\n }\n \n@@ -761,7 +802,13 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin(self) -> f32 {\n-        unsafe { intrinsics::sinf32(self) }\n+        return sinf(self);\n+\n+        // see notes in `core::f32::Float::floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn sinf(f: f32) -> f32 { (f as f64).sin() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn sinf(f: f32) -> f32 { unsafe { intrinsics::sinf32(f) } }\n     }\n \n     /// Computes the cosine of a number (in radians).\n@@ -778,7 +825,13 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn cos(self) -> f32 {\n-        unsafe { intrinsics::cosf32(self) }\n+        return cosf(self);\n+\n+        // see notes in `core::f32::Float::floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn cosf(f: f32) -> f32 { (f as f64).cos() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn cosf(f: f32) -> f32 { unsafe { intrinsics::cosf32(f) } }\n     }\n \n     /// Computes the tangent of a number (in radians)."}, {"sha": "7f89ea979391e251d3517090dd73ab8ff4e7c2f8", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 96, "deletions": 115, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -13,6 +13,9 @@\n #![allow(bad_style, dead_code, overflowing_literals)]\n \n use libc;\n+use libc::{c_uint, c_ulong};\n+use libc::{DWORD, BOOL, BOOLEAN, ERROR_CALL_NOT_IMPLEMENTED, LPVOID, HANDLE};\n+use libc::{LPCWSTR, LONG};\n \n pub use self::GET_FILEEX_INFO_LEVELS::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n@@ -240,7 +243,32 @@ pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub PathBuffer: libc::WCHAR,\n }\n \n+pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n+pub type PSRWLOCK = *mut SRWLOCK;\n+pub type ULONG = c_ulong;\n+pub type ULONG_PTR = c_ulong;\n+\n+#[repr(C)]\n+pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct SRWLOCK { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct CRITICAL_SECTION {\n+    CriticalSectionDebug: LPVOID,\n+    LockCount: LONG,\n+    RecursionCount: LONG,\n+    OwningThread: HANDLE,\n+    LockSemaphore: HANDLE,\n+    SpinCount: ULONG_PTR\n+}\n+\n+pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n+    ptr: 0 as *mut _,\n+};\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n+\n #[link(name = \"ws2_32\")]\n+#[link(name = \"userenv\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;\n@@ -295,115 +323,13 @@ extern \"system\" {\n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n     pub fn CancelIoEx(hFile: libc::HANDLE,\n                       lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n-}\n-\n-pub mod compat {\n-    use prelude::v1::*;\n \n-    use ffi::CString;\n-    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-    use sync::atomic::{AtomicUsize, Ordering};\n+    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n+    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n-    extern \"system\" {\n-        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n-    }\n-\n-    fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                  fallback: usize) -> usize {\n-        let mut module: Vec<u16> = module.utf16_units().collect();\n-        module.push(0);\n-        let symbol = CString::new(symbol).unwrap();\n-        let func = unsafe {\n-            let handle = GetModuleHandleW(module.as_ptr());\n-            GetProcAddress(handle, symbol.as_ptr()) as usize\n-        };\n-        let value = if func == 0 {fallback} else {func};\n-        ptr.store(value, Ordering::SeqCst);\n-        value\n-    }\n-\n-    /// Macro for creating a compatibility fallback for a Windows function\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// compat_fn!(adll32::SomeFunctionW(_arg: LPCWSTR) {\n-    ///     // Fallback implementation\n-    /// })\n-    /// ```\n-    ///\n-    /// Note that arguments unused by the fallback implementation should not be\n-    /// called `_` as they are used to be passed to the real function if\n-    /// available.\n-    macro_rules! compat_fn {\n-        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n-                                      -> $rettype:ty { $fallback:expr }) => (\n-            #[inline(always)]\n-            pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use sync::atomic::{AtomicUsize, Ordering};\n-                use mem;\n-\n-                static PTR: AtomicUsize = AtomicUsize::new(0);\n-\n-                fn load() -> usize {\n-                    ::sys::c::compat::store_func(&PTR,\n-                                                 stringify!($module),\n-                                                 stringify!($symbol),\n-                                                 fallback as usize)\n-                }\n-\n-                extern \"system\" fn fallback($($argname: $argtype),*)\n-                                            -> $rettype { $fallback }\n-\n-                let addr = match PTR.load(Ordering::SeqCst) {\n-                    0 => load(),\n-                    n => n,\n-                };\n-                let f: extern \"system\" fn($($argtype),*) -> $rettype =\n-                    mem::transmute(addr);\n-                f($($argname),*)\n-            }\n-        )\n-    }\n-\n-    /// Compatibility layer for functions in `kernel32.dll`\n-    ///\n-    /// Latest versions of Windows this is needed for:\n-    ///\n-    /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n-    /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n-    pub mod kernel32 {\n-        use libc::c_uint;\n-        use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n-        use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-        use sys::c::SetLastError;\n-\n-        compat_fn! {\n-            kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n-                                          _lpTargetFileName: LPCWSTR,\n-                                          _dwFlags: DWORD) -> BOOLEAN {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-\n-        compat_fn! {\n-            kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                                _lpszFilePath: LPCWSTR,\n-                                                _cchFilePath: DWORD,\n-                                                _dwFlags: DWORD) -> DWORD {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-\n-        compat_fn! {\n-            kernel32::SetThreadErrorMode(_dwNewMode: DWORD, _lpOldMode: *mut DWORD) -> c_uint {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-    }\n-}\n-\n-extern \"system\" {\n     // FIXME - pInputControl should be PCONSOLE_READCONSOLE_CONTROL\n     pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,\n                         lpBuffer: libc::LPVOID,\n@@ -447,10 +373,6 @@ extern \"system\" {\n                        lpCreationTime: *const libc::FILETIME,\n                        lpLastAccessTime: *const libc::FILETIME,\n                        lpLastWriteTime: *const libc::FILETIME) -> libc::BOOL;\n-    pub fn SetFileInformationByHandle(hFile: libc::HANDLE,\n-                    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-                    lpFileInformation: libc::LPVOID,\n-                    dwBufferSize: libc::DWORD) -> libc::BOOL;\n     pub fn GetTempPathW(nBufferLength: libc::DWORD,\n                         lpBuffer: libc::LPCWSTR) -> libc::DWORD;\n     pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,\n@@ -483,11 +405,70 @@ extern \"system\" {\n     pub fn SwitchToThread() -> libc::BOOL;\n     pub fn Sleep(dwMilliseconds: libc::DWORD);\n     pub fn GetProcessId(handle: libc::HANDLE) -> libc::DWORD;\n-}\n-\n-#[link(name = \"userenv\")]\n-extern \"system\" {\n     pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,\n                                     lpProfileDir: libc::LPCWSTR,\n                                     lpcchSize: *mut libc::DWORD) -> libc::BOOL;\n }\n+\n+// Functions that aren't available on Windows XP, but we still use them and just\n+// provide some form of a fallback implementation.\n+compat_fn! {\n+    kernel32:\n+\n+    pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+                               _lpTargetFileName: LPCWSTR,\n+                               _dwFlags: DWORD) -> BOOLEAN {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                     _lpszFilePath: LPCWSTR,\n+                                     _cchFilePath: DWORD,\n+                                     _dwFlags: DWORD) -> DWORD {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetThreadErrorMode(_dwNewMode: DWORD,\n+                              _lpOldMode: *mut DWORD) -> c_uint {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetFileInformationByHandle(_hFile: HANDLE,\n+                    _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+                    _lpFileInformation: LPVOID,\n+                    _dwBufferSize: DWORD) -> BOOL {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n+                                     SRWLock: PSRWLOCK,\n+                                     dwMilliseconds: DWORD,\n+                                     Flags: ULONG) -> BOOL {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n+                                 -> () {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n+                                    -> () {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN {\n+        panic!(\"rwlocks not available\")\n+    }\n+}"}, {"sha": "3a03b91f24ed3ba75a05db658ae9307f315d2c8c", "filename": "src/libstd/sys/windows/compat.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A \"compatibility layer\" for spanning XP and Windows 7\n+//!\n+//! The standard library currently binds many functions that are not available\n+//! on Windows XP, but we would also like to support building executables that\n+//! run on XP. To do this we specify all non-XP APIs as having a fallback\n+//! implementation to do something reasonable.\n+//!\n+//! This dynamic runtime detection of whether a function is available is\n+//! implemented with `GetModuleHandle` and `GetProcAddress` paired with a\n+//! static-per-function which caches the result of the first check. In this\n+//! manner we pay a semi-large one-time cost up front for detecting whether a\n+//! function is available but afterwards it's just a load and a jump.\n+\n+use prelude::v1::*;\n+\n+use ffi::CString;\n+use libc::{LPVOID, LPCWSTR, HMODULE, LPCSTR};\n+use sync::atomic::{AtomicUsize, Ordering};\n+\n+extern \"system\" {\n+    fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+    fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n+}\n+\n+pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n+    let mut module: Vec<u16> = module.utf16_units().collect();\n+    module.push(0);\n+    let symbol = CString::new(symbol).unwrap();\n+    unsafe {\n+        let handle = GetModuleHandleW(module.as_ptr());\n+        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n+            0 => None,\n+            n => Some(n),\n+        }\n+    }\n+}\n+\n+pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n+                  fallback: usize) -> usize {\n+    let value = lookup(module, symbol).unwrap_or(fallback);\n+    ptr.store(value, Ordering::SeqCst);\n+    value\n+}\n+\n+macro_rules! compat_fn {\n+    ($module:ident: $(\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n+                                  -> $rettype:ty {\n+            $($body:expr);*\n+        }\n+    )*) => ($(\n+        #[allow(unused_variables)]\n+        pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+            use sync::atomic::{AtomicUsize, Ordering};\n+            use mem;\n+            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n+\n+            static PTR: AtomicUsize = AtomicUsize::new(0);\n+\n+            fn load() -> usize {\n+                ::sys::compat::store_func(&PTR,\n+                                          stringify!($module),\n+                                          stringify!($symbol),\n+                                          fallback as usize)\n+            }\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n+                                               -> $rettype {\n+                $($body);*\n+            }\n+\n+            let addr = match PTR.load(Ordering::SeqCst) {\n+                0 => load(),\n+                n => n,\n+            };\n+            mem::transmute::<usize, F>(addr)($($argname),*)\n+        }\n+    )*)\n+}"}, {"sha": "04d62200e9bcc553777977cbe47171609972da6a", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -12,35 +12,35 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use libc::{self, DWORD};\n-use sys::os;\n+use sys::c;\n use sys::mutex::{self, Mutex};\n-use sys::sync as ffi;\n+use sys::os;\n use time::Duration;\n \n-pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n+pub struct Condvar { inner: UnsafeCell<c::CONDITION_VARIABLE> }\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { inner: UnsafeCell::new(ffi::CONDITION_VARIABLE_INIT) }\n+        Condvar { inner: UnsafeCell::new(c::CONDITION_VARIABLE_INIT) }\n     }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n-                                               mutex::raw(mutex),\n-                                               libc::INFINITE,\n-                                               0);\n+        let r = c::SleepConditionVariableSRW(self.inner.get(),\n+                                             mutex::raw(mutex),\n+                                             libc::INFINITE,\n+                                             0);\n         debug_assert!(r != 0);\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n-                                               mutex::raw(mutex),\n-                                               super::dur2timeout(dur),\n-                                               0);\n+        let r = c::SleepConditionVariableSRW(self.inner.get(),\n+                                             mutex::raw(mutex),\n+                                             super::dur2timeout(dur),\n+                                             0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;\n             debug_assert_eq!(os::errno() as usize, ERROR_TIMEOUT as usize);\n@@ -52,12 +52,12 @@ impl Condvar {\n \n     #[inline]\n     pub unsafe fn notify_one(&self) {\n-        ffi::WakeConditionVariable(self.inner.get())\n+        c::WakeConditionVariable(self.inner.get())\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-        ffi::WakeAllConditionVariable(self.inner.get())\n+        c::WakeAllConditionVariable(self.inner.get())\n     }\n \n     pub unsafe fn destroy(&self) {"}, {"sha": "36fabe72aa0c1f70fb5665bf653aabee9780f246", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -497,12 +497,11 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n-    use sys::c::compat::kernel32::CreateSymbolicLinkW;\n     let src = to_utf16(src);\n     let dst = to_utf16(dst);\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     try!(cvt(unsafe {\n-        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n+        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n     }));\n     Ok(())\n }\n@@ -565,14 +564,13 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n \n     let mut opts = OpenOptions::new();\n     opts.read(true);\n     let f = try!(File::open(p, &opts));\n     super::fill_utf16_buf(|buf, sz| unsafe {\n-        GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n-                                  libc::VOLUME_NAME_DOS)\n+        c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n+                                     libc::VOLUME_NAME_DOS)\n     }, |buf| {\n         PathBuf::from(OsString::from_wide(buf))\n     })"}, {"sha": "b6d080109df053d4290f0c5f19a1fac3678fe625", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -22,6 +22,8 @@ use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n \n+#[macro_use] pub mod compat;\n+\n pub mod backtrace;\n pub mod c;\n pub mod condvar;\n@@ -36,7 +38,6 @@ pub mod pipe;\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;\n-pub mod sync;\n pub mod thread;\n pub mod thread_local;\n pub mod time;"}, {"sha": "277c3d14c0ec5515e4a2396986ede72ac9cdae93", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 128, "deletions": 31, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -8,57 +8,154 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! System Mutexes\n+//!\n+//! The Windows implementation of mutexes is a little odd and it may not be\n+//! immediately obvious what's going on. The primary oddness is that SRWLock is\n+//! used instead of CriticalSection, and this is done because:\n+//!\n+//! 1. SRWLock is several times faster than CriticalSection according to\n+//!    benchmarks performed on both Windows 8 and Windows 7.\n+//!\n+//! 2. CriticalSection allows recursive locking while SRWLock deadlocks. The\n+//!    Unix implementation deadlocks so consistency is preferred. See #19962 for\n+//!    more details.\n+//!\n+//! 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n+//!    is there there are no guarantees of fairness.\n+//!\n+//! The downside of this approach, however, is that SRWLock is not available on\n+//! Windows XP, so we continue to have a fallback implementation where\n+//! CriticalSection is used and we keep track of who's holding the mutex to\n+//! detect recursive locks.\n+\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use sys::sync as ffi;\n use mem;\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sys::c;\n+use sys::compat;\n \n-pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n+pub struct Mutex {\n+    lock: AtomicUsize,\n+    held: UnsafeCell<bool>,\n+}\n \n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n-#[inline]\n-pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n-    m.inner.get()\n+#[derive(Clone, Copy)]\n+enum Kind {\n+    SRWLock = 1,\n+    CriticalSection = 2,\n }\n \n-// So you might be asking why we're using SRWLock instead of CriticalSection?\n-//\n-// 1. SRWLock is several times faster than CriticalSection according to\n-//    benchmarks performed on both Windows 8 and Windows 7.\n-//\n-// 2. CriticalSection allows recursive locking while SRWLock deadlocks. The Unix\n-//    implementation deadlocks so consistency is preferred. See #19962 for more\n-//    details.\n-//\n-// 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n-//    is there there are no guarantees of fairness.\n+#[inline]\n+pub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK {\n+    debug_assert!(mem::size_of::<c::SRWLOCK>() <= mem::size_of_val(&m.lock));\n+    &m.lock as *const _ as *mut _\n+}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+        Mutex {\n+            lock: AtomicUsize::new(0),\n+            held: UnsafeCell::new(false),\n+        }\n     }\n-    #[inline]\n     pub unsafe fn lock(&self) {\n-        ffi::AcquireSRWLockExclusive(self.inner.get())\n+        match kind() {\n+            Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),\n+            Kind::CriticalSection => {\n+                let re = self.remutex();\n+                (*re).lock();\n+                if !self.flag_locked() {\n+                    (*re).unlock();\n+                    panic!(\"cannot recursively lock a mutex\");\n+                }\n+            }\n+        }\n     }\n-    #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+        match kind() {\n+            Kind::SRWLock => c::TryAcquireSRWLockExclusive(raw(self)) != 0,\n+            Kind::CriticalSection => {\n+                let re = self.remutex();\n+                if !(*re).try_lock() {\n+                    false\n+                } else if self.flag_locked() {\n+                    true\n+                } else {\n+                    (*re).unlock();\n+                    false\n+                }\n+            }\n+        }\n     }\n-    #[inline]\n     pub unsafe fn unlock(&self) {\n-        ffi::ReleaseSRWLockExclusive(self.inner.get())\n+        *self.held.get() = false;\n+        match kind() {\n+            Kind::SRWLock => c::ReleaseSRWLockExclusive(raw(self)),\n+            Kind::CriticalSection => (*self.remutex()).unlock(),\n+        }\n     }\n-    #[inline]\n     pub unsafe fn destroy(&self) {\n-        // ...\n+        match kind() {\n+            Kind::SRWLock => {}\n+            Kind::CriticalSection => {\n+                match self.lock.load(Ordering::SeqCst) {\n+                    0 => {}\n+                    n => { Box::from_raw(n as *mut ReentrantMutex).destroy(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    unsafe fn remutex(&self) -> *mut ReentrantMutex {\n+        match self.lock.load(Ordering::SeqCst) {\n+            0 => {}\n+            n => return n as *mut _,\n+        }\n+        let mut re = Box::new(ReentrantMutex::uninitialized());\n+        re.init();\n+        let re = Box::into_raw(re);\n+        match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n+            0 => re,\n+            n => { Box::from_raw(re).destroy(); n as *mut _ }\n+        }\n+    }\n+\n+    unsafe fn flag_locked(&self) -> bool {\n+        if *self.held.get() {\n+            false\n+        } else {\n+            *self.held.get() = true;\n+            true\n+        }\n+\n     }\n }\n \n-pub struct ReentrantMutex { inner: UnsafeCell<ffi::CRITICAL_SECTION> }\n+fn kind() -> Kind {\n+    static KIND: AtomicUsize = AtomicUsize::new(0);\n+\n+    let val = KIND.load(Ordering::SeqCst);\n+    if val == Kind::SRWLock as usize {\n+        return Kind::SRWLock\n+    } else if val == Kind::CriticalSection as usize {\n+        return Kind::CriticalSection\n+    }\n+\n+    let ret = match compat::lookup(\"kernel32\", \"AcquireSRWLockExclusive\") {\n+        None => Kind::CriticalSection,\n+        Some(..) => Kind::SRWLock,\n+    };\n+    KIND.store(ret as usize, Ordering::SeqCst);\n+    return ret;\n+}\n+\n+pub struct ReentrantMutex { inner: UnsafeCell<c::CRITICAL_SECTION> }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n@@ -69,23 +166,23 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn init(&mut self) {\n-        ffi::InitializeCriticalSection(self.inner.get());\n+        c::InitializeCriticalSection(self.inner.get());\n     }\n \n     pub unsafe fn lock(&self) {\n-        ffi::EnterCriticalSection(self.inner.get());\n+        c::EnterCriticalSection(self.inner.get());\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::TryEnterCriticalSection(self.inner.get()) != 0\n+        c::TryEnterCriticalSection(self.inner.get()) != 0\n     }\n \n     pub unsafe fn unlock(&self) {\n-        ffi::LeaveCriticalSection(self.inner.get());\n+        c::LeaveCriticalSection(self.inner.get());\n     }\n \n     pub unsafe fn destroy(&self) {\n-        ffi::DeleteCriticalSection(self.inner.get());\n+        c::DeleteCriticalSection(self.inner.get());\n     }\n }"}, {"sha": "25865286db051aba32e4f60c33b191efc35cb00b", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -11,40 +11,40 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use sys::sync as ffi;\n+use sys::c;\n \n-pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }\n+pub struct RWLock { inner: UnsafeCell<c::SRWLOCK> }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+        RWLock { inner: UnsafeCell::new(c::SRWLOCK_INIT) }\n     }\n     #[inline]\n     pub unsafe fn read(&self) {\n-        ffi::AcquireSRWLockShared(self.inner.get())\n+        c::AcquireSRWLockShared(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        ffi::TryAcquireSRWLockShared(self.inner.get()) != 0\n+        c::TryAcquireSRWLockShared(self.inner.get()) != 0\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n-        ffi::AcquireSRWLockExclusive(self.inner.get())\n+        c::AcquireSRWLockExclusive(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+        c::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n     }\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        ffi::ReleaseSRWLockShared(self.inner.get())\n+        c::ReleaseSRWLockShared(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        ffi::ReleaseSRWLockExclusive(self.inner.get())\n+        c::ReleaseSRWLockExclusive(self.inner.get())\n     }\n \n     #[inline]"}, {"sha": "cf827848db5c99f0f70de6295220a007ecb4fb76", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da0d415b66733f9a146bbdd6c6cce81430e77c2/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=5da0d415b66733f9a146bbdd6c6cce81430e77c2", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rt::util::report_overflow;\n use core::prelude::*;\n-use ptr;\n-use mem;\n+\n+use libc::types::os::arch::extra::{LPVOID, DWORD, LONG};\n use libc;\n-use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n+use mem;\n+use ptr;\n+use rt::util::report_overflow;\n+use sys::c;\n use sys_common::stack;\n \n pub struct Handler {\n@@ -69,8 +71,12 @@ pub unsafe fn cleanup() {\n }\n \n pub unsafe fn make_handler() -> Handler {\n-    if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-        panic!(\"failed to reserve stack space for exception handling\");\n+    // This API isn't available on XP, so don't panic in that case and just pray\n+    // it works out ok.\n+    if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+        if libc::GetLastError() as u32 != libc::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n+            panic!(\"failed to reserve stack space for exception handling\");\n+        }\n     }\n \n     Handler { _data: 0 as *mut libc::c_void }\n@@ -103,5 +109,4 @@ extern \"system\" {\n     fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n                                    VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n                                   -> LPVOID;\n-    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n }"}, {"sha": "5410259540eaccbf5338c460a0c0c0add8a2a7c1", "filename": "src/libstd/sys/windows/sync.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8fa2185e0babe71699b2c372f8399c27effecd92/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa2185e0babe71699b2c372f8399c27effecd92/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=8fa2185e0babe71699b2c372f8399c27effecd92", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{BOOL, DWORD, LPVOID, LONG, HANDLE, c_ulong};\n-use libc::types::os::arch::extra::BOOLEAN;\n-\n-pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n-pub type PSRWLOCK = *mut SRWLOCK;\n-pub type ULONG = c_ulong;\n-pub type ULONG_PTR = c_ulong;\n-\n-#[repr(C)]\n-pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n-#[repr(C)]\n-pub struct SRWLOCK { pub ptr: LPVOID }\n-#[repr(C)]\n-pub struct CRITICAL_SECTION {\n-    CriticalSectionDebug: LPVOID,\n-    LockCount: LONG,\n-    RecursionCount: LONG,\n-    OwningThread: HANDLE,\n-    LockSemaphore: HANDLE,\n-    SpinCount: ULONG_PTR\n-}\n-\n-pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n-    ptr: 0 as *mut _,\n-};\n-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n-\n-extern \"system\" {\n-    // condition variables\n-    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n-                                     SRWLock: PSRWLOCK,\n-                                     dwMilliseconds: DWORD,\n-                                     Flags: ULONG) -> BOOL;\n-    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-\n-    // slim rwlocks\n-    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n-    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n-\n-    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n-    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-}"}]}