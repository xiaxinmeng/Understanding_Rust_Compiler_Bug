{"sha": "d1a242533392d4772c84ce2be80cf7fd40aa8be3", "node_id": "C_kwDOAAsO6NoAKGQxYTI0MjUzMzM5MmQ0NzcyYzg0Y2UyYmU4MGNmN2ZkNDBhYThiZTM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-20T12:36:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-20T12:36:03Z"}, "message": "Merge from rustc", "tree": {"sha": "cdeb9012fc4907fc9a04be5cd69ba8dc4110fe4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdeb9012fc4907fc9a04be5cd69ba8dc4110fe4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1a242533392d4772c84ce2be80cf7fd40aa8be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a242533392d4772c84ce2be80cf7fd40aa8be3", "html_url": "https://github.com/rust-lang/rust/commit/d1a242533392d4772c84ce2be80cf7fd40aa8be3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1a242533392d4772c84ce2be80cf7fd40aa8be3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a52c7507327eb6a4459a93f6f04653380471dedf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a52c7507327eb6a4459a93f6f04653380471dedf", "html_url": "https://github.com/rust-lang/rust/commit/a52c7507327eb6a4459a93f6f04653380471dedf"}, {"sha": "2f163554866e1b4b348811e9df6a4a753beb0abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f163554866e1b4b348811e9df6a4a753beb0abf", "html_url": "https://github.com/rust-lang/rust/commit/2f163554866e1b4b348811e9df6a4a753beb0abf"}], "stats": {"total": 3261, "additions": 2458, "deletions": 803}, "files": [{"sha": "7f857528c7c5c4ca8c1018827f0a504d5cb00a20", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -347,7 +347,12 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             }\n             TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n-                    if let mir::AssertKind::OverflowNeg(_) = *msg {\n+                    let overflow_not_to_check = match msg {\n+                        AssertKind::OverflowNeg(..) => true,\n+                        AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                        _ => false,\n+                    };\n+                    if overflow_not_to_check {\n                         let target = fx.get_block(*target);\n                         fx.bcx.ins().jump(target, &[]);\n                         continue;\n@@ -567,15 +572,7 @@ fn codegen_stmt<'tcx>(\n                     let lhs = codegen_operand(fx, &lhs_rhs.0);\n                     let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n-                    let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val =\n-                            crate::num::codegen_int_binop(fx, bin_op, lhs, rhs).load_scalar(fx);\n-                        let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n-                        CValue::by_val_pair(val, is_overflow, lval.layout())\n-                    } else {\n-                        crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs)\n-                    };\n-\n+                    let res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::UnaryOp(un_op, ref operand) => {"}, {"sha": "6feb3a7732e1295c8f65bb573b57cadca0ccda5c", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -493,20 +493,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         }\n-        sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-            intrinsic_args!(fx, args => (x, y); intrinsic);\n-\n-            assert_eq!(x.layout().ty, y.layout().ty);\n-            let bin_op = match intrinsic {\n-                sym::add_with_overflow => BinOp::Add,\n-                sym::sub_with_overflow => BinOp::Sub,\n-                sym::mul_with_overflow => BinOp::Mul,\n-                _ => unreachable!(),\n-            };\n-\n-            let res = crate::num::codegen_checked_int_binop(fx, bin_op, x, y);\n-            ret.write_cvalue(fx, res);\n-        }\n         sym::saturating_add | sym::saturating_sub => {\n             intrinsic_args!(fx, args => (lhs, rhs); intrinsic);\n "}, {"sha": "9cda24bab87d345820ee7ec1e62227062d180a87", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     ) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n-        match self.ty.kind() {\n+        match *self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);\n             }\n@@ -339,6 +339,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n             }\n+            // `dyn* Trait` has the same ABI as `*mut dyn Trait`\n+            ty::Dynamic(bounds, region, ty::DynStar) => {\n+                let ptr_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_dynamic(bounds, region, ty::Dyn));\n+                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n+            }\n             _ => {}\n         }\n "}, {"sha": "4e13d4dbcb7a4dbdbcf260218026ab762a222beb", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -39,7 +39,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, Size, VariantIdx};\n+use rustc_target::abi::{Align, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::time::{Duration, Instant};\n@@ -273,12 +273,13 @@ pub fn cast_to_dyn_star<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n         \"destination type must be a dyn*\"\n     );\n-    // FIXME(dyn-star): this is probably not the best way to check if this is\n-    // a pointer, and really we should ensure that the value is a suitable\n-    // pointer earlier in the compilation process.\n-    let src = match src_ty_and_layout.pointee_info_at(bx.cx(), Size::ZERO) {\n-        Some(_) => bx.ptrtoint(src, bx.cx().type_isize()),\n-        None => bx.bitcast(src, bx.type_isize()),\n+    // FIXME(dyn-star): We can remove this when all supported LLVMs use opaque ptrs only.\n+    let unit_ptr = bx.cx().type_ptr_to(bx.cx().type_struct(&[], false));\n+    let src = match bx.cx().type_kind(bx.cx().backend_type(src_ty_and_layout)) {\n+        TypeKind::Pointer => bx.pointercast(src, unit_ptr),\n+        TypeKind::Integer => bx.inttoptr(src, unit_ptr),\n+        // FIXME(dyn-star): We probably have to do a bitcast first, then inttoptr.\n+        kind => bug!(\"unexpected TypeKind for left-hand side of `dyn*` cast: {kind:?}\"),\n     };\n     (src, unsized_info(bx, src_ty_and_layout.ty, dst_ty, old_info))\n }"}, {"sha": "e105322a0b426eca9dcbae136b80fe9d6947e939", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -452,86 +452,84 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_abi) = match ty.kind() {\n-            // FIXME(eddyb) perhaps move some of this logic into\n-            // `Instance::resolve_drop_in_place`?\n-            ty::Dynamic(_, _, ty::Dyn) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn Trait)\n-                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n-                //                       args[0]    args[1]\n-                //\n-                // args = ( Data, Vtable )\n-                //                  |\n-                //                  v\n-                //                /-------\\\n-                //                | ...   |\n-                //                \\-------/\n-                //\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let vtable = args[1];\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            ty::Dynamic(_, _, ty::DynStar) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn* Trait)\n-                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n-                //\n-                // args = [ * ]\n-                //          |\n-                //          v\n-                //      ( Data, Vtable )\n-                //                |\n-                //                v\n-                //              /-------\\\n-                //              | ...   |\n-                //              \\-------/\n-                //\n-                //\n-                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n-                //\n-                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n-                // vtable = (*args[0]).1   // loads the vtable out\n-                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n-                //\n-                // SO THEN WE CAN USE THE ABOVE CODE.\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let data = args[0];\n-                let data_ty = bx.cx().backend_type(place.layout);\n-                let vtable_ptr =\n-                    bx.gep(data_ty, data, &[bx.cx().const_i32(0), bx.cx().const_i32(1)]);\n-                let vtable = bx.load(bx.type_i8p(), vtable_ptr, abi::Align::ONE);\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                debug!(\"args' = {:?}\", args);\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n-        };\n+        let (drop_fn, fn_abi) =\n+            match ty.kind() {\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                ty::Dynamic(_, _, ty::Dyn) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn Trait)\n+                    // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                    //                       args[0]    args[1]\n+                    //\n+                    // args = ( Data, Vtable )\n+                    //                  |\n+                    //                  v\n+                    //                /-------\\\n+                    //                | ...   |\n+                    //                \\-------/\n+                    //\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let vtable = args[1];\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, vtable, ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                ty::Dynamic(_, _, ty::DynStar) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn* Trait)\n+                    // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                    //\n+                    // args = [ * ]\n+                    //          |\n+                    //          v\n+                    //      ( Data, Vtable )\n+                    //                |\n+                    //                v\n+                    //              /-------\\\n+                    //              | ...   |\n+                    //              \\-------/\n+                    //\n+                    //\n+                    // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                    //\n+                    // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                    // vtable = (*args[0]).1   // loads the vtable out\n+                    // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                    //\n+                    // SO THEN WE CAN USE THE ABOVE CODE.\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let meta_ptr = place.project_field(bx, 1);\n+                    let meta = bx.load_operand(meta_ptr);\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    debug!(\"args' = {:?}\", args);\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, meta.immediate(), ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n+            };\n         helper.do_call(\n             self,\n             bx,\n@@ -565,11 +563,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        // NOTE: Unlike binops, negation doesn't have its own\n-        // checked operation, just a comparison with the minimum\n-        // value, so we have to check for the assert message.\n-        if !bx.check_overflow() {\n-            if let AssertKind::OverflowNeg(_) = *msg {\n+        if !bx.cx().check_overflow() {\n+            let overflow_not_to_check = match msg {\n+                AssertKind::OverflowNeg(..) => true,\n+                AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                _ => false,\n+            };\n+            if overflow_not_to_check {\n                 const_cond = Some(expected);\n             }\n         }"}, {"sha": "7af7fc92dbce2e0d3906927516d355d5231a5bf3", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -218,9 +218,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args[1].val.unaligned_volatile_store(bx, dst);\n                 return;\n             }\n-            sym::add_with_overflow\n-            | sym::sub_with_overflow\n-            | sym::mul_with_overflow\n             | sym::unchecked_div\n             | sym::unchecked_rem\n             | sym::unchecked_shl\n@@ -232,28 +229,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let ty = arg_tys[0];\n                 match int_type_width_signed(ty, bx.tcx()) {\n                     Some((_width, signed)) => match name {\n-                        sym::add_with_overflow\n-                        | sym::sub_with_overflow\n-                        | sym::mul_with_overflow => {\n-                            let op = match name {\n-                                sym::add_with_overflow => OverflowOp::Add,\n-                                sym::sub_with_overflow => OverflowOp::Sub,\n-                                sym::mul_with_overflow => OverflowOp::Mul,\n-                                _ => bug!(),\n-                            };\n-                            let (val, overflow) =\n-                                bx.checked_binop(op, ty, args[0].immediate(), args[1].immediate());\n-                            // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let val = bx.from_immediate(val);\n-                            let overflow = bx.from_immediate(overflow);\n-\n-                            let dest = result.project_field(bx, 0);\n-                            bx.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(bx, 1);\n-                            bx.store(overflow, dest.llval, dest.align);\n-\n-                            return;\n-                        }\n                         sym::exact_div => {\n                             if signed {\n                                 bx.exactsdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "41cd1c09a4e70e637aa1adea65c58e33699b23d1", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -652,15 +652,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         rhs: Bx::Value,\n         input_ty: Ty<'tcx>,\n     ) -> OperandValue<Bx::Value> {\n-        // This case can currently arise only from functions marked\n-        // with #[rustc_inherit_overflow_checks] and inlined from\n-        // another crate (mostly core::num generic/#[inline] fns),\n-        // while the current crate doesn't use overflow checks.\n-        if !bx.cx().check_overflow() {\n-            let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, bx.cx().const_bool(false));\n-        }\n-\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {"}, {"sha": "c5d558aeb6ccda0e5b20392fd9edf508fa101a47", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -210,19 +210,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let out_val = numeric_intrinsic(intrinsic_name, bits, kind);\n                 self.write_scalar(out_val, dest)?;\n             }\n-            sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                let lhs = self.read_immediate(&args[0])?;\n-                let rhs = self.read_immediate(&args[1])?;\n-                let bin_op = match intrinsic_name {\n-                    sym::add_with_overflow => BinOp::Add,\n-                    sym::sub_with_overflow => BinOp::Sub,\n-                    sym::mul_with_overflow => BinOp::Mul,\n-                    _ => bug!(),\n-                };\n-                self.binop_with_overflow(\n-                    bin_op, /*force_overflow_checks*/ true, &lhs, &rhs, dest,\n-                )?;\n-            }\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(&args[0])?;\n                 let r = self.read_immediate(&args[1])?;"}, {"sha": "450488315ef01d19b50963ca68fa79fd07614ed0", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -147,8 +147,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         true\n     }\n \n-    /// Whether CheckedBinOp MIR statements should actually check for overflow.\n-    fn checked_binop_checks_overflow(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// Whether Assert(OverflowNeg) and Assert(Overflow) MIR terminators should actually\n+    /// check for overflow.\n+    fn ignore_checkable_overflow_assertions(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Entry point for obtaining the MIR of anything that should get evaluated.\n     /// So not just functions and shims, but also const/static initializers, anonymous\n@@ -466,8 +467,8 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n+    fn ignore_checkable_overflow_assertions(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n+        false\n     }\n \n     #[inline(always)]"}, {"sha": "422120084d3182e3f692486bda7a351bcc30b482", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -10,13 +10,9 @@ use super::{ImmTy, Immediate, InterpCx, Machine, PlaceTy};\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    ///\n-    /// `force_overflow_checks` indicates whether overflow checks should be done even when\n-    /// `tcx.sess.overflow_checks()` is `false`.\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        force_overflow_checks: bool,\n         left: &ImmTy<'tcx, M::Provenance>,\n         right: &ImmTy<'tcx, M::Provenance>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n@@ -28,10 +24,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             \"type mismatch for result of {:?}\",\n             op,\n         );\n-        // As per https://github.com/rust-lang/rust/pull/98738, we always return `false` in the 2nd\n-        // component when overflow checking is disabled.\n-        let overflowed =\n-            overflowed && (force_overflow_checks || M::checked_binop_checks_overflow(self));\n         // Write the result to `dest`.\n         if let Abi::ScalarPair(..) = dest.layout.abi {\n             // We can use the optimized path and avoid `place_field` (which might do"}, {"sha": "6863435e5087813d315084abbf4c4221d9e165bd", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -185,9 +185,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_with_overflow(\n-                    bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n-                )?;\n+                self.binop_with_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {"}, {"sha": "294bd35c13ee1529ba09c9a07dfaeb42b1b750dd", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -137,8 +137,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                let ignored = M::ignore_checkable_overflow_assertions(self)\n+                    && match msg {\n+                        mir::AssertKind::OverflowNeg(..) => true,\n+                        mir::AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                        _ => false,\n+                    };\n                 let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n-                if expected == cond_val {\n+                if ignored || expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n                     M::assert_panic(self, msg, cleanup)?;"}, {"sha": "a9c2886b41448a4ae764d066863120096d1fb665", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 228, "deletions": 2, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,10 +1,11 @@\n use crate::astconv::AstConv;\n use crate::errors::{ManualImplementation, MissingTypeParams};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty;\n+use rustc_infer::traits::FulfillmentError;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n@@ -221,6 +222,231 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit()\n     }\n \n+    pub(crate) fn complain_about_ambiguous_inherent_assoc_type(\n+        &self,\n+        name: Ident,\n+        candidates: Vec<DefId>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            name.span,\n+            E0034,\n+            \"multiple applicable items in scope\"\n+        );\n+        err.span_label(name.span, format!(\"multiple `{name}` found\"));\n+        self.note_ambiguous_inherent_assoc_type(&mut err, candidates, span);\n+        err.emit()\n+    }\n+\n+    // FIXME(fmease): Heavily adapted from `rustc_hir_typeck::method::suggest`. Deduplicate.\n+    fn note_ambiguous_inherent_assoc_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        candidates: Vec<DefId>,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        // Dynamic limit to avoid hiding just one candidate, which is silly.\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+\n+        for (index, &item) in candidates.iter().take(limit).enumerate() {\n+            let impl_ = tcx.impl_of_method(item).unwrap();\n+\n+            let note_span = if item.is_local() {\n+                Some(tcx.def_span(item))\n+            } else if impl_.is_local() {\n+                Some(tcx.def_span(impl_))\n+            } else {\n+                None\n+            };\n+\n+            let title = if candidates.len() > 1 {\n+                format!(\"candidate #{}\", index + 1)\n+            } else {\n+                \"the candidate\".into()\n+            };\n+\n+            let impl_ty = tcx.at(span).type_of(impl_).subst_identity();\n+            let note = format!(\"{title} is defined in an impl for the type `{impl_ty}`\");\n+\n+            if let Some(span) = note_span {\n+                err.span_note(span, &note);\n+            } else {\n+                err.note(&note);\n+            }\n+        }\n+        if candidates.len() > limit {\n+            err.note(&format!(\"and {} others\", candidates.len() - limit));\n+        }\n+    }\n+\n+    // FIXME(inherent_associated_types): Find similarly named associated types and suggest them.\n+    pub(crate) fn complain_about_inherent_assoc_type_not_found(\n+        &self,\n+        name: Ident,\n+        self_ty: Ty<'tcx>,\n+        candidates: Vec<(DefId, (DefId, DefId))>,\n+        fulfillment_errors: Vec<FulfillmentError<'tcx>>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        // FIXME(fmease): This was copied in parts from an old version of `rustc_hir_typeck::method::suggest`.\n+        // Either\n+        // * update this code by applying changes similar to #106702 or by taking a\n+        //   Vec<(DefId, (DefId, DefId), Option<Vec<FulfillmentError<'tcx>>>)> or\n+        // * deduplicate this code across the two crates.\n+\n+        let tcx = self.tcx();\n+\n+        let adt_did = self_ty.ty_adt_def().map(|def| def.did());\n+        let add_def_label = |err: &mut Diagnostic| {\n+            if let Some(did) = adt_did {\n+                err.span_label(\n+                    tcx.def_span(did),\n+                    format!(\n+                        \"associated item `{name}` not found for this {}\",\n+                        tcx.def_kind(did).descr(did)\n+                    ),\n+                );\n+            }\n+        };\n+\n+        if fulfillment_errors.is_empty() {\n+            // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+\n+            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let type_candidates = candidates\n+                .iter()\n+                .take(limit)\n+                .map(|&(impl_, _)| format!(\"- `{}`\", tcx.at(span).type_of(impl_).subst_identity()))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            let additional_types = if candidates.len() > limit {\n+                format!(\"\\nand {} more types\", candidates.len() - limit)\n+            } else {\n+                String::new()\n+            };\n+\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                name.span,\n+                E0220,\n+                \"associated type `{name}` not found for `{self_ty}` in the current scope\"\n+            );\n+            err.span_label(name.span, format!(\"associated item not found in `{self_ty}`\"));\n+            err.note(&format!(\n+                \"the associated type was found for\\n{type_candidates}{additional_types}\",\n+            ));\n+            add_def_label(&mut err);\n+            return err.emit();\n+        }\n+\n+        let mut bound_spans = Vec::new();\n+\n+        let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n+            let msg = format!(\n+                \"doesn't satisfy `{}`\",\n+                if obligation.len() > 50 { quiet } else { obligation }\n+            );\n+            match &self_ty.kind() {\n+                // Point at the type that couldn't satisfy the bound.\n+                ty::Adt(def, _) => bound_spans.push((tcx.def_span(def.did()), msg)),\n+                // Point at the trait object that couldn't satisfy the bound.\n+                ty::Dynamic(preds, _, _) => {\n+                    for pred in preds.iter() {\n+                        match pred.skip_binder() {\n+                            ty::ExistentialPredicate::Trait(tr) => {\n+                                bound_spans.push((tcx.def_span(tr.def_id), msg.clone()))\n+                            }\n+                            ty::ExistentialPredicate::Projection(_)\n+                            | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                        }\n+                    }\n+                }\n+                // Point at the closure that couldn't satisfy the bound.\n+                ty::Closure(def_id, _) => {\n+                    bound_spans.push((tcx.def_span(*def_id), format!(\"doesn't satisfy `{quiet}`\")))\n+                }\n+                _ => {}\n+            }\n+        };\n+\n+        let format_pred = |pred: ty::Predicate<'tcx>| {\n+            let bound_predicate = pred.kind();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                    let pred = bound_predicate.rebind(pred);\n+                    // `<Foo as Iterator>::Item = String`.\n+                    let projection_ty = pred.skip_binder().projection_ty;\n+\n+                    let substs_with_infer_self = tcx.mk_substs(\n+                        std::iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n+                            .chain(projection_ty.substs.iter().skip(1)),\n+                    );\n+\n+                    let quiet_projection_ty =\n+                        tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n+\n+                    let term = pred.skip_binder().term;\n+\n+                    let obligation = format!(\"{projection_ty} = {term}\");\n+                    let quiet = format!(\"{quiet_projection_ty} = {term}\");\n+\n+                    bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                    Some((obligation, projection_ty.self_ty()))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n+                    let p = poly_trait_ref.trait_ref;\n+                    let self_ty = p.self_ty();\n+                    let path = p.print_only_trait_path();\n+                    let obligation = format!(\"{self_ty}: {path}\");\n+                    let quiet = format!(\"_: {path}\");\n+                    bound_span_label(self_ty, &obligation, &quiet);\n+                    Some((obligation, self_ty))\n+                }\n+                _ => None,\n+            }\n+        };\n+\n+        // FIXME(fmease): `rustc_hir_typeck::method::suggest` uses a `skip_list` to filter out some bounds.\n+        // I would do the same here if it didn't mean more code duplication.\n+        let mut bounds: Vec<_> = fulfillment_errors\n+            .into_iter()\n+            .map(|error| error.root_obligation.predicate)\n+            .filter_map(format_pred)\n+            .map(|(p, _)| format!(\"`{}`\", p))\n+            .collect();\n+        bounds.sort();\n+        bounds.dedup();\n+\n+        let mut err = tcx.sess.struct_span_err(\n+            name.span,\n+            &format!(\"the associated type `{name}` exists for `{self_ty}`, but its trait bounds were not satisfied\")\n+        );\n+        if !bounds.is_empty() {\n+            err.note(&format!(\n+                \"the following trait bounds were not satisfied:\\n{}\",\n+                bounds.join(\"\\n\")\n+            ));\n+        }\n+        err.span_label(\n+            name.span,\n+            format!(\"associated type cannot be referenced on `{self_ty}` due to unsatisfied trait bounds\")\n+        );\n+\n+        bound_spans.sort();\n+        bound_spans.dedup();\n+        for (span, msg) in bound_spans {\n+            if !tcx.sess.source_map().is_span_accessible(span) {\n+                continue;\n+            }\n+            err.span_label(span, &msg);\n+        }\n+        add_def_label(&mut err);\n+        err.emit()\n+    }\n+\n     /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n     /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n     /// same trait bound have the same name (as they come from different supertraits), we instead"}, {"sha": "716b4fc6ae36f75473c50fbcfec8253cf1ec2091", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 213, "deletions": 53, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -27,7 +27,10 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n@@ -39,12 +42,11 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::astconv_object_safety_violations;\n use rustc_trait_selection::traits::error_reporting::{\n     report_object_safety_error, suggestions::NextTypeParamName,\n };\n use rustc_trait_selection::traits::wf::object_region_bounds;\n+use rustc_trait_selection::traits::{self, astconv_object_safety_violations, ObligationCtxt};\n \n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n@@ -1944,7 +1946,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Err\n         };\n \n-        // Check if we have an enum variant.\n+        // Check if we have an enum variant or an inherent associated type.\n         let mut variant_resolution = None;\n         if let Some(adt_def) = self.probe_adt(span, qself_ty) {\n             if adt_def.is_enum() {\n@@ -2043,23 +2045,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n \n-            // see if we can satisfy using an inherent associated type\n-            for &impl_ in tcx.inherent_impls(adt_def.did()) {\n-                let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n-                    continue;\n-                };\n-                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n-                    // FIXME(inherent_associated_types)\n-                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n-                };\n-                let item_substs = self.create_substs_for_associated_item(\n-                    span,\n-                    assoc_ty_did,\n-                    assoc_segment,\n-                    adt_substs,\n-                );\n-                let ty = tcx.type_of(assoc_ty_did).subst(tcx, item_substs);\n-                return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n+            if let Some((ty, did)) = self.lookup_inherent_assoc_ty(\n+                assoc_ident,\n+                assoc_segment,\n+                adt_def.did(),\n+                qself_ty,\n+                hir_ref_id,\n+                span,\n+            )? {\n+                return Ok((ty, DefKind::AssocTy, did));\n             }\n         }\n \n@@ -2202,6 +2196,172 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn lookup_inherent_assoc_ty(\n+        &self,\n+        name: Ident,\n+        segment: &hir::PathSegment<'_>,\n+        adt_did: DefId,\n+        self_ty: Ty<'tcx>,\n+        block: hir::HirId,\n+        span: Span,\n+    ) -> Result<Option<(Ty<'tcx>, DefId)>, ErrorGuaranteed> {\n+        let tcx = self.tcx();\n+\n+        let candidates: Vec<_> = tcx\n+            .inherent_impls(adt_did)\n+            .iter()\n+            .filter_map(|&impl_| Some((impl_, self.lookup_assoc_ty_unchecked(name, block, impl_)?)))\n+            .collect();\n+\n+        if candidates.is_empty() {\n+            return Ok(None);\n+        }\n+\n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = match self.infcx() {\n+            Some(infcx) => infcx,\n+            None => {\n+                assert!(!self_ty.needs_infer());\n+                infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n+                &infcx_\n+            }\n+        };\n+\n+        let param_env = tcx.param_env(block.owner.to_def_id());\n+        let cause = ObligationCause::misc(span, block.owner.def_id);\n+        let mut fulfillment_errors = Vec::new();\n+        let mut applicable_candidates: Vec<_> = candidates\n+            .iter()\n+            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                infcx.probe(|_| {\n+                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+\n+                    let impl_ty = tcx.type_of(impl_);\n+                    let impl_substs = infcx.fresh_item_substs(impl_);\n+                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+\n+                    // Check that the Self-types can be related.\n+                    // FIXME(fmease): Should we use `eq` here?\n+                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+\n+                    // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_bounds = tcx.predicates_of(impl_);\n+                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+\n+                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+\n+                    let impl_obligations = traits::predicates_for_generics(\n+                        |_, _| cause.clone(),\n+                        param_env,\n+                        impl_bounds,\n+                    );\n+\n+                    ocx.register_obligations(impl_obligations);\n+\n+                    let mut errors = ocx.select_where_possible();\n+                    if !errors.is_empty() {\n+                        fulfillment_errors.append(&mut errors);\n+                        return None;\n+                    }\n+\n+                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                })\n+            })\n+            .collect();\n+\n+        if applicable_candidates.len() > 1 {\n+            return Err(self.complain_about_ambiguous_inherent_assoc_type(\n+                name,\n+                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                span,\n+            ));\n+        }\n+\n+        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+            self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n+\n+            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n+            // need to relate the Self-type with fresh item substs & register region obligations for\n+            // regionck to prove/disprove.\n+\n+            let item_substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+\n+            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n+            // associated type hold, if any.\n+            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+\n+            return Ok(Some((ty, assoc_item)));\n+        }\n+\n+        Err(self.complain_about_inherent_assoc_type_not_found(\n+            name,\n+            self_ty,\n+            candidates,\n+            fulfillment_errors,\n+            span,\n+        ))\n+    }\n+\n+    fn lookup_assoc_ty(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        span: Span,\n+        scope: DefId,\n+    ) -> Option<DefId> {\n+        let (item, def_scope) = self.lookup_assoc_ty_unchecked(name, block, scope)?;\n+        self.check_assoc_ty(item, name, def_scope, block, span);\n+        Some(item)\n+    }\n+\n+    fn lookup_assoc_ty_unchecked(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        scope: DefId,\n+    ) -> Option<(DefId, DefId)> {\n+        let tcx = self.tcx();\n+        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(name, scope, block);\n+\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n+        // of calling `find_by_name_and_kind`.\n+        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n+            i.kind.namespace() == Namespace::TypeNS\n+                && i.ident(tcx).normalize_to_macros_2_0() == ident\n+        })?;\n+\n+        Some((item.def_id, def_scope))\n+    }\n+\n+    fn check_assoc_ty(\n+        &self,\n+        item: DefId,\n+        name: Ident,\n+        def_scope: DefId,\n+        block: hir::HirId,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+        let kind = DefKind::AssocTy;\n+\n+        if !tcx.visibility(item).is_accessible_from(def_scope, tcx) {\n+            let kind = kind.descr(item);\n+            let msg = format!(\"{kind} `{name}` is private\");\n+            let def_span = tcx.def_span(item);\n+            tcx.sess\n+                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n+                .span_label(span, &format!(\"private {kind}\"))\n+                .span_label(def_span, &format!(\"{kind} defined here\"))\n+                .emit();\n+        }\n+        tcx.check_stability(item, Some(block), span, None);\n+    }\n+\n     fn probe_traits_that_match_assoc_ty(\n         &self,\n         qself_ty: Ty<'tcx>,\n@@ -2255,39 +2415,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect()\n     }\n \n-    fn lookup_assoc_ty(\n-        &self,\n-        ident: Ident,\n-        block: hir::HirId,\n-        span: Span,\n-        scope: DefId,\n-    ) -> Option<DefId> {\n-        let tcx = self.tcx();\n-        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(ident, scope, block);\n-\n-        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n-        // of calling `find_by_name_and_kind`.\n-        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n-            i.kind.namespace() == Namespace::TypeNS\n-                && i.ident(tcx).normalize_to_macros_2_0() == ident\n-        })?;\n-\n-        let kind = DefKind::AssocTy;\n-        if !item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n-            let kind = kind.descr(item.def_id);\n-            let msg = format!(\"{kind} `{ident}` is private\");\n-            let def_span = self.tcx().def_span(item.def_id);\n-            tcx.sess\n-                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n-                .span_label(span, &format!(\"private {kind}\"))\n-                .span_label(def_span, &format!(\"{kind} defined here\"))\n-                .emit();\n-        }\n-        tcx.check_stability(item.def_id, Some(block), span, None);\n-\n-        Some(item.def_id)\n-    }\n-\n     fn qpath_to_ty(\n         &self,\n         span: Span,\n@@ -3375,3 +3502,36 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n }\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx>;\n+}\n+\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx> {\n+        InternalSubsts::for_item(self.tcx, def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => self.tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } => self\n+                .next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::SubstitutionPlaceholder,\n+                    span: self.tcx.def_span(def_id),\n+                })\n+                .into(),\n+            GenericParamDefKind::Const { .. } => {\n+                let span = self.tcx.def_span(def_id);\n+                let origin = ConstVariableOrigin {\n+                    kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n+                    span,\n+                };\n+                self.next_const_var(\n+                    self.tcx\n+                        .type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                    origin,\n+                )\n+                .into()\n+            }\n+        })\n+    }\n+}"}, {"sha": "5743f086f89b4b31adc3e108c7ff9ea00f1bffee", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1599,7 +1599,7 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     {\n         for arg in fn_output.walk() {\n             if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Alias(ty::Projection, proj) = ty.kind()\n+                && let ty::Alias(ty::Opaque, proj) = ty.kind()\n                 && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n                 && tcx.impl_trait_in_trait_parent(proj.def_id) == fn_def_id.to_def_id()\n             {"}, {"sha": "eb6c0b7686b6d94c12b646d210496bc94a319088", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -9,12 +9,11 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n+use rustc_hir_analysis::astconv::InferCtxtExt as _;\n use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n-use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n@@ -1941,33 +1940,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         (self.tcx.type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n     }\n \n-    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self.tcx, def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => self.tcx.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } => self\n-                .next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::SubstitutionPlaceholder,\n-                    span: self.tcx.def_span(def_id),\n-                })\n-                .into(),\n-            GenericParamDefKind::Const { .. } => {\n-                let span = self.tcx.def_span(def_id);\n-                let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n-                    span,\n-                };\n-                self.next_const_var(\n-                    self.tcx\n-                        .type_of(param.def_id)\n-                        .no_bound_vars()\n-                        .expect(\"const parameter types cannot be generic\"),\n-                    origin,\n-                )\n-                .into()\n-            }\n-        })\n-    }\n-\n     /// Replaces late-bound-regions bound by `value` with `'static` using\n     /// `ty::erase_late_bound_regions`.\n     ///"}, {"sha": "b736a416e4a108922e3103ca7aa84c26ae71b83e", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -418,10 +418,15 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::Placeholder(placeholder) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderTy(placeholder) },\n-                t,\n-            ),\n+            ty::Placeholder(mut placeholder) => {\n+                if !self.canonicalize_mode.preserve_universes() {\n+                    placeholder.universe = ty::UniverseIndex::ROOT;\n+                }\n+                self.canonicalize_ty_var(\n+                    CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderTy(placeholder) },\n+                    t,\n+                )\n+            }\n \n             ty::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {"}, {"sha": "ae09562a85e987e5102654fbb154252a34ccd7cb", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -671,6 +671,12 @@ pub enum TerminatorKind<'tcx> {\n     /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n     /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n     /// assertion does not fail, execution continues at the specified basic block.\n+    ///\n+    /// When overflow checking is disabled and this is run-time MIR (as opposed to compile-time MIR\n+    /// that is used for CTFE), the following variants of this terminator behave as `goto target`:\n+    /// - `OverflowNeg(..)`,\n+    /// - `Overflow(op, ..)` if op is a \"checkable\" operation (add, sub, mul, shl, shr, but NOT\n+    /// div or rem).\n     Assert {\n         cond: Operand<'tcx>,\n         expected: bool,\n@@ -1103,10 +1109,6 @@ pub enum Rvalue<'tcx> {\n \n     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n     ///\n-    /// When overflow checking is disabled and we are generating run-time code, the error condition\n-    /// is false. Otherwise, and always during CTFE, the error condition is determined as described\n-    /// below.\n-    ///\n     /// For addition, subtraction, and multiplication on integers the error condition is set when\n     /// the infinite precision result would be unequal to the actual result.\n     ///"}, {"sha": "52f4414e37bde93c1d68864fcaf0a78a01cf8369", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -217,23 +217,21 @@ impl<'tcx> ConstKind<'tcx> {\n             // Note that we erase regions *before* calling `with_reveal_all_normalized`,\n             // so that we don't try to invoke this query with\n             // any region variables.\n-            let param_env_and = tcx\n-                .erase_regions(param_env)\n-                .with_reveal_all_normalized(tcx)\n-                .and(tcx.erase_regions(unevaluated));\n \n             // HACK(eddyb) when the query key would contain inference variables,\n             // attempt using identity substs and `ParamEnv` instead, that will succeed\n             // when the expression doesn't depend on any parameters.\n             // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n             // we can call `infcx.const_eval_resolve` which handles inference variables.\n-            let param_env_and = if param_env_and.needs_infer() {\n+            let param_env_and = if (param_env, unevaluated).has_non_region_infer() {\n                 tcx.param_env(unevaluated.def.did).and(ty::UnevaluatedConst {\n                     def: unevaluated.def,\n                     substs: InternalSubsts::identity_for_item(tcx, unevaluated.def.did),\n                 })\n             } else {\n-                param_env_and\n+                tcx.erase_regions(param_env)\n+                    .with_reveal_all_normalized(tcx)\n+                    .and(tcx.erase_regions(unevaluated))\n             };\n \n             // FIXME(eddyb) maybe the `const_eval_*` methods should take"}, {"sha": "993191ee96a446f8ad02652c707fa0dc84fc5414", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -770,7 +770,7 @@ where\n \n                 ty::Dynamic(_, _, ty::DynStar) => {\n                     if i == 0 {\n-                        TyMaybeWithLayout::Ty(tcx.types.usize)\n+                        TyMaybeWithLayout::Ty(tcx.mk_mut_ptr(tcx.types.unit))\n                     } else if i == 1 {\n                         // FIXME(dyn-star) same FIXME as above applies here too\n                         TyMaybeWithLayout::Ty("}, {"sha": "a101127104de812d83cff116dbfce975e9d9bd8a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -735,7 +735,10 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(print(data))\n                 }\n             }\n-            ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n+            ty::Placeholder(placeholder) => match placeholder.name {\n+                ty::BoundTyKind::Anon(_) => p!(write(\"Placeholder({:?})\", placeholder)),\n+                ty::BoundTyKind::Param(_, name) => p!(write(\"{}\", name)),\n+            },\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should"}, {"sha": "ca46cf29919f850b1d5f6997ef809df1646f03c6", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -4,7 +4,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n-    self, ir::TypeFolder, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable,\n+    self, ir::TypeFolder, DefIdTree, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable,\n     TypeSuperFoldable,\n };\n use crate::ty::{GenericArgKind, SubstsRef};\n@@ -865,6 +865,26 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for OpaqueTypeExpander<'tcx> {\n         }\n         t\n     }\n+\n+    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+        if let ty::PredicateKind::Clause(clause) = p.kind().skip_binder()\n+            && let ty::Clause::Projection(projection_pred) = clause\n+        {\n+            p.kind()\n+                .rebind(ty::ProjectionPredicate {\n+                    projection_ty: projection_pred.projection_ty.fold_with(self),\n+                    // Don't fold the term on the RHS of the projection predicate.\n+                    // This is because for default trait methods with RPITITs, we\n+                    // install a `NormalizesTo(Projection(RPITIT) -> Opaque(RPITIT))`\n+                    // predicate, which would trivially cause a cycle when we do\n+                    // anything that requires `ParamEnv::with_reveal_all_normalized`.\n+                    term: projection_pred.term,\n+                })\n+                .to_predicate(self.tcx)\n+        } else {\n+            p.super_fold_with(self)\n+        }\n+    }\n }\n \n impl<'tcx> Ty<'tcx> {"}, {"sha": "33ee90ffc119dc132114f1fbd749e54364690004", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 96, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::visit::{\n };\n use rustc_middle::mir::{\n     BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n     RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -503,55 +503,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>) -> Option<()> {\n-        if self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n-            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n-            Ok(overflow)\n-        })? {\n-            // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n-            // appropriate to use.\n-            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-            return None;\n-        }\n-\n-        Some(())\n-    }\n-\n-    fn check_binary_op(\n-        &mut self,\n-        op: BinOp,\n-        left: &Operand<'tcx>,\n-        right: &Operand<'tcx>,\n-    ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n-        // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if matches!(op, BinOp::Shr | BinOp::Shl) {\n-            let r = r.clone()?;\n-            // We need the type of the LHS. We cannot use `place_layout` as that is the type\n-            // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(self.local_decls, self.tcx);\n-            let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n-            let right_size = r.layout.size;\n-            let r_bits = r.to_scalar().to_bits(right_size).ok();\n-            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                return None;\n-            }\n-        }\n-\n-        if let (Some(l), Some(r)) = (&l, &r) {\n-            // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(|this| {\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-                Ok(overflow)\n-            })? {\n-                return None;\n-            }\n-        }\n-        Some(())\n-    }\n-\n     fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n@@ -587,28 +538,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         //   2. Working around bugs in other parts of the compiler\n         //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n-            // Additional checking: give lints to the user if an overflow would occur.\n-            // We do this here and not in the `Assert` terminator as that terminator is\n-            // only sometimes emitted (overflow checks can be disabled), but we want to always\n-            // lint.\n-            Rvalue::UnaryOp(op, arg) => {\n-                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg)?;\n-            }\n-            Rvalue::BinaryOp(op, box (left, right)) => {\n-                trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                trace!(\n-                    \"checking CheckedBinaryOp(op = {:?}, left = {:?}, right = {:?})\",\n-                    op,\n-                    left,\n-                    right\n-                );\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-\n             // Do not try creating references (#67862)\n             Rvalue::AddressOf(_, place) | Rvalue::Ref(_, _, place) => {\n                 trace!(\"skipping AddressOf | Ref for {:?}\", place);\n@@ -638,7 +567,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             | Rvalue::Cast(..)\n             | Rvalue::ShallowInitBox(..)\n             | Rvalue::Discriminant(..)\n-            | Rvalue::NullaryOp(..) => {}\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..) => {}\n         }\n \n         // FIXME we need to revisit this for #67176\n@@ -1079,31 +1011,18 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // Do NOT early return in this function, it does some crucial fixup of the state at the end!\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n+                if let Some(ref value) = self.eval_operand(&cond)\n                     // FIXME should be used use_ecx rather than a local match... but we have\n                     // quite a few of these read_scalar/read_immediate that need fixing.\n-                    if let Ok(value_const) = self.ecx.read_scalar(&value) {\n-                        if expected != value_const {\n-                            // Poison all places this operand references so that further code\n-                            // doesn't use the invalid value\n-                            match cond {\n-                                Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                    Self::remove_const(&mut self.ecx, place.local);\n-                                }\n-                                Operand::Constant(_) => {}\n-                            }\n-                        } else {\n-                            if self.should_const_prop(value) {\n-                                *cond = self.operand_from_scalar(\n-                                    value_const,\n-                                    self.tcx.types.bool,\n-                                    source_info.span,\n-                                );\n-                            }\n-                        }\n-                    }\n+                    && let Ok(value_const) = self.ecx.read_scalar(&value)\n+                    && self.should_const_prop(value)\n+                {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    *cond = self.operand_from_scalar(\n+                        value_const,\n+                        self.tcx.types.bool,\n+                        source_info.span,\n+                    );\n                 }\n             }\n             TerminatorKind::SwitchInt { ref mut discr, .. } => {"}, {"sha": "19019e3ef744aa8cd7121ef89da72eb654656b8a", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -180,12 +180,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                         let overflow = match overflow {\n                             FlatSet::Top => FlatSet::Top,\n                             FlatSet::Elem(overflow) => {\n-                                if overflow {\n-                                    // Overflow cannot be reliably propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n-                                    FlatSet::Top\n-                                } else {\n-                                    self.wrap_scalar(Scalar::from_bool(false), self.tcx.types.bool)\n-                                }\n+                                self.wrap_scalar(Scalar::from_bool(overflow), self.tcx.types.bool)\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };"}, {"sha": "f596cc1808fa2b491fc8b82170df85d88f75eef6", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -107,9 +107,29 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                         }\n                     }\n                     sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                        // The checked binary operations are not suitable target for lowering here,\n-                        // since their semantics depend on the value of overflow-checks flag used\n-                        // during codegen. Issue #35310.\n+                        if let Some(target) = *target {\n+                            let lhs;\n+                            let rhs;\n+                            {\n+                                let mut args = args.drain(..);\n+                                lhs = args.next().unwrap();\n+                                rhs = args.next().unwrap();\n+                            }\n+                            let bin_op = match intrinsic_name {\n+                                sym::add_with_overflow => BinOp::Add,\n+                                sym::sub_with_overflow => BinOp::Sub,\n+                                sym::mul_with_overflow => BinOp::Mul,\n+                                _ => bug!(\"unexpected intrinsic\"),\n+                            };\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    *destination,\n+                                    Rvalue::CheckedBinaryOp(bin_op, Box::new((lhs, rhs))),\n+                                ))),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n                     }\n                     sym::size_of | sym::min_align_of => {\n                         if let Some(target) = *target {"}, {"sha": "623be668464e8f141ea29f9dfd8a6fb3b937facc", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -3,6 +3,7 @@\n #![feature(hash_raw_entry)]\n #![feature(min_specialization)]\n #![feature(extern_types)]\n+#![feature(let_chains)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]"}, {"sha": "21a0c73d7208363aee28b272e2652f1a24bf4b4f", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -408,10 +408,27 @@ where\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n+        // Fingerprint the key, just to assert that it doesn't\n+        // have anything we don't consider hashable\n+        if cfg!(debug_assertions) {\n+            let _ = key.to_fingerprint(*qcx.dep_context());\n+        }\n+\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n         let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(qcx, key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+        // Similarly, fingerprint the result to assert that\n+        // it doesn't have anything not considered hashable.\n+        if cfg!(debug_assertions)\n+            && let Some(hash_result) = Q::HASH_RESULT\n+        {\n+            qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+                hash_result(&mut hcx, &result);\n+            });\n+        }\n+\n         return (result, dep_node_index);\n     }\n "}, {"sha": "162f91e05f8c84d36ab5716307485acc63bf5964", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -4211,7 +4211,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 if let Some(res) = res\n                     && let Some(def_id) = res.opt_def_id()\n                     && !def_id.is_local()\n-                    && self.r.session.crate_types().contains(&CrateType::ProcMacro) {\n+                    && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                    && matches!(self.r.session.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n                     // Encoding foreign def ids in proc macro crate metadata will ICE.\n                     return None;\n                 }\n@@ -4281,6 +4282,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         .filter_map(|tr| {\n                             if !tr.def_id.is_local()\n                                 && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                                && matches!(\n+                                    self.r.session.opts.resolve_doc_links,\n+                                    ResolveDocLinks::ExportedMetadata\n+                                )\n                             {\n                                 // Encoding foreign def ids in proc macro crate metadata will ICE.\n                                 return None;"}, {"sha": "5e4b66018e42ec9e0b3263301cdb65f3558ee974", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,11 +1,10 @@\n-use pulldown_cmark::{BrokenLink, Event, Options, Parser, Tag};\n+use pulldown_cmark::{BrokenLink, Event, LinkType, Options, Parser, Tag};\n use rustc_ast as ast;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n-use std::cell::RefCell;\n use std::{cmp, mem};\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n@@ -340,6 +339,7 @@ pub fn inner_docs(attrs: &[ast::Attribute]) -> bool {\n fn preprocess_link(link: &str) -> String {\n     let link = link.replace('`', \"\");\n     let link = link.split('#').next().unwrap();\n+    let link = link.trim();\n     let link = link.rsplit('@').next().unwrap();\n     let link = link.strip_suffix(\"()\").unwrap_or(link);\n     let link = link.strip_suffix(\"{}\").unwrap_or(link);\n@@ -348,22 +348,37 @@ fn preprocess_link(link: &str) -> String {\n     strip_generics_from_path(link).unwrap_or_else(|_| link.to_string())\n }\n \n+/// Keep inline and reference links `[]`,\n+/// but skip autolinks `<>` which we never consider to be intra-doc links.\n+pub fn may_be_doc_link(link_type: LinkType) -> bool {\n+    match link_type {\n+        LinkType::Inline\n+        | LinkType::Reference\n+        | LinkType::ReferenceUnknown\n+        | LinkType::Collapsed\n+        | LinkType::CollapsedUnknown\n+        | LinkType::Shortcut\n+        | LinkType::ShortcutUnknown => true,\n+        LinkType::Autolink | LinkType::Email => false,\n+    }\n+}\n+\n /// Simplified version of `preprocessed_markdown_links` from rustdoc.\n /// Must return at least the same links as it, but may add some more links on top of that.\n pub(crate) fn attrs_to_preprocessed_links(attrs: &[ast::Attribute]) -> Vec<String> {\n     let (doc_fragments, _) = attrs_to_doc_fragments(attrs.iter().map(|attr| (attr, None)), true);\n     let doc = prepare_to_doc_link_resolution(&doc_fragments).into_values().next().unwrap();\n \n-    let links = RefCell::new(Vec::new());\n-    let mut callback = |link: BrokenLink<'_>| {\n-        links.borrow_mut().push(preprocess_link(&link.reference));\n-        None\n-    };\n-    for event in Parser::new_with_broken_link_callback(&doc, main_body_opts(), Some(&mut callback))\n-    {\n-        if let Event::Start(Tag::Link(_, dest, _)) = event {\n-            links.borrow_mut().push(preprocess_link(&dest));\n+    Parser::new_with_broken_link_callback(\n+        &doc,\n+        main_body_opts(),\n+        Some(&mut |link: BrokenLink<'_>| Some((link.reference, \"\".into()))),\n+    )\n+    .filter_map(|event| match event {\n+        Event::Start(Tag::Link(link_type, dest, _)) if may_be_doc_link(link_type) => {\n+            Some(preprocess_link(&dest))\n         }\n-    }\n-    links.into_inner()\n+        _ => None,\n+    })\n+    .collect()\n }"}, {"sha": "841169ac78d7d83e648c0190e898e85cc9b20c4c", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -90,16 +90,20 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n-    fn consider_impl_candidate(\n+    // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n+    // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n+    // goal by equating it with the assumption.\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        impl_def_id: DefId,\n+        assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n-    fn consider_assumption(\n+    fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        impl_def_id: DefId,\n     ) -> QueryResult<'tcx>;\n \n     // A type implements an `auto trait` if its components do as well. These components\n@@ -355,7 +359,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n                 }\n@@ -402,7 +406,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -452,7 +456,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_assumption(self, goal, assumption.predicate) {\n+            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "48153b465b7ec9487e2cef6c085032b82c7b6c0e", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -168,6 +168,37 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n+    fn consider_implied_clause(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred =\n+                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                nested_goals.extend(requirements);\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -260,35 +291,6 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.infcx.probe(|_| {\n-                let assumption_projection_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n-                let nested_goals = ecx.infcx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n     fn consider_auto_trait_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -329,25 +331,28 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n-        if let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n-                ecx.tcx(),\n-                goal.predicate.self_ty(),\n-                goal_kind,\n-            )?\n-        {\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n-                    projection_ty: ecx\n-                        .tcx()\n-                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n-                    term: output.into(),\n-                })\n-                .to_predicate(ecx.tcx());\n-            Self::consider_assumption(ecx, goal, pred)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+        let tcx = ecx.tcx();\n+        let Some(tupled_inputs_and_output) =\n+        structural_traits::extract_tupled_inputs_and_output_from_callable(\n+            tcx,\n+            goal.predicate.self_ty(),\n+            goal_kind,\n+        )? else {\n+        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+    };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                projection_ty: tcx\n+                    .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                term: output.into(),\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -466,14 +471,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let term = substs.as_generator().return_ty().into();\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n                 projection_ty: ecx.tcx().mk_alias_ty(goal.predicate.def_id(), [self_ty]),\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n \n@@ -503,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             bug!(\"unexpected associated item `<{self_ty} as Generator>::{name}`\")\n         };\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -513,6 +521,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}, {"sha": "f2f25ef850a9a6ac92f203ec5b4b7d0aa515e8eb", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -6,6 +6,7 @@ use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n@@ -61,10 +62,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption(\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -73,11 +75,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred =\n                     ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n-                let nested_goals = ecx.infcx.eq(\n+                let mut nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n+                nested_goals.extend(requirements);\n                 ecx.evaluate_all_and_make_canonical_response(nested_goals)\n             })\n         } else {\n@@ -173,23 +176,26 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n-        if let Some(tupled_inputs_and_output) =\n+        let tcx = ecx.tcx();\n+        let Some(tupled_inputs_and_output) =\n             structural_traits::extract_tupled_inputs_and_output_from_callable(\n-                ecx.tcx(),\n+                tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )?\n-        {\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, _)| {\n-                    ecx.tcx()\n-                        .mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n-                })\n-                .to_predicate(ecx.tcx());\n-            Self::consider_assumption(ecx, goal, pred)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+            )? else {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, _)| {\n+                tcx.mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -225,6 +231,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         // Async generator unconditionally implement `Future`\n+        // Technically, we need to check that the future output type is Sized,\n+        // but that's already proven by the generator being WF.\n         ecx.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -244,13 +252,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         let generator = substs.as_generator();\n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(\n                 tcx.mk_trait_ref(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n             )\n             .to_predicate(tcx),\n+            // Technically, we need to check that the generator types are Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}, {"sha": "1c66fb257ebb56acbc68b244ffd52a2bf114d1de", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -90,15 +90,7 @@ enum ProjectionCandidate<'tcx> {\n     /// From an \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n \n-    ImplTraitInTrait(ImplTraitInTraitCandidate<'tcx>),\n-}\n-\n-#[derive(PartialEq, Eq, Debug)]\n-enum ImplTraitInTraitCandidate<'tcx> {\n-    // The `impl Trait` from a trait function's default body\n-    Trait,\n-    // A concrete type provided from a trait's `impl Trait` from an impl\n-    Impl(ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>),\n+    ImplTraitInTrait(ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>),\n }\n \n enum ProjectionCandidateSet<'tcx> {\n@@ -1292,17 +1284,6 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n     if tcx.def_kind(obligation.predicate.def_id) == DefKind::ImplTraitPlaceholder {\n         let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-        // If we are trying to project an RPITIT with trait's default `Self` parameter,\n-        // then we must be within a default trait body.\n-        if obligation.predicate.self_ty()\n-            == ty::InternalSubsts::identity_for_item(tcx, obligation.predicate.def_id).type_at(0)\n-            && tcx.associated_item(trait_fn_def_id).defaultness(tcx).has_value()\n-        {\n-            candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n-                ImplTraitInTraitCandidate::Trait,\n-            ));\n-            return;\n-        }\n \n         let trait_def_id = tcx.parent(trait_fn_def_id);\n         let trait_substs =\n@@ -1313,9 +1294,7 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n         let _ = selcx.infcx.commit_if_ok(|_| {\n             match selcx.select(&obligation.with(tcx, trait_predicate)) {\n                 Ok(Some(super::ImplSource::UserDefined(data))) => {\n-                    candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n-                        ImplTraitInTraitCandidate::Impl(data),\n-                    ));\n+                    candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(data));\n                     Ok(())\n                 }\n                 Ok(None) => {\n@@ -1777,18 +1756,9 @@ fn confirm_candidate<'cx, 'tcx>(\n         ProjectionCandidate::Select(impl_source) => {\n             confirm_select_candidate(selcx, obligation, impl_source)\n         }\n-        ProjectionCandidate::ImplTraitInTrait(ImplTraitInTraitCandidate::Impl(data)) => {\n+        ProjectionCandidate::ImplTraitInTrait(data) => {\n             confirm_impl_trait_in_trait_candidate(selcx, obligation, data)\n         }\n-        // If we're projecting an RPITIT for a default trait body, that's just\n-        // the same def-id, but as an opaque type (with regular RPIT semantics).\n-        ProjectionCandidate::ImplTraitInTrait(ImplTraitInTraitCandidate::Trait) => Progress {\n-            term: selcx\n-                .tcx()\n-                .mk_opaque(obligation.predicate.def_id, obligation.predicate.substs)\n-                .into(),\n-            obligations: vec![],\n-        },\n     };\n \n     // When checking for cycle during evaluation, we compare predicates with"}, {"sha": "4b15dd408b3708bdd324b32b70b815f433d830f1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -2148,12 +2148,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }))\n             }\n \n-            ty::Alias(..) | ty::Param(_) => None,\n+            ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::Placeholder(..)\n-            | ty::Bound(..)\n-            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            // We can make this an ICE if/once we actually instantiate the trait obligation.\n+            ty::Bound(..) => None,\n+\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\", self_ty);\n             }\n         }"}, {"sha": "1a62794b0b441b471192f0fb6229f43c45698e25", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -193,7 +193,7 @@ fn layout_of_uncached<'tcx>(\n         }\n \n         ty::Dynamic(_, _, ty::DynStar) => {\n-            let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n+            let mut data = scalar_unit(Pointer(AddressSpace::DATA));\n             data.valid_range_mut().start = 0;\n             let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n             vtable.valid_range_mut().start = 1;"}, {"sha": "f1af0073e4da95564b15b22585c0d63a45ec0d38", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,8 +1,12 @@\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n+#[cfg(not(bootstrap))]\n+use rustc_middle::ty::ir::TypeVisitable;\n use rustc_middle::ty::{\n-    self, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n+    self, ir::TypeVisitor, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n+    TypeSuperVisitable,\n };\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n@@ -136,6 +140,19 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n         predicates.extend(environment);\n     }\n \n+    if tcx.def_kind(def_id) == DefKind::AssocFn\n+        && tcx.associated_item(def_id).container == ty::AssocItemContainer::TraitContainer\n+    {\n+        let sig = tcx.fn_sig(def_id).subst_identity();\n+        sig.visit_with(&mut ImplTraitInTraitFinder {\n+            tcx,\n+            fn_def_id: def_id,\n+            bound_vars: sig.bound_vars(),\n+            predicates: &mut predicates,\n+            seen: FxHashSet::default(),\n+        });\n+    }\n+\n     let local_did = def_id.as_local();\n     let hir_id = local_did.map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id));\n \n@@ -222,6 +239,46 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n }\n \n+/// Walk through a function type, gathering all RPITITs and installing a\n+/// `NormalizesTo(Projection(RPITIT) -> Opaque(RPITIT))` predicate into the\n+/// predicates list. This allows us to observe that an RPITIT projects to\n+/// its corresponding opaque within the body of a default-body trait method.\n+struct ImplTraitInTraitFinder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    predicates: &'a mut Vec<Predicate<'tcx>>,\n+    fn_def_id: DefId,\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+    seen: FxHashSet<DefId>,\n+}\n+\n+impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n+        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n+            && self.tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n+            && self.tcx.impl_trait_in_trait_parent(alias_ty.def_id) == self.fn_def_id\n+            && self.seen.insert(alias_ty.def_id)\n+        {\n+            self.predicates.push(\n+                ty::Binder::bind_with_vars(\n+                    ty::ProjectionPredicate {\n+                        projection_ty: alias_ty,\n+                        term: self.tcx.mk_alias(ty::Opaque, alias_ty).into(),\n+                    },\n+                    self.bound_vars,\n+                )\n+                .to_predicate(self.tcx),\n+            );\n+\n+            for bound in self.tcx.item_bounds(alias_ty.def_id).subst_iter(self.tcx, alias_ty.substs)\n+            {\n+                bound.visit_with(self);\n+            }\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+}\n+\n /// Elaborate the environment.\n ///\n /// Collect a list of `Predicate`'s used for building the `ParamEnv`. Adds `TypeWellFormedFromEnv`'s"}, {"sha": "ebe2b76aef335e5bf2c5a9948ece67e49d417ebf", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -26,11 +26,9 @@ pub enum DynKind {\n     Dyn,\n     /// A sized `dyn* Trait` object\n     ///\n-    /// These objects are represented as a `(data, vtable)` pair where `data` is a ptr-sized value\n-    /// (often a pointer to the real object, but not necessarily) and `vtable` is a pointer to\n-    /// the vtable for `dyn* Trait`. The representation is essentially the same as `&dyn Trait`\n-    /// or similar, but the drop function included in the vtable is responsible for freeing the\n-    /// underlying storage if needed. This allows a `dyn*` object to be treated agnostically with\n+    /// These objects are represented as a `(data, vtable)` pair where `data` is a value of some\n+    /// ptr-sized and ptr-aligned dynamically determined type `T` and `vtable` is a pointer to the\n+    /// vtable of `impl T for Trait`. This allows a `dyn*` object to be treated agnostically with\n     /// respect to whether it points to a `Box<T>`, `Rc<T>`, etc.\n     DynStar,\n }"}, {"sha": "313a97ed1ffcc34d5c78edd23e18bd21b032976e", "filename": "library/alloc/benches/vec_deque.rs", "status": "modified", "additions": 145, "deletions": 1, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Falloc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Falloc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec_deque.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,4 +1,8 @@\n-use std::collections::VecDeque;\n+use core::iter::Iterator;\n+use std::{\n+    collections::{vec_deque, VecDeque},\n+    mem,\n+};\n use test::{black_box, Bencher};\n \n #[bench]\n@@ -53,6 +57,146 @@ fn bench_try_fold(b: &mut Bencher) {\n     b.iter(|| black_box(ring.iter().try_fold(0, |a, b| Some(a + b))))\n }\n \n+/// does the memory bookkeeping to reuse the buffer of the Vec between iterations.\n+/// `setup` must not modify its argument's length or capacity. `g` must not move out of its argument.\n+fn into_iter_helper<\n+    T: Copy,\n+    F: FnOnce(&mut VecDeque<T>),\n+    G: FnOnce(&mut vec_deque::IntoIter<T>),\n+>(\n+    v: &mut Vec<T>,\n+    setup: F,\n+    g: G,\n+) {\n+    let ptr = v.as_mut_ptr();\n+    let len = v.len();\n+    // ensure that the vec is full, to make sure that any wrapping from the deque doesn't\n+    // access uninitialized memory.\n+    assert_eq!(v.len(), v.capacity());\n+\n+    let mut deque = VecDeque::from(mem::take(v));\n+    setup(&mut deque);\n+\n+    let mut it = deque.into_iter();\n+    g(&mut it);\n+\n+    mem::forget(it);\n+\n+    // SAFETY: the provided functions are not allowed to modify the allocation, so the buffer is still alive.\n+    // len and capacity are accurate due to the above assertion.\n+    // All the elements in the buffer are still valid, because of `T: Copy` which implies `T: !Drop`.\n+    mem::forget(mem::replace(v, unsafe { Vec::from_raw_parts(ptr, len, len) }));\n+}\n+\n+#[bench]\n+fn bench_into_iter(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+\n+        let mut sum = 0;\n+        // rotating a full deque doesn't move any memory.\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_fold(b: &mut Bencher) {\n+    let len = 1024;\n+\n+    // because `fold` takes ownership of the iterator,\n+    // we can't prevent it from dropping the memory,\n+    // so we have to bite the bullet and reallocate\n+    // for every iteration.\n+    b.iter(|| {\n+        let deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+\n+        // rotating a full deque doesn't move any memory.\n+        let mut deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        deque.rotate_left(len / 2);\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_try_fold(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    // Iterator::any uses Iterator::try_fold under the hood\n+    b.iter(|| {\n+        let mut b = false;\n+        into_iter_helper(&mut vec, |_| {}, |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+\n+        into_iter_helper(&mut vec, |d| d.rotate_left(len / 2), |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_next_chunk(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut buf = [0; 64];\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+    });\n+}\n+\n #[bench]\n fn bench_from_array_1000(b: &mut Bencher) {\n     const N: usize = 1000;"}, {"sha": "34bc0ce9177c402723a1ab6cd2eb02e1a4d439b4", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 184, "deletions": 1, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,5 +1,5 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n+use core::{array, fmt, mem::MaybeUninit, ops::Try, ptr};\n \n use crate::alloc::{Allocator, Global};\n \n@@ -52,6 +52,126 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        if self.inner.len < n {\n+            let len = self.inner.len;\n+            self.inner.clear();\n+            Err(len)\n+        } else {\n+            self.inner.drain(..n);\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.inner.len\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+                self.deque.head = self.deque.to_physical_idx(self.consumed);\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = head\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Because we incremented `guard.consumed`, the\n+                // deque effectively forgot the element, so we can take\n+                // ownership\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)?;\n+\n+        tail.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_fold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.inner.pop_back()\n+    }\n+\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut raw_arr = MaybeUninit::uninit_array();\n+        let raw_arr_ptr = raw_arr.as_mut_ptr().cast();\n+        let (head, tail) = self.inner.as_slices();\n+\n+        if head.len() >= N {\n+            // SAFETY: By manually adjusting the head and length of the deque, we effectively\n+            // make it forget the first `N` elements, so taking ownership of them is safe.\n+            unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, N) };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head`\n+            return Ok(unsafe { raw_arr.transpose().assume_init() });\n+        }\n+\n+        // SAFETY: Same argument as above.\n+        unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, head.len()) };\n+        let remaining = N - head.len();\n+\n+        if tail.len() >= remaining {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), remaining)\n+            };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head` and `tail`\n+            Ok(unsafe { raw_arr.transpose().assume_init() })\n+        } else {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), tail.len())\n+            };\n+            let init = head.len() + tail.len();\n+            // We completely drained all the deques elements.\n+            self.inner.head = 0;\n+            self.inner.len = 0;\n+            // SAFETY: We copied all elements from both slices to the beginning of the array, so\n+            // the given range is initialized.\n+            Err(unsafe { array::IntoIter::new_unchecked(raw_arr, 0..init) })\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -60,10 +180,73 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let len = self.inner.len;\n+        if len >= n {\n+            self.inner.truncate(len - n);\n+            Ok(())\n+        } else {\n+            self.inner.clear();\n+            Err(len)\n+        }\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = tail\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: See `try_fold`'s safety comment.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)?;\n+\n+        head.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_rfold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    #[inline]\n     fn is_empty(&self) -> bool {\n         self.inner.is_empty()\n     }"}, {"sha": "208b220c24a94ce0b10a8120604d863a4d23ef13", "filename": "library/core/src/result.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -525,8 +525,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_ok(), true);\n@@ -572,8 +570,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_err(), false);\n@@ -627,8 +623,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.ok(), Some(2));\n@@ -658,8 +652,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.err(), None);\n@@ -693,8 +685,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.as_ref(), Ok(&2));\n@@ -716,8 +706,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// fn mutate(r: &mut Result<i32, i32>) {\n     ///     match r.as_mut() {\n@@ -812,8 +800,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let k = 21;\n     ///\n@@ -841,8 +827,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n     ///\n@@ -968,8 +952,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(7);\n     /// assert_eq!(x.iter().next(), Some(&7));\n@@ -989,8 +971,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let mut x: Result<u32, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n@@ -1031,8 +1011,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```should_panic\n     /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n@@ -1160,8 +1138,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```should_panic\n     /// let x: Result<u32, &str> = Ok(10);\n     /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n@@ -1222,8 +1198,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// # #![feature(never_type)]\n     /// # #![feature(unwrap_infallible)]\n@@ -1259,8 +1233,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// # #![feature(never_type)]\n     /// # #![feature(unwrap_infallible)]\n@@ -1298,8 +1270,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Err(\"late error\");\n@@ -1383,8 +1353,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<u32, &str> = Err(\"late error\");\n@@ -1426,8 +1394,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n     /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n@@ -1456,8 +1422,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let default = 2;\n     /// let x: Result<u32, &str> = Ok(9);\n@@ -1487,8 +1451,6 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// fn count(x: &str) -> usize { x.len() }\n     ///\n@@ -1752,8 +1714,6 @@ impl<T, E> Result<Result<T, E>, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// #![feature(result_flattening)]\n     /// let x: Result<Result<&'static str, u32>, u32> = Ok(Ok(\"hello\"));\n@@ -1842,8 +1802,6 @@ impl<T, E> IntoIterator for Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// let x: Result<u32, &str> = Ok(5);\n     /// let v: Vec<u32> = x.into_iter().collect();"}, {"sha": "e83747845013d7df68938e38456a00bf61a9ac20", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -2730,8 +2730,10 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n     /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n-    /// (i.e. does not allocate), and *O*(*n*) worst-case. This function is also/ known as \"kth\n-    /// element\" in other libraries. It returns a triplet of the following from the reordered slice:\n+    /// (i.e. does not allocate), and *O*(*n*) on average. The worst-case performance is *O*(*n* log *n*).\n+    /// This function is also known as \"kth element\" in other libraries.\n+    ///\n+    /// It returns a triplet of the following from the reordered slice:\n     /// the subslice prior to `index`, the element at `index`, and the subslice after `index`;\n     /// accordingly, the values in those two subslices will respectively all be less-than-or-equal-to\n     /// and greater-than-or-equal-to the value of the element at `index`.\n@@ -2777,8 +2779,11 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index` using the comparator function.\n     /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n-    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n-    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following from\n+    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) on average.\n+    /// The worst-case performance is *O*(*n* log *n*). This function is also known as\n+    /// \"kth element\" in other libraries.\n+    ///\n+    /// It returns a triplet of the following from\n     /// the slice reordered according to the provided comparator function: the subslice prior to\n     /// `index`, the element at `index`, and the subslice after `index`; accordingly, the values in\n     /// those two subslices will respectively all be less-than-or-equal-to and greater-than-or-equal-to\n@@ -2829,8 +2834,11 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index` using the key extraction function.\n     /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n-    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n-    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following from\n+    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) on average.\n+    /// The worst-case performance is *O*(*n* log *n*).\n+    /// This function is also known as \"kth element\" in other libraries.\n+    ///\n+    /// It returns a triplet of the following from\n     /// the slice reordered according to the provided key extraction function: the subslice prior to\n     /// `index`, the element at `index`, and the subslice after `index`; accordingly, the values in\n     /// those two subslices will respectively all be less-than-or-equal-to and greater-than-or-equal-to"}, {"sha": "ab57fba6c9f2729c611ebe1b894f7241bb7cef16", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -284,6 +284,10 @@ impl<'a> Read for &'a FileDesc {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)\n     }\n+\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n+    }\n }\n \n impl AsInner<OwnedFd> for FileDesc {"}, {"sha": "489af776798ad6251b2c8f93837a5c42cf3d36ea", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -124,8 +124,10 @@\n //!\n //! ## Stack size\n //!\n-//! The default stack size is platform-dependent and subject to change. Currently it is 2MB on all\n-//! Tier-1 platforms. There are two ways to manually specify the stack size for spawned threads:\n+//! The default stack size is platform-dependent and subject to change.\n+//! Currently, it is 2 MiB on all Tier-1 platforms.\n+//!\n+//! There are two ways to manually specify the stack size for spawned threads:\n //!\n //! * Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n //! * Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack"}, {"sha": "56f96734bbbc7af2d9cadb4408baedd468fee0af", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1315,15 +1315,6 @@ impl Config {\n             } else {\n                 RustfmtState::Unavailable\n             };\n-        } else {\n-            // If using a system toolchain for bootstrapping, see if that has rustfmt available.\n-            let host = config.build;\n-            let rustfmt_path = config.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n-            let bin_root = config.out.join(host.triple).join(\"stage0\");\n-            if !rustfmt_path.starts_with(&bin_root) {\n-                // Using a system-provided toolchain; we shouldn't download rustfmt.\n-                *config.initial_rustfmt.borrow_mut() = RustfmtState::SystemToolchain(rustfmt_path);\n-            }\n         }\n \n         // Now that we've reached the end of our configuration, infer the"}, {"sha": "a027139df23979032eb231ee90ff3c9e015a0920", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -29,6 +29,7 @@ pub enum Profile {\n static SETTINGS_HASHES: &[&str] = &[\n     \"ea67e259dedf60d4429b6c349a564ffcd1563cf41c920a856d1f5b16b4701ac8\",\n     \"56e7bf011c71c5d81e0bf42e84938111847a810eee69d906bba494ea90b51922\",\n+    \"af1b5efe196aed007577899db9dae15d6dbc923d6fa42fa0934e68617ba9bbe0\",\n ];\n static VSCODE_SETTINGS: &str = include_str!(\"../etc/vscode_settings.json\");\n "}, {"sha": "b4f1506dc8f30c019aaaf0ec021eac9ceb6d6c15", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -435,6 +435,10 @@ impl Step for Rustfmt {\n             &[],\n         );\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n@@ -615,6 +619,10 @@ impl Step for Miri {\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         // miri tests need to know about the stage sysroot\n         cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n         cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n@@ -746,6 +754,10 @@ impl Step for Clippy {\n             &[],\n         );\n \n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n         cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n         let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());"}, {"sha": "dd01bfaa7252d77022b423ce858ea1951147accf", "filename": "src/etc/vscode_settings.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fetc%2Fvscode_settings.json", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Fetc%2Fvscode_settings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvscode_settings.json?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,7 +1,7 @@\n {\n     \"rust-analyzer.check.invocationLocation\": \"root\",\n     \"rust-analyzer.check.invocationStrategy\": \"once\",\n-    \"rust-analyzer.checkOnSave.overrideCommand\": [\n+    \"rust-analyzer.check.overrideCommand\": [\n         \"python3\",\n         \"x.py\",\n         \"check\",\n@@ -23,6 +23,6 @@\n         \"check\",\n         \"--json-output\"\n     ],\n-    \"rust-analyzer.cargo.sysroot\": \"./build/host/stage0-sysroot\",\n+    \"rust-analyzer.cargo.sysrootSrc\": \"./library\",\n     \"rust-analyzer.rustc.source\": \"./Cargo.toml\"\n }"}, {"sha": "8dbfaf4bbc93d4b814b00c1dd04f7db3d549e462", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -287,6 +287,16 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     } else {\n                         let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = match &*last {\n+                            ParentStackItem::Impl {\n+                                // impl Trait for &T { fn method(self); }\n+                                //\n+                                // When generating a function index with the above shape, we want it\n+                                // associated with `T`, not with the primitive reference type. It should\n+                                // show up as `T::method`, rather than `reference::method`, in the search\n+                                // results page.\n+                                for_: clean::Type::BorrowedRef { type_, .. },\n+                                ..\n+                            } => type_.def_id(&self.cache),\n                             ParentStackItem::Impl { for_, .. } => for_.def_id(&self.cache),\n                             ParentStackItem::Type(item_id) => item_id.as_def_id(),\n                         };"}, {"sha": "9ef0b501c085036149fb1c125971f1c02ec7a2e5", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 18, "deletions": 43, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -29,12 +29,12 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n pub(crate) use rustc_resolve::rustdoc::main_body_opts;\n+use rustc_resolve::rustdoc::may_be_doc_link;\n use rustc_span::edition::Edition;\n use rustc_span::{Span, Symbol};\n \n use once_cell::sync::Lazy;\n use std::borrow::Cow;\n-use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt::Write;\n@@ -1226,14 +1226,12 @@ pub(crate) struct MarkdownLink {\n \n pub(crate) fn markdown_links<R>(\n     md: &str,\n-    filter_map: impl Fn(MarkdownLink) -> Option<R>,\n+    preprocess_link: impl Fn(MarkdownLink) -> Option<R>,\n ) -> Vec<R> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n-    let links = RefCell::new(vec![]);\n-\n     // FIXME: remove this function once pulldown_cmark can provide spans for link definitions.\n     let locate = |s: &str, fallback: Range<usize>| unsafe {\n         let s_start = s.as_ptr();\n@@ -1265,46 +1263,23 @@ pub(crate) fn markdown_links<R>(\n         }\n     };\n \n-    let mut push = |link: BrokenLink<'_>| {\n-        let span = span_for_link(&link.reference, link.span);\n-        filter_map(MarkdownLink {\n-            kind: LinkType::ShortcutUnknown,\n-            link: link.reference.to_string(),\n-            range: span,\n-        })\n-        .map(|link| links.borrow_mut().push(link));\n-        None\n-    };\n-    let p = Parser::new_with_broken_link_callback(md, main_body_opts(), Some(&mut push))\n-        .into_offset_iter();\n-\n-    // There's no need to thread an IdMap through to here because\n-    // the IDs generated aren't going to be emitted anywhere.\n-    let mut ids = IdMap::new();\n-    let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids, HeadingOffset::H1));\n-\n-    for ev in iter {\n-        if let Event::Start(Tag::Link(\n-            // `<>` links cannot be intra-doc links so we skip them.\n-            kind @ (LinkType::Inline\n-            | LinkType::Reference\n-            | LinkType::ReferenceUnknown\n-            | LinkType::Collapsed\n-            | LinkType::CollapsedUnknown\n-            | LinkType::Shortcut\n-            | LinkType::ShortcutUnknown),\n-            dest,\n-            _,\n-        )) = ev.0\n-        {\n-            debug!(\"found link: {dest}\");\n-            let span = span_for_link(&dest, ev.1);\n-            filter_map(MarkdownLink { kind, link: dest.into_string(), range: span })\n-                .map(|link| links.borrow_mut().push(link));\n+    Parser::new_with_broken_link_callback(\n+        md,\n+        main_body_opts(),\n+        Some(&mut |link: BrokenLink<'_>| Some((link.reference, \"\".into()))),\n+    )\n+    .into_offset_iter()\n+    .filter_map(|(event, span)| match event {\n+        Event::Start(Tag::Link(link_type, dest, _)) if may_be_doc_link(link_type) => {\n+            preprocess_link(MarkdownLink {\n+                kind: link_type,\n+                range: span_for_link(&dest, span),\n+                link: dest.into_string(),\n+            })\n         }\n-    }\n-\n-    links.into_inner()\n+        _ => None,\n+    })\n+    .collect()\n }\n \n #[derive(Debug)]"}, {"sha": "2869a39613fa1360442f776846713b6235494960", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -39,10 +39,10 @@ use crate::html::{highlight, static_files};\n use askama::Template;\n use itertools::Itertools;\n \n-const ITEM_TABLE_OPEN: &str = \"<div class=\\\"item-table\\\">\";\n-const ITEM_TABLE_CLOSE: &str = \"</div>\";\n-const ITEM_TABLE_ROW_OPEN: &str = \"<div class=\\\"item-row\\\">\";\n-const ITEM_TABLE_ROW_CLOSE: &str = \"</div>\";\n+const ITEM_TABLE_OPEN: &str = \"<ul class=\\\"item-table\\\">\";\n+const ITEM_TABLE_CLOSE: &str = \"</ul>\";\n+const ITEM_TABLE_ROW_OPEN: &str = \"<li>\";\n+const ITEM_TABLE_ROW_CLOSE: &str = \"</li>\";\n \n // A component in a `use` path, like `string` in std::string::ToString\n struct PathComponent {\n@@ -338,14 +338,14 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 match *src {\n                     Some(src) => write!(\n                         w,\n-                        \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n+                        \"<div class=\\\"item-name\\\"><code>{}extern crate {} as {};\",\n                         visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n-                        \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n+                        \"<div class=\\\"item-name\\\"><code>{}extern crate {};\",\n                         visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n@@ -384,11 +384,11 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 let (stab_tags_before, stab_tags_after) = if stab_tags.is_empty() {\n                     (\"\", \"\")\n                 } else {\n-                    (\"<div class=\\\"item-right docblock-short\\\">\", \"</div>\")\n+                    (\"<div class=\\\"desc docblock-short\\\">\", \"</div>\")\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left\\\"{id}>\\\n+                    \"<div class=\\\"item-name\\\"{id}>\\\n                          <code>{vis}{imp}</code>\\\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n@@ -426,11 +426,11 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 let (docs_before, docs_after) = if docs.is_empty() {\n                     (\"\", \"\")\n                 } else {\n-                    (\"<div class=\\\"item-right docblock-short\\\">\", \"</div>\")\n+                    (\"<div class=\\\"desc docblock-short\\\">\", \"</div>\")\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left\\\">\\\n+                    \"<div class=\\\"item-name\\\">\\\n                         <a class=\\\"{class}\\\" href=\\\"{href}\\\" title=\\\"{title}\\\">{name}</a>\\\n                         {visibility_emoji}\\\n                         {unsafety_flag}\\"}, {"sha": "d18b56eb19c25d1d9c8d0a547193492d38a9a8bb", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -201,7 +201,7 @@ h1, h2, h3, h4, h5, h6,\n .mobile-topbar,\n .search-input,\n .search-results .result-name,\n-.item-left > a,\n+.item-name > a,\n .out-of-band,\n span.since,\n a.srclink,\n@@ -750,14 +750,16 @@ table,\n \n .item-table {\n \tdisplay: table;\n+\tpadding: 0;\n+\tmargin: 0;\n }\n-.item-row {\n+.item-table > li {\n \tdisplay: table-row;\n }\n-.item-left, .item-right {\n+.item-table > li > div {\n \tdisplay: table-cell;\n }\n-.item-left {\n+.item-table > li > .item-name {\n \tpadding-right: 1.25rem;\n }\n \n@@ -962,7 +964,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tpadding: 3px;\n \tmargin-bottom: 5px;\n }\n-.item-left .stab {\n+.item-name .stab {\n \tmargin-left: 0.3125em;\n }\n .stab {\n@@ -1695,7 +1697,7 @@ in storage.js\n \t}\n \n \t/* Display an alternating layout on tablets and phones */\n-\t.item-table, .item-row, .item-left, .item-right,\n+\t.item-table, .item-row, .item-table > li, .item-table > li > div,\n \t.search-results > a, .search-results > a > div {\n \t\tdisplay: block;\n \t}\n@@ -1704,7 +1706,7 @@ in storage.js\n \t.search-results > a {\n \t\tpadding: 5px 0px;\n \t}\n-\t.search-results > a > div.desc, .item-right {\n+\t.search-results > a > div.desc, .item-table > li > div.desc {\n \t\tpadding-left: 2em;\n \t}\n "}, {"sha": "d5e9010eb4ed98682e08976810fd35edad3fd0a6", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 67, "deletions": 32, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -38,7 +38,7 @@ impl JsonRenderer<'_> {\n                     Some(UrlFragment::UserWritten(_)) | None => *page_id,\n                 };\n \n-                (link.clone(), from_item_id(id.into(), self.tcx))\n+                (link.clone(), id_from_item_default(id.into(), self.tcx))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n@@ -50,7 +50,8 @@ impl JsonRenderer<'_> {\n             .collect();\n         let span = item.span(self.tcx);\n         let visibility = item.visibility(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, item_id, cfg: _, .. } = item;\n+        let clean::Item { name, item_id, .. } = item;\n+        let id = id_from_item(&item, self.tcx);\n         let inner = match *item.kind {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n@@ -69,7 +70,7 @@ impl JsonRenderer<'_> {\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id_with_name(item_id, self.tcx, name),\n+            id,\n             crate_id: item_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: span.and_then(|span| self.convert_span(span)),\n@@ -107,7 +108,7 @@ impl JsonRenderer<'_> {\n             Some(ty::Visibility::Public) => Visibility::Public,\n             Some(ty::Visibility::Restricted(did)) if did.is_crate_root() => Visibility::Crate,\n             Some(ty::Visibility::Restricted(did)) => Visibility::Restricted {\n-                parent: from_item_id(did.into(), self.tcx),\n+                parent: id_from_item_default(did.into(), self.tcx),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -204,21 +205,42 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-/// It generates an ID as follows:\n-///\n-/// `CRATE_ID:ITEM_ID[:NAME_ID]` (if there is no name, NAME_ID is not generated).\n-pub(crate) fn from_item_id(item_id: ItemId, tcx: TyCtxt<'_>) -> Id {\n-    from_item_id_with_name(item_id, tcx, None)\n+#[inline]\n+pub(crate) fn id_from_item_default(item_id: ItemId, tcx: TyCtxt<'_>) -> Id {\n+    id_from_item_inner(item_id, tcx, None, None)\n }\n \n-// FIXME: this function (and appending the name at the end of the ID) should be removed when\n-// reexports are not inlined anymore for json format. It should be done in #93518.\n-pub(crate) fn from_item_id_with_name(item_id: ItemId, tcx: TyCtxt<'_>, name: Option<Symbol>) -> Id {\n-    struct DisplayDefId<'a>(DefId, TyCtxt<'a>, Option<Symbol>);\n+/// It generates an ID as follows:\n+///\n+/// `CRATE_ID:ITEM_ID[:NAME_ID][-EXTRA]`:\n+///   * If there is no `name`, `NAME_ID` is not generated.\n+///   * If there is no `extra`, `EXTRA` is not generated.\n+///\n+/// * `name` is the item's name if available (it's not for impl blocks for example).\n+/// * `extra` is used for reexports: it contains the ID of the reexported item. It is used to allow\n+///   to have items with the same name but different types to both appear in the generated JSON.\n+pub(crate) fn id_from_item_inner(\n+    item_id: ItemId,\n+    tcx: TyCtxt<'_>,\n+    name: Option<Symbol>,\n+    extra: Option<&Id>,\n+) -> Id {\n+    struct DisplayDefId<'a, 'b>(DefId, TyCtxt<'a>, Option<&'b Id>, Option<Symbol>);\n \n-    impl<'a> fmt::Display for DisplayDefId<'a> {\n+    impl<'a, 'b> fmt::Display for DisplayDefId<'a, 'b> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let DisplayDefId(def_id, tcx, name) = self;\n+            let DisplayDefId(def_id, tcx, extra, name) = self;\n+            // We need this workaround because primitive types' DefId actually refers to\n+            // their parent module, which isn't present in the output JSON items. So\n+            // instead, we directly get the primitive symbol and convert it to u32 to\n+            // generate the ID.\n+            let s;\n+            let extra = if let Some(e) = extra {\n+                s = format!(\"-{}\", e.0);\n+                &s\n+            } else {\n+                \"\"\n+            };\n             let name = match name {\n                 Some(name) => format!(\":{}\", name.as_u32()),\n                 None => {\n@@ -240,18 +262,33 @@ pub(crate) fn from_item_id_with_name(item_id: ItemId, tcx: TyCtxt<'_>, name: Opt\n                     }\n                 }\n             };\n-            write!(f, \"{}:{}{}\", self.0.krate.as_u32(), u32::from(self.0.index), name)\n+            write!(f, \"{}:{}{name}{extra}\", def_id.krate.as_u32(), u32::from(def_id.index))\n         }\n     }\n \n     match item_id {\n-        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, name))),\n-        ItemId::Blanket { for_, impl_id } => {\n-            Id(format!(\"b:{}-{}\", DisplayDefId(impl_id, tcx, None), DisplayDefId(for_, tcx, name)))\n-        }\n-        ItemId::Auto { for_, trait_ } => {\n-            Id(format!(\"a:{}-{}\", DisplayDefId(trait_, tcx, None), DisplayDefId(for_, tcx, name)))\n+        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, extra, name))),\n+        ItemId::Blanket { for_, impl_id } => Id(format!(\n+            \"b:{}-{}\",\n+            DisplayDefId(impl_id, tcx, None, None),\n+            DisplayDefId(for_, tcx, extra, name)\n+        )),\n+        ItemId::Auto { for_, trait_ } => Id(format!(\n+            \"a:{}-{}\",\n+            DisplayDefId(trait_, tcx, None, None),\n+            DisplayDefId(for_, tcx, extra, name)\n+        )),\n+    }\n+}\n+\n+pub(crate) fn id_from_item(item: &clean::Item, tcx: TyCtxt<'_>) -> Id {\n+    match *item.kind {\n+        clean::ItemKind::ImportItem(ref import) => {\n+            let extra =\n+                import.source.did.map(ItemId::from).map(|i| id_from_item_inner(i, tcx, None, None));\n+            id_from_item_inner(item.item_id, tcx, item.name, extra.as_ref())\n         }\n+        _ => id_from_item_inner(item.item_id, tcx, item.name, None),\n     }\n }\n \n@@ -525,7 +562,7 @@ impl FromWithTcx<clean::Path> for Path {\n     fn from_tcx(path: clean::Path, tcx: TyCtxt<'_>) -> Path {\n         Path {\n             name: path.whole_name(),\n-            id: from_item_id(path.def_id().into(), tcx),\n+            id: id_from_item_default(path.def_id().into(), tcx),\n             args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n         }\n     }\n@@ -702,7 +739,7 @@ impl FromWithTcx<clean::Import> for Import {\n         Import {\n             source: import.source.path.whole_name(),\n             name,\n-            id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n+            id: import.source.did.map(ItemId::from).map(|i| id_from_item_default(i, tcx)),\n             glob,\n         }\n     }\n@@ -791,7 +828,7 @@ fn ids(items: impl IntoIterator<Item = clean::Item>, tcx: TyCtxt<'_>) -> Vec<Id>\n     items\n         .into_iter()\n         .filter(|x| !x.is_stripped() && !x.is_keyword())\n-        .map(|i| from_item_id_with_name(i.item_id, tcx, i.name))\n+        .map(|i| id_from_item(&i, tcx))\n         .collect()\n }\n \n@@ -801,12 +838,10 @@ fn ids_keeping_stripped(\n ) -> Vec<Option<Id>> {\n     items\n         .into_iter()\n-        .map(|i| {\n-            if !i.is_stripped() && !i.is_keyword() {\n-                Some(from_item_id_with_name(i.item_id, tcx, i.name))\n-            } else {\n-                None\n-            }\n-        })\n+        .map(\n+            |i| {\n+                if !i.is_stripped() && !i.is_keyword() { Some(id_from_item(&i, tcx)) } else { None }\n+            },\n+        )\n         .collect()\n }"}, {"sha": "08bceb59cfde683c686bae3e66eb7b6baaf2872f", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -28,7 +28,7 @@ use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-use crate::json::conversions::{from_item_id, from_item_id_with_name, IntoWithTcx};\n+use crate::json::conversions::{id_from_item, id_from_item_default, IntoWithTcx};\n use crate::{clean, try_err};\n \n #[derive(Clone)]\n@@ -58,7 +58,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id_with_name(item.item_id, self.tcx, item.name)\n+                        id_from_item(&item, self.tcx)\n                     })\n                     .collect()\n             })\n@@ -89,7 +89,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n \n                         if item.item_id.is_local() || is_primitive_impl {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id_with_name(item.item_id, self.tcx, item.name))\n+                            Some(id_from_item(&item, self.tcx))\n                         } else {\n                             None\n                         }\n@@ -150,7 +150,6 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let name = item.name;\n         let item_id = item.item_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             let can_be_ignored = match new_item.inner {\n@@ -193,10 +192,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 | types::ItemEnum::Macro(_)\n                 | types::ItemEnum::ProcMacro(_) => false,\n             };\n-            let removed = self\n-                .index\n-                .borrow_mut()\n-                .insert(from_item_id_with_name(item_id, self.tcx, name), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(new_item.id.clone(), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is\n@@ -207,6 +203,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 if !can_be_ignored {\n                     assert_eq!(old_item, new_item);\n                 }\n+                trace!(\"replaced {:?}\\nwith {:?}\", old_item, new_item);\n             }\n         }\n \n@@ -246,7 +243,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(&self.cache.external_paths)\n                 .map(|(&k, &(ref path, kind))| {\n                     (\n-                        from_item_id(k.into(), self.tcx),\n+                        id_from_item_default(k.into(), self.tcx),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path: path.iter().map(|s| s.to_string()).collect(),"}, {"sha": "920a3b22f25a2f610cbe93f50d07a16a3e6ce5ce", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -884,7 +884,8 @@ fn preprocess_link(\n     let mut parts = stripped.split('#');\n \n     let link = parts.next().unwrap();\n-    if link.trim().is_empty() {\n+    let link = link.trim();\n+    if link.is_empty() {\n         // This is an anchor to an element of the current page, nothing to do in here!\n         return None;\n     }\n@@ -897,7 +898,7 @@ fn preprocess_link(\n     // Parse and strip the disambiguator from the link, if present.\n     let (disambiguator, path_str, link_text) = match Disambiguator::from_str(link) {\n         Ok(Some((d, path, link_text))) => (Some(d), path.trim(), link_text.trim()),\n-        Ok(None) => (None, link.trim(), link.trim()),\n+        Ok(None) => (None, link, link),\n         Err((err_msg, relative_range)) => {\n             // Only report error if we would not have ignored this link. See issue #83859.\n             if !should_ignore_link_with_disambiguators(link) {"}, {"sha": "8bbf9f87b43e51652f8ef17349e0f659a42da9ad", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -821,8 +821,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn checked_binop_checks_overflow(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n-        ecx.tcx.sess.overflow_checks()\n+    fn ignore_checkable_overflow_assertions(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        !ecx.tcx.sess.overflow_checks()\n     }\n \n     #[inline(always)]"}, {"sha": "d6f019016a5a7a7959be2497395c47f3928aa3eb", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: -O -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(dyn_star)]\n \n use std::mem::MaybeUninit;\n use std::num::NonZeroU64;\n@@ -279,3 +280,11 @@ pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x\n }\n+\n+// CHECK: { {{\\{\\}\\*|ptr}}, {{.+}} } @dyn_star({{\\{\\}\\*|ptr}} noundef %x.0, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %x.1)\n+// Expect an ABI something like `{ {}*, [3 x i64]* }`, but that's hard to match on generically,\n+// so do like the `trait_box` test and just match on `{{.+}}` for the vtable.\n+#[no_mangle]\n+pub fn dyn_star(x: dyn* Drop) -> dyn* Drop {\n+  x\n+}"}, {"sha": "0b0b890b2c99a0343c495c35b78e11742defee2f", "filename": "tests/codegen/inherit_overflow.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fcodegen%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fcodegen%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Finherit_overflow.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Zmir-enable-passes=+Inline,+ConstProp --crate-type lib\n+// revisions: ASSERT NOASSERT\n+//[ASSERT] compile-flags: -Coverflow-checks=on\n+//[NOASSERT] compile-flags: -Coverflow-checks=off\n+\n+// CHECK-LABEL: define{{.*}} @assertion\n+// ASSERT: call void @_ZN4core9panicking5panic17h\n+// NOASSERT: ret i8 0\n+#[no_mangle]\n+pub fn assertion() -> u8 {\n+    // Optimized MIR will replace this `CheckedBinaryOp` by `const (0, true)`.\n+    // Verify that codegen does or does not emit the panic.\n+    <u8 as std::ops::Add>::add(255, 1)\n+}"}, {"sha": "900061a484b3884b85d103d4c532b93ba6ac05d5", "filename": "tests/mir-opt/const_prop/bad_op_div_by_zero.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -24,9 +24,10 @@\n           StorageLive(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _3 = _1;                         // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _4 = Eq(_3, const 0_i32);        // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n+-         assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _3 = const 0_i32;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n +         _4 = const true;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-          assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n++         assert(!const true, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb1: {"}, {"sha": "d03c23a3fb56c1893155f6bab9c589ba2f15bb7c", "filename": "tests/mir-opt/const_prop/inherit_overflow.main.ConstProp.diff", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,39 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n+      let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      scope 1 {\n+      }\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = const (0_u8, true);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n+          return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "541a8c5c3af28779366e6b21334e5681c5497933", "filename": "tests/mir-opt/const_prop/inherit_overflow.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: ConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n+\n+// EMIT_MIR inherit_overflow.main.ConstProp.diff\n+fn main() {\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n+    let _ = <u8 as std::ops::Add>::add(255, 1);\n+}"}, {"sha": "944afed8f465abd701e2c10dc3f59997cfc1364e", "filename": "tests/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -61,7 +61,7 @@\n -         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n +         _9 = const i32::MAX;             // scope 4 at $DIR/checked.rs:+6:13: +6:14\n +         _10 = CheckedAdd(const i32::MAX, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n-+         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n       }\n   \n       bb2: {"}, {"sha": "29781e9ce18866feb12327d4f7c7378fcbce7e6f", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -5,26 +5,34 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n       let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       scope 1 {\n       }\n-      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:7:13: 7:47\n-          debug self => _1;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          debug other => _2;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _3: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _1 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _2 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _3 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n           return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "f4aba60f0c801666dc9a4b0031d85d781cd63111", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,8 +1,9 @@\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DataflowConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n \n // EMIT_MIR inherit_overflow.main.DataflowConstProp.diff\n fn main() {\n-    // After inlining, this will contain a `CheckedBinaryOp`. The overflow\n-    // must be ignored by the constant propagation to avoid triggering a panic.\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n     let _ = <u8 as std::ops::Add>::add(255, 1);\n }"}, {"sha": "7147be43ca5e36eb180f456633abdf25a9c082e7", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -72,3 +72,10 @@ pub fn assume() {\n         std::intrinsics::assume(true);\n     }\n }\n+\n+// EMIT_MIR lower_intrinsics.with_overflow.LowerIntrinsics.diff\n+pub fn with_overflow(a: i32, b: i32) {\n+    let _x = core::intrinsics::add_with_overflow(a, b);\n+    let _y = core::intrinsics::sub_with_overflow(a, b);\n+    let _z = core::intrinsics::mul_with_overflow(a, b);\n+}"}, {"sha": "9870a70dec5eed17801559be9e1c7980d0ea588a", "filename": "tests/mir-opt/lower_intrinsics.with_overflow.LowerIntrinsics.diff", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,83 @@\n+- // MIR for `with_overflow` before LowerIntrinsics\n++ // MIR for `with_overflow` after LowerIntrinsics\n+  \n+  fn with_overflow(_1: i32, _2: i32) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:22: +0:23\n+      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:30: +0:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:38: +0:38\n+      let _3: (i32, bool);                 // in scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+      let mut _4: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+      let mut _5: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+      let mut _7: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+      let mut _8: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+      let mut _10: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+      let mut _11: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+      scope 1 {\n+          debug _x => _3;                  // in scope 1 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+          let _6: (i32, bool);             // in scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+          scope 2 {\n+              debug _y => _6;              // in scope 2 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+              let _9: (i32, bool);         // in scope 2 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+              scope 3 {\n+                  debug _z => _9;          // in scope 3 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+          StorageLive(_4);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+          _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+-         _3 = add_with_overflow::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:78:14: 78:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {add_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _3 = CheckedAdd(move _4, move _5); // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n++         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:54: +1:55\n+          StorageDead(_4);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:54: +1:55\n+          StorageLive(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+          StorageLive(_7);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+          _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+          StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+          _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+-         _6 = sub_with_overflow::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:79:14: 79:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {sub_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _6 = CheckedSub(move _7, move _8); // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n++         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n+      }\n+  \n+      bb2: {\n+          StorageDead(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:54: +2:55\n+          StorageDead(_7);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:54: +2:55\n+          StorageLive(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+          StorageLive(_10);                // scope 2 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+          _10 = _1;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+          StorageLive(_11);                // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+          _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+-         _9 = mul_with_overflow::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:80:14: 80:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {mul_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _9 = CheckedMul(move _10, move _11); // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n++         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n+      }\n+  \n+      bb3: {\n+          StorageDead(_11);                // scope 2 at $DIR/lower_intrinsics.rs:+3:54: +3:55\n+          StorageDead(_10);                // scope 2 at $DIR/lower_intrinsics.rs:+3:54: +3:55\n+          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:+0:38: +4:2\n+          StorageDead(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          StorageDead(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          StorageDead(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "636382a9169916f13e7d8a8191c5cf4b1e033764", "filename": "tests/rustdoc-gui/huge-collection-of-constants.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fhuge-collection-of-constants.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fhuge-collection-of-constants.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fhuge-collection-of-constants.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -3,7 +3,7 @@\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/huge_amount_of_consts/index.html\"\n \n compare-elements-position-near-false: (\n-    \"//*[@class='item-table']//div[last()-1]\",\n-    \"//*[@class='item-table']//div[last()-3]\",\n+    \"//ul[@class='item-table']/li[last()-1]\",\n+    \"//ul[@class='item-table']/li[last()-3]\",\n     {\"y\": 12},\n )"}, {"sha": "7a219bd54c3e65e4c90c76167620c6b2e23cd51b", "filename": "tests/rustdoc-gui/item-summary-table.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fitem-summary-table.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fitem-summary-table.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fitem-summary-table.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,6 +1,6 @@\n // This test ensures that <table> elements aren't display in items summary.\n goto: \"file://\" + |DOC_PATH| + \"/lib2/summary_table/index.html\"\n // We check that we picked the right item first.\n-assert-text: (\".item-table .item-left\", \"Foo\")\n+assert-text: (\".item-table .item-name\", \"Foo\")\n // Then we check that its summary is empty.\n-assert-false: \".item-table .item-right\"\n+assert-false: \".item-table .desc\""}, {"sha": "412e475dcc9b80f51511a7a45050bd680335895f", "filename": "tests/rustdoc-gui/label-next-to-symbol.goml", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -9,58 +9,58 @@ assert: (\".stab.portability\")\n \n // make sure that deprecated and portability have the right colors\n assert-css: (\n-    \".item-table .item-left .stab.deprecated\",\n+    \".item-table .item-name .stab.deprecated\",\n     { \"background-color\": \"rgb(255, 245, 214)\" },\n )\n assert-css: (\n-    \".item-table .item-left .stab.portability\",\n+    \".item-table .item-name .stab.portability\",\n     { \"background-color\": \"rgb(255, 245, 214)\" },\n )\n \n // table like view\n-assert-css: (\".item-right.docblock-short\", { \"padding-left\": \"0px\" })\n+assert-css: (\".desc.docblock-short\", { \"padding-left\": \"0px\" })\n compare-elements-position-near: (\n-    \"//*[@class='item-left']//a[text()='replaced_function']\",\n-    \".item-left .stab.deprecated\",\n+    \"//*[@class='item-name']//a[text()='replaced_function']\",\n+    \".item-name .stab.deprecated\",\n     {\"y\": 2},\n )\n compare-elements-position: (\n-    \".item-left .stab.deprecated\",\n-    \".item-left .stab.portability\",\n+    \".item-name .stab.deprecated\",\n+    \".item-name .stab.portability\",\n     (\"y\"),\n )\n \n // Ensure no wrap\n compare-elements-position: (\n-    \"//*[@class='item-left']//a[text()='replaced_function']/..\",\n-    \"//*[@class='item-right docblock-short'][text()='a thing with a label']\",\n+    \"//*[@class='item-name']//a[text()='replaced_function']/..\",\n+    \"//*[@class='desc docblock-short'][text()='a thing with a label']\",\n     (\"y\"),\n )\n \n \n // Mobile view\n size: (600, 600)\n // staggered layout with 2em spacing\n-assert-css: (\".item-right.docblock-short\", { \"padding-left\": \"32px\" })\n+assert-css: (\".desc.docblock-short\", { \"padding-left\": \"32px\" })\n compare-elements-position-near: (\n-    \"//*[@class='item-left']//a[text()='replaced_function']\",\n-    \".item-left .stab.deprecated\",\n+    \"//*[@class='item-name']//a[text()='replaced_function']\",\n+    \".item-name .stab.deprecated\",\n     {\"y\": 2},\n )\n compare-elements-position: (\n-    \".item-left .stab.deprecated\",\n-    \".item-left .stab.portability\",\n+    \".item-name .stab.deprecated\",\n+    \".item-name .stab.portability\",\n     (\"y\"),\n )\n \n // Ensure wrap\n compare-elements-position-false: (\n-    \"//*[@class='item-left']//a[text()='replaced_function']/..\",\n-    \"//*[@class='item-right docblock-short'][text()='a thing with a label']\",\n+    \"//*[@class='item-name']//a[text()='replaced_function']/..\",\n+    \"//*[@class='desc docblock-short'][text()='a thing with a label']\",\n     (\"y\"),\n )\n compare-elements-position-false: (\n-    \".item-left .stab.deprecated\",\n-    \"//*[@class='item-right docblock-short'][text()='a thing with a label']\",\n+    \".item-name .stab.deprecated\",\n+    \"//*[@class='desc docblock-short'][text()='a thing with a label']\",\n     (\"y\"),\n )"}, {"sha": "23823f8b6c7918f1712700e188cf1bd420b622fb", "filename": "tests/rustdoc-gui/module-items-font.goml", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fmodule-items-font.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fmodule-items-font.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fmodule-items-font.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,7 +1,7 @@\n // This test checks that the correct font is used on module items (in index.html pages).\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n assert-css: (\n-    \".item-table .item-left > a\",\n+    \".item-table .item-name > a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n     ALL,\n )\n@@ -13,55 +13,55 @@ assert-css: (\n \n // modules\n assert-css: (\n-    \"#modules + .item-table .item-left a\",\n+    \"#modules + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#modules + .item-table .item-right.docblock-short\",\n+    \"#modules + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )\n // structs\n assert-css: (\n-    \"#structs + .item-table .item-left a\",\n+    \"#structs + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#structs + .item-table .item-right.docblock-short\",\n+    \"#structs + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )\n // enums\n assert-css: (\n-    \"#enums + .item-table .item-left a\",\n+    \"#enums + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#enums + .item-table .item-right.docblock-short\",\n+    \"#enums + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )\n // traits\n assert-css: (\n-    \"#traits + .item-table .item-left a\",\n+    \"#traits + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#traits + .item-table .item-right.docblock-short\",\n+    \"#traits + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )\n // functions\n assert-css: (\n-    \"#functions + .item-table .item-left a\",\n+    \"#functions + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#functions + .item-table .item-right.docblock-short\",\n+    \"#functions + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )\n // keywords\n assert-css: (\n-    \"#keywords + .item-table .item-left a\",\n+    \"#keywords + .item-table .item-name a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n )\n assert-css: (\n-    \"#keywords + .item-table .item-right.docblock-short\",\n+    \"#keywords + .item-table .desc.docblock-short\",\n     {\"font-family\": '\"Source Serif 4\", NanumBarunGothic, serif'},\n )"}, {"sha": "a6d51709019e49bc7c5cdf34b89d005a62b8e323", "filename": "tests/rustdoc-gui/sidebar.goml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fsidebar.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Fsidebar.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsidebar.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -70,8 +70,8 @@ assert-text: (\".sidebar-elems section ul > li:nth-child(8)\", \"Functions\")\n assert-text: (\".sidebar-elems section ul > li:nth-child(9)\", \"Type Definitions\")\n assert-text: (\".sidebar-elems section ul > li:nth-child(10)\", \"Unions\")\n assert-text: (\".sidebar-elems section ul > li:nth-child(11)\", \"Keywords\")\n-assert-text: (\"#structs + .item-table .item-left > a\", \"Foo\")\n-click: \"#structs + .item-table .item-left > a\"\n+assert-text: (\"#structs + .item-table .item-name > a\", \"Foo\")\n+click: \"#structs + .item-table .item-name > a\"\n \n // PAGE: struct.Foo.html\n assert-count: (\".sidebar .location\", 1)\n@@ -103,8 +103,8 @@ assert-text: (\".sidebar-elems > section ul.block > li:nth-child(2)\", \"Structs\")\n assert-text: (\".sidebar-elems > section ul.block > li:nth-child(3)\", \"Traits\")\n assert-text: (\".sidebar-elems > section ul.block > li:nth-child(4)\", \"Functions\")\n assert-text: (\".sidebar-elems > section ul.block > li:nth-child(5)\", \"Type Definitions\")\n-assert-text: (\"#functions + .item-table .item-left > a\", \"foobar\")\n-click: \"#functions + .item-table .item-left > a\"\n+assert-text: (\"#functions + .item-table .item-name > a\", \"foobar\")\n+click: \"#functions + .item-table .item-name > a\"\n \n // PAGE: fn.foobar.html\n // In items containing no items (like functions or constants) and in modules, we have no\n@@ -127,7 +127,7 @@ assert-text: (\".sidebar > .location\", \"Module sub_sub_module\")\n // We check that we don't have the crate list.\n assert-false: \".sidebar-elems .crate\"\n assert-text: (\".sidebar-elems > section ul > li:nth-child(1)\", \"Functions\")\n-assert-text: (\"#functions + .item-table .item-left > a\", \"foo\")\n+assert-text: (\"#functions + .item-table .item-name > a\", \"foo\")\n \n // Links to trait implementations in the sidebar should not wrap even if they are long.\n goto: \"file://\" + |DOC_PATH| + \"/lib2/struct.HasALongTraitWithParams.html\""}, {"sha": "9d2577178c08a3ace936fab335e0a0f10fac70e6", "filename": "tests/rustdoc-gui/unsafe-fn.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Funsafe-fn.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-gui%2Funsafe-fn.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Funsafe-fn.goml?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -19,7 +19,7 @@ define-function: (\n         local-storage: {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}\n         // We reload the page so the local storage settings are being used.\n         reload:\n-        assert-css: (\".item-left sup\", {\"color\": |color|})\n+        assert-css: (\".item-name sup\", {\"color\": |color|})\n     },\n )\n "}, {"sha": "f90be6d1bfd3514859914b3b5ec9988a9aee4843", "filename": "tests/rustdoc-js-std/reference-shrink.js", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-js-std%2Freference-shrink.js", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-js-std%2Freference-shrink.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Freference-shrink.js?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,8 @@\n+// exact-check\n+\n+const QUERY = 'reference::shrink';\n+\n+const EXPECTED = {\n+    // avoid including the method that's not going to be in the HTML\n+    'others': [],\n+};"}, {"sha": "2314a4eb90940368e3f31b9abf188e3f10fb0c44", "filename": "tests/rustdoc-json/reexport/same_name_different_types.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/107677>.\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+pub mod nested {\n+    // @set foo_struct = \"$.index[*][?(@.docs == 'Foo the struct')].id\"\n+\n+    /// Foo the struct\n+    pub struct Foo {}\n+\n+    // @set foo_fn = \"$.index[*][?(@.docs == 'Foo the function')].id\"\n+\n+    #[allow(non_snake_case)]\n+    /// Foo the function\n+    pub fn Foo() {}\n+}\n+\n+// @ismany \"$.index[*][?(@.inner.name == 'Foo' && @.kind == 'import')].inner.id\" $foo_fn $foo_struct\n+// @ismany \"$.index[*][?(@.inner.name == 'Bar' && @.kind == 'import')].inner.id\" $foo_fn $foo_struct\n+\n+// @count \"$.index[*][?(@.inner.name == 'Foo' && @.kind == 'import')]\" 2\n+pub use nested::Foo;\n+// @count \"$.index[*][?(@.inner.name == 'Bar' && @.kind == 'import')]\" 2\n+pub use Foo as Bar;"}, {"sha": "8335fc902cc5b7c7b4e1fe40b8b0b9e23cd9e4fd", "filename": "tests/rustdoc-ui/intra-doc/proc-macro-doc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-ui%2Fintra-doc%2Fproc-macro-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-ui%2Fintra-doc%2Fproc-macro-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fproc-macro-doc.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: --crate-type proc-macro\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+/// [`Unpin`]\n+#[proc_macro_derive(F)]\n+pub fn derive_(t: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    t\n+}\n+\n+/// [`Vec`]\n+#[proc_macro_attribute]\n+pub fn attr(t: proc_macro::TokenStream, _: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    t\n+}\n+\n+/// [`std::fs::File`]\n+#[proc_macro]\n+pub fn func(t: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    t\n+}"}, {"sha": "741a7f51a77e25a04d6cb5eaf0cc22987772ea97", "filename": "tests/rustdoc-ui/intra-doc/unknown-disambiguator.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-ui%2Fintra-doc%2Funknown-disambiguator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc-ui%2Fintra-doc%2Funknown-disambiguator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Funknown-disambiguator.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -20,22 +20,6 @@ LL | //! Linking to [foo@banana] and [`bar@banana!()`].\n    |\n    = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n \n-error: unknown disambiguator `foo`\n-  --> $DIR/unknown-disambiguator.rs:10:34\n-   |\n-LL | //! And with weird backticks: [``foo@hello``] [foo`@`hello].\n-   |                                  ^^^\n-   |\n-   = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n-\n-error: unknown disambiguator `foo`\n-  --> $DIR/unknown-disambiguator.rs:10:48\n-   |\n-LL | //! And with weird backticks: [``foo@hello``] [foo`@`hello].\n-   |                                                ^^^\n-   |\n-   = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n-\n error: unknown disambiguator ``\n   --> $DIR/unknown-disambiguator.rs:7:31\n    |\n@@ -52,5 +36,21 @@ LL | //! And to [no disambiguator](@nectarine) and [another](@apricot!()).\n    |\n    = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n \n+error: unknown disambiguator `foo`\n+  --> $DIR/unknown-disambiguator.rs:10:34\n+   |\n+LL | //! And with weird backticks: [``foo@hello``] [foo`@`hello].\n+   |                                  ^^^\n+   |\n+   = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n+\n+error: unknown disambiguator `foo`\n+  --> $DIR/unknown-disambiguator.rs:10:48\n+   |\n+LL | //! And with weird backticks: [``foo@hello``] [foo`@`hello].\n+   |                                                ^^^\n+   |\n+   = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n+\n error: aborting due to 6 previous errors\n "}, {"sha": "a10c84f2cacc1c93331b2e1152c1b855d1b4ee38", "filename": "tests/rustdoc/cfg_doc_reexport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fcfg_doc_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fcfg_doc_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fcfg_doc_reexport.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -5,8 +5,8 @@\n #![no_core]\n \n // @has 'foo/index.html'\n-// @has - '//*[@class=\"item-left\"]/*[@class=\"stab portability\"]' 'foobar'\n-// @has - '//*[@class=\"item-left\"]/*[@class=\"stab portability\"]' 'bar'\n+// @has - '//*[@class=\"item-name\"]/*[@class=\"stab portability\"]' 'foobar'\n+// @has - '//*[@class=\"item-name\"]/*[@class=\"stab portability\"]' 'bar'\n \n #[doc(cfg(feature = \"foobar\"))]\n mod imp_priv {"}, {"sha": "51860441b359ead48b0e030d3a2abc22ac8e06b0", "filename": "tests/rustdoc/deprecated.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdeprecated.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,14 +1,14 @@\n-// @has deprecated/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n+// @has deprecated/index.html '//*[@class=\"item-name\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n-// @has - '//*[@class=\"item-right docblock-short\"]' 'Deprecated docs'\n+// @has - '//*[@class=\"desc docblock-short\"]' 'Deprecated docs'\n \n // @has deprecated/struct.S.html '//*[@class=\"stab deprecated\"]' \\\n //      'Deprecated since 1.0.0: text'\n /// Deprecated docs\n #[deprecated(since = \"1.0.0\", note = \"text\")]\n pub struct S;\n \n-// @matches deprecated/index.html '//*[@class=\"item-right docblock-short\"]' '^Docs'\n+// @matches deprecated/index.html '//*[@class=\"desc docblock-short\"]' '^Docs'\n /// Docs\n pub struct T;\n "}, {"sha": "c4702d4109e3ea3dbc7cd5e1c00b0177bdfe8168", "filename": "tests/rustdoc/doc-cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-cfg.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -12,7 +12,7 @@ pub struct Portable;\n // @has doc_cfg/unix_only/index.html \\\n //  '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\\n //  'Available on Unix only.'\n-// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\AARM\\Z'\n+// @matches - '//*[@class=\"item-name\"]//*[@class=\"stab portability\"]' '\\AARM\\Z'\n // @count - '//*[@class=\"stab portability\"]' 2\n #[doc(cfg(unix))]\n pub mod unix_only {\n@@ -42,7 +42,7 @@ pub mod unix_only {\n // @has doc_cfg/wasi_only/index.html \\\n //  '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\\n //  'Available on WASI only.'\n-// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\AWebAssembly\\Z'\n+// @matches - '//*[@class=\"item-name\"]//*[@class=\"stab portability\"]' '\\AWebAssembly\\Z'\n // @count - '//*[@class=\"stab portability\"]' 2\n #[doc(cfg(target_os = \"wasi\"))]\n pub mod wasi_only {\n@@ -74,7 +74,7 @@ pub mod wasi_only {\n \n // the portability header is different on the module view versus the full view\n // @has doc_cfg/index.html\n-// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n+// @matches - '//*[@class=\"item-name\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n \n // @has doc_cfg/fn.uses_target_feature.html\n // @has - '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\"}, {"sha": "12846c5c17ad6da2c4f60dc5382ed36080b9e692", "filename": "tests/rustdoc/duplicate-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fduplicate-cfg.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -2,8 +2,8 @@\n #![feature(doc_cfg)]\n \n // @has 'foo/index.html'\n-// @matches '-' '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '^sync$'\n-// @has '-' '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]/@title' 'Available on crate feature `sync` only'\n+// @matches '-' '//*[@class=\"item-name\"]//*[@class=\"stab portability\"]' '^sync$'\n+// @has '-' '//*[@class=\"item-name\"]//*[@class=\"stab portability\"]/@title' 'Available on crate feature `sync` only'\n \n // @has 'foo/struct.Foo.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'sync'"}, {"sha": "58fe8173e038103fc81cfab5b1b2538fcbf309a5", "filename": "tests/rustdoc/glob-shadowing-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fglob-shadowing-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fglob-shadowing-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fglob-shadowing-const.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -15,6 +15,6 @@ mod sub4 {\n pub use sub4::inner::*;\n \n // @has 'foo/index.html'\n-// @has - '//div[@class=\"item-right docblock-short\"]' '1'\n-// @!has - '//div[@class=\"item-right docblock-short\"]' '0'\n+// @has - '//div[@class=\"desc docblock-short\"]' '1'\n+// @!has - '//div[@class=\"desc docblock-short\"]' '0'\n fn main() { assert_eq!(X, 1); }"}, {"sha": "c117b9d6489465b27ca3afc9be20e145b631c674", "filename": "tests/rustdoc/glob-shadowing.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fglob-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fglob-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fglob-shadowing.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,17 +1,17 @@\n // @has 'glob_shadowing/index.html'\n-// @count - '//div[@class=\"item-left\"]' 6\n-// @!has - '//div[@class=\"item-right docblock-short\"]' 'sub1::describe'\n-// @has - '//div[@class=\"item-right docblock-short\"]' 'sub2::describe'\n+// @count - '//div[@class=\"item-name\"]' 6\n+// @!has - '//div[@class=\"desc docblock-short\"]' 'sub1::describe'\n+// @has - '//div[@class=\"desc docblock-short\"]' 'sub2::describe'\n \n-// @!has - '//div[@class=\"item-right docblock-short\"]' 'sub1::describe2'\n+// @!has - '//div[@class=\"desc docblock-short\"]' 'sub1::describe2'\n \n-// @!has - '//div[@class=\"item-right docblock-short\"]' 'sub1::prelude'\n-// @has - '//div[@class=\"item-right docblock-short\"]' 'mod::prelude'\n+// @!has - '//div[@class=\"desc docblock-short\"]' 'sub1::prelude'\n+// @has - '//div[@class=\"desc docblock-short\"]' 'mod::prelude'\n \n-// @has - '//div[@class=\"item-right docblock-short\"]' 'sub1::Foo (struct)'\n-// @has - '//div[@class=\"item-right docblock-short\"]' 'mod::Foo (function)'\n+// @has - '//div[@class=\"desc docblock-short\"]' 'sub1::Foo (struct)'\n+// @has - '//div[@class=\"desc docblock-short\"]' 'mod::Foo (function)'\n \n-// @has - '//div[@class=\"item-right docblock-short\"]' 'sub4::inner::X'\n+// @has - '//div[@class=\"desc docblock-short\"]' 'sub4::inner::X'\n \n // @has 'glob_shadowing/fn.describe.html'\n // @has - '//div[@class=\"docblock\"]' 'sub2::describe'"}, {"sha": "a41b9c5b1972656a6d3acd1a7c21c94ccd3ecc56", "filename": "tests/rustdoc/inline_cross/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fmacros.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -6,9 +6,9 @@\n \n extern crate macros;\n \n-// @has foo/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n+// @has foo/index.html '//*[@class=\"item-name\"]/span[@class=\"stab deprecated\"]' \\\n //         Deprecated\n-// @has - '//*[@class=\"item-left\"]/span[@class=\"stab unstable\"]' \\\n+// @has - '//*[@class=\"item-name\"]/span[@class=\"stab unstable\"]' \\\n //         Experimental\n \n // @has foo/macro.my_macro.html"}, {"sha": "27b0897689e0986b3debd3fad07017faf0146c90", "filename": "tests/rustdoc/internal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finternal.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -3,12 +3,12 @@\n // Check that the unstable marker is not added for \"rustc_private\".\n \n // @!matches internal/index.html \\\n-//      '//*[@class=\"item-right docblock-short\"]/span[@class=\"stab unstable\"]' \\\n+//      '//*[@class=\"desc docblock-short\"]/span[@class=\"stab unstable\"]' \\\n //      ''\n // @!matches internal/index.html \\\n-//      '//*[@class=\"item-right docblock-short\"]/span[@class=\"stab internal\"]' \\\n+//      '//*[@class=\"desc docblock-short\"]/span[@class=\"stab internal\"]' \\\n //      ''\n-// @matches - '//*[@class=\"item-right docblock-short\"]' 'Docs'\n+// @matches - '//*[@class=\"desc docblock-short\"]' 'Docs'\n \n // @!has internal/struct.S.html '//*[@class=\"stab unstable\"]' ''\n // @!has internal/struct.S.html '//*[@class=\"stab internal\"]' ''"}, {"sha": "1273e4fdd12ebd876806b09eb01119973f8077e9", "filename": "tests/rustdoc/issue-107995.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-107995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-107995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-107995.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/107995>.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/fn.foo.html'\n+// @has - '//*[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar`'\n+/// A foo, see also [ bar`]\n+pub fn foo() {}\n+\n+// @has 'foo/fn.bar.html'\n+// @has - '//*[@class=\"docblock\"]' 'line Path line'\n+// @has - '//*[@class=\"docblock\"]//a[@href=\"struct.Path.html\"]' 'Path'\n+#[doc = \"line [\"]\n+#[doc = \"Path\"]\n+#[doc = \"] line\"]\n+pub fn bar() {}\n+\n+// @has 'foo/fn.another.html'\n+// @has - '//*[@class=\"docblock\"]//a[@href=\"struct.Path.html\"]' 'Path'\n+/// [ `Path`]\n+pub fn another() {}\n+\n+// @has 'foo/fn.last.html'\n+// @has - '//*[@class=\"docblock\"]//a[@href=\"struct.Path.html\"]' 'Path'\n+/// [ Path`]\n+pub fn last() {}\n+\n+pub struct Path;"}, {"sha": "985bf03a12159a9c4279e472e04e97ae579b7354", "filename": "tests/rustdoc/issue-32374.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32374.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -2,11 +2,11 @@\n #![doc(issue_tracker_base_url = \"https://issue_url/\")]\n #![unstable(feature = \"test\", issue = \"32374\")]\n \n-// @matches issue_32374/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-name\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n-// @matches issue_32374/index.html '//*[@class=\"item-left\"]/span[@class=\"stab unstable\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-name\"]/span[@class=\"stab unstable\"]' \\\n //      'Experimental'\n-// @matches issue_32374/index.html '//*[@class=\"item-right docblock-short\"]/text()' 'Docs'\n+// @matches issue_32374/index.html '//*[@class=\"desc docblock-short\"]/text()' 'Docs'\n \n // @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]/span' '\ud83d\udc4e'\n // @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]/span' \\"}, {"sha": "1311b4721e2f728d717840d3786f35c1ce155bb5", "filename": "tests/rustdoc/issue-46377.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-46377.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-46377.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-46377.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,3 +1,3 @@\n-// @has 'issue_46377/index.html' '//*[@class=\"item-right docblock-short\"]' 'Check out this struct!'\n+// @has 'issue_46377/index.html' '//*[@class=\"desc docblock-short\"]' 'Check out this struct!'\n /// # Check out this struct!\n pub struct SomeStruct;"}, {"sha": "941cb3ce1ca5b1a57c6cf1c909d75117a98d5703", "filename": "tests/rustdoc/issue-55364.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-55364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-55364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-55364.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -29,8 +29,8 @@ pub mod subone {\n // @has - '//section[@id=\"main-content\"]/details/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n // @has - '//section[@id=\"main-content\"]/details/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n // Though there should be such links later\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left\"]/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left\"]/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main-content\"]/ul[@class=\"item-table\"]//div[@class=\"item-name\"]/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main-content\"]/ul[@class=\"item-table\"]//div[@class=\"item-name\"]/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n /// See either [foo] or [bar].\n pub mod subtwo {\n \n@@ -68,8 +68,8 @@ pub mod subthree {\n // Next we go *deeper* - In order to ensure it's not just \"this or parent\"\n // we test `crate::` and a `super::super::...` chain\n // @has issue_55364/subfour/subfive/subsix/subseven/subeight/index.html\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-right docblock-short\"]//a[@href=\"../../../../../subone/fn.foo.html\"]' 'other foo'\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-right docblock-short\"]//a[@href=\"../../../../../subtwo/fn.bar.html\"]' 'other bar'\n+// @has - '//section[@id=\"main-content\"]/ul[@class=\"item-table\"]//div[@class=\"desc docblock-short\"]//a[@href=\"../../../../../subone/fn.foo.html\"]' 'other foo'\n+// @has - '//section[@id=\"main-content\"]/ul[@class=\"item-table\"]//div[@class=\"desc docblock-short\"]//a[@href=\"../../../../../subtwo/fn.bar.html\"]' 'other bar'\n pub mod subfour {\n     pub mod subfive {\n         pub mod subsix {"}, {"sha": "83f1f2f75bf021b811d8769f568b3316f051bf4a", "filename": "tests/rustdoc/issue-95873.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-95873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fissue-95873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-95873.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,2 +1,2 @@\n-// @has issue_95873/index.html \"//*[@class='item-left']\" \"pub use ::std as x;\"\n+// @has issue_95873/index.html \"//*[@class='item-name']\" \"pub use ::std as x;\"\n pub use ::std as x;"}, {"sha": "5908d2150f2a5dc24c6da88dc71802ce1bb00656", "filename": "tests/rustdoc/reexport-check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Freexport-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Freexport-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-check.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -8,13 +8,13 @@ extern crate reexport_check;\n #[allow(deprecated, deprecated_in_future)]\n pub use std::i32;\n // @!has 'foo/index.html' '//code' 'pub use self::string::String;'\n-// @has 'foo/index.html' '//div[@class=\"item-left\"]' 'String'\n+// @has 'foo/index.html' '//div[@class=\"item-name\"]' 'String'\n pub use std::string::String;\n \n // i32 is deprecated, String is not\n // @count 'foo/index.html' '//span[@class=\"stab deprecated\"]' 1\n \n-// @has 'foo/index.html' '//div[@class=\"item-right docblock-short\"]' 'Docs in original'\n+// @has 'foo/index.html' '//div[@class=\"desc docblock-short\"]' 'Docs in original'\n // this is a no-op, but shows what happens if there's an attribute that isn't a doc-comment\n #[doc(inline)]\n pub use reexport_check::S;"}, {"sha": "7ecd80b8c723d0128f3a8434e0ae5256f40273eb", "filename": "tests/rustdoc/short-docblock-codeblock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fshort-docblock-codeblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fshort-docblock-codeblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fshort-docblock-codeblock.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,6 +1,6 @@\n #![crate_name = \"foo\"]\n \n-// @count foo/index.html '//*[@class=\"item-right docblock-short\"]' 0\n+// @count foo/index.html '//*[@class=\"desc docblock-short\"]' 0\n \n /// ```\n /// let x = 12;"}, {"sha": "791d3547c9fec06831f4fab8efebfa7fa5d260ed", "filename": "tests/rustdoc/short-docblock.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fshort-docblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Frustdoc%2Fshort-docblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fshort-docblock.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -1,24 +1,24 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/index.html '//*[@class=\"item-right docblock-short\"]' 'fooo'\n-// @!has foo/index.html '//*[@class=\"item-right docblock-short\"]/h1' 'fooo'\n+// @has foo/index.html '//*[@class=\"desc docblock-short\"]' 'fooo'\n+// @!has foo/index.html '//*[@class=\"desc docblock-short\"]/h1' 'fooo'\n // @has foo/fn.foo.html '//h2[@id=\"fooo\"]/a[@href=\"#fooo\"]' 'fooo'\n \n /// # fooo\n ///\n /// foo\n pub fn foo() {}\n \n-// @has foo/index.html '//*[@class=\"item-right docblock-short\"]' 'mooood'\n-// @!has foo/index.html '//*[@class=\"item-right docblock-short\"]/h2' 'mooood'\n+// @has foo/index.html '//*[@class=\"desc docblock-short\"]' 'mooood'\n+// @!has foo/index.html '//*[@class=\"desc docblock-short\"]/h2' 'mooood'\n // @has foo/foo/index.html '//h3[@id=\"mooood\"]/a[@href=\"#mooood\"]' 'mooood'\n \n /// ## mooood\n ///\n /// foo mod\n pub mod foo {}\n \n-// @has foo/index.html '//*[@class=\"item-right docblock-short\"]/a[@href=\\\n+// @has foo/index.html '//*[@class=\"desc docblock-short\"]/a[@href=\\\n //                      \"https://nougat.world\"]/code' 'nougat'\n \n /// [`nougat`](https://nougat.world)"}, {"sha": "73920555b3e0415982d5526cee4c1c81ff9bfe99", "filename": "tests/ui/associated-inherent-types/ambiguity.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,16 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Wrapper<T>(T);\n+\n+impl Wrapper<i32> {\n+    type Foo = i32;\n+}\n+\n+impl Wrapper<()> {\n+    type Foo = ();\n+}\n+\n+fn main() {\n+    let _: Wrapper<_>::Foo = (); //~ ERROR multiple applicable items in scope\n+}"}, {"sha": "155c296cbb3c424b2a40b32a6e26d5b14e930e48", "filename": "tests/ui/associated-inherent-types/ambiguity.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,20 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/ambiguity.rs:15:24\n+   |\n+LL |     let _: Wrapper<_>::Foo = ();\n+   |                        ^^^ multiple `Foo` found\n+   |\n+note: candidate #1 is defined in an impl for the type `Wrapper<i32>`\n+  --> $DIR/ambiguity.rs:7:5\n+   |\n+LL |     type Foo = i32;\n+   |     ^^^^^^^^\n+note: candidate #2 is defined in an impl for the type `Wrapper<()>`\n+  --> $DIR/ambiguity.rs:11:5\n+   |\n+LL |     type Foo = ();\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}, {"sha": "53ac79e0561baee45614c02ff575e52b27855a20", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,23 @@\n+// known-bug: unknown\n+// failure-status: 101\n+// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n+\n+// FIXME: I presume a type variable that couldn't be solved by `resolve_vars_if_possible`\n+//        escapes the InferCtxt snapshot.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Cont<T>(T);\n+\n+impl<T: Copy> Cont<T> {\n+    type Out = Vec<T>;\n+}\n+\n+pub fn weird<T: Copy>(x: T) {\n+    let _: Cont<_>::Out = vec![true];\n+}\n+\n+fn main() {}"}, {"sha": "7b0d1c50516241ab6984a8872d1feb3d72fb56d1", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,6 @@\n+error: the compiler unexpectedly panicked. this is a bug.\n+\n+query stack during panic:\n+#0 [typeck] type-checking `weird`\n+#1 [typeck_item_bodies] type-checking all item bodies\n+end of query stack"}, {"sha": "a920b412b1a492a9840b0c588299bed9d0838926", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,15 @@\n+// known-bug: unknown\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl S<()> {\n+    type P = i128;\n+}\n+\n+fn main() {\n+    // We fail to infer `_ == ()` here.\n+    let _: S<_>::P;\n+}"}, {"sha": "425691bd6c4f694a860e05181f81a7fdd5e7f84e", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/inference-fail.rs:14:14\n+   |\n+LL |     let _: S<_>::P;\n+   |              ^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "632dbf3854b2b7b0eb5f09225f4be7c938abb462", "filename": "tests/ui/associated-inherent-types/bugs/lack-of-regionck.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,19 @@\n+// known-bug: unknown\n+// check-pass\n+\n+// We currently don't region-check inherent associated type projections at all.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features, dead_code)]\n+\n+struct S<T>(T);\n+\n+impl S<&'static ()> {\n+    type T = ();\n+}\n+\n+fn usr<'a>() {\n+    let _: S::<&'a ()>::T; // this should *fail* but it doesn't!\n+}\n+\n+fn main() {}"}, {"sha": "f846bfa4168acdb9959ba7d7d8a6684b9a801070", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T>(T);\n+\n+impl Select<u8> {\n+    type Projection = ();\n+}\n+\n+impl Select<String> {\n+    type Projection = bool;\n+}\n+\n+struct Choose<T>(T);\n+struct NonCopy;\n+\n+impl<T: Copy> Choose<T> {\n+    type Result = Vec<T>;\n+}\n+\n+impl Choose<NonCopy> {\n+    type Result = ();\n+}\n+\n+fn main() {\n+    let _: Select<String>::Projection = false;\n+    let _: Select<u8>::Projection = ();\n+\n+    let _: Choose<NonCopy>::Result = ();\n+    let _: Choose<bool>::Result = vec![true];\n+}\n+\n+// Test if we use the correct `ParamEnv` when proving obligations.\n+\n+pub fn parameterized<T: Copy>(x: T) {\n+    let _: Choose<T>::Result = vec![x];\n+}"}, {"sha": "9b0fa8dc6f32cf9c606eaf98a27afdb4b8d628de", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types, auto_traits, negative_impls)]\n+#![allow(incomplete_features)]\n+\n+use std::cmp::Ordering;\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T, U>(T, U);\n+\n+impl<T: Ordinary, U: Ordinary> Select<T, U> {\n+    type Type = ();\n+}\n+\n+impl<T: Ordinary> Select<T, Special> {\n+    type Type = bool;\n+}\n+\n+impl<T: Ordinary> Select<Special, T> {\n+    type Type = Ordering;\n+}\n+\n+impl Select<Special, Special> {\n+    type Type = (bool, bool);\n+}\n+\n+fn main() {\n+    let _: Select<String, Special>::Type = false;\n+    let _: Select<Special, Special>::Type = (true, false);\n+    let _: Select<Special, u8>::Type = Ordering::Equal;\n+    let _: Select<i128, ()>::Type = ();\n+}\n+\n+enum Special {}\n+\n+impl !Ordinary for Special {}\n+\n+auto trait Ordinary {}"}, {"sha": "7b205952f52bcee72b0e11fb029ede4d555331a6", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,17 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Parameterized<T, U>(T, U);\n+\n+impl Parameterized<(), ()> {\n+    type Output = bool;\n+}\n+\n+impl<T> Parameterized<bool, T> {\n+    type Result = T;\n+}\n+\n+fn main() {\n+    let _: Parameterized<(), ()>::Output = String::new(); //~ ERROR mismatched types\n+    let _: Parameterized<bool, u32>::Result = (); //~ ERROR mismatched types\n+}"}, {"sha": "c9a48872af40e1c4bc1410dc1f208bc40598101e", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:15:44\n+   |\n+LL |     let _: Parameterized<(), ()>::Output = String::new();\n+   |            -----------------------------   ^^^^^^^^^^^^^ expected `bool`, found `String`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:16:47\n+   |\n+LL |     let _: Parameterized<bool, u32>::Result = ();\n+   |            --------------------------------   ^^ expected `u32`, found `()`\n+   |            |\n+   |            expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d2efb24c666204850974f2395d46850d79ad4601", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,31 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that it's okay to report \u201c[inherent] associated type [\u2026] not found\u201d for inherent associated\n+// type candidates that are not applicable (due to unsuitable Self type) even if there exists a\n+// \u201cshadowed\u201d associated type from a trait with the same name since its use would be ambiguous\n+// anyway if the IAT didn't exist.\n+// FIXME(inherent_associated_types): Figure out which error would be more helpful here.\n+\n+// revisions: shadowed uncovered\n+\n+struct S<T>(T);\n+\n+trait Tr {\n+    type Pr;\n+}\n+\n+impl<T> Tr for S<T> {\n+    type Pr = ();\n+}\n+\n+#[cfg(shadowed)]\n+impl S<()> {\n+    type Pr = i32;\n+}\n+\n+fn main() {\n+    let _: S::<bool>::Pr = ();\n+    //[shadowed]~^ ERROR associated type `Pr` not found\n+    //[uncovered]~^^ ERROR ambiguous associated type\n+}"}, {"sha": "3561db354c03f81f7a047cf6d8731381e65c89d0", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Pr` not found for `S<bool>` in the current scope\n+  --> $DIR/not-found-self-type-differs-shadowing-trait-item.rs:28:23\n+   |\n+LL | struct S<T>(T);\n+   | ----------- associated item `Pr` not found for this struct\n+...\n+LL |     let _: S::<bool>::Pr = ();\n+   |                       ^^ associated item not found in `S<bool>`\n+   |\n+   = note: the associated type was found for\n+           - `S<()>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "88c72042ce2d0166a06d75e6382dcba692f2de65", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/not-found-self-type-differs-shadowing-trait-item.rs:28:12\n+   |\n+LL |     let _: S::<bool>::Pr = ();\n+   |            ^^^^^^^^^^^^^ help: use the fully-qualified path: `<S<bool> as Tr>::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "4396435a6ddc5d2a583478c197b90269ed4a8420", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.alias.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<Option<()>>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:17:34\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL | type Alias = Family<Option<()>>::Proj;\n+   |                                  ^^^^ associated item not found in `Family<Option<()>>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "d527db022172fd3935f495f62cd4dd2d8eeb3ea1", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.local.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<PathBuf>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:21:40\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL |     let _: Family<std::path::PathBuf>::Proj = ();\n+   |                                        ^^^^ associated item not found in `Family<PathBuf>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "93f58dcb6e61a7585f22eb1464a049f88e5350fb", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,22 @@\n+// revisions: local alias\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Family<T>(T);\n+\n+impl Family<()> {\n+    type Proj = ();\n+}\n+\n+impl<T> Family<Result<T, ()>> {\n+    type Proj = Self;\n+}\n+\n+#[cfg(alias)]\n+type Alias = Family<Option<()>>::Proj; //[alias]~ ERROR associated type `Proj` not found for `Family<Option<()>>`\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Family<std::path::PathBuf>::Proj = (); //[local]~ ERROR associated type `Proj` not found for `Family<PathBuf>`\n+}"}, {"sha": "b00830fa1c15c6d2edd9aa2881f90e97195737f0", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-0.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for issue #104251.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Container<T: ?Sized>(T);\n+\n+impl<T> Container<T> {\n+    type Yield = i32;\n+}\n+\n+struct Duple<T, U>(T, U);\n+\n+impl<T: Copy, U: Send> Duple<T, U> {\n+    type Combination = (T, U);\n+}\n+\n+fn main() {\n+    let _: Container<[u8]>::Yield = 1; //~ ERROR the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+    let _: Duple<String, std::rc::Rc<str>>::Combination; //~ ERROR the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+}"}, {"sha": "736579067615a7338268fb4ae341d96688e8759f", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-0.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,27 @@\n+error: the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-0.rs:19:29\n+   |\n+LL | struct Container<T: ?Sized>(T);\n+   | --------------------------- associated item `Yield` not found for this struct\n+...\n+LL |     let _: Container<[u8]>::Yield = 1;\n+   |                             ^^^^^ associated type cannot be referenced on `Container<[u8]>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `[u8]: Sized`\n+\n+error: the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-0.rs:20:45\n+   |\n+LL | struct Duple<T, U>(T, U);\n+   | ------------------ associated item `Combination` not found for this struct\n+...\n+LL |     let _: Duple<String, std::rc::Rc<str>>::Combination;\n+   |                                             ^^^^^^^^^^^ associated type cannot be referenced on `Duple<String, Rc<str>>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `Rc<str>: Send`\n+           `String: Copy`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c80b1364ae3b8a24c7cf1c4c7c70eda674697ff4", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,18 @@\n+// fail-check\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Test if we use the correct `ParamEnv` when proving obligations.\n+\n+fn parameterized<T>() {\n+    let _: Container<T>::Proj = String::new(); //~ ERROR the associated type `Proj` exists for `Container<T>`, but its trait bounds were not satisfied\n+}\n+\n+struct Container<T>(T);\n+\n+impl<T: Clone> Container<T> {\n+    type Proj = String;\n+}\n+\n+fn main() {}"}, {"sha": "230bfa538b4f32148c02556715f17d9bd0f72732", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,14 @@\n+error: the associated type `Proj` exists for `Container<T>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-1.rs:9:26\n+   |\n+LL |     let _: Container<T>::Proj = String::new();\n+   |                          ^^^^ associated type cannot be referenced on `Container<T>` due to unsatisfied trait bounds\n+...\n+LL | struct Container<T>(T);\n+   | ------------------- associated item `Proj` not found for this struct\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `T: Clone`\n+\n+error: aborting due to previous error\n+"}, {"sha": "5b0e8de9c580baf4478c7241899bf4cabff5ba42", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-in-multiple-impls.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,20 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<A, B>(A, B);\n+struct Featureless;\n+\n+trait One {}\n+trait Two {}\n+\n+impl<T: One> S<Featureless, T> {\n+    type X = ();\n+}\n+\n+impl<T: Two> S<T, Featureless> {\n+    type X = String;\n+}\n+\n+fn main() {\n+    let _: S::<Featureless, Featureless>::X; //~ ERROR the associated type `X` exists for `S<Featureless, Featureless>`, but its trait bounds were not satisfied\n+}"}, {"sha": "3ddab25deb54c00b7e48dae515154ce0feff0ede", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-in-multiple-impls.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,20 @@\n+error: the associated type `X` exists for `S<Featureless, Featureless>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-in-multiple-impls.rs:19:43\n+   |\n+LL | struct S<A, B>(A, B);\n+   | -------------- associated item `X` not found for this struct\n+LL | struct Featureless;\n+   | ------------------\n+   | |\n+   | doesn't satisfy `Featureless: One`\n+   | doesn't satisfy `Featureless: Two`\n+...\n+LL |     let _: S::<Featureless, Featureless>::X;\n+   |                                           ^ associated type cannot be referenced on `S<Featureless, Featureless>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `Featureless: One`\n+           `Featureless: Two`\n+\n+error: aborting due to previous error\n+"}, {"sha": "00eb1a14da47ae77604011b87f35b5951b38e3e2", "filename": "tests/ui/associated-inherent-types/substitute-params-bad.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for issue #105305 and for\n+// https://github.com/rust-lang/rust/issues/107468#issuecomment-1409096700\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T, 'a> S<T> { //~ ERROR lifetime parameters must be declared prior to type and const parameters\n+    type P = T;\n+}\n+\n+struct Subj<T>(T);\n+\n+impl<T, S> Subj<(T, S)> {\n+    type Un = (T, S);\n+}\n+\n+fn main() {\n+    type A = S<()>::P;\n+\n+    let _: Subj<(i32, i32)>::Un = 0i32; //~ ERROR mismatched types\n+}"}, {"sha": "7a7808ba67b14d3ee6ecb5c5ddcffef17b70ca26", "filename": "tests/ui/associated-inherent-types/substitute-params-bad.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,20 @@\n+error: lifetime parameters must be declared prior to type and const parameters\n+  --> $DIR/substitute-params-bad.rs:9:9\n+   |\n+LL | impl<T, 'a> S<T> {\n+   |     ----^^- help: reorder the parameters: lifetimes, then consts and types: `<'a, T>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/substitute-params-bad.rs:22:35\n+   |\n+LL |     let _: Subj<(i32, i32)>::Un = 0i32;\n+   |            --------------------   ^^^^ expected `(i32, i32)`, found `i32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected tuple `(i32, i32)`\n+               found type `i32`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e94d683315903c9c84babf8089a367717896e79b", "filename": "tests/ui/associated-inherent-types/substitute-params.rs", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -9,7 +9,15 @@ impl<T> S<T> {\n     type P = T;\n }\n \n+impl<T> S<(T,)> {\n+    type Un = T;\n+}\n+\n fn main() {\n+    // Regression test for issue #104240.\n     type A = S<()>::P;\n     let _: A = ();\n+\n+    // Regression test for issue #107468.\n+    let _: S<(i32,)>::Un = 0i32;\n }", "previous_filename": "tests/ui/associated-inherent-types/struct-generics.rs"}, {"sha": "0fd1a2703db998ecd8d85544e483b5f658821194", "filename": "tests/ui/async-await/in-trait/async-default-fn-overridden.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,66 @@\n+// run-pass\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+//~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use\n+\n+use std::future::Future;\n+\n+trait AsyncTrait {\n+    async fn default_impl() {\n+        assert!(false);\n+    }\n+\n+    async fn call_default_impl() {\n+        Self::default_impl().await\n+    }\n+}\n+\n+struct AsyncType;\n+\n+impl AsyncTrait for AsyncType {\n+    async fn default_impl() {\n+        // :)\n+    }\n+}\n+\n+async fn async_main() {\n+    // Should not assert false\n+    AsyncType::call_default_impl().await;\n+}\n+\n+// ------------------------------------------------------------------------- //\n+// Implementation Details Below...\n+\n+use std::pin::Pin;\n+use std::task::*;\n+\n+pub fn noop_waker() -> Waker {\n+    let raw = RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE);\n+\n+    // SAFETY: the contracts for RawWaker and RawWakerVTable are upheld\n+    unsafe { Waker::from_raw(raw) }\n+}\n+\n+const NOOP_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(noop_clone, noop, noop, noop);\n+\n+unsafe fn noop_clone(_p: *const ()) -> RawWaker {\n+    RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE)\n+}\n+\n+unsafe fn noop(_p: *const ()) {}\n+\n+fn main() {\n+    let mut fut = async_main();\n+\n+    // Poll loop, just to test the future...\n+    let waker = noop_waker();\n+    let ctx = &mut Context::from_waker(&waker);\n+\n+    loop {\n+        match unsafe { Pin::new_unchecked(&mut fut).poll(ctx) } {\n+            Poll::Pending => {}\n+            Poll::Ready(()) => break,\n+        }\n+    }\n+}"}, {"sha": "61a826258d09f0c351b2ee6775b6aac15cb4f424", "filename": "tests/ui/async-await/in-trait/async-default-fn-overridden.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-default-fn-overridden.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/async-default-fn-overridden.rs:4:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d35519632becf0ea033c086c2c4c9ebe754f3bcd", "filename": "tests/ui/dyn-star/llvm-old-style-ptrs.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// compile-flags: -Copt-level=0 -Cllvm-args=-opaque-pointers=0\n+\n+// (opaque-pointers flag is called force-opaque-pointers in LLVM 13...)\n+// min-llvm-version: 14.0\n+\n+// This test can be removed once non-opaque pointers are gone from LLVM, maybe.\n+\n+#![feature(dyn_star, pointer_like_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+use std::marker::PointerLike;\n+\n+fn make_dyn_star<'a>(t: impl PointerLike + Debug + 'a) -> dyn* Debug + 'a {\n+    t as _\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", make_dyn_star(Box::new(1i32)));\n+    println!(\"{:?}\", make_dyn_star(2usize));\n+    println!(\"{:?}\", make_dyn_star((3usize,)));\n+}"}, {"sha": "ba473653ecfe328ff545df1011a644ab097e6cf8", "filename": "tests/ui/traits/new-solver/builtin-fn-must-return-sized.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+#![feature(fn_traits)]\n+#![feature(unboxed_closures)]\n+#![feature(tuple_trait)]\n+\n+use std::ops::Fn;\n+use std::marker::Tuple;\n+\n+fn foo<F: Fn<T>, T: Tuple>(f: Option<F>, t: T) {\n+    let y = (f.unwrap()).call(t);\n+}\n+\n+fn main() {\n+    foo::<fn() -> str, _>(None, ());\n+    //~^ expected a `Fn<_>` closure, found `fn() -> str`\n+}"}, {"sha": "f7551739b13286dfa23e7b8e8c4bc74ceec00980", "filename": "tests/ui/traits/new-solver/builtin-fn-must-return-sized.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: expected a `Fn<_>` closure, found `fn() -> str`\n+  --> $DIR/builtin-fn-must-return-sized.rs:15:27\n+   |\n+LL |     foo::<fn() -> str, _>(None, ());\n+   |     --------------------- ^^^^ expected an `Fn<_>` closure, found `fn() -> str`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<_>` is not implemented for `fn() -> str`\n+note: required by a bound in `foo`\n+  --> $DIR/builtin-fn-must-return-sized.rs:10:11\n+   |\n+LL | fn foo<F: Fn<T>, T: Tuple>(f: Option<F>, t: T) {\n+   |           ^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dfc800c8e7e1213811489a12af5ddde1463b342e", "filename": "tests/ui/traits/non_lifetime_binders/bad-sized-cond.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.rs?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,23 @@\n+#![feature(non_lifetime_binders)]\n+//~^ WARN is incomplete and may not be safe\n+\n+pub fn foo()\n+where\n+    for<V> V: Sized,\n+{\n+}\n+\n+pub fn bar()\n+where\n+    for<V> V: IntoIterator,\n+{\n+}\n+\n+fn main() {\n+    foo();\n+    //~^ ERROR the size for values of type `V` cannot be known at compilation time\n+\n+    bar();\n+    //~^ ERROR the size for values of type `V` cannot be known at compilation time\n+    //~| ERROR `V` is not an iterator\n+}"}, {"sha": "6480e490e8b307fffdd62f6e13c001782ad429f5", "filename": "tests/ui/traits/non_lifetime_binders/bad-sized-cond.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1a242533392d4772c84ce2be80cf7fd40aa8be3/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbad-sized-cond.stderr?ref=d1a242533392d4772c84ce2be80cf7fd40aa8be3", "patch": "@@ -0,0 +1,62 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/bad-sized-cond.rs:1:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0277]: the size for values of type `V` cannot be known at compilation time\n+  --> $DIR/bad-sized-cond.rs:17:5\n+   |\n+LL |     foo();\n+   |     ^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `V`\n+note: required by a bound in `foo`\n+  --> $DIR/bad-sized-cond.rs:6:15\n+   |\n+LL | pub fn foo()\n+   |        --- required by a bound in this\n+LL | where\n+LL |     for<V> V: Sized,\n+   |               ^^^^^ required by this bound in `foo`\n+\n+error[E0277]: the size for values of type `V` cannot be known at compilation time\n+  --> $DIR/bad-sized-cond.rs:20:5\n+   |\n+LL |     bar();\n+   |     ^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `V`\n+   = note: required for `V` to implement `IntoIterator`\n+note: required by a bound in `bar`\n+  --> $DIR/bad-sized-cond.rs:12:15\n+   |\n+LL | pub fn bar()\n+   |        --- required by a bound in this\n+LL | where\n+LL |     for<V> V: IntoIterator,\n+   |               ^^^^^^^^^^^^ required by this bound in `bar`\n+\n+error[E0277]: `V` is not an iterator\n+  --> $DIR/bad-sized-cond.rs:20:5\n+   |\n+LL |     bar();\n+   |     ^^^ `V` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `V`\n+   = note: required for `V` to implement `IntoIterator`\n+note: required by a bound in `bar`\n+  --> $DIR/bad-sized-cond.rs:12:15\n+   |\n+LL | pub fn bar()\n+   |        --- required by a bound in this\n+LL | where\n+LL |     for<V> V: IntoIterator,\n+   |               ^^^^^^^^^^^^ required by this bound in `bar`\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}]}