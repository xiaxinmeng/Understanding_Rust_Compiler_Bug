{"sha": "d3181a9a012805133d4b2808108c37cf4b23ea66", "node_id": "C_kwDOAAsO6NoAKGQzMTgxYTlhMDEyODA1MTMzZDRiMjgwODEwOGMzN2NmNGIyM2VhNjY", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "liehr.exchange@gmx.net", "date": "2022-06-23T15:19:56Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "liehr.exchange@gmx.net", "date": "2022-07-04T16:39:52Z"}, "message": "rustdoc: censor certain complex unevaluated const exprs", "tree": {"sha": "4215886013b789c317d2205fe5db1ca65d658a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4215886013b789c317d2205fe5db1ca65d658a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3181a9a012805133d4b2808108c37cf4b23ea66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3181a9a012805133d4b2808108c37cf4b23ea66", "html_url": "https://github.com/rust-lang/rust/commit/d3181a9a012805133d4b2808108c37cf4b23ea66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3181a9a012805133d4b2808108c37cf4b23ea66/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25b1315ee968146a5b206a8f3c670c5b307ebfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25b1315ee968146a5b206a8f3c670c5b307ebfe", "html_url": "https://github.com/rust-lang/rust/commit/a25b1315ee968146a5b206a8f3c670c5b307ebfe"}], "stats": {"total": 269, "additions": 259, "deletions": 10}, "files": [{"sha": "3bd4d2f01f5e998f94fc33e0578934a086f17d1d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -343,17 +343,98 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n+/// Build a textual representation of an unevaluated constant expression.\n+///\n+/// If the const expression is too complex, an underscore `_` is returned.\n+/// For const arguments, it's `{ _ }` to be precise.\n+/// This means that the output is not necessarily valid Rust code.\n+///\n+/// Currently, only\n+///\n+/// * literals (optionally with a leading `-`)\n+/// * unit `()`\n+/// * blocks (`{ \u2026 }`) around simple expressions and\n+/// * paths without arguments\n+///\n+/// are considered simple enough. Simple blocks are included since they are\n+/// necessary to disambiguate unit from the unit type.\n+/// This list might get extended in the future.\n+///\n+/// Without this censoring, in a lot of cases the output would get too large\n+/// and verbose. Consider `match` expressions, blocks and deeply nested ADTs.\n+/// Further, private and `doc(hidden)` fields of structs would get leaked\n+/// since HIR datatypes like the `body` parameter do not contain enough\n+/// semantic information for this function to be able to hide them \u2013\n+/// at least not without significant performance overhead.\n+///\n+/// Whenever possible, prefer to evaluate the constant first and try to\n+/// use a different method for pretty-printing. Ideally this function\n+/// should only ever be used as a fallback.\n pub(crate) fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n     let hir = tcx.hir();\n     let value = &hir.body(body).value;\n \n-    let snippet = if !value.span.from_expansion() {\n-        tcx.sess.source_map().span_to_snippet(value.span).ok()\n-    } else {\n-        None\n-    };\n+    #[derive(PartialEq, Eq)]\n+    enum Classification {\n+        Literal,\n+        Simple,\n+        Complex,\n+    }\n \n-    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&hir, body.hir_id))\n+    use Classification::*;\n+\n+    fn classify(expr: &hir::Expr<'_>) -> Classification {\n+        match &expr.kind {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                if matches!(expr.kind, hir::ExprKind::Lit(_)) { Literal } else { Complex }\n+            }\n+            hir::ExprKind::Lit(_) => Literal,\n+            hir::ExprKind::Tup([]) => Simple,\n+            hir::ExprKind::Block(hir::Block { stmts: [], expr: Some(expr), .. }, _) => {\n+                if classify(expr) == Complex { Complex } else { Simple }\n+            }\n+            // Paths with a self-type or arguments are too \u201ccomplex\u201d following our measure since\n+            // they may leak private fields of structs (with feature `adt_const_params`).\n+            // Consider: `<Self as Trait<{ Struct { private: () } }>>::CONSTANT`.\n+            // Paths without arguments are definitely harmless though.\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, hir::Path { segments, .. })) => {\n+                if segments.iter().all(|segment| segment.args.is_none()) { Simple } else { Complex }\n+            }\n+            // FIXME: Claiming that those kinds of QPaths are simple is probably not true if the Ty\n+            //        contains const arguments. Is there a *concise* way to check for this?\n+            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => Simple,\n+            // FIXME: Can they contain const arguments and thus leak private struct fields?\n+            hir::ExprKind::Path(hir::QPath::LangItem(..)) => Simple,\n+            _ => Complex,\n+        }\n+    }\n+\n+    let classification = classify(value);\n+\n+    if classification == Literal\n+    && !value.span.from_expansion()\n+    && let Ok(snippet) = tcx.sess.source_map().span_to_snippet(value.span) {\n+        // For literals, we avoid invoking the pretty-printer and use the source snippet instead to\n+        // preserve certain stylistic choices the user likely made for the sake legibility like\n+        //\n+        // * hexadecimal notation\n+        // * underscores\n+        // * character escapes\n+        //\n+        // FIXME: This passes through `-/*spacer*/0` verbatim.\n+        snippet\n+    } else if classification == Simple {\n+        // Otherwise we prefer pretty-printing to get rid of extraneous whitespace, comments and\n+        // other formatting artifacts.\n+        rustc_hir_pretty::id_to_string(&hir, body.hir_id)\n+    } else if tcx.def_kind(hir.body_owner_def_id(body).to_def_id()) == DefKind::AnonConst {\n+        // FIXME: Omit the curly braces if the enclosing expression is an array literal\n+        //        with a repeated element (an `ExprKind::Repeat`) as in such case it\n+        //        would not actually need any disambiguation.\n+        \"{ _ }\".to_owned()\n+    } else {\n+        \"_\".to_owned()\n+    }\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "7642473b6cd3d9347c2df4915c5a0ddd9c454246", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -707,12 +707,14 @@ fn assoc_const(\n         ty = ty.print(cx),\n     );\n     if let Some(default) = default {\n+        write!(w, \" = \");\n+\n         // FIXME: `.value()` uses `clean::utils::format_integer_with_underscore_sep` under the\n         //        hood which adds noisy underscores and a type suffix to number literals.\n         //        This hurts readability in this context especially when more complex expressions\n         //        are involved and it doesn't add much of value.\n         //        Find a way to print constants here without all that jazz.\n-        write!(w, \" = {}\", default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx())));\n+        write!(w, \"{}\", Escape(&default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx()))));\n     }\n }\n "}, {"sha": "d3e1bdc697ff7b23f26309db778956778628e538", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -1356,6 +1356,15 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n                 typ = c.type_.print(cx),\n             );\n \n+            // FIXME: The code below now prints\n+            //            ` = _; // 100i32`\n+            //        if the expression is\n+            //            `50 + 50`\n+            //        which looks just wrong.\n+            //        Should we print\n+            //            ` = 100i32;`\n+            //        instead?\n+\n             let value = c.value(cx.tcx());\n             let is_literal = c.is_literal(cx.tcx());\n             let expr = c.expr(cx.tcx());"}, {"sha": "a79e93145ba7db99905043b11be0b3ab8b764a83", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -27,6 +27,10 @@ impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAR\"]' \\\n     //      'const BAR: usize'\n     pub const BAR: usize = 3;\n+\n+    // @has - '//*[@id=\"associatedconstant.BAR_ESCAPED\"]' \\\n+    //      \"const BAR_ESCAPED: &'static str = \\\"<em>markup</em>\\\"\"\n+    pub const BAR_ESCAPED: &'static str = \"<em>markup</em>\";\n }\n \n pub struct Baz<'a, U: 'a, T>(T, &'a [U]);"}, {"sha": "5b2f3c48d57fa8a847024b3ad88397927c083ae8", "filename": "src/test/rustdoc/const-value-display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-value-display.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/constant.HOUR_IN_SECONDS.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = 60 * 60; // 3_600u64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = _; // 3_600u64'\n pub const HOUR_IN_SECONDS: u64 = 60 * 60;\n \n // @has 'foo/constant.NEGATIVE.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = -60 * 60; // -3_600i64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = _; // -3_600i64'\n pub const NEGATIVE: i64 = -60 * 60;"}, {"sha": "644a6e1cf33c52324035a5dd9d8beaaed3290d16", "filename": "src/test/rustdoc/hide-complex-unevaluated-const-arguments.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -0,0 +1,82 @@\n+// Test that certain unevaluated constant expression arguments that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+#![feature(const_trait_impl, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+// @has hide_complex_unevaluated_const_arguments/trait.Stage.html\n+pub trait Stage {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: usize;\n+\n+    // Currently considered \"overly complex\" by the `generic_const_exprs`\n+    // feature. If / once this expression kind gets supported, this\n+    // unevaluated const expression could leak the private struct field.\n+    //\n+    // FIXME: Once the line below compiles, make this a test that\n+    //        ensures that the private field is not printed.\n+    //\n+    //const ARRAY0: [u8; Struct { private: () } + Self::ABSTRACT];\n+\n+    // This assoc. const could leak the private assoc. function `Struct::new`.\n+    // Ensure that this does not happen.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARRAY1\"]' \\\n+    //        'const ARRAY1: [u8; { _ }]'\n+    const ARRAY1: [u8; Struct::new(/* ... */) + Self::ABSTRACT * 1_000];\n+\n+    // @has - '//*[@id=\"associatedconstant.VERBOSE\"]' \\\n+    //        'const VERBOSE: [u16; { _ }]'\n+    const VERBOSE: [u16; compute(\"thing\", 9 + 9) * Self::ABSTRACT];\n+\n+    // Check that we do not leak the private struct field contained within\n+    // the path. The output could definitely be improved upon\n+    // (e.g. printing sth. akin to `<Self as Helper<{ _ }>>::OUT`) but\n+    // right now \u201csafe is safe\u201d.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.PATH\"]' \\\n+    //        'const PATH: usize = _'\n+    const PATH: usize = <Self as Helper<{ Struct { private: () } }>>::OUT;\n+}\n+\n+const fn compute(input: &str, extra: usize) -> usize {\n+    input.len() + extra\n+}\n+\n+pub trait Helper<const S: Struct> {\n+    const OUT: usize;\n+}\n+\n+impl<const S: Struct, St: Stage + ?Sized> Helper<S> for St {\n+    const OUT: usize = St::ABSTRACT;\n+}\n+\n+// Currently in rustdoc, const arguments are not evaluated in this position\n+// and therefore they fall under the realm of `print_const_expr`.\n+// If rustdoc gets patched to evaluate const arguments, it is fine to replace\n+// this test as long as one can ensure that private fields are not leaked!\n+//\n+// @has hide_complex_unevaluated_const_arguments/trait.Sub.html \\\n+//      '//*[@class=\"rust trait\"]' \\\n+//      'pub trait Sub: Sup<{ _ }, { _ }> { }'\n+pub trait Sub: Sup<{ 90 * 20 * 4 }, { Struct { private: () } }> {}\n+\n+pub trait Sup<const N: usize, const S: Struct> {}\n+\n+pub struct Struct { private: () }\n+\n+impl Struct {\n+    const fn new() -> Self { Self { private: () } }\n+}\n+\n+impl const std::ops::Add<usize> for Struct {\n+    type Output = usize;\n+\n+    fn add(self, _: usize) -> usize { 0 }\n+}"}, {"sha": "ba623246a01e0da1dea82303ed33a062b0c5ede2", "filename": "src/test/rustdoc/hide-complex-unevaluated-consts.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -0,0 +1,71 @@\n+// Regression test for issue #97933.\n+//\n+// Test that certain unevaluated constant expressions that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+\n+// @has hide_complex_unevaluated_consts/trait.Container.html\n+pub trait Container {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: i32;\n+\n+    // Ensure that the private field does not get leaked:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT0\"]' \\\n+    //        'const STRUCT0: Struct = _'\n+    const STRUCT0: Struct = Struct { private: () };\n+\n+    // @has - '//*[@id=\"associatedconstant.STRUCT1\"]' \\\n+    //        'const STRUCT1: (Struct,) = _'\n+    const STRUCT1: (Struct,) = (Struct{private: /**/()},);\n+\n+    // Although the struct field is public here, check that it is not\n+    // displayed. In a future version of rustdoc, we definitely want to\n+    // show it. However for the time being, the printing logic is a bit\n+    // conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT2\"]' \\\n+    //        'const STRUCT2: Record = _'\n+    const STRUCT2: Record = Record { public: 5 };\n+\n+    // Test that we do not show the incredibly verbose match expr:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.MATCH0\"]' \\\n+    //        'const MATCH0: i32 = _'\n+    const MATCH0: i32 = match 234 {\n+        0 => 1,\n+        _ => Self::ABSTRACT,\n+    };\n+\n+    // @has - '//*[@id=\"associatedconstant.MATCH1\"]' \\\n+    //        'const MATCH1: bool = _'\n+    const MATCH1: bool = match Self::ABSTRACT {\n+        _ => true,\n+    };\n+\n+    // Check that we hide complex (arithmetic) operations.\n+    // In this case, it is a bit unfortunate since the expression\n+    // is not *that* verbose and it might be quite useful to the reader.\n+    //\n+    // However in general, the expression might be quite large and\n+    // contain match expressions and structs with private fields.\n+    // We would need to recurse over the whole expression and even more\n+    // importantly respect operator precedence when pretty-printing\n+    // the potentially partially censored expression.\n+    // For now, the implementation is quite simple and the choices\n+    // rather conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARITH_OPS\"]' \\\n+    //        'const ARITH_OPS: i32 = _'\n+    const ARITH_OPS: i32 = Self::ABSTRACT * 2 + 1;\n+}\n+\n+pub struct Struct { private: () }\n+\n+pub struct Record { pub public: i32 }"}, {"sha": "48b60885974afc7542ddcde7241d95f213f0c458", "filename": "src/test/rustdoc/show-const-contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3181a9a012805133d4b2808108c37cf4b23ea66/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs?ref=d3181a9a012805133d4b2808108c37cf4b23ea66", "patch": "@@ -21,7 +21,7 @@ pub const CONST_NEG_I32: i32 = -42;\n // @!has show_const_contents/constant.CONST_EQ_TO_VALUE_I32.html '// 42i32'\n pub const CONST_EQ_TO_VALUE_I32: i32 = 42i32;\n \n-// @has show_const_contents/constant.CONST_CALC_I32.html '= 42 + 1; // 43i32'\n+// @has show_const_contents/constant.CONST_CALC_I32.html '= _; // 43i32'\n pub const CONST_CALC_I32: i32 = 42 + 1;\n \n // @!has show_const_contents/constant.CONST_REF_I32.html '= &42;'"}]}