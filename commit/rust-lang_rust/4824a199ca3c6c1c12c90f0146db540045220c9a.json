{"sha": "4824a199ca3c6c1c12c90f0146db540045220c9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MjRhMTk5Y2EzYzZjMWMxMmM5MGYwMTQ2ZGI1NDAwNDUyMjBjOWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-24T15:15:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-03T20:42:07Z"}, "message": "factor variances into a proper query\n\nThere are now two queries: crate and item. The crate one computes the\nvariance of all items in the crate; it is sort of an implementation\ndetail, and not meant to be used. The item one reads from the crate one,\nsynthesizing correct deps in lieu of the red-green algorithm.\n\nAt the same time, remove the `variance_computed` flag, which was a\nhorrible hack used to force invariance early on (e.g. when type-checking\nconstants). This is only needed because of trait applications, and\ntraits are always invariant anyway. Therefore, we now change to take\nadvantage of the query system:\n\n- When asked to compute variances for a trait, just return a vector\n  saying 'all invariant'.\n- Remove the corresponding \"inferreds\" from traits, and tweak the\n  constraint generation code to understand that traits are always\n  inferred.", "tree": {"sha": "13fc7438a45773d7d0d3ea4f94d706be650b4f20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13fc7438a45773d7d0d3ea4f94d706be650b4f20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4824a199ca3c6c1c12c90f0146db540045220c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4824a199ca3c6c1c12c90f0146db540045220c9a", "html_url": "https://github.com/rust-lang/rust/commit/4824a199ca3c6c1c12c90f0146db540045220c9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4824a199ca3c6c1c12c90f0146db540045220c9a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55412a201aa687e16cb76681d8dc7d595253800d", "url": "https://api.github.com/repos/rust-lang/rust/commits/55412a201aa687e16cb76681d8dc7d595253800d", "html_url": "https://github.com/rust-lang/rust/commit/55412a201aa687e16cb76681d8dc7d595253800d"}], "stats": {"total": 469, "additions": 295, "deletions": 174}, "files": [{"sha": "b4920f909cbdae09d86f5f27bededaa76874edfb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -81,6 +81,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TransCrateItem(D),\n     TransInlinedItem(D),\n     TransWriteMetadata,\n+    CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n@@ -89,6 +90,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    ItemVarianceConstraints(D),\n+    ItemVariances(D),\n     IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n@@ -199,6 +202,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             Coherence => Some(Coherence),\n+            CrateVariances => Some(CrateVariances),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n@@ -230,6 +234,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            ItemVariances(ref d) => op(d).map(ItemVariances),\n+            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n             IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))"}, {"sha": "13295e4030d56b778cb0377c187126a71b3c891b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -468,9 +468,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// True if the variance has been computed yet; false otherwise.\n-    pub variance_computed: Cell<bool>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -753,7 +750,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n-            variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),"}, {"sha": "3a2a6147345824f9029e9c79b8a4ba50c2effff9", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -265,6 +265,12 @@ impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\",\n@@ -673,9 +679,13 @@ define_maps! { <'tcx>\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n+    /// Get a map with the variance of every item; use `item_variance`\n+    /// instead.\n+    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [pub] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n@@ -810,3 +820,7 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n     DepNode::MirKeys\n }\n+\n+fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::CrateVariances\n+}"}, {"sha": "481098450eda416a9459f68d272c2e819351b321", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -55,6 +55,7 @@ use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -309,6 +310,27 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n+/// The crate variances map is computed during typeck and contains the\n+/// variance of every item in the local crate. You should not use it\n+/// directly, because to do so will make your pass dependent on the\n+/// HIR of every item in the local crate. Instead, use\n+/// `tcx.item_variances()` to get the variance for a *particular*\n+/// item.\n+pub struct CrateVariancesMap {\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n+\n+    /// For each item with generics, maps to a vector of the variance\n+    /// of its generics.  If an item has no generics, it will have no\n+    /// entry.\n+    pub variances: FxHashMap<DefId, Rc<Vec<ty::Variance>>>,\n+\n+    /// An empty vector, useful for cloning.\n+    pub empty_variance: Rc<Vec<ty::Variance>>,\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise."}, {"sha": "dfa11b9c71a04c6c038621d4dc63330310fa986b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -124,14 +124,8 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n            a_subst,\n            b_subst);\n \n-    let variances;\n-    let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = relation.tcx().variances_of(item_def_id);\n-        Some(&*variances)\n-    } else {\n-        None\n-    };\n-    relate_substs(relation, opt_variances, a_subst, b_subst)\n+    let opt_variances = relation.tcx().variances_of(item_def_id);\n+    relate_substs(relation, Some(&opt_variances), a_subst, b_subst)\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,"}, {"sha": "46463944043bd63c8d2c983246a919df159361c1", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -134,6 +134,20 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Returns a vector of all things less than `a`.\n+    ///\n+    /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n+    /// I'm too lazy to make that work, and -- given the caching\n+    /// strategy -- it'd be a touch tricky anyhow.\n+    pub fn less_than(&self, a: &T) -> Vec<&T> {\n+        match self.index(a) {\n+            Some(a) => self.with_closure(|closure| {\n+                closure.iter(a.0).map(|i| &self.elements[i]).collect()\n+            }),\n+            None => vec![],\n+        }\n+    }\n+\n     /// Picks what I am referring to as the \"postdominating\"\n     /// upper-bound for `a` and `b`. This is usually the least upper\n     /// bound, but in cases where there is no single least upper"}, {"sha": "efb7cacc5820cb03e035955694be73c5bd90a0d4", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -293,6 +293,7 @@ pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n     coherence::provide(providers);\n     check::provide(providers);\n+    variance::provide(providers);\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -307,9 +308,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     })?;\n \n-    time(time_passes, \"variance inference\", ||\n-         variance::infer_variance(tcx));\n-\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n              impl_wf_check::impl_wf_check(tcx));"}, {"sha": "9ec20c1a45c347c9dfd2bae71c320092db1227ec", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -97,51 +97,29 @@ types involved before considering variance.\n \n #### Dependency graph management\n \n-Because variance works in two phases, if we are not careful, we wind\n-up with a muddled mess of a dep-graph. Basically, when gathering up\n-the constraints, things are fairly well-structured, but then we do a\n-fixed-point iteration and write the results back where they\n-belong. You can't give this fixed-point iteration a single task\n-because it reads from (and writes to) the variance of all types in the\n-crate. In principle, we *could* switch the \"current task\" in a very\n-fine-grained way while propagating constraints in the fixed-point\n-iteration and everything would be automatically tracked, but that\n-would add some overhead and isn't really necessary anyway.\n-\n-Instead what we do is to add edges into the dependency graph as we\n-construct the constraint set: so, if computing the constraints for\n-node `X` requires loading the inference variables from node `Y`, then\n-we can add an edge `Y -> X`, since the variance we ultimately infer\n-for `Y` will affect the variance we ultimately infer for `X`.\n-\n-At this point, we've basically mirrored the inference graph in the\n-dependency graph. This means we can just completely ignore the\n-fixed-point iteration, since it is just shuffling values along this\n-graph. In other words, if we added the fine-grained switching of tasks\n-I described earlier, all it would show is that we repeatedly read the\n-values described by the constraints, but those edges were already\n-added when building the constraints in the first place.\n-\n-Here is how this is implemented (at least as of the time of this\n-writing). The associated `DepNode` for the variance map is (at least\n-presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n-when we visit an item to load up its constraints, we set\n-`Signature(DefId)` as the current task (the \"memoization\" pattern\n-described in the `dep-graph` README). Then whenever we find an\n-embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n-which covers the variances we will compute for all of its\n-parameters. This read is synthetic (i.e., we call\n-`variance_map.read()`) because, in fact, the final variance is not yet\n-computed -- the read *will* occur (repeatedly) during the fixed-point\n-iteration phase.\n-\n-In fact, we don't really *need* this synthetic read. That's because we\n-do wind up looking up the `TypeScheme` or `TraitDef` for all\n-references types/traits, and those reads add an edge from\n-`Signature(DefId)` (that is, they share the same dep node as\n-variance). However, I've kept the synthetic reads in place anyway,\n-just for future-proofing (in case we change the dep-nodes in the\n-future), and because it makes the intention a bit clearer I think.\n+Because variance is a whole-crate inference, its dependency graph\n+can become quite muddled if we are not careful. To resolve this, we refactor\n+into two queries:\n+\n+- `crate_variances` computes the variance for all items in the current crate.\n+- `item_variances` accesses the variance for an individual reading; it\n+  works by requesting `crate_variances` and extracting the relevant data.\n+  \n+If you limit yourself to reading `item_variances`, your code will only\n+depend then on the inference inferred for that particular item.\n+\n+Eventually, the goal is to rely on the red-green dependency management\n+algorithm. At the moment, however, we rely instead on a hack, where\n+`item_variances` ignores the dependencies of accessing\n+`crate_variances` and instead computes the *correct* dependencies\n+itself. To this end, when we build up the constraints in the system,\n+we also built up a transitive `dependencies` relation as part of the\n+crate map. A `(X, Y)` pair is added to the map each time we have a\n+constraint that the variance of some inferred for the item `X` depends\n+on the variance of some element of `Y`. This is to some extent a\n+mirroring of the inference graph in the dependency graph. This means\n+we can just completely ignore the fixed-point iteration, since it is\n+just shuffling values along this graph.\n \n ### Addendum: Variance on traits\n "}, {"sha": "e986a381cd963df034968e27a66fa463c2a5c2e6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 102, "deletions": 65, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -15,19 +15,20 @@\n \n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -38,6 +39,11 @@ pub struct ConstraintContext<'a, 'tcx: 'a> {\n     bivariant: VarianceTermPtr<'a>,\n \n     pub constraints: Vec<Constraint<'a>>,\n+\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -57,7 +63,6 @@ pub struct Constraint<'a> {\n ///\n /// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n /// the def-id and generics of `Foo`.\n-#[allow(dead_code)] // TODO -- `def_id` field not used yet\n pub struct CurrentItem<'a> {\n     def_id: DefId,\n     generics: &'a ty::Generics,\n@@ -77,10 +82,10 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n         invariant: invariant,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n+        dependencies: TransitiveRelation::new(),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut constraint_cx);\n \n     constraint_cx\n }\n@@ -90,13 +95,64 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         let def_id = tcx.hir.local_def_id(item.id);\n \n+        // Encapsulate constructing the constraints into a task we can\n+        // reference later. This can go away once the red-green\n+        // algorithm is in place.\n+        //\n+        // See README.md for a detailed discussion\n+        // on dep-graph management.\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n+                tcx.dep_graph.with_task(DepNode::ItemVarianceConstraints(def_id),\n+                                        AssertDepGraphSafe(self),\n+                                        def_id,\n+                                        visit_item_task);\n+            }\n+            _ => {\n+                // Nothing to do here, skip the task.\n+            }\n+        }\n+\n+        fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n+                                     def_id: DefId)\n+        {\n+            ccx.0.build_constraints_for_item(def_id);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(hir_map::NodeLifetime(..)) => true,\n+        _ => false,\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.terms_cx.tcx\n+    }\n+\n+    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+        let tcx = self.tcx();\n+        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+        let item = tcx.hir.expect_item(id);\n         debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(did);\n+                let generics = tcx.generics_of(def_id);\n                 let current_item = &CurrentItem { def_id, generics };\n \n                 // Not entirely obvious: constraints on structs/enums do not\n@@ -105,24 +161,14 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(did).all_fields() {\n+                for field in tcx.adt_def(def_id).all_fields() {\n                     self.add_constraints_from_ty(current_item,\n-                                                 tcx.item_type(field.did),\n+                                                 tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n-                let generics = tcx.generics_of(did);\n-                let current_item = &CurrentItem { def_id, generics };\n-                let trait_ref = ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: Substs::identity_for_item(tcx, def_id)\n-                };\n-                self.add_constraints_from_trait_ref(current_item,\n-                                                    trait_ref,\n-                                                    self.invariant);\n-            }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemStatic(..) |\n@@ -133,38 +179,25 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemGlobalAsm(..) |\n             hir::ItemTy(..) |\n             hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {}\n+            hir::ItemDefaultImpl(..) => {\n+                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.terms_cx.tcx\n+    /// Load the generics for another item, adding a corresponding\n+    /// relation into the dependencies to indicate that the variance\n+    /// for `current` relies on `def_id`.\n+    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n+        let generics = self.tcx().generics_of(def_id);\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+        generics\n     }\n \n-    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.get(&param_id) {\n-            Some(&index) => index,\n-            None => {\n-                bug!(\"no inferred index entry for {}\",\n-                     self.tcx().hir.node_to_string(param_id));\n-            }\n-        }\n+    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n+        self.terms_cx.inferred_map.get(&param_id)\n     }\n \n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n@@ -245,8 +278,27 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_node_id);\n-            self.terms_cx.inferred_infos[index].term\n+            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n+                self.terms_cx.inferred_infos[index].term\n+            } else {\n+                // If there is no inferred entry for a type parameter,\n+                // it must be declared on a (locally defiend) trait -- they don't\n+                // get inferreds because they are always invariant.\n+                if cfg!(debug_assertions) {\n+                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n+                    let item = self.tcx().hir.expect_item(item_node_id);\n+                    let success = match item.node {\n+                        hir::ItemTrait(..) => true,\n+                        _ => false,\n+                    };\n+                    if !success {\n+                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n+                             item_def_id,\n+                             item);\n+                    }\n+                }\n+                self.invariant\n+            }\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -305,11 +357,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-        // This edge is actually implied by the call to\n-        // `trait_def`, but I'm trying to be future-proof. See\n-        // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n         self.add_constraints_from_substs(current,\n                                          trait_ref.def_id,\n                                          &trait_generics.types,\n@@ -362,12 +409,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.tcx().generics_of(def.did);\n-\n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n+                let adt_generics = self.read_generics(current, def.did);\n \n                 self.add_constraints_from_substs(current,\n                                                  def.did,\n@@ -381,11 +423,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let trait_ref = &data.trait_ref;\n                 let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n                 self.add_constraints_from_substs(current,\n                                                  trait_ref.def_id,\n                                                  &trait_generics.types,\n@@ -505,7 +542,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let def_id = current.generics.regions[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n-                    let index = self.inferred_index(node_id);\n+                    let &index = self.opt_inferred_index(node_id).unwrap();\n                     self.add_constraint(index, variance);\n                 }\n             }"}, {"sha": "99e23589dd730584261ff9b1d1a594908e39dce5", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -12,7 +12,12 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::ty::TyCtxt;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use std::rc::Rc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -27,10 +32,60 @@ mod solve;\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        variances_of,\n+        crate_variances,\n+        ..*providers\n+    };\n+}\n+\n+fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+                             -> Rc<CrateVariancesMap> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    solve::solve_constraints(constraints_cx);\n-    tcx.variance_computed.set(true);\n+    Rc::new(solve::solve_constraints(constraints_cx))\n+}\n+\n+fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+                            -> Rc<Vec<ty::Variance>> {\n+    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let item = tcx.hir.expect_item(item_id);\n+    match item.node {\n+        hir::ItemTrait(..) => {\n+            // Traits are always invariant.\n+            let generics = tcx.generics_of(item_def_id);\n+            assert!(generics.parent.is_none());\n+            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n+        }\n+\n+        hir::ItemEnum(..) |\n+        hir::ItemStruct(..) |\n+        hir::ItemUnion(..) => {\n+            // Everything else must be inferred.\n+\n+            // Lacking red/green, we read the variances for all items here\n+            // but ignore the dependencies, then re-synthesize the ones we need.\n+            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+            tcx.dep_graph.read(DepNode::ItemVarianceConstraints(item_def_id));\n+            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+                if dep_def_id.is_local() {\n+                    tcx.dep_graph.read(DepNode::ItemVarianceConstraints(dep_def_id));\n+                } else {\n+                    tcx.dep_graph.read(DepNode::ItemVariances(dep_def_id));\n+                }\n+            }\n+\n+            crate_map.variances.get(&item_def_id)\n+                               .unwrap_or(&crate_map.empty_variance)\n+                               .clone()\n+        }\n+\n+        _ => {\n+            // Variance not relevant.\n+            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+        }\n+    }\n }"}, {"sha": "5ba5005ccc21007469bd78403e4b33e053fb9c42", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -15,7 +15,9 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -31,8 +33,8 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n+pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+    let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n     let solutions = terms_cx.inferred_infos\n         .iter()\n@@ -45,7 +47,10 @@ pub fn solve_constraints(constraints_cx: ConstraintContext) {\n         solutions: solutions,\n     };\n     solutions_cx.solve();\n-    solutions_cx.write();\n+    let variances = solutions_cx.create_map();\n+    let empty_variance = Rc::new(Vec::new());\n+\n+    ty::CrateVariancesMap { dependencies, variances, empty_variance }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -83,7 +88,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write(&self) {\n+    fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n         // Collect all the variances for a particular item and stick\n         // them into the variance map. We rely on the fact that we\n         // generate all the inferreds for a particular item\n@@ -95,11 +100,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let tcx = self.terms_cx.tcx;\n \n-        // Ignore the writes here because the relevant edges were\n-        // already accounted for in `constraints.rs`. See the section\n-        // on dependency graph management in README.md for more\n-        // information.\n-        let _ignore = tcx.dep_graph.in_ignore();\n+        let mut map = FxHashMap();\n \n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n@@ -137,9 +138,10 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            tcx.maps.variances_of.borrow_mut()\n-               .insert(item_def_id, Rc::new(item_variances));\n+            map.insert(item_def_id, Rc::new(item_variances));\n         }\n+\n+        map\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "3f4b15e35a42db30d6019df2c046ac3efcada97a", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -139,7 +139,6 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self,\n                               item_id: ast::NodeId,\n-                              has_self: bool,\n                               generics: &hir::Generics) {\n         //! Add \"inferreds\" for the generic parameters declared on this\n         //! item. This has a lot of annoying parameters because we are\n@@ -149,38 +148,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         //!\n \n         // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-        let inferreds_on_entry = self.num_inferred();\n-\n-        if has_self {\n-            self.add_inferred(item_id, 0, item_id);\n-        }\n-\n-        for (i, p) in generics.lifetimes.iter().enumerate() {\n+        for (p, i) in generics.lifetimes.iter().zip(0..) {\n             let id = p.lifetime.id;\n-            let i = has_self as usize + i;\n             self.add_inferred(item_id, i, id);\n         }\n \n-        for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + generics.lifetimes.len() + i;\n+        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n             self.add_inferred(item_id, i, p.id);\n         }\n-\n-        // If this item has no type or lifetime parameters,\n-        // then there are no variances to infer, so just\n-        // insert an empty entry into the variance map.\n-        // Arguably we could just leave the map empty in this\n-        // case but it seems cleaner to be able to distinguish\n-        // \"invalid item id\" from \"item id with no\n-        // parameters\".\n-        if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx.maps.variances_of.borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone());\n-        }\n     }\n \n     fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n@@ -232,15 +210,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, false, generics);\n-            }\n-            hir::ItemTrait(_, ref generics, ..) => {\n-                // Note: all inputs for traits are ultimately\n-                // constrained to be invariant. See `visit_item` in\n-                // the impl for `ConstraintContext` in `constraints.rs`.\n-                self.add_inferreds_for_item(item.id, true, generics);\n+                self.add_inferreds_for_item(item.id, generics);\n             }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemDefaultImpl(..) |"}, {"sha": "9b621a13fc484b7200b44c96a81294ab127664bd", "filename": "src/test/compile-fail/dep-graph-variance-alias.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4824a199ca3c6c1c12c90f0146db540045220c9a/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs?ref=4824a199ca3c6c1c12c90f0146db540045220c9a", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that changing what a `type` points to does not go unnoticed\n+// by the variance analysis.\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+struct Foo<T> {\n+    f: T\n+}\n+\n+#[rustc_if_this_changed]\n+type TypeAlias<T> = Foo<T>;\n+\n+#[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK\n+struct Use<T> {\n+    x: TypeAlias<T>\n+}"}]}