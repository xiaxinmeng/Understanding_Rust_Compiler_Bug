{"sha": "7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjODRlNDUxZDUzM2YxMmQzYTFhN2IzNWNhNjZiZGQwMmVjZjE3ZmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-29T08:40:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-29T08:40:40Z"}, "message": "move panic intrinsic codegen to helper function", "tree": {"sha": "fd7c1b6633a90e1ef67d61ac725ddc7aa824505c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd7c1b6633a90e1ef67d61ac725ddc7aa824505c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc", "html_url": "https://github.com/rust-lang/rust/commit/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfe593e03a0f73ee52ac666be17e963957ef628f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe593e03a0f73ee52ac666be17e963957ef628f", "html_url": "https://github.com/rust-lang/rust/commit/bfe593e03a0f73ee52ac666be17e963957ef628f"}], "stats": {"total": 158, "additions": 92, "deletions": 66}, "files": [{"sha": "c8d352cd2dd988361543f0aa80bd393a4f8cdfae", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=7c84e451d533f12d3a1a7b35ca66bdd02ecf17fc", "patch": "@@ -434,6 +434,89 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup);\n     }\n \n+    /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n+    fn codegen_panic_intrinsic(\n+        &mut self,\n+        helper: &TerminatorCodegenHelper<'tcx>,\n+        bx: &mut Bx,\n+        intrinsic: Option<&str>,\n+        instance: Option<Instance<'tcx>>,\n+        span: Span,\n+        destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n+        cleanup: Option<mir::BasicBlock>,\n+    ) -> bool {\n+        // Emit a panic or a no-op for `panic_if_uninhabited`.\n+        // These are intrinsics that compile to panics so that we can get a message\n+        // which mentions the offending type, even from a const context.\n+        #[derive(Debug, PartialEq)]\n+        enum PanicIntrinsic {\n+            IfUninhabited,\n+            IfZeroInvalid,\n+            IfAnyInvalid,\n+        };\n+        let panic_intrinsic = intrinsic.and_then(|i| match i {\n+            // FIXME: Move to symbols instead of strings.\n+            \"panic_if_uninhabited\" => Some(PanicIntrinsic::IfUninhabited),\n+            \"panic_if_zero_invalid\" => Some(PanicIntrinsic::IfZeroInvalid),\n+            \"panic_if_any_invalid\" => Some(PanicIntrinsic::IfAnyInvalid),\n+            _ => None,\n+        });\n+        if let Some(intrinsic) = panic_intrinsic {\n+            use PanicIntrinsic::*;\n+            let ty = instance.unwrap().substs.type_at(0);\n+            let layout = bx.layout_of(ty);\n+            let do_panic = match intrinsic {\n+                IfUninhabited => layout.abi.is_uninhabited(),\n+                // We unwrap as the error type is `!`.\n+                IfZeroInvalid => !layout.might_permit_raw_init(bx, /*zero:*/ true).unwrap(),\n+                // We unwrap as the error type is `!`.\n+                IfAnyInvalid => !layout.might_permit_raw_init(bx, /*zero:*/ false).unwrap(),\n+            };\n+            if do_panic {\n+                let msg_str = if layout.abi.is_uninhabited() {\n+                    // Use this error even for the other intrinsics as it is more precise.\n+                    format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n+                } else if intrinsic == IfZeroInvalid {\n+                    format!(\"attempted to zero-initialize type `{}`, which is invalid\", ty)\n+                } else {\n+                    format!(\"attempted to leave type `{}` uninitialized, which is invalid\", ty)\n+                };\n+                let msg = bx.const_str(Symbol::intern(&msg_str));\n+                let location = self.get_caller_location(bx, span).immediate();\n+\n+                // Obtain the panic entry point.\n+                // FIXME: dedup this with `codegen_assert_terminator` above.\n+                let def_id =\n+                    common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n+                let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n+                let llfn = bx.get_fn_addr(instance);\n+\n+                if let Some((_, target)) = destination.as_ref() {\n+                    helper.maybe_sideeffect(self.mir, bx, &[*target]);\n+                }\n+                // Codegen the actual panic invoke/call.\n+                helper.do_call(\n+                    self,\n+                    bx,\n+                    fn_abi,\n+                    llfn,\n+                    &[msg.0, msg.1, location],\n+                    destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n+                    cleanup,\n+                );\n+            } else {\n+                // a NOP\n+                let target = destination.as_ref().unwrap().1;\n+                helper.maybe_sideeffect(self.mir, bx, &[target]);\n+                helper.funclet_br(self, bx, target)\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn codegen_call_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n@@ -520,72 +603,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bug!(\"`miri_start_panic` should never end up in compiled code\");\n         }\n \n-        // Emit a panic or a no-op for `panic_if_uninhabited`.\n-        // These are intrinsics that compile to panics so that we can get a message\n-        // which mentions the offending type, even from a const context.\n-        #[derive(Debug, PartialEq)]\n-        enum PanicIntrinsic {\n-            IfUninhabited,\n-            IfZeroInvalid,\n-            IfAnyInvalid,\n-        };\n-        let panic_intrinsic = intrinsic.and_then(|i| match i {\n-            // FIXME: Move to symbols instead of strings.\n-            \"panic_if_uninhabited\" => Some(PanicIntrinsic::IfUninhabited),\n-            \"panic_if_zero_invalid\" => Some(PanicIntrinsic::IfZeroInvalid),\n-            \"panic_if_any_invalid\" => Some(PanicIntrinsic::IfAnyInvalid),\n-            _ => None,\n-        });\n-        if let Some(intrinsic) = panic_intrinsic {\n-            use PanicIntrinsic::*;\n-            let ty = instance.unwrap().substs.type_at(0);\n-            let layout = bx.layout_of(ty);\n-            let do_panic = match intrinsic {\n-                IfUninhabited => layout.abi.is_uninhabited(),\n-                // We unwrap as the error type is `!`.\n-                IfZeroInvalid => !layout.might_permit_raw_init(&bx, /*zero:*/ true).unwrap(),\n-                // We unwrap as the error type is `!`.\n-                IfAnyInvalid => !layout.might_permit_raw_init(&bx, /*zero:*/ false).unwrap(),\n-            };\n-            if do_panic {\n-                let msg_str = if layout.abi.is_uninhabited() {\n-                    // Use this error even for the other intrinsics as it is more precise.\n-                    format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n-                } else if intrinsic == IfZeroInvalid {\n-                    format!(\"attempted to zero-initialize type `{}`, which is invalid\", ty)\n-                } else {\n-                    format!(\"attempted to leave type `{}` uninitialized, which is invalid\", ty)\n-                };\n-                let msg = bx.const_str(Symbol::intern(&msg_str));\n-                let location = self.get_caller_location(&mut bx, span).immediate();\n-\n-                // Obtain the panic entry point.\n-                // FIXME: dedup this with `codegen_assert_terminator` above.\n-                let def_id =\n-                    common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n-                let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n-                let llfn = bx.get_fn_addr(instance);\n-\n-                if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n-                }\n-                // Codegen the actual panic invoke/call.\n-                helper.do_call(\n-                    self,\n-                    &mut bx,\n-                    fn_abi,\n-                    llfn,\n-                    &[msg.0, msg.1, location],\n-                    destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n-                    cleanup,\n-                );\n-            } else {\n-                // a NOP\n-                let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target)\n-            }\n+        if self.codegen_panic_intrinsic(\n+            &helper,\n+            &mut bx,\n+            intrinsic,\n+            instance,\n+            span,\n+            destination,\n+            cleanup,\n+        ) {\n             return;\n         }\n "}]}