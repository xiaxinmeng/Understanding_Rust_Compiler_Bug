{"sha": "4f5616e3c43f866f4758a21f67d98da52b89ee20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNTYxNmUzYzQzZjg2NmY0NzU4YTIxZjY3ZDk4ZGE1MmI4OWVlMjA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-22T07:12:13Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-01T22:30:29Z"}, "message": "Avoid cascading name resolution errors caused by an ambiguous module.", "tree": {"sha": "1022ea0c9d9ccdbd18fa10db24a60a51482761a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1022ea0c9d9ccdbd18fa10db24a60a51482761a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f5616e3c43f866f4758a21f67d98da52b89ee20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5616e3c43f866f4758a21f67d98da52b89ee20", "html_url": "https://github.com/rust-lang/rust/commit/4f5616e3c43f866f4758a21f67d98da52b89ee20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f5616e3c43f866f4758a21f67d98da52b89ee20/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32a0cfeb485f2c1bbfe52eaa9e119e974e38f21f", "url": "https://api.github.com/repos/rust-lang/rust/commits/32a0cfeb485f2c1bbfe52eaa9e119e974e38f21f", "html_url": "https://github.com/rust-lang/rust/commit/32a0cfeb485f2c1bbfe52eaa9e119e974e38f21f"}], "stats": {"total": 75, "additions": 45, "deletions": 30}, "files": [{"sha": "0fe7f9ed21547d5f022cee680220e2c418cfd0ed", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4f5616e3c43f866f4758a21f67d98da52b89ee20", "patch": "@@ -749,10 +749,6 @@ impl<'a> LexicalScopeBinding<'a> {\n             _ => None,\n         }\n     }\n-\n-    fn module(self) -> Option<Module<'a>> {\n-        self.item().and_then(NameBinding::module)\n-    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -884,12 +880,13 @@ enum NameBindingKind<'a> {\n struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n impl<'a> NameBinding<'a> {\n-    fn module(&self) -> Option<Module<'a>> {\n+    fn module(&self) -> Result<Module<'a>, bool /* true if an error has already been reported */> {\n         match self.kind {\n-            NameBindingKind::Module(module) => Some(module),\n-            NameBindingKind::Def(_) => None,\n+            NameBindingKind::Module(module) => Ok(module),\n             NameBindingKind::Import { binding, .. } => binding.module(),\n-            NameBindingKind::Ambiguity { ..  } => None,\n+            NameBindingKind::Def(Def::Err) => Err(true),\n+            NameBindingKind::Def(_) => Err(false),\n+            NameBindingKind::Ambiguity { ..  } => Err(false),\n         }\n     }\n \n@@ -915,7 +912,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().and_then(|module| module.extern_crate_id).is_some()\n+        self.module().ok().and_then(|module| module.extern_crate_id).is_some()\n     }\n \n     fn is_import(&self) -> bool {\n@@ -1269,7 +1266,7 @@ impl<'a> Resolver<'a> {\n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().ok().and_then(ModuleS::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n@@ -1292,6 +1289,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn expect_module(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Option<Span>)\n+                     -> ResolveResult<Module<'a>> {\n+        match binding.module() {\n+            Ok(module) => Success(module),\n+            Err(true) => Failed(None),\n+            Err(false) => {\n+                let msg = format!(\"Not a module `{}`\", name);\n+                Failed(span.map(|span| (span, msg)))\n+            }\n+        }\n+    }\n+\n     /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n                                      mut search_module: Module<'a>,\n@@ -1357,11 +1366,9 @@ impl<'a> Resolver<'a> {\n                 Success(binding) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    if let Some(module_def) = binding.module() {\n-                        search_module = module_def;\n-                    } else {\n-                        let msg = format!(\"Not a module `{}`\", name);\n-                        return Failed(span.map(|span| (span, msg)));\n+                    match self.expect_module(name, binding, span) {\n+                        Success(module) => search_module = module,\n+                        result @ _ => return result,\n                     }\n                 }\n             }\n@@ -1414,17 +1421,20 @@ impl<'a> Resolver<'a> {\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n                         let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n-                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, span)\n-                                  .and_then(LexicalScopeBinding::module) {\n-                            None => {\n-                                let msg =\n-                                    format!(\"Use of undeclared type or module `{}`\", ident.name);\n-                                return Failed(span.map(|span| (span, msg)));\n-                            }\n-                            Some(containing_module) => {\n-                                search_module = containing_module;\n-                                start_index = 1;\n+                        let lexical_binding =\n+                            self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n+                        if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n+                            match self.expect_module(ident.name, binding, span) {\n+                                Success(containing_module) => {\n+                                    search_module = containing_module;\n+                                    start_index = 1;\n+                                }\n+                                result @ _ => return result,\n                             }\n+                        } else {\n+                            let msg =\n+                                format!(\"Use of undeclared type or module `{}`\", ident.name);\n+                            return Failed(span.map(|span| (span, msg)));\n                         }\n                     }\n                 }\n@@ -3202,7 +3212,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // collect submodules to explore\n-                if let Some(module) = name_binding.module() {\n+                if let Ok(module) = name_binding.module() {\n                     // form the path\n                     let path_segments = match module.parent_link {\n                         NoParentLink => path_segments.clone(),\n@@ -3341,9 +3351,9 @@ impl<'a> Resolver<'a> {\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n-                (TypeNS, Some(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n-                (TypeNS, Some(module)) if module.is_normal() => \"a module\",\n-                (TypeNS, Some(module)) if module.is_trait() => \"a trait\",\n+                (TypeNS, Ok(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n+                (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n             };\n             format!(\"{} named `{}` has already been {} in this {}\","}, {"sha": "c8982d95d4e0084320db43e57589d64a4d76ada4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4f5616e3c43f866f4758a21f67d98da52b89ee20", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 errors = true;\n                 let (span, help) = match err {\n                     Some((span, msg)) => (span, msg),\n-                    None => (import.span, String::new()),\n+                    None => continue,\n                 };\n \n                 // If the error is a single failed import then create a \"fake\" import"}, {"sha": "fb61bb8e489bec7b3e9ccb80f251ea8fcc423f29", "filename": "src/test/compile-fail/imports/duplicate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5616e3c43f866f4758a21f67d98da52b89ee20/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs?ref=4f5616e3c43f866f4758a21f67d98da52b89ee20", "patch": "@@ -56,7 +56,12 @@ mod ambiguous_module_errors {\n     pub mod m2 { pub use super::m2 as foo; }\n \n     use self::m1::*; //~ NOTE\n+                     //~| NOTE\n     use self::m2::*; //~ NOTE\n+                     //~| NOTE\n+\n+    use self::foo::bar; //~ ERROR `foo` is ambiguous\n+                        //~| NOTE\n \n     fn f() {\n         foo::bar(); //~ ERROR `foo` is ambiguous"}]}