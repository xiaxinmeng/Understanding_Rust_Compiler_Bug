{"sha": "b96639f23ac5c361370cb900fd924f34d2af60a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NjYzOWYyM2FjNWMzNjEzNzBjYjkwMGZkOTI0ZjM0ZDJhZjYwYTg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-23T07:21:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-23T07:21:31Z"}, "message": "Merge pull request #2143 from HMPerson1/master\n\nAdd lint for fallible impls of `From`", "tree": {"sha": "44027ed6c19c56df67722991b558a201e8695134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44027ed6c19c56df67722991b558a201e8695134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b96639f23ac5c361370cb900fd924f34d2af60a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b96639f23ac5c361370cb900fd924f34d2af60a8", "html_url": "https://github.com/rust-lang/rust/commit/b96639f23ac5c361370cb900fd924f34d2af60a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b96639f23ac5c361370cb900fd924f34d2af60a8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d89798119681b2fbd108a0640a8507d3d3720ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d89798119681b2fbd108a0640a8507d3d3720ec", "html_url": "https://github.com/rust-lang/rust/commit/6d89798119681b2fbd108a0640a8507d3d3720ec"}, {"sha": "7206023b1b203e478fdbe450e63829690a92d6a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7206023b1b203e478fdbe450e63829690a92d6a4", "html_url": "https://github.com/rust-lang/rust/commit/7206023b1b203e478fdbe450e63829690a92d6a4"}], "stats": {"total": 290, "additions": 290, "deletions": 0}, "files": [{"sha": "bdcda99124c62a77d70fd2f26c937b9085b06374", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=b96639f23ac5c361370cb900fd924f34d2af60a8", "patch": "@@ -0,0 +1,130 @@\n+use rustc::lint::*;\n+use rustc::hir;\n+use rustc::ty;\n+use syntax_pos::Span;\n+use utils::{method_chain_args, match_def_path, span_lint_and_then, walk_ptrs_ty};\n+use utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n+\n+/// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+///\n+/// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// struct Foo(i32);\n+/// impl From<String> for Foo {\n+///     fn from(s: String) -> Self {\n+///         Foo(s.parse().unwrap())\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub FALLIBLE_IMPL_FROM, Allow,\n+    \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\"\n+}\n+\n+pub struct FallibleImplFrom;\n+\n+impl LintPass for FallibleImplFrom {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(FALLIBLE_IMPL_FROM)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        // check for `impl From<???> for ..`\n+        let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n+        if_let_chain!{[\n+            let hir::ItemImpl(.., ref impl_items) = item.node,\n+            let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id),\n+            match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT),\n+        ], {\n+            lint_impl_body(cx, item.span, impl_items);\n+        }}\n+    }\n+}\n+\n+fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_items: &hir::HirVec<hir::ImplItemRef>) {\n+    use rustc::hir::*;\n+    use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+\n+    struct FindPanicUnwrap<'a, 'tcx: 'a> {\n+        tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+        tables: &'tcx ty::TypeckTables<'tcx>,\n+        result: Vec<Span>,\n+    }\n+\n+    impl<'a, 'tcx: 'a> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr) {\n+            // check for `begin_panic`\n+            if_let_chain!{[\n+                let ExprCall(ref func_expr, _) = expr.node,\n+                let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node,\n+                match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC) ||\n+                    match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC_FMT),\n+            ], {\n+                self.result.push(expr.span);\n+            }}\n+\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n+                if match_type(self.tcx, reciever_ty, &OPTION) ||\n+                    match_type(self.tcx, reciever_ty, &RESULT)\n+                {\n+                    self.result.push(expr.span);\n+                }\n+            }\n+\n+            // and check sub-expressions\n+            intravisit::walk_expr(self, expr);\n+        }\n+\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+\n+    for impl_item in impl_items {\n+        if_let_chain!{[\n+            impl_item.name == \"from\",\n+            let ImplItemKind::Method(_, body_id) =\n+                cx.tcx.hir.impl_item(impl_item.id).node,\n+        ], {\n+            // check the body for `begin_panic` or `unwrap`\n+            let body = cx.tcx.hir.body(body_id);\n+            let impl_item_def_id = cx.tcx.hir.local_def_id(impl_item.id.node_id);\n+            let mut fpu = FindPanicUnwrap {\n+                tcx: cx.tcx,\n+                tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                result: Vec::new(),\n+            };\n+            fpu.visit_expr(&body.value);\n+\n+            // if we've found one, lint\n+            if !fpu.result.is_empty() {\n+                span_lint_and_then(\n+                    cx,\n+                    FALLIBLE_IMPL_FROM,\n+                    impl_span,\n+                    \"consider implementing `TryFrom` instead\",\n+                    move |db| {\n+                        db.help(\n+                            \"`From` is intended for infallible conversions only. \\\n+                             Use `TryFrom` if there's a possibility for the conversion to fail.\");\n+                        db.span_note(fpu.result, \"potential failure(s)\");\n+                    });\n+            }\n+        }}\n+    }\n+}\n+\n+fn match_type(tcx: ty::TyCtxt, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n+        _ => false,\n+    }\n+}"}, {"sha": "81839b92cd53a4349ba4bd7701a2d7f2a3fc7a00", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b96639f23ac5c361370cb900fd924f34d2af60a8", "patch": "@@ -100,6 +100,7 @@ pub mod identity_conversion;\n pub mod identity_op;\n pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n+pub mod fallible_impl_from;\n pub mod infinite_iter;\n pub mod int_plus_one;\n pub mod invalid_ref;\n@@ -341,6 +342,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box identity_conversion::IdentityConversion::default());\n     reg.register_late_lint_pass(box types::ImplicitHasher);\n     reg.register_early_lint_pass(box const_static_lifetime::StaticConst);\n+    reg.register_late_lint_pass(box fallible_impl_from::FallibleImplFrom);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -446,6 +448,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         identity_conversion::IDENTITY_CONVERSION,\n         identity_op::IDENTITY_OP,\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n+        fallible_impl_from::FALLIBLE_IMPL_FROM,\n         infinite_iter::INFINITE_ITER,\n         invalid_ref::INVALID_REF,\n         is_unit_expr::UNIT_EXPR,"}, {"sha": "96ccddaf2d04c1ea3b04a41d8907b785ec574f73", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96639f23ac5c361370cb900fd924f34d2af60a8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=b96639f23ac5c361370cb900fd924f34d2af60a8", "patch": "@@ -6,6 +6,7 @@ pub const ARC: [&str; 3] = [\"alloc\", \"arc\", \"Arc\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n+pub const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n pub const BINARY_HEAP: [&str; 3] = [\"alloc\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BOX: [&str; 3] = [\"std\", \"boxed\", \"Box\"];\n@@ -27,6 +28,7 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n+pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];"}, {"sha": "eb1cd4c5e9ada59413ed5b4302c0df870d585802", "filename": "tests/ui/fallible_impl_from.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b96639f23ac5c361370cb900fd924f34d2af60a8/tests%2Fui%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96639f23ac5c361370cb900fd924f34d2af60a8/tests%2Fui%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffallible_impl_from.rs?ref=b96639f23ac5c361370cb900fd924f34d2af60a8", "patch": "@@ -0,0 +1,64 @@\n+#![deny(fallible_impl_from)]\n+\n+// docs example\n+struct Foo(i32);\n+impl From<String> for Foo {\n+    fn from(s: String) -> Self {\n+        Foo(s.parse().unwrap())\n+    }\n+}\n+\n+\n+struct Valid(Vec<u8>);\n+\n+impl<'a> From<&'a str> for Valid {\n+    fn from(s: &'a str) -> Valid {\n+        Valid(s.to_owned().into_bytes())\n+    }\n+}\n+impl From<usize> for Valid {\n+    fn from(i: usize) -> Valid {\n+        Valid(Vec::with_capacity(i))\n+    }\n+}\n+\n+\n+struct Invalid;\n+\n+impl From<usize> for Invalid {\n+    fn from(i: usize) -> Invalid {\n+        if i != 42 {\n+            panic!();\n+        }\n+        Invalid\n+    }\n+}\n+\n+impl From<Option<String>> for Invalid {\n+    fn from(s: Option<String>) -> Invalid {\n+        let s = s.unwrap();\n+        if !s.is_empty() {\n+            panic!(42);\n+        } else if s.parse::<u32>().unwrap() != 42 {\n+            panic!(\"{:?}\", s);\n+        }\n+        Invalid\n+    }\n+}\n+\n+trait ProjStrTrait {\n+    type ProjString;\n+}\n+impl<T> ProjStrTrait for Box<T> {\n+    type ProjString = String;\n+}\n+impl<'a> From<&'a mut <Box<u32> as ProjStrTrait>::ProjString> for Invalid {\n+    fn from(s: &'a mut <Box<u32> as ProjStrTrait>::ProjString) -> Invalid {\n+        if s.parse::<u32>().ok().unwrap() != 42 {\n+            panic!(\"{:?}\", s);\n+        }\n+        Invalid\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "89dfaf623ed83d4a67b4b78eca8cd4e318abccb5", "filename": "tests/ui/fallible_impl_from.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b96639f23ac5c361370cb900fd924f34d2af60a8/tests%2Fui%2Ffallible_impl_from.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b96639f23ac5c361370cb900fd924f34d2af60a8/tests%2Fui%2Ffallible_impl_from.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffallible_impl_from.stderr?ref=b96639f23ac5c361370cb900fd924f34d2af60a8", "patch": "@@ -0,0 +1,91 @@\n+error: consider implementing `TryFrom` instead\n+ --> $DIR/fallible_impl_from.rs:5:1\n+  |\n+5 | / impl From<String> for Foo {\n+6 | |     fn from(s: String) -> Self {\n+7 | |         Foo(s.parse().unwrap())\n+8 | |     }\n+9 | | }\n+  | |_^\n+  |\n+note: lint level defined here\n+ --> $DIR/fallible_impl_from.rs:1:9\n+  |\n+1 | #![deny(fallible_impl_from)]\n+  |         ^^^^^^^^^^^^^^^^^^\n+  = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+note: potential failure(s)\n+ --> $DIR/fallible_impl_from.rs:7:13\n+  |\n+7 |         Foo(s.parse().unwrap())\n+  |             ^^^^^^^^^^^^^^^^^^\n+\n+error: consider implementing `TryFrom` instead\n+  --> $DIR/fallible_impl_from.rs:28:1\n+   |\n+28 | / impl From<usize> for Invalid {\n+29 | |     fn from(i: usize) -> Invalid {\n+30 | |         if i != 42 {\n+31 | |             panic!();\n+...  |\n+34 | |     }\n+35 | | }\n+   | |_^\n+   |\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+note: potential failure(s)\n+  --> $DIR/fallible_impl_from.rs:31:13\n+   |\n+31 |             panic!();\n+   |             ^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: consider implementing `TryFrom` instead\n+  --> $DIR/fallible_impl_from.rs:37:1\n+   |\n+37 | / impl From<Option<String>> for Invalid {\n+38 | |     fn from(s: Option<String>) -> Invalid {\n+39 | |         let s = s.unwrap();\n+40 | |         if !s.is_empty() {\n+...  |\n+46 | |     }\n+47 | | }\n+   | |_^\n+   |\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+note: potential failure(s)\n+  --> $DIR/fallible_impl_from.rs:39:17\n+   |\n+39 |         let s = s.unwrap();\n+   |                 ^^^^^^^^^^\n+40 |         if !s.is_empty() {\n+41 |             panic!(42);\n+   |             ^^^^^^^^^^^\n+42 |         } else if s.parse::<u32>().unwrap() != 42 {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+43 |             panic!(\"{:?}\", s);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: consider implementing `TryFrom` instead\n+  --> $DIR/fallible_impl_from.rs:55:1\n+   |\n+55 | / impl<'a> From<&'a mut <Box<u32> as ProjStrTrait>::ProjString> for Invalid {\n+56 | |     fn from(s: &'a mut <Box<u32> as ProjStrTrait>::ProjString) -> Invalid {\n+57 | |         if s.parse::<u32>().ok().unwrap() != 42 {\n+58 | |             panic!(\"{:?}\", s);\n+...  |\n+61 | |     }\n+62 | | }\n+   | |_^\n+   |\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+note: potential failure(s)\n+  --> $DIR/fallible_impl_from.rs:57:12\n+   |\n+57 |         if s.parse::<u32>().ok().unwrap() != 42 {\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+58 |             panic!(\"{:?}\", s);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+"}]}