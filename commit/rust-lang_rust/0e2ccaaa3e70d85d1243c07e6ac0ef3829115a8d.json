{"sha": "0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMmNjYWFhM2U3MGQ4NWQxMjQzYzA3ZTZhYzBlZjM4MjkxMTVhOGQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-15T01:19:34Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-18T19:01:36Z"}, "message": "Fix 'type annotations needed' error with opaque types\n\nRelated: #66426\n\nThis commit adds handling for opaque types during inference variable\nfallback. Type variables generated from the instantiatino of opaque\ntypes now fallback to the opque type itself.\n\nNormally, the type variable for an instantiated opaque type is either\nunified with the concrete type, or with the opaque type itself (e.g when\na function returns an opaque type by calling another function).\n\nHowever, it's possible for the type variable to be left completely\nunconstrained. This can occur in code like this:\n\n```rust\npub type Foo = impl Copy;\nfn produce() -> Option<Foo> {\n    None\n}\n```\n\nHere, we'll instantatiate the `Foo` in `Option<Foo>` to a fresh type\nvariable, but we will never unify it with anything due to the fact\nthat we return a `None`.\n\nThis results in the error message:\n\n`type annotations needed: cannot resolve `_: std::marker::Copy``\n\npointing at `pub type Foo = impl Copy`.\n\nThis message is not only confusing, it's incorrect. When an opaque type\ninference variable is completely unconstrained, we can always fall back\nto using the opaque type itself. This effectively turns that particular\nuse of the opaque type into a non-defining use, even if it appears in a\ndefining scope.", "tree": {"sha": "752bbf3236269b21bff14e63be3efefe643f6e88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/752bbf3236269b21bff14e63be3efefe643f6e88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3S6pAACgkQtAh+UQ6Y\nsWSPSQ//RGvXFOoC2jpgOrKJ2Tekr1UgccVNLQu3FcY+jZ6MT0gml9w0qOU8gcPI\n3PGUMbDQaJCckHtg7ap3ELVDlh0UJlPKqf+b2riDp0jpsIVE4UoQqdxjQz/GwGo/\nBEbfFD6Xj4Kd51WVgs5ob9taYh8VfrMX2iw/XIvWf9MLXYbwye1va0aDOMLj2h03\nOd3Shg/dZaGPaL7VFBlsDPjYBrp4nIzHre5RbH3C8PVFwP6oJfzTQWbJ1BPdDmx/\nzqbSgX3oX0GNYPrjRfJr9VPEo/M9ZjuW9q7Yd6BuyT6GX1ZtpIZrSaoxQ/fhCc6i\nHVyu08UWgicojXFf1SKk5XxuyWA3gwsFVd40Nso0p2nEdzQSrmERQlM7lOSM2TpA\nz5si0g6B1Zcm7Qk/eeSd/6mIgDGp/BEAcLKB258gLN1P+nlY706F3KoXTyUWXqht\nE5ecTtflFbCHMFoKkJHHl6XKJqmtG8TX+NGQ4VmOJ27kuWNhZUOSS6tOxFWIi8Rq\ndQ45r0Ieuz9HEs+EHK0qH3wdLuvpXztYwtTQvP6J7zAeMRXpWUI9TcwgANlwdM17\n+5DURTLo06xmAA3XfyJb70LfbATSsm+muoyx04KFVNuDKMbmSHehBxHI66FOJBBM\nS9S7+Yc+AnWnXFsQ22NpZ5PHwXQaPn21qJw2mLVRCYvV8njTfLY=\n=24sx\n-----END PGP SIGNATURE-----", "payload": "tree 752bbf3236269b21bff14e63be3efefe643f6e88\nparent 1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5\nauthor Aaron Hill <aa1ronham@gmail.com> 1573780774 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1574103696 -0500\n\nFix 'type annotations needed' error with opaque types\n\nRelated: #66426\n\nThis commit adds handling for opaque types during inference variable\nfallback. Type variables generated from the instantiatino of opaque\ntypes now fallback to the opque type itself.\n\nNormally, the type variable for an instantiated opaque type is either\nunified with the concrete type, or with the opaque type itself (e.g when\na function returns an opaque type by calling another function).\n\nHowever, it's possible for the type variable to be left completely\nunconstrained. This can occur in code like this:\n\n```rust\npub type Foo = impl Copy;\nfn produce() -> Option<Foo> {\n    None\n}\n```\n\nHere, we'll instantatiate the `Foo` in `Option<Foo>` to a fresh type\nvariable, but we will never unify it with anything due to the fact\nthat we return a `None`.\n\nThis results in the error message:\n\n`type annotations needed: cannot resolve `_: std::marker::Copy``\n\npointing at `pub type Foo = impl Copy`.\n\nThis message is not only confusing, it's incorrect. When an opaque type\ninference variable is completely unconstrained, we can always fall back\nto using the opaque type itself. This effectively turns that particular\nuse of the opaque type into a non-defining use, even if it appears in a\ndefining scope.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "html_url": "https://github.com/rust-lang/rust/commit/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5", "html_url": "https://github.com/rust-lang/rust/commit/1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5"}], "stats": {"total": 153, "additions": 144, "deletions": 9}, "files": [{"sha": "500122ce8c49e0fcc3ce52b7f6af293d1a095272", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -24,6 +24,10 @@ pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n /// appear in the return type).\n #[derive(Copy, Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n+\n+    /// The opaque type (`ty::Opaque`) for this declaration\n+    pub opaque_type: Ty<'tcx>,\n+\n     /// The substitutions that we apply to the opaque type that this\n     /// `impl Trait` desugars to. e.g., if:\n     ///\n@@ -1150,6 +1154,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         self.opaque_types.insert(\n             def_id,\n             OpaqueTypeDecl {\n+                opaque_type: ty,\n                 substs,\n                 definition_span,\n                 concrete_ty: ty_var,"}, {"sha": "6c2f6e4fb3eead79f8e8ae38fcc7394e2bc86757", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 97, "deletions": 4, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -147,7 +147,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashSet, HirIdMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -231,6 +231,13 @@ pub struct Inherited<'a, 'tcx> {\n     // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n     opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n \n+    /// A map from inference variables created from opaque\n+    /// type instantiations (ty::Infer) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n@@ -696,6 +703,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             opaque_types: RefCell::new(Default::default()),\n+            opaque_types_vars: RefCell::new(Default::default()),\n             implicit_region_bound,\n             body_id,\n         }\n@@ -937,9 +945,46 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n         // All type checking constraints were added, try to fallback unsolved variables.\n         fcx.select_obligations_where_possible(false, |_| {});\n         let mut fallback_has_occurred = false;\n+\n+        // We do fallback in two passes, to try to generate\n+        // better error messages.\n+        // The first time, we do *not* replace opaque types.\n+        for ty in &fcx.unsolved_variables() {\n+            fallback_has_occurred |= fcx.fallback_if_possible(ty, false /* opaque_fallback */);\n+        }\n+        // We now see if we can make progress. This might\n+        // cause us to unify inference variables for opaque types,\n+        // since we may have unified some other type variables\n+        // during the first phase of fallback.\n+        // This means that we only replace inference variables with their underlying\n+        // opaque types as a last resort.\n+        //\n+        // In code like this:\n+        //\n+        // ```rust\n+        // type MyType = impl Copy;\n+        // fn produce() -> MyType { true }\n+        // fn bad_produce() -> MyType { panic!() }\n+        // ```\n+        //\n+        // we want to unify the opaque inference variable in `bad_produce`\n+        // with the diverging fallback for `panic!` (e.g. `()` or `!`),\n+        // This will produce a nice error message about conflicting concrete\n+        // types for `MyType`.\n+        //\n+        // If we had tried to fallback the opaque inference variable to `MyType`,\n+        // we will generate a confusing type-check error that does not explicitly\n+        // refer to opaque types.\n+        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        // We now run fallback again, but this time we allow it to replace\n+        // unconstrained opaque type variables, in addition to performing\n+        // other kinds of fallback.\n         for ty in &fcx.unsolved_variables() {\n-            fallback_has_occurred |= fcx.fallback_if_possible(ty);\n+            fallback_has_occurred |= fcx.fallback_if_possible(ty, true /* opaque_fallback */);\n         }\n+\n+        // See if we can make any more progress\n         fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n@@ -2864,8 +2909,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let mut opaque_types = self.opaque_types.borrow_mut();\n+        let mut opaque_types_vars = self.opaque_types_vars.borrow_mut();\n         for (ty, decl) in opaque_type_map {\n             let _ = opaque_types.insert(ty, decl);\n+            let _ = opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n         }\n \n         value\n@@ -3078,7 +3125,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n     // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>, opaque_fallback: bool) -> bool {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n@@ -3088,7 +3135,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n             Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n-            Neither => return false,\n+            Neither => {\n+                // This type variable was created from the instantiation of an opaque\n+                // type. The fact that we're attempting to perform fallback for it\n+                // means that the function neither constrained it to a concrete\n+                // type, nor to the opaque type itself.\n+                //\n+                // For example, in this code:\n+                //\n+                //```\n+                // type MyType = impl Copy;\n+                // fn defining_use() -> MyType { true }\n+                // fn other_use() -> MyType { defining_use() }\n+                // ```\n+                //\n+                // `defining_use` will constrain the instantiated inference\n+                // variable to `bool`, while `other_use` will constrain\n+                // the instantiated inference variable to `MyType`.\n+                //\n+                // When we process opaque types during writeback, we\n+                // will handle cases like `other_use`, and not count\n+                // them as defining usages\n+                //\n+                // However, we also need to handle cases like this:\n+                //\n+                // ```rust\n+                // pub type Foo = impl Copy;\n+                // fn produce() -> Option<Foo> {\n+                //     None\n+                //  }\n+                //  ```\n+                //\n+                // In the above snippet, the inference varaible created by\n+                // instantiating `Option<Foo>` will be completely unconstrained.\n+                // We treat this as a non-defining use by making the inference\n+                // variable fall back to the opaque type itself.\n+                if opaque_fallback {\n+                    if let Some(opaque_ty) = self.opaque_types_vars.borrow().get(ty) {\n+                        debug!(\"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n+                               ty, opaque_ty);\n+                        *opaque_ty\n+                    } else {\n+                        return false;\n+                    }\n+                } else {\n+                    return false;\n+                }\n+            },\n         };\n         debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n         self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);"}, {"sha": "f7744ef1b3eaeb0da606b0e3625755b39090bca1", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -0,0 +1,9 @@\n+//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n+//! too early to display them.\n+use std::fmt::Debug;\n+\n+// Disallowed\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+//~^ ERROR opaque type expands to a recursive type\n+\n+fn main() {}"}, {"sha": "1de15014c1f8dd3cd46ce46f92d597eaffd3fc71", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -0,0 +1,11 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/where-allowed-2.rs:6:30\n+   |\n+LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+   |                              ^^^^^^^^^^ expands to a recursive type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "211a14ed4dd9998a24445a990b51bb94ba11a5b5", "filename": "src/test/ui/impl-trait/where-allowed.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -11,10 +11,6 @@ fn in_return() -> impl Debug { panic!() }\n // Allowed\n fn in_adt_in_parameters(_: Vec<impl Debug>) { panic!() }\n \n-// Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-//~^ ERROR type annotations needed\n-\n // Disallowed\n fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n@@ -60,7 +56,6 @@ fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n //~| ERROR nested `impl Trait` is not allowed\n-//~| ERROR type annotations needed\n \n // Disallowed\n fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }"}, {"sha": "c59c1e3b7d01e83510b13e0d11aca7d1ae98b2b2", "filename": "src/test/ui/type-alias-impl-trait/fallback.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs?ref=0e2ccaaa3e70d85d1243c07e6ac0ef3829115a8d", "patch": "@@ -0,0 +1,22 @@\n+// Tests that we correctly handle the instantiated\n+// inference variable being completely unconstrained.\n+//\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl Copy;\n+\n+enum Wrapper<T> {\n+    First(T),\n+    Second\n+}\n+\n+fn _make_iter() -> Foo {\n+    true\n+}\n+\n+fn _produce() -> Wrapper<Foo> {\n+    Wrapper::Second\n+}\n+\n+fn main() {}"}]}