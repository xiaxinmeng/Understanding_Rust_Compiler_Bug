{"sha": "4e415a269e2d821f31963c05843517c6fde0132d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNDE1YTI2OWUyZDgyMWYzMTk2M2MwNTg0MzUxN2M2ZmRlMDEzMmQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T18:04:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T18:04:24Z"}, "message": "Remove ns-polymorphic type_for_def", "tree": {"sha": "9acc9b8f635405f8c194cfd807927c45ee3fbb02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9acc9b8f635405f8c194cfd807927c45ee3fbb02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e415a269e2d821f31963c05843517c6fde0132d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e415a269e2d821f31963c05843517c6fde0132d", "html_url": "https://github.com/rust-lang/rust/commit/4e415a269e2d821f31963c05843517c6fde0132d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e415a269e2d821f31963c05843517c6fde0132d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "475367d08a0b5e8ed4d6c7c7d43947fd11b26bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/475367d08a0b5e8ed4d6c7c7d43947fd11b26bb7", "html_url": "https://github.com/rust-lang/rust/commit/475367d08a0b5e8ed4d6c7c7d43947fd11b26bb7"}], "stats": {"total": 294, "additions": 129, "deletions": 165}, "files": [{"sha": "c5cf39ee1a3896e8d7a7e6396bd33c7fc3974217", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -28,8 +28,7 @@ use crate::{\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n-        self, InEnvironment, InferenceResult, Namespace, TraitEnvironment, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n+        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n     CallableDef, Either, HirDisplay, Name, Source,\n };\n@@ -354,11 +353,11 @@ impl Struct {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n@@ -381,7 +380,7 @@ impl Union {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n@@ -442,7 +441,7 @@ impl Enum {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n }\n \n@@ -617,7 +616,7 @@ impl Function {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n@@ -797,7 +796,7 @@ impl TypeAlias {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+        db.ty(self.id.into())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {"}, {"sha": "3b5aa75161cc775a2087771a598f1d60b22c5669", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -9,8 +9,8 @@ use crate::{\n     ty::{\n         method_resolution::CrateImplBlocks,\n         traits::{AssocTyValue, Impl},\n-        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n-        TypeCtor,\n+        CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+        ValueTyDefId,\n     },\n     Crate, DefWithBody, ImplBlock, Trait,\n };\n@@ -37,8 +37,11 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::infer_query)]\n     fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n \n-    #[salsa::invoke(crate::ty::type_for_def)]\n-    fn type_for_def(&self, def: TypableDef, ns: Namespace) -> Ty;\n+    #[salsa::invoke(crate::ty::ty_query)]\n+    fn ty(&self, def: TyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::ty::value_ty_query)]\n+    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n \n     #[salsa::invoke(crate::ty::field_types_query)]\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;"}, {"sha": "680ddc2f9c5986ad259b5e2aded7b88b2eb7dfab", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -37,8 +37,8 @@ pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n     callable_item_sig, field_types_query, generic_defaults_query,\n-    generic_predicates_for_param_query, generic_predicates_query, type_for_def, Namespace,\n-    TypableDef,\n+    generic_predicates_for_param_query, generic_predicates_query, ty_query, value_ty_query,\n+    TyDefId, TypableDef, ValueTyDefId,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "beb2efb7aa316b8d3c352f2f0627bc4179f6a3c6", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 15, "deletions": 38, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -35,15 +35,15 @@ use test_utils::tested_by;\n \n use super::{\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypableDef,\n-    TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n use crate::{\n     code_model::TypeAlias,\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n+    AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -520,45 +520,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let def: TypableDef =\n-            // FIXME: this should resolve assoc items as well, see this example:\n-            // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-            match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n-                Some(TypeNs::AdtId(AdtId::StructId(it))) => it.into(),\n-                Some(TypeNs::AdtId(AdtId::UnionId(it))) => it.into(),\n-                Some(TypeNs::AdtSelfType(adt)) => adt.into(),\n-                Some(TypeNs::EnumVariantId(it)) => it.into(),\n-                Some(TypeNs::TypeAliasId(it)) => it.into(),\n-\n-                Some(TypeNs::SelfType(_)) |\n-                Some(TypeNs::GenericParam(_)) |\n-                Some(TypeNs::BuiltinType(_)) |\n-                Some(TypeNs::TraitId(_)) |\n-                Some(TypeNs::AdtId(AdtId::EnumId(_))) |\n-                None => {\n-                    return (Ty::Unknown, None)\n-                }\n-            };\n-        // FIXME remove the duplication between here and `Ty::from_path`?\n-        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n-        match def {\n-            TypableDef::Adt(Adt::Struct(s)) => {\n-                let ty = s.ty(self.db);\n+        // FIXME: this should resolve assoc items as well, see this example:\n+        // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n+        match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+            Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(s.into()))\n+                (ty, Some(VariantDef::Struct(strukt.into())))\n             }\n-            TypableDef::EnumVariant(var) => {\n-                let ty = var.parent_enum(self.db).ty(self.db);\n+            Some(TypeNs::EnumVariantId(var)) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(var.into()))\n+                (ty, Some(VariantDef::EnumVariant(var.into())))\n             }\n-            TypableDef::Adt(Adt::Enum(_))\n-            | TypableDef::Adt(Adt::Union(_))\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::Function(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::BuiltinType(_) => (Ty::Unknown, None),\n+            Some(_) | None => (Ty::Unknown, None),\n         }\n     }\n "}, {"sha": "eb221d6bc8961bd0c466c98f76f971850fbed3eb", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -17,8 +17,8 @@ use crate::{\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     ty::{\n         autoderef, method_resolution, op, traits::InEnvironment, CallableDef, InferTy, IntTy,\n-        Mutability, Namespace, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n-        TypeCtor, TypeWalk, Uncertain,\n+        Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+        TypeWalk, Uncertain,\n     },\n     Name,\n };\n@@ -558,11 +558,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (\n-                    ty,\n-                    self.db.type_for_def(func.into(), Namespace::Values),\n-                    Some(self.db.generic_params(func.id.into())),\n-                )\n+                (ty, self.db.value_ty(func.id.into()), Some(self.db.generic_params(func.id.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };"}, {"sha": "be2067dd4d373b4964c511b1113091fb76776155", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n \n use crate::{\n     db::HirDatabase,\n-    ty::{method_resolution, Namespace, Substs, Ty, TypableDef, TypeWalk},\n+    ty::{method_resolution, Substs, Ty, TypeWalk, ValueTyDefId},\n     AssocItem, Container, Function, Name, Path,\n };\n \n@@ -56,7 +56,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n         };\n \n-        let typable: TypableDef = match value {\n+        let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n@@ -69,11 +69,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n-        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+        let mut ty = self.db.value_ty(typable);\n         if let Some(self_subst) = self_subst {\n             ty = ty.subst(&self_subst);\n         }\n-\n         let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n         let ty = ty.subst(&substs);\n         Some(ty)"}, {"sha": "709492d21761f959612edd78b739128eb2d7aa70", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 89, "deletions": 100, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -14,8 +14,8 @@ use hir_def::{\n     path::{GenericArg, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, EnumVariantId, FunctionId, GenericDefId, HasModule, LocalStructFieldId,\n-    Lookup, StructId, TraitId, VariantId,\n+    AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n+    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -35,17 +35,6 @@ use crate::{\n     TypeAlias, Union,\n };\n \n-// FIXME: this is only really used in `type_for_def`, which contains a bunch of\n-// impossible cases. Perhaps we should recombine `TypeableDef` and `Namespace`\n-// into a `AsTypeDef`, `AsValueDef` enums?\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n-    // Note that only type inference uses this enum, and it doesn't care about macros.\n-    // Macro,\n-}\n-\n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n@@ -281,27 +270,15 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         segment: &PathSegment,\n-        typable: TypableDef,\n+        typable: TyDefId,\n     ) -> Ty {\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path_segment(db, resolver, segment, typable);\n-        ty.subst(&substs)\n-    }\n-\n-    pub(super) fn substs_from_path_segment(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        segment: &PathSegment,\n-        resolved: TypableDef,\n-    ) -> Substs {\n-        let def_generic: Option<GenericDefId> = match resolved {\n-            TypableDef::Function(func) => Some(func.id.into()),\n-            TypableDef::Adt(adt) => Some(adt.into()),\n-            TypableDef::EnumVariant(var) => Some(var.parent_enum(db).id.into()),\n-            TypableDef::TypeAlias(t) => Some(t.id.into()),\n-            TypableDef::Const(_) | TypableDef::Static(_) | TypableDef::BuiltinType(_) => None,\n+        let generic_def = match typable {\n+            TyDefId::BuiltinType(_) => None,\n+            TyDefId::AdtId(it) => Some(it.into()),\n+            TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        substs_from_path_segment(db, resolver, segment, def_generic, false)\n+        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n+        db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -310,17 +287,18 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         path: &Path,\n-        resolved: TypableDef,\n+        // Note that we don't call `db.value_type(resolved)` here,\n+        // `ValueTyDefId` is just a convenient way to pass generics and\n+        // special-case enum variants\n+        resolved: ValueTyDefId,\n     ) -> Substs {\n         let last = path.segments.last().expect(\"path should have at least one segment\");\n-        let segment = match resolved {\n-            TypableDef::Function(_)\n-            | TypableDef::Adt(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::BuiltinType(_) => last,\n-            TypableDef::EnumVariant(_) => {\n+        let (segment, generic_def) = match resolved {\n+            ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StructId(it) => (last, Some(it.into())),\n+            ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StaticId(_) => (last, None),\n+            ValueTyDefId::EnumVariantId(var) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n@@ -334,10 +312,10 @@ impl Ty {\n                     // Option::None::<T>\n                     last\n                 };\n-                segment\n+                (segment, Some(var.parent.into()))\n             }\n         };\n-        Ty::substs_from_path_segment(db, resolver, segment, resolved)\n+        substs_from_path_segment(db, resolver, segment, generic_def, false)\n     }\n }\n \n@@ -522,33 +500,6 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         })\n }\n \n-/// Build the declared type of an item. This depends on the namespace; e.g. for\n-/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n-/// the constructor function `(usize) -> Foo` which lives in the values\n-/// namespace.\n-pub(crate) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace) -> Ty {\n-    match (def, ns) {\n-        (TypableDef::Function(f), Namespace::Values) => type_for_fn(db, f),\n-        (TypableDef::Adt(Adt::Struct(s)), Namespace::Values) => type_for_struct_constructor(db, s),\n-        (TypableDef::Adt(adt), Namespace::Types) => type_for_adt(db, adt),\n-        (TypableDef::EnumVariant(v), Namespace::Values) => type_for_enum_variant_constructor(db, v),\n-        (TypableDef::TypeAlias(t), Namespace::Types) => type_for_type_alias(db, t),\n-        (TypableDef::Const(c), Namespace::Values) => type_for_const(db, c),\n-        (TypableDef::Static(c), Namespace::Values) => type_for_static(db, c),\n-        (TypableDef::BuiltinType(t), Namespace::Types) => type_for_builtin(t),\n-\n-        // 'error' cases:\n-        (TypableDef::Function(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Union(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Enum(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::EnumVariant(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::TypeAlias(_), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Const(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Static(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::BuiltinType(_), Namespace::Values) => Ty::Unknown,\n-    }\n-}\n-\n /// Build the signature of a callable item (function, struct or enum variant).\n pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n     match def {\n@@ -647,24 +598,24 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n-    let generics = db.generic_params(def.id.into());\n+fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.id.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: Const) -> Ty {\n-    let data = db.const_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n+    let data = db.const_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: Static) -> Ty {\n-    let data = db.static_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n+    let data = db.static_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n@@ -688,19 +639,19 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let ret = type_for_adt(db, Struct::from(def));\n+    let ret = type_for_adt(db, def.into());\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n-    let struct_data = db.struct_data(def.id.into());\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n+    let struct_data = db.struct_data(def.into());\n     if struct_data.variant_data.is_unit() {\n-        return type_for_adt(db, def); // Unit struct\n+        return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.id.into());\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.id.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> FnSig {\n@@ -714,34 +665,33 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n         .collect::<Vec<_>>();\n     let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n-    let ret = type_for_adt(db, Enum::from(def.parent)).subst(&substs);\n+    let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n-    let var_data = def.variant_data(db);\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Ty {\n+    let enum_data = db.enum_data(def.parent);\n+    let var_data = &enum_data.variants[def.local_id].variant_data;\n     if var_data.is_unit() {\n-        return type_for_adt(db, def.parent_enum(db)); // Unit variant\n+        return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent_enum(db).id.into());\n+    let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: impl Into<Adt>) -> Ty {\n-    let adt = adt.into();\n-    let adt_id: AdtId = adt.into();\n-    let generics = db.generic_params(adt_id.into());\n-    Ty::apply(TypeCtor::Adt(adt_id), Substs::identity(&generics))\n+fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n+    let generics = db.generic_params(adt.into());\n+    Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n-    let generics = db.generic_params(t.id.into());\n-    let resolver = t.id.resolver(db);\n-    let type_ref = t.type_ref(db);\n+fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n+    let generics = db.generic_params(t.into());\n+    let resolver = t.resolver(db);\n+    let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, &type_ref.unwrap_or(TypeRef::Error));\n+    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n     inner.subst(&substs)\n }\n \n@@ -808,3 +758,42 @@ impl From<CallableDef> for GenericDefId {\n         }\n     }\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TyDefId {\n+    BuiltinType(BuiltinType),\n+    AdtId(AdtId),\n+    TypeAliasId(TypeAliasId),\n+}\n+impl_froms!(TyDefId: BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ValueTyDefId {\n+    FunctionId(FunctionId),\n+    StructId(StructId),\n+    EnumVariantId(EnumVariantId),\n+    ConstId(ConstId),\n+    StaticId(StaticId),\n+}\n+impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId);\n+\n+/// Build the declared type of an item. This depends on the namespace; e.g. for\n+/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n+/// the constructor function `(usize) -> Foo` which lives in the values\n+/// namespace.\n+pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n+    match def {\n+        TyDefId::BuiltinType(it) => type_for_builtin(it),\n+        TyDefId::AdtId(it) => type_for_adt(db, it),\n+        TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n+    }\n+}\n+pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n+    match def {\n+        ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n+        ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n+        ValueTyDefId::EnumVariantId(it) => type_for_enum_variant_constructor(db, it),\n+        ValueTyDefId::ConstId(it) => type_for_const(db, it),\n+        ValueTyDefId::StaticId(it) => type_for_static(db, it),\n+    }\n+}"}, {"sha": "4b0f4f56c2d26cc8a4b54f5ccf87ed6def330243", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -786,7 +786,7 @@ fn type_alias_associated_ty_value(\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let generic_params = db.generic_params(impl_block.id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let ty = db.ty(type_alias.id.into()).subst(&bound_vars);\n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n         impl_id,"}, {"sha": "4a76d1dd83ce996d5e00b50752f4e554d6e44ccb", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e415a269e2d821f31963c05843517c6fde0132d/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=4e415a269e2d821f31963c05843517c6fde0132d", "patch": "@@ -323,7 +323,8 @@ impl RootDatabase {\n             hir::db::DocumentationQuery\n             hir::db::ExprScopesQuery\n             hir::db::InferQuery\n-            hir::db::TypeForDefQuery\n+            hir::db::TyQuery\n+            hir::db::ValueTyQuery\n             hir::db::FieldTypesQuery\n             hir::db::CallableItemSignatureQuery\n             hir::db::GenericPredicatesQuery"}]}