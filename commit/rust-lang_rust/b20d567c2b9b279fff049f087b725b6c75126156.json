{"sha": "b20d567c2b9b279fff049f087b725b6c75126156", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMGQ1NjdjMmI5YjI3OWZmZjA0OWYwODdiNzI1YjZjNzUxMjYxNTY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-25T04:40:46Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-26T00:37:27Z"}, "message": "Privacy check paths in resolve and typeck", "tree": {"sha": "b981e1246ec02cd7fd5b1cab03750bb155cdd7ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b981e1246ec02cd7fd5b1cab03750bb155cdd7ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20d567c2b9b279fff049f087b725b6c75126156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20d567c2b9b279fff049f087b725b6c75126156", "html_url": "https://github.com/rust-lang/rust/commit/b20d567c2b9b279fff049f087b725b6c75126156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20d567c2b9b279fff049f087b725b6c75126156/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07957ffb2eace00019c2bb07fe5fc03191a476c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/07957ffb2eace00019c2bb07fe5fc03191a476c7", "html_url": "https://github.com/rust-lang/rust/commit/07957ffb2eace00019c2bb07fe5fc03191a476c7"}], "stats": {"total": 111, "additions": 98, "deletions": 13}, "files": [{"sha": "042b77e42c4e99d77d0034f85e36dd0b41f34ada", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b20d567c2b9b279fff049f087b725b6c75126156", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n                final_ident,\n                vis);\n-        let is_public = vis == hir::Public;\n+        let is_public = vis == hir::Public || new_parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {"}, {"sha": "a758008e807b7c2da7aeacbe397c995b8d952ecb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b20d567c2b9b279fff049f087b725b6c75126156", "patch": "@@ -934,6 +934,15 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n+    fn is_ancestor_of(&self, module: Module<'a>) -> bool {\n+        if self.def_id() == module.def_id() { return true }\n+        match module.parent_link {\n+            ParentLink::BlockParentLink(parent, _) |\n+            ParentLink::ModuleParentLink(parent, _) => self.is_ancestor_of(parent),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn inc_glob_count(&self) {\n         self.glob_count.set(self.glob_count.get() + 1);\n     }\n@@ -1000,9 +1009,14 @@ enum NameBindingKind<'a> {\n     Import {\n         binding: &'a NameBinding<'a>,\n         id: NodeId,\n+        // Some(error) if using this imported name causes the import to be a privacy error\n+        privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n }\n \n+#[derive(Clone, Debug)]\n+struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n+\n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n@@ -1145,6 +1159,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // The intention is that the callback modifies this flag.\n     // Once set, the resolver falls out of the walk, preserving the ribs.\n     resolved: bool,\n+    privacy_errors: Vec<PrivacyError<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n }\n@@ -1209,6 +1224,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             callback: None,\n             resolved: false,\n+            privacy_errors: Vec::new(),\n \n             arenas: arenas,\n         }\n@@ -1255,12 +1271,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             self.used_crates.insert(krate);\n         }\n \n-        let import_id = match binding.kind {\n-            NameBindingKind::Import { id, .. } => id,\n+        let (import_id, privacy_error) = match binding.kind {\n+            NameBindingKind::Import { id, ref privacy_error, .. } => (id, privacy_error),\n             _ => return,\n         };\n \n         self.used_imports.insert((import_id, ns));\n+        if let Some(error) = privacy_error.as_ref() {\n+            self.privacy_errors.push((**error).clone());\n+        }\n \n         if !self.make_glob_map {\n             return;\n@@ -1352,6 +1371,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n+                        self.check_privacy(search_module, name, binding, span);\n                         search_module = module_def;\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n@@ -2911,7 +2931,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        result.success().map(|binding| binding.def().unwrap())\n+        result.success().map(|binding| {\n+            self.check_privacy(containing_module, name, binding, span);\n+            binding.def().unwrap()\n+        })\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2958,7 +2981,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        result.success().map(|binding| binding.def().unwrap())\n+        result.success().map(|binding| {\n+            self.check_privacy(containing_module, name, binding, span);\n+            binding.def().unwrap()\n+        })\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n@@ -3570,6 +3596,37 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn is_visible(&self, binding: &'a NameBinding<'a>, parent: Module<'a>) -> bool {\n+        binding.is_public() || parent.is_ancestor_of(self.current_module)\n+    }\n+\n+    fn check_privacy(&mut self,\n+                     module: Module<'a>,\n+                     name: Name,\n+                     binding: &'a NameBinding<'a>,\n+                     span: Span) {\n+        if !self.is_visible(binding, module) {\n+            self.privacy_errors.push(PrivacyError(span, name, binding));\n+        }\n+    }\n+\n+    fn report_privacy_errors(&self) {\n+        if self.privacy_errors.len() == 0 { return }\n+        let mut reported_spans = HashSet::new();\n+        for &PrivacyError(span, name, binding) in &self.privacy_errors {\n+            if !reported_spans.insert(span) { continue }\n+            if binding.is_extern_crate() {\n+                // Warn when using an inaccessible extern crate.\n+                let node_id = binding.module().unwrap().extern_crate_id.unwrap();\n+                let msg = format!(\"extern crate `{}` is private\", name);\n+                self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n+            } else {\n+                let def = binding.def().unwrap();\n+                self.session.span_err(span, &format!(\"{} `{}` is private\", def.kind_name(), name));\n+            }\n+        }\n+    }\n }\n \n \n@@ -3726,6 +3783,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     resolver.resolve_crate(krate);\n \n     check_unused::check_crate(&mut resolver, krate);\n+    resolver.report_privacy_errors();\n \n     CrateMap {\n         def_map: resolver.def_map,"}, {"sha": "f6d23c8caa2c7f757d4fb376b8b67fd0883b985c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b20d567c2b9b279fff049f087b725b6c75126156", "patch": "@@ -13,7 +13,7 @@ use self::ImportDirectiveSubclass::*;\n use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind};\n+use {NameBinding, NameBindingKind, PrivacyError};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n@@ -78,7 +78,9 @@ impl ImportDirective {\n \n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import<'a>(&self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n+    fn import<'a>(&self,\n+                  binding: &'a NameBinding<'a>,\n+                  privacy_error: Option<Box<PrivacyError<'a>>>) -> NameBinding<'a> {\n         let mut modifiers = match self.is_public {\n             true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n             false => DefModifiers::empty(),\n@@ -91,7 +93,11 @@ impl ImportDirective {\n         }\n \n         NameBinding {\n-            kind: NameBindingKind::Import { binding: binding, id: self.id },\n+            kind: NameBindingKind::Import {\n+                binding: binding,\n+                id: self.id,\n+                privacy_error: privacy_error,\n+            },\n             span: Some(self.span),\n             modifiers: modifiers,\n         }\n@@ -219,7 +225,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 span: None,\n             });\n             let dummy_binding =\n-                self.resolver.new_name_binding(e.import_directive.import(dummy_binding));\n+                self.resolver.new_name_binding(e.import_directive.import(dummy_binding, None));\n \n             let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n             let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n@@ -419,17 +425,31 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n+        let mut privacy_error = None;\n+        let mut report_privacy_error = true;\n         for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n             if let Success(binding) = *result {\n                 if !binding.defined_with(DefModifiers::IMPORTABLE) {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                self.define(module_, target, ns, directive.import(binding));\n+                privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n+                } else {\n+                    report_privacy_error = false;\n+                    None\n+                };\n+\n+                self.define(module_, target, ns, directive.import(binding, privacy_error.clone()));\n             }\n         }\n \n+        if report_privacy_error { // then all successful namespaces are privacy errors\n+            // We report here so there is an error even if the imported name is not used\n+            self.resolver.privacy_errors.push(*privacy_error.unwrap());\n+        }\n+\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n@@ -472,7 +492,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n         target_module.for_each_child(|name, ns, binding| {\n             if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n-            self.define(module_, name, ns, directive.import(binding));\n+            self.define(module_, name, ns, directive.import(binding, None));\n \n             if ns == TypeNS && directive.is_public &&\n                binding.defined_with(DefModifiers::PRIVATE_VARIANT) {"}, {"sha": "31e23344734886c940e650cb22f8774d5a4e5bcf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20d567c2b9b279fff049f087b725b6c75126156/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b20d567c2b9b279fff049f087b725b6c75126156", "patch": "@@ -337,9 +337,16 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    Ok(pick.item.def())\n-}\n+    let def = pick.item.def();\n \n+    if let probe::InherentImplPick = pick.kind {\n+        if pick.item.vis() != hir::Public && !fcx.private_item_is_visible(def.def_id()) {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+            fcx.tcx().sess.span_err(span, &msg);\n+        }\n+    }\n+    Ok(def)\n+}\n \n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item."}]}