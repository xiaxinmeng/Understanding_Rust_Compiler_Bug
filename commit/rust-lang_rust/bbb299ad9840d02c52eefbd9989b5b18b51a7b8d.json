{"sha": "bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjI5OWFkOTg0MGQwMmM1MmVlZmJkOTk4OWI1YjE4YjUxYTdiOGQ=", "commit": {"author": {"name": "root", "email": "root@localhost", "date": "2014-07-17T22:59:49Z"}, "committer": {"name": "root", "email": "root@localhost", "date": "2014-07-18T22:28:45Z"}, "message": "Clarify str Chars iterator implementation\n\nThanks to comments from @huonw, clarify decoding details and use\nstatics for important constants for UTF-8 decoding. Convert some magic\nnumbers scattered in the same file to use the statics too.", "tree": {"sha": "926bfd91a710e3c258b2f9269f77c37784bfda60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/926bfd91a710e3c258b2f9269f77c37784bfda60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "html_url": "https://github.com/rust-lang/rust/commit/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e59c7626381eff9ee9110091b68a079b8a5b7d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e59c7626381eff9ee9110091b68a079b8a5b7d8", "html_url": "https://github.com/rust-lang/rust/commit/9e59c7626381eff9ee9110091b68a079b8a5b7d8"}], "stats": {"total": 29, "additions": 16, "deletions": 13}, "files": [{"sha": "f8ff4cfb1d9a34d831ed562710f760c711001fc1", "filename": "src/libcore/str.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "patch": "@@ -114,11 +114,11 @@ macro_rules! utf8_first_byte(\n \n // return the value of $ch updated with continuation byte $byte\n macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & CONT_MASK) as u32)\n )\n \n macro_rules! utf8_is_cont_byte(\n-    ($byte:expr) => (($byte & 192u8) == 128)\n+    ($byte:expr) => (($byte & !CONT_MASK) == TAG_CONT_U8)\n )\n \n #[inline]\n@@ -137,20 +137,20 @@ impl<'a> Iterator<char> for Chars<'a> {\n         fn decode_multibyte<'a>(x: u8, it: &mut slice::Items<'a, u8>) -> char {\n             // NOTE: Performance is very sensitive to the exact formulation here\n             // Decode from a byte combination out of: [[[x y] z] w]\n-            let cont_mask = 0x3F; // continuation byte mask\n             let init = utf8_first_byte!(x, 2);\n             let y = unwrap_or_0(it.next());\n             let mut ch = utf8_acc_cont_byte!(init, y);\n             if x >= 0xE0 {\n-                /* [[x y z] w] case */\n+                /* [[x y z] w] case\n+                 * 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid */\n                 let z = unwrap_or_0(it.next());\n-\n-                let y_z = (((y & cont_mask) as u32) << 6) | (z & cont_mask) as u32;\n+                let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n                 ch = init << 12 | y_z;\n                 if x >= 0xF0 {\n-                    /* [x y z w] case */\n+                    /* [x y z w] case\n+                     * use only the lower 3 bits of `init` */\n                     let w = unwrap_or_0(it.next());\n-                    ch = (init & 7) << 18 | y_z << 6 | (w & cont_mask) as u32;\n+                    ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n                 }\n             }\n             unsafe {\n@@ -754,9 +754,9 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n             match w {\n-                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                2 => if second & !CONT_MASK != TAG_CONT_U8 {err!()},\n                 3 => {\n-                    match (first, second, next!() & 192) {\n+                    match (first, second, next!() & !CONT_MASK) {\n                         (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n                         (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n                         (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n@@ -765,7 +765,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n                     }\n                 }\n                 4 => {\n-                    match (first, second, next!() & 192, next!() & 192) {\n+                    match (first, second, next!() & !CONT_MASK, next!() & !CONT_MASK) {\n                         (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n                         (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n                         (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n@@ -962,7 +962,10 @@ pub struct CharRange {\n     pub next: uint,\n }\n \n-static TAG_CONT_U8: u8 = 128u8;\n+/// Mask of the value bits of a continuation byte\n+static CONT_MASK: u8 = 0b0011_1111u8;\n+/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte\n+static TAG_CONT_U8: u8 = 0b1000_0000u8;\n \n /// Unsafe operations\n pub mod raw {\n@@ -1898,7 +1901,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n         fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n-            while i > 0 && s.as_bytes()[i] & 192u8 == TAG_CONT_U8 {\n+            while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1u;\n             }\n "}]}