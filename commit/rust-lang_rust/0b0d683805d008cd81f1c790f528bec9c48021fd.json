{"sha": "0b0d683805d008cd81f1c790f528bec9c48021fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMGQ2ODM4MDVkMDA4Y2Q4MWYxYzc5MGY1MjhiZWM5YzQ4MDIxZmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-19T12:10:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-19T12:10:14Z"}, "message": "Rollup merge of #66239 - estebank:suggest-async-closure-call, r=Centril\n\nSuggest calling async closure when needed\n\nWhen using an async closure as a value in a place that expects a future,\nsuggest calling the closure.\n\nFix #65923.", "tree": {"sha": "06e5c9f4116371c3a996a0016bddddbfbb7947d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06e5c9f4116371c3a996a0016bddddbfbb7947d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0d683805d008cd81f1c790f528bec9c48021fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd09umCRBK7hj4Ov3rIwAAdHIIAH6FF41IPMFT527UKzE50NAE\ng/5NJQN0Y+R0wsYub7WXfeBS6+UjLK6Gzep0BWDoKHoipHpECiXeZUJ230qojYD0\njhRTw/Bwm7eCkjxidG9dNnTzFv8ztW++REvdlCEoFPoiOilWwlDa2rwFkIpT1K2W\njlQbPr25ZLGcPDNuqUTV8JWT6+7AN3kDwBbBr/RuSFTgDaMGgBbxE9HnFc+uRxet\ng5Z1yF/hrmQjugQDdus7LUkVQoNmgVgDlNDtl326b2MFwSLmZtyhUCRwi1gvzff0\nzmjnfuizIFemWKtCTg8UfrJSlVt7ufOp8UQA/57SvAahLLarGlQbbptilxgVMqw=\n=1BgD\n-----END PGP SIGNATURE-----\n", "payload": "tree 06e5c9f4116371c3a996a0016bddddbfbb7947d9\nparent 40deec82bcb9f13829f60a30d1bc3afedb9d5c8c\nparent 614da98454984921142eb2059db7be953d2c855c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574165414 +0100\ncommitter GitHub <noreply@github.com> 1574165414 +0100\n\nRollup merge of #66239 - estebank:suggest-async-closure-call, r=Centril\n\nSuggest calling async closure when needed\n\nWhen using an async closure as a value in a place that expects a future,\nsuggest calling the closure.\n\nFix #65923.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0d683805d008cd81f1c790f528bec9c48021fd", "html_url": "https://github.com/rust-lang/rust/commit/0b0d683805d008cd81f1c790f528bec9c48021fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0d683805d008cd81f1c790f528bec9c48021fd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40deec82bcb9f13829f60a30d1bc3afedb9d5c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40deec82bcb9f13829f60a30d1bc3afedb9d5c8c", "html_url": "https://github.com/rust-lang/rust/commit/40deec82bcb9f13829f60a30d1bc3afedb9d5c8c"}, {"sha": "614da98454984921142eb2059db7be953d2c855c", "url": "https://api.github.com/repos/rust-lang/rust/commits/614da98454984921142eb2059db7be953d2c855c", "html_url": "https://github.com/rust-lang/rust/commit/614da98454984921142eb2059db7be953d2c855c"}], "stats": {"total": 240, "additions": 175, "deletions": 65}, "files": [{"sha": "0144d51a9693f82c2d422b0aeef6f86dde4824df", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 133, "deletions": 62, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0b0d683805d008cd81f1c790f528bec9c48021fd", "patch": "@@ -1245,6 +1245,60 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref = ty::TraitRef {\n+            def_id,\n+            substs: self.tcx.mk_substs_trait(output_ty, &[]),\n+        };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+\n+    /// Given a closure's `DefId`, return the given name of the closure.\n+    ///\n+    /// This doesn't account for reassignments, but it's only used for suggestions.\n+    fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String> {\n+        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n+            // Get the local name of this closure. This can be inaccurate because\n+            // of the possibility of reassignment, but this should be good enough.\n+            match &kind {\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                    Some(format!(\"{}\", name))\n+                }\n+                _ => {\n+                    err.note(&msg);\n+                    None\n+                }\n+            }\n+        };\n+\n+        let hir = self.tcx.hir();\n+        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let parent_node = hir.get_parent_node(hir_id);\n+        match hir.find(parent_node) {\n+            Some(hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Local(local), ..\n+            })) => get_name(err, &local.pat.kind),\n+            // Different to previous arm because one is `&hir::Local` and the other\n+            // is `P<hir::Local>`.\n+            Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n+            _ => return None,\n+        }\n+    }\n+\n+    /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+    /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+    /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n     fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1253,63 +1307,82 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         points_at_arg: bool,\n     ) {\n         let self_ty = trait_ref.self_ty();\n-        match self_ty.kind {\n+        let (def_id, output_ty, callable) = match self_ty.kind {\n+            ty::Closure(def_id, substs) => {\n+                (def_id, self.closure_sig(def_id, substs).output(), \"closure\")\n+            }\n             ty::FnDef(def_id, _) => {\n-                // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n-                // to a type that *would* satisfy the trait binding. If it would, suggest calling\n-                // it: `bar(foo)` -> `bar(foo)`. This case is *very* likely to be hit if `foo` is\n-                // `async`.\n-                let output_ty = self_ty.fn_sig(self.tcx).output();\n-                let new_trait_ref = ty::TraitRef {\n-                    def_id: trait_ref.def_id(),\n-                    substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n+                (def_id, self_ty.fn_sig(self.tcx).output(), \"function\")\n+            }\n+            _ => return,\n+        };\n+        let msg = format!(\"use parentheses to call the {}\", callable);\n+\n+        let obligation = self.mk_obligation_for_def_id(\n+            trait_ref.def_id(),\n+            output_ty.skip_binder(),\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+        );\n+\n+        match self.evaluate_obligation(&obligation) {\n+            Ok(EvaluationResult::EvaluatedToOk) |\n+            Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n+            Ok(EvaluationResult::EvaluatedToAmbig) => {}\n+            _ => return,\n+        }\n+        let hir = self.tcx.hir();\n+        // Get the name of the callable and the arguments to be used in the suggestion.\n+        let snippet = match hir.get_if_local(def_id) {\n+            Some(hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                ..\n+            })) => {\n+                err.span_label(*span, \"consider calling this closure\");\n+                let name = match self.get_closure_name(def_id, err, &msg) {\n+                    Some(name) => name,\n+                    None => return,\n                 };\n-                let obligation = Obligation::new(\n-                    obligation.cause.clone(),\n-                    obligation.param_env,\n-                    new_trait_ref.to_predicate(),\n-                );\n-                match self.evaluate_obligation(&obligation) {\n-                    Ok(EvaluationResult::EvaluatedToOk) |\n-                    Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n-                    Ok(EvaluationResult::EvaluatedToAmbig) => {\n-                        if let Some(hir::Node::Item(hir::Item {\n-                            ident,\n-                            kind: hir::ItemKind::Fn(.., body_id),\n-                            ..\n-                        })) = self.tcx.hir().get_if_local(def_id) {\n-                            let body = self.tcx.hir().body(*body_id);\n-                            let msg = \"use parentheses to call the function\";\n-                            let snippet = format!(\n-                                \"{}({})\",\n-                                ident,\n-                                body.params.iter()\n-                                    .map(|arg| match &arg.pat.kind {\n-                                        hir::PatKind::Binding(_, _, ident, None)\n-                                        if ident.name != kw::SelfLower => ident.to_string(),\n-                                        _ => \"_\".to_string(),\n-                                    }).collect::<Vec<_>>().join(\", \"),\n-                            );\n-                            // When the obligation error has been ensured to have been caused by\n-                            // an argument, the `obligation.cause.span` points at the expression\n-                            // of the argument, so we can provide a suggestion. This is signaled\n-                            // by `points_at_arg`. Otherwise, we give a more general note.\n-                            if points_at_arg {\n-                                err.span_suggestion(\n-                                    obligation.cause.span,\n-                                    msg,\n-                                    snippet,\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                            } else {\n-                                err.help(&format!(\"{}: `{}`\", msg, snippet));\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n+                let args = decl.inputs.iter()\n+                    .map(|_| \"_\")\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}({})\", name, args)\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(.., body_id),\n+                ..\n+            })) => {\n+                err.span_label(ident.span, \"consider calling this function\");\n+                let body = hir.body(*body_id);\n+                let args = body.params.iter()\n+                    .map(|arg| match &arg.pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, None)\n+                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n+                        // should suggest a method call.\n+                        if ident.name != kw::SelfLower => ident.to_string(),\n+                        _ => \"_\".to_string(),\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}({})\", ident, args)\n             }\n-            _ => {}\n+            _ => return,\n+        };\n+        if points_at_arg {\n+            // When the obligation error has been ensured to have been caused by\n+            // an argument, the `obligation.cause.span` points at the expression\n+            // of the argument, so we can provide a suggestion. This is signaled\n+            // by `points_at_arg`. Otherwise, we give a more general note.\n+            err.span_suggestion(\n+                obligation.cause.span,\n+                &msg,\n+                snippet,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            err.help(&format!(\"{}: `{}`\", msg, snippet));\n         }\n     }\n \n@@ -1410,12 +1483,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let ty::Ref(_, t_type, _) = trait_type.kind {\n                     trait_type = t_type;\n \n-                    let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n-                    let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n-                    let new_obligation = Obligation::new(\n+                    let new_obligation = self.mk_obligation_for_def_id(\n+                        trait_ref.def_id,\n+                        trait_type,\n                         ObligationCause::dummy(),\n                         obligation.param_env,\n-                        new_trait_ref.to_predicate(),\n                     );\n \n                     if self.predicate_may_hold(&new_obligation) {\n@@ -1473,12 +1545,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n-                let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n-                let new_trait_ref = ty::TraitRef::new(trait_ref.skip_binder().def_id, substs);\n-                let new_obligation = Obligation::new(\n+                let new_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.skip_binder().def_id,\n+                    trait_type,\n                     ObligationCause::dummy(),\n                     obligation.param_env,\n-                    new_trait_ref.to_predicate(),\n                 );\n \n                 if self.evaluate_obligation_no_overflow("}, {"sha": "156162c9027c318a89675aabf092739df0a218aa", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs?ref=0b0d683805d008cd81f1c790f528bec9c48021fd", "patch": "@@ -1,4 +1,5 @@\n // edition:2018\n+#![feature(async_closure)]\n use std::future::Future;\n \n async fn foo() {}\n@@ -7,4 +8,6 @@ fn bar(f: impl Future<Output=()>) {}\n \n fn main() {\n     bar(foo); //~ERROR E0277\n+    let async_closure = async || ();\n+    bar(async_closure); //~ERROR E0277\n }"}, {"sha": "05583876a066c3aca42f206fce868e9c75ebd380", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=0b0d683805d008cd81f1c790f528bec9c48021fd", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the trait bound `fn() -> impl std::future::Future {foo}: std::future::Future` is not satisfied\n-  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:9:9\n+  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:10:9\n    |\n+LL | async fn foo() {}\n+   |          --- consider calling this function\n+LL | \n LL | fn bar(f: impl Future<Output=()>) {}\n    |    ---         ----------------- required by this bound in `bar`\n ...\n@@ -10,6 +13,20 @@ LL |     bar(foo);\n    |         the trait `std::future::Future` is not implemented for `fn() -> impl std::future::Future {foo}`\n    |         help: use parentheses to call the function: `foo()`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]: std::future::Future` is not satisfied\n+  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:12:9\n+   |\n+LL | fn bar(f: impl Future<Output=()>) {}\n+   |    ---         ----------------- required by this bound in `bar`\n+...\n+LL |     let async_closure = async || ();\n+   |                         -------- consider calling this closure\n+LL |     bar(async_closure);\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         the trait `std::future::Future` is not implemented for `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]`\n+   |         help: use parentheses to call the closure: `async_closure()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4303e5c54056977b86abc8fdc9d83b957a1ea43d", "filename": "src/test/ui/suggestions/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs?ref=0b0d683805d008cd81f1c790f528bec9c48021fd", "patch": "@@ -15,4 +15,6 @@ fn bar(f: impl T<O=()>) {}\n \n fn main() {\n     bar(foo); //~ERROR E0277\n+    let closure = || S;\n+    bar(closure); //~ERROR E0277\n }"}, {"sha": "91f60e8f426c4fa552a8c5bb68c304a2cccca99f", "filename": "src/test/ui/suggestions/fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d683805d008cd81f1c790f528bec9c48021fd/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=0b0d683805d008cd81f1c790f528bec9c48021fd", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the trait bound `fn() -> impl T {foo}: T` is not satisfied\n   --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:17:9\n    |\n+LL | fn foo() -> impl T<O=()> { S }\n+   |    --- consider calling this function\n+LL | \n LL | fn bar(f: impl T<O=()>) {}\n    |    ---         ------- required by this bound in `bar`\n ...\n@@ -10,6 +13,20 @@ LL |     bar(foo);\n    |         the trait `T` is not implemented for `fn() -> impl T {foo}`\n    |         help: use parentheses to call the function: `foo()`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:23]: T` is not satisfied\n+  --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:19:9\n+   |\n+LL | fn bar(f: impl T<O=()>) {}\n+   |    ---         ------- required by this bound in `bar`\n+...\n+LL |     let closure = || S;\n+   |                   -- consider calling this closure\n+LL |     bar(closure);\n+   |         ^^^^^^^\n+   |         |\n+   |         the trait `T` is not implemented for `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:23]`\n+   |         help: use parentheses to call the closure: `closure()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}