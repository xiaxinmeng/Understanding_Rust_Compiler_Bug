{"sha": "3657c92ac978f69667b9c8bb46e51bc602b3d7ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTdjOTJhYzk3OGY2OTY2N2I5YzhiYjQ2ZTUxYmM2MDJiM2Q3ZWU=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-07-23T16:14:10Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-08-03T04:34:17Z"}, "message": "Check for other things which can be used indirectly", "tree": {"sha": "2051a1cbbd7cfc5d5ae56846c99b554dd8bb7bae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2051a1cbbd7cfc5d5ae56846c99b554dd8bb7bae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3657c92ac978f69667b9c8bb46e51bc602b3d7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3657c92ac978f69667b9c8bb46e51bc602b3d7ee", "html_url": "https://github.com/rust-lang/rust/commit/3657c92ac978f69667b9c8bb46e51bc602b3d7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3657c92ac978f69667b9c8bb46e51bc602b3d7ee/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee61373fe056efb46b6b1b243b31cec0d7e6099", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee61373fe056efb46b6b1b243b31cec0d7e6099", "html_url": "https://github.com/rust-lang/rust/commit/3ee61373fe056efb46b6b1b243b31cec0d7e6099"}], "stats": {"total": 94, "additions": 62, "deletions": 32}, "files": [{"sha": "11a9b1e531c8c6a787de180c626eb001ee8c59b6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3657c92ac978f69667b9c8bb46e51bc602b3d7ee/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657c92ac978f69667b9c8bb46e51bc602b3d7ee/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3657c92ac978f69667b9c8bb46e51bc602b3d7ee", "patch": "@@ -2429,7 +2429,6 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if let ExprKind::Block(ref block, _) = expr.kind {\n         for ref stmt in block.stmts {\n             if_chain! {\n-                // TODO also work for assignments to an existing variable\n                 if let StmtKind::Local(\n                     Local { pat: Pat { kind: PatKind::Binding(_, _, ident, .. ), .. },\n                     init: Some(ref init_expr), .. }\n@@ -2446,21 +2445,22 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n                 if iter_calls.len() == 1;\n                 then {\n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n                     span_lint_and_then(\n                         cx,\n                         NEEDLESS_COLLECT,\n-                        stmt.span,\n+                        stmt.span.until(iter_call.span),\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {\n-                            let iter_replacement = Sugg::hir(cx, iter_source, \"..\").to_string();\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n                             diag.multipart_suggestion(\n-                                \"Use the original Iterator instead of collecting it and then producing a new one\",\n+                                iter_call.get_suggestion_text(),\n                                 vec![\n                                     (stmt.span, String::new()),\n-                                    (iter_calls[0].span, iter_replacement)\n+                                    (iter_call.span, iter_replacement)\n                                 ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n                         },\n                     );\n                 }\n@@ -2469,32 +2469,62 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     }\n }\n \n-struct IntoIterVisitor<'tcx> {\n-    iters: Vec<&'tcx Expr<'tcx>>,\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => format!(\".any(|x| x == {})\", snippet(cx, *span, \"..\")),\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => \"Use the original Iterator instead of collecting it and then producing a new one\",\n+            IterFunctionKind::Len => \"Take the original Iterator's count instead of collecting it and finding the length\",\n+            IterFunctionKind::IsEmpty => \"Check if the original Iterator has anything instead of collecting it and seeing if it's empty\",\n+            IterFunctionKind::Contains(_) => \"Check if the original Iterator contains an element instead of collecting then checking\",\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n     seen_other: bool,\n     target: String,\n }\n-impl<'tcx> Visitor<'tcx> for IntoIterVisitor<'tcx> {\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        match &expr.kind {\n-            ExprKind::MethodCall(\n-                method_name,\n-                _,\n-                &[Expr {\n-                    kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n-                    ..\n-                }],\n-                _,\n-            ) if match_path(path, &[&self.target]) => {\n-                // TODO Check what method is being called, if it's called on target, and act\n-                // accordingly\n-                if method_name.ident.name == sym!(into_iter) {\n-                    self.iters.push(expr);\n-                } else {\n-                    self.seen_other = true;\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if match_path(path, &[&self.target]);\n+            then {\n+                let into_iter = sym!(into_iter);\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    name if name == into_iter => self.uses.push(IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }),\n+                    name if name == len => self.uses.push(IterFunction { func: IterFunctionKind::Len, span: expr.span }),\n+                    name if name == is_empty => self.uses.push(IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }),\n+                    name if name == contains => self.uses.push(IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }),\n+                    _ => self.seen_other = true,\n                 }\n-            },\n-            _ => walk_expr(self, expr),\n+            }\n+            else {\n+                walk_expr(self, expr);\n+            }\n         }\n     }\n \n@@ -2506,17 +2536,17 @@ impl<'tcx> Visitor<'tcx> for IntoIterVisitor<'tcx> {\n \n /// Detect the occurences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<&'tcx Expr<'tcx>>> {\n-    let mut visitor = IntoIterVisitor {\n-        iters: Vec::new(),\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n         target: identifier.name.to_ident_string(),\n         seen_other: false,\n     };\n     visitor.visit_block(block);\n     if visitor.seen_other {\n         None\n     } else {\n-        Some(visitor.iters)\n+        Some(visitor.uses)\n     }\n }\n "}]}