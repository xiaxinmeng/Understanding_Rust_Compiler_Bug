{"sha": "793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "node_id": "C_kwDOAAsO6NoAKDc5M2IyZmZiNjc2MzBiZDRkOTJiYTUwODNiZmRkMDZhZTg0YjYxZWI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-27T05:40:17Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-27T07:50:02Z"}, "message": "Factor out common code in `intern_node`.\n\nThere are three very similar blocks in this function.", "tree": {"sha": "08f4d2109711e0d168fbb605228179a239a1660a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08f4d2109711e0d168fbb605228179a239a1660a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "html_url": "https://github.com/rust-lang/rust/commit/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "207cec017f7ba30a15ab6faf60f28f6e027400a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/207cec017f7ba30a15ab6faf60f28f6e027400a4", "html_url": "https://github.com/rust-lang/rust/commit/207cec017f7ba30a15ab6faf60f28f6e027400a4"}], "stats": {"total": 80, "additions": 26, "deletions": 54}, "files": [{"sha": "8de4d06fe782b0055cf046e3b6a5f35b21b36aa6", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "patch": "@@ -1232,76 +1232,48 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             self.node_intern_event_id.map(|eid| profiler.generic_activity_with_event_id(eid));\n \n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            let get_dep_node_index = |color, fingerprint| {\n+                if print_status {\n+                    eprintln!(\"[task::{color:}] {key:?}\");\n+                }\n+\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key, fingerprint);\n+\n+                dep_node_index\n+            };\n+\n             // Determine the color and index of the new `DepNode`.\n             if let Some(fingerprint) = fingerprint {\n                 if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n-                    if print_status {\n-                        eprintln!(\"[task::green] {key:?}\");\n-                    }\n-\n                     // This is a green node: it existed in the previous compilation,\n                     // its query was re-executed, and it has the same result as before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"green\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n-                    if print_status {\n-                        eprintln!(\"[task::red] {key:?}\");\n-                    }\n-\n                     // This is a red node: it existed in the previous compilation, its query\n                     // was re-executed, but it has a different result from before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"red\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n-                if print_status {\n-                    eprintln!(\"[task::unknown] {key:?}\");\n-                }\n-\n                 // This is a red node, effectively: it existed in the previous compilation\n                 // session, its query was re-executed, but it doesn't compute a result hash\n                 // (i.e. it represents a `no_hash` query), so we have no way of determining\n                 // whether or not the result was the same as before.\n-                let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                let dep_node_index = match prev_index_to_index[prev_index] {\n-                    Some(dep_node_index) => dep_node_index,\n-                    None => {\n-                        let dep_node_index =\n-                            self.encoder.borrow().send(profiler, key, Fingerprint::ZERO, edges);\n-                        prev_index_to_index[prev_index] = Some(dep_node_index);\n-                        dep_node_index\n-                    }\n-                };\n-\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n+                let dep_node_index = get_dep_node_index(\"unknown\", Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {"}]}