{"sha": "d82d9874a6f88e0afa021796e9efaba5b3670c31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MmQ5ODc0YTZmODhlMGFmYTAyMTc5NmU5ZWZhYmE1YjM2NzBjMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T00:09:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T00:09:37Z"}, "message": "auto merge of #6232 : pcwalton/rust/demuting, r=pcwalton\n\nThey're still parsed for bootstrapping purposes, but the qualifier is immediately dropped on the floor.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "4270207820c8eca6e33cf2bbf9f1bbcafe9d74a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4270207820c8eca6e33cf2bbf9f1bbcafe9d74a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d82d9874a6f88e0afa021796e9efaba5b3670c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d82d9874a6f88e0afa021796e9efaba5b3670c31", "html_url": "https://github.com/rust-lang/rust/commit/d82d9874a6f88e0afa021796e9efaba5b3670c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d82d9874a6f88e0afa021796e9efaba5b3670c31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a65f51d666855d7685850808cc06e49c3d21c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a65f51d666855d7685850808cc06e49c3d21c72", "html_url": "https://github.com/rust-lang/rust/commit/5a65f51d666855d7685850808cc06e49c3d21c72"}, {"sha": "d20e63ab65f7ba28db36ae43379706ca9dba1ca5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d20e63ab65f7ba28db36ae43379706ca9dba1ca5", "html_url": "https://github.com/rust-lang/rust/commit/d20e63ab65f7ba28db36ae43379706ca9dba1ca5"}], "stats": {"total": 2934, "additions": 1596, "deletions": 1338}, "files": [{"sha": "75dfe1e780646ec4dcb52cff495847f76a9777b3", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -29,9 +29,9 @@ pub mod rustrt {\n     #[abi = \"cdecl\"]\n     #[link_name = \"rustrt\"]\n     pub extern {\n-        pub unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                                ++v: **vec::raw::VecRepr,\n-                                                ++n: libc::size_t);\n+        pub unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n+                                                v: **vec::raw::VecRepr,\n+                                                n: libc::size_t);\n     }\n }\n \n@@ -60,7 +60,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec: @[A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n-    builder(|+x| unsafe { raw::push(&mut vec, x) });\n+    builder(|x| unsafe { raw::push(&mut vec, x) });\n     return unsafe { transmute(vec) };\n }\n "}, {"sha": "9b93cf68622f6bc3441bf653f1ebb3c900e573b6", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -17,7 +17,7 @@ pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     #[link_name = \"rusti\"]\n     pub extern \"rust-intrinsic\" {\n-        fn forget<T>(+x: T);\n+        fn forget<T>(x: T);\n \n         fn transmute<T,U>(e: T) -> U;\n     }"}, {"sha": "7eaa8535493368ca24fbaa4c02189ec190794826", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 138, "deletions": 96, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,6 +12,7 @@\n Message passing\n */\n \n+use cast::{transmute, transmute_mut};\n use cast;\n use either::{Either, Left, Right};\n use kinds::Owned;\n@@ -118,13 +119,15 @@ pub mod streamp {\n }\n \n /// An endpoint that can send many messages.\n+#[unsafe_mut_field(endp)]\n pub struct Chan<T> {\n-    mut endp: Option<streamp::client::Open<T>>\n+    endp: Option<streamp::client::Open<T>>\n }\n \n /// An endpoint that can receive many messages.\n+#[unsafe_mut_field(endp)]\n pub struct Port<T> {\n-    mut endp: Option<streamp::server::Open<T>>,\n+    endp: Option<streamp::server::Open<T>>,\n }\n \n /** Creates a `(Port, Chan)` pair.\n@@ -135,98 +138,119 @@ These allow sending or receiving an unlimited number of messages.\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     let (c, s) = streamp::init();\n \n-    (Port { endp: Some(s) }, Chan { endp: Some(c) })\n+    (Port {\n+        endp: Some(s)\n+    }, Chan {\n+        endp: Some(c)\n+    })\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n     #[inline(always)]\n     fn send(&self, x: T) {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        self.endp = Some(\n-            streamp::client::data(endp.unwrap(), x))\n+        unsafe {\n+            let mut endp = None;\n+            let mut self_endp = transmute_mut(&self.endp);\n+            endp <-> *self_endp;\n+            *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+        }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match streamp::client::try_data(endp.unwrap(), x) {\n-            Some(next) => {\n-                self.endp = Some(next);\n-                true\n+        unsafe {\n+            let mut endp = None;\n+            let mut self_endp = transmute_mut(&self.endp);\n+            endp <-> *self_endp;\n+            match streamp::client::try_data(endp.unwrap(), x) {\n+                Some(next) => {\n+                    *self_endp = Some(next);\n+                    true\n+                }\n+                None => false\n             }\n-            None => false\n         }\n     }\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n     #[inline(always)]\n     fn recv(&self) -> T {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let streamp::data(x, endp) = recv(endp.unwrap());\n-        self.endp = Some(endp);\n-        x\n+        unsafe {\n+            let mut endp = None;\n+            let mut self_endp = transmute_mut(&self.endp);\n+            endp <-> *self_endp;\n+            let streamp::data(x, endp) = recv(endp.unwrap());\n+            *self_endp = Some(endp);\n+            x\n+        }\n     }\n \n     #[inline(always)]\n     fn try_recv(&self) -> Option<T> {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match try_recv(endp.unwrap()) {\n-            Some(streamp::data(x, endp)) => {\n-                self.endp = Some(endp);\n-                Some(x)\n+        unsafe {\n+            let mut endp = None;\n+            let mut self_endp = transmute_mut(&self.endp);\n+            endp <-> *self_endp;\n+            match try_recv(endp.unwrap()) {\n+                Some(streamp::data(x, endp)) => {\n+                    *self_endp = Some(endp);\n+                    Some(x)\n+                }\n+                None => None\n             }\n-            None => None\n         }\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n     #[inline(always)]\n     fn peek(&self) -> bool {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let peek = match &endp {\n-            &Some(ref endp) => peek(endp),\n-            &None => fail!(~\"peeking empty stream\")\n-        };\n-        self.endp <-> endp;\n-        peek\n+        unsafe {\n+            let mut endp = None;\n+            let mut self_endp = transmute_mut(&self.endp);\n+            endp <-> *self_endp;\n+            let peek = match endp {\n+                Some(ref mut endp) => peek(endp),\n+                None => fail!(~\"peeking empty stream\")\n+            };\n+            *self_endp <-> endp;\n+            peek\n+        }\n     }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         unsafe {\n             match self.endp {\n-                Some(ref endp) => endp.header(),\n+                Some(ref mut endp) => endp.header(),\n                 None => fail!(~\"peeking empty stream\")\n             }\n         }\n     }\n }\n \n /// Treat many ports as one.\n+#[unsafe_mut_field(ports)]\n pub struct PortSet<T> {\n-    mut ports: ~[Port<T>],\n+    ports: ~[Port<T>],\n }\n \n pub impl<T: Owned> PortSet<T> {\n-\n     fn new() -> PortSet<T> {\n         PortSet {\n             ports: ~[]\n         }\n     }\n \n     fn add(&self, port: Port<T>) {\n-        self.ports.push(port)\n+        unsafe {\n+            let self_ports = transmute_mut(&self.ports);\n+            self_ports.push(port)\n+        }\n     }\n \n     fn chan(&self) -> Chan<T> {\n@@ -238,25 +262,28 @@ pub impl<T: Owned> PortSet<T> {\n \n impl<T:Owned> GenericPort<T> for PortSet<T> {\n     fn try_recv(&self) -> Option<T> {\n-        let mut result = None;\n-        // we have to swap the ports array so we aren't borrowing\n-        // aliasable mutable memory.\n-        let mut ports = ~[];\n-        ports <-> self.ports;\n-        while result.is_none() && ports.len() > 0 {\n-            let i = wait_many(ports);\n-            match ports[i].try_recv() {\n-                Some(m) => {\n-                    result = Some(m);\n-                }\n-                None => {\n-                    // Remove this port.\n-                    let _ = ports.swap_remove(i);\n+        unsafe {\n+            let mut self_ports = transmute_mut(&self.ports);\n+            let mut result = None;\n+            // we have to swap the ports array so we aren't borrowing\n+            // aliasable mutable memory.\n+            let mut ports = ~[];\n+            ports <-> *self_ports;\n+            while result.is_none() && ports.len() > 0 {\n+                let i = wait_many(ports);\n+                match ports[i].try_recv() {\n+                    Some(m) => {\n+                        result = Some(m);\n+                    }\n+                    None => {\n+                        // Remove this port.\n+                        let _ = ports.swap_remove(i);\n+                    }\n                 }\n             }\n+            ports <-> *self_ports;\n+            result\n         }\n-        ports <-> self.ports;\n-        result\n     }\n     fn recv(&self) -> T {\n         self.try_recv().expect(\"port_set: endpoints closed\")\n@@ -268,10 +295,9 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-            // XXX: Botch pending demuting.\n-            unsafe {\n-                let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n-                if port.peek() { return true }\n+            let port: &Port<T> = &self.ports[i];\n+            if port.peek() {\n+                return true;\n             }\n         }\n         false\n@@ -327,23 +353,20 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n #[allow(non_camel_case_types)]\n pub mod oneshot {\n     priv use core::kinds::Owned;\n-    use ptr::to_unsafe_ptr;\n+    use ptr::to_mut_unsafe_ptr;\n \n     pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n         pub use core::pipes::HasBuffer;\n \n-        let buffer =\n-            ~::core::pipes::Buffer{\n+        let mut buffer = ~::core::pipes::Buffer {\n             header: ::core::pipes::BufferHeader(),\n-            data: __Buffer{\n+            data: __Buffer {\n                 Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n             },\n         };\n         do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n-            {\n-                data.Oneshot.set_buffer(buffer);\n-                to_unsafe_ptr(&data.Oneshot)\n-            }\n+            data.Oneshot.set_buffer(buffer);\n+            to_mut_unsafe_ptr(&mut data.Oneshot)\n         }\n     }\n     #[allow(non_camel_case_types)]\n@@ -497,48 +520,66 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n \n \n /// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n+pub fn select2i<A:Selectable, B:Selectable>(a: &mut A, b: &mut B)\n+                                            -> Either<(), ()> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    match wait_many(endpoints) {\n+        0 => Left(()),\n+        1 => Right(()),\n+        _ => fail!(~\"wait returned unexpected index\"),\n     }\n }\n \n /// Receive a message from one of two endpoints.\n pub trait Select2<T: Owned, U: Owned> {\n     /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n+    fn try_select(&mut self) -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n-    fn select(&self) -> Either<T, U>;\n+    fn select(&mut self) -> Either<T, U>;\n }\n \n-impl<T: Owned, U: Owned,\n-     Left: Selectable + GenericPort<T>,\n-     Right: Selectable + GenericPort<U>>\n-    Select2<T, U> for (Left, Right) {\n-\n-    fn select(&self) -> Either<T, U> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.recv()),\n-            Right(()) => Right(rp.recv())\n-          }\n+impl<T:Owned,\n+     U:Owned,\n+     Left:Selectable + GenericPort<T>,\n+     Right:Selectable + GenericPort<U>>\n+     Select2<T, U>\n+     for (Left, Right) {\n+    fn select(&mut self) -> Either<T, U> {\n+        // XXX: Bad borrow check workaround.\n+        unsafe {\n+            let this: &(Left, Right) = transmute(self);\n+            match *this {\n+                (ref lp, ref rp) => {\n+                    let lp: &mut Left = transmute(lp);\n+                    let rp: &mut Right = transmute(rp);\n+                    match select2i(lp, rp) {\n+                        Left(()) => Left(lp.recv()),\n+                        Right(()) => Right(rp.recv()),\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.try_recv()),\n-            Right(()) => Right(rp.try_recv())\n-          }\n+    fn try_select(&mut self) -> Either<Option<T>, Option<U>> {\n+        // XXX: Bad borrow check workaround.\n+        unsafe {\n+            let this: &(Left, Right) = transmute(self);\n+            match *this {\n+                (ref lp, ref rp) => {\n+                    let lp: &mut Left = transmute(lp);\n+                    let rp: &mut Right = transmute(rp);\n+                    match select2i(lp, rp) {\n+                        Left(()) => Left (lp.try_recv()),\n+                        Right(()) => Right(rp.try_recv()),\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -555,9 +596,10 @@ mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n-          Right(_) => fail!(),\n-          _ => ()\n+        let mut tuple = (p1, p2);\n+        match tuple.select() {\n+            Right(_) => fail!(),\n+            _ => (),\n         }\n \n         c2.send(123);"}, {"sha": "29d0eb422d50a220750410e65dd8cb86f159b271", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -84,10 +84,11 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_flate_round_trip() {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n     let mut words = ~[];\n     for 20.times {\n-        words.push(r.gen_bytes(r.gen_uint_range(1, 10)));\n+        let range = r.gen_uint_range(1, 10);\n+        words.push(r.gen_bytes(range));\n     }\n     for 20.times {\n         let mut in = ~[];"}, {"sha": "d535abf8ead7c7d304a1ba2af8c3bf6bc4375786", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 126, "deletions": 88, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -19,12 +19,16 @@\n  * CPRNG like rand::rng.\n  */\n \n-use io;\n-use io::Writer;\n+#[cfg(stage0)]\n+use cast;\n+use rt::io::Writer;\n use to_bytes::IterBytes;\n use uint;\n use vec;\n \n+// Alias `SipState` to `State`.\n+pub use State = hash::SipState;\n+\n /**\n  * Types that can meaningfully be hashed should implement this.\n  *\n@@ -65,112 +69,158 @@ impl<A:Hash> HashUtil for A {\n \n /// Streaming hash-functions should implement this.\n pub trait Streaming {\n-    fn input(&self, (&const [u8]));\n+    fn input(&mut self, &[u8]);\n     // These can be refactored some when we have default methods.\n-    fn result_bytes(&self) -> ~[u8];\n-    fn result_str(&self) -> ~str;\n-    fn result_u64(&self) -> u64;\n-    fn reset(&self);\n+    fn result_bytes(&mut self) -> ~[u8];\n+    fn result_str(&mut self) -> ~str;\n+    fn result_u64(&mut self) -> u64;\n+    fn reset(&mut self);\n+}\n+\n+// XXX: Ugly workaround for bootstrapping.\n+#[cfg(stage0)]\n+fn transmute_for_stage0<'a>(bytes: &'a [const u8]) -> &'a [u8] {\n+    unsafe {\n+        cast::transmute(bytes)\n+    }\n+}\n+#[cfg(not(stage0))]\n+fn transmute_for_stage0<'a>(bytes: &'a [u8]) -> &'a [u8] {\n+    bytes\n }\n \n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        let s = &State(k0, k1);\n+        let mut s = State::new(k0, k1);\n         for self.iter_bytes(true) |bytes| {\n-            s.input(bytes);\n+            s.input(transmute_for_stage0(bytes));\n         }\n         s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n-                D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n-                           -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+                D: IterBytes>(\n+                a: &A,\n+                b: &B,\n+                c: &C,\n+                d: &D,\n+                k0: u64,\n+                k1: u64)\n+                -> u64 {\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for d.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n-                              k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for e.iter_bytes(true) |bytes| { s.input(bytes); }\n+                E: IterBytes>(\n+                a: &A,\n+                b: &B,\n+                c: &C,\n+                d: &D,\n+                e: &E,\n+                k0: u64,\n+                k1: u64)\n+                -> u64 {\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for d.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for e.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n-// Implement State as SipState\n-\n-pub type State = SipState;\n-\n-#[inline(always)]\n-pub fn State(k0: u64, k1: u64) -> State {\n-    SipState(k0, k1)\n-}\n-\n #[inline(always)]\n pub fn default_state() -> State {\n-    State(0,0)\n+    State::new(0, 0)\n }\n \n struct SipState {\n     k0: u64,\n     k1: u64,\n-    mut length: uint, // how many bytes we've processed\n-    mut v0: u64,      // hash state\n-    mut v1: u64,\n-    mut v2: u64,\n-    mut v3: u64,\n-    mut tail: [u8, ..8], // unprocessed bytes\n-    mut ntail: uint,  // how many bytes in tail are valid\n+    length: uint, // how many bytes we've processed\n+    v0: u64,      // hash state\n+    v1: u64,\n+    v2: u64,\n+    v3: u64,\n+    tail: [u8, ..8], // unprocessed bytes\n+    ntail: uint,  // how many bytes in tail are valid\n }\n \n-#[inline(always)]\n-fn SipState(key0: u64, key1: u64) -> SipState {\n-    let state = SipState {\n-        k0 : key0,\n-        k1 : key1,\n-        mut length : 0u,\n-        mut v0 : 0u64,\n-        mut v1 : 0u64,\n-        mut v2 : 0u64,\n-        mut v3 : 0u64,\n-        mut tail : [0u8,0,0,0,0,0,0,0],\n-        mut ntail : 0u,\n-    };\n-    (&state).reset();\n-    state\n+impl SipState {\n+    #[inline(always)]\n+    fn new(key0: u64, key1: u64) -> SipState {\n+        let mut state = SipState {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            v0: 0,\n+            v1: 0,\n+            v2: 0,\n+            v3: 0,\n+            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -207,12 +257,10 @@ macro_rules! compress (\n )\n \n \n-impl io::Writer for SipState {\n-\n+impl Writer for SipState {\n     // Methods for io::writer\n     #[inline(always)]\n-    fn write(&self, msg: &const [u8]) {\n-\n+    fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n \n@@ -272,29 +320,19 @@ impl io::Writer for SipState {\n         self.ntail = left;\n     }\n \n-    fn seek(&self, _x: int, _s: io::SeekStyle) {\n-        fail!();\n-    }\n-    fn tell(&self) -> uint {\n-        self.length\n-    }\n-    fn flush(&self) -> int {\n-        0\n-    }\n-    fn get_type(&self) -> io::WriterType {\n-        io::File\n+    fn flush(&mut self) {\n+        // No-op\n     }\n }\n \n impl Streaming for SipState {\n-\n     #[inline(always)]\n-    fn input(&self, buf: &const [u8]) {\n+    fn input(&mut self, buf: &[u8]) {\n         self.write(buf);\n     }\n \n     #[inline(always)]\n-    fn result_u64(&self) -> u64 {\n+    fn result_u64(&mut self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n         let mut v2 = self.v2;\n@@ -324,7 +362,7 @@ impl Streaming for SipState {\n         return (v0 ^ v1 ^ v2 ^ v3);\n     }\n \n-    fn result_bytes(&self) -> ~[u8] {\n+    fn result_bytes(&mut self) -> ~[u8] {\n         let h = self.result_u64();\n         ~[(h >> 0) as u8,\n           (h >> 8) as u8,\n@@ -337,7 +375,7 @@ impl Streaming for SipState {\n         ]\n     }\n \n-    fn result_str(&self) -> ~str {\n+    fn result_str(&mut self) -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for vec::each(r) |b| {\n@@ -347,7 +385,7 @@ impl Streaming for SipState {\n     }\n \n     #[inline(always)]\n-    fn reset(&self) {\n+    fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.v1 = self.k1 ^ 0x646f72616e646f6d;\n@@ -435,10 +473,10 @@ mod tests {\n         let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n         let mut buf : ~[u8] = ~[];\n         let mut t = 0;\n-        let stream_inc = &State(k0,k1);\n-        let stream_full = &State(k0,k1);\n+        let mut stream_inc = SipState::new(k0, k1);\n+        let mut stream_full = SipState::new(k0, k1);\n \n-        fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n+        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n             for vec::each(*r) |b| {\n                 s += uint::to_str_radix(*b as uint, 16u);\n@@ -529,4 +567,4 @@ mod tests {\n             val & !(0xff << (byte * 8))\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8e0a185248e6109975333d2f20cbb4b4501a8881", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -56,7 +56,7 @@ fn resize_at(capacity: uint) -> uint {\n \n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n-    let r = rand::task_rng();\n+    let mut r = rand::task_rng();\n     linear_map_with_capacity_and_keys(r.gen(), r.gen(),\n                                       initial_capacity)\n }"}, {"sha": "1bb754fc2be4229cacb01f8606065511bd6aa0c3", "filename": "src/libcore/io.rs", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -983,36 +983,50 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n // Byte readers\n pub struct BytesReader<'self> {\n     bytes: &'self [u8],\n-    mut pos: uint\n+    pos: @mut uint\n }\n \n impl<'self> Reader for BytesReader<'self> {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        let count = uint::min(len, self.bytes.len() - self.pos);\n+        let count = uint::min(len, self.bytes.len() - *self.pos);\n \n-        let view = vec::slice(self.bytes, self.pos, self.bytes.len());\n+        let view = vec::slice(self.bytes, *self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n \n-        self.pos += count;\n+        *self.pos += count;\n \n         count\n     }\n+\n     fn read_byte(&self) -> int {\n-        if self.pos == self.bytes.len() { return -1; }\n-        let b = self.bytes[self.pos];\n-        self.pos += 1u;\n-        return b as int;\n+        if *self.pos == self.bytes.len() {\n+            return -1;\n+        }\n+\n+        let b = self.bytes[*self.pos];\n+        *self.pos += 1u;\n+        b as int\n+    }\n+\n+    fn eof(&self) -> bool {\n+        *self.pos == self.bytes.len()\n     }\n-    fn eof(&self) -> bool { self.pos == self.bytes.len() }\n+\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = self.pos;\n-        self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n+        let pos = *self.pos;\n+        *self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n+    }\n+\n+    fn tell(&self) -> uint {\n+        *self.pos\n     }\n-    fn tell(&self) -> uint { self.pos }\n }\n \n-pub fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n-    f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n+pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n+    f(@BytesReader {\n+        bytes: bytes,\n+        pos: @mut 0\n+    } as @Reader)\n }\n \n pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n@@ -1498,49 +1512,70 @@ pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n-pub fn print(s: &str) { stdout().write_str(s); }\n-pub fn println(s: &str) { stdout().write_line(s); }\n+pub fn print(s: &str) {\n+    stdout().write_str(s);\n+}\n+\n+pub fn println(s: &str) {\n+    stdout().write_line(s);\n+}\n \n pub struct BytesWriter {\n-    mut bytes: ~[u8],\n-    mut pos: uint,\n+    bytes: @mut ~[u8],\n+    pos: @mut uint,\n }\n \n impl Writer for BytesWriter {\n     fn write(&self, v: &[u8]) {\n         let v_len = v.len();\n-        let bytes_len = vec::uniq_len(&const self.bytes);\n \n-        let count = uint::max(bytes_len, self.pos + v_len);\n-        vec::reserve(&mut self.bytes, count);\n+        let bytes = &mut *self.bytes;\n+        let count = uint::max(bytes.len(), *self.pos + v_len);\n+        vec::reserve(bytes, count);\n \n         unsafe {\n-            vec::raw::set_len(&mut self.bytes, count);\n-            let view = vec::mut_slice(self.bytes, self.pos, count);\n+            // Silly stage0 borrow check workaround...\n+            let casted: &mut ~[u8] = cast::transmute_copy(&bytes);\n+            vec::raw::set_len(casted, count);\n+\n+            let view = vec::mut_slice(*bytes, *self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);\n         }\n \n-        self.pos += v_len;\n+        *self.pos += v_len;\n     }\n+\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = self.pos;\n-        let len = vec::uniq_len(&const self.bytes);\n-        self.pos = seek_in_buf(offset, pos, len, whence);\n+        let pos = *self.pos;\n+        let len = vec::uniq_len(&const *self.bytes);\n+        *self.pos = seek_in_buf(offset, pos, len, whence);\n+    }\n+\n+    fn tell(&self) -> uint {\n+        *self.pos\n+    }\n+\n+    fn flush(&self) -> int {\n+        0\n+    }\n+\n+    fn get_type(&self) -> WriterType {\n+        File\n     }\n-    fn tell(&self) -> uint { self.pos }\n-    fn flush(&self) -> int { 0 }\n-    fn get_type(&self) -> WriterType { File }\n }\n \n pub fn BytesWriter() -> BytesWriter {\n-    BytesWriter { bytes: ~[], mut pos: 0u }\n+    BytesWriter {\n+        bytes: @mut ~[],\n+        pos: @mut 0\n+    }\n }\n \n pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as @Writer);\n-    let @BytesWriter{bytes, _} = wr;\n-    return bytes;\n+    let @BytesWriter { bytes, _ } = wr;\n+    copy *bytes\n }\n \n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n@@ -1550,7 +1585,9 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     v.push(0);\n     assert!(str::is_utf8(v));\n \n-    unsafe { ::cast::transmute(v) }\n+    unsafe {\n+        ::cast::transmute(v)\n+    }\n }\n \n // Utility functions\n@@ -1849,15 +1886,15 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert!(wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert!(*wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert!(wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert!(*wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert!(wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert!(*wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n \n     #[test]"}, {"sha": "afb9641485859a275042d0d8aadcd5530c401aef", "filename": "src/libcore/os.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -352,7 +352,10 @@ pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n     }\n }\n \n-pub struct Pipe { in: c_int, out: c_int }\n+pub struct Pipe {\n+    in: c_int,\n+    out: c_int\n+}\n \n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n@@ -1432,7 +1435,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> ~str {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert!(getenv(n).is_none());\n         n"}, {"sha": "8301254fbdd18a705fd495ac76d4f21fa1757bbf", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 173, "deletions": 151, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -111,7 +111,7 @@ enum State {\n pub struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n-    mut ref_count: int,\n+    ref_count: int,\n \n     // We may want a drop, and to be careful about stringing this\n     // thing along.\n@@ -130,12 +130,12 @@ pub struct Buffer<T> {\n }\n \n pub struct PacketHeader {\n-    mut state: State,\n-    mut blocked_task: *rust_task,\n+    state: State,\n+    blocked_task: *rust_task,\n \n     // This is a transmute_copy of a ~buffer, that can also be cast\n     // to a buffer_header if need be.\n-    mut buffer: *libc::c_void,\n+    buffer: *libc::c_void,\n }\n \n pub fn PacketHeader() -> PacketHeader {\n@@ -148,14 +148,14 @@ pub fn PacketHeader() -> PacketHeader {\n \n pub impl PacketHeader {\n     // Returns the old state.\n-    unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n+    unsafe fn mark_blocked(&mut self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n         assert!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n-    unsafe fn unblock(&self) {\n+    unsafe fn unblock(&mut self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::rust_task_deref(old_task)\n@@ -169,13 +169,13 @@ pub impl PacketHeader {\n \n     // unsafe because this can do weird things to the space/time\n     // continuum. It ends making multiple unique pointers to the same\n-    // thing. You'll proobably want to forget them when you're done.\n-    unsafe fn buf_header(&self) -> ~BufferHeader {\n+    // thing. You'll probably want to forget them when you're done.\n+    unsafe fn buf_header(&mut self) -> ~BufferHeader {\n         assert!(self.buffer.is_not_null());\n         transmute_copy(&self.buffer)\n     }\n \n-    fn set_buffer<T:Owned>(&self, b: ~Buffer<T>) {\n+    fn set_buffer<T:Owned>(&mut self, b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = transmute_copy(&b);\n         }\n@@ -184,15 +184,15 @@ pub impl PacketHeader {\n \n pub struct Packet<T> {\n     header: PacketHeader,\n-    mut payload: Option<T>,\n+    payload: Option<T>,\n }\n \n pub trait HasBuffer {\n-    fn set_buffer(&self, b: *libc::c_void);\n+    fn set_buffer(&mut self, b: *libc::c_void);\n }\n \n impl<T:Owned> HasBuffer for Packet<T> {\n-    fn set_buffer(&self, b: *libc::c_void) {\n+    fn set_buffer(&mut self, b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n@@ -204,7 +204,7 @@ pub fn mk_packet<T:Owned>() -> Packet<T> {\n     }\n }\n fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n-    let b = ~Buffer {\n+    let mut b = ~Buffer {\n         header: BufferHeader(),\n         data: Packet {\n             header: PacketHeader(),\n@@ -218,22 +218,25 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     b\n }\n \n-pub fn packet<T>() -> *Packet<T> {\n-    let b = unibuffer();\n-    let p = ptr::to_unsafe_ptr(&(b.data));\n+pub fn packet<T>() -> *mut Packet<T> {\n+    let mut b = unibuffer();\n+    let p = ptr::to_mut_unsafe_ptr(&mut b.data);\n     // We'll take over memory management from here.\n-    unsafe { forget(b) }\n+    unsafe {\n+        forget(b);\n+    }\n     p\n }\n \n pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n-    buffer: ~Buffer<T>,\n-    init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n-    -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n-{\n-    let p = init(unsafe { transmute_copy(&buffer) }, &buffer.data);\n-    unsafe { forget(buffer) }\n-    (SendPacketBuffered(p), RecvPacketBuffered(p))\n+    mut buffer: ~Buffer<T>,\n+    init: &fn(*libc::c_void, x: &mut T) -> *mut Packet<Tstart>)\n+    -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>) {\n+    unsafe {\n+        let p = init(transmute_copy(&buffer), &mut buffer.data);\n+        forget(buffer);\n+        (SendPacketBuffered(p), RecvPacketBuffered(p))\n+    }\n }\n \n pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n@@ -292,7 +295,7 @@ fn swap_state_rel(dst: &mut State, src: State) -> State {\n     }\n }\n \n-pub unsafe fn get_buffer<T>(p: *PacketHeader) -> ~Buffer<T> {\n+pub unsafe fn get_buffer<T>(p: *mut PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n@@ -306,10 +309,14 @@ struct BufferResource<T> {\n impl<T> Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n-            let b = move_it!(self.buffer);\n+            let this: &mut BufferResource<T> = transmute(self);\n+\n+            let mut b = move_it!(this.buffer);\n             //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n-            let old_count = intrinsics::atomic_xsub_rel(&mut b.header.ref_count, 1);\n+            let old_count = intrinsics::atomic_xsub_rel(\n+                &mut b.header.ref_count,\n+                1);\n             //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n             if old_count == 1 {\n                 // The new count is 0.\n@@ -323,21 +330,25 @@ impl<T> Drop for BufferResource<T> {\n     }\n }\n \n-fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T>(mut b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::to_unsafe_ptr(*b);\n     //error!(\"take %?\", p);\n-    unsafe { intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1) };\n+    unsafe {\n+        intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1);\n+    }\n \n     BufferResource {\n         // tjc: ????\n         buffer: b\n     }\n }\n \n-pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n+pub fn send<T,Tbuffer>(mut p: SendPacketBuffered<T,Tbuffer>,\n+                       payload: T)\n+                       -> bool {\n     let header = p.header();\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n+    let mut p_ = p.unwrap();\n+    let p = unsafe { &mut *p_ };\n     assert!(ptr::to_unsafe_ptr(&(p.header)) == header);\n     assert!(p.payload.is_none());\n     p.payload = Some(payload);\n@@ -391,11 +402,12 @@ Returns `None` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n-    -> Option<T>\n-{\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n+pub fn try_recv<T:Owned,Tbuffer:Owned>(mut p: RecvPacketBuffered<T, Tbuffer>)\n+                                       -> Option<T> {\n+    let mut p_ = p.unwrap();\n+    let mut p = unsafe {\n+        &mut *p_\n+    };\n \n     do (|| {\n         try_recv_(p)\n@@ -412,7 +424,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     }\n }\n \n-fn try_recv_<T:Owned>(p: &Packet<T>) -> Option<T> {\n+fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n@@ -498,16 +510,20 @@ fn try_recv_<T:Owned>(p: &Packet<T>) -> Option<T> {\n }\n \n /// Returns true if messages are available.\n-pub fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n-    match unsafe {(*p.header()).state} {\n-      Empty | Terminated => false,\n-      Blocked => fail!(~\"peeking on blocked packet\"),\n-      Full => true\n+pub fn peek<T:Owned,Tb:Owned>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n+    unsafe {\n+        match (*p.header()).state {\n+            Empty | Terminated => false,\n+            Blocked => fail!(~\"peeking on blocked packet\"),\n+            Full => true\n+        }\n     }\n }\n \n-fn sender_terminate<T:Owned>(p: *Packet<T>) {\n-    let p = unsafe { &*p };\n+fn sender_terminate<T:Owned>(p: *mut Packet<T>) {\n+    let p = unsafe {\n+        &mut *p\n+    };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n         // The receiver will eventually clean up.\n@@ -536,8 +552,10 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     }\n }\n \n-fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n-    let p = unsafe { &*p };\n+fn receiver_terminate<T:Owned>(p: *mut Packet<T>) {\n+    let p = unsafe {\n+        &mut *p\n+    };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n         assert!(p.header.blocked_task.is_null());\n@@ -569,36 +587,45 @@ that vector. The index points to an endpoint that has either been\n closed by the sender or has a message waiting to be received.\n \n */\n-pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n-    let this = unsafe { rustrt::rust_get_task() };\n+pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n+    let this = unsafe {\n+        rustrt::rust_get_task()\n+    };\n \n     unsafe {\n         rustrt::task_clear_event_reject(this);\n     }\n \n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    for pkts.eachi |i, p| {\n+    for vec::eachi_mut(pkts) |i, p| {\n         unsafe {\n-            let p = &*p.header();\n+            let p = &mut *p.header();\n             let old = p.mark_blocked(this);\n             match old {\n-              Full | Terminated => {\n-                data_avail = true;\n-                ready_packet = i;\n-                (*p).state = old;\n-                break;\n-              }\n-              Blocked => fail!(~\"blocking on blocked packet\"),\n-              Empty => ()\n+                Full | Terminated => {\n+                    data_avail = true;\n+                    ready_packet = i;\n+                    (*p).state = old;\n+                    break;\n+                }\n+                Blocked => fail!(~\"blocking on blocked packet\"),\n+                Empty => ()\n             }\n         }\n     }\n \n     while !data_avail {\n         debug!(\"sleeping on %? packets\", pkts.len());\n         let event = wait_event(this) as *PacketHeader;\n-        let pos = vec::position(pkts, |p| p.header() == event);\n+\n+        let mut pos = None;\n+        for vec::eachi_mut(pkts) |i, p| {\n+            if p.header() == event {\n+                pos = Some(i);\n+                break;\n+            }\n+        };\n \n         match pos {\n           Some(i) => {\n@@ -609,11 +636,15 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n         }\n     }\n \n-    debug!(\"%?\", pkts[ready_packet]);\n+    debug!(\"%?\", &mut pkts[ready_packet]);\n \n-    for pkts.each |p| { unsafe{ (*p.header()).unblock()} }\n+    for vec::each_mut(pkts) |p| {\n+        unsafe {\n+            (*p.header()).unblock()\n+        }\n+    }\n \n-    debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n+    debug!(\"%?, %?\", ready_packet, &mut pkts[ready_packet]);\n \n     unsafe {\n         assert!((*pkts[ready_packet].header()).state == Full\n@@ -629,65 +660,58 @@ message.\n */\n pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n \n-pub fn SendPacket<T>(p: *Packet<T>) -> SendPacket<T> {\n+pub fn SendPacket<T>(p: *mut Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n pub struct SendPacketBuffered<T, Tbuffer> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n+    p: Option<*mut Packet<T>>,\n+    buffer: Option<BufferResource<Tbuffer>>,\n }\n \n #[unsafe_destructor]\n impl<T:Owned,Tbuffer:Owned> Drop for SendPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n-        //if self.p != none {\n-        //    debug!(\"drop send %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            sender_terminate(p.unwrap())\n+        unsafe {\n+            let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n+            if this.p != None {\n+                let mut p = None;\n+                p <-> this.p;\n+                sender_terminate(p.unwrap())\n+            }\n         }\n-        //unsafe { error!(\"send_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n     }\n }\n \n-pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n-    -> SendPacketBuffered<T, Tbuffer> {\n-        //debug!(\"take send %?\", p);\n+pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n+                                     -> SendPacketBuffered<T,Tbuffer> {\n     SendPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n+            Some(BufferResource(get_buffer(&mut (*p).header)))\n         }\n     }\n }\n \n pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap(&self) -> *Packet<T> {\n+    fn unwrap(&mut self) -> *mut Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         p.unwrap()\n     }\n \n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::to_unsafe_ptr(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => fail!(~\"packet already consumed\")\n+            Some(packet) => unsafe {\n+                let packet = &mut *packet;\n+                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n+                header\n+            },\n+            None => fail!(~\"packet already consumed\")\n         }\n     }\n \n-    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n+    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n@@ -699,69 +723,62 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n /// message.\n pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n \n-pub fn RecvPacket<T>(p: *Packet<T>) -> RecvPacket<T> {\n+pub fn RecvPacket<T>(p: *mut Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n+\n pub struct RecvPacketBuffered<T, Tbuffer> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n+    p: Option<*mut Packet<T>>,\n+    buffer: Option<BufferResource<Tbuffer>>,\n }\n \n #[unsafe_destructor]\n impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n-        //if self.p != none {\n-        //    debug!(\"drop recv %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            receiver_terminate(p.unwrap())\n+        unsafe {\n+            let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n+            if this.p != None {\n+                let mut p = None;\n+                p <-> this.p;\n+                receiver_terminate(p.unwrap())\n+            }\n         }\n-        //unsafe { error!(\"recv_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n     }\n }\n \n pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n-    fn unwrap(&self) -> *Packet<T> {\n+    fn unwrap(&mut self) -> *mut Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         p.unwrap()\n     }\n \n-    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n-        //error!(\"recv reuse_buffer\");\n+    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         let mut tmp = None;\n         tmp <-> self.buffer;\n         tmp.unwrap()\n     }\n }\n \n impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::to_unsafe_ptr(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => fail!(~\"packet already consumed\")\n+            Some(packet) => unsafe {\n+                let packet = &mut *packet;\n+                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n+                header\n+            },\n+            None => fail!(~\"packet already consumed\")\n         }\n     }\n }\n \n-pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n-    -> RecvPacketBuffered<T,Tbuffer> {\n-    //debug!(\"take recv %?\", p);\n+pub fn RecvPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n+                                     -> RecvPacketBuffered<T,Tbuffer> {\n     RecvPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n+            Some(BufferResource(get_buffer(&mut (*p).header)))\n         }\n     }\n }\n@@ -800,51 +817,55 @@ this case, `select2` may return either `left` or `right`.\n \n */\n pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n-    a: RecvPacketBuffered<A, Ab>,\n-    b: RecvPacketBuffered<B, Bb>)\n+    mut a: RecvPacketBuffered<A, Ab>,\n+    mut b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n-              (RecvPacketBuffered<A, Ab>, Option<B>)>\n-{\n-    let i = wait_many([a.header(), b.header()]);\n-\n+              (RecvPacketBuffered<A, Ab>, Option<B>)> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    let i = wait_many(endpoints);\n     match i {\n-      0 => Left((try_recv(a), b)),\n-      1 => Right((a, try_recv(b))),\n-      _ => fail!(~\"select2 return an invalid packet\")\n+        0 => Left((try_recv(a), b)),\n+        1 => Right((a, try_recv(b))),\n+        _ => fail!(~\"select2 return an invalid packet\")\n     }\n }\n \n pub trait Selectable {\n-    fn header(&self) -> *PacketHeader;\n+    fn header(&mut self) -> *mut PacketHeader;\n }\n \n-impl Selectable for *PacketHeader {\n-    fn header(&self) -> *PacketHeader { *self }\n+impl Selectable for *mut PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader { *self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T:Selectable>(endpoints: &mut [T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n+pub fn select2i<A:Selectable,B:Selectable>(a: &mut A, b: &mut B)\n+                                           -> Either<(), ()> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    match wait_many(endpoints) {\n+        0 => Left(()),\n+        1 => Right(()),\n+        _ => fail!(~\"wait returned unexpected index\")\n     }\n }\n \n-/** Waits on a set of endpoints. Returns a message, its index, and a\n- list of the remaining endpoints.\n+/// Waits on a set of endpoints. Returns a message, its index, and a\n+/// list of the remaining endpoints.\n+pub fn select<T:Owned,Tb:Owned>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n+                                -> (uint,\n+                                    Option<T>,\n+                                    ~[RecvPacketBuffered<T, Tb>]) {\n+    let mut endpoint_headers = ~[];\n+    for vec::each_mut(endpoints) |endpoint| {\n+        endpoint_headers.push(endpoint.header());\n+    }\n \n-*/\n-pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n-    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n-{\n-    let ready = wait_many(endpoints.map(|p| p.header()));\n+    let ready = wait_many(endpoint_headers);\n     let mut remaining = endpoints;\n     let port = remaining.swap_remove(ready);\n     let result = try_recv(port);\n@@ -873,9 +894,10 @@ mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n-          Right(_) => fail!(),\n-          _ => ()\n+        let mut tuple = (p1, p2);\n+        match tuple.select() {\n+            Right(_) => fail!(),\n+            _ => (),\n         }\n \n         c2.send(123);"}, {"sha": "1a5ff39b30565fca59a5549d71754b0dbcd29066", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -336,7 +336,10 @@ pub mod ptr_tests {\n     #[test]\n     fn test() {\n         unsafe {\n-            struct Pair {mut fst: int, mut snd: int};\n+            struct Pair {\n+                fst: int,\n+                snd: int\n+            };\n             let mut p = Pair {fst: 10, snd: 20};\n             let pptr: *mut Pair = &mut p;\n             let iptr: *mut int = cast::transmute(pptr);"}, {"sha": "f11840c95d5acc95384e43cf6cbc2ff66b8cce37", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 119, "deletions": 101, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -55,12 +55,12 @@ pub mod distributions;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n-    fn rand<R: Rng>(rng: &R) -> Self;\n+    fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n impl Rand for int {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> int {\n+    fn rand<R: Rng>(rng: &mut R) -> int {\n         if int::bits == 32 {\n             rng.next() as int\n         } else {\n@@ -71,35 +71,35 @@ impl Rand for int {\n \n impl Rand for i8 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i8 {\n+    fn rand<R: Rng>(rng: &mut R) -> i8 {\n         rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i16 {\n+    fn rand<R: Rng>(rng: &mut R) -> i16 {\n         rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i32 {\n+    fn rand<R: Rng>(rng: &mut R) -> i32 {\n         rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i64 {\n+    fn rand<R: Rng>(rng: &mut R) -> i64 {\n         (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> uint {\n+    fn rand<R: Rng>(rng: &mut R) -> uint {\n         if uint::bits == 32 {\n             rng.next() as uint\n         } else {\n@@ -110,50 +110,50 @@ impl Rand for uint {\n \n impl Rand for u8 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u8 {\n+    fn rand<R: Rng>(rng: &mut R) -> u8 {\n         rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u16 {\n+    fn rand<R: Rng>(rng: &mut R) -> u16 {\n         rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u32 {\n+    fn rand<R: Rng>(rng: &mut R) -> u32 {\n         rng.next()\n     }\n }\n \n impl Rand for u64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u64 {\n+    fn rand<R: Rng>(rng: &mut R) -> u64 {\n         (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> float {\n+    fn rand<R: Rng>(rng: &mut R) -> float {\n         rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> f32 {\n+    fn rand<R: Rng>(rng: &mut R) -> f32 {\n         rng.gen::<f64>() as f32\n     }\n }\n \n static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> f64 {\n+    fn rand<R: Rng>(rng: &mut R) -> f64 {\n         let u1 = rng.next() as f64;\n         let u2 = rng.next() as f64;\n         let u3 = rng.next() as f64;\n@@ -164,14 +164,14 @@ impl Rand for f64 {\n \n impl Rand for char {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> char {\n+    fn rand<R: Rng>(rng: &mut R) -> char {\n         rng.next() as char\n     }\n }\n \n impl Rand for bool {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> bool {\n+    fn rand<R: Rng>(rng: &mut R) -> bool {\n         rng.next() & 1u32 == 1u32\n     }\n }\n@@ -185,7 +185,7 @@ macro_rules! tuple_impl {\n             > Rand for ( $( $tyvar ),* , ) {\n \n             #[inline]\n-            fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n+            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n                 (\n                     // use the $tyvar's to get the appropriate number of\n                     // repeats (they're not actually needed)\n@@ -201,7 +201,7 @@ macro_rules! tuple_impl {\n \n impl Rand for () {\n     #[inline]\n-    fn rand<R: Rng>(_: &R) -> () { () }\n+    fn rand<R: Rng>(_: &mut R) -> () { () }\n }\n tuple_impl!{A}\n tuple_impl!{A, B}\n@@ -216,7 +216,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> Option<T> {\n+    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n         if rng.gen() {\n             Some(rng.gen())\n         } else {\n@@ -227,12 +227,12 @@ impl<T:Rand> Rand for Option<T> {\n \n impl<T: Rand> Rand for ~T {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n }\n \n #[abi = \"cdecl\"]\n@@ -248,7 +248,7 @@ pub mod rustrt {\n /// A random number generator\n pub trait Rng {\n     /// Return the next random integer\n-    pub fn next(&self) -> u32;\n+    pub fn next(&mut self) -> u32;\n }\n \n /// A value with a particular weight compared to other values\n@@ -259,21 +259,21 @@ pub struct Weighted<T> {\n \n pub trait RngUtil {\n     /// Return a random value of a Rand type\n-    fn gen<T:Rand>(&self) -> T;\n+    fn gen<T:Rand>(&mut self) -> T;\n     /**\n      * Return a int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_int_range(&self, start: int, end: int) -> int;\n+    fn gen_int_range(&mut self, start: int, end: int) -> int;\n     /**\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_uint_range(&self, start: uint, end: uint) -> uint;\n+    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint;\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(&self, chars: &str) -> char;\n+    fn gen_char_from(&mut self, chars: &str) -> char;\n     /**\n      * Return a bool with a 1 in n chance of true\n      *\n@@ -289,7 +289,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_weighted_bool(&self, n: uint) -> bool;\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool;\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      *\n@@ -305,7 +305,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_str(&self, len: uint) -> ~str;\n+    fn gen_str(&mut self, len: uint) -> ~str;\n     /**\n      * Return a random byte string of the specified length\n      *\n@@ -321,7 +321,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_bytes(&self, len: uint) -> ~[u8];\n+    fn gen_bytes(&mut self, len: uint) -> ~[u8];\n     /**\n      * Choose an item randomly, failing if values is empty\n      *\n@@ -337,9 +337,9 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose<T:Copy>(&self, values: &[T]) -> T;\n+    fn choose<T:Copy>(&mut self, values: &[T]) -> T;\n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T>;\n+    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T>;\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n@@ -359,7 +359,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T;\n+    fn choose_weighted<T:Copy>(&mut self, v : &[Weighted<T>]) -> T;\n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n@@ -379,7 +379,8 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T>;\n+    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n+                                     -> Option<T>;\n     /**\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n@@ -399,7 +400,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T];\n+    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T];\n     /**\n      * Shuffle a vec\n      *\n@@ -415,7 +416,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T];\n+    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T];\n     /**\n      * Shuffle a mutable vec in place\n      *\n@@ -435,22 +436,22 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn shuffle_mut<T>(&self, values: &mut [T]);\n+    fn shuffle_mut<T>(&mut self, values: &mut [T]);\n }\n \n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n     #[inline(always)]\n-    fn gen<T: Rand>(&self) -> T {\n+    fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n     /**\n      * Return an int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_int_range(&self, start: int, end: int) -> int {\n+    fn gen_int_range(&mut self, start: int, end: int) -> int {\n         assert!(start < end);\n         start + int::abs(self.gen::<int>() % (end - start))\n     }\n@@ -459,23 +460,23 @@ impl<R: Rng> RngUtil for R {\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n+    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n         assert!(start < end);\n         start + (self.gen::<uint>() % (end - start))\n     }\n \n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(&self, chars: &str) -> char {\n+    fn gen_char_from(&mut self, chars: &str) -> char {\n         assert!(!chars.is_empty());\n         let mut cs = ~[];\n         for str::each_char(chars) |c| { cs.push(c) }\n         self.choose(cs)\n     }\n \n     /// Return a bool with a 1-in-n chance of true\n-    fn gen_weighted_bool(&self, n: uint) -> bool {\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n         if n == 0u {\n             true\n         } else {\n@@ -486,7 +487,7 @@ impl<R: Rng> RngUtil for R {\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      */\n-    fn gen_str(&self, len: uint) -> ~str {\n+    fn gen_str(&mut self, len: uint) -> ~str {\n         let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                        abcdefghijklmnopqrstuvwxyz\\\n                        0123456789\";\n@@ -500,19 +501,19 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Return a random byte string of the specified length\n-    fn gen_bytes(&self, len: uint) -> ~[u8] {\n+    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n             self.gen()\n         }\n     }\n \n     /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Copy>(&self, values: &[T]) -> T {\n+    fn choose<T:Copy>(&mut self, values: &[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T> {\n+    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T> {\n         if values.is_empty() {\n             None\n         } else {\n@@ -523,15 +524,16 @@ impl<R: Rng> RngUtil for R {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T {\n+    fn choose_weighted<T:Copy>(&mut self, v: &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T> {\n+    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n+                                     -> Option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n@@ -554,7 +556,7 @@ impl<R: Rng> RngUtil for R {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n@@ -565,14 +567,14 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T] {\n+    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n         m\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(&self, values: &mut [T]) {\n+    fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n@@ -594,12 +596,12 @@ static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n /// A random number generator that uses the [ISAAC\n /// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n pub struct IsaacRng {\n-    priv mut cnt: u32,\n-    priv mut rsl: [u32, .. RAND_SIZE],\n-    priv mut mem: [u32, .. RAND_SIZE],\n-    priv mut a: u32,\n-    priv mut b: u32,\n-    priv mut c: u32\n+    priv cnt: u32,\n+    priv rsl: [u32, .. RAND_SIZE],\n+    priv mem: [u32, .. RAND_SIZE],\n+    priv a: u32,\n+    priv b: u32,\n+    priv c: u32\n }\n \n pub impl IsaacRng {\n@@ -647,7 +649,7 @@ pub impl IsaacRng {\n     /// Initialises `self`. If `use_rsl` is true, then use the current value\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n-    priv fn init(&self, use_rsl: bool) {\n+    priv fn init(&mut self, use_rsl: bool) {\n         macro_rules! init_mut_many (\n             ($( $var:ident ),* = $val:expr ) => {\n                 let mut $( $var = $val ),*;\n@@ -705,16 +707,16 @@ pub impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n-    priv fn isaac(&self) {\n+    priv fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n         let mut a = self.a, b = self.b + self.c;\n-        let mem = &mut self.mem;\n-        let rsl = &mut self.rsl;\n \n         static midpoint: uint =  RAND_SIZE as uint / 2;\n \n-        macro_rules! ind (($x:expr) => { mem[($x >> 2) & (RAND_SIZE - 1)] });\n+        macro_rules! ind (($x:expr) => {\n+            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n+        });\n         macro_rules! rngstep(\n             ($j:expr, $shift:expr) => {{\n                 let base = base + $j;\n@@ -724,13 +726,13 @@ pub impl IsaacRng {\n                     a << $shift as uint\n                 };\n \n-                let x = mem[base  + mr_offset];\n-                a = (a ^ mix) + mem[base + m2_offset];\n+                let x = self.mem[base  + mr_offset];\n+                a = (a ^ mix) + self.mem[base + m2_offset];\n                 let y = ind!(x) + a + b;\n-                mem[base + mr_offset] = y;\n+                self.mem[base + mr_offset] = y;\n \n                 b = ind!(y >> RAND_SIZE_LEN) + x;\n-                rsl[base + mr_offset] = b;\n+                self.rsl[base + mr_offset] = b;\n             }}\n         );\n \n@@ -751,7 +753,7 @@ pub impl IsaacRng {\n \n impl Rng for IsaacRng {\n     #[inline(always)]\n-    fn next(&self) -> u32 {\n+    fn next(&mut self) -> u32 {\n         if self.cnt == 0 {\n             // make some more numbers\n             self.isaac();\n@@ -765,15 +767,15 @@ impl Rng for IsaacRng {\n /// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n /// cryptographic purposes.\n pub struct XorShiftRng {\n-    priv mut x: u32,\n-    priv mut y: u32,\n-    priv mut z: u32,\n-    priv mut w: u32,\n+    priv x: u32,\n+    priv y: u32,\n+    priv z: u32,\n+    priv w: u32,\n }\n \n impl Rng for XorShiftRng {\n     #[inline]\n-    pub fn next(&self) -> u32 {\n+    pub fn next(&mut self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -789,7 +791,10 @@ pub impl XorShiftRng {\n     /// Create an xor shift random number generator with a default seed.\n     fn new() -> XorShiftRng {\n         // constants taken from http://en.wikipedia.org/wiki/Xorshift\n-        XorShiftRng::new_seeded(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n+        XorShiftRng::new_seeded(123456789u32,\n+                                362436069u32,\n+                                521288629u32,\n+                                88675123u32)\n     }\n \n     /**\n@@ -798,7 +803,12 @@ pub impl XorShiftRng {\n      * all other generators constructed with the same seed.\n      */\n     fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n-        XorShiftRng { x: x, y: y, z: z, w: w }\n+        XorShiftRng {\n+            x: x,\n+            y: y,\n+            z: z,\n+            w: w,\n+        }\n     }\n }\n \n@@ -815,23 +825,23 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n-fn tls_rng_state(_v: @IsaacRng) {}\n+fn tls_rng_state(_v: @@mut IsaacRng) {}\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * `task_rng().gen::<int>()`.\n  */\n #[inline]\n-pub fn task_rng() -> @IsaacRng {\n-    let r : Option<@IsaacRng>;\n+pub fn task_rng() -> @@mut IsaacRng {\n+    let r : Option<@@mut IsaacRng>;\n     unsafe {\n         r = task::local_data::local_data_get(tls_rng_state);\n     }\n     match r {\n         None => {\n             unsafe {\n-                let rng = @IsaacRng::new_seeded(seed());\n+                let rng = @@mut IsaacRng::new_seeded(seed());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n                 rng\n             }\n@@ -841,9 +851,13 @@ pub fn task_rng() -> @IsaacRng {\n }\n \n // Allow direct chaining with `task_rng`\n-impl<R: Rng> Rng for @R {\n+impl<R: Rng> Rng for @@mut R {\n     #[inline(always)]\n-    fn next(&self) -> u32 { (**self).next() }\n+    fn next(&mut self) -> u32 {\n+        match *self {\n+            @@ref mut r => r.next()\n+        }\n+    }\n }\n \n /**\n@@ -852,7 +866,9 @@ impl<R: Rng> Rng for @R {\n  */\n #[inline]\n pub fn random<T: Rand>() -> T {\n-    (*task_rng()).gen()\n+    match *task_rng() {\n+        @ref mut r => r.gen()\n+    }\n }\n \n #[cfg(test)]\n@@ -863,24 +879,24 @@ mod tests {\n     #[test]\n     fn test_rng_seeded() {\n         let seed = seed();\n-        let ra = IsaacRng::new_seeded(seed);\n-        let rb = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n     fn test_rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = IsaacRng::new_seeded(seed);\n-        let rb = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n     fn test_rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n@@ -890,7 +906,7 @@ mod tests {\n \n     #[test]\n     fn test_gen_int_range() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n         assert!(r.gen_int_range(0, 1) == 0);\n@@ -901,12 +917,13 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_gen_int_from_fail() {\n-        rng().gen_int_range(5, -2);\n+        let mut r = rng();\n+        r.gen_int_range(5, -2);\n     }\n \n     #[test]\n     fn test_gen_uint_range() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -917,27 +934,28 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_gen_uint_range_fail() {\n-        rng().gen_uint_range(5u, 2u);\n+        let mut r = rng();\n+        r.gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n     fn test_gen_float() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen::<float>();\n         let b = r.gen::<float>();\n         debug!((a, b));\n     }\n \n     #[test]\n     fn test_gen_weighted_bool() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n     fn test_gen_str() {\n-        let r = rng();\n+        let mut r = rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -948,29 +966,29 @@ mod tests {\n \n     #[test]\n     fn test_gen_bytes() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n     fn test_choose() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n     fn test_choose_option() {\n-        let r = rng();\n+        let mut r = rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n     fn test_choose_weighted() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose_weighted(~[\n             Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n@@ -982,7 +1000,7 @@ mod tests {\n \n     #[test]\n     fn test_choose_weighted_option() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose_weighted_option(~[\n             Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n@@ -996,7 +1014,7 @@ mod tests {\n \n     #[test]\n     fn test_weighted_vec() {\n-        let r = rng();\n+        let mut r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n         assert!(r.weighted_vec(~[\n@@ -1008,15 +1026,15 @@ mod tests {\n \n     #[test]\n     fn test_shuffle() {\n-        let r = rng();\n+        let mut r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n-        let r = task_rng();\n+        let mut r = task_rng();\n         r.gen::<int>();\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -1063,7 +1081,7 @@ mod tests {\n                 let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n-                let rng = IsaacRng::new_seeded(seed);\n+                let mut rng = IsaacRng::new_seeded(seed);\n \n                 for 10000.times {\n                     assert_eq!(rng.next(), rustrt::rand_next(rt_rng));"}, {"sha": "72cff5111e76291e46be9ca60b7b03d682972302", "filename": "src/libcore/rand/distributions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand%2Fdistributions.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -27,13 +27,13 @@ mod ziggurat_tables;\n \n // inlining should mean there is no performance penalty for this\n #[inline(always)]\n-fn ziggurat<R:Rng>(rng: &R,\n+fn ziggurat<R:Rng>(rng: &mut R,\n                    center_u: bool,\n                    X: ziggurat_tables::ZigTable,\n                    F: ziggurat_tables::ZigTable,\n                    F_DIFF: ziggurat_tables::ZigTable,\n                    pdf: &'static fn(f64) -> f64, // probability density function\n-                   zero_case: &'static fn(&R, f64) -> f64) -> f64 {\n+                   zero_case: &'static fn(&mut R, f64) -> f64) -> f64 {\n     loop {\n         let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};\n         let i: uint = rng.gen::<uint>() & 0xff;\n@@ -76,13 +76,13 @@ fn ziggurat<R:Rng>(rng: &R,\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n-    fn rand<R:Rng>(rng: &R) -> StandardNormal {\n+    fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n         #[inline(always)]\n         fn pdf(x: f64) -> f64 {\n             f64::exp((-x*x/2.0) as f64) as f64\n         }\n         #[inline(always)]\n-        fn zero_case<R:Rng>(rng: &R, u: f64) -> f64 {\n+        fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n             // compute a random number in the tail by hand\n \n             // strange initial conditions, because the loop is not\n@@ -130,13 +130,13 @@ pub struct Exp1(f64);\n // This could be done via `-f64::ln(rng.gen::<f64>())` but that is slower.\n impl Rand for Exp1 {\n     #[inline]\n-    fn rand<R:Rng>(rng: &R) -> Exp1 {\n+    fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n         #[inline(always)]\n         fn pdf(x: f64) -> f64 {\n             f64::exp(-x)\n         }\n         #[inline(always)]\n-        fn zero_case<R:Rng>(rng: &R, _u: f64) -> f64 {\n+        fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n             ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n         }\n "}, {"sha": "a645a7e86807674b655b7a46f508d84558b6637a", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -144,28 +144,30 @@ enum VariantState {\n }\n \n pub struct ReprVisitor {\n-    mut ptr: *c_void,\n-    mut ptr_stk: ~[*c_void],\n-    mut var_stk: ~[VariantState],\n+    ptr: @mut *c_void,\n+    ptr_stk: @mut ~[*c_void],\n+    var_stk: @mut ~[VariantState],\n     writer: @Writer\n }\n pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n-    ReprVisitor { ptr: ptr,\n-                  ptr_stk: ~[],\n-                  var_stk: ~[],\n-                  writer: writer }\n+    ReprVisitor {\n+        ptr: @mut ptr,\n+        ptr_stk: @mut ~[],\n+        var_stk: @mut ~[],\n+        writer: writer,\n+    }\n }\n \n impl MovePtr for ReprVisitor {\n     #[inline(always)]\n     fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n-        self.ptr = adjustment(self.ptr);\n+        *self.ptr = adjustment(*self.ptr);\n     }\n     fn push_ptr(&self) {\n-        self.ptr_stk.push(self.ptr);\n+        self.ptr_stk.push(*self.ptr);\n     }\n     fn pop_ptr(&self) {\n-        self.ptr = self.ptr_stk.pop();\n+        *self.ptr = self.ptr_stk.pop();\n     }\n }\n \n@@ -176,14 +178,14 @@ pub impl ReprVisitor {\n     #[inline(always)]\n     fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n-            f(transmute::<*c_void,&T>(copy self.ptr));\n+            f(transmute::<*c_void,&T>(*self.ptr));\n         }\n         true\n     }\n \n     #[inline(always)]\n     fn visit_inner(&self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(self.ptr, inner)\n+        self.visit_ptr_inner(*self.ptr, inner)\n     }\n \n     #[inline(always)]\n@@ -446,11 +448,16 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    fn visit_enter_enum(&self, _n_variants: uint,\n+    fn visit_enter_enum(&self,\n+                        _n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        _sz: uint, _align: uint) -> bool {\n-        let disr = unsafe { get_disr(transmute(self.ptr)) };\n-        self.var_stk.push(SearchingFor(disr));\n+                        _sz: uint,\n+                        _align: uint) -> bool {\n+        let var_stk: &mut ~[VariantState] = self.var_stk;\n+        let disr = unsafe {\n+            get_disr(transmute(*self.ptr))\n+        };\n+        var_stk.push(SearchingFor(disr));\n         true\n     }\n \n@@ -482,8 +489,12 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    fn visit_enum_variant_field(&self, i: uint, _offset: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n+    fn visit_enum_variant_field(&self,\n+                                i: uint,\n+                                _offset: uint,\n+                                inner: *TyDesc)\n+                                -> bool {\n+        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n             Matched => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -501,7 +512,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n+        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n             Matched => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');\n@@ -512,10 +523,14 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    fn visit_leave_enum(&self, _n_variants: uint,\n+    fn visit_leave_enum(&self,\n+                        _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        _sz: uint, _align: uint) -> bool {\n-        match self.var_stk.pop() {\n+                        _sz: uint,\n+                        _align: uint)\n+                        -> bool {\n+        let var_stk: &mut ~[VariantState] = self.var_stk;\n+        match var_stk.pop() {\n             SearchingFor(*) => fail!(~\"enum value matched no variant\"),\n             _ => true\n         }"}, {"sha": "5ca7a72e84e8678a5656e2c935278cb5e2c085b0", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -225,8 +225,8 @@ mod test {\n     fn rng() {\n         do run_in_newsched_task() {\n             use rand::{rng, Rng};\n-            let r = rng();\n+            let mut r = rng();\n             let _ = r.next();\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4bff3bff7d3aed9abe1bfaa15296bdff080fea5a", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -393,24 +393,26 @@ extern {\n     // FIXME ref #2064\n     fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                            tcp_handle_ptr: *uv_tcp_t,\n-                           ++after_cb: *u8,\n-                           ++addr: *sockaddr_in) -> c_int;\n+                           after_cb: *u8,\n+                           addr: *sockaddr_in) -> c_int;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n     // FIXME ref #2064\n     fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n                             tcp_handle_ptr: *uv_tcp_t,\n-                            ++after_cb: *u8,\n-                            ++addr: *sockaddr_in6) -> c_int;\n+                            after_cb: *u8,\n+                            addr: *sockaddr_in6) -> c_int;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                               name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                                name: *sockaddr_in6) ->c_int;\n     fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n     fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n     fn rust_uv_write(req: *c_void,\n                      stream: *c_void,\n-                     ++buf_in: *uv_buf_t,\n+                     buf_in: *uv_buf_t,\n                      buf_cnt: c_int,\n                      cb: *u8) -> c_int;\n     fn rust_uv_read_start(stream: *c_void,\n@@ -426,7 +428,7 @@ extern {\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n \n     fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n     fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n@@ -436,6 +438,6 @@ extern {\n     fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n     fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n-    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> size_t;\n+    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n }"}, {"sha": "1958b5b9d80dae80a4d73587c1b9fbf4f0c536fb", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -81,6 +81,6 @@ fn frame_address(f: &fn(x: *u8)) {\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n-        pub fn frame_address(+f: &once fn(x: *u8));\n+        pub fn frame_address(f: &once fn(x: *u8));\n     }\n }"}, {"sha": "e58aa14572b7e4dacbb05fc1beaae17edd9c176c", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 114, "deletions": 165, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -156,7 +156,7 @@ pub struct SchedOpts {\n pub struct TaskOpts {\n     linked: bool,\n     supervised: bool,\n-    mut notify_chan: Option<Chan<TaskResult>>,\n+    notify_chan: Option<Chan<TaskResult>>,\n     sched: SchedOpts\n }\n \n@@ -176,9 +176,9 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    mut gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n     can_not_copy: Option<util::NonCopyable>,\n-    mut consumed: bool,\n+    consumed: bool,\n }\n \n /**\n@@ -191,13 +191,13 @@ pub fn task() -> TaskBuilder {\n         opts: default_task_opts(),\n         gen_body: None,\n         can_not_copy: None,\n-        mut consumed: false,\n+        consumed: false,\n     }\n }\n \n #[doc(hidden)] // FIXME #3538\n priv impl TaskBuilder {\n-    fn consume(&self) -> TaskBuilder {\n+    fn consume(&mut self) -> TaskBuilder {\n         if self.consumed {\n             fail!(~\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n@@ -219,57 +219,25 @@ priv impl TaskBuilder {\n }\n \n pub impl TaskBuilder {\n-    /**\n-     * Decouple the child task's failure from the parent's. If either fails,\n-     * the other will not be killed.\n-     */\n-    fn unlinked(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: false,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+    /// Decouple the child task's failure from the parent's. If either fails,\n+    /// the other will not be killed.\n+    fn unlinked(&mut self) {\n+        self.opts.linked = false;\n     }\n-    /**\n-     * Unidirectionally link the child task's failure with the parent's. The\n-     * child's failure will not kill the parent, but the parent's will kill\n-     * the child.\n-     */\n-    fn supervised(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: false,\n-                supervised: true,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+\n+    /// Unidirectionally link the child task's failure with the parent's. The\n+    /// child's failure will not kill the parent, but the parent's will kill\n+    /// the child.\n+    fn supervised(&mut self) {\n+        self.opts.supervised = true;\n+        self.opts.linked = false;\n     }\n-    /**\n-     * Link the child task's and parent task's failures. If either fails, the\n-     * other will be killed.\n-     */\n-    fn linked(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: true,\n-                supervised: false,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+\n+    /// Link the child task's and parent task's failures. If either fails, the\n+    /// other will be killed.\n+    fn linked(&mut self) {\n+        self.opts.linked = true;\n+        self.opts.supervised = false;\n     }\n \n     /**\n@@ -289,7 +257,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(&self, blk: &fn(v: Port<TaskResult>)) -> TaskBuilder {\n+    fn future_result(&mut self, blk: &fn(v: Port<TaskResult>)) {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -305,30 +273,12 @@ pub impl TaskBuilder {\n         blk(notify_pipe_po);\n \n         // Reconfigure self to use a notify channel.\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: Some(notify_pipe_ch),\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+        self.opts.notify_chan = Some(notify_pipe_ch);\n     }\n+\n     /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(&self, mode: SchedMode) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: SchedOpts { mode: mode, foreign_stack_size: None}\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+    fn sched_mode(&mut self, mode: SchedMode) {\n+        self.opts.sched.mode = mode;\n     }\n \n     /**\n@@ -343,7 +293,7 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(&self, wrapper: ~fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n+    fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n         let prev_gen_body = replace(&mut self.gen_body, None);\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n@@ -360,18 +310,7 @@ pub impl TaskBuilder {\n             };\n             f\n         };\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            gen_body: Some(next_gen_body),\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+        self.gen_body = Some(next_gen_body);\n     }\n \n     /**\n@@ -386,7 +325,7 @@ pub impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(&self, f: ~fn()) {\n+    fn spawn(&mut self, f: ~fn()) {\n         let gen_body = replace(&mut self.gen_body, None);\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n@@ -406,8 +345,9 @@ pub impl TaskBuilder {\n         };\n         spawn::spawn_raw(opts, f);\n     }\n+\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A:Owned>(&self, arg: A, f: ~fn(v: A)) {\n+    fn spawn_with<A:Owned>(&mut self, arg: A, f: ~fn(v: A)) {\n         let arg = Cell(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -427,16 +367,16 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T:Owned>(&self, f: ~fn() -> T) -> Result<T,()> {\n+    fn try<T:Owned>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n \n-        let fr_task_builder = self.future_result(|+r| {\n-            result = Some(r);\n-        });\n-        do fr_task_builder.spawn || {\n+        self.future_result(|r| { result = Some(r); });\n+\n+        do self.spawn {\n             ch.send(f());\n         }\n+\n         match result.unwrap().recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n@@ -468,26 +408,23 @@ pub fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n+/// Creates and executes a new child task\n+///\n+/// Sets up a new task with its own call stack and schedules it to run\n+/// the provided unique closure.\n+///\n+/// This function is equivalent to `task().spawn(f)`.\n pub fn spawn(f: ~fn()) {\n-    /*!\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure.\n-     *\n-     * This function is equivalent to `task().spawn(f)`.\n-     */\n-\n-    task().spawn(f)\n+    let mut task = task();\n+    task.spawn(f)\n }\n \n+/// Creates a child task unlinked from the current one. If either this\n+/// task or the child task fails, the other will not be killed.\n pub fn spawn_unlinked(f: ~fn()) {\n-    /*!\n-     * Creates a child task unlinked from the current one. If either this\n-     * task or the child task fails, the other will not be killed.\n-     */\n-\n-    task().unlinked().spawn(f)\n+    let mut task = task();\n+    task.unlinked();\n+    task.spawn(f)\n }\n \n pub fn spawn_supervised(f: ~fn()) {\n@@ -497,7 +434,9 @@ pub fn spawn_supervised(f: ~fn()) {\n      * the child will be killed.\n      */\n \n-    task().supervised().spawn(f)\n+    let mut task = task();\n+    task.supervised();\n+    task.spawn(f)\n }\n \n pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n@@ -511,7 +450,8 @@ pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n      * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n-    task().spawn_with(arg, f)\n+    let mut task = task();\n+    task.spawn_with(arg, f)\n }\n \n pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n@@ -527,7 +467,9 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n      * greater than zero.\n      */\n \n-    task().sched_mode(mode).spawn(f)\n+    let mut task = task();\n+    task.sched_mode(mode);\n+    task.spawn(f)\n }\n \n pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n@@ -538,7 +480,9 @@ pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    task().supervised().try(f)\n+    let mut task = task();\n+    task.supervised();\n+    task.try(f)\n }\n \n \n@@ -653,12 +597,13 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n-    let b = task().unlinked();\n-    do b.spawn { }\n+    let mut builder = task();\n+    builder.unlinked();\n+    do builder.spawn {}\n     // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n     // got move mode on self. When 3724 is fixed, this test should fail to\n     // compile instead, and should go in tests/compile-fail.\n-    do b.spawn { } // b should have been consumed by the previous call\n+    do builder.spawn {} // b should have been consumed by the previous call\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -701,43 +646,31 @@ fn test_spawn_unlinked_sup_fail_down() {\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     let (po, _ch) = stream::<()>();\n+\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        opts\n-    };\n+    let mut b0 = task();\n+    b0.opts.linked = true;\n+    b0.opts.supervised = true;\n \n-    let b0 = task();\n-    let b1 = TaskBuilder {\n-        opts: opts,\n-        can_not_copy: None,\n-        .. b0\n-    };\n-    do b1.spawn { fail!(); }\n+    do b0.spawn {\n+        fail!();\n+    }\n     po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        opts\n-    };\n-\n-    let b0 = task();\n-    let b1 = TaskBuilder {\n-        opts: opts,\n-        can_not_copy: None,\n-        .. b0\n-    };\n-    do b1.spawn { loop { task::yield(); } }\n+    let mut b0 = task();\n+    b0.opts.linked = true;\n+    b0.opts.supervised = true;\n+    do b0.spawn {\n+        loop {\n+            task::yield();\n+        }\n+    }\n     fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -756,7 +689,13 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     // Make sure the above test is the same as this one.\n-    do task().linked().spawn { loop { task::yield(); } }\n+    let mut builder = task();\n+    builder.linked();\n+    do builder.spawn {\n+        loop {\n+            task::yield();\n+        }\n+    }\n     fail!();\n }\n \n@@ -814,53 +753,60 @@ fn test_spawn_linked_sup_propagate_sibling() {\n #[test]\n fn test_run_basic() {\n     let (po, ch) = stream::<()>();\n-    do task().spawn {\n+    let mut builder = task();\n+    do builder.spawn {\n         ch.send(());\n     }\n     po.recv();\n }\n \n #[cfg(test)]\n struct Wrapper {\n-    mut f: Option<Chan<()>>\n+    f: Option<Chan<()>>\n }\n \n #[test]\n fn test_add_wrapper() {\n     let (po, ch) = stream::<()>();\n-    let b0 = task();\n-    let ch = Wrapper { f: Some(ch) };\n-    let b1 = do b0.add_wrapper |body| {\n-        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n+    let mut b0 = task();\n+    let ch = Cell(ch);\n+    do b0.add_wrapper |body| {\n+        let ch = Cell(ch.take());\n         let result: ~fn() = || {\n-            let ch = ch.f.swap_unwrap();\n+            let mut ch = ch.take();\n             body();\n             ch.send(());\n         };\n         result\n     };\n-    do b1.spawn { }\n+    do b0.spawn { }\n     po.recv();\n }\n \n #[test]\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|+r| { result = Some(r); }).spawn { }\n+    let mut builder = task();\n+    builder.future_result(|r| result = Some(r));\n+    do builder.spawn {}\n     assert!(result.unwrap().recv() == Success);\n \n     result = None;\n-    do task().future_result(|+r|\n-        { result = Some(r); }).unlinked().spawn {\n+    let mut builder = task();\n+    builder.future_result(|r| result = Some(r));\n+    builder.unlinked();\n+    do builder.spawn {\n         fail!();\n     }\n     assert!(result.unwrap().recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_back_to_the_future_result() {\n-    let _ = task().future_result(util::ignore).future_result(util::ignore);\n+    let mut builder = task();\n+    builder.future_result(util::ignore);\n+    builder.future_result(util::ignore);\n }\n \n #[test]\n@@ -922,12 +868,12 @@ fn test_spawn_sched_childs_on_default_sched() {\n     // Assuming tests run on the default scheduler\n     let default_id = unsafe { rt::rust_get_sched_id() };\n \n-    let ch = Wrapper { f: Some(ch) };\n+    let ch = Cell(ch);\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n-        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n+        let ch = Cell(ch.take());\n         do spawn {\n-            let ch = ch.f.swap_unwrap();\n+            let ch = ch.take();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n             assert!(parent_sched_id != child_sched_id);\n             assert!(child_sched_id == default_id);\n@@ -1035,7 +981,8 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn || {\n+        let mut builder = task();\n+        do builder.spawn || {\n             f();\n         }\n     }\n@@ -1062,7 +1009,9 @@ fn test_avoid_copying_the_body_unlinked() {\n #[test]\n fn test_platform_thread() {\n     let (po, ch) = stream();\n-    do task().sched_mode(PlatformThread).spawn {\n+    let mut builder = task();\n+    builder.sched_mode(PlatformThread);\n+    do builder.spawn {\n         ch.send(());\n     }\n     po.recv();"}, {"sha": "19c417dfdfc950f66fd31c893287e57ee3e90791", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 69, "deletions": 43, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -72,6 +72,7 @@\n \n #[doc(hidden)]; // FIXME #3538\n \n+use cast::transmute;\n use cast;\n use cell::Cell;\n use container::Map;\n@@ -117,10 +118,10 @@ pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n struct TaskGroupData {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n-    mut members:     TaskSet,\n+    members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n-    mut descendants: TaskSet,\n+    descendants: TaskSet,\n }\n type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n \n@@ -145,11 +146,11 @@ struct AncestorNode {\n     // Hence we assert that this counter monotonically decreases as we\n     // approach the tail of the list.\n     // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n-    generation:       uint,\n-    // Should really be an immutable non-option. This way appeases borrowck.\n-    mut parent_group: Option<TaskGroupArc>,\n+    generation:     uint,\n+    // Should really be a non-option. This way appeases borrowck.\n+    parent_group:   Option<TaskGroupArc>,\n     // Recursive rest of the list.\n-    mut ancestors:    AncestorList,\n+    ancestors:      AncestorList,\n }\n \n struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n@@ -301,22 +302,26 @@ fn each_ancestor(list:        &mut AncestorList,\n \n // One of these per task.\n struct TCB {\n-    me:            *rust_task,\n+    me:         *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n-    tasks:         TaskGroupArc, // 'none' means the group has failed.\n+    tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    mut ancestors: AncestorList,\n-    is_main:       bool,\n-    notifier:      Option<AutoNotify>,\n+    ancestors:  AncestorList,\n+    is_main:    bool,\n+    notifier:   Option<AutoNotify>,\n }\n \n impl Drop for TCB {\n     // Runs on task exit.\n     fn finalize(&self) {\n         unsafe {\n+            let this: &mut TCB = transmute(self);\n+\n             // If we are failing, the whole taskgroup needs to die.\n             if rt::rust_task_is_unwinding(self.me) {\n-                for self.notifier.each |x| { x.failed = true; }\n+                for this.notifier.each_mut |x| {\n+                    x.failed = true;\n+                }\n                 // Take everybody down with us.\n                 do access_group(&self.tasks) |tg| {\n                     kill_taskgroup(tg, self.me, self.is_main);\n@@ -331,16 +336,21 @@ impl Drop for TCB {\n             // with our own taskgroup, so long as both happen before we die.\n             // We remove ourself from every ancestor we can, so no cleanup; no\n             // break.\n-            for each_ancestor(&mut self.ancestors, None) |ancestor_group| {\n+            for each_ancestor(&mut this.ancestors, None) |ancestor_group| {\n                 leave_taskgroup(ancestor_group, self.me, false);\n             };\n         }\n     }\n }\n \n-fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n-       is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n-    for notifier.each |x| { x.failed = false; }\n+fn TCB(me: *rust_task,\n+       tasks: TaskGroupArc,\n+       ancestors: AncestorList,\n+       is_main: bool,\n+       mut notifier: Option<AutoNotify>) -> TCB {\n+    for notifier.each_mut |x| {\n+        x.failed = false;\n+    }\n \n     TCB {\n         me: me,\n@@ -353,7 +363,7 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n \n struct AutoNotify {\n     notify_chan: Chan<TaskResult>,\n-    mut failed:  bool,\n+    failed: bool,\n }\n \n impl Drop for AutoNotify {\n@@ -375,9 +385,12 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = newstate.unwrap();\n-        taskset_insert(if is_member { &mut group.members }\n-                       else         { &mut group.descendants }, me);\n+        let mut group = newstate.unwrap();\n+        taskset_insert(if is_member {\n+            &mut group.members\n+        } else {\n+            &mut group.descendants\n+        }, me);\n         *state = Some(group);\n         true\n     } else {\n@@ -391,9 +404,12 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = newstate.unwrap();\n-        taskset_remove(if is_member { &mut group.members }\n-                       else         { &mut group.descendants }, me);\n+        let mut group = newstate.unwrap();\n+        taskset_remove(if is_member {\n+            &mut group.members\n+        } else {\n+            &mut group.descendants\n+        }, me);\n         *state = Some(group);\n     }\n }\n@@ -451,23 +467,30 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         /*##################################################################*\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n-        let spawner_group = match local_get(OldHandle(spawner), taskgroup_key!()) {\n-            None => {\n-                // Main task, doing first spawn ever. Lazily initialise here.\n-                let mut members = new_taskset();\n-                taskset_insert(&mut members, spawner);\n-                let tasks = unstable::exclusive(Some(TaskGroupData {\n-                    members: members,\n-                    descendants: new_taskset(),\n-                }));\n-                // Main task/group has no ancestors, no notifier, etc.\n-                let group =\n-                    @TCB(spawner, tasks, AncestorList(None), true, None);\n-                local_set(OldHandle(spawner), taskgroup_key!(), group);\n-                group\n-            }\n-            Some(group) => group\n-        };\n+        let mut spawner_group: @@mut TCB =\n+            match local_get(OldHandle(spawner), taskgroup_key!()) {\n+                None => {\n+                    // Main task, doing first spawn ever. Lazily initialise\n+                    // here.\n+                    let mut members = new_taskset();\n+                    taskset_insert(&mut members, spawner);\n+                    let tasks = unstable::exclusive(Some(TaskGroupData {\n+                        members: members,\n+                        descendants: new_taskset(),\n+                    }));\n+                    // Main task/group has no ancestors, no notifier, etc.\n+                    let group = @@mut TCB(spawner,\n+                                          tasks,\n+                                          AncestorList(None),\n+                                          true,\n+                                          None);\n+                    local_set(OldHandle(spawner), taskgroup_key!(), group);\n+                    group\n+                }\n+                Some(group) => group\n+            };\n+        let spawner_group: &mut TCB = *spawner_group;\n+\n         /*##################################################################*\n          * Step 2. Process spawn options for child.\n          *##################################################################*/\n@@ -557,7 +580,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     sched.schedule_new_task(task);\n }\n \n-fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n+fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n@@ -624,8 +647,11 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n             };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @TCB(child, child_arc, ancestors,\n-                                 is_main, notifier);\n+                let group = @@mut TCB(child,\n+                                      child_arc,\n+                                      ancestors,\n+                                      is_main,\n+                                      notifier);\n                 unsafe {\n                     local_set(OldHandle(child), taskgroup_key!(), group);\n                 }"}, {"sha": "7f42507bfd5f46b293dc8c8c6d17d8d3f6750e1c", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -235,17 +235,30 @@ pub impl LittleLock {\n     }\n }\n \n-struct ExData<T> { lock: LittleLock, failed: bool, data: T, }\n+struct ExData<T> {\n+    lock: LittleLock,\n+    failed: bool,\n+    data: T,\n+}\n+\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n+pub struct Exclusive<T> {\n+    x: SharedMutableState<ExData<T>>\n+}\n \n pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), failed: false, data: user_data\n+        lock: LittleLock(),\n+        failed: false,\n+        data: user_data\n     };\n-    Exclusive { x: unsafe { shared_mutable_state(data) } }\n+    Exclusive {\n+        x: unsafe {\n+            shared_mutable_state(data)\n+        }\n+    }\n }\n \n impl<T:Owned> Clone for Exclusive<T> {"}, {"sha": "39c930d415f1c38300bb0eb6fd6748fa746954d7", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -62,14 +62,17 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     // give us ownership of the array of functions\n     let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n     // Let's not make any promises about execution order\n-    rand::rng().shuffle_mut(exit_fns_vec);\n+    let mut rng = rand::rng();\n+    rng.shuffle_mut(exit_fns_vec);\n \n     debug!(\"running %u exit functions\", exit_fns_vec.len());\n \n     while !exit_fns_vec.is_empty() {\n         match exit_fns_vec.pop() {\n             ~f => {\n-                task::task().supervised().spawn(f);\n+                let mut task = task::task();\n+                task.supervised();\n+                task.spawn(f);\n             }\n         }\n     }"}, {"sha": "363dbb84c1c3e326abf14d821d30e33a0c162d91", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -34,8 +34,8 @@ pub extern \"rust-intrinsic\" {\n \n     pub fn size_of<T>() -> uint;\n \n-    pub fn move_val<T>(dst: &mut T, +src: T);\n-    pub fn move_val_init<T>(dst: &mut T, +src: T);\n+    pub fn move_val<T>(dst: &mut T, src: T);\n+    pub fn move_val_init<T>(dst: &mut T, src: T);\n \n     pub fn min_align_of<T>() -> uint;\n     pub fn pref_align_of<T>() -> uint;"}, {"sha": "8670bcfcd9a056f1c2f56b08666b9079d6514917", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -72,7 +72,9 @@ fn create_global_service() -> ~WeakTaskService {\n     let chan = SharedChan::new(chan);\n     let chan_clone = chan.clone();\n \n-    do task().unlinked().spawn {\n+    let mut task = task();\n+    task.unlinked();\n+    do task.spawn {\n         debug!(\"running global weak task service\");\n         let port = Cell(port.take());\n         do (|| {\n@@ -189,12 +191,14 @@ fn test_select_stream_and_oneshot() {\n     use comm::select2i;\n     use either::{Left, Right};\n \n-    let (port, chan) = stream();\n+    let mut (port, chan) = stream();\n+    let port = Cell(port);\n     let (waitport, waitchan) = stream();\n     do spawn {\n         unsafe {\n-            do weaken_task |signal| {\n-                match select2i(&port, &signal) {\n+            do weaken_task |mut signal| {\n+                let mut port = port.take();\n+                match select2i(&mut port, &mut signal) {\n                     Left(*) => (),\n                     Right(*) => fail!()\n                 }"}, {"sha": "36acbdf4b56193a20fdd49f4cea61b8d0c4bde4d", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -42,13 +42,13 @@ pub mod rustrt {\n         // These names are terrible. reserve_shared applies\n         // to ~[] and reserve_shared_actual applies to @[].\n         #[fast_ffi]\n-        unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n-                                     ++v: **raw::VecRepr,\n-                                     ++n: libc::size_t);\n+        unsafe fn vec_reserve_shared(t: *sys::TypeDesc,\n+                                     v: **raw::VecRepr,\n+                                     n: libc::size_t);\n         #[fast_ffi]\n-        unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                            ++v: **raw::VecRepr,\n-                                            ++n: libc::size_t);\n+        unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n+                                            v: **raw::VecRepr,\n+                                            n: libc::size_t);\n     }\n }\n "}, {"sha": "33e970c305adcb3545be99b5a70af13c05c3e65d", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -263,7 +263,7 @@ pub fn under(n: uint, it: &fn(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-pub fn as_str(f: @fn(+x: @io::Writer)) -> ~str {\n+pub fn as_str(f: @fn(x: @io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n "}, {"sha": "3b5c90ec1f964eb98cba4dd41825e69d299fd33a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -22,9 +22,9 @@ use util::ppaux;\n \n use core::hash::Streaming;\n use core::hash;\n-use core::io::WriterUtil;\n use core::libc::{c_int, c_uint};\n use core::os::consts::{macos, freebsd, linux, android, win32};\n+use core::rt::io::Writer;\n use core::run;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n@@ -41,6 +41,11 @@ pub enum output_type {\n     output_type_exe,\n }\n \n+fn write_string<W:Writer>(writer: &mut W, string: &str) {\n+    let buffer = str::as_bytes_slice(string);\n+    writer.write(buffer);\n+}\n+\n pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n@@ -458,9 +463,11 @@ pub mod write {\n  *\n  */\n \n-pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n-                   symbol_hasher: &hash::State) -> LinkMeta {\n-\n+pub fn build_link_meta(sess: Session,\n+                       c: &ast::crate,\n+                       output: &Path,\n+                       symbol_hasher: &mut hash::State)\n+                       -> LinkMeta {\n     struct ProvidedMetas {\n         name: Option<@str>,\n         vers: Option<@str>,\n@@ -498,7 +505,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n+    fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::meta_item],\n                               dep_hashes: ~[~str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n@@ -511,17 +518,17 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n \n         let cmh_items = attr::sort_meta_items(cmh_items);\n \n-        fn hash(symbol_hasher: &hash::State, m: &@ast::meta_item) {\n+        fn hash(symbol_hasher: &mut hash::State, m: &@ast::meta_item) {\n             match m.node {\n               ast::meta_name_value(key, value) => {\n-                symbol_hasher.write_str(len_and_str(*key));\n-                symbol_hasher.write_str(len_and_str_lit(value));\n+                write_string(symbol_hasher, len_and_str(*key));\n+                write_string(symbol_hasher, len_and_str_lit(value));\n               }\n               ast::meta_word(name) => {\n-                symbol_hasher.write_str(len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(*name));\n               }\n               ast::meta_list(name, ref mis) => {\n-                symbol_hasher.write_str(len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(*name));\n                 for mis.each |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n@@ -535,7 +542,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n         }\n \n         for dep_hashes.each |dh| {\n-            symbol_hasher.write_str(len_and_str(*dh));\n+            write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n     // tjc: allocation is unfortunate; need to change core::hash\n@@ -596,23 +603,26 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     }\n }\n \n-pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n+pub fn truncated_hash_result(symbol_hasher: &mut hash::State) -> ~str {\n     symbol_hasher.result_str()\n }\n \n \n // This calculates STH for a symbol, as defined above\n-pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n-               link_meta: LinkMeta) -> @str {\n+pub fn symbol_hash(tcx: ty::ctxt,\n+                   symbol_hasher: &mut hash::State,\n+                   t: ty::t,\n+                   link_meta: LinkMeta)\n+                   -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.write_str(link_meta.name);\n-    symbol_hasher.write_str(~\"-\");\n-    symbol_hasher.write_str(link_meta.extras_hash);\n-    symbol_hasher.write_str(~\"-\");\n-    symbol_hasher.write_str(encoder::encoded_ty(tcx, t));\n+    write_string(symbol_hasher, link_meta.name);\n+    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, link_meta.extras_hash);\n+    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n     str::unshift_char(&mut hash, '_');"}, {"sha": "4d2ea4eb4a642c7943be4e95393f3028996eb528", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -34,9 +34,9 @@ pub fn declare_upcalls(targ_cfg: @session::config,\n     fn nothrow(f: ValueRef) -> ValueRef {\n         base::set_no_unwind(f); f\n     }\n-    let d: &fn(+a: ~str, +b: ~[TypeRef], +c: TypeRef) -> ValueRef =\n+    let d: &fn(a: ~str, b: ~[TypeRef], c: TypeRef) -> ValueRef =\n         |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n-    let dv: &fn(+a: ~str, +b: ~[TypeRef]) -> ValueRef =\n+    let dv: &fn(a: ~str, b: ~[TypeRef]) -> ValueRef =\n         |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n \n     let int_t = T_int(targ_cfg);"}, {"sha": "ece53451ccf80232463cc8a04c66fa55bd08e978", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -132,7 +132,7 @@ pub mod intrinsic {\n         #[abi = \"rust-intrinsic\"]\n         pub extern \"rust-intrinsic\" {\n             pub fn get_tydesc<T>() -> *();\n-            pub fn visit_tydesc(++td: *TyDesc, ++tv: @TyVisitor);\n+            pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n         }\n     }\n }"}, {"sha": "36d5a8e3cfe9ef315055831e612745a1896ed00d", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1561,12 +1561,18 @@ pub mod llvm {\n                                        Name: *c_char) -> ValueRef;\n \n         /* Atomic Operations */\n-        pub unsafe fn LLVMBuildAtomicCmpXchg(B: BuilderRef, LHS: ValueRef,\n-                                  CMP: ValueRef, RHS: ValueRef,\n-                                  ++Order: AtomicOrdering) -> ValueRef;\n-        pub unsafe fn LLVMBuildAtomicRMW(B: BuilderRef, ++Op: AtomicBinOp,\n-                              LHS: ValueRef, RHS: ValueRef,\n-                              ++Order: AtomicOrdering) -> ValueRef;\n+        pub unsafe fn LLVMBuildAtomicCmpXchg(B: BuilderRef,\n+                                             LHS: ValueRef,\n+                                             CMP: ValueRef,\n+                                             RHS: ValueRef,\n+                                             Order: AtomicOrdering)\n+                                             -> ValueRef;\n+        pub unsafe fn LLVMBuildAtomicRMW(B: BuilderRef,\n+                                         Op: AtomicBinOp,\n+                                         LHS: ValueRef,\n+                                         RHS: ValueRef,\n+                                         Order: AtomicOrdering)\n+                                         -> ValueRef;\n \n         /* Selected entries from the downcasts. */\n         #[fast_ffi]"}, {"sha": "fd35a4425d87017214e10b41af7e34ab2a3717e5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -204,18 +204,6 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n     }\n }\n \n-fn field_mutability(d: ebml::Doc) -> ast::struct_mutability {\n-    // Use maybe_get_doc in case it's a method\n-    reader::maybe_get_doc(d, tag_struct_mut).map_default(\n-        ast::struct_immutable,\n-        |d| {\n-            match reader::doc_as_u8(*d) as char {\n-              'm' => ast::struct_mutable,\n-              _   => ast::struct_immutable\n-            }\n-        })\n-}\n-\n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n         int::parse_bytes(reader::doc_data(val_doc), 10u)\n@@ -923,12 +911,10 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n         if f == PublicField || f == PrivateField || f == InheritedField {\n             let name = item_name(intr, an_item);\n             let did = item_def_id(an_item, cdata);\n-            let mt = field_mutability(an_item);\n             result.push(ty::field_ty {\n                 ident: name,\n                 id: did, vis:\n                 struct_field_family_to_visibility(f),\n-                mutability: mt,\n             });\n         }\n     }\n@@ -938,7 +924,6 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n             ident: special_idents::unnamed_field,\n             id: did,\n             vis: ast::inherited,\n-            mutability: ast::struct_immutable,\n         });\n     }\n     result"}, {"sha": "87ccd1e45b6f9855ccfcfda19291e863b0bc724e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -119,16 +119,6 @@ fn encode_region_param(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_mutability(ebml_w: &mut writer::Encoder, mt: struct_mutability) {\n-    ebml_w.start_tag(tag_struct_mut);\n-    let val = match mt {\n-      struct_immutable => 'a',\n-      struct_mutable => 'm'\n-    };\n-    ebml_w.writer.write(&[val as u8]);\n-    ebml_w.end_tag();\n-}\n-\n struct entry<T> {\n     val: T,\n     pos: uint\n@@ -518,13 +508,9 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n     for fields.each |field| {\n-        let (nm, mt, vis) = match field.node.kind {\n-            named_field(nm, mt, vis) => (nm, mt, vis),\n-            unnamed_field => (\n-                special_idents::unnamed_field,\n-                struct_immutable,\n-                inherited\n-            )\n+        let (nm, vis) = match field.node.kind {\n+            named_field(nm, vis) => (nm, vis),\n+            unnamed_field => (special_idents::unnamed_field, inherited)\n         };\n \n         let id = field.node.id;\n@@ -537,7 +523,6 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n         encode_name(ecx, ebml_w, nm);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-        encode_mutability(ebml_w, mt);\n         encode_def_id(ebml_w, local_def(id));\n         ebml_w.end_tag();\n     }\n@@ -828,7 +813,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n         needs to know*/\n         for struct_def.fields.each |f| {\n             match f.node.kind {\n-                named_field(ident, _, vis) => {\n+                named_field(ident, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n                    encode_struct_field_family(ebml_w, vis);\n                    encode_name(ecx, ebml_w, ident);\n@@ -1372,41 +1357,40 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n-    let mut i = wr.pos;\n+    let mut i = *wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = wr.pos - i;\n+    ecx.stats.attr_bytes = *wr.pos - i;\n \n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = wr.pos - i;\n+    ecx.stats.dep_bytes = *wr.pos - i;\n \n     // Encode the language items.\n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_lang_items(ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = wr.pos - i;\n+    ecx.stats.lang_item_bytes = *wr.pos - i;\n \n     // Encode the link args.\n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_link_args(ecx, &mut ebml_w);\n-    ecx.stats.link_args_bytes = wr.pos - i;\n+    ecx.stats.link_args_bytes = *wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = wr.pos;\n+    i = *wr.pos;\n     let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = wr.pos - i;\n+    ecx.stats.item_bytes = *wr.pos - i;\n \n-    i = wr.pos;\n+    i = *wr.pos;\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_int);\n-    ecx.stats.index_bytes = wr.pos - i;\n+    ecx.stats.index_bytes = *wr.pos - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = wr.pos;\n+    ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-\n         do wr.bytes.each |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n@@ -1438,9 +1422,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     //\n     //   vec::from_slice(metadata_encoding_version) +\n \n+    let writer_bytes: &mut ~[u8] = wr.bytes;\n+\n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8).to_vec()\n-    }) + flate::deflate_bytes(wr.bytes)\n+    }) + flate::deflate_bytes(*writer_bytes)\n }\n \n // Get the encoded string for a type"}, {"sha": "c223ff821c268c514ce115dce4d9afe2239972db", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1237,7 +1237,7 @@ fn test_simplification() {\n     let ext_cx = mk_ctxt();\n     let item_in = ast::ii_item(quote_item!(\n         fn new_int_alist<B:Copy>() -> alist<int, B> {\n-            fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+            fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());"}, {"sha": "b3bd60d8ac7be80f8bd67a7e3af0138e63bdf40b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -56,7 +56,6 @@ pub enum lint {\n     non_camel_case_types,\n     type_limits,\n     default_methods,\n-    deprecated_mutable_fields,\n     unused_unsafe,\n \n     managed_heap_memory,\n@@ -197,13 +196,6 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: deny\n      }),\n \n-    (\"deprecated_mutable_fields\",\n-     LintSpec {\n-        lint: deprecated_mutable_fields,\n-        desc: \"deprecated mutable fields in structures\",\n-        default: deny\n-    }),\n-\n     (\"unused_unsafe\",\n      LintSpec {\n         lint: unused_unsafe,\n@@ -455,7 +447,6 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_heap(cx, i);\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n-    check_item_deprecated_mutable_fields(cx, i);\n     check_item_unused_unsafe(cx, i);\n     check_item_unused_mut(cx, i);\n }\n@@ -640,28 +631,7 @@ fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n-fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n-    match item.node {\n-        ast::item_struct(struct_def, _) => {\n-            for struct_def.fields.each |field| {\n-                match field.node.kind {\n-                    ast::named_field(_, ast::struct_mutable, _) => {\n-                        cx.sess.span_lint(deprecated_mutable_fields,\n-                                          item.id,\n-                                          item.id,\n-                                          field.span,\n-                                          \"mutable fields are deprecated\");\n-                    }\n-                    ast::named_field(*) | ast::unnamed_field => {}\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n-\n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                         decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );"}, {"sha": "26992388b29d385b4acbc0bf41dc20b663f66cfa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -581,17 +581,7 @@ pub impl mem_categorization_ctxt {\n                              f_name: ast::ident,\n                              f_ty: ty::t,\n                              field_id: ast::node_id) -> cmt {\n-        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty,\n-                                        f_name, field_id) {\n-            Some(f_mutbl) => f_mutbl,\n-            None => {\n-                self.tcx.sess.span_bug(\n-                    node.span(),\n-                    fmt!(\"Cannot find field `%s` in type `%s`\",\n-                         *self.tcx.sess.str_of(f_name),\n-                         ty_to_str(self.tcx, base_cmt.ty)));\n-            }\n-        };\n+        let f_mutbl = m_imm;\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n         let f_interior = interior_field(f_name, f_mutbl);\n         @cmt_ {\n@@ -968,11 +958,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_struct(did, _) => {\n         for ty::lookup_struct_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {\n-                let m = match fld.mutability {\n-                  ast::struct_mutable => ast::m_mutbl,\n-                  ast::struct_immutable => ast::m_imm\n-                };\n-                return Some(m);\n+                return Some(ast::m_imm);\n             }\n         }\n       }\n@@ -981,11 +967,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {\n-                    let m = match fld.mutability {\n-                      ast::struct_mutable => ast::m_mutbl,\n-                      ast::struct_immutable => ast::m_imm\n-                    };\n-                    return Some(m);\n+                    return Some(ast::m_imm);\n                 }\n             }\n           }"}, {"sha": "76d35527104d5a2326dfacf36efe2ab6543298d1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -894,17 +894,7 @@ pub fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n         cx: @mut DetermineRpCtxt,\n         visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    match cm.node.kind {\n-      ast::named_field(_, ast::struct_mutable, _) => {\n-        do cx.with_ambient_variance(rv_invariant) {\n-            visit::visit_struct_field(cm, cx, visitor);\n-        }\n-      }\n-      ast::named_field(_, ast::struct_immutable, _) |\n-      ast::unnamed_field => {\n-        visit::visit_struct_field(cm, cx, visitor);\n-      }\n-    }\n+    visit::visit_struct_field(cm, cx, visitor);\n }\n \n pub fn determine_rp_in_crate(sess: Session,"}, {"sha": "ff002afd028f52b208f49c444dcbcf5d499e5eae", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -4667,7 +4667,7 @@ pub impl Resolver {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n-                          named_field(ident, _, _) => {\n+                          named_field(ident, _) => {\n                               if str::eq_slice(*this.session.str_of(ident),\n                                                name) {\n                                 return true"}, {"sha": "484f66ae9921b42843417b1c49aea4a0bcfd8867", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -4718,7 +4718,7 @@ pub impl Resolver {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n-                          named_field(ident, _, _) => {\n+                          named_field(ident, _) => {\n                               if str::eq_slice(*this.session.str_of(ident),\n                                                name) {\n                                 return true"}, {"sha": "76ad7d7405365ea0e2b9d33007b87c028eebea12", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -2987,9 +2987,8 @@ pub fn trans_crate(sess: session::Session,\n                    emap2: resolve::ExportMap2,\n                    maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n-    let symbol_hasher = @hash::default_state();\n-    let link_meta =\n-        link::build_link_meta(sess, crate, output, symbol_hasher);\n+    let symbol_hasher = @mut hash::default_state();\n+    let link_meta = link::build_link_meta(sess, crate, output, symbol_hasher);\n     let reachable = reachable::find_reachable(\n         &crate.node.module,\n         emap2,"}, {"sha": "c1309b422880affbd1a2406e013fd358541dcc81", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -207,7 +207,7 @@ pub struct CrateContext {\n      adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n-     symbol_hasher: @hash::State,\n+     symbol_hasher: @mut hash::State,\n      type_hashcodes: @mut HashMap<ty::t, @str>,\n      type_short_names: @mut HashMap<ty::t, ~str>,\n      all_llvm_symbols: @mut HashSet<@~str>,"}, {"sha": "5f9dc277c51a3362c69399314de89c2cb00eb094", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -120,14 +120,14 @@ lvalues are *never* stored by value.\n */\n \n use back::abi;\n-use lib;\n use lib::llvm::{ValueRef, TypeRef, llvm};\n+use lib;\n use metadata::csearch;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n-use middle::trans::base;\n use middle::trans::base::*;\n+use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::callee::DoAutorefArg;\n use middle::trans::callee;\n@@ -142,8 +142,10 @@ use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::tvec;\n use middle::trans::type_of;\n+use middle::ty::struct_fields;\n+use middle::ty::{AutoDerefRef, AutoAddEnv};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n-use middle::ty::struct_mutable_fields;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n                  AutoDerefRef, AutoAddEnv, AutoUnsafe};\n use util::common::indenter;\n@@ -1107,7 +1109,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          op: &fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n-            op(0, struct_mutable_fields(tcx, did, substs))\n+            op(0, struct_fields(tcx, did, substs))\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -1124,8 +1126,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                         ast::def_variant(enum_id, variant_id) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n-                            op(variant_info.disr_val, struct_mutable_fields(\n-                                tcx, variant_id, substs))\n+                            op(variant_info.disr_val,\n+                               struct_fields(tcx, variant_id, substs))\n                         }\n                         _ => {\n                             tcx.sess.bug(~\"resolve didn't map this expr to a \\"}, {"sha": "3b06f903641d4fe08c1096590c9351dc0f95b0d2", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -496,9 +496,7 @@ pub fn trans_struct_drop(bcx: block,\n         Call(bcx, dtor_addr, args);\n \n         // Drop the fields\n-        let field_tys =\n-            ty::struct_mutable_fields(bcx.tcx(), class_did,\n-                                              substs);\n+        let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n         for vec::eachi(field_tys) |i, fld| {\n             let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);"}, {"sha": "b2938476d35071938f4837d5ec72cb97e2b1d0d8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -106,10 +106,9 @@ pub enum SelfMode {\n }\n \n pub struct field_ty {\n-  ident: ident,\n-  id: def_id,\n-  vis: ast::visibility,\n-  mutability: ast::struct_mutability,\n+    ident: ident,\n+    id: def_id,\n+    vis: ast::visibility,\n }\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -4027,12 +4026,11 @@ pub fn lookup_struct_field(cx: ctxt,\n fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n     do fields.map |field| {\n         match field.node.kind {\n-            named_field(ident, mutability, visibility) => {\n+            named_field(ident, visibility) => {\n                 field_ty {\n                     ident: ident,\n                     id: ast_util::local_def(field.node.id),\n                     vis: visibility,\n-                    mutability: mutability,\n                 }\n             }\n             unnamed_field => {\n@@ -4041,51 +4039,22 @@ fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n                         syntax::parse::token::special_idents::unnamed_field,\n                     id: ast_util::local_def(field.node.id),\n                     vis: ast::public,\n-                    mutability: ast::struct_immutable,\n                 }\n             }\n         }\n     }\n }\n \n-// Return a list of fields corresponding to the struct's items\n-// (as if the struct was a record). trans uses this\n-// Takes a list of substs with which to instantiate field types\n-// Keep in mind that this function reports that all fields are\n-// mutable, regardless of how they were declared. It's meant to\n-// be used in trans.\n-pub fn struct_mutable_fields(cx: ctxt,\n-                             did: ast::def_id,\n-                             substs: &substs)\n-                          -> ~[field] {\n-    struct_item_fields(cx, did, substs, |_mt| m_mutbl)\n-}\n-\n-// Same as struct_mutable_fields, but doesn't change\n-// mutability.\n-pub fn struct_fields(cx: ctxt,\n-                     did: ast::def_id,\n-                     substs: &substs)\n-                  -> ~[field] {\n-    struct_item_fields(cx, did, substs, |mt| match mt {\n-      struct_mutable => m_mutbl,\n-        struct_immutable => m_imm })\n-}\n-\n-\n-fn struct_item_fields(cx:ctxt,\n-                     did: ast::def_id,\n-                     substs: &substs,\n-                     frob_mutability: &fn(struct_mutability) -> mutability)\n-    -> ~[field] {\n+// Returns a list of fields corresponding to the struct's items. trans uses\n+// this. Takes a list of substs with which to instantiate field types.\n+pub fn struct_fields(cx: ctxt, did: ast::def_id, substs: &substs)\n+                     -> ~[field] {\n     do lookup_struct_fields(cx, did).map |f| {\n-       // consider all instance vars mut, because the\n-       // constructor may mutate all vars\n        field {\n-           ident: f.ident,\n+            ident: f.ident,\n             mt: mt {\n                 ty: lookup_field_type(cx, did, f.id, substs),\n-                mutbl: frob_mutability(f.mutability)\n+                mutbl: m_imm\n             }\n         }\n     }"}, {"sha": "34faf6cefa32be04f2fdd36b0f1c6a43fa555f5b", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -22,7 +22,7 @@ use syntax;\n  * there. */\n macro_rules! interner_key (\n     () => (cast::transmute::<(uint, uint),\n-           &fn(+v: @@syntax::parse::token::ident_interner)>((-3 as uint, 0u)))\n+           &fn(v: @@syntax::parse::token::ident_interner)>((-3 as uint, 0u)))\n )\n \n // Hack; rather than thread an interner through everywhere, rely on\n@@ -274,7 +274,7 @@ fn structdoc_from_struct(\n         item: itemdoc,\n         fields: do struct_def.fields.map |field| {\n             match field.node.kind {\n-                ast::named_field(ident, _, _) => to_str(ident),\n+                ast::named_field(ident, _) => to_str(ident),\n                 ast::unnamed_field => ~\"(unnamed)\",\n             }\n         },"}, {"sha": "e56b0fb60cd1241734d9543191908d426a721023", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -26,8 +26,8 @@ pub type Writer = ~fn(v: WriteInstr);\n pub type WriterFactory = ~fn(page: doc::Page) -> Writer;\n \n pub trait WriterUtils {\n-    fn put_str(&self, +str: ~str);\n-    fn put_line(&self, +str: ~str);\n+    fn put_str(&self, str: ~str);\n+    fn put_line(&self, str: ~str);\n     fn put_done(&self);\n }\n \n@@ -230,6 +230,7 @@ pub fn future_writer_factory(\n         let markdown_ch = markdown_ch.clone();\n         do task::spawn || {\n             let (writer, future) = future_writer();\n+            let mut future = future;\n             writer_ch.send(writer);\n             let s = future.get();\n             markdown_ch.send((copy page, s));"}, {"sha": "b80f43a7bbd068fd66ce04e9aff36f63fc5b74ac", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -17,7 +17,7 @@ use time;\n /// A single operation on the document model\n pub struct Pass {\n     name: ~str,\n-    f: @fn(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n+    f: @fn(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc\n }\n \n pub fn run_passes("}, {"sha": "5e43cb4396075856b34d1f8af793439a80f8951f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,6 +11,7 @@\n use core::*;\n use core::cmp::Ord;\n use core::hash::Streaming;\n+use core::rt::io::Writer;\n use rustc::driver::{driver, session};\n use rustc::driver::session::{lib_crate, unknown_crate};\n use rustc::metadata::filesearch;\n@@ -367,9 +368,9 @@ pub fn error(msg: ~str) {\n }\n \n pub fn hash(data: ~str) -> ~str {\n-    let hasher = &hash::default_state();\n-\n-    hasher.write_str(data);\n+    let mut hasher = hash::default_state();\n+    let buffer = str::as_bytes_slice(data);\n+    hasher.write(buffer);\n     hasher.result_str()\n }\n "}, {"sha": "d69839faa64bc9cdb16fe4e781cbd1d6ee5d5d92", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -673,20 +673,25 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = (*arc).clone();\n-            do task::task().future_result(|+r| children.push(r)).spawn\n-                || {\n+            let mut builder = task::task();\n+            builder.future_result(|r| children.push(r));\n+            do builder.spawn {\n                 do arc3.read |num| {\n                     assert!(*num >= 0);\n                 }\n             }\n         }\n \n         // Wait for children to pass their asserts\n-        for vec::each(children) |r| { r.recv(); }\n+        for vec::each(children) |r| {\n+            r.recv();\n+        }\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| { assert!(*num == 10); }\n+        do arc.read |num| {\n+            assert!(*num == 10);\n+        }\n     }\n     #[test]\n     fn test_rw_downgrade() {"}, {"sha": "d6380551da91bcf9492ac107a0ede81ca58ba76a", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -47,7 +47,7 @@ use core::vec;\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n-        fn move_val_init<T>(dst: &mut T, +src: T);\n+        fn move_val_init<T>(dst: &mut T, src: T);\n         fn needs_drop<T>() -> bool;\n     }\n }"}, {"sha": "461fb61ed5665ee9f777498f097f79f89253b135", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1426,7 +1426,7 @@ mod tests {\n \n     #[bench]\n     fn bench_uint_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n             bitv |= (1 << ((r.next() as uint) % uint::bits));\n@@ -1435,7 +1435,7 @@ mod tests {\n \n     #[bench]\n     fn bench_small_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1444,7 +1444,7 @@ mod tests {\n \n     #[bench]\n     fn bench_big_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1453,7 +1453,7 @@ mod tests {\n \n     #[bench]\n     fn bench_big_bitv_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut storage = ~[];\n         storage.grow(bench_bits / uint::bits, &0);\n         let mut bitv = BigBitv::new(storage);\n@@ -1464,7 +1464,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = Bitv::new(bench_bits, false);\n         do b.iter {\n             bitv.set((r.next() as uint) % bench_bits, true);\n@@ -1473,7 +1473,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1482,7 +1482,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_set_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n             bitv.insert((r.next() as uint) % uint::bits);\n@@ -1491,7 +1491,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_set_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n             bitv.insert((r.next() as uint) % bench_bits);"}, {"sha": "20ab2d61ecc0793e632f8f676cd52f462be465d1", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -72,7 +72,7 @@ impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n }\n \n impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n-    fn header(&self) -> *pipes::PacketHeader {\n+    fn header(&mut self) -> *mut pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "5e4f708f52fd4c3e3659f68d33db8a55928da4d4", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -600,11 +600,18 @@ pub mod writer {\n     use core::vec;\n \n     // ebml writing\n+    #[cfg(stage0)]\n     pub struct Encoder {\n         writer: @io::Writer,\n         priv mut size_positions: ~[uint],\n     }\n \n+    #[cfg(not(stage0))]\n+    pub struct Encoder {\n+        writer: @io::Writer,\n+        priv size_positions: ~[uint],\n+    }\n+\n     fn write_sized_vuint(w: @io::Writer, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n@@ -625,9 +632,22 @@ pub mod writer {\n         fail!(fmt!(\"vint to write too big: %?\", n));\n     }\n \n+    #[cfg(stage0)]\n+    pub fn Encoder(w: @io::Writer) -> Encoder {\n+        let size_positions: ~[uint] = ~[];\n+        Encoder {\n+            writer: w,\n+            mut size_positions: size_positions\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n     pub fn Encoder(w: @io::Writer) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n-        Encoder { writer: w, mut size_positions: size_positions }\n+        Encoder {\n+            writer: w,\n+            size_positions: size_positions\n+        }\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header."}, {"sha": "90774d19595abdcb6ef0756e3fc0ac233b841efa", "filename": "src/libstd/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffileinput.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -145,7 +145,7 @@ struct FileInput_ {\n // \"self.fi.\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    priv mut fi: FileInput_\n+    priv fi: @mut FileInput_\n }\n \n impl FileInput {\n@@ -170,7 +170,7 @@ impl FileInput {\n     pub fn from_vec_raw(files: ~[Option<Path>])\n                                          -> FileInput {\n         FileInput{\n-            fi: FileInput_ {\n+            fi: @mut FileInput_ {\n                 files: files,\n                 current_reader: None,\n                 state: FileInputState {"}, {"sha": "0d4ef69a2753b1abc41397b6129920b8588944d1", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -558,9 +558,11 @@ pub mod bytepipes {\n         }\n     }\n \n+    // XXX: Remove `@mut` when this module is ported to the new I/O traits,\n+    // which use `&mut self` properly.\n     pub struct PipeBytePort {\n         port: comm::Port<~[u8]>,\n-        mut buf: ~[u8]\n+        buf: @mut ~[u8]\n     }\n \n     pub struct PipeByteChan {\n@@ -569,13 +571,13 @@ pub mod bytepipes {\n \n     impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            if vec::uniq_len(&const self.buf) >= count {\n-                let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                self.buf = bytes.slice(count, bytes.len()).to_owned();\n+            if vec::uniq_len(&const *self.buf) >= count {\n+                let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n+                *self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n-            } else if vec::uniq_len(&const self.buf) > 0 {\n-                let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n+            } else if vec::uniq_len(&const *self.buf) > 0 {\n+                let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n                 assert!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n                     Some(rest) => {\n@@ -584,11 +586,11 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else if vec::uniq_len(&const self.buf) == 0 {\n+            } else if vec::uniq_len(&const *self.buf) == 0 {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n                         assert!(!buf.is_empty());\n-                        self.buf = buf;\n+                        *self.buf = buf;\n                         return self.try_recv(count);\n                     }\n                     None => return None\n@@ -609,7 +611,7 @@ pub mod bytepipes {\n         fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n                 port: p,\n-                buf: ~[]\n+                buf: @mut ~[]\n             }\n         }\n     }\n@@ -643,7 +645,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy chan.byte_chan.writer.bytes;\n+        let bytes = copy *chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = serial::reader_port(reader);\n@@ -690,7 +692,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy chan.byte_chan.writer.bytes;\n+        let bytes = copy *chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = pod::reader_port(reader);\n@@ -926,7 +928,7 @@ mod test {\n             test_try_recv_none3(pipe_port_loader);\n         }\n \n-        fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\n+        fn test_try_recv_none4<P:BytePort>(loader: PortLoader<P>) {\n             assert!(do task::try || {\n                 static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,"}, {"sha": "37eb1e02a8014e2089c253f49956264978cac0e4", "filename": "src/libstd/future.rs", "status": "modified", "additions": 65, "deletions": 22, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -28,10 +28,17 @@ use core::pipes::recv;\n use core::task;\n \n #[doc = \"The future type\"]\n+#[cfg(stage0)]\n pub struct Future<A> {\n     priv mut state: FutureState<A>,\n }\n \n+#[doc = \"The future type\"]\n+#[cfg(not(stage0))]\n+pub struct Future<A> {\n+    priv state: FutureState<A>,\n+}\n+\n // FIXME(#2829) -- futures should not be copyable, because they close\n // over ~fn's that have pipes and so forth within!\n #[unsafe_destructor]\n@@ -47,33 +54,68 @@ priv enum FutureState<A> {\n \n /// Methods on the `future` type\n pub impl<A:Copy> Future<A> {\n-    fn get(&self) -> A {\n+    fn get(&mut self) -> A {\n         //! Get the value of the future\n         *(self.get_ref())\n     }\n }\n \n pub impl<A> Future<A> {\n+    #[cfg(stage0)]\n     fn get_ref<'a>(&'a self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as\n         * the future.\n         */\n         unsafe {\n-            match self.state {\n-                Forced(ref mut v) => { return cast::transmute(v); }\n-                Evaluating => fail!(~\"Recursive forcing of future!\"),\n-                Pending(_) => {}\n+            {\n+                match self.state {\n+                    Forced(ref mut v) => { return cast::transmute(v); }\n+                    Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                    Pending(_) => {}\n+                }\n             }\n+            {\n+                let mut state = Evaluating;\n+                self.state <-> state;\n+                match state {\n+                    Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                    Pending(f) => {\n+                        self.state = Forced(f());\n+                        cast::transmute(self.get_ref())\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-            let mut state = Evaluating;\n-            self.state <-> state;\n-            match state {\n-                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(f) => {\n-                    self.state = Forced(f());\n-                    self.get_ref()\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a mut self) -> &'a A {\n+        /*!\n+        * Executes the future's closure and then returns a borrowed\n+        * pointer to the result.  The borrowed pointer lasts as long as\n+        * the future.\n+        */\n+        unsafe {\n+            {\n+                match self.state {\n+                    Forced(ref mut v) => { return cast::transmute(v); }\n+                    Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                    Pending(_) => {}\n+                }\n+            }\n+            {\n+                let mut state = Evaluating;\n+                self.state <-> state;\n+                match state {\n+                    Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                    Pending(f) => {\n+                        self.state = Forced(f());\n+                        cast::transmute(self.get_ref())\n+                    }\n                 }\n             }\n         }\n@@ -142,63 +184,64 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n #[allow(non_implicitly_copyable_typarams)]\n #[cfg(test)]\n mod test {\n-\n     use future::*;\n \n+    use core::cell::Cell;\n     use core::comm::{oneshot, send_one};\n     use core::task;\n \n     #[test]\n     fn test_from_value() {\n-        let f = from_value(~\"snail\");\n+        let mut f = from_value(~\"snail\");\n         assert!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n         send_one(ch, ~\"whale\");\n-        let f = from_port(po);\n+        let mut f = from_port(po);\n         assert!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let f = from_fn(|| ~\"brail\");\n+        let mut f = from_fn(|| ~\"brail\");\n         assert!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let f = from_value(~\"fail\");\n+        let mut f = from_value(~\"fail\");\n         assert!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n     fn test_get_ref_method() {\n-        let f = from_value(22);\n+        let mut f = from_value(22);\n         assert!(*f.get_ref() == 22);\n     }\n \n     #[test]\n     fn test_spawn() {\n-        let f = spawn(|| ~\"bale\");\n+        let mut f = spawn(|| ~\"bale\");\n         assert!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     fn test_futurefail() {\n-        let f = spawn(|| fail!());\n+        let mut f = spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n-        let f = do spawn { copy expected };\n-        do task::spawn || {\n+        let f = Cell(do spawn { copy expected });\n+        do task::spawn {\n+            let mut f = f.take();\n             let actual = f.get();\n             assert!(actual == expected);\n         }"}, {"sha": "7d43663cc808b0db971d74a3eaa65e2e0e0b2d7d", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -13,14 +13,14 @@ use core::io;\n \n pub struct BufReader {\n     buf: ~[u8],\n-    mut pos: uint\n+    pos: @mut uint\n }\n \n pub impl BufReader {\n     pub fn new(v: ~[u8]) -> BufReader {\n         BufReader {\n             buf: v,\n-            pos: 0\n+            pos: @mut 0\n         }\n     }\n \n@@ -29,13 +29,13 @@ pub impl BufReader {\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {\n             bytes: ::core::util::id::<&[u8]>(self.buf),\n-            pos: self.pos\n+            pos: @mut *self.pos\n         };\n \n         let res = f(&bytes_reader);\n \n         // FIXME #4429: This isn't correct if f fails\n-        self.pos = bytes_reader.pos;\n+        *self.pos = *bytes_reader.pos;\n \n         return res;\n     }"}, {"sha": "c815c9dd48062fac00c3023e403d5aa3049fec70", "filename": "src/libstd/json.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -220,11 +220,18 @@ impl serialize::Encoder for Encoder {\n     }\n }\n \n+#[cfg(stage0)]\n pub struct PrettyEncoder {\n     priv wr: @io::Writer,\n     priv mut indent: uint,\n }\n \n+#[cfg(not(stage0))]\n+pub struct PrettyEncoder {\n+    priv wr: @io::Writer,\n+    priv indent: uint,\n+}\n+\n pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n     PrettyEncoder {\n         wr: wr,\n@@ -838,10 +845,16 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n     }\n }\n \n+#[cfg(stage0)]\n pub struct Decoder {\n     priv mut stack: ~[Json],\n }\n \n+#[cfg(not(stage0))]\n+pub struct Decoder {\n+    priv stack: ~[Json],\n+}\n+\n pub fn Decoder(json: Json) -> Decoder {\n     Decoder {\n         stack: ~[json]"}, {"sha": "bc4168ba7f8756ab9c98403652acd4b251dff779", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -71,14 +71,14 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n  * satisfy both the `io::Reader` and `io::Writer` traits.\n  */\n pub struct TcpSocketBuf {\n-    data: @TcpBufferedSocketData,\n-    mut end_of_stream: bool\n+    data: @mut TcpBufferedSocketData,\n+    end_of_stream: @mut bool\n }\n \n-pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n+pub fn TcpSocketBuf(data: @mut TcpBufferedSocketData) -> TcpSocketBuf {\n     TcpSocketBuf {\n         data: data,\n-        end_of_stream: false\n+        end_of_stream: @mut false\n     }\n }\n \n@@ -670,7 +670,7 @@ fn listen_common(host_ip: ip::IpAddr,\n             &ip::Ipv4(_) => { false }\n             &ip::Ipv6(_) => { true }\n         },\n-        mut active: true\n+        active: @mut true\n     };\n     let server_data_ptr: *TcpListenFcData = &server_data;\n \n@@ -751,7 +751,7 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\n                         \"tcp::listen post-kill recv hl interact %?\",\n                              loop_ptr);\n-                    (*server_data_ptr).active = false;\n+                    *(*server_data_ptr).active = false;\n                     uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n             };\n@@ -782,7 +782,7 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\n                         \"tcp::listen post-kill recv hl interact %?\",\n                              loop_ptr);\n-                    (*server_data_ptr).active = false;\n+                    *(*server_data_ptr).active = false;\n                     uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n             };\n@@ -816,8 +816,8 @@ fn listen_common(host_ip: ip::IpAddr,\n  * A buffered wrapper that you can cast as an `io::Reader` or `io::Writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@TcpBufferedSocketData {\n-        sock: sock, mut buf: ~[], buf_off: 0\n+    TcpSocketBuf(@mut TcpBufferedSocketData {\n+        sock: sock, buf: ~[], buf_off: 0\n     })\n }\n \n@@ -902,12 +902,15 @@ impl io::Reader for TcpSocketBuf {\n           // need to read in data from the socket. Note that the internal\n           // buffer is of no use anymore as we read all bytes from it,\n           // so we can throw it away.\n-          let read_result = read(&self.data.sock, 0u);\n+          let read_result = {\n+            let data = &*self.data;\n+            read(&data.sock, 0)\n+          };\n           if read_result.is_err() {\n               let err_data = read_result.get_err();\n \n               if err_data.err_name == ~\"EOF\" {\n-                  self.end_of_stream = true;\n+                  *self.end_of_stream = true;\n                   break;\n               } else {\n                   debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n@@ -917,8 +920,7 @@ impl io::Reader for TcpSocketBuf {\n                   // should show up in a later call to read().\n                   break;\n               }\n-          }\n-          else {\n+          } else {\n               self.data.buf = result::unwrap(read_result);\n               self.data.buf_off = 0;\n           }\n@@ -934,27 +936,29 @@ impl io::Reader for TcpSocketBuf {\n             return c as int\n           }\n \n-          let read_result = read(&self.data.sock, 0u);\n+          let read_result = {\n+            let data = &*self.data;\n+            read(&data.sock, 0)\n+          };\n           if read_result.is_err() {\n               let err_data = read_result.get_err();\n \n               if err_data.err_name == ~\"EOF\" {\n-                  self.end_of_stream = true;\n+                  *self.end_of_stream = true;\n                   return -1\n               } else {\n                   debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n                          err_data.err_name, err_data.err_msg);\n                   fail!()\n               }\n-          }\n-          else {\n+          } else {\n               self.data.buf = result::unwrap(read_result);\n               self.data.buf_off = 0;\n           }\n         }\n     }\n     fn eof(&self) -> bool {\n-        self.end_of_stream\n+        *self.end_of_stream\n     }\n     fn seek(&self, dist: int, seek: io::SeekStyle) {\n         debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n@@ -1204,7 +1208,7 @@ struct TcpListenFcData {\n     on_connect_cb: ~fn(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n-    mut active: bool,\n+    active: @mut bool,\n }\n \n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n@@ -1222,15 +1226,15 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n             as *TcpListenFcData;\n         let kill_ch = (*server_data_ptr).kill_ch.clone();\n-        if (*server_data_ptr).active {\n+        if *(*server_data_ptr).active {\n             match status {\n               0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n               _ => {\n                 let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n                 kill_ch.send(\n                            Some(uv::ll::get_last_err_data(loop_ptr)\n                                 .to_tcp_err()));\n-                (*server_data_ptr).active = false;\n+                *(*server_data_ptr).active = false;\n               }\n             }\n         }\n@@ -1430,8 +1434,8 @@ struct TcpSocketData {\n \n struct TcpBufferedSocketData {\n     sock: TcpSocket,\n-    mut buf: ~[u8],\n-    mut buf_off: uint\n+    buf: ~[u8],\n+    buf_off: uint\n }\n \n #[cfg(test)]\n@@ -1959,7 +1963,7 @@ mod test {\n     }\n \n     fn tcp_write_single(sock: &TcpSocket, val: ~[u8]) {\n-        let write_result_future = sock.write_future(val);\n+        let mut write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(&write_result) {\n             debug!(\"tcp_write_single: write failed!\");"}, {"sha": "cf0eba9d30cea1a890cf0fd096f44b1dd4dcb959", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -73,10 +73,10 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n         assert!((num_tasks == futures.len()));\n \n-        let r = do futures.map() |ys| {\n+        let r = do vec::map_consume(futures) |ys| {\n+            let mut ys = ys;\n             ys.get()\n         };\n-        assert!((r.len() == futures.len()));\n         r\n     }\n }"}, {"sha": "9bf7db07ac9dd7032fe42b9674dd628ddfa73df3", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,7 +14,7 @@ use core::old_iter::BaseIter;\n \n #[abi = \"rust-intrinsic\"]\n extern \"rust-intrinsic\" mod rusti {\n-    fn move_val_init<T>(dst: &mut T, +src: T);\n+    fn move_val_init<T>(dst: &mut T, src: T);\n     fn init<T>() -> T;\n }\n "}, {"sha": "6994ca4aedb6d8369c8b8dcd7626f5f969857926", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -946,8 +946,10 @@ mod test_tim_sort {\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            let rng = rand::rng();\n-            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            let mut rng = rand::rng();\n+            if rng.gen::<float>() > 0.995 {\n+                fail!(~\"It's happening!!!\");\n+            }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n@@ -995,7 +997,7 @@ mod test_tim_sort {\n     #[should_fail]\n     #[cfg(unix)]\n     fn crash_test() {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let mut arr = do vec::from_fn(1000) |_i| {\n             CVal { val: rng.gen() }\n         };\n@@ -1015,7 +1017,7 @@ mod test_tim_sort {\n \n     #[test]\n     fn test_bad_Ord_impl() {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let mut arr = do vec::from_fn(500) |_i| {\n             DVal { val: rng.gen() }\n         };\n@@ -1067,7 +1069,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n@@ -1138,7 +1140,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;"}, {"sha": "931974d245485f34047642618178ccd2286ace0d", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -28,7 +28,9 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n-#[allow(deprecated_mutable_fields)];\n+\n+// Allow mutable fields only in stage0.\n+#[warn(deprecated_mutable_fields)];\n \n pub mod uv_ll;\n "}, {"sha": "0c52e1ff80e21145de2d73bb0625d851702e7548", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -70,7 +70,9 @@ pub impl<T> TaskPool<T> {\n                     task::spawn(task_body);\n                 }\n                 Some(sched_mode) => {\n-                    task::task().sched_mode(sched_mode).spawn(task_body);\n+                    let mut task = task::task();\n+                    task.sched_mode(sched_mode);\n+                    task.spawn(task_body);\n                 }\n             }\n "}, {"sha": "e02a7a337334ed98cd1da4b6098da4c1f368c1c1", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -13,7 +13,7 @@\n use core::rand::RngUtil;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n     for 1000.times {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700"}, {"sha": "7d24262aea600412f5ea62a743d372cc53ee9be3", "filename": "src/libstd/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -556,9 +556,12 @@ pub fn run_test(force_ignore: bool,\n         let testfn_cell = ::core::cell::Cell(testfn);\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n-            task::task().unlinked().future_result(|+r| {\n-                result_future = Some(r);\n-            }).spawn(testfn_cell.take());\n+\n+            let mut task = task::task();\n+            task.unlinked();\n+            task.future_result(|r| { result_future = Some(r) });\n+            task.spawn(testfn_cell.take());\n+\n             let task_result = result_future.unwrap().recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n@@ -688,7 +691,7 @@ pub mod bench {\n         // not met, it may run as long as the Go algorithm.\n         pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n \n-            let rng = rand::rng();\n+            let mut rng = rand::rng();\n             let mut magnitude = 10;\n             let mut prev_madp = 0.0;\n "}, {"sha": "0d15bbb54d321785e92fa7816fbd752fae016c48", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,10 +14,11 @@ use uv;\n use uv::iotask;\n use uv::iotask::IoTask;\n \n-use core::libc;\n-use core::libc::c_void;\n use core::cast::transmute;\n+use core::cast;\n use core::comm::{stream, Chan, SharedChan, Port, select2i};\n+use core::libc::c_void;\n+use core::libc;\n \n /**\n  * Wait for timeout period then send provided value over a channel\n@@ -120,22 +121,28 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: &Port<T>)\n-                                -> Option<T> {\n-    let (timeout_po, timeout_ch) = stream::<()>();\n+                                   -> Option<T> {\n+    let mut (timeout_po, timeout_ch) = stream::<()>();\n     delayed_send(iotask, msecs, &timeout_ch, ());\n-    // FIXME: This could be written clearer (#2618)\n-    either::either(\n-        |_| {\n-            None\n-        }, |_| {\n-            Some(wait_po.recv())\n-        }, &select2i(&timeout_po, wait_po)\n-    )\n+\n+    // XXX: Workaround due to ports and channels not being &mut. They should\n+    // be.\n+    unsafe {\n+        let wait_po = cast::transmute_mut(wait_po);\n+\n+        // FIXME: This could be written clearer (#2618)\n+        either::either(\n+            |_| {\n+                None\n+            }, |_| {\n+                Some(wait_po.recv())\n+            }, &select2i(&mut timeout_po, wait_po)\n+        )\n+    }\n }\n \n // INTERNAL API\n-extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n-                                status: libc::c_int) {\n+extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t, status: libc::c_int) {\n     unsafe {\n         debug!(\n             \"delayed_send_cb handle %? status %?\", handle, status);\n@@ -212,7 +219,7 @@ mod test {\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use core::rand::*;\n-                    let rng = rng();\n+                    let mut rng = rng();\n                     for old_iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n@@ -269,7 +276,8 @@ mod test {\n         let hl_loop = uv::global_loop::get();\n \n         for old_iter::repeat(times as uint) {\n-            let expected = rand::rng().gen_str(16u);\n+            let mut rng = rand::rng();\n+            let expected = rng.gen_str(16u);\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {"}, {"sha": "06ac1a71bacd0eedd0a86ec7c9b112e89ba63523", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -848,7 +848,7 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let rng = rand::IsaacRng::new_seeded(&[42]);\n+        let mut rng = rand::IsaacRng::new_seeded(&[42]);\n \n         for 3.times {\n             for 90.times {"}, {"sha": "e1b7eb61505255da7f1ea4f10b1e78bd3b459684", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -62,7 +62,9 @@ fn get_monitor_task_gl() -> IoTask {\n                 }\n             };\n             if installed {\n-                do task().unlinked().spawn() {\n+                let mut task = task();\n+                task.unlinked();\n+                do task.spawn {\n                     unsafe {\n                         debug!(\"global monitor task starting\");\n                         // As a weak task the runtime will notify us\n@@ -88,7 +90,9 @@ fn get_monitor_task_gl() -> IoTask {\n }\n \n fn spawn_loop() -> IoTask {\n-    let builder = do task().add_wrapper |task_body| {\n+    let mut builder = task();\n+\n+    do builder.add_wrapper |task_body| {\n         let result: ~fn() = || {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n@@ -107,7 +111,8 @@ fn spawn_loop() -> IoTask {\n         };\n         result\n     };\n-    let builder = builder.unlinked();\n+\n+    builder.unlinked();\n     spawn_iotask(builder)\n }\n "}, {"sha": "83e95a6e1993ab17a4e7c9e082cd16cd4565e599", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -36,11 +36,11 @@ impl Clone for IoTask {\n     }\n }\n \n-pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n-\n+pub fn spawn_iotask(mut task: task::TaskBuilder) -> IoTask {\n     let (iotask_port, iotask_chan) = stream();\n \n-    do task.sched_mode(task::SingleThreaded).spawn {\n+    task.sched_mode(task::SingleThreaded);\n+    do task.spawn {\n         debug!(\"entering libuv task\");\n         run_loop(&iotask_chan);\n         debug!(\"libuv task exiting\");"}, {"sha": "ad3cfeb4a990d3f52b3798548b4255762b772b1b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -780,31 +780,32 @@ extern mod rustrt {\n     // FIXME ref #2064\n     unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                                   tcp_handle_ptr: *uv_tcp_t,\n-                                  ++after_cb: *u8,\n-                                  ++addr: *sockaddr_in) -> libc::c_int;\n+                                  after_cb: *u8,\n+                                  addr: *sockaddr_in)\n+                                  -> libc::c_int;\n     // FIXME ref #2064\n     unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n-                               ++addr: *sockaddr_in) -> libc::c_int;\n+                               addr: *sockaddr_in) -> libc::c_int;\n     // FIXME ref #2064\n     unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n                                    tcp_handle_ptr: *uv_tcp_t,\n-                                   ++after_cb: *u8,\n-                                   ++addr: *sockaddr_in6) -> libc::c_int;\n+                                   after_cb: *u8,\n+                                   addr: *sockaddr_in6) -> libc::c_int;\n     // FIXME ref #2064\n     unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n-                                ++addr: *sockaddr_in6) -> libc::c_int;\n+                                addr: *sockaddr_in6) -> libc::c_int;\n     unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                                      ++name: *sockaddr_in) -> libc::c_int;\n+                                      name: *sockaddr_in) -> libc::c_int;\n     unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                       ++name: *sockaddr_in6) ->libc::c_int;\n+                                       name: *sockaddr_in6) ->libc::c_int;\n     unsafe fn rust_uv_listen(stream: *libc::c_void,\n                              backlog: libc::c_int,\n                              cb: *u8) -> libc::c_int;\n     unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n                           -> libc::c_int;\n     unsafe fn rust_uv_write(req: *libc::c_void,\n                             stream: *libc::c_void,\n-                            ++buf_in: *uv_buf_t,\n+                            buf_in: *uv_buf_t,\n                             buf_cnt: libc::c_int,\n                             cb: *u8)\n         -> libc::c_int;\n@@ -843,7 +844,7 @@ extern mod rustrt {\n     unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n         -> *sockaddr_in6;\n     unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    unsafe fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    unsafe fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n     unsafe fn rust_uv_get_stream_handle_from_connect_req(\n         connect_req: *uv_connect_t)\n         -> *uv_stream_t;\n@@ -864,8 +865,8 @@ extern mod rustrt {\n         -> *libc::c_void;\n     unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n                                        data: *libc::c_void);\n-    unsafe fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    unsafe fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+    unsafe fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n+    unsafe fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> libc::size_t;\n \n     // sizeof testing helpers\n     unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n@@ -1258,7 +1259,7 @@ mod test {\n \n     extern fn on_read_cb(stream: *uv_stream_t,\n                         nread: libc::ssize_t,\n-                        ++buf: uv_buf_t) {\n+                        buf: uv_buf_t) {\n         unsafe {\n             let nread = nread as int;\n             debug!(\"CLIENT entering on_read_cb nred: %d\",\n@@ -1444,7 +1445,7 @@ mod test {\n \n     extern fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n                                nread: libc::ssize_t,\n-                               ++buf: uv_buf_t) {\n+                               buf: uv_buf_t) {\n         unsafe {\n             let nread = nread as int;\n             if (nread > 0) {"}, {"sha": "c8fc04eaea1a3cd3ac4f2549efa287a991c86ff8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1168,7 +1168,7 @@ pub type struct_field = spanned<struct_field_>;\n #[auto_decode]\n #[deriving(Eq)]\n pub enum struct_field_kind {\n-    named_field(ident, struct_mutability, visibility),\n+    named_field(ident, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n@@ -1218,17 +1218,6 @@ pub enum item_ {\n     item_mac(mac),\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum struct_mutability { struct_mutable, struct_immutable }\n-\n-impl to_bytes::IterBytes for struct_mutability {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n@@ -1289,6 +1278,21 @@ mod test {\n         assert_eq! (s,~[14]);\n     }\n \n+    #[test] fn test_marksof () {\n+        let stopname = uints_to_name(&~[12,14,78]);\n+        assert_eq!(s,~[]);\n+        xorPush(&mut s,14);\n+        assert_eq!(s,~[14]);\n+        xorPush(&mut s,15);\n+        assert_eq!(s,~[14,15]);\n+        xorPush (&mut s,16);\n+        assert_eq! (s,~[14,15,16]);\n+        xorPush (&mut s,16);\n+        assert_eq! (s,~[14,15]);\n+        xorPush (&mut s,15);\n+        assert_eq! (s,~[14]);\n+    }\n+\n     #[test] fn test_marksof () {\n         let stopname = uints_to_name(&~[12,14,78]);\n         let name1 = uints_to_name(&~[4,9,7]);\n@@ -1347,3 +1351,12 @@ mod test {\n }\n \n */\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "7b20d71fdc4094a4e37241dee93aa36f63aaa877", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -285,7 +285,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n \n pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     match field.node.kind {\n-        ast::named_field(_, _, visibility) => visibility,\n+        ast::named_field(_, visibility) => visibility,\n         ast::unnamed_field => ast::public\n     }\n }"}, {"sha": "5bd4f89a3b38bb538cc4441d8d7a663475671ebe", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -914,19 +914,15 @@ struct field {\n \n fn mk_struct_fields(fields: &[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n-        let (ident, mutbl) = match field.node.kind {\n-            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n-            _ => fail!(~\"[auto_encode] does not support \\\n-                        unnamed fields\")\n+        let ident = match field.node.kind {\n+            ast::named_field(ident, _) => ident,\n+            _ => fail!(~\"[auto_encode] does not support unnamed fields\")\n         };\n \n         field {\n             span: field.span,\n             ident: ident,\n-            mutbl: match mutbl {\n-                ast::struct_mutable => ast::m_mutbl,\n-                ast::struct_immutable => ast::m_imm,\n-            },\n+            mutbl: ast::m_imm,\n         }\n     }\n }"}, {"sha": "3097cb799a2044ef223192b499b17569066960e2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,6 +11,7 @@\n use ast;\n use codemap;\n use codemap::span;\n+use fold;\n use ext::base::ext_ctxt;\n use ext::build;\n \n@@ -516,3 +517,20 @@ pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n     mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n }\n+\n+//\n+// Duplication functions\n+//\n+// These functions just duplicate AST nodes.\n+//\n+\n+pub fn duplicate_expr(cx: @ext_ctxt, expr: @ast::expr) -> @ast::expr {\n+    let folder = fold::default_ast_fold();\n+    let folder = @fold::AstFoldFns {\n+        new_id: |_| cx.next_id(),\n+        ..*folder\n+    };\n+    let folder = fold::make_fold(folder);\n+    folder.fold_expr(expr)\n+}\n+"}, {"sha": "2bdfe51c50eabdf822611a05ba37a94dc238c83d", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -280,7 +280,7 @@ fn expand_deriving_decodable_struct_method(\n     let mut fields = ~[];\n     for struct_def.fields.each |struct_field| {\n         match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n+            named_field(ident, _) => {\n                 fields.push(create_read_struct_field(cx, span, i, ident));\n             }\n             unnamed_field => {"}, {"sha": "54e5687f415ab112b7a08a201e041cb72342585e", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -211,7 +211,7 @@ fn expand_deriving_encodable_struct_method(\n     let mut statements = ~[];\n     for struct_def.fields.each |struct_field| {\n         match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n+            named_field(ident, _) => {\n                 // Create the accessor for this field.\n                 let self_field = build::mk_access(\n                     cx,"}, {"sha": "d785f3816de30f0b07794b57882f71e2e89b2661", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -818,12 +818,8 @@ fn summarise_struct(cx: @ext_ctxt, span: span,\n     let mut unnamed_count = 0;\n     for struct_def.fields.each |field| {\n         match field.node.kind {\n-            ast::named_field(ident, _, _) => {\n-                named_idents.push(ident)\n-            }\n-            ast::unnamed_field => {\n-                unnamed_count += 1;\n-            }\n+            ast::named_field(ident, _) => named_idents.push(ident),\n+            ast::unnamed_field => unnamed_count += 1,\n         }\n     }\n "}, {"sha": "3d66506d6ca8ffadb220f0f7bb0c15cee01ccdc7", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -90,4 +90,4 @@ fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) ->\n     }\n \n     build::mk_block(cx, span, ~[], stmts, None)\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2bd45e1466ce735e5f1aaadd7727abd3fcfaed91", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -281,8 +281,8 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n \n     for struct_def.fields.eachi |i, struct_field| {\n         let opt_id = match struct_field.node.kind {\n-            ast::named_field(ident, _, _) if (struct_type == Unknown ||\n-                                              struct_type == Record) => {\n+            ast::named_field(ident, _) if (struct_type == Unknown ||\n+                                           struct_type == Record) => {\n                 struct_type = Record;\n                 Some(ident)\n             }"}, {"sha": "604686f442fd7b073485e516d09b885c4d1cf5f9", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_rand(cx: @ext_ctxt,\n                 self_ty: None,\n                 args: ~[\n                     Ptr(~Literal(Path::new_local(~\"R\")),\n-                        Borrowed(None, ast::m_imm))\n+                        Borrowed(None, ast::m_mutbl))\n                 ],\n                 ret_ty: Self,\n                 const_nonmatching: false,\n@@ -59,8 +59,10 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n         cx.ident_of(~\"rand\")\n     ];\n     let rand_call = || {\n-        build::mk_call_global(cx, span,\n-                              copy rand_ident, copy rng)\n+        build::mk_call_global(cx,\n+                              span,\n+                              copy rand_ident,\n+                              ~[ build::duplicate_expr(cx, rng[0]) ])\n     };\n \n     return match *substr.fields {\n@@ -80,7 +82,10 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n             let rand_name = build::mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n             let rand_name = build::mk_path_raw(cx, span, rand_name);\n \n-            let rv_call = build::mk_call_(cx, span, rand_name, copy rng);\n+            let rv_call = build::mk_call_(cx,\n+                                          span,\n+                                          rand_name,\n+                                          ~[ build::duplicate_expr(cx, rng[0]) ]);\n \n             // rand() % variants.len()\n             let rand_variant = build::mk_binary(cx, span, ast::rem,\n@@ -133,4 +138,4 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "7ac3ea4789d63680ca263ee31c27c5b43626bd6e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -64,6 +64,7 @@ impl gen_send for message {\n \n             let mut body = ~\"{\\n\";\n             body += fmt!(\"use super::%s;\\n\", name);\n+            body += ~\"let mut pipe = pipe;\\n\";\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = match (this.dir, next.dir) {\n@@ -73,12 +74,12 @@ impl gen_send for message {\n                   (recv, recv) => (~\"c\", ~\"s\")\n                 };\n \n-                body += ~\"let b = pipe.reuse_buffer();\\n\";\n+                body += ~\"let mut b = pipe.reuse_buffer();\\n\";\n                 body += fmt!(\"let %s = ::core::pipes::SendPacketBuffered(\\\n-                              &(b.buffer.data.%s));\\n\",\n+                              &mut (b.buffer.data.%s));\\n\",\n                              sp, next.name);\n                 body += fmt!(\"let %s = ::core::pipes::RecvPacketBuffered(\\\n-                              &(b.buffer.data.%s));\\n\",\n+                              &mut (b.buffer.data.%s));\\n\",\n                              rp, next.name);\n             }\n             else {\n@@ -366,7 +367,7 @@ impl gen_init for protocol {\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n                 ext_cx.parse_expr(fmt!(\n-                    \"::core::ptr::to_unsafe_ptr(&(data.%s))\",\n+                    \"::core::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n                     self.states[0].name))));\n \n         quote_expr!({\n@@ -410,10 +411,8 @@ impl gen_init for protocol {\n \n             @spanned {\n                 node: ast::struct_field_ {\n-                    kind: ast::named_field(\n-                            cx.ident_of(s.name),\n-                            ast::struct_immutable,\n-                            ast::inherited),\n+                    kind: ast::named_field(cx.ident_of(s.name),\n+                                           ast::inherited),\n                     id: cx.next_id(),\n                     ty: fty,\n                     attrs: ~[],"}, {"sha": "d181dd87e38d17acb25e612e426ffb796270a4be", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -859,3 +859,4 @@ impl AstFoldExtensions for @ast_fold {\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n+"}, {"sha": "0543295eb4e6dbe1b305e1bf41963507dd3e96f6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -45,7 +45,7 @@ use ast::{pat_tup, pat_uniq, pat_wild, private};\n use ast::{rem, required};\n use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n-use ast::{struct_immutable, struct_mutable, struct_variant_kind, subtract};\n+use ast::{struct_variant_kind, subtract};\n use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n@@ -390,8 +390,8 @@ pub impl Parser {\n     // parse a ty_closure type\n     fn parse_ty_closure(&self,\n                         sigil: ast::Sigil,\n-                        region: Option<@ast::Lifetime>) -> ty_\n-    {\n+                        region: Option<@ast::Lifetime>)\n+                        -> ty_ {\n         /*\n \n         (&|~|@) ['r] [pure|unsafe] [once] fn <'lt> (S) -> T\n@@ -773,20 +773,17 @@ pub impl Parser {\n         return ty_rptr(opt_lifetime, mt);\n     }\n \n-    // parse an optional mode.\n-    // XXX: Remove after snapshot.\n+    // parse an optional, obsolete argument mode.\n     fn parse_arg_mode(&self) {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             self.obsolete(*self.span, ObsoleteMode);\n         } else if self.eat(&token::ANDAND) {\n-            // Ignore.\n+            self.obsolete(*self.span, ObsoleteMode);\n         } else if self.eat(&token::BINOP(token::PLUS)) {\n             if self.eat(&token::BINOP(token::PLUS)) {\n-                // ++ mode is obsolete, but we need a snapshot\n-                // to stop parsing it.\n-                // Ignore.\n+                self.obsolete(*self.span, ObsoleteMode);\n             } else {\n-                // Ignore.\n+                self.obsolete(*self.span, ObsoleteMode);\n             }\n         } else {\n             // Ignore.\n@@ -2528,10 +2525,10 @@ pub impl Parser {\n     fn parse_name_and_ty(&self,\n                          pr: visibility,\n                          attrs: ~[attribute]) -> @struct_field {\n-        let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"mut\") {\n-            is_mutbl = struct_mutable;\n+            // Do nothing, for backwards compatibility.\n+            // XXX: Remove after snapshot.\n         }\n         if !is_plain_ident(&*self.token) {\n             self.fatal(~\"expected ident\");\n@@ -2540,7 +2537,7 @@ pub impl Parser {\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         @spanned(lo, self.last_span.hi, ast::struct_field_ {\n-            kind: named_field(name, is_mutbl, pr),\n+            kind: named_field(name, pr),\n             id: self.get_id(),\n             ty: ty,\n             attrs: attrs,"}, {"sha": "f12fb21992e85dbd3a97ad26ae9800745e65e41f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -703,14 +703,11 @@ pub fn print_struct(s: @ps,\n         for struct_def.fields.each |field| {\n             match field.node.kind {\n                 ast::unnamed_field => fail!(~\"unexpected unnamed field\"),\n-                ast::named_field(ident, mutability, visibility) => {\n+                ast::named_field(ident, visibility) => {\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n                     print_outer_attributes(s, field.node.attrs);\n                     print_visibility(s, visibility);\n-                    if mutability == ast::struct_mutable {\n-                        word_nbsp(s, ~\"mut\");\n-                    }\n                     print_ident(s, ident);\n                     word_nbsp(s, ~\":\");\n                     print_type(s, field.node.ty);"}, {"sha": "23084c34209e953d277b748996ed941668283255", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -84,7 +84,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n * for another case of this. */\n macro_rules! interner_key (\n     () => (cast::transmute::<(uint, uint),\n-           &fn(+v: @@::parse::token::ident_interner)>(\n+           &fn(v: @@::parse::token::ident_interner)>(\n         (-3 as uint, 0u)))\n )\n "}, {"sha": "7ad617cebdbb31e6465f542406e434c1d1c745c4", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -23,7 +23,7 @@ pub mod kitties {\n         fn meow_count(&mut self) -> uint { self.meows }\n     }\n \n-    pub fn cat<U>(in_x : uint, in_y : int, +in_info: ~[U]) -> cat<U> {\n+    pub fn cat<U>(in_x : uint, in_y : int, in_info: ~[U]) -> cat<U> {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "cb494ec9d206ae03a8728be8260be7dbd8f4d725", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -103,7 +103,7 @@ fn main() {\n     let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let rng = core::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n+        let mut rng = core::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.next() as uint;"}, {"sha": "bae21c6d4a325ef092650e4cf77f9e82f470335b", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -31,8 +31,13 @@ fn timed(result: &mut float, op: &fn()) {\n }\n \n pub impl Results {\n-    fn bench_int<T:Set<uint>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n-                               rand_cap: uint, f: &fn() -> T) {\n+    fn bench_int<T:Set<uint>,\n+                 R: rand::Rng>(\n+                 &mut self,\n+                 rng: &mut R,\n+                 num_keys: uint,\n+                 rand_cap: uint,\n+                 f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_ints) {\n@@ -69,8 +74,12 @@ pub impl Results {\n         }\n     }\n \n-    fn bench_str<T:Set<~str>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n-                                            f: &fn() -> T) {\n+    fn bench_str<T:Set<~str>,\n+                 R:rand::Rng>(\n+                 &mut self,\n+                 rng: &mut R,\n+                 num_keys: uint,\n+                 f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {\n@@ -155,25 +164,25 @@ fn main() {\n     let max = 200000;\n \n     {\n-        let rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(&rng, num_keys, max, || HashSet::new::<uint>());\n-        results.bench_str(&rng, num_keys, || HashSet::new::<~str>());\n+        results.bench_int(&mut rng, num_keys, max, || HashSet::new::<uint>());\n+        results.bench_str(&mut rng, num_keys, || HashSet::new::<~str>());\n         write_results(\"core::hashmap::HashSet\", &results);\n     }\n \n     {\n-        let rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(&rng, num_keys, max, || TreeSet::new::<uint>());\n-        results.bench_str(&rng, num_keys, || TreeSet::new::<~str>());\n+        results.bench_int(&mut rng, num_keys, max, || TreeSet::new::<uint>());\n+        results.bench_str(&mut rng, num_keys, || TreeSet::new::<~str>());\n         write_results(\"std::treemap::TreeSet\", &results);\n     }\n \n     {\n-        let rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(&rng, num_keys, max, || BitvSet::new());\n+        results.bench_int(&mut rng, num_keys, max, || BitvSet::new());\n         write_results(\"std::bitv::BitvSet\", &results);\n     }\n }"}, {"sha": "95a83af93d5412843884034b35aacd49c1d3d9be", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -33,12 +33,15 @@ fn main() {\n fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     let mut run_test = false;\n \n-    if os::getenv(~\"RUST_BENCH\").is_some() { run_test = true }\n-    else if argv.len() > 0 {\n+    if os::getenv(~\"RUST_BENCH\").is_some() {\n+        run_test = true\n+    } else if argv.len() > 0 {\n         run_test = argv.contains(&~\"all\") || argv.contains(&name)\n     }\n \n-    if !run_test { return }\n+    if !run_test {\n+        return\n+    }\n \n     let start = precise_time_s();\n     test();\n@@ -69,7 +72,7 @@ fn read_line() {\n }\n \n fn vec_plus() {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n@@ -86,7 +89,7 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n@@ -103,7 +106,7 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n \n     let mut v = ~[];\n     for uint::range(0, 1500) |i| {"}, {"sha": "1842a8ff42e525b644d076ae840045bc120b4ce6", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -32,19 +32,20 @@ type graph = ~[~[node_id]];\n type bfs_result = ~[node_id];\n \n fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n-    let r = rand::XorShiftRng::new();\n-\n-    fn choose_edge<R: rand::Rng>(i: node_id, j: node_id, scale: uint, r: &R)\n-        -> (node_id, node_id) {\n+    let mut r = rand::XorShiftRng::new();\n \n+    fn choose_edge<R: rand::Rng>(i: node_id,\n+                                 j: node_id,\n+                                 scale: uint,\n+                                 r: &mut R)\n+                                 -> (node_id, node_id) {\n         let A = 0.57;\n         let B = 0.19;\n         let C = 0.19;\n \n         if scale == 0u {\n             (i, j)\n-        }\n-        else {\n+        } else {\n             let i = i * 2i64;\n             let j = j * 2i64;\n             let scale = scale - 1u;\n@@ -73,7 +74,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n     }\n \n     do vec::from_fn((1u << scale) * edgefactor) |_i| {\n-        choose_edge(0i64, 0i64, scale, &r)\n+        choose_edge(0i64, 0i64, scale, &mut r)\n     }\n }\n \n@@ -103,7 +104,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     let mut keys = HashSet::new();\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n \n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n@@ -272,7 +273,7 @@ fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n         colors = do par::mapi(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(graph);\n-            let result: ~fn(+x: uint, +y: &color) -> color = |i, c| {\n+            let result: ~fn(x: uint, y: &color) -> color = |i, c| {\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);\n                 match *c {\n@@ -394,7 +395,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     let status = do par::alli(tree) {\n         let edges = copy edges;\n-        let result: ~fn(+x: uint, v: &i64) -> bool = |u, v| {\n+        let result: ~fn(x: uint, v: &i64) -> bool = |u, v| {\n             let u = u as node_id;\n             if *v == -1i64 || u == root {\n                 true"}, {"sha": "95758b3fe64063c0bf7c19f8dd436008ef8b2f97", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -65,15 +65,15 @@ fn run(args: &[~str]) {\n     let mut worker_results = ~[];\n     for uint::range(0, workers) |_i| {\n         let to_child = to_child.clone();\n-        do task::task().future_result(|+r| {\n-            worker_results.push(r);\n-        }).spawn || {\n+        let mut builder = task::task();\n+        builder.future_result(|r| worker_results.push(r));\n+        do builder.spawn {\n             for uint::range(0, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //error!(\"worker %? exiting\", i);\n-        };\n+        }\n     }\n     do task::spawn || {\n         server(&from_parent, &to_parent);"}, {"sha": "e213a44b49ae7133b7e08a67f0a484f012e2f860", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -62,9 +62,9 @@ fn run(args: &[~str]) {\n     for uint::range(0, workers) |_i| {\n         let (from_parent_, to_child) = stream();\n         from_parent.add(from_parent_);\n-        do task::task().future_result(|+r| {\n-            worker_results.push(r);\n-        }).spawn || {\n+        let mut builder = task::task();\n+        builder.future_result(|r| worker_results.push(r));\n+        do builder.spawn {\n             for uint::range(0, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));"}, {"sha": "2d234634cc8ba3690fb8e5939d995d88aedf2c29", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -45,10 +45,7 @@ fn init() -> (pipe,pipe) {\n }\n \n \n-fn thread_ring(i: uint,\n-               count: uint,\n-               +num_chan: pipe,\n-               +num_port: pipe) {\n+fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n@@ -103,7 +100,9 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.each |f| { f.get() };\n+    for futures.each_mut |f| {\n+        f.get()\n+    }\n \n     let stop = time::precise_time_s();\n "}, {"sha": "aef5c18499ac3b7924eb3878eb94860eb88d9a4b", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -35,8 +35,8 @@ macro_rules! move_out (\n \n fn thread_ring(i: uint,\n                count: uint,\n-               +num_chan: ring::client::num,\n-               +num_port: ring::server::num) {\n+               num_chan: ring::client::num,\n+               num_port: ring::server::num) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n@@ -96,7 +96,9 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.each |f| { f.get() };\n+    for futures.each_mut |f| {\n+        let _ = f.get();\n+    }\n \n     let stop = time::precise_time_s();\n "}, {"sha": "02415c4bcfce741797ab81626d2cf9409fa28ca9", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -46,10 +46,7 @@ fn init() -> (pipe,pipe) {\n }\n \n \n-fn thread_ring(i: uint,\n-               count: uint,\n-               +num_chan: pipe,\n-               +num_port: pipe) {\n+fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n@@ -104,7 +101,9 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n-    for futures.each |f| { f.get() };\n+    for futures.each_mut |f| {\n+        let _ = f.get();\n+    }\n \n     let stop = time::precise_time_s();\n "}, {"sha": "992ce73a4bff7473591ae6ffdc7503ce79c3bdbe", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -13,7 +13,7 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n #[inline(always)]\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n-fn random_gradient<R:Rng>(r: &R) -> Vec2 {\n+fn random_gradient<R:Rng>(r: &mut R) -> Vec2 {\n     let v = 2.0 * float::consts::pi * r.gen();\n     Vec2 {\n         x: float::cos(v) as f32,\n@@ -33,11 +33,15 @@ struct Noise2DContext {\n \n pub impl Noise2DContext {\n     fn new() -> Noise2DContext {\n-        let r = rand::rng();\n+        let mut r = rand::rng();\n         let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n-        for int::range(0, 256) |i| { rgradients[i] = random_gradient(&r); }\n+        for int::range(0, 256) |i| {\n+            rgradients[i] = random_gradient(&mut r);\n+        }\n         let mut permutations = [ 0, ..256 ];\n-        for int::range(0, 256) |i| { permutations[i] = i; }\n+        for int::range(0, 256) |i| {\n+            permutations[i] = i;\n+        }\n         r.shuffle_mut(permutations);\n \n         Noise2DContext {\n@@ -53,7 +57,11 @@ pub impl Noise2DContext {\n     }\n \n     #[inline]\n-    fn get_gradients(&self, gradients: &mut [Vec2, ..4], origins: &mut [Vec2, ..4], x: f32, y: f32) {\n+    fn get_gradients(&self,\n+                     gradients: &mut [Vec2, ..4],\n+                     origins: &mut [Vec2, ..4],\n+                     x: f32,\n+                     y: f32) {\n         let x0f = f32::floor(x);\n         let y0f = f32::floor(y);\n         let x0 = x0f as int;"}, {"sha": "cfad253cfed5b3941026ff397e2916c2aa396ffb", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -117,8 +117,9 @@ pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n     client\n }\n \n-fn switch<T:Owned,Tb:Owned,U>(+endp: core::pipes::RecvPacketBuffered<T, Tb>,\n-                      f: &fn(+v: Option<T>) -> U) -> U {\n+fn switch<T:Owned,Tb:Owned,U>(endp: core::pipes::RecvPacketBuffered<T, Tb>,\n+                              f: &fn(v: Option<T>) -> U)\n+                              -> U {\n     f(core::pipes::try_recv(endp))\n }\n "}, {"sha": "7316b68f8bd420976bbe2892b7f69caadaa8e632", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -63,7 +63,10 @@ fn make_random_fasta(wr: @io::Writer,\n                      genelist: ~[AminoAcids],\n                      n: int) {\n     wr.write_line(~\">\" + id + ~\" \" + desc);\n-    let rng = @mut MyRandom {last: rand::rng().next()};\n+    let mut rng = rand::rng();\n+    let rng = @mut MyRandom {\n+        last: rng.next()\n+    };\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n         str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),"}, {"sha": "b7ae331c8f376b03d8cc727f3e6b7713a5a12b29", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -26,7 +26,6 @@ use core::int::range;\n use core::comm::*;\n use core::io::WriterUtil;\n \n-use core::result;\n use core::result::{Ok, Err};\n \n fn fib(n: int) -> int {\n@@ -67,7 +66,7 @@ fn parse_opts(argv: ~[~str]) -> Config {\n     }\n }\n \n-fn stress_task(&&id: int) {\n+fn stress_task(id: int) {\n     let mut i = 0;\n     loop {\n         let n = 15;\n@@ -80,13 +79,15 @@ fn stress_task(&&id: int) {\n fn stress(num_tasks: int) {\n     let mut results = ~[];\n     for range(0, num_tasks) |i| {\n-        do task::task().future_result(|+r| {\n-            results.push(r);\n-        }).spawn {\n+        let mut builder = task::task();\n+        builder.future_result(|r| results.push(r));\n+        do builder.spawn {\n             stress_task(i);\n         }\n     }\n-    for results.each |r| { r.recv(); }\n+    for results.each |r| {\n+        r.recv();\n+    }\n }\n \n fn main() {"}, {"sha": "6015f21be727f711f548d8c3b2a0e529d9123119", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -46,9 +46,12 @@ fn grandchild_group(num_tasks: uint) {\n     // Master grandchild task exits early.\n }\n \n-fn spawn_supervised_blocking(myname: &str, +f: ~fn()) {\n+fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n     let mut res = None;\n-    task::task().future_result(|+r| res = Some(r)).supervised().spawn(f);\n+    let mut builder = task::task();\n+    builder.future_result(|r| res = Some(r));\n+    builder.supervised();\n+    builder.spawn(f);\n     error!(\"%s group waiting\", myname);\n     let x = res.unwrap().recv();\n     assert!(x == task::Success);"}, {"sha": "e6da898a03493a9ca547318b8c68b31f62ec8e80", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(&&n: uint) {\n+fn f(n: uint) {\n     let mut i = 0u;\n     while i < n {\n         task::try(|| g() );"}, {"sha": "df9eb9fdda69b863dc4638e7e76526f806a554fd", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,9 +12,9 @@\n // other tycons.\n \n fn coerce(b: &fn()) -> extern fn() {\n-    fn lol(+f: extern fn(+v: &fn()) -> extern fn(),\n-           +g: &fn()) -> extern fn() { return f(g); }\n-    fn fn_id(+f: extern fn()) -> extern fn() { return f }\n+    fn lol(f: extern fn(v: &fn()) -> extern fn(),\n+           g: &fn()) -> extern fn() { return f(g); }\n+    fn fn_id(f: extern fn()) -> extern fn() { return f }\n     return lol(fn_id, b);\n     //~^ ERROR mismatched types\n }"}, {"sha": "f1cca89b227d6773c59340949b31dbe3c8e7c7c9", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn match_ref(&&v: Option<int>) -> int {\n+fn match_ref(v: Option<int>) -> int {\n     match v {\n       Some(ref i) => {\n         *i\n@@ -17,7 +17,7 @@ fn match_ref(&&v: Option<int>) -> int {\n     }\n }\n \n-fn match_ref_unused(&&v: Option<int>) {\n+fn match_ref_unused(v: Option<int>) {\n     match v {\n       Some(_) => {}\n       None => {}"}, {"sha": "cf7529865118afb6ee2de8c17eefad57631b0efb", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(+x: ~int) -> int {\n+fn foo(x: ~int) -> int {\n     let y = &*x;\n     free(x); //~ ERROR cannot move out of `*x` because it is borrowed\n     *y\n }\n \n-fn free(+_x: ~int) {\n+fn free(_x: ~int) {\n }\n \n fn main() {"}, {"sha": "fa34c056794fc63bc4ede843d06aeff0591fdcc5", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -18,7 +18,7 @@ impl Drop for X {\n     }\n }\n \n-fn unwrap(+x: X) -> ~str {\n+fn unwrap(x: X) -> ~str {\n     let X { x: y } = x; //~ ERROR deconstructing struct not allowed in pattern\n     y\n }"}, {"sha": "5b55cc772fde8c85e847322d092e7e3cef9cf5f0", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -15,10 +15,10 @@ pub mod stream {\n         use core::pipes;\n \n         pub impl<T:Owned> Stream<T> {\n-            pub fn recv() -> extern fn(+v: Stream<T>) -> ::stream::Stream<T> {\n+            pub fn recv() -> extern fn(v: Stream<T>) -> ::stream::Stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes.\n-              pub fn recv(+pipe: Stream<T>) -> ::stream::Stream<T> { //~ ERROR attempt to use a type argument out of scope\n+              pub fn recv(pipe: Stream<T>) -> ::stream::Stream<T> { //~ ERROR attempt to use a type argument out of scope\n                 //~^ ERROR use of undeclared type name\n                 //~^^ ERROR attempt to use a type argument out of scope\n                 //~^^^ ERROR use of undeclared type name"}, {"sha": "062ee8fd01e46a795b06728269c78bdac9054c3e", "filename": "src/test/compile-fail/issue-3296.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -18,7 +18,7 @@ struct Foo {\n     a: ()\n }\n \n-fn deserialize_foo<__D: std::serialization::deserializer>(&&__d: __D) {\n+fn deserialize_foo<__D: std::serialization::deserializer>(__d: __D) {\n }\n \n fn main() { let des = Deserializer(); let foo = deserialize_foo(des); }"}, {"sha": "23d3fff01cf3c9fe6dc218cf7cee98f5ba88ca7f", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn send<T:Owned>(ch: _chan<T>, +data: T) {\n+fn send<T:Owned>(ch: _chan<T>, data: T) {\n     debug!(ch);\n     debug!(data);\n     fail!();"}, {"sha": "c907eb4be49f8a2679ea11ef3f9c96101513b3c4", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,7 +11,7 @@\n extern mod std;\n \n fn main() {\n-    unsafe fn f(&&v: *const int) {\n+    unsafe fn f(v: *const int) {\n         *v = 1 //~ ERROR cannot assign\n     }\n "}, {"sha": "003e8ccf30956d16258e0c4cf79065a982d73bf0", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -21,7 +21,7 @@ impl Drop for r {\n     }\n }\n \n-fn f<T>(+_i: ~[T], +_j: ~[T]) {\n+fn f<T>(_i: ~[T], _j: ~[T]) {\n }\n \n fn main() {"}, {"sha": "012e9d19b121883738176c6db2c427c1b8d01bf4", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,7 +14,7 @@\n \n extern mod std;\n \n-fn getbig_and_fail(&&i: int) {\n+fn getbig_and_fail(i: int) {\n     let _r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);"}, {"sha": "6fc187491cf8ceac4ce50ddff3ac2d2cd6ded104", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,7 +14,7 @@\n \n extern mod std;\n \n-fn getbig_and_fail(&&i: int) {\n+fn getbig_and_fail(i: int) {\n     let r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);"}, {"sha": "8f1b34d17cd99f8c038c9a0a34ad1591382c3708", "filename": "src/test/run-fail/unwind-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Funwind-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-fail%2Funwind-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-move.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // error-pattern:fail\n-fn f(+_a: @int) {\n+fn f(_a: @int) {\n     fail!();\n }\n "}, {"sha": "8c84187ff6f0662ec61cd5b99f434ce1c566b40e", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -10,9 +10,11 @@\n \n // xfail-fast\n \n-struct X { x: int }\n+struct X {\n+    x: int\n+}\n \n-fn f1(a: &mut X, b: &mut int, +c: int) -> int {\n+fn f1(a: &mut X, b: &mut int, c: int) -> int {\n     let r = a.x + *b + c;\n     a.x = 0;\n     *b = 10;"}, {"sha": "f74d78f99d0b205038f1b17d898c8cf0e723b217", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n trait Pushable<T> {\n-    fn push_val(&mut self, +t: T);\n+    fn push_val(&mut self, t: T);\n }\n \n impl<T> Pushable<T> for ~[T] {\n-    fn push_val(&mut self, +t: T) {\n+    fn push_val(&mut self, t: T) {\n         self.push(t);\n     }\n }"}, {"sha": "8752102c3a51377f6661b9cab2ce80ae72c64e85", "filename": "src/test/run-pass/bind-by-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-by-move.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n extern mod std;\n use std::arc;\n-fn dispose(+_x: arc::ARC<bool>) { unsafe { } }\n+fn dispose(_x: arc::ARC<bool>) { unsafe { } }\n \n pub fn main() {\n     let p = arc::ARC(true);"}, {"sha": "a912e1ef65c423655cedb392c73b9d9b3e8475ad", "filename": "src/test/run-pass/borrowck-lend-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-lend-args.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -10,15 +10,15 @@\n \n fn borrow(_v: &int) {}\n \n-fn borrow_from_arg_imm_ref(&&v: ~int) {\n+fn borrow_from_arg_imm_ref(v: ~int) {\n     borrow(v);\n }\n \n fn borrow_from_arg_mut_ref(v: &mut ~int) {\n     borrow(*v);\n }\n \n-fn borrow_from_arg_copy(+v: ~int) {\n+fn borrow_from_arg_copy(v: ~int) {\n     borrow(v);\n }\n "}, {"sha": "8f66faab014519ce284d795a3f151bb550bb6c05", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,7 +14,7 @@ fn want_slice(v: &[int]) -> int {\n     return sum;\n }\n \n-fn has_mut_vec(+v: ~[int]) -> int {\n+fn has_mut_vec(v: ~[int]) -> int {\n     want_slice(v)\n }\n "}, {"sha": "5f0c7cad6191c532805ac9cde04c5f3dd9a53b13", "filename": "src/test/run-pass/borrowck-newtype-issue-2573.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -25,7 +25,7 @@ impl frob for foo {\n }\n \n // Override default mode so that we are passing by value\n-fn really_impure(++bar: baz) {\n+fn really_impure(bar: baz) {\n     bar.baz = 3;\n }\n "}, {"sha": "817891c1146401d2872f8d16626c7c27dbd36270", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -26,7 +26,7 @@\n \n use core::comm::*;\n \n-fn foo(&&x: ()) -> Port<()> {\n+fn foo(x: ()) -> Port<()> {\n     let (p, c) = stream::<()>();\n     do task::spawn() {\n         c.send(x);"}, {"sha": "4eb3cea3a2586285ec53f4c4350a3d6a78980e46", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,6 +12,8 @@\n \n extern mod std;\n \n-fn child2(&&s: ~str) { }\n+fn child2(s: ~str) { }\n \n-pub fn main() { let x = task::spawn(|| child2(~\"hi\") ); }\n+pub fn main() {\n+    let x = task::spawn(|| child2(~\"hi\"));\n+}"}, {"sha": "9774d8d14882e6356be47e839adab9564351e9f2", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -22,7 +22,7 @@ pub impl<U> cat<U> {\n     fn meow_count(&mut self) -> uint { self.meows }\n }\n \n-fn cat<U>(in_x : uint, in_y : int, +in_info: ~[U]) -> cat<U> {\n+fn cat<U>(in_x : uint, in_y : int, in_info: ~[U]) -> cat<U> {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,"}, {"sha": "cb378da13ea603fd09d3b8332ebe44276edab6ff", "filename": "src/test/run-pass/cleanup-copy-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-win32\n-fn adder(+x: @int, +y: @int) -> int { return *x + *y; }\n+fn adder(x: @int, y: @int) -> int { return *x + *y; }\n fn failer() -> @int { fail!(); }\n pub fn main() {\n     assert!(result::is_err(&task::try(|| {"}, {"sha": "19b99eaccc9563fe6dd66f00b360775f7588cd0e", "filename": "src/test/run-pass/extern-pass-TwoU64s-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -16,7 +16,7 @@ struct TwoU64s {\n }\n \n pub extern {\n-    pub fn rust_dbg_extern_identity_TwoU64s(&&u: TwoU64s) -> TwoU64s;\n+    pub fn rust_dbg_extern_identity_TwoU64s(u: TwoU64s) -> TwoU64s;\n }\n \n pub fn main() {"}, {"sha": "1cd709ee91b9d5d5aebf7e1f54853cbad0a41bcb", "filename": "src/test/run-pass/extern-pub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pub.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1,7 +1,7 @@\n extern {\n-    pub unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                            ++v: **vec::raw::VecRepr,\n-                                            ++n: libc::size_t);\n+    pub unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n+                                            v: **vec::raw::VecRepr,\n+                                            n: libc::size_t);\n }\n \n pub fn main() {"}, {"sha": "b78bd488bc6ea7c6d016d6113e07613e392d09a7", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -14,7 +14,7 @@ fn spawn<T:Owned>(val: T, f: extern fn(T)) {\n     f(val);\n }\n \n-fn f(+i: int) {\n+fn f(i: int) {\n     assert!(i == 100);\n }\n "}, {"sha": "2dbc60e9a14ac2bdc19377e61685b2c39c38baf1", "filename": "src/test/run-pass/foreign-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fforeign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fforeign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-struct.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -18,7 +18,7 @@ mod bindgen {\n \n     #[nolink]\n     pub extern {\n-        pub fn printf(++v: void);\n+        pub fn printf(v: void);\n     }\n }\n "}, {"sha": "9f683d20898774076272b19ae123e120117890eb", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,8 +11,8 @@\n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n-        pub fn move_val_init<T>(dst: &mut T, +src: T);\n-        pub fn move_val<T>(dst: &mut T, +src: T);\n+        pub fn move_val_init<T>(dst: &mut T, src: T);\n+        pub fn move_val<T>(dst: &mut T, src: T);\n     }\n }\n "}, {"sha": "71a491b8a3955bba2877f7dbe67403a35fc78711", "filename": "src/test/run-pass/issue-2633-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633-2.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn a_val(&&x: ~int, +y: ~int) -> int {\n+fn a_val(x: ~int, y: ~int) -> int {\n     *x + *y\n }\n "}, {"sha": "acd26a88a736191dc7a3cc40f4be3244dfe6deaf", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -53,23 +53,23 @@ pub mod pipes {\n \n     // We should consider moving this to ::core::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n-    pub unsafe fn uniquify<T>(+x: *T) -> ~T {\n+    pub unsafe fn uniquify<T>(x: *T) -> ~T {\n         unsafe { cast::transmute(x) }\n     }\n \n-    pub fn swap_state_acq(+dst: &mut state, src: state) -> state {\n+    pub fn swap_state_acq(dst: &mut state, src: state) -> state {\n         unsafe {\n             transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n         }\n     }\n \n-    pub fn swap_state_rel(+dst: &mut state, src: state) -> state {\n+    pub fn swap_state_rel(dst: &mut state, src: state) -> state {\n         unsafe {\n             transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n         }\n     }\n \n-    pub fn send<T:Owned>(mut p: send_packet<T>, +payload: T) {\n+    pub fn send<T:Owned>(mut p: send_packet<T>, payload: T) {\n         let mut p = p.unwrap();\n         let mut p = unsafe { uniquify(p) };\n         assert!((*p).payload.is_none());\n@@ -229,7 +229,7 @@ pub mod pingpong {\n     pub struct ping(::pipes::send_packet<pong>);\n     pub struct pong(::pipes::send_packet<ping>);\n \n-    pub fn liberate_ping(+p: ping) -> ::pipes::send_packet<pong> {\n+    pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let addr : *::pipes::send_packet<pong> = match &p {\n               &ping(ref x) => { cast::transmute(x) }\n@@ -240,7 +240,7 @@ pub mod pingpong {\n         }\n     }\n \n-    pub fn liberate_pong(+p: pong) -> ::pipes::send_packet<ping> {\n+    pub fn liberate_pong(p: pong) -> ::pipes::send_packet<ping> {\n         unsafe {\n             let addr : *::pipes::send_packet<ping> = match &p {\n               &pong(ref x) => { cast::transmute(x) }\n@@ -262,14 +262,14 @@ pub mod pingpong {\n         pub type ping = ::pipes::send_packet<pingpong::ping>;\n         pub type pong = ::pipes::recv_packet<pingpong::pong>;\n \n-        pub fn do_ping(+c: ping) -> pong {\n+        pub fn do_ping(c: ping) -> pong {\n             let (sp, rp) = ::pipes::entangle();\n \n             ::pipes::send(c, pingpong::ping(sp));\n             rp\n         }\n \n-        pub fn do_pong(+c: pong) -> (ping, ()) {\n+        pub fn do_pong(c: pong) -> (ping, ()) {\n             let packet = ::pipes::recv(c);\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n@@ -284,30 +284,30 @@ pub mod pingpong {\n         pub type ping = ::pipes::recv_packet<pingpong::ping>;\n         pub type pong = ::pipes::send_packet<pingpong::pong>;\n \n-        pub fn do_ping(+c: ping) -> (pong, ()) {\n+        pub fn do_ping(c: ping) -> (pong, ()) {\n             let packet = ::pipes::recv(c);\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n             }\n             (pingpong::liberate_ping(packet.unwrap()), ())\n         }\n \n-        pub fn do_pong(+c: pong) -> ping {\n+        pub fn do_pong(c: pong) -> ping {\n             let (sp, rp) = ::pipes::entangle();\n             ::pipes::send(c, pingpong::pong(sp));\n             rp\n         }\n     }\n }\n \n-fn client(+chan: pingpong::client::ping) {\n+fn client(chan: pingpong::client::ping) {\n     let chan = pingpong::client::do_ping(chan);\n     error!(~\"Sent ping\");\n     let (_chan, _data) = pingpong::client::do_pong(chan);\n     error!(~\"Received pong\");\n }\n \n-fn server(+chan: pingpong::server::ping) {\n+fn server(chan: pingpong::server::ping) {\n     let (chan, _data) = pingpong::server::do_ping(chan);\n     error!(~\"Received ping\");\n     let _chan = pingpong::server::do_pong(chan);"}, {"sha": "112aab597f0299e7c689160d8741e2611df822f7", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -59,7 +59,7 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr:'static + io::Reader>(+in: rdr) -> ~[~[square]] {\n+fn read_board_grid<rdr:'static + io::Reader>(in: rdr) -> ~[~[square]] {\n     let in = @in as @io::Reader;\n     let mut grid = ~[];\n     for in.each_line |line| {"}, {"sha": "d22c7e82ad5de456b8925d062c0cec42d200ce52", "filename": "src/test/run-pass/issue-3176.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -26,7 +26,8 @@ pub fn main() {\n         c2.send(());\n         error!(\"child blocks\");\n         let (p, c) = comm::stream();\n-        (p, p3).select();\n+        let mut tuple = (p, p3);\n+        tuple.select();\n         c.send(());\n     };\n     error!(\"parent tries\");"}, {"sha": "895e90beef4aa5232eec90804692346d226f8482", "filename": "src/test/run-pass/issue-3656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3656.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -24,7 +24,7 @@ struct KEYGEN {\n \n extern {\n     // Bogus signature, just need to test if it compiles.\n-    pub fn malloc(++data: KEYGEN);\n+    pub fn malloc(data: KEYGEN);\n }\n \n pub fn main() {"}, {"sha": "5f427861e7917d52f3147fbb4821e6816faa750e", "filename": "src/test/run-pass/iter-min-max.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-min-max.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n+fn is_even(x: uint) -> bool { (x % 2u) == 0u }\n \n pub fn main() {\n     assert!([1u, 3u].min() == 1u);"}, {"sha": "acdf388a8ff033720b7111825985b9afdddaf84b", "filename": "src/test/run-pass/liveness-move-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn take(+x: int) -> int {x}\n+fn take(x: int) -> int {x}\n \n fn the_loop() {\n     let mut list = ~[];"}, {"sha": "e1561db8b9162a8475116ece1634888b07308d4a", "filename": "src/test/run-pass/morestack5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack5.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,7 +12,7 @@\n \n extern mod std;\n \n-fn getbig(&&i: int) {\n+fn getbig(i: int) {\n     if i != 0 {\n         getbig(i - 1);\n     }"}, {"sha": "dafdd0fba48c37606454b93a191dca2052bffba3", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -62,7 +62,7 @@ pub fn main() {\n         calllink09,\n         calllink10\n     ];\n-    let rng = rand::rng();\n+    let mut rng = rand::rng();\n     for fns.each |f| {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;"}, {"sha": "ed3cdc81c31796e21f42e29b677bdc8890ba46a4", "filename": "src/test/run-pass/move-arg-2-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test(+foo: ~~[int]) { assert!((foo[0] == 10)); }\n+fn test(foo: ~~[int]) { assert!((foo[0] == 10)); }\n \n pub fn main() {\n     let x = ~~[10];"}, {"sha": "fc909da8b0323acd8720c6896353938d21cd5612", "filename": "src/test/run-pass/move-arg-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test(+foo: @~[int]) { assert!((foo[0] == 10)); }\n+fn test(foo: @~[int]) { assert!((foo[0] == 10)); }\n \n pub fn main() {\n     let x = @~[10];"}, {"sha": "87db5cbe2f13ed2a4e049f0b3deff663ea8d6e15", "filename": "src/test/run-pass/move-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test(+foo: int) { assert!((foo == 10)); }\n+fn test(foo: int) { assert!((foo == 10)); }\n \n pub fn main() { let x = 10; test(x); }"}, {"sha": "ab66bb936354f406e57eb592fb8f9f5b8b2eb54d", "filename": "src/test/run-pass/move-nullary-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // Issue #922\n-fn f2(+thing: @fn()) { }\n+fn f2(thing: @fn()) { }\n \n-fn f(+thing: @fn()) {\n+fn f(thing: @fn()) {\n     f2(thing);\n }\n "}, {"sha": "8c26dfa1fac56b3c1b0734a249a66c3977151b6a", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -40,7 +40,7 @@ impl ops::Not<Point> for Point {\n }\n \n impl ops::Index<bool,int> for Point {\n-    fn index(&self, +x: &bool) -> int {\n+    fn index(&self, x: &bool) -> int {\n         if *x { self.x } else { self.y }\n     }\n }"}, {"sha": "8698d1f39a88ffbb0361960c0957547a53e50509", "filename": "src/test/run-pass/option-unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-unwrap.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -23,7 +23,7 @@ impl Drop for dtor {\n     }\n }\n \n-fn unwrap<T>(+o: Option<T>) -> T {\n+fn unwrap<T>(o: Option<T>) -> T {\n     match o {\n       Some(v) => v,\n       None => fail!()"}, {"sha": "c4f328940c49f4714bb01747afb57459c354ddf5", "filename": "src/test/run-pass/pass-by-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn magic(+x: A) { debug!(x); }\n-fn magic2(+x: @int) { debug!(x); }\n+fn magic(x: A) { debug!(x); }\n+fn magic2(x: @int) { debug!(x); }\n \n struct A { a: @int }\n "}, {"sha": "5e2be7e6d081a08916510ab79c3ede7a272c9d43", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -48,12 +48,12 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n-fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,\n-                      f: &fn(+v: Option<T>) -> U) -> U {\n+fn switch<T:Owned,U>(endp: pipes::RecvPacket<T>,\n+                     f: &fn(v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }\n \n-fn move_it<T>(+x: T) -> T { x }\n+fn move_it<T>(x: T) -> T { x }\n \n macro_rules! follow (\n     {\n@@ -68,7 +68,7 @@ macro_rules! follow (\n     );\n )\n \n-fn client_follow(+bank: bank::client::login) {\n+fn client_follow(bank: bank::client::login) {\n     use bank::*;\n \n     let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n@@ -89,7 +89,7 @@ fn client_follow(+bank: bank::client::login) {\n     ));\n }\n \n-fn bank_client(+bank: bank::client::login) {\n+fn bank_client(bank: bank::client::login) {\n     use bank::*;\n \n     let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");"}, {"sha": "985eaecdc781b28275776cdd6d28561498f610f6", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -22,11 +22,11 @@ proto! oneshot (\n )\n \n pub fn main() {\n-    let (c, p) = oneshot::init();\n+    let mut (c, p) = oneshot::init();\n \n-    assert!(!pipes::peek(&p));\n+    assert!(!pipes::peek(&mut p));\n \n     oneshot::client::signal(c);\n \n-    assert!(pipes::peek(&p));\n+    assert!(pipes::peek(&mut p));\n }"}, {"sha": "3c37371a5371c3dd9a68cb4f303fb91bddc789bf", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -40,7 +40,7 @@ mod pingpong {\n         do pipes::entangle_buffer(buffer) |buffer, data| {\n             data.ping.set_buffer(buffer);\n             data.pong.set_buffer(buffer);\n-            ptr::to_unsafe_ptr(&(data.ping))\n+            ptr::to_mut_unsafe_ptr(&mut (data.ping))\n         }\n     }\n     pub struct ping(server::pong);\n@@ -50,11 +50,11 @@ mod pingpong {\n         use core::pipes::*;\n         use core::ptr;\n \n-        pub fn ping(+pipe: ping) -> pong {\n+        pub fn ping(mut pipe: ping) -> pong {\n             {\n-                let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(&b.buffer.data.pong);\n-                let c = RecvPacketBuffered(&b.buffer.data.pong);\n+                let mut b = pipe.reuse_buffer();\n+                let s = SendPacketBuffered(&mut b.buffer.data.pong);\n+                let c = RecvPacketBuffered(&mut b.buffer.data.pong);\n                 let message = ::pingpong::ping(s);\n                 send(pipe, message);\n                 c\n@@ -72,11 +72,11 @@ mod pingpong {\n \n         pub type ping = pipes::RecvPacketBuffered<::pingpong::ping,\n         ::pingpong::Packets>;\n-        pub fn pong(+pipe: pong) -> ping {\n+        pub fn pong(mut pipe: pong) -> ping {\n             {\n-                let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(&b.buffer.data.ping);\n-                let c = RecvPacketBuffered(&b.buffer.data.ping);\n+                let mut b = pipe.reuse_buffer();\n+                let s = SendPacketBuffered(&mut b.buffer.data.ping);\n+                let c = RecvPacketBuffered(&mut b.buffer.data.ping);\n                 let message = ::pingpong::pong(s);\n                 send(pipe, message);\n                 c\n@@ -91,7 +91,7 @@ mod test {\n     use core::pipes::recv;\n     use pingpong::{ping, pong};\n \n-    pub fn client(+chan: ::pingpong::client::ping) {\n+    pub fn client(chan: ::pingpong::client::ping) {\n         use pingpong::client;\n \n         let chan = client::ping(chan); return;\n@@ -100,7 +100,7 @@ mod test {\n         error!(\"Received pong\");\n     }\n \n-    pub fn server(+chan: ::pingpong::server::ping) {\n+    pub fn server(chan: ::pingpong::server::ping) {\n         use pingpong::server;\n \n         let ping(chan) = recv(chan); return;"}, {"sha": "5978438ef76355d0b8206157cbe619b535bbf531", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -29,7 +29,7 @@ mod test {\n     use core::pipes::recv;\n     use pingpong::{ping, pong};\n \n-    pub fn client(+chan: ::pingpong::client::ping) {\n+    pub fn client(chan: ::pingpong::client::ping) {\n         use pingpong::client;\n \n         let chan = client::ping(chan);\n@@ -38,7 +38,7 @@ mod test {\n         error!(~\"Received pong\");\n     }\n \n-    pub fn server(+chan: ::pingpong::server::ping) {\n+    pub fn server(chan: ::pingpong::server::ping) {\n         use pingpong::server;\n \n         let ping(chan) = recv(chan);"}, {"sha": "fcfd77dab0aa3f88296d562f01147b1cc49c8dde", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -1,4 +1,8 @@\n // xfail-fast\n+// xfail-test\n+\n+// XFAIL'd because this is going to be revamped, and it's not compatible as\n+// written with the new mutability rules.\n \n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at"}, {"sha": "774f2470b3cd33be6718433bd150e792f0596104", "filename": "src/test/run-pass/platform_thread.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fplatform_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fplatform_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplatform_thread.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -24,9 +24,15 @@ fn run(i: int) {\n         return;\n     }\n \n-    do task::task().sched_mode(task::PlatformThread).unlinked().spawn {\n+    let mut builder = task::task();\n+    builder.sched_mode(task::PlatformThread);\n+    builder.unlinked();\n+    do builder.spawn {\n         task::yield();\n-        do task::task().sched_mode(task::SingleThreaded).unlinked().spawn {\n+        let mut builder = task::task();\n+        builder.sched_mode(task::SingleThreaded);\n+        builder.unlinked();\n+        do builder.spawn {\n             task::yield();\n             run(i - 1);\n             task::yield();"}, {"sha": "5255c13bead62a2e689f5ed5db19fc2bf7ceef1b", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -633,7 +633,7 @@ impl TyVisitor for my_visitor {\n     fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n-fn get_tydesc_for<T>(&&_t: T) -> *TyDesc {\n+fn get_tydesc_for<T>(_t: T) -> *TyDesc {\n     get_tydesc::<T>()\n }\n "}, {"sha": "2e9ff88f96e90c9c57b79c3e3c40a90760182d74", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,7 +12,7 @@ struct closure_box<'self> {\n     cl: &'self fn(),\n }\n \n-fn box_it<'r>(+x: &'r fn()) -> closure_box<'r> {\n+fn box_it<'r>(x: &'r fn()) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "eab057548ef5e5d1ad7b2d82840bb7315cadd1fc", "filename": "src/test/run-pass/regions-static-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,7 +12,7 @@ struct closure_box<'self> {\n     cl: &'self fn(),\n }\n \n-fn box_it<'r>(+x: &'r fn()) -> closure_box<'r> {\n+fn box_it<'r>(x: &'r fn()) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "2a69b2ca01779edfe7de1305ef05e4baef2cba9f", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,7 +12,7 @@ use core::cell::Cell;\n \n pub fn main() { test05(); }\n \n-fn test05_start(&&f: ~fn(int)) {\n+fn test05_start(f: ~fn(int)) {\n     f(22);\n }\n "}, {"sha": "9a5131ef2300097acfedc1dca2ece305b224189c", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -17,4 +17,4 @@ pub fn main() {\n     task::spawn(|| child(10) );\n }\n \n-fn child(&&i: int) { error!(i); assert!((i == 10)); }\n+fn child(i: int) { error!(i); assert!((i == 10)); }"}, {"sha": "642babb5a1e5c0331727855eed839920d74ad075", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,7 +11,7 @@\n \n pub fn main() { task::spawn(|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)) ); }\n \n-fn child(&&args: (int, int, int, int, int, int, int, int, int)) {\n+fn child(args: (int, int, int, int, int, int, int, int, int)) {\n     let (i1, i2, i3, i4, i5, i6, i7, i8, i9) = args;\n     error!(i1);\n     error!(i2);"}, {"sha": "e06d09c564c00a538c268e005b6ffd1c5f3278ae", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -13,46 +13,46 @@\n // A trait for objects that can be used to do an if-then-else\n // (No actual need for this to be static, but it is a simple test.)\n trait bool_like {\n-    fn select<A>(b: Self, +x1: A, +x2: A) -> A;\n+    fn select<A>(b: Self, x1: A, x2: A) -> A;\n }\n \n fn andand<T:bool_like + Copy>(x1: T, x2: T) -> T {\n     bool_like::select(x1, x2, x1)\n }\n \n impl bool_like for bool {\n-    fn select<A>(&&b: bool, +x1: A, +x2: A) -> A {\n+    fn select<A>(b: bool, x1: A, x2: A) -> A {\n         if b { x1 } else { x2 }\n     }\n }\n \n impl bool_like for int {\n-    fn select<A>(&&b: int, +x1: A, +x2: A) -> A {\n+    fn select<A>(b: int, x1: A, x2: A) -> A {\n         if b != 0 { x1 } else { x2 }\n     }\n }\n \n // A trait for sequences that can be constructed imperatively.\n trait buildable<A> {\n-     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> Self;\n+     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> Self;\n }\n \n \n impl<A> buildable<A> for @[A] {\n     #[inline(always)]\n-     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> @[A] {\n+     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n          at_vec::build_sized(size, builder)\n      }\n }\n impl<A> buildable<A> for ~[A] {\n     #[inline(always)]\n-     fn build_sized(size: uint, builder: &fn(push: &fn(+v: A))) -> ~[A] {\n+     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n          vec::build_sized(size, builder)\n      }\n }\n \n #[inline(always)]\n-fn build<A, B: buildable<A>>(builder: &fn(push: &fn(+v: A))) -> B {\n+fn build<A, B: buildable<A>>(builder: &fn(push: &fn(v: A))) -> B {\n     buildable::build_sized(4, builder)\n }\n "}, {"sha": "7ac74fd52175f525917d126127d203e5484e1e1d", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -16,8 +16,8 @@ mod rustrt {\n \n     #[nolink]\n     pub extern {\n-        pub fn debug_abi_1(++q: Quad) -> Quad;\n-        pub fn debug_abi_2(++f: Floats) -> Floats;\n+        pub fn debug_abi_1(q: Quad) -> Quad;\n+        pub fn debug_abi_2(f: Floats) -> Floats;\n     }\n }\n "}, {"sha": "0f0b82d7c21df7ce7ca4fb045d5006f7d037fd03", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -12,12 +12,14 @@ extern mod std;\n \n pub fn main() { test00(); }\n \n-fn start(&&task_number: int) { debug!(\"Started / Finished task.\"); }\n+fn start(task_number: int) { debug!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n     let mut result = None;\n-    do task::task().future_result(|+r| { result = Some(r); }).spawn {\n+    let mut builder = task::task();\n+    builder.future_result(|r| result = Some(r));\n+    do builder.spawn {\n         start(i)\n     }\n "}, {"sha": "fd700475988cfe670f793e16218c866dcb735d40", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -40,9 +40,9 @@ fn test00() {\n     let mut results = ~[];\n     while i < number_of_tasks {\n         let ch = po.chan();\n-        task::task().future_result(|+r| {\n-            results.push(r);\n-        }).spawn({\n+        let mut builder = task::task();\n+        builder.future_result(|r| results.push(r));\n+        builder.spawn({\n             let i = i;\n             || test00_start(&ch, i, number_of_messages)\n         });"}, {"sha": "798e9d37b553469bf11f106167101ff74622918b", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -27,8 +27,9 @@ fn test00() {\n     let ch = p.chan();\n \n     let mut result = None;\n-    do task::task().future_result(|+r| { result = Some(r); }).spawn\n-          || {\n+    let mut builder = task::task();\n+    builder.future_result(|r| result = Some(r));\n+    do builder.spawn {\n         test00_start(&ch, number_of_messages);\n     }\n "}, {"sha": "9885c5d6f3fc0f9ed95942fd99c41339a1055f50", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -13,6 +13,6 @@ pub fn main() {\n     task::spawn(|| child(~\"Hello\") );\n }\n \n-fn child(&&s: ~str) {\n+fn child(s: ~str) {\n \n }"}, {"sha": "a72d3dd40f4caf8345aa2e8f79523b65a5d3aaab", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -18,4 +18,4 @@ pub fn main() {\n     debug!(\"main thread exiting\");\n }\n \n-fn child(&&x: int) { debug!(x); }\n+fn child(x: int) { debug!(x); }"}, {"sha": "4a6386244f17790a259c7d284510ace59bef7231", "filename": "src/test/run-pass/unique-fn-arg-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(+i: ~int) {\n+fn f(i: ~int) {\n     assert!(*i == 100);\n }\n "}, {"sha": "2d916abf0da698858680f1ab450909a583da6eff", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,7 +11,9 @@\n \n pub fn main() {\n     let mut result = None;\n-    task::task().future_result(|+r| { result = Some(r); }).spawn(child);\n+    let mut builder = task::task();\n+    builder.future_result(|r| { result = Some(r); });\n+    builder.spawn(child);\n     error!(\"1\");\n     task::yield();\n     error!(\"2\");"}, {"sha": "f3ca5b1211899145af5c195a048f0cfcb976c35d", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82d9874a6f88e0afa021796e9efaba5b3670c31/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=d82d9874a6f88e0afa021796e9efaba5b3670c31", "patch": "@@ -11,7 +11,9 @@\n \n pub fn main() {\n     let mut result = None;\n-    task::task().future_result(|+r| { result = Some(r); }).spawn(child);\n+    let mut builder = task::task();\n+    builder.future_result(|r| { result = Some(r); });\n+    builder.spawn(child);\n     error!(\"1\");\n     task::yield();\n     result.unwrap().recv();"}]}