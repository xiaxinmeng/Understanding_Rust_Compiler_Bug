{"sha": "68ee0337622f4025202687ccfac79c04d2046de8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZWUwMzM3NjIyZjQwMjUyMDI2ODdjY2ZhYzc5YzA0ZDIwNDZkZTg=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-09T07:53:09Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:02:46Z"}, "message": "URL doc outputs in hover", "tree": {"sha": "65f52f88ad89d3e969e8f766ef9cf8f75c173d5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65f52f88ad89d3e969e8f766ef9cf8f75c173d5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68ee0337622f4025202687ccfac79c04d2046de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68ee0337622f4025202687ccfac79c04d2046de8", "html_url": "https://github.com/rust-lang/rust/commit/68ee0337622f4025202687ccfac79c04d2046de8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68ee0337622f4025202687ccfac79c04d2046de8/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2023af53f09ed9466c6d7442d6830276eba19b45", "url": "https://api.github.com/repos/rust-lang/rust/commits/2023af53f09ed9466c6d7442d6830276eba19b45", "html_url": "https://github.com/rust-lang/rust/commit/2023af53f09ed9466c6d7442d6830276eba19b45"}], "stats": {"total": 84, "additions": 68, "deletions": 16}, "files": [{"sha": "fa925fc5a71287e61f36fb8f6e5ed41dea5ca48b", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68ee0337622f4025202687ccfac79c04d2046de8/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/68ee0337622f4025202687ccfac79c04d2046de8/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=68ee0337622f4025202687ccfac79c04d2046de8", "patch": "@@ -34,6 +34,7 @@ ra_assists = { path = \"../ra_assists\" }\n ra_ssr = { path = \"../ra_ssr\" }\n ra_project_model = { path = \"../ra_project_model\" }\n ra_hir_def = { path = \"../ra_hir_def\" }\n+ra_tt = { path = \"../ra_tt\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "91167e30a18145b4b13b8e357b6d2c980a3aa33d", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/68ee0337622f4025202687ccfac79c04d2046de8/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68ee0337622f4025202687ccfac79c04d2046de8/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=68ee0337622f4025202687ccfac79c04d2046de8", "patch": "@@ -2,7 +2,7 @@ use std::iter::once;\n \n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics, Module, Documentation\n+    ModuleSource, Semantics, Module, Documentation, AttrDef, Crate\n };\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n@@ -13,6 +13,7 @@ use ra_ide_db::{\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n use ra_project_model::ProjectWorkspace;\n use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase, ModuleDefId};\n+use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf, Subtree, SmolStr};\n \n use crate::{\n     display::{\n@@ -415,7 +416,7 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, wor\n                         // If contains ::               module-based link\n                         Err(_) => {\n                             let link_str = String::from_utf8(link.url.clone()).unwrap();\n-                            let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str)\n+                            let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str, UrlMode::Url)\n                                 .or_else(|| try_resolve_intra(db, &mut doc_target_dirs.clone(), definition, &link_str));\n \n                             if let Some(resolved) = resolved {\n@@ -442,27 +443,77 @@ fn try_resolve_intra(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pa\n     None\n }\n \n+enum UrlMode {\n+    Url,\n+    File\n+}\n+\n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`)\n-fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link: &str) -> Option<String> {\n+fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link: &str, mode: UrlMode) -> Option<String> {\n     let ns = if let Definition::ModuleDef(moddef) = definition {\n         ItemInNs::Types(moddef.clone().into())\n     } else {\n         return None;\n     };\n-    let krate = definition.module(db)?.krate();\n+    let module = definition.module(db)?;\n+    let krate = module.krate();\n     let import_map = db.import_map(krate.into());\n-    let base = import_map.path_of(ns).unwrap();\n-    let base = base.segments.iter().map(|name| format!(\"{}\", name)).collect::<PathBuf>();\n-\n-    doc_target_dirs\n-        .map(|dir| dir.join(format!(\"{}\", krate.display_name(db).unwrap())).join(base.join(\"..\").join(link)))\n-        .inspect(|path| eprintln!(\"candidate {}\", path.display()))\n-        .filter(|path| path.exists())\n-        // slice out the UNC '\\?\\' added by canonicalize\n-        .map(|path| format!(\"file:///{}\", path.display()))\n-        // \\. is treated as an escape in vscode's markdown hover rendering\n-        .map(|path_str| path_str.replace(\"\\\\\", \"/\"))\n-        .next()\n+    // TODO: It should be possible to fall back to not-necessarilly-public paths if we can't find a public one,\n+    // then hope rustdoc was run locally with `--document-private-items`\n+    let base = import_map.path_of(ns)?;\n+    let mut base = once(format!(\"{}\", krate.display_name(db)?)).chain(base.segments.iter().map(|name| format!(\"{}\", name)));\n+\n+    match mode {\n+        UrlMode::Url => {\n+            let root = get_doc_url(db, &krate);\n+            let mut base = base.join(\"/\");\n+            if let Some(url) = root {\n+                eprintln!(\"root: {:?} base: {:?} link: {} root&base: {} root&base&link: {}\", url, &base, link, url.join(&base).unwrap(), url.join(&base).unwrap().join(link).unwrap());\n+                if link.starts_with(\"#\") {\n+                    base = base + \"/\"\n+                };\n+                Some(url.join(&base)?.join(link)?.into_string())\n+            } else {None}\n+        },\n+        UrlMode::File => {\n+            let base = base.collect::<PathBuf>();\n+            doc_target_dirs\n+                .map(|dir| dir.join(format!(\"{}\", krate.display_name(db).unwrap())).join(base.join(\"..\").join(link)))\n+                .inspect(|path| eprintln!(\"candidate {}\", path.display()))\n+                .filter(|path| path.exists())\n+                .map(|path| format!(\"file:///{}\", path.display()))\n+                // \\. is treated as an escape in vscode's markdown hover rendering\n+                .map(|path_str| path_str.replace(\"\\\\\", \"/\"))\n+                .next()\n+        }\n+    }\n+}\n+\n+/// Try to get the root URL of the documentation of a crate.\n+fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+    // Look for #![doc(html_root_url = \"https://docs.rs/...\")]\n+    let attrs = db.attrs(AttrDef::from(krate.root_module(db)?).into());\n+    let doc_attr_q = attrs.by_key(\"doc\");\n+    let doc_url = if doc_attr_q.exists() {\n+        doc_attr_q.tt_values().filter_map(|tt| match tt.token_trees.as_slice() {\n+            &[\n+                TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident_text, ..})),\n+                TokenTree::Leaf(Leaf::Punct(Punct{r#char: '=', ..})),\n+                TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))\n+            ] if ident_text == \"html_root_url\" => Some(text),\n+            _ => {\n+                None\n+            }\n+        }).next()\n+    } else {\n+        None\n+    };\n+    eprintln!(\"url {:?}\", doc_url);\n+\n+    // TODO: It should be possible to fallback to `format!(\"https://docs.rs/{}/*\", crate_name, *)`\n+    let url = doc_url.map(|s| s.trim_matches('\"').to_owned() + \"/\").and_then(|s| Url::parse(&s).ok());\n+    eprintln!(\"url {:?}\", url);\n+    url\n }\n \n fn iter_nodes<'a, F>(node: &'a comrak::nodes::AstNode<'a>, f: &F)"}]}