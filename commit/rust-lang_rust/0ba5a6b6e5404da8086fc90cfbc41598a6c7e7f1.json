{"sha": "0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYTVhNmI2ZTU0MDRkYTgwODZmYzkwY2ZiYzQxNTk4YTZjN2U3ZjE=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T05:47:12Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:32:14Z"}, "message": "Moved all Adt* types to adt.rs", "tree": {"sha": "d0bbfcad8708535d4b2a1f852048251bcd89470c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0bbfcad8708535d4b2a1f852048251bcd89470c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "html_url": "https://github.com/rust-lang/rust/commit/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "html_url": "https://github.com/rust-lang/rust/commit/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c"}], "stats": {"total": 955, "additions": 488, "deletions": 467}, "files": [{"sha": "95159ea46aec3e9950150c87cbc4aeaf0f287ca0", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "patch": "@@ -0,0 +1,482 @@\n+use crate::ich::StableHashingContext;\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty;\n+use crate::ty::util::{Discr, IntTypeExt};\n+use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_session::DataTypeKind;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::VariantIdx;\n+\n+use std::cell::RefCell;\n+use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher};\n+use std::ops::Range;\n+use std::{ptr, str};\n+\n+use super::{\n+    Destructor, FieldDef, GenericPredicates, ReprOptions, Ty, TyCtxt, VariantDef, VariantDiscr,\n+};\n+\n+#[derive(Clone, HashStable, Debug)]\n+pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n+\n+bitflags! {\n+    #[derive(HashStable)]\n+    pub struct AdtFlags: u32 {\n+        const NO_ADT_FLAGS        = 0;\n+        /// Indicates whether the ADT is an enum.\n+        const IS_ENUM             = 1 << 0;\n+        /// Indicates whether the ADT is a union.\n+        const IS_UNION            = 1 << 1;\n+        /// Indicates whether the ADT is a struct.\n+        const IS_STRUCT           = 1 << 2;\n+        /// Indicates whether the ADT is a struct and has a constructor.\n+        const HAS_CTOR            = 1 << 3;\n+        /// Indicates whether the type is `PhantomData`.\n+        const IS_PHANTOM_DATA     = 1 << 4;\n+        /// Indicates whether the type has a `#[fundamental]` attribute.\n+        const IS_FUNDAMENTAL      = 1 << 5;\n+        /// Indicates whether the type is `Box`.\n+        const IS_BOX              = 1 << 6;\n+        /// Indicates whether the type is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP    = 1 << 7;\n+        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n+        /// (i.e., this flag is never set unless this ADT is an enum).\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n+    }\n+}\n+\n+/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n+///\n+/// These are all interned (by `alloc_adt_def`) into the global arena.\n+///\n+/// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n+/// This is slightly wrong because `union`s are not ADTs.\n+/// Moreover, Rust only allows recursive data types through indirection.\n+///\n+/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+pub struct AdtDef {\n+    /// The `DefId` of the struct, enum or union item.\n+    pub did: DefId,\n+    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n+    pub variants: IndexVec<VariantIdx, VariantDef>,\n+    /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n+    flags: AdtFlags,\n+    /// Repr options provided by the user.\n+    pub repr: ReprOptions,\n+}\n+\n+impl PartialOrd for AdtDef {\n+    fn partial_cmp(&self, other: &AdtDef) -> Option<Ordering> {\n+        Some(self.cmp(&other))\n+    }\n+}\n+\n+/// There should be only one AdtDef for each `did`, therefore\n+/// it is fine to implement `Ord` only based on `did`.\n+impl Ord for AdtDef {\n+    fn cmp(&self, other: &AdtDef) -> Ordering {\n+        self.did.cmp(&other.did)\n+    }\n+}\n+\n+impl PartialEq for AdtDef {\n+    // `AdtDef`s are always interned, and this is part of `TyS` equality.\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        ptr::eq(self, other)\n+    }\n+}\n+\n+impl Eq for AdtDef {}\n+\n+impl Hash for AdtDef {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const AdtDef).hash(s)\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for AdtDef {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.did.encode(s)\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        thread_local! {\n+            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n+        }\n+\n+        let hash: Fingerprint = CACHE.with(|cache| {\n+            let addr = self as *const AdtDef as usize;\n+            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n+                let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n+\n+                let mut hasher = StableHasher::new();\n+                did.hash_stable(hcx, &mut hasher);\n+                variants.hash_stable(hcx, &mut hasher);\n+                flags.hash_stable(hcx, &mut hasher);\n+                repr.hash_stable(hcx, &mut hasher);\n+\n+                hasher.finish()\n+            })\n+        });\n+\n+        hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum AdtKind {\n+    Struct,\n+    Union,\n+    Enum,\n+}\n+\n+impl Into<DataTypeKind> for AdtKind {\n+    fn into(self) -> DataTypeKind {\n+        match self {\n+            AdtKind::Struct => DataTypeKind::Struct,\n+            AdtKind::Union => DataTypeKind::Union,\n+            AdtKind::Enum => DataTypeKind::Enum,\n+        }\n+    }\n+}\n+\n+impl<'tcx> AdtDef {\n+    /// Creates a new `AdtDef`.\n+    pub(super) fn new(\n+        tcx: TyCtxt<'_>,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, VariantDef>,\n+        repr: ReprOptions,\n+    ) -> Self {\n+        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n+        let mut flags = AdtFlags::NO_ADT_FLAGS;\n+\n+        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n+        }\n+\n+        flags |= match kind {\n+            AdtKind::Enum => AdtFlags::IS_ENUM,\n+            AdtKind::Union => AdtFlags::IS_UNION,\n+            AdtKind::Struct => AdtFlags::IS_STRUCT,\n+        };\n+\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n+            flags |= AdtFlags::HAS_CTOR;\n+        }\n+\n+        let attrs = tcx.get_attrs(did);\n+        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n+            flags |= AdtFlags::IS_FUNDAMENTAL;\n+        }\n+        if Some(did) == tcx.lang_items().phantom_data() {\n+            flags |= AdtFlags::IS_PHANTOM_DATA;\n+        }\n+        if Some(did) == tcx.lang_items().owned_box() {\n+            flags |= AdtFlags::IS_BOX;\n+        }\n+        if Some(did) == tcx.lang_items().manually_drop() {\n+            flags |= AdtFlags::IS_MANUALLY_DROP;\n+        }\n+\n+        AdtDef { did, variants, flags, repr }\n+    }\n+\n+    /// Returns `true` if this is a struct.\n+    #[inline]\n+    pub fn is_struct(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_STRUCT)\n+    }\n+\n+    /// Returns `true` if this is a union.\n+    #[inline]\n+    pub fn is_union(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_UNION)\n+    }\n+\n+    /// Returns `true` if this is a enum.\n+    #[inline]\n+    pub fn is_enum(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_ENUM)\n+    }\n+\n+    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n+    #[inline]\n+    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+    }\n+\n+    /// Returns the kind of the ADT.\n+    #[inline]\n+    pub fn adt_kind(&self) -> AdtKind {\n+        if self.is_enum() {\n+            AdtKind::Enum\n+        } else if self.is_union() {\n+            AdtKind::Union\n+        } else {\n+            AdtKind::Struct\n+        }\n+    }\n+\n+    /// Returns a description of this abstract data type.\n+    pub fn descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"enum\",\n+        }\n+    }\n+\n+    /// Returns a description of a variant of this abstract data type.\n+    #[inline]\n+    pub fn variant_descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"variant\",\n+        }\n+    }\n+\n+    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n+    #[inline]\n+    pub fn has_ctor(&self) -> bool {\n+        self.flags.contains(AdtFlags::HAS_CTOR)\n+    }\n+\n+    /// Returns `true` if this type is `#[fundamental]` for the purposes\n+    /// of coherence checking.\n+    #[inline]\n+    pub fn is_fundamental(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n+    }\n+\n+    /// Returns `true` if this is `PhantomData<T>`.\n+    #[inline]\n+    pub fn is_phantom_data(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n+    }\n+\n+    /// Returns `true` if this is Box<T>.\n+    #[inline]\n+    pub fn is_box(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_BOX)\n+    }\n+\n+    /// Returns `true` if this is `ManuallyDrop<T>`.\n+    #[inline]\n+    pub fn is_manually_drop(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    }\n+\n+    /// Returns `true` if this type has a destructor.\n+    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.destructor(tcx).is_some()\n+    }\n+\n+    /// Asserts this is a struct or union and returns its unique variant.\n+    pub fn non_enum_variant(&self) -> &VariantDef {\n+        assert!(self.is_struct() || self.is_union());\n+        &self.variants[VariantIdx::new(0)]\n+    }\n+\n+    #[inline]\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n+        tcx.predicates_of(self.did)\n+    }\n+\n+    /// Returns an iterator over all fields contained\n+    /// by this ADT.\n+    #[inline]\n+    pub fn all_fields(&self) -> impl Iterator<Item = &FieldDef> + Clone {\n+        self.variants.iter().flat_map(|v| v.fields.iter())\n+    }\n+\n+    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n+    /// e.g., `enum Void {}` is considered payload free as well.\n+    pub fn is_payloadfree(&self) -> bool {\n+        self.variants.iter().all(|v| v.fields.is_empty())\n+    }\n+\n+    /// Return a `VariantDef` given a variant id.\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n+        self.variants.iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n+    }\n+\n+    /// Return a `VariantDef` given a constructor id.\n+    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n+        self.variants\n+            .iter()\n+            .find(|v| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_with_ctor_id: unknown variant\")\n+    }\n+\n+    /// Return the index of `VariantDef` given a variant id.\n+    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.def_id == vid)\n+            .expect(\"variant_index_with_id: unknown variant\")\n+            .0\n+    }\n+\n+    /// Return the index of `VariantDef` given a constructor id.\n+    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_index_with_ctor_id: unknown variant\")\n+            .0\n+    }\n+\n+    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n+        match res {\n+            Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n+            Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::TyAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::SelfTy(..)\n+            | Res::SelfCtor(..) => self.non_enum_variant(),\n+            _ => bug!(\"unexpected res {:?} in variant_of_res\", res),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+        assert!(self.is_enum());\n+        let param_env = tcx.param_env(expr_did);\n+        let repr_type = self.repr.discr_type();\n+        match tcx.const_eval_poly(expr_did) {\n+            Ok(val) => {\n+                let ty = repr_type.to_ty(tcx);\n+                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n+                    trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                    Some(Discr { val: b, ty })\n+                } else {\n+                    info!(\"invalid enum discriminant: {:#?}\", val);\n+                    crate::mir::interpret::struct_error(\n+                        tcx.at(tcx.def_span(expr_did)),\n+                        \"constant evaluation of enum discriminant resulted in non-integer\",\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            }\n+            Err(err) => {\n+                let msg = match err {\n+                    ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n+                        \"enum discriminant evaluation failed\"\n+                    }\n+                    ErrorHandled::TooGeneric => \"enum discriminant depends on generics\",\n+                };\n+                tcx.sess.delay_span_bug(tcx.def_span(expr_did), msg);\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn discriminants(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n+        assert!(self.is_enum());\n+        let repr_type = self.repr.discr_type();\n+        let initial = repr_type.initial_discriminant(tcx);\n+        let mut prev_discr = None::<Discr<'tcx>>;\n+        self.variants.iter_enumerated().map(move |(i, v)| {\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n+            if let VariantDiscr::Explicit(expr_did) = v.discr {\n+                if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n+                    discr = new_discr;\n+                }\n+            }\n+            prev_discr = Some(discr);\n+\n+            (i, discr)\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn variant_range(&self) -> Range<VariantIdx> {\n+        VariantIdx::new(0)..VariantIdx::new(self.variants.len())\n+    }\n+\n+    /// Computes the discriminant value used by a specific variant.\n+    /// Unlike `discriminants`, this is (amortized) constant-time,\n+    /// only doing at most one query for evaluating an explicit\n+    /// discriminant (the last one before the requested variant),\n+    /// assuming there are no constant-evaluation errors there.\n+    #[inline]\n+    pub fn discriminant_for_variant(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Discr<'tcx> {\n+        assert!(self.is_enum());\n+        let (val, offset) = self.discriminant_def_for_variant(variant_index);\n+        let explicit_value = val\n+            .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n+            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n+        explicit_value.checked_add(tcx, offset as u128).0\n+    }\n+\n+    /// Yields a `DefId` for the discriminant and an offset to add to it\n+    /// Alternatively, if there is no explicit discriminant, returns the\n+    /// inferred discriminant directly.\n+    pub fn discriminant_def_for_variant(&self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n+        assert!(!self.variants.is_empty());\n+        let mut explicit_index = variant_index.as_u32();\n+        let expr_did;\n+        loop {\n+            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n+                ty::VariantDiscr::Relative(0) => {\n+                    expr_did = None;\n+                    break;\n+                }\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(did) => {\n+                    expr_did = Some(did);\n+                    break;\n+                }\n+            }\n+        }\n+        (expr_did, variant_index.as_u32() - explicit_index)\n+    }\n+\n+    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n+        tcx.adt_destructor(self.did)\n+    }\n+\n+    /// Returns a list of types such that `Self: Sized` if and only\n+    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n+    ///\n+    /// Oddly enough, checking that the sized-constraint is `Sized` is\n+    /// actually more expressive than checking all members:\n+    /// the `Sized` trait is inductive, so an associated type that references\n+    /// `Self` would prevent its containing ADT from being `Sized`.\n+    ///\n+    /// Due to normalization being eager, this applies even if\n+    /// the associated type is behind a pointer (e.g., issue #31299).\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n+        tcx.adt_sized_constraint(self.did).0\n+    }\n+}"}, {"sha": "785d96b5adaa6e78c7d5e990f43321860e7ceeca", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 467, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0ba5a6b6e5404da8086fc90cfbc41598a6c7e7f1", "patch": "@@ -14,6 +14,7 @@ pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n+pub use adt::*;\n pub use assoc::*;\n pub use generics::*;\n pub use upvar::*;\n@@ -24,39 +25,32 @@ use crate::hir::place::{\n };\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n-use crate::mir::interpret::ErrorHandled;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::util::{Discr, IntTypeExt};\n+use crate::ty::util::Discr;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, ParallelIterator};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Constness, Node};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n-use rustc_serialize::{self, Encodable, Encoder};\n-use rustc_session::DataTypeKind;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::Align;\n \n-use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n-use std::ops::{ControlFlow, Range};\n+use std::ops::ControlFlow;\n use std::{fmt, ptr, str};\n \n pub use crate::ty::diagnostics::*;\n@@ -107,6 +101,7 @@ pub mod trait_def;\n pub mod util;\n pub mod walk;\n \n+mod adt;\n mod assoc;\n mod consts;\n mod context;\n@@ -1447,32 +1442,6 @@ pub struct Destructor {\n     pub did: DefId,\n }\n \n-bitflags! {\n-    #[derive(HashStable)]\n-    pub struct AdtFlags: u32 {\n-        const NO_ADT_FLAGS        = 0;\n-        /// Indicates whether the ADT is an enum.\n-        const IS_ENUM             = 1 << 0;\n-        /// Indicates whether the ADT is a union.\n-        const IS_UNION            = 1 << 1;\n-        /// Indicates whether the ADT is a struct.\n-        const IS_STRUCT           = 1 << 2;\n-        /// Indicates whether the ADT is a struct and has a constructor.\n-        const HAS_CTOR            = 1 << 3;\n-        /// Indicates whether the type is `PhantomData`.\n-        const IS_PHANTOM_DATA     = 1 << 4;\n-        /// Indicates whether the type has a `#[fundamental]` attribute.\n-        const IS_FUNDAMENTAL      = 1 << 5;\n-        /// Indicates whether the type is `Box`.\n-        const IS_BOX              = 1 << 6;\n-        /// Indicates whether the type is `ManuallyDrop`.\n-        const IS_MANUALLY_DROP    = 1 << 7;\n-        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n-        /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n-    }\n-}\n-\n bitflags! {\n     #[derive(HashStable)]\n     pub struct VariantFlags: u32 {\n@@ -1596,105 +1565,6 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n-///\n-/// These are all interned (by `alloc_adt_def`) into the global arena.\n-///\n-/// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n-/// This is slightly wrong because `union`s are not ADTs.\n-/// Moreover, Rust only allows recursive data types through indirection.\n-///\n-/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n-pub struct AdtDef {\n-    /// The `DefId` of the struct, enum or union item.\n-    pub did: DefId,\n-    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n-    pub variants: IndexVec<VariantIdx, VariantDef>,\n-    /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n-    flags: AdtFlags,\n-    /// Repr options provided by the user.\n-    pub repr: ReprOptions,\n-}\n-\n-impl PartialOrd for AdtDef {\n-    fn partial_cmp(&self, other: &AdtDef) -> Option<Ordering> {\n-        Some(self.cmp(&other))\n-    }\n-}\n-\n-/// There should be only one AdtDef for each `did`, therefore\n-/// it is fine to implement `Ord` only based on `did`.\n-impl Ord for AdtDef {\n-    fn cmp(&self, other: &AdtDef) -> Ordering {\n-        self.did.cmp(&other.did)\n-    }\n-}\n-\n-impl PartialEq for AdtDef {\n-    // `AdtDef`s are always interned, and this is part of `TyS` equality.\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-\n-impl Eq for AdtDef {}\n-\n-impl Hash for AdtDef {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const AdtDef).hash(s)\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for AdtDef {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.did.encode(s)\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        thread_local! {\n-            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n-        }\n-\n-        let hash: Fingerprint = CACHE.with(|cache| {\n-            let addr = self as *const AdtDef as usize;\n-            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n-                let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n-\n-                let mut hasher = StableHasher::new();\n-                did.hash_stable(hcx, &mut hasher);\n-                variants.hash_stable(hcx, &mut hasher);\n-                flags.hash_stable(hcx, &mut hasher);\n-                repr.hash_stable(hcx, &mut hasher);\n-\n-                hasher.finish()\n-            })\n-        });\n-\n-        hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n-pub enum AdtKind {\n-    Struct,\n-    Union,\n-    Enum,\n-}\n-\n-impl Into<DataTypeKind> for AdtKind {\n-    fn into(self) -> DataTypeKind {\n-        match self {\n-            AdtKind::Struct => DataTypeKind::Struct,\n-            AdtKind::Union => DataTypeKind::Union,\n-            AdtKind::Enum => DataTypeKind::Enum,\n-        }\n-    }\n-}\n-\n bitflags! {\n     #[derive(TyEncodable, TyDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {\n@@ -1817,334 +1687,6 @@ impl ReprOptions {\n     }\n }\n \n-impl<'tcx> AdtDef {\n-    /// Creates a new `AdtDef`.\n-    fn new(\n-        tcx: TyCtxt<'_>,\n-        did: DefId,\n-        kind: AdtKind,\n-        variants: IndexVec<VariantIdx, VariantDef>,\n-        repr: ReprOptions,\n-    ) -> Self {\n-        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n-        let mut flags = AdtFlags::NO_ADT_FLAGS;\n-\n-        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n-            debug!(\"found non-exhaustive variant list for {:?}\", did);\n-            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n-        }\n-\n-        flags |= match kind {\n-            AdtKind::Enum => AdtFlags::IS_ENUM,\n-            AdtKind::Union => AdtFlags::IS_UNION,\n-            AdtKind::Struct => AdtFlags::IS_STRUCT,\n-        };\n-\n-        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n-            flags |= AdtFlags::HAS_CTOR;\n-        }\n-\n-        let attrs = tcx.get_attrs(did);\n-        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n-            flags |= AdtFlags::IS_FUNDAMENTAL;\n-        }\n-        if Some(did) == tcx.lang_items().phantom_data() {\n-            flags |= AdtFlags::IS_PHANTOM_DATA;\n-        }\n-        if Some(did) == tcx.lang_items().owned_box() {\n-            flags |= AdtFlags::IS_BOX;\n-        }\n-        if Some(did) == tcx.lang_items().manually_drop() {\n-            flags |= AdtFlags::IS_MANUALLY_DROP;\n-        }\n-\n-        AdtDef { did, variants, flags, repr }\n-    }\n-\n-    /// Returns `true` if this is a struct.\n-    #[inline]\n-    pub fn is_struct(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_STRUCT)\n-    }\n-\n-    /// Returns `true` if this is a union.\n-    #[inline]\n-    pub fn is_union(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_UNION)\n-    }\n-\n-    /// Returns `true` if this is a enum.\n-    #[inline]\n-    pub fn is_enum(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_ENUM)\n-    }\n-\n-    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n-    #[inline]\n-    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n-    }\n-\n-    /// Returns the kind of the ADT.\n-    #[inline]\n-    pub fn adt_kind(&self) -> AdtKind {\n-        if self.is_enum() {\n-            AdtKind::Enum\n-        } else if self.is_union() {\n-            AdtKind::Union\n-        } else {\n-            AdtKind::Struct\n-        }\n-    }\n-\n-    /// Returns a description of this abstract data type.\n-    pub fn descr(&self) -> &'static str {\n-        match self.adt_kind() {\n-            AdtKind::Struct => \"struct\",\n-            AdtKind::Union => \"union\",\n-            AdtKind::Enum => \"enum\",\n-        }\n-    }\n-\n-    /// Returns a description of a variant of this abstract data type.\n-    #[inline]\n-    pub fn variant_descr(&self) -> &'static str {\n-        match self.adt_kind() {\n-            AdtKind::Struct => \"struct\",\n-            AdtKind::Union => \"union\",\n-            AdtKind::Enum => \"variant\",\n-        }\n-    }\n-\n-    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n-    #[inline]\n-    pub fn has_ctor(&self) -> bool {\n-        self.flags.contains(AdtFlags::HAS_CTOR)\n-    }\n-\n-    /// Returns `true` if this type is `#[fundamental]` for the purposes\n-    /// of coherence checking.\n-    #[inline]\n-    pub fn is_fundamental(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n-    }\n-\n-    /// Returns `true` if this is `PhantomData<T>`.\n-    #[inline]\n-    pub fn is_phantom_data(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n-    }\n-\n-    /// Returns `true` if this is Box<T>.\n-    #[inline]\n-    pub fn is_box(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_BOX)\n-    }\n-\n-    /// Returns `true` if this is `ManuallyDrop<T>`.\n-    #[inline]\n-    pub fn is_manually_drop(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n-    }\n-\n-    /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        self.destructor(tcx).is_some()\n-    }\n-\n-    /// Asserts this is a struct or union and returns its unique variant.\n-    pub fn non_enum_variant(&self) -> &VariantDef {\n-        assert!(self.is_struct() || self.is_union());\n-        &self.variants[VariantIdx::new(0)]\n-    }\n-\n-    #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n-        tcx.predicates_of(self.did)\n-    }\n-\n-    /// Returns an iterator over all fields contained\n-    /// by this ADT.\n-    #[inline]\n-    pub fn all_fields(&self) -> impl Iterator<Item = &FieldDef> + Clone {\n-        self.variants.iter().flat_map(|v| v.fields.iter())\n-    }\n-\n-    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n-    /// e.g., `enum Void {}` is considered payload free as well.\n-    pub fn is_payloadfree(&self) -> bool {\n-        self.variants.iter().all(|v| v.fields.is_empty())\n-    }\n-\n-    /// Return a `VariantDef` given a variant id.\n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n-        self.variants.iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n-    }\n-\n-    /// Return a `VariantDef` given a constructor id.\n-    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n-        self.variants\n-            .iter()\n-            .find(|v| v.ctor_def_id == Some(cid))\n-            .expect(\"variant_with_ctor_id: unknown variant\")\n-    }\n-\n-    /// Return the index of `VariantDef` given a variant id.\n-    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.def_id == vid)\n-            .expect(\"variant_index_with_id: unknown variant\")\n-            .0\n-    }\n-\n-    /// Return the index of `VariantDef` given a constructor id.\n-    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.ctor_def_id == Some(cid))\n-            .expect(\"variant_index_with_ctor_id: unknown variant\")\n-            .0\n-    }\n-\n-    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n-        match res {\n-            Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n-            Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n-            Res::Def(DefKind::Struct, _)\n-            | Res::Def(DefKind::Union, _)\n-            | Res::Def(DefKind::TyAlias, _)\n-            | Res::Def(DefKind::AssocTy, _)\n-            | Res::SelfTy(..)\n-            | Res::SelfCtor(..) => self.non_enum_variant(),\n-            _ => bug!(\"unexpected res {:?} in variant_of_res\", res),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n-        assert!(self.is_enum());\n-        let param_env = tcx.param_env(expr_did);\n-        let repr_type = self.repr.discr_type();\n-        match tcx.const_eval_poly(expr_did) {\n-            Ok(val) => {\n-                let ty = repr_type.to_ty(tcx);\n-                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n-                    trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                    Some(Discr { val: b, ty })\n-                } else {\n-                    info!(\"invalid enum discriminant: {:#?}\", val);\n-                    crate::mir::interpret::struct_error(\n-                        tcx.at(tcx.def_span(expr_did)),\n-                        \"constant evaluation of enum discriminant resulted in non-integer\",\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            }\n-            Err(err) => {\n-                let msg = match err {\n-                    ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                        \"enum discriminant evaluation failed\"\n-                    }\n-                    ErrorHandled::TooGeneric => \"enum discriminant depends on generics\",\n-                };\n-                tcx.sess.delay_span_bug(tcx.def_span(expr_did), msg);\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn discriminants(\n-        &'tcx self,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n-        assert!(self.is_enum());\n-        let repr_type = self.repr.discr_type();\n-        let initial = repr_type.initial_discriminant(tcx);\n-        let mut prev_discr = None::<Discr<'tcx>>;\n-        self.variants.iter_enumerated().map(move |(i, v)| {\n-            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n-            if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n-                    discr = new_discr;\n-                }\n-            }\n-            prev_discr = Some(discr);\n-\n-            (i, discr)\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn variant_range(&self) -> Range<VariantIdx> {\n-        VariantIdx::new(0)..VariantIdx::new(self.variants.len())\n-    }\n-\n-    /// Computes the discriminant value used by a specific variant.\n-    /// Unlike `discriminants`, this is (amortized) constant-time,\n-    /// only doing at most one query for evaluating an explicit\n-    /// discriminant (the last one before the requested variant),\n-    /// assuming there are no constant-evaluation errors there.\n-    #[inline]\n-    pub fn discriminant_for_variant(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        variant_index: VariantIdx,\n-    ) -> Discr<'tcx> {\n-        assert!(self.is_enum());\n-        let (val, offset) = self.discriminant_def_for_variant(variant_index);\n-        let explicit_value = val\n-            .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n-            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n-        explicit_value.checked_add(tcx, offset as u128).0\n-    }\n-\n-    /// Yields a `DefId` for the discriminant and an offset to add to it\n-    /// Alternatively, if there is no explicit discriminant, returns the\n-    /// inferred discriminant directly.\n-    pub fn discriminant_def_for_variant(&self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n-        assert!(!self.variants.is_empty());\n-        let mut explicit_index = variant_index.as_u32();\n-        let expr_did;\n-        loop {\n-            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n-                ty::VariantDiscr::Relative(0) => {\n-                    expr_did = None;\n-                    break;\n-                }\n-                ty::VariantDiscr::Relative(distance) => {\n-                    explicit_index -= distance;\n-                }\n-                ty::VariantDiscr::Explicit(did) => {\n-                    expr_did = Some(did);\n-                    break;\n-                }\n-            }\n-        }\n-        (expr_did, variant_index.as_u32() - explicit_index)\n-    }\n-\n-    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n-        tcx.adt_destructor(self.did)\n-    }\n-\n-    /// Returns a list of types such that `Self: Sized` if and only\n-    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n-    ///\n-    /// Oddly enough, checking that the sized-constraint is `Sized` is\n-    /// actually more expressive than checking all members:\n-    /// the `Sized` trait is inductive, so an associated type that references\n-    /// `Self` would prevent its containing ADT from being `Sized`.\n-    ///\n-    /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n-        tcx.adt_sized_constraint(self.did).0\n-    }\n-}\n-\n impl<'tcx> FieldDef {\n     /// Returns the type of this field. The `subst` is typically obtained\n     /// via the second field of `TyKind::AdtDef`.\n@@ -2597,9 +2139,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-#[derive(Clone, HashStable, Debug)]\n-pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n-\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(def_id) = def_id.as_local() {"}]}