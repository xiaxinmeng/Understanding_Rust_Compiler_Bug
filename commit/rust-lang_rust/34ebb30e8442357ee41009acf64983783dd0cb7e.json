{"sha": "34ebb30e8442357ee41009acf64983783dd0cb7e", "node_id": "C_kwDOAAsO6NoAKDM0ZWJiMzBlODQ0MjM1N2VlNDEwMDlhY2Y2NDk4Mzc4M2RkMGNiN2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-22T09:36:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-22T09:36:38Z"}, "message": "Auto merge of #14610 - lowr:fix/hygiene-for-meta-item, r=Veykril\n\nfix: Resolve `$crate` in derive paths\n\nPaths in derive meta item list may contain any kind of paths, including those that start with `$crate` generated by macros. We need to take hygiene into account when we lower paths in the list.\n\nThis issue was identified while investigating #14607, though this patch doesn't fix the broken trait resolution.", "tree": {"sha": "4e9c45b8f616de694453f762d923cbedd5e95f47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e9c45b8f616de694453f762d923cbedd5e95f47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34ebb30e8442357ee41009acf64983783dd0cb7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34ebb30e8442357ee41009acf64983783dd0cb7e", "html_url": "https://github.com/rust-lang/rust/commit/34ebb30e8442357ee41009acf64983783dd0cb7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34ebb30e8442357ee41009acf64983783dd0cb7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f43a5620120f54c5012f8a35f352cb2fbccb717", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f43a5620120f54c5012f8a35f352cb2fbccb717", "html_url": "https://github.com/rust-lang/rust/commit/6f43a5620120f54c5012f8a35f352cb2fbccb717"}, {"sha": "85e76542fe4302482ce91fcb1d193cd6f374676a", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e76542fe4302482ce91fcb1d193cd6f374676a", "html_url": "https://github.com/rust-lang/rust/commit/85e76542fe4302482ce91fcb1d193cd6f374676a"}], "stats": {"total": 93, "additions": 76, "deletions": 17}, "files": [{"sha": "ba93b2c70ef0a8588d4f09c6a19597dab65ac339", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=34ebb30e8442357ee41009acf64983783dd0cb7e", "patch": "@@ -14,6 +14,7 @@ use hir_expand::{\n     builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     proc_macro::ProcMacroExpander,\n     ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc,\n@@ -122,6 +123,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         from_glob_import: Default::default(),\n         skip_attrs: Default::default(),\n         is_proc_macro,\n+        hygienes: FxHashMap::default(),\n     };\n     if tree_id.is_block() {\n         collector.seed_with_inner(tree_id);\n@@ -269,6 +271,12 @@ struct DefCollector<'a> {\n     /// This also stores the attributes to skip when we resolve derive helpers and non-macro\n     /// non-builtin attributes in general.\n     skip_attrs: FxHashMap<InFile<ModItem>, AttrId>,\n+    /// `Hygiene` cache, because `Hygiene` construction is expensive.\n+    ///\n+    /// Almost all paths should have been lowered to `ModPath` during `ItemTree` construction.\n+    /// However, `DefCollector` still needs to lower paths in attributes, in particular those in\n+    /// derive meta item list.\n+    hygienes: FxHashMap<HirFileId, Hygiene>,\n }\n \n impl DefCollector<'_> {\n@@ -312,13 +320,15 @@ impl DefCollector<'_> {\n                 }\n \n                 if *attr_name == hir_expand::name![feature] {\n-                    let features =\n-                        attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n-                            |feat| match feat.segments() {\n-                                [name] => Some(name.to_smol_str()),\n-                                _ => None,\n-                            },\n-                        );\n+                    let hygiene = &Hygiene::new_unhygienic();\n+                    let features = attr\n+                        .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n+                        .into_iter()\n+                        .flatten()\n+                        .filter_map(|feat| match feat.segments() {\n+                            [name] => Some(name.to_smol_str()),\n+                            _ => None,\n+                        });\n                     self.def_map.unstable_features.extend(features);\n                 }\n \n@@ -1224,7 +1234,19 @@ impl DefCollector<'_> {\n                         };\n                         let ast_id = ast_id.with_value(ast_adt_id);\n \n-                        match attr.parse_path_comma_token_tree() {\n+                        let extend_unhygenic;\n+                        let hygiene = if file_id.is_macro() {\n+                            self.hygienes\n+                                .entry(file_id)\n+                                .or_insert_with(|| Hygiene::new(self.db.upcast(), file_id))\n+                        } else {\n+                            // Avoid heap allocation (`Hygiene` embraces `Arc`) and hash map entry\n+                            // when we're in an oridinary (non-macro) file.\n+                            extend_unhygenic = Hygiene::new_unhygienic();\n+                            &extend_unhygenic\n+                        };\n+\n+                        match attr.parse_path_comma_token_tree(self.db.upcast(), hygiene) {\n                             Some(derive_macros) => {\n                                 let mut len = 0;\n                                 for (idx, path) in derive_macros.enumerate() {\n@@ -2212,6 +2234,7 @@ mod tests {\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             is_proc_macro: false,\n+            hygienes: FxHashMap::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "6ee56c9368e4006783b60acf56623b0471e639ad", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=34ebb30e8442357ee41009acf64983783dd0cb7e", "patch": "@@ -664,6 +664,29 @@ pub struct bar;\n     );\n }\n \n+#[test]\n+fn macro_dollar_crate_is_correct_in_derive_meta() {\n+    let map = compute_crate_def_map(\n+        r#\"\n+//- minicore: derive, clone\n+//- /main.rs crate:main deps:lib\n+lib::foo!();\n+\n+//- /lib.rs crate:lib\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        #[derive($crate::Clone)]\n+        struct S;\n+    }\n+}\n+\n+pub use core::clone::Clone;\n+\"#,\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+}\n+\n #[test]\n fn expand_derive() {\n     let map = compute_crate_def_map("}, {"sha": "17360090db1dc7aea0e8c037e9ab45b773eba593", "filename": "crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ebb30e8442357ee41009acf64983783dd0cb7e/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=34ebb30e8442357ee41009acf64983783dd0cb7e", "patch": "@@ -12,8 +12,7 @@ use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n use crate::{\n     db::ExpandDatabase,\n     hygiene::Hygiene,\n-    mod_path::{ModPath, PathKind},\n-    name::AsName,\n+    mod_path::ModPath,\n     tt::{self, Subtree},\n     InFile,\n };\n@@ -267,7 +266,11 @@ impl Attr {\n     }\n \n     /// Parses this attribute as a token tree consisting of comma separated paths.\n-    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+    pub fn parse_path_comma_token_tree<'a>(\n+        &'a self,\n+        db: &'a dyn ExpandDatabase,\n+        hygiene: &'a Hygiene,\n+    ) -> Option<impl Iterator<Item = ModPath> + 'a> {\n         let args = self.token_tree_value()?;\n \n         if args.delimiter.kind != DelimiterKind::Parenthesis {\n@@ -276,15 +279,25 @@ impl Attr {\n         let paths = args\n             .token_trees\n             .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n-            .filter_map(|tts| {\n+            .filter_map(move |tts| {\n                 if tts.is_empty() {\n                     return None;\n                 }\n-                let segments = tts.iter().filter_map(|tt| match tt {\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                    _ => None,\n-                });\n-                Some(ModPath::from_segments(PathKind::Plain, segments))\n+                // FIXME: This is necessarily a hack. It'd be nice if we could avoid allocation here.\n+                let subtree = tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees: tts.into_iter().cloned().collect(),\n+                };\n+                let (parse, _) =\n+                    mbe::token_tree_to_syntax_node(&subtree, mbe::TopEntryPoint::MetaItem);\n+                let meta = ast::Meta::cast(parse.syntax_node())?;\n+                // Only simple paths are allowed.\n+                if meta.eq_token().is_some() || meta.expr().is_some() || meta.token_tree().is_some()\n+                {\n+                    return None;\n+                }\n+                let path = meta.path()?;\n+                ModPath::from_src(db, path, hygiene)\n             });\n \n         Some(paths)"}]}