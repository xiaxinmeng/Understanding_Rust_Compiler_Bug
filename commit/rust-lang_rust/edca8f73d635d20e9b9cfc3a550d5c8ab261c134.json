{"sha": "edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkY2E4ZjczZDYzNWQyMGU5YjljZmMzYTU1MGQ1YzhhYjI2MWMxMzQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-02T03:37:07Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-04T21:45:35Z"}, "message": "rustfmt librustc_trans/save", "tree": {"sha": "4d1813ecf54177859586d82ae6630a7414d6481c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d1813ecf54177859586d82ae6630a7414d6481c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "html_url": "https://github.com/rust-lang/rust/commit/edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "668dac477eeb8b7d7bf0556c77bbc3292e5c7cc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/668dac477eeb8b7d7bf0556c77bbc3292e5c7cc2", "html_url": "https://github.com/rust-lang/rust/commit/668dac477eeb8b7d7bf0556c77bbc3292e5c7cc2"}], "stats": {"total": 295, "additions": 118, "deletions": 177}, "files": [{"sha": "581c9bc597fc683f87a271e8ccdbb3d5a0fd45a5", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "patch": "@@ -71,30 +71,29 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     span: SpanUtils<'l>,\n     fmt: FmtStrs<'l>,\n \n-    cur_scope: NodeId\n+    cur_scope: NodeId,\n }\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     pub fn new(tcx: &'l ty::ctxt<'tcx>,\n                analysis: &'l ty::CrateAnalysis,\n-               output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n+               output_file: Box<File>)\n+               -> DumpCsvVisitor<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         DumpCsvVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n             save_ctxt: SaveContext::from_span_utils(tcx, span_utils.clone()),\n             analysis: analysis,\n             span: span_utils.clone(),\n-            fmt: FmtStrs::new(box Recorder {\n-                                out: output_file,\n-                                dump_spans: false,\n-                              }, span_utils),\n-            cur_scope: 0\n+            fmt: FmtStrs::new(box Recorder { out: output_file, dump_spans: false },\n+                              span_utils),\n+            cur_scope: 0,\n         }\n     }\n \n-    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n-        F: FnOnce(&mut DumpCsvVisitor<'l, 'tcx>),\n+    fn nest<F>(&mut self, scope_id: NodeId, f: F)\n+        where F: FnOnce(&mut DumpCsvVisitor<'l, 'tcx>)\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -140,9 +139,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut segs = vec!();\n         for (i, (seg, span)) in path.segments.iter().zip(&spans).enumerate() {\n             segs.push(seg.clone());\n-            let sub_path = ast::Path{span: *span, // span for the last segment\n-                                     global: path.global,\n-                                     segments: segs};\n+            let sub_path = ast::Path {\n+                span: *span, // span for the last segment\n+                global: path.global,\n+                segments: segs,\n+            };\n             let qualname = if i == 0 && path.global {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n@@ -271,7 +272,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n                                                  def));\n-            },\n+            }\n         }\n     }\n \n@@ -357,9 +358,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_struct_field_def(&mut self,\n-                                field: &ast::StructField,\n-                                parent_id: NodeId) {\n+    fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n             self.fmt.field_str(field.span,\n@@ -374,7 +373,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     // Dump generic params bindings, then visit_generics\n     fn process_generic_params(&mut self,\n-                              generics:&ast::Generics,\n+                              generics: &ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n@@ -427,11 +426,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         self.nest(item.id, |v| v.visit_block(&body));\n     }\n \n-    fn process_static_or_const_item(&mut self,\n-                                    item: &ast::Item,\n-                                    typ: &ast::Ty,\n-                                    expr: &ast::Expr)\n-    {\n+    fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n         let var_data = self.save_ctxt.get_item_data(item);\n         down_cast_data!(var_data, VariableData, self, item.span);\n         self.fmt.static_str(item.span,\n@@ -452,8 +447,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      ident: &ast::Ident,\n                      span: Span,\n                      typ: &ast::Ty,\n-                     expr: &ast::Expr)\n-    {\n+                     expr: &ast::Expr) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span,\n@@ -641,8 +635,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                          sub_span,\n                                          id,\n                                          item.id);\n-                },\n-                None => ()\n+                }\n+                None => (),\n             }\n         }\n \n@@ -653,8 +647,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_mod(&mut self,\n-                   item: &ast::Item) {  // The module in question, represented as an item.\n+    fn process_mod(&mut self, item: &ast::Item) {  // The module in question, represented as an item.\n         let mod_data = self.save_ctxt.get_item_data(item);\n         down_cast_data!(mod_data, ModData, self, item.span);\n         self.fmt.mod_str(item.span,\n@@ -665,10 +658,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                          &mod_data.filename);\n     }\n \n-    fn process_path(&mut self,\n-                    id: NodeId,\n-                    path: &ast::Path,\n-                    ref_kind: Option<recorder::Row>) {\n+    fn process_path(&mut self, id: NodeId, path: &ast::Path, ref_kind: Option<recorder::Row>) {\n         if generated_code(path.span) {\n             return;\n         }\n@@ -737,7 +727,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n-            _ => {},\n+            _ => {}\n         }\n     }\n \n@@ -783,9 +773,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         visit::walk_expr_opt(self, base)\n     }\n \n-    fn process_method_call(&mut self,\n-                           ex: &ast::Expr,\n-                           args: &Vec<P<ast::Expr>>) {\n+    fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n         if let Some(call_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(call_data, MethodCallData, self, ex.span);\n             self.fmt.meth_call_str(ex.span,\n@@ -799,7 +787,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         visit::walk_exprs(self, &args);\n     }\n \n-    fn process_pat(&mut self, p:&ast::Pat) {\n+    fn process_pat(&mut self, p: &ast::Pat) {\n         if generated_code(p.span) {\n             return;\n         }\n@@ -827,7 +815,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     self.visit_pat(&field.pat);\n                 }\n             }\n-            _ => visit::walk_pat(self, p)\n+            _ => visit::walk_pat(self, p),\n         }\n     }\n }\n@@ -851,10 +839,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                                                    sub_span,\n                                                                    def_id,\n                                                                    self.cur_scope),\n-                                    None => {},\n+                                    None => {}\n                                 }\n                                 Some(def_id)\n-                            },\n+                            }\n                             None => None,\n                         };\n \n@@ -902,20 +890,19 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             match plid.node {\n                                 ast::PathListIdent { id, .. } => {\n                                     match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n+                                        Some(def_id) => match self.lookup_def_kind(id, plid.span) {\n+                                            Some(kind) => {\n+                                                self.fmt.ref_str(\n                                                         kind, plid.span,\n                                                         Some(plid.span),\n                                                         def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n+                                            }\n+                                            None => (),\n+                                        },\n+                                        None => (),\n                                     }\n-                                },\n-                                ast::PathListMod { .. } => ()\n+                                }\n+                                ast::PathListMod { .. } => (),\n                             }\n                         }\n \n@@ -978,7 +965,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n-            },\n+            }\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n         }\n@@ -1048,14 +1035,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                          sub_span,\n                                          id,\n                                          self.cur_scope);\n-                    },\n-                    None => ()\n+                    }\n+                    None => (),\n                 }\n \n                 self.write_sub_paths_truncated(path, false);\n \n                 visit::walk_path(self, path);\n-            },\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }\n@@ -1101,7 +1088,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                      field_data.ref_id,\n                                      field_data.scope);\n                 }\n-            },\n+            }\n             ast::ExprTupField(ref sub_ex, idx) => {\n                 if generated_code(sub_ex.span) {\n                     return\n@@ -1125,7 +1112,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                             &format!(\"Expected struct or tuple \\\n                                                       type, found {:?}\", ty)),\n                 }\n-            },\n+            }\n             ast::ExprClosure(_, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n@@ -1146,7 +1133,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));\n-            },\n+            }\n             _ => {\n                 visit::walk_expr(self, ex)\n             }\n@@ -1182,7 +1169,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n-                def::DefLocal(id)  => {\n+                def::DefLocal(id) => {\n                     let value = if immut == ast::MutImmutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {\n@@ -1205,7 +1192,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 def::DefConst(..) |\n                 def::DefAssociatedConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            def)\n+                            def),\n             }\n         }\n "}, {"sha": "9c6f1a0eb5a89bd6794b558bfea4c570af0d14a5", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "patch": "@@ -176,18 +176,15 @@ pub struct MethodCallData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l ty::ctxt<'tcx>) -> SaveContext <'l, 'tcx> {\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>) -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         SaveContext::from_span_utils(tcx, span_utils)\n     }\n \n     pub fn from_span_utils(tcx: &'l ty::ctxt<'tcx>,\n                            span_utils: SpanUtils<'l>)\n                            -> SaveContext<'l, 'tcx> {\n-        SaveContext {\n-            tcx: tcx,\n-            span_utils: span_utils,\n-        }\n+        SaveContext { tcx: tcx, span_utils: span_utils }\n     }\n \n     // List external crates used by the current crate.\n@@ -268,7 +265,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                     filename: filename,\n                 })\n-            },\n+            }\n             ast::ItemEnum(..) => {\n                 let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n@@ -281,7 +278,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: enum_name,\n                     scope: self.enclosing_scope(item.id),\n                 })\n-            },\n+            }\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n@@ -297,7 +294,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             scope: parent,\n                             ref_id: id,\n                         });\n-                    },\n+                    }\n                     _ => {\n                         // Less useful case, impl for a compound type.\n                         let span = typ.span;\n@@ -341,17 +338,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: \"\".to_owned(),\n                     type_value: typ,\n                 })\n-            },\n+            }\n             _ => None,\n         }\n     }\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self,\n-                           id: ast::NodeId,\n-                           name: ast::Name,\n-                           span: Span) -> FunctionData {\n+    pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> FunctionData {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match self.tcx.impl_of_method(DefId::local(id)) {\n@@ -367,7 +361,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n                                         &self.tcx.item_path_str(def_id));\n-                                },\n+                                }\n                                 None => {}\n                             }\n                             result.push_str(\">\");\n@@ -377,14 +371,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             self.tcx.sess.span_bug(span,\n                                 &format!(\"Container {} for method {} not an impl?\",\n                                          impl_id.node, id));\n-                        },\n+                        }\n                     }\n-                },\n+                }\n                 _ => {\n                     self.tcx.sess.span_bug(span,\n                         &format!(\"Container {} for method {} is not a node item {:?}\",\n                                  impl_id.node, id, self.tcx.map.get(impl_id.node)));\n-                },\n+                }\n             },\n             None => match self.tcx.trait_of_item(DefId::local(id)) {\n                 Some(def_id) => {\n@@ -398,11 +392,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                          def_id.node, id));\n                         }\n                     }\n-                },\n+                }\n                 None => {\n                     self.tcx.sess.span_bug(span,\n                         &format!(\"Could not find container for method {}\", id));\n-                },\n+                }\n             },\n         };\n \n@@ -492,7 +486,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n-                    ty::TraitContainer(_) => (None, Some(method_id))\n+                    ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n                 let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n                 let parent = self.enclosing_scope(expr.id);\n@@ -513,10 +507,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self,\n-                         id: NodeId,\n-                         path: &ast::Path)\n-                         -> Option<Data> {\n+    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.tcx.sess.span_bug(path.span,\n@@ -583,7 +574,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: def_id,\n                     decl_id: Some(decl_id),\n                 }))\n-            },\n+            }\n             def::DefFn(def_id, _) => {\n                 Some(Data::FunctionCallData(FunctionCallData {\n                     ref_id: def_id,\n@@ -663,9 +654,7 @@ struct PathCollector {\n \n impl PathCollector {\n     fn new() -> PathCollector {\n-        PathCollector {\n-            collected_paths: vec![],\n-        }\n+        PathCollector { collected_paths: vec![] }\n     }\n }\n \n@@ -722,7 +711,7 @@ pub fn process_crate(tcx: &ty::ctxt,\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n             String::from(\"unknown_crate\")\n-        },\n+        }\n     };\n \n     info!(\"Dumping crate {}\", cratename);\n@@ -775,5 +764,5 @@ fn escape(s: String) -> String {\n // If the expression is a macro expansion or other generated code, run screaming\n // and don't index.\n pub fn generated_code(span: Span) -> bool {\n-    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n+    span.expn_id != NO_EXPANSION || span == DUMMY_SP\n }"}, {"sha": "f8e6864985364a8d72614de61e149859ac8fc5be", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "patch": "@@ -18,14 +18,14 @@ use middle::def_id::DefId;\n use std::io::Write;\n \n use syntax::ast;\n-use syntax::ast::{NodeId};\n+use syntax::ast::NodeId;\n use syntax::codemap::*;\n \n const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };\n \n pub struct Recorder {\n     // output file\n-    pub out: Box<Write+'static>,\n+    pub out: Box<Write + 'static>,\n     pub dump_spans: bool,\n }\n \n@@ -37,11 +37,7 @@ impl Recorder {\n         }\n     }\n \n-    pub fn dump_span(&mut self,\n-                     su: SpanUtils,\n-                     kind: &str,\n-                     span: Span,\n-                     _sub_span: Option<Span>) {\n+    pub fn dump_span(&mut self, su: SpanUtils, kind: &str, span: Span, _sub_span: Option<Span>) {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n@@ -96,10 +92,7 @@ pub enum Row {\n \n impl<'a> FmtStrs<'a> {\n     pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>) -> FmtStrs<'a> {\n-        FmtStrs {\n-            recorder: rec,\n-            span: span,\n-        }\n+        FmtStrs { recorder: rec, span: span }\n     }\n \n     // A map from kind of item to a tuple of\n@@ -111,55 +104,60 @@ impl<'a> FmtStrs<'a> {\n         match r {\n             Variable => (\"variable\",\n                          vec!(\"id\",\"name\",\"qualname\",\"value\",\"type\",\"scopeid\"),\n-                         true, true),\n+                         true,\n+                         true),\n             Enum => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n             Variant => (\"variant\",\n                         vec!(\"id\",\"name\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n-                        true, true),\n+                        true,\n+                        true),\n             VariantStruct => (\"variant_struct\",\n                               vec!(\"id\",\"ctor_id\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n-                              true, true),\n+                              true,\n+                              true),\n             Function => (\"function\",\n                          vec!(\"id\",\"qualname\",\"declid\",\"declidcrate\",\"scopeid\"),\n-                         true, true),\n+                         true,\n+                         true),\n             MethodDecl => (\"method_decl\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n             Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n             Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n             Impl => (\"impl\",\n                      vec!(\"id\",\"refid\",\"refidcrate\",\"traitid\",\"traitidcrate\",\"scopeid\"),\n-                     true, true),\n+                     true,\n+                     true),\n             Module => (\"module\", vec!(\"id\",\"qualname\",\"scopeid\",\"def_file\"), true, false),\n-            UseAlias => (\"use_alias\",\n-                         vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"),\n-                         true, true),\n+            UseAlias => (\"use_alias\", vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"), true, true),\n             UseGlob => (\"use_glob\", vec!(\"id\",\"value\",\"scopeid\"), true, true),\n             ExternCrate => (\"extern_crate\",\n                             vec!(\"id\",\"name\",\"location\",\"crate\",\"scopeid\"),\n-                            true, true),\n+                            true,\n+                            true),\n             Inheritance => (\"inheritance\",\n                             vec!(\"base\",\"basecrate\",\"derived\",\"derivedcrate\"),\n-                            true, false),\n+                            true,\n+                            false),\n             MethodCall => (\"method_call\",\n                            vec!(\"refid\",\"refidcrate\",\"declid\",\"declidcrate\",\"scopeid\"),\n-                           true, true),\n+                           true,\n+                           true),\n             Typedef => (\"typedef\", vec!(\"id\",\"qualname\",\"value\"), true, true),\n             ExternalCrate => (\"external_crate\", vec!(\"name\",\"crate\",\"file_name\"), false, false),\n             Crate => (\"crate\", vec!(\"name\"), true, false),\n             FnCall => (\"fn_call\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n             ModRef => (\"mod_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n             VarRef => (\"var_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n-            TypeRef => (\"type_ref\",\n-                        vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n-                        true, true),\n-            FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true)\n+            TypeRef => (\"type_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n+            FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n         }\n     }\n \n     pub fn make_values_str(&self,\n                            kind: &'static str,\n                            fields: &Vec<&'static str>,\n                            values: Vec<String>,\n-                           span: Span) -> Option<String> {\n+                           span: Span)\n+                           -> Option<String> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, &format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n@@ -183,10 +181,7 @@ impl<'a> FmtStrs<'a> {\n         }))\n     }\n \n-    pub fn record_without_span(&mut self,\n-                               kind: Row,\n-                               values: Vec<String>,\n-                               span: Span) {\n+    pub fn record_without_span(&mut self, kind: Row, values: Vec<String>, span: Span) {\n         let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n \n         if needs_span {\n@@ -387,7 +382,7 @@ impl<'a> FmtStrs<'a> {\n                       scope_id: NodeId) {\n         let values = match decl_id {\n             Some(decl_id) => svec!(id, name, decl_id.node, decl_id.krate, scope_id),\n-            None => svec!(id, name, \"\", \"\", scope_id)\n+            None => svec!(id, name, \"\", \"\", scope_id),\n         };\n         self.check_and_record(Function,\n                               span,\n@@ -476,7 +471,7 @@ impl<'a> FmtStrs<'a> {\n                          parent: NodeId) {\n         let (mod_node, mod_crate) = match mod_id {\n             Some(mod_id) => (mod_id.node, mod_id.krate),\n-            None => (0, 0)\n+            None => (0, 0),\n         };\n         self.check_and_record(UseAlias,\n                               span,\n@@ -528,7 +523,7 @@ impl<'a> FmtStrs<'a> {\n                        span: Span,\n                        sub_span: Option<Span>,\n                        id: DefId,\n-                       scope_id:NodeId) {\n+                       scope_id: NodeId) {\n         self.check_and_record(FnCall,\n                               span,\n                               sub_span,\n@@ -543,23 +538,19 @@ impl<'a> FmtStrs<'a> {\n                          scope_id: NodeId) {\n         let (dfn, dfk) = match defid {\n             Some(defid) => (defid.node, defid.krate),\n-            None => (0, 0)\n+            None => (0, 0),\n         };\n         let (dcn, dck) = match declid {\n             Some(declid) => (s!(declid.node), s!(declid.krate)),\n-            None => (\"\".to_string(), \"\".to_string())\n+            None => (\"\".to_string(), \"\".to_string()),\n         };\n         self.check_and_record(MethodCall,\n                               span,\n                               sub_span,\n                               svec!(dfn, dfk, dcn, dck, scope_id));\n     }\n \n-    pub fn sub_mod_ref_str(&mut self,\n-                           span: Span,\n-                           sub_span: Span,\n-                           qualname: &str,\n-                           parent:NodeId) {\n+    pub fn sub_mod_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str, parent: NodeId) {\n         self.record_with_span(ModRef,\n                               span,\n                               sub_span,\n@@ -578,29 +569,21 @@ impl<'a> FmtStrs<'a> {\n                               svec!(id, qualname, value));\n     }\n \n-    pub fn crate_str(&mut self,\n-                     span: Span,\n-                     name: &str) {\n+    pub fn crate_str(&mut self, span: Span, name: &str) {\n         self.record_with_span(Crate,\n                               span,\n                               span,\n                               svec!(name));\n     }\n \n-    pub fn external_crate_str(&mut self,\n-                              span: Span,\n-                              name: &str,\n-                              num: ast::CrateNum) {\n+    pub fn external_crate_str(&mut self, span: Span, name: &str, num: ast::CrateNum) {\n         let lo_loc = self.span.sess.codemap().lookup_char_pos(span.lo);\n         self.record_without_span(ExternalCrate,\n                                  svec!(name, num, lo_loc.file.name),\n                                  span);\n     }\n \n-    pub fn sub_type_ref_str(&mut self,\n-                            span: Span,\n-                            sub_span: Span,\n-                            qualname: &str) {\n+    pub fn sub_type_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str) {\n         self.record_with_span(TypeRef,\n                               span,\n                               sub_span,"}, {"sha": "5647e88658a3b9cb934a397f1054313c8b089128", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edca8f73d635d20e9b9cfc3a550d5c8ab261c134/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=edca8f73d635d20e9b9cfc3a550d5c8ab261c134", "patch": "@@ -17,7 +17,7 @@ use std::cell::Cell;\n use syntax::ast;\n use syntax::codemap::*;\n use syntax::parse::lexer;\n-use syntax::parse::lexer::{Reader,StringReader};\n+use syntax::parse::lexer::{Reader, StringReader};\n use syntax::parse::token;\n use syntax::parse::token::{keywords, Token};\n \n@@ -29,10 +29,7 @@ pub struct SpanUtils<'a> {\n \n impl<'a> SpanUtils<'a> {\n     pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n-        SpanUtils {\n-            sess: sess,\n-            err_count: Cell::new(0)\n-        }\n+        SpanUtils { sess: sess, err_count: Cell::new(0) }\n     }\n \n     // Standard string for extents/location.\n@@ -62,8 +59,7 @@ impl<'a> SpanUtils<'a> {\n         match sub_span {\n             None => None,\n             Some(sub) => {\n-                let FileMapAndBytePos {fm, pos} =\n-                    self.sess.codemap().lookup_byte_offset(span.lo);\n+                let FileMapAndBytePos {fm, pos} = self.sess.codemap().lookup_byte_offset(span.lo);\n                 let base = pos + fm.start_pos;\n                 Some(Span {\n                     lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n@@ -107,16 +103,15 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 return self.make_sub_span(span, result)\n             }\n-            if bracket_count == 0 &&\n-               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n+            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 result = Some(ts.sp);\n             }\n \n             bracket_count += match ts.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n                 token::BinOp(token::Shr) => -2,\n-                _ => 0\n+                _ => 0,\n             }\n         }\n     }\n@@ -130,16 +125,15 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 return None;\n             }\n-            if bracket_count == 0 &&\n-               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n+            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 return self.make_sub_span(span, Some(ts.sp));\n             }\n \n             bracket_count += match ts.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n                 token::BinOp(token::Shr) => -2,\n-                _ => 0\n+                _ => 0,\n             }\n         }\n     }\n@@ -156,20 +150,16 @@ impl<'a> SpanUtils<'a> {\n             last_span = None;\n             let mut next = toks.real_token();\n \n-            if (next.tok == token::OpenDelim(token::Paren) ||\n-                next.tok == token::Lt) &&\n-               bracket_count == 0 &&\n-               prev.tok.is_ident() {\n+            if (next.tok == token::OpenDelim(token::Paren) || next.tok == token::Lt) &&\n+               bracket_count == 0 && prev.tok.is_ident() {\n                 result = Some(prev.sp);\n             }\n \n-            if bracket_count == 0 &&\n-                next.tok == token::ModSep {\n+            if bracket_count == 0 && next.tok == token::ModSep {\n                 let old = prev;\n                 prev = next;\n                 next = toks.real_token();\n-                if next.tok == token::Lt &&\n-                   old.tok.is_ident() {\n+                if next.tok == token::Lt && old.tok.is_ident() {\n                     result = Some(old.sp);\n                 }\n             }\n@@ -178,7 +168,7 @@ impl<'a> SpanUtils<'a> {\n                 token::OpenDelim(token::Paren) | token::Lt => 1,\n                 token::CloseDelim(token::Paren) | token::Gt => -1,\n                 token::BinOp(token::Shr) => -2,\n-                _ => 0\n+                _ => 0,\n             };\n \n             if prev.tok.is_ident() && bracket_count == 0 {\n@@ -202,9 +192,7 @@ impl<'a> SpanUtils<'a> {\n         loop {\n             let next = toks.real_token();\n \n-            if (next.tok == token::Lt ||\n-                next.tok == token::Colon) &&\n-               bracket_count == 0 &&\n+            if (next.tok == token::Lt || next.tok == token::Colon) && bracket_count == 0 &&\n                prev.tok.is_ident() {\n                 result = Some(prev.sp);\n             }\n@@ -214,7 +202,7 @@ impl<'a> SpanUtils<'a> {\n                 token::Gt => -1,\n                 token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n-                _ => 0\n+                _ => 0,\n             };\n \n             if next.tok == token::Eof {\n@@ -265,7 +253,7 @@ impl<'a> SpanUtils<'a> {\n                 token::Gt => -1,\n                 token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n-                _ => 0\n+                _ => 0,\n             };\n \n             // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n@@ -316,21 +304,15 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn sub_span_after_keyword(&self,\n-                                  span: Span,\n-                                  keyword: keywords::Keyword) -> Option<Span> {\n+    pub fn sub_span_after_keyword(&self, span: Span, keyword: keywords::Keyword) -> Option<Span> {\n         self.sub_span_after(span, |t| t.is_keyword(keyword))\n     }\n \n-    pub fn sub_span_after_token(&self,\n-                                span: Span,\n-                                tok: Token) -> Option<Span> {\n+    pub fn sub_span_after_token(&self, span: Span, tok: Token) -> Option<Span> {\n         self.sub_span_after(span, |t| t == tok)\n     }\n \n-    fn sub_span_after<F: Fn(Token) -> bool>(&self,\n-                                            span: Span,\n-                                            f: F) -> Option<Span> {\n+    fn sub_span_after<F: Fn(Token) -> bool>(&self, span: Span, f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();"}]}