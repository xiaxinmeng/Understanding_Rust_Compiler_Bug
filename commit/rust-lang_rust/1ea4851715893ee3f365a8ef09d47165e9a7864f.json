{"sha": "1ea4851715893ee3f365a8ef09d47165e9a7864f", "node_id": "C_kwDOAAsO6NoAKDFlYTQ4NTE3MTU4OTNlZTNmMzY1YThlZjA5ZDQ3MTY1ZTlhNzg2NGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T23:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T23:18:01Z"}, "message": "Auto merge of #93285 - JulianKnodt:const_eq_2, r=oli-obk\n\nContinue work on associated const equality\n\nThis actually implements some more complex logic for assigning associated consts to values.\nInside of projection candidates, it now defers to a separate function for either consts or\ntypes. To reduce amount of code, projections are now generic over T, where T is either a Type or\na Const. I can add some comments back later, but this was the fastest way to implement it.\n\nIt also now finds the correct type of consts in type_of.\n\n---\n\nThe current main TODO is finding the const of the def id for the LeafDef.\n\nRight now it works if the function isn't called, but once you use the trait impl with the bound it fails inside projection.\nI was hoping to get some help in getting the `&'tcx ty::Const<'tcx>`, in addition to a bunch of other `todo!()`s which I think may not be hit.\n\nr? `@oli-obk`\n\nUpdates #92827", "tree": {"sha": "51abd81d7ec00e252eda25cd53e5481be292ba64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51abd81d7ec00e252eda25cd53e5481be292ba64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea4851715893ee3f365a8ef09d47165e9a7864f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4851715893ee3f365a8ef09d47165e9a7864f", "html_url": "https://github.com/rust-lang/rust/commit/1ea4851715893ee3f365a8ef09d47165e9a7864f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4851715893ee3f365a8ef09d47165e9a7864f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2681f253bcdb31a274411d2be456e7c6a1c67d62", "url": "https://api.github.com/repos/rust-lang/rust/commits/2681f253bcdb31a274411d2be456e7c6a1c67d62", "html_url": "https://github.com/rust-lang/rust/commit/2681f253bcdb31a274411d2be456e7c6a1c67d62"}, {"sha": "78fb74a6005642bca0a3da7016f9edbbd99f1846", "url": "https://api.github.com/repos/rust-lang/rust/commits/78fb74a6005642bca0a3da7016f9edbbd99f1846", "html_url": "https://github.com/rust-lang/rust/commit/78fb74a6005642bca0a3da7016f9edbbd99f1846"}], "stats": {"total": 560, "additions": 379, "deletions": 181}, "files": [{"sha": "43900ba88993e3eb2c3eb4f189fd1aab74b64c00", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -2203,6 +2203,12 @@ impl TypeBinding<'_> {\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n         }\n     }\n+    pub fn opt_const(&self) -> Option<&'_ AnonConst> {\n+        match self.kind {\n+            TypeBindingKind::Equality { term: Term::Const(ref c) } => Some(c),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "147061dafeb1ed555e543024173fe9ac92f79d8f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -286,6 +286,26 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        match (a, b) {\n+            (ty::Term::Ty(a), ty::Term::Ty(b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n+            }\n+            (ty::Term::Const(a), ty::Term::Const(b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n+            }\n+            (_, _) => todo!(),\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "a1a1168a21d2e8fa216670c452d8d0a7a8407685", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -93,7 +93,7 @@ pub enum ProjectionCacheEntry<'tcx> {\n     Recur,\n     Error,\n     NormalizedTy {\n-        ty: NormalizedTy<'tcx>,\n+        ty: Normalized<'tcx, ty::Term<'tcx>>,\n         /// If we were able to successfully evaluate the\n         /// corresponding cache entry key during predicate\n         /// evaluation, then this field stores the final\n@@ -174,7 +174,11 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    pub fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n+    pub fn insert_term(\n+        &mut self,\n+        key: ProjectionCacheKey<'tcx>,\n+        value: Normalized<'tcx, ty::Term<'tcx>>,\n+    ) {\n         debug!(\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value"}, {"sha": "78878487a9b489ac457fdf26e4cad3be222f74b7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -867,6 +867,9 @@ impl<'tcx> Term<'tcx> {\n     pub fn ty(&self) -> Option<Ty<'tcx>> {\n         if let Term::Ty(ty) = self { Some(ty) } else { None }\n     }\n+    pub fn ct(&self) -> Option<&'tcx Const<'tcx>> {\n+        if let Term::Const(c) = self { Some(c) } else { None }\n+    }\n }\n \n /// This kind of predicate has no *direct* correspondent in the"}, {"sha": "6cb19416cd769be512516716938bf2e57bd0e1ed", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -1373,19 +1373,31 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(_)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-                // FIXME(associated_const_equality): Handle Consts here\n-                let data_ty = data.term.ty().unwrap();\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n                     is_normalized_ty_expected,\n                     normalized_ty,\n-                    data_ty,\n+                    data.term,\n                 ) {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data_ty,\n-                    )));\n-\n+                    values = Some(match (normalized_ty, data.term) {\n+                        (ty::Term::Ty(normalized_ty), ty::Term::Ty(ty)) => {\n+                            infer::ValuePairs::Types(ExpectedFound::new(\n+                                is_normalized_ty_expected,\n+                                normalized_ty,\n+                                ty,\n+                            ))\n+                        }\n+                        (ty::Term::Const(normalized_ct), ty::Term::Const(ct)) => {\n+                            infer::ValuePairs::Consts(ExpectedFound::new(\n+                                is_normalized_ty_expected,\n+                                normalized_ct,\n+                                ct,\n+                            ))\n+                        }\n+                        (_, _) => span_bug!(\n+                            obligation.cause.span,\n+                            \"found const or type where other expected\"\n+                        ),\n+                    });\n                     err_buf = error;\n                     err = &err_buf;\n                 }"}, {"sha": "6634f3e364d327c082c5c186fa696a13d11a527a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -2496,7 +2496,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n                     trait_pred,\n-                    normalized_ty,\n+                    normalized_ty.ty().unwrap(),\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)"}, {"sha": "e7897887df7063896245eacb455be83a41d75f81", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         debug!(?normalized_ty);\n \n-        normalized_ty\n+        normalized_ty.ty().unwrap()\n     }\n \n     fn register_predicate_obligation("}, {"sha": "5e7d4c8b415c33902049d1635124eab9e3550b53", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -22,12 +22,13 @@ use crate::traits::error_reporting::InferCtxtExt as _;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n use std::collections::BTreeMap;\n@@ -44,7 +45,7 @@ pub(super) struct InProgress;\n \n /// When attempting to resolve `<T as TraitRef>::Name` ...\n #[derive(Debug)]\n-pub enum ProjectionTyError<'tcx> {\n+pub enum ProjectionError<'tcx> {\n     /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n     TooManyCandidates,\n \n@@ -53,7 +54,7 @@ pub enum ProjectionTyError<'tcx> {\n }\n \n #[derive(PartialEq, Eq, Debug)]\n-enum ProjectionTyCandidate<'tcx> {\n+enum ProjectionCandidate<'tcx> {\n     /// From a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n \n@@ -67,28 +68,28 @@ enum ProjectionTyCandidate<'tcx> {\n     Select(Selection<'tcx>),\n }\n \n-enum ProjectionTyCandidateSet<'tcx> {\n+enum ProjectionCandidateSet<'tcx> {\n     None,\n-    Single(ProjectionTyCandidate<'tcx>),\n+    Single(ProjectionCandidate<'tcx>),\n     Ambiguous,\n     Error(SelectionError<'tcx>),\n }\n \n-impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+impl<'tcx> ProjectionCandidateSet<'tcx> {\n     fn mark_ambiguous(&mut self) {\n-        *self = ProjectionTyCandidateSet::Ambiguous;\n+        *self = ProjectionCandidateSet::Ambiguous;\n     }\n \n     fn mark_error(&mut self, err: SelectionError<'tcx>) {\n-        *self = ProjectionTyCandidateSet::Error(err);\n+        *self = ProjectionCandidateSet::Error(err);\n     }\n \n     // Returns true if the push was successful, or false if the candidate\n     // was discarded -- this could be because of ambiguity, or because\n     // a higher-priority candidate is already there.\n-    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n-        use self::ProjectionTyCandidate::*;\n-        use self::ProjectionTyCandidateSet::*;\n+    fn push_candidate(&mut self, candidate: ProjectionCandidate<'tcx>) -> bool {\n+        use self::ProjectionCandidate::*;\n+        use self::ProjectionCandidateSet::*;\n \n         // This wacky variable is just used to try and\n         // make code readable and avoid confusing paths.\n@@ -196,7 +197,9 @@ fn project_and_unify_type<'cx, 'tcx>(\n     debug!(?obligation, \"project_and_unify_type\");\n \n     let mut obligations = vec![];\n-    let normalized_ty = match opt_normalize_projection_type(\n+\n+    let infcx = selcx.infcx();\n+    let normalized = match opt_normalize_projection_type(\n         selcx,\n         obligation.param_env,\n         obligation.predicate.projection_ty,\n@@ -208,13 +211,11 @@ fn project_and_unify_type<'cx, 'tcx>(\n         Ok(None) => return Ok(Ok(None)),\n         Err(InProgress) => return Ok(Err(InProgress)),\n     };\n-\n-    debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n-\n-    let infcx = selcx.infcx();\n-    // FIXME(associated_const_equality): Handle consts here as well as types.\n-    let obligation_pred_ty = obligation.predicate.term.ty().unwrap();\n-    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized_ty, obligation_pred_ty) {\n+    debug!(?normalized, ?obligations, \"project_and_unify_type result\");\n+    match infcx\n+        .at(&obligation.cause, obligation.param_env)\n+        .eq(normalized, obligation.predicate.term)\n+    {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Ok(Some(obligations)))\n@@ -441,7 +442,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     obligations.len = ?self.obligations.len(),\n                     \"AssocTypeNormalizer: normalized type\"\n                 );\n-                normalized_ty\n+                normalized_ty.ty().unwrap()\n             }\n \n             ty::Projection(data) => {\n@@ -471,6 +472,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 )\n                 .ok()\n                 .flatten()\n+                .map(|term| term.ty().unwrap())\n                 .map(|normalized_ty| {\n                     PlaceholderReplacer::replace_placeholders(\n                         infcx,\n@@ -793,7 +795,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Ty<'tcx> {\n+) -> Term<'tcx> {\n     opt_normalize_projection_type(\n         selcx,\n         param_env,\n@@ -809,7 +811,10 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        selcx.infcx().infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n+        selcx\n+            .infcx()\n+            .infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n+            .into()\n     })\n }\n \n@@ -831,7 +836,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Result<Option<Ty<'tcx>>, InProgress> {\n+) -> Result<Option<Term<'tcx>>, InProgress> {\n     let infcx = selcx.infcx();\n     // Don't use the projection cache in intercrate mode -\n     // the `infcx` may be re-used between intercrate in non-intercrate\n@@ -907,40 +912,37 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             debug!(\"opt_normalize_projection_type: found error\");\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n-            return Ok(Some(result.value));\n+            return Ok(Some(result.value.into()));\n         }\n     }\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n \n-    match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress {\n-            ty: projected_ty,\n+    match project(selcx, &obligation) {\n+        Ok(Projected::Progress(Progress {\n+            term: projected_term,\n             obligations: mut projected_obligations,\n         })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            let projected_ty = selcx.infcx().resolve_vars_if_possible(projected_ty);\n-            debug!(?projected_ty, ?depth, ?projected_obligations);\n+            let projected_term = selcx.infcx().resolve_vars_if_possible(projected_term);\n \n-            let mut result = if projected_ty.has_projections() {\n+            let mut result = if projected_term.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n                     selcx,\n                     param_env,\n                     cause,\n                     depth + 1,\n                     &mut projected_obligations,\n                 );\n-                let normalized_ty = normalizer.fold(projected_ty);\n-\n-                debug!(?normalized_ty, ?depth);\n+                let normalized_ty = normalizer.fold(projected_term);\n \n                 Normalized { value: normalized_ty, obligations: projected_obligations }\n             } else {\n-                Normalized { value: projected_ty, obligations: projected_obligations }\n+                Normalized { value: projected_term, obligations: projected_obligations }\n             };\n \n             let mut deduped: SsoHashSet<_> = Default::default();\n@@ -952,28 +954,27 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             });\n \n             if use_cache {\n-                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+                infcx.inner.borrow_mut().projection_cache().insert_term(cache_key, result.clone());\n             }\n             obligations.extend(result.obligations);\n-            Ok(Some(result.value))\n+            Ok(Some(result.value.into()))\n         }\n-        Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(?projected_ty, \"opt_normalize_projection_type: no progress\");\n+        Ok(Projected::NoProgress(projected_ty)) => {\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n             if use_cache {\n-                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+                infcx.inner.borrow_mut().projection_cache().insert_term(cache_key, result.clone());\n             }\n             // No need to extend `obligations`.\n             Ok(Some(result.value))\n         }\n-        Err(ProjectionTyError::TooManyCandidates) => {\n+        Err(ProjectionError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: too many candidates\");\n             if use_cache {\n                 infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n             }\n             Ok(None)\n         }\n-        Err(ProjectionTyError::TraitSelectionError(_)) => {\n+        Err(ProjectionError::TraitSelectionError(_)) => {\n             debug!(\"opt_normalize_projection_type: ERROR\");\n             // if we got an error processing the `T as Trait` part,\n             // just return `ty::err` but add the obligation `T :\n@@ -985,7 +986,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             }\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n-            Ok(Some(result.value))\n+            Ok(Some(result.value.into()))\n         }\n     }\n }\n@@ -1032,30 +1033,22 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n-enum ProjectedTy<'tcx> {\n+enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n-    NoProgress(Ty<'tcx>),\n+    NoProgress(ty::Term<'tcx>),\n }\n \n struct Progress<'tcx> {\n-    ty: Ty<'tcx>,\n+    term: ty::Term<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n impl<'tcx> Progress<'tcx> {\n     fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { ty: tcx.ty_error(), obligations: vec![] }\n+        Progress { term: tcx.ty_error().into(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n-        debug!(\n-            self.obligations.len = ?self.obligations.len(),\n-            obligations.len = obligations.len(),\n-            \"with_addl_obligations\"\n-        );\n-\n-        debug!(?self.obligations, ?obligations, \"with_addl_obligations\");\n-\n         self.obligations.append(&mut obligations);\n         self\n     }\n@@ -1066,22 +1059,21 @@ impl<'tcx> Progress<'tcx> {\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n #[tracing::instrument(level = \"info\", skip(selcx))]\n-fn project_type<'cx, 'tcx>(\n+fn project<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n+) -> Result<Projected<'tcx>, ProjectionError<'tcx>> {\n     if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n-        debug!(\"project: overflow!\");\n         // This should really be an immediate error, but some existing code\n         // relies on being able to recover from this.\n-        return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n+        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n     if obligation.predicate.references_error() {\n-        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n+        return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    let mut candidates = ProjectionTyCandidateSet::None;\n+    let mut candidates = ProjectionCandidateSet::None;\n \n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n@@ -1092,7 +1084,7 @@ fn project_type<'cx, 'tcx>(\n \n     assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n \n-    if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n+    if let ProjectionCandidateSet::Single(ProjectionCandidate::Object(_)) = candidates {\n         // Avoid normalization cycle from selection (see\n         // `assemble_candidates_from_object_ty`).\n         // FIXME(lazy_normalization): Lazy normalization should save us from\n@@ -1102,19 +1094,22 @@ fn project_type<'cx, 'tcx>(\n     };\n \n     match candidates {\n-        ProjectionTyCandidateSet::Single(candidate) => {\n-            Ok(ProjectedTy::Progress(confirm_candidate(selcx, obligation, candidate)))\n+        ProjectionCandidateSet::Single(candidate) => {\n+            Ok(Projected::Progress(confirm_candidate(selcx, obligation, candidate)))\n         }\n-        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+        ProjectionCandidateSet::None => Ok(Projected::NoProgress(\n+            // FIXME(associated_const_generics): this may need to change in the future?\n+            // need to investigate whether or not this is fine.\n             selcx\n                 .tcx()\n-                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n+                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs)\n+                .into(),\n         )),\n         // Error occurred while trying to processing impls.\n-        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n         // Inherent ambiguity that prevents us from even enumerating the\n         // candidates.\n-        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n+        ProjectionCandidateSet::Ambiguous => Err(ProjectionError::TooManyCandidates),\n     }\n }\n \n@@ -1124,14 +1119,13 @@ fn project_type<'cx, 'tcx>(\n fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n-    debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::ParamEnv,\n+        ProjectionCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n         false,\n     );\n@@ -1150,7 +1144,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n@@ -1173,7 +1167,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::TraitDef,\n+        ProjectionCandidate::TraitDef,\n         bounds.iter(),\n         true,\n     )\n@@ -1191,7 +1185,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_object_ty(..)\");\n \n@@ -1218,7 +1212,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n         selcx,\n         obligation,\n         candidate_set,\n-        ProjectionTyCandidate::Object,\n+        ProjectionCandidate::Object,\n         env_predicates,\n         false,\n     );\n@@ -1231,14 +1225,13 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n+    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n-        debug!(?predicate);\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n             let data = bound_predicate.rebind(data);\n@@ -1253,8 +1246,6 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                     )\n                 });\n \n-            debug!(?data, ?is_match, ?same_def_id);\n-\n             if is_match {\n                 candidate_set.push_candidate(ctor(data));\n \n@@ -1275,7 +1266,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n@@ -1299,10 +1290,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             super::ImplSource::Closure(_)\n             | super::ImplSource::Generator(_)\n             | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::TraitAlias(_) => {\n-                debug!(?impl_source);\n-                true\n-            }\n+            | super::ImplSource::TraitAlias(_) => true,\n             super::ImplSource::UserDefined(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n@@ -1327,7 +1315,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n+                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;\n \n                 if node_item.is_final() {\n@@ -1500,7 +1488,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         };\n \n         if eligible {\n-            if candidate_set.push_candidate(ProjectionTyCandidate::Select(impl_source)) {\n+            if candidate_set.push_candidate(ProjectionCandidate::Select(impl_source)) {\n                 Ok(())\n             } else {\n                 Err(())\n@@ -1514,30 +1502,32 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n fn confirm_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    candidate: ProjectionTyCandidate<'tcx>,\n+    candidate: ProjectionCandidate<'tcx>,\n ) -> Progress<'tcx> {\n     debug!(?obligation, ?candidate, \"confirm_candidate\");\n     let mut progress = match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection)\n-        | ProjectionTyCandidate::Object(poly_projection) => {\n+        ProjectionCandidate::ParamEnv(poly_projection)\n+        | ProjectionCandidate::Object(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection, false)\n         }\n \n-        ProjectionTyCandidate::TraitDef(poly_projection) => {\n+        ProjectionCandidate::TraitDef(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection, true)\n         }\n \n-        ProjectionTyCandidate::Select(impl_source) => {\n+        ProjectionCandidate::Select(impl_source) => {\n             confirm_select_candidate(selcx, obligation, impl_source)\n         }\n     };\n+\n     // When checking for cycle during evaluation, we compare predicates with\n     // \"syntactic\" equality. Since normalization generally introduces a type\n     // with new region variables, we need to resolve them to existing variables\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n-    if progress.ty.has_infer_regions() {\n-        progress.ty = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty);\n+    if progress.term.has_infer_regions() {\n+        progress.term =\n+            progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx()));\n     }\n     progress\n }\n@@ -1804,7 +1794,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n             // FIXME(associated_const_equality): Handle consts here as well? Maybe this progress type should just take\n             // a term instead.\n-            Progress { ty: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n+            Progress { term: cache_entry.term, obligations: nested_obligations }\n         }\n         Err(e) => {\n             let msg = format!(\n@@ -1813,7 +1803,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n             let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n-            Progress { ty: err, obligations: vec![] }\n+            Progress { term: err.into(), obligations: vec![] }\n         }\n     }\n }\n@@ -1830,9 +1820,9 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n+    let assoc_ty = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n         Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { ty: tcx.ty_error(), obligations: nested },\n+        Err(ErrorReported) => return Progress { term: tcx.ty_error().into(), obligations: nested },\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {\n@@ -1844,7 +1834,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.name, obligation.predicate\n         );\n-        return Progress { ty: tcx.ty_error(), obligations: nested };\n+        return Progress { term: tcx.ty_error().into(), obligations: nested };\n     }\n     // If we're trying to normalize `<Vec<u32> as X>::A<S>` using\n     //`impl<T> X for Vec<T> { type A<Y> = Box<Y>; }`, then:\n@@ -1856,15 +1846,25 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n+    let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n+    let term: ty::Term<'tcx> = if is_const {\n+        let identity_substs =\n+            crate::traits::InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n+        let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n+        let val = ty::ConstKind::Unevaluated(ty::Unevaluated::new(did, identity_substs));\n+        tcx.mk_const(ty::Const { ty, val }).into()\n+    } else {\n+        ty.into()\n+    };\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl item and trait item have different parameter counts\",\n         );\n-        Progress { ty: err, obligations: nested }\n+        Progress { term: err.into(), obligations: nested }\n     } else {\n         assoc_ty_own_obligations(selcx, obligation, &mut nested);\n-        Progress { ty: ty.subst(tcx, substs), obligations: nested }\n+        Progress { term: term.subst(tcx, substs), obligations: nested }\n     }\n }\n \n@@ -1905,10 +1905,10 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_ty_def(\n+fn assoc_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n-    assoc_ty_def_id: DefId,\n+    assoc_def_id: DefId,\n ) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1920,7 +1920,7 @@ fn assoc_ty_def(\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n-    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_ty_def_id) {\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n         let item = tcx.associated_item(impl_item_id);\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         return Ok(specialization_graph::LeafDef {\n@@ -1931,7 +1931,7 @@ fn assoc_ty_def(\n     }\n \n     let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_def_id) {\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n         Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n@@ -1942,7 +1942,7 @@ fn assoc_ty_def(\n         // should have failed in astconv.\n         bug!(\n             \"No associated type `{}` for {}\",\n-            tcx.item_name(assoc_ty_def_id),\n+            tcx.item_name(assoc_def_id),\n             tcx.def_path_str(impl_def_id)\n         )\n     }"}, {"sha": "1de50bae31b8c73522f3373370351f3e3d2cd198", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -36,7 +36,10 @@ fn normalize_projection_ty<'tcx>(\n                 &mut obligations,\n             );\n             fulfill_cx.register_predicate_obligations(infcx, obligations);\n-            Ok(NormalizationResult { normalized_ty: answer })\n+            // FIXME(associated_const_equality): All users of normalize_projection_ty expected\n+            // a type, but there is the possibility it could've been a const now. Maybe change\n+            // it to a Term later?\n+            Ok(NormalizationResult { normalized_ty: answer.ty().unwrap() })\n         },\n     )\n }"}, {"sha": "3e2d7fc3820503b088f352a4229335e8e2910c1e", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -1145,51 +1145,48 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n-        let assoc_ty = tcx\n+        let assoc_item = tcx\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| {\n                 (i.kind == ty::AssocKind::Type || i.kind == ty::AssocKind::Const)\n                     && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n             })\n             .expect(\"missing associated type\");\n-        // FIXME(associated_const_equality): need to handle assoc_consts here as well.\n-        if assoc_ty.kind == ty::AssocKind::Const {\n-            tcx.sess\n-                .struct_span_err(path_span, &format!(\"associated const equality is incomplete\"))\n-                .span_label(path_span, \"cannot yet relate associated const\")\n-                .emit();\n-            return Err(ErrorReported);\n-        }\n \n-        if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n+        if !assoc_item.vis.is_accessible_from(def_scope, tcx) {\n+            let kind = match assoc_item.kind {\n+                ty::AssocKind::Type => \"type\",\n+                ty::AssocKind::Const => \"const\",\n+                _ => unreachable!(),\n+            };\n             tcx.sess\n                 .struct_span_err(\n                     binding.span,\n-                    &format!(\"associated type `{}` is private\", binding.item_name),\n+                    &format!(\"associated {kind} `{}` is private\", binding.item_name),\n                 )\n-                .span_label(binding.span, \"private associated type\")\n+                .span_label(binding.span, &format!(\"private associated {kind}\"))\n                 .emit();\n         }\n-        tcx.check_stability(assoc_ty.def_id, Some(hir_ref_id), binding.span, None);\n+        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n \n         if !speculative {\n             dup_bindings\n-                .entry(assoc_ty.def_id)\n+                .entry(assoc_item.def_id)\n                 .and_modify(|prev_span| {\n                     self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n                         span: binding.span,\n                         prev_span: *prev_span,\n                         item_name: binding.item_name,\n-                        def_path: tcx.def_path_str(assoc_ty.container.id()),\n+                        def_path: tcx.def_path_str(assoc_item.container.id()),\n                     });\n                 })\n                 .or_insert(binding.span);\n         }\n \n         // Include substitutions for generic parameters of associated types\n         let projection_ty = candidate.map_bound(|trait_ref| {\n-            let ident = Ident::new(assoc_ty.name, binding.item_name.span);\n+            let ident = Ident::new(assoc_item.name, binding.item_name.span);\n             let item_segment = hir::PathSegment {\n                 ident,\n                 hir_id: Some(binding.hir_id),\n@@ -1201,7 +1198,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n                 tcx,\n                 path_span,\n-                assoc_ty.def_id,\n+                assoc_item.def_id,\n                 &item_segment,\n                 trait_ref.substs,\n             );\n@@ -1212,14 +1209,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n \n             ty::ProjectionTy {\n-                item_def_id: assoc_ty.def_id,\n+                item_def_id: assoc_item.def_id,\n                 substs: substs_trait_ref_and_assoc_item,\n             }\n         });\n \n         if !speculative {\n             // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref or assoc_ty. These are not well-formed.\n+            // declared in the trait-ref or assoc_item. These are not well-formed.\n             //\n             // Example:\n             //\n@@ -1260,6 +1257,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n+                let assoc_item_def_id = projection_ty.skip_binder().item_def_id;\n+                let def_kind = tcx.def_kind(assoc_item_def_id);\n+                match (def_kind, term) {\n+                    (hir::def::DefKind::AssocTy, ty::Term::Ty(_))\n+                    | (hir::def::DefKind::AssocConst, ty::Term::Const(_)) => (),\n+                    (_, _) => {\n+                        let got = if let ty::Term::Ty(_) = term { \"type\" } else { \"const\" };\n+                        let expected = def_kind.descr(assoc_item_def_id);\n+                        tcx.sess\n+                            .struct_span_err(\n+                                binding.span,\n+                                &format!(\"mismatch in bind of {expected}, got {got}\"),\n+                            )\n+                            .span_note(\n+                                tcx.def_span(assoc_item_def_id),\n+                                &format!(\"{expected} defined here does not match {got}\"),\n+                            )\n+                            .emit();\n+                    }\n+                }\n                 bounds.projection_bounds.push((\n                     projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n                         projection_ty,"}, {"sha": "5cb0d309ff4ee020073f606b143ecaf103f37844", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -1,5 +1,6 @@\n use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n+use rustc_hir::def::CtorOf;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n@@ -160,29 +161,43 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // We've encountered an `AnonConst` in some path, so we need to\n             // figure out which generic parameter it corresponds to and return\n             // the relevant type.\n-            let filtered = path\n-                .segments\n-                .iter()\n-                .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n-                .find_map(|(args, seg)| {\n-                    args.iter()\n-                        .filter(|arg| arg.is_ty_or_const())\n-                        .position(|arg| arg.id() == hir_id)\n-                        .map(|index| (index, seg))\n-                });\n+            let filtered = path.segments.iter().find_map(|seg| {\n+                seg.args?\n+                    .args\n+                    .iter()\n+                    .filter(|arg| arg.is_ty_or_const())\n+                    .position(|arg| arg.id() == hir_id)\n+                    .map(|index| (index, seg))\n+            });\n+\n+            // FIXME(associated_const_generics): can we blend this with iteration above?\n             let (arg_index, segment) = match filtered {\n                 None => {\n-                    tcx.sess\n-                        .delay_span_bug(tcx.def_span(def_id), \"no arg matching AnonConst in path\");\n-                    return None;\n+                    let binding_filtered = path.segments.iter().find_map(|seg| {\n+                        seg.args?\n+                            .bindings\n+                            .iter()\n+                            .filter_map(TypeBinding::opt_const)\n+                            .position(|ct| ct.hir_id == hir_id)\n+                            .map(|idx| (idx, seg))\n+                    });\n+                    match binding_filtered {\n+                        Some(inner) => inner,\n+                        None => {\n+                            tcx.sess.delay_span_bug(\n+                                tcx.def_span(def_id),\n+                                \"no arg matching AnonConst in path\",\n+                            );\n+                            return None;\n+                        }\n+                    }\n                 }\n                 Some(inner) => inner,\n             };\n \n             // Try to use the segment resolution if it is valid, otherwise we\n             // default to the path resolution.\n             let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-            use def::CtorOf;\n             let generics = match res {\n                 Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx\n                     .generics_of(tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap()),\n@@ -483,15 +498,49 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n+                Node::TraitRef(trait_ref @ &TraitRef {\n+                  path, ..\n+                }) if let Some((binding, seg)) =\n+                  path\n+                      .segments\n+                      .iter()\n+                      .find_map(|seg| {\n+                          seg.args?.bindings\n+                              .iter()\n+                              .find_map(|binding| if binding.opt_const()?.hir_id == hir_id {\n+                                Some((binding, seg))\n+                              } else {\n+                                None\n+                              })\n+                      }) =>\n+                {\n+                  // FIXME(associated_const_equality) when does this unwrap fail? I have no idea what case it would.\n+                  let trait_def_id = trait_ref.trait_def_id().unwrap();\n+                  let assoc_items = tcx.associated_items(trait_def_id);\n+                  let assoc_item = assoc_items.find_by_name_and_kind(\n+                    tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n+                  );\n+                  if let Some(assoc_item) = assoc_item {\n+                    tcx.type_of(assoc_item.def_id)\n+                  } else {\n+                      // FIXME(associated_const_equality): add a useful error message here.\n+                      tcx.ty_error_with_message(\n+                        DUMMY_SP,\n+                        &format!(\"Could not find associated const on trait\"),\n+                    )\n+                  }\n+                }\n+\n                 Node::GenericParam(&GenericParam {\n                     hir_id: param_hir_id,\n                     kind: GenericParamKind::Const { default: Some(ct), .. },\n                     ..\n                 }) if ct.hir_id == hir_id => tcx.type_of(tcx.hir().local_def_id(param_hir_id)),\n \n-                x => tcx.ty_error_with_message(\n+                x =>\n+                  tcx.ty_error_with_message(\n                     DUMMY_SP,\n-                    &format!(\"unexpected const parent in type_of(): {:?}\", x),\n+                    &format!(\"unexpected const parent in type_of(): {x:?}\"),\n                 ),\n             }\n         }"}, {"sha": "5e029a12df26f844006de127056f9a30b39a6995", "filename": "src/test/ui/associated-consts/assoc-const-eq-missing.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -0,0 +1,26 @@\n+#![feature(associated_const_equality)]\n+#![allow(unused)]\n+\n+pub trait Foo {\n+  const N: usize;\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+  const N: usize = 3;\n+}\n+\n+\n+fn foo1<F: Foo<Z=3>>() {}\n+//~^ ERROR associated type\n+fn foo2<F: Foo<Z=usize>>() {}\n+//~^ ERROR associated type\n+fn foo3<F: Foo<Z=5>>() {}\n+//~^ ERROR associated type\n+\n+fn main() {\n+  foo1::<Bar>();\n+  foo2::<Bar>();\n+  foo3::<Bar>();\n+}"}, {"sha": "b4bd6456c8517b4482eb2098332e86c0b25bd928", "filename": "src/test/ui/associated-consts/assoc-const-eq-missing.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-eq-missing.stderr?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -0,0 +1,21 @@\n+error[E0220]: associated type `Z` not found for `Foo`\n+  --> $DIR/assoc-const-eq-missing.rs:15:16\n+   |\n+LL | fn foo1<F: Foo<Z=3>>() {}\n+   |                ^ associated type `Z` not found\n+\n+error[E0220]: associated type `Z` not found for `Foo`\n+  --> $DIR/assoc-const-eq-missing.rs:17:16\n+   |\n+LL | fn foo2<F: Foo<Z=usize>>() {}\n+   |                ^ associated type `Z` not found\n+\n+error[E0220]: associated type `Z` not found for `Foo`\n+  --> $DIR/assoc-const-eq-missing.rs:19:16\n+   |\n+LL | fn foo3<F: Foo<Z=5>>() {}\n+   |                ^ associated type `Z` not found\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "c3293156345a79bcadcb4aeaf150400e9bb89704", "filename": "src/test/ui/associated-consts/assoc-const-ty-mismatch.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -0,0 +1,31 @@\n+#![feature(associated_const_equality)]\n+#![allow(unused)]\n+\n+pub trait Foo {\n+  const N: usize;\n+}\n+\n+pub trait FooTy {\n+  type T;\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+  const N: usize = 3;\n+}\n+\n+impl FooTy for Bar {\n+  type T = usize;\n+}\n+\n+\n+fn foo<F: Foo<N=usize>>() {}\n+//~^ ERROR mismatch in\n+fn foo2<F: FooTy<T=3usize>>() {}\n+//~^ ERROR mismatch in\n+\n+fn main() {\n+  foo::<Bar>();\n+  foo2::<Bar>();\n+}"}, {"sha": "703245145ce4e0576bcf7fe213e705b550921571", "filename": "src/test/ui/associated-consts/assoc-const-ty-mismatch.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -0,0 +1,26 @@\n+error: mismatch in bind of associated constant, got type\n+  --> $DIR/assoc-const-ty-mismatch.rs:23:15\n+   |\n+LL | fn foo<F: Foo<N=usize>>() {}\n+   |               ^^^^^^^\n+   |\n+note: associated constant defined here does not match type\n+  --> $DIR/assoc-const-ty-mismatch.rs:5:3\n+   |\n+LL |   const N: usize;\n+   |   ^^^^^^^^^^^^^^^\n+\n+error: mismatch in bind of associated type, got const\n+  --> $DIR/assoc-const-ty-mismatch.rs:25:18\n+   |\n+LL | fn foo2<F: FooTy<T=3usize>>() {}\n+   |                  ^^^^^^^^\n+   |\n+note: associated type defined here does not match const\n+  --> $DIR/assoc-const-ty-mismatch.rs:9:3\n+   |\n+LL |   type T;\n+   |   ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9c7884c80734ca8750a5ae638099657649884968", "filename": "src/test/ui/associated-consts/assoc-const.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -1,4 +1,6 @@\n+// run-pass\n #![feature(associated_const_equality)]\n+#![allow(unused)]\n \n pub trait Foo {\n   const N: usize;\n@@ -13,9 +15,8 @@ impl Foo for Bar {\n const TEST:usize = 3;\n \n \n-fn foo<F: Foo<N=3>>() {}\n-//~^ ERROR associated const equality is incomplete\n-fn bar<F: Foo<N={TEST}>>() {}\n-//~^ ERROR associated const equality is incomplete\n+fn foo<F: Foo<N=3usize>>() {}\n \n-fn main() {}\n+fn main() {\n+  foo::<Bar>()\n+}"}, {"sha": "ccaa6fa8ee8847156bd2170cba80504468f6ce05", "filename": "src/test/ui/associated-consts/assoc-const.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2681f253bcdb31a274411d2be456e7c6a1c67d62/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2681f253bcdb31a274411d2be456e7c6a1c67d62/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr?ref=2681f253bcdb31a274411d2be456e7c6a1c67d62", "patch": "@@ -1,14 +0,0 @@\n-error: associated const equality is incomplete\n-  --> $DIR/assoc-const.rs:16:15\n-   |\n-LL | fn foo<F: Foo<N=3>>() {}\n-   |               ^^^ cannot yet relate associated const\n-\n-error: associated const equality is incomplete\n-  --> $DIR/assoc-const.rs:18:15\n-   |\n-LL | fn bar<F: Foo<N={TEST}>>() {}\n-   |               ^^^^^^^^ cannot yet relate associated const\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "2534c527be4636626a13314a56c5b4f5fc6c1ab2", "filename": "src/test/ui/feature-gates/feature-gate-associated_const_equality.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -9,7 +9,6 @@ impl TraitWAssocConst for Demo {\n \n fn foo<A: TraitWAssocConst<A=32>>() {}\n //~^ ERROR associated const equality\n-//~| ERROR associated const equality\n \n fn main() {\n   foo::<Demo>();"}, {"sha": "6563fbcba2e4bd6880c90320eeab4ffcc2c31cbb", "filename": "src/test/ui/feature-gates/feature-gate-associated_const_equality.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4851715893ee3f365a8ef09d47165e9a7864f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr?ref=1ea4851715893ee3f365a8ef09d47165e9a7864f", "patch": "@@ -7,12 +7,6 @@ LL | fn foo<A: TraitWAssocConst<A=32>>() {}\n    = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n    = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n \n-error: associated const equality is incomplete\n-  --> $DIR/feature-gate-associated_const_equality.rs:10:28\n-   |\n-LL | fn foo<A: TraitWAssocConst<A=32>>() {}\n-   |                            ^^^^ cannot yet relate associated const\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}]}