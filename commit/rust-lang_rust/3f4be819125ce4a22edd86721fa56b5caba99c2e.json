{"sha": "3f4be819125ce4a22edd86721fa56b5caba99c2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNGJlODE5MTI1Y2U0YTIyZWRkODY3MjFmYTU2YjVjYWJhOTljMmU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T09:05:55Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T09:05:55Z"}, "message": "Merge #449\n\n449: switch to new rowan API r=matklad a=matklad\n\ncloses https://github.com/rust-analyzer/rust-analyzer/issues/448\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "be93895ddc08c911585d9f7bc64623a3741f32c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be93895ddc08c911585d9f7bc64623a3741f32c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f4be819125ce4a22edd86721fa56b5caba99c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4be819125ce4a22edd86721fa56b5caba99c2e", "html_url": "https://github.com/rust-lang/rust/commit/3f4be819125ce4a22edd86721fa56b5caba99c2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f4be819125ce4a22edd86721fa56b5caba99c2e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "4e444d2bc24d16284401444fd2154f63e0f96070", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e444d2bc24d16284401444fd2154f63e0f96070", "html_url": "https://github.com/rust-lang/rust/commit/4e444d2bc24d16284401444fd2154f63e0f96070"}, {"sha": "122410d7aa34a32d468a3173858cbc8a2bbc68f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/122410d7aa34a32d468a3173858cbc8a2bbc68f5", "html_url": "https://github.com/rust-lang/rust/commit/122410d7aa34a32d468a3173858cbc8a2bbc68f5"}], "stats": {"total": 6266, "additions": 2504, "deletions": 3762}, "files": [{"sha": "6ef51fed0ccaa54a4318204b45ac3c54a0df0fd8", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -221,7 +221,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -284,7 +284,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -295,7 +295,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"flexi_logger\"\n-version = \"0.10.3\"\n+version = \"0.10.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -501,7 +501,7 @@ dependencies = [\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -585,7 +585,7 @@ dependencies = [\n  \"pest_meta 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -706,7 +706,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n@@ -728,7 +728,7 @@ dependencies = [\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gen_lsp_server 0.1.0\",\n  \"im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.53.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -764,7 +764,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -969,7 +969,7 @@ dependencies = [\n \n [[package]]\n name = \"rowan\"\n-version = \"0.1.4\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1075,7 +1075,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1140,7 +1140,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"syn\"\n-version = \"0.15.23\"\n+version = \"0.15.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1155,7 +1155,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1510,7 +1510,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n-\"checksum flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dda06444ccc8b0a6da19d939989b4a4e83f328710ada449eedaed48c8b903cd\"\n+\"checksum flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d3681306880a7ce87740ceb3d1ce98ca92ae636ff30a629494488cbbcf85ff8\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db72126ca7dff566cdbbdd54af44668c544897d9d3862b198141f176f1238bdf\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n@@ -1571,7 +1571,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7790c7f1cc73d831d28dc5a7deb316a006e7848e6a7f467cdb10a0a9e0fb1c\"\n \"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n \"checksum ron 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c48677d8a9247a4e0d1f3f9cb4b0a8e29167fdc3c04f383a5e669cd7a960ae0f\"\n-\"checksum rowan 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c218b4430ab922850b71b14fa9bca224425097f935f6155c0b6a4b1f398a54f0\"\n+\"checksum rowan 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9ae7dba5e703f423ceb8646d636c73e6d858a2f8c834808b4565e42ccda9e2\"\n \"checksum rustc-demangle 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"adacaae16d02b6ec37fdc7acfcddf365978de76d1983d3ee22afc260e1ca9619\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n@@ -1593,7 +1593,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum superslice 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b50b13d42370e0f5fc62eafdd5c2d20065eaf5458dab215ff3e20e63eea96b30\"\n-\"checksum syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9545a6a093a3f0bd59adb472700acc08cad3776f860f16a897dfce8c88721cbc\"\n+\"checksum syn 0.15.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"734ecc29cd36e8123850d9bf21dfd62ef8300aaa8f879aabaa899721808be37c\"\n \"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015\"\n \"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n \"checksum tera 0.11.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4b505279e19d8f7d24b1a9dc58327c9c36174b1a2c7ebdeac70792d017cb64f3\""}, {"sha": "c1739e47eab5f04673ce5db26bdb28b0ac6fcd1a", "filename": "crates/ra_analysis/src/completion/complete_fn_param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -39,9 +39,9 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n                 .add_to(acc)\n         });\n \n-    fn process<'a, N: ast::FnDefOwner<'a>>(\n-        node: N,\n-        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    fn process<'a, N: ast::FnDefOwner>(\n+        node: &'a N,\n+        params: &mut FxHashMap<String, (u32, &'a ast::Param)>,\n     ) {\n         node.functions()\n             .filter_map(|it| it.param_list())"}, {"sha": "d350f06ceb60f2551cff11f6cb8932e040edc925", "filename": "crates/ra_analysis/src/completion/complete_keyword.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -2,7 +2,7 @@ use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     AstNode,\n     ast::{self, LoopBodyOwner},\n-    SyntaxKind::*, SyntaxNodeRef,\n+    SyntaxKind::*, SyntaxNode,\n };\n \n use crate::completion::{CompletionContext, CompletionItem, Completions, CompletionKind, CompletionItemKind};\n@@ -76,7 +76,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     acc.add_all(complete_return(fn_def, ctx.can_be_stmt));\n }\n \n-fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n+fn is_in_loop_body(leaf: &SyntaxNode) -> bool {\n     for node in leaf.ancestors() {\n         if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n             break;\n@@ -95,7 +95,7 @@ fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n     false\n }\n \n-fn complete_return(fn_def: ast::FnDef, can_be_stmt: bool) -> Option<CompletionItem> {\n+fn complete_return(fn_def: &ast::FnDef, can_be_stmt: bool) -> Option<CompletionItem> {\n     let snip = match (can_be_stmt, fn_def.ret_type().is_some()) {\n         (true, true) => \"return $0;\",\n         (true, false) => \"return;\","}, {"sha": "988c21c58d3de30c378d228f9e2ca117c69bfdee", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,13 +1,9 @@\n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{\n-    algo::{find_leaf_at_offset, find_covering_node},\n+    AstNode, SyntaxNode, SourceFile, TextUnit, TextRange,\n     ast,\n-    AstNode,\n-    SyntaxNodeRef,\n-    SourceFileNode,\n-    TextUnit,\n-    TextRange,\n+    algo::{find_leaf_at_offset, find_covering_node},\n     SyntaxKind::*,\n };\n use hir::source_binder;\n@@ -20,11 +16,11 @@ use crate::{db, FilePosition, Cancelable};\n pub(super) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n     pub(super) offset: TextUnit,\n-    pub(super) leaf: SyntaxNodeRef<'a>,\n+    pub(super) leaf: &'a SyntaxNode,\n     pub(super) module: Option<hir::Module>,\n     pub(super) function: Option<hir::Function>,\n-    pub(super) function_syntax: Option<ast::FnDef<'a>>,\n-    pub(super) use_item_syntax: Option<ast::UseItem<'a>>,\n+    pub(super) function_syntax: Option<&'a ast::FnDef>,\n+    pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n     pub(super) is_param: bool,\n     /// A single-indent path, like `foo`.\n     pub(super) is_trivial_path: bool,\n@@ -36,15 +32,15 @@ pub(super) struct CompletionContext<'a> {\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     pub(super) is_new_item: bool,\n     /// The receiver if this is a field or method access, i.e. writing something.<|>\n-    pub(super) dot_receiver: Option<ast::Expr<'a>>,\n+    pub(super) dot_receiver: Option<&'a ast::Expr>,\n     /// If this is a method call in particular, i.e. the () are already there.\n     pub(super) is_method_call: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n     pub(super) fn new(\n         db: &'a db::RootDatabase,\n-        original_file: &'a SourceFileNode,\n+        original_file: &'a SourceFile,\n         position: FilePosition,\n     ) -> Cancelable<Option<CompletionContext<'a>>> {\n         let module = source_binder::module_from_position(db, position)?;\n@@ -71,7 +67,7 @@ impl<'a> CompletionContext<'a> {\n         Ok(Some(ctx))\n     }\n \n-    fn fill(&mut self, original_file: &'a SourceFileNode, offset: TextUnit) {\n+    fn fill(&mut self, original_file: &'a SourceFile, offset: TextUnit) {\n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n@@ -100,7 +96,7 @@ impl<'a> CompletionContext<'a> {\n             }\n         }\n     }\n-    fn classify_name_ref(&mut self, original_file: &'a SourceFileNode, name_ref: ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n         let top_node = name_ref\n             .syntax()\n@@ -197,15 +193,12 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn find_node_with_range<'a, N: AstNode<'a>>(\n-    syntax: SyntaxNodeRef<'a>,\n-    range: TextRange,\n-) -> Option<N> {\n+fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<&N> {\n     let node = find_covering_node(syntax, range);\n     node.ancestors().find_map(N::cast)\n }\n \n-fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n+fn is_node<N: AstNode>(node: &SyntaxNode) -> bool {\n     match node.ancestors().filter_map(N::cast).next() {\n         None => false,\n         Some(n) => n.syntax().range() == node.range(),"}, {"sha": "3b130f96648d3879d9c34eb85fc0ecab22f1a65d", "filename": "crates/ra_analysis/src/extend_selection.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,6 +1,6 @@\n use ra_db::SyntaxDatabase;\n use ra_syntax::{\n-    SyntaxNodeRef, AstNode, SourceFileNode,\n+    SyntaxNode, AstNode, SourceFile,\n     ast, algo::find_covering_node,\n };\n \n@@ -19,18 +19,18 @@ pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRang\n \n fn extend_selection_in_macro(\n     _db: &RootDatabase,\n-    source_file: &SourceFileNode,\n+    source_file: &SourceFile,\n     frange: FileRange,\n ) -> Option<TextRange> {\n     let macro_call = find_macro_call(source_file.syntax(), frange.range)?;\n     let (off, exp) = hir::MacroDef::ast_expand(macro_call)?;\n     let dst_range = exp.map_range_forward(frange.range - off)?;\n-    let dst_range = ra_editor::extend_selection(exp.syntax().borrowed(), dst_range)?;\n+    let dst_range = ra_editor::extend_selection(&exp.syntax(), dst_range)?;\n     let src_range = exp.map_range_back(dst_range)? + off;\n     Some(src_range)\n }\n \n-fn find_macro_call(node: SyntaxNodeRef, range: TextRange) -> Option<ast::MacroCall> {\n+fn find_macro_call(node: &SyntaxNode, range: TextRange) -> Option<&ast::MacroCall> {\n     find_covering_node(node, range)\n         .ancestors()\n         .find_map(ast::MacroCall::cast)"}, {"sha": "0bcf13ebde4574735dc08399e2cb98d8cffca43a", "filename": "crates/ra_analysis/src/goto_defenition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn goto_defenition(\n pub(crate) fn reference_defenition(\n     db: &RootDatabase,\n     file_id: FileId,\n-    name_ref: ast::NameRef,\n+    name_ref: &ast::NameRef,\n ) -> Cancelable<Vec<NavigationTarget>> {\n     if let Some(fn_descr) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n@@ -53,7 +53,7 @@ pub(crate) fn reference_defenition(\n fn name_defenition(\n     db: &RootDatabase,\n     file_id: FileId,\n-    name: ast::Name,\n+    name: &ast::Name,\n ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n     if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n         if module.has_semi() {"}, {"sha": "5607c3ef313513514518053dd3e624f1b79de374", "filename": "crates/ra_analysis/src/hover.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,7 +1,7 @@\n use ra_db::{Cancelable, SyntaxDatabase};\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    AstNode, SyntaxNode,\n+    AstNode, SyntaxNode, TreePtr,\n     ast::{self, NameOwner},\n     algo::{find_covering_node, find_leaf_at_offset, visit::{visitor, Visitor}},\n };\n@@ -88,20 +88,19 @@ fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<S\n }\n \n impl NavigationTarget {\n-    fn node(&self, db: &RootDatabase) -> Option<SyntaxNode> {\n+    fn node(&self, db: &RootDatabase) -> Option<TreePtr<SyntaxNode>> {\n         let source_file = db.source_file(self.file_id);\n         let source_file = source_file.syntax();\n         let node = source_file\n             .descendants()\n             .find(|node| node.kind() == self.kind && node.range() == self.range)?\n-            .owned();\n+            .to_owned();\n         Some(node)\n     }\n \n     fn docs(&self, db: &RootDatabase) -> Option<String> {\n         let node = self.node(db)?;\n-        let node = node.borrowed();\n-        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+        fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n             let comments = node.doc_comment_text();\n             if comments.is_empty() {\n                 None\n@@ -119,7 +118,7 @@ impl NavigationTarget {\n             .visit(doc_comments::<ast::TypeDef>)\n             .visit(doc_comments::<ast::ConstDef>)\n             .visit(doc_comments::<ast::StaticDef>)\n-            .accept(node)?\n+            .accept(&node)?\n     }\n \n     /// Get a description of this node.\n@@ -128,50 +127,49 @@ impl NavigationTarget {\n     fn description(&self, db: &RootDatabase) -> Option<String> {\n         // TODO: After type inference is done, add type information to improve the output\n         let node = self.node(db)?;\n-        let node = node.borrowed();\n         // TODO: Refactor to be have less repetition\n         visitor()\n-            .visit(|node: ast::FnDef| {\n+            .visit(|node: &ast::FnDef| {\n                 let mut string = \"fn \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::StructDef| {\n+            .visit(|node: &ast::StructDef| {\n                 let mut string = \"struct \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::EnumDef| {\n+            .visit(|node: &ast::EnumDef| {\n                 let mut string = \"enum \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::TraitDef| {\n+            .visit(|node: &ast::TraitDef| {\n                 let mut string = \"trait \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::Module| {\n+            .visit(|node: &ast::Module| {\n                 let mut string = \"mod \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::TypeDef| {\n+            .visit(|node: &ast::TypeDef| {\n                 let mut string = \"type \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::ConstDef| {\n+            .visit(|node: &ast::ConstDef| {\n                 let mut string = \"const \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .visit(|node: ast::StaticDef| {\n+            .visit(|node: &ast::StaticDef| {\n                 let mut string = \"static \".to_string();\n                 node.name()?.syntax().text().push_to(&mut string);\n                 Some(string)\n             })\n-            .accept(node)?\n+            .accept(&node)?\n     }\n }\n "}, {"sha": "8ac430e416b9bd944c278295b9690381516b6945", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -8,10 +8,9 @@ use hir::{\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, assists, LocalEdit, Severity};\n use ra_syntax::{\n-    ast::{self, ArgListOwner, Expr, NameOwner},\n-    AstNode, SourceFileNode,\n+    SyntaxNode, TextRange, TextUnit, AstNode, SourceFile,\n+    ast::{self, ArgListOwner, NameOwner},\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -113,7 +112,6 @@ impl db::RootDatabase {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n-        let ast_module = ast_module.borrowed();\n         let name = ast_module.name().unwrap();\n         Ok(vec![NavigationTarget {\n             file_id,\n@@ -163,9 +161,9 @@ impl db::RootDatabase {\n \n         fn find_binding<'a>(\n             db: &db::RootDatabase,\n-            source_file: &'a SourceFileNode,\n+            source_file: &'a SourceFile,\n             position: FilePosition,\n-        ) -> Cancelable<Option<(ast::BindPat<'a>, hir::Function)>> {\n+        ) -> Cancelable<Option<(&'a ast::BindPat, hir::Function)>> {\n             let syntax = source_file.syntax();\n             if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n                 let descr = ctry!(source_binder::function_from_child_node(\n@@ -281,7 +279,7 @@ impl db::RootDatabase {\n             if symbol.ptr.kind() == FN_DEF {\n                 let fn_file = self.source_file(symbol.file_id);\n                 let fn_def = symbol.ptr.resolve(&fn_file);\n-                let fn_def = ast::FnDef::cast(fn_def.borrowed()).unwrap();\n+                let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n                 let descr = ctry!(source_binder::function_from_source(\n                     self,\n                     symbol.file_id,\n@@ -352,7 +350,7 @@ impl db::RootDatabase {\n             .collect::<Vec<_>>();\n         Ok(res)\n     }\n-    pub(crate) fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n+    pub(crate) fn index_resolve(&self, name_ref: &ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();\n@@ -379,12 +377,12 @@ impl SourceChange {\n }\n \n enum FnCallNode<'a> {\n-    CallExpr(ast::CallExpr<'a>),\n-    MethodCallExpr(ast::MethodCallExpr<'a>),\n+    CallExpr(&'a ast::CallExpr),\n+    MethodCallExpr(&'a ast::MethodCallExpr),\n }\n \n impl<'a> FnCallNode<'a> {\n-    pub fn with_node(syntax: SyntaxNodeRef, offset: TextUnit) -> Option<FnCallNode> {\n+    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n         if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n             return Some(FnCallNode::CallExpr(expr));\n         }\n@@ -394,10 +392,10 @@ impl<'a> FnCallNode<'a> {\n         None\n     }\n \n-    pub fn name_ref(&self) -> Option<ast::NameRef> {\n+    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n         match *self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()? {\n-                Expr::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n+            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n+                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n                 _ => return None,\n             }),\n \n@@ -409,7 +407,7 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n \n-    pub fn arg_list(&self) -> Option<ast::ArgList> {\n+    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n         match *self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),"}, {"sha": "ec400ffe23d0f2011e09d639c2079f2f13e32833", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -26,7 +26,7 @@ mod syntax_highlighting;\n \n use std::{fmt, sync::Arc};\n \n-use ra_syntax::{SmolStr, SourceFileNode, SyntaxKind, TextRange, TextUnit};\n+use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n@@ -308,7 +308,7 @@ impl Analysis {\n         self.db.file_text(file_id)\n     }\n     /// Gets the syntax tree of the file.\n-    pub fn file_syntax(&self, file_id: FileId) -> SourceFileNode {\n+    pub fn file_syntax(&self, file_id: FileId) -> TreePtr<SourceFile> {\n         self.db.source_file(file_id).clone()\n     }\n     /// Gets the file's `LineIndex`: data structure to convert between absolute\n@@ -322,7 +322,7 @@ impl Analysis {\n     }\n     /// Returns position of the mathcing brace (all types of braces are\n     /// supported).\n-    pub fn matching_brace(&self, file: &SourceFileNode, offset: TextUnit) -> Option<TextUnit> {\n+    pub fn matching_brace(&self, file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n         ra_editor::matching_brace(file, offset)\n     }\n     /// Returns a syntax tree represented as `String`, for debug purposes.\n@@ -469,7 +469,7 @@ impl LibraryData {\n         files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n     ) -> LibraryData {\n         let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n-            let file = SourceFileNode::parse(text);\n+            let file = SourceFile::parse(text);\n             (*file_id, file)\n         }));\n         let mut root_change = RootChange::default();"}, {"sha": "98b1d2d5521170cc57d3ab4767d8da72a37500b3", "filename": "crates/ra_analysis/src/runnables.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Frunnables.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use ra_syntax::{\n+    TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner, ModuleItemOwner},\n-    TextRange, SyntaxNodeRef,\n };\n use ra_db::{Cancelable, SyntaxDatabase};\n \n@@ -30,7 +30,7 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Ru\n     Ok(res)\n }\n \n-fn runnable(db: &RootDatabase, file_id: FileId, item: SyntaxNodeRef) -> Option<Runnable> {\n+fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {\n     if let Some(fn_def) = ast::FnDef::cast(item) {\n         runnable_fn(fn_def)\n     } else if let Some(m) = ast::Module::cast(item) {\n@@ -40,7 +40,7 @@ fn runnable(db: &RootDatabase, file_id: FileId, item: SyntaxNodeRef) -> Option<R\n     }\n }\n \n-fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n+fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n     let name = fn_def.name()?.text();\n     let kind = if name == \"main\" {\n         RunnableKind::Bin\n@@ -57,12 +57,12 @@ fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n     })\n }\n \n-fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Option<Runnable> {\n+fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n         .items()\n-        .filter_map(|it| match it {\n-            ast::ModuleItem::FnDef(it) => Some(it),\n+        .filter_map(|it| match it.kind() {\n+            ast::ModuleItemKind::FnDef(it) => Some(it),\n             _ => None,\n         })\n         .any(|f| f.has_atom_attr(\"test\"));"}, {"sha": "ed179675643618037473cefd08cbe0f5dcb5c385", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -27,7 +27,7 @@ use std::{\n \n use fst::{self, Streamer};\n use ra_syntax::{\n-    SyntaxNodeRef, SourceFileNode, SmolStr,\n+    SyntaxNode, SourceFile, SmolStr, TreePtr, AstNode,\n     algo::{visit::{visitor, Visitor}, find_covering_node},\n     SyntaxKind::{self, *},\n     ast::{self, NameOwner},\n@@ -141,7 +141,7 @@ impl SymbolIndex {\n     }\n \n     pub(crate) fn for_files(\n-        files: impl ParallelIterator<Item = (FileId, SourceFileNode)>,\n+        files: impl ParallelIterator<Item = (FileId, TreePtr<SourceFile>)>,\n     ) -> SymbolIndex {\n         let symbols = files\n             .flat_map(|(file_id, file)| {\n@@ -203,8 +203,8 @@ pub(crate) struct FileSymbol {\n     pub(crate) ptr: LocalSyntaxPtr,\n }\n \n-fn to_symbol(node: SyntaxNodeRef) -> Option<(SmolStr, LocalSyntaxPtr)> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<(SmolStr, LocalSyntaxPtr)> {\n+fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, LocalSyntaxPtr)> {\n+    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, LocalSyntaxPtr)> {\n         let name = node.name()?.text();\n         let ptr = LocalSyntaxPtr::new(node.syntax());\n         Some((name, ptr))"}, {"sha": "d2dc6cfbb9b4a1e3746cfb4bf086757394f91f38", "filename": "crates/ra_analysis/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -16,7 +16,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Hi\n         .filter_map(ast::MacroCall::cast)\n     {\n         if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n-            let mapped_ranges = ra_editor::highlight(exp.syntax().borrowed())\n+            let mapped_ranges = ra_editor::highlight(&exp.syntax())\n                 .into_iter()\n                 .filter_map(|r| {\n                     let mapped_range = exp.map_range_back(r.range)?;"}, {"sha": "0d12f3a88a820e56e20d1acf90be89edcec86feb", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -3,7 +3,7 @@ use std::{fs, io::Read, path::Path, time::Instant};\n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n use ra_editor::{extend_selection, file_structure, syntax_tree};\n-use ra_syntax::{SourceFileNode, TextRange};\n+use ra_syntax::{SourceFile, TextRange, TreePtr, AstNode};\n use tools::collect_tests;\n \n type Result<T> = ::std::result::Result<T, failure::Error>;\n@@ -71,9 +71,9 @@ fn main() -> Result<()> {\n     Ok(())\n }\n \n-fn file() -> Result<SourceFileNode> {\n+fn file() -> Result<TreePtr<SourceFile>> {\n     let text = read_stdin()?;\n-    Ok(SourceFileNode::parse(&text))\n+    Ok(SourceFile::parse(&text))\n }\n \n fn read_stdin() -> Result<String> {\n@@ -92,12 +92,12 @@ fn render_test(file: &Path, line: usize) -> Result<(String, String)> {\n         None => failure::bail!(\"No test found at line {} at {}\", line, file.display()),\n         Some((_start_line, test)) => test,\n     };\n-    let file = SourceFileNode::parse(&test.text);\n+    let file = SourceFile::parse(&test.text);\n     let tree = syntax_tree(&file);\n     Ok((test.text, tree))\n }\n \n-fn selections(file: &SourceFileNode, start: u32, end: u32) -> String {\n+fn selections(file: &SourceFile, start: u32, end: u32) -> String {\n     let mut ranges = Vec::new();\n     let mut cur = Some(TextRange::from_to((start - 1).into(), (end - 1).into()));\n     while let Some(r) = cur {"}, {"sha": "3c41ee56dafd0d9507ab903046ce1bb60bc3c7e3", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -8,7 +8,7 @@ pub mod mock;\n use std::sync::Arc;\n \n use ra_editor::LineIndex;\n-use ra_syntax::{TextUnit, TextRange, SourceFileNode};\n+use ra_syntax::{TextUnit, TextRange, SourceFile, TreePtr};\n \n pub use crate::{\n     cancelation::{Canceled, Cancelable},\n@@ -47,7 +47,7 @@ pub trait BaseDatabase: salsa::Database {\n \n salsa::query_group! {\n     pub trait SyntaxDatabase: crate::input::FilesDatabase + BaseDatabase {\n-        fn source_file(file_id: FileId) -> SourceFileNode {\n+        fn source_file(file_id: FileId) -> TreePtr<SourceFile> {\n             type SourceFileQuery;\n         }\n         fn file_lines(file_id: FileId) -> Arc<LineIndex> {\n@@ -56,9 +56,9 @@ salsa::query_group! {\n     }\n }\n \n-fn source_file(db: &impl SyntaxDatabase, file_id: FileId) -> SourceFileNode {\n+fn source_file(db: &impl SyntaxDatabase, file_id: FileId) -> TreePtr<SourceFile> {\n     let text = db.file_text(file_id);\n-    SourceFileNode::parse(&*text)\n+    SourceFile::parse(&*text)\n }\n fn file_lines(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<LineIndex> {\n     let text = db.file_text(file_id);"}, {"sha": "be64d417cee6c49df2eca6478a1462bd3592a3b2", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, TextRange};\n+use ra_syntax::{AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, TreePtr};\n \n /// A pointer to a syntax node inside a file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -8,18 +8,18 @@ pub struct LocalSyntaxPtr {\n }\n \n impl LocalSyntaxPtr {\n-    pub fn new(node: SyntaxNodeRef) -> LocalSyntaxPtr {\n+    pub fn new(node: &SyntaxNode) -> LocalSyntaxPtr {\n         LocalSyntaxPtr {\n             range: node.range(),\n             kind: node.kind(),\n         }\n     }\n \n-    pub fn resolve(self, file: &SourceFileNode) -> SyntaxNode {\n+    pub fn resolve(self, file: &SourceFile) -> TreePtr<SyntaxNode> {\n         let mut curr = file.syntax();\n         loop {\n             if curr.range() == self.range && curr.kind() == self.kind {\n-                return curr.owned();\n+                return curr.to_owned();\n             }\n             curr = curr\n                 .children()\n@@ -40,13 +40,13 @@ impl LocalSyntaxPtr {\n #[test]\n fn test_local_syntax_ptr() {\n     use ra_syntax::{ast, AstNode};\n-    let file = SourceFileNode::parse(\"struct Foo { f: u32, }\");\n+    let file = SourceFile::parse(\"struct Foo { f: u32, }\");\n     let field = file\n         .syntax()\n         .descendants()\n         .find_map(ast::NamedFieldDef::cast)\n         .unwrap();\n     let ptr = LocalSyntaxPtr::new(field.syntax());\n     let field_syntax = ptr.resolve(&file);\n-    assert_eq!(field.syntax(), field_syntax);\n+    assert_eq!(field.syntax(), &*field_syntax);\n }"}, {"sha": "a320caabfaadbda480707db570de82234e1e8733", "filename": "crates/ra_editor/src/assists.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -12,7 +12,7 @@ mod split_import;\n \n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n-    Direction, SyntaxNodeRef, TextUnit, TextRange,SourceFileNode, AstNode,\n+    Direction, SyntaxNode, TextUnit, TextRange, SourceFile, AstNode,\n     algo::{find_leaf_at_offset, find_covering_node, LeafAtOffset},\n };\n \n@@ -28,7 +28,7 @@ pub use self::{\n };\n \n /// Return all the assists applicable at the given position.\n-pub fn assists(file: &SourceFileNode, range: TextRange) -> Vec<LocalEdit> {\n+pub fn assists(file: &SourceFile, range: TextRange) -> Vec<LocalEdit> {\n     let ctx = AssistCtx::new(file, range);\n     [\n         flip_comma,\n@@ -50,7 +50,7 @@ pub struct LocalEdit {\n     pub cursor_position: Option<TextUnit>,\n }\n \n-fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<SyntaxNodeRef> {\n+fn non_trivia_sibling(node: &SyntaxNode, direction: Direction) -> Option<&SyntaxNode> {\n     node.siblings(direction)\n         .skip(1)\n         .find(|node| !node.kind().is_trivia())\n@@ -88,7 +88,7 @@ fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<Synta\n /// easier to just compute the edit eagarly :-)\n #[derive(Debug, Clone)]\n pub struct AssistCtx<'a> {\n-    source_file: &'a SourceFileNode,\n+    source_file: &'a SourceFile,\n     range: TextRange,\n     should_compute_edit: bool,\n }\n@@ -106,7 +106,7 @@ struct AssistBuilder {\n }\n \n impl<'a> AssistCtx<'a> {\n-    pub fn new(source_file: &'a SourceFileNode, range: TextRange) -> AssistCtx {\n+    pub fn new(source_file: &'a SourceFile, range: TextRange) -> AssistCtx {\n         AssistCtx {\n             source_file,\n             range,\n@@ -145,13 +145,13 @@ impl<'a> AssistCtx<'a> {\n         }))\n     }\n \n-    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<SyntaxNodeRef<'a>> {\n+    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<&'a SyntaxNode> {\n         find_leaf_at_offset(self.source_file.syntax(), self.range.start())\n     }\n-    pub(crate) fn node_at_offset<N: AstNode<'a>>(&self) -> Option<N> {\n+    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n         find_node_at_offset(self.source_file.syntax(), self.range.start())\n     }\n-    pub(crate) fn covering_node(&self) -> SyntaxNodeRef<'a> {\n+    pub(crate) fn covering_node(&self) -> &'a SyntaxNode {\n         find_covering_node(self.source_file.syntax(), self.range)\n     }\n }"}, {"sha": "6e964d011bdfe4445522b0567fcf9b8347dd2607", "filename": "crates/ra_editor/src/assists/add_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -28,7 +28,7 @@ pub fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n }\n \n // Insert `derive` after doc comments.\n-fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n+fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n     let non_ws_child = nominal\n         .syntax()\n         .children()"}, {"sha": "89729e2c251aed548ecb12d4de773be8c5699430", "filename": "crates/ra_editor/src/assists/change_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -46,7 +46,7 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(ctx: AssistCtx, vis: &ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() != \"pub\" {\n         return None;\n     }"}, {"sha": "523ec7034f2da3bd4f56289990f379b58dfa742a", "filename": "crates/ra_editor/src/assists/introduce_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,7 +1,7 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::WHITESPACE,\n-    SyntaxNodeRef, TextUnit,\n+    SyntaxNode, TextUnit,\n };\n \n use crate::assists::{AssistCtx, Assist};\n@@ -39,7 +39,7 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n \n /// Statement or last in the block expression, which will follow\n /// the freshly introduced var.\n-fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n+fn anchor_stmt(expr: &ast::Expr) -> Option<&SyntaxNode> {\n     expr.syntax().ancestors().find(|&node| {\n         if ast::Stmt::cast(node).is_some() {\n             return true;"}, {"sha": "2b695dfdfc486e151bf4a5a03845c0997b0f650f", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,25 +1,15 @@\n use itertools::Itertools;\n \n use ra_syntax::{\n+    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n     ast::{self, AstNode},\n-    Location,\n-    SourceFileNode,\n-    SyntaxKind,\n-    TextRange,\n-};\n-use ra_syntax::SyntaxNodeRef;\n-use ra_text_edit::{\n-    TextEdit,\n-    TextEditBuilder,\n-};\n \n-use crate::{\n-    Diagnostic,\n-    LocalEdit,\n-    Severity,\n };\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+\n+use crate::{Diagnostic, LocalEdit, Severity};\n \n-pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n+pub fn diagnostics(file: &SourceFile) -> Vec<Diagnostic> {\n     fn location_to_range(location: Location) -> TextRange {\n         match location {\n             Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n@@ -48,7 +38,7 @@ pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n \n fn check_unnecessary_braces_in_use_statement(\n     acc: &mut Vec<Diagnostic>,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node)?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n@@ -79,7 +69,7 @@ fn check_unnecessary_braces_in_use_statement(\n }\n \n fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: ast::UseTree,\n+    single_use_tree: &ast::UseTree,\n ) -> Option<TextEdit> {\n     let use_tree_list_node = single_use_tree.syntax().parent()?;\n     if single_use_tree\n@@ -102,7 +92,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n \n fn check_struct_shorthand_initialization(\n     acc: &mut Vec<Diagnostic>,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Option<()> {\n     let struct_lit = ast::StructLit::cast(node)?;\n     let named_field_list = struct_lit.named_field_list()?;\n@@ -138,10 +128,10 @@ mod tests {\n \n     use super::*;\n \n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, SyntaxNodeRef) -> Option<()>;\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n \n     fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let file = SourceFileNode::parse(code);\n+        let file = SourceFile::parse(code);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n             func(&mut diagnostics, node);\n@@ -150,7 +140,7 @@ mod tests {\n     }\n \n     fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let file = SourceFileNode::parse(before);\n+        let file = SourceFile::parse(before);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n             func(&mut diagnostics, node);"}, {"sha": "08cae5a51616f7e62ae8b607721dd9ee2eb26de8", "filename": "crates/ra_editor/src/extend_selection.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,11 +1,10 @@\n use ra_syntax::{\n+    Direction, SyntaxNode, TextRange, TextUnit,\n     algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n-    Direction,\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n-pub fn extend_selection(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange> {\n+pub fn extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     if range.is_empty() {\n         let offset = range.start();\n@@ -40,7 +39,7 @@ pub fn extend_selection(root: SyntaxNodeRef, range: TextRange) -> Option<TextRan\n }\n \n fn extend_single_word_in_comment_or_string(\n-    leaf: SyntaxNodeRef,\n+    leaf: &SyntaxNode,\n     offset: TextUnit,\n ) -> Option<TextRange> {\n     let text: &str = leaf.leaf_text()?;\n@@ -66,7 +65,7 @@ fn extend_single_word_in_comment_or_string(\n     }\n }\n \n-fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRange {\n+fn extend_ws(root: &SyntaxNode, ws: &SyntaxNode, offset: TextUnit) -> TextRange {\n     let ws_text = ws.leaf_text().unwrap();\n     let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n     let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n@@ -89,9 +88,9 @@ fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRa\n     ws.range()\n }\n \n-fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a> {\n+fn pick_best<'a>(l: &'a SyntaxNode, r: &'a SyntaxNode) -> &'a SyntaxNode {\n     return if priority(r) > priority(l) { r } else { l };\n-    fn priority(n: SyntaxNodeRef) -> usize {\n+    fn priority(n: &SyntaxNode) -> usize {\n         match n.kind() {\n             WHITESPACE => 0,\n             IDENT | SELF_KW | SUPER_KW | CRATE_KW | LIFETIME => 2,\n@@ -100,7 +99,7 @@ fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a\n     }\n }\n \n-fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n+fn extend_comments(node: &SyntaxNode) -> Option<TextRange> {\n     let prev = adj_comments(node, Direction::Prev);\n     let next = adj_comments(node, Direction::Next);\n     if prev != next {\n@@ -110,7 +109,7 @@ fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n     }\n }\n \n-fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n+fn adj_comments(node: &SyntaxNode, dir: Direction) -> &SyntaxNode {\n     let mut res = node;\n     for node in node.siblings(dir) {\n         match node.kind() {\n@@ -124,13 +123,14 @@ fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use ra_syntax::SourceFileNode;\n+    use ra_syntax::{SourceFile, AstNode};\n     use test_utils::extract_offset;\n \n+    use super::*;\n+\n     fn do_check(before: &str, afters: &[&str]) {\n         let (cursor, before) = extract_offset(before);\n-        let file = SourceFileNode::parse(&before);\n+        let file = SourceFile::parse(&before);\n         let mut range = TextRange::offset_len(cursor, 0.into());\n         for &after in afters {\n             range = extend_selection(file.syntax(), range).unwrap();"}, {"sha": "6f310688939b07fdcbb5d3016ec174709eddfde8", "filename": "crates/ra_editor/src/folding_ranges.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,9 +1,8 @@\n use rustc_hash::FxHashSet;\n \n use ra_syntax::{\n-    ast, AstNode, Direction, SourceFileNode,\n+    ast, AstNode, Direction, SourceFile, SyntaxNode, TextRange,\n     SyntaxKind::{self, *},\n-    SyntaxNodeRef, TextRange,\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -19,7 +18,7 @@ pub struct Fold {\n     pub kind: FoldKind,\n }\n \n-pub fn folding_ranges(file: &SourceFileNode) -> Vec<Fold> {\n+pub fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     let mut res = vec![];\n     let mut visited_comments = FxHashSet::default();\n     let mut visited_imports = FxHashSet::default();\n@@ -69,7 +68,7 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     }\n }\n \n-fn has_newline(node: SyntaxNodeRef) -> bool {\n+fn has_newline(node: &SyntaxNode) -> bool {\n     for descendant in node.descendants() {\n         if let Some(ws) = ast::Whitespace::cast(descendant) {\n             if ws.has_newlines() {\n@@ -86,8 +85,8 @@ fn has_newline(node: SyntaxNodeRef) -> bool {\n }\n \n fn contiguous_range_for_group<'a>(\n-    first: SyntaxNodeRef<'a>,\n-    visited: &mut FxHashSet<SyntaxNodeRef<'a>>,\n+    first: &'a SyntaxNode,\n+    visited: &mut FxHashSet<&'a SyntaxNode>,\n ) -> Option<TextRange> {\n     visited.insert(first);\n \n@@ -124,8 +123,8 @@ fn contiguous_range_for_group<'a>(\n }\n \n fn contiguous_range_for_comment<'a>(\n-    first: SyntaxNodeRef<'a>,\n-    visited: &mut FxHashSet<SyntaxNodeRef<'a>>,\n+    first: &'a SyntaxNode,\n+    visited: &mut FxHashSet<&'a SyntaxNode>,\n ) -> Option<TextRange> {\n     visited.insert(first);\n \n@@ -174,7 +173,7 @@ mod tests {\n \n     fn do_check(text: &str, fold_kinds: &[FoldKind]) {\n         let (ranges, text) = extract_ranges(text, \"fold\");\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let folds = folding_ranges(&file);\n \n         assert_eq!("}, {"sha": "6731260a31af358e1227651ab3c8e2d458cd8844", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -21,11 +21,10 @@ pub use self::{\n };\n use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n-    ast::{self, AstNode},\n-    SourceFileNode,\n+    SourceFile, SyntaxNode, TextRange, TextUnit, Direction,\n     SyntaxKind::{self, *},\n-    SyntaxNodeRef, TextRange, TextUnit, Direction,\n+    ast::{self, AstNode},\n+    algo::find_leaf_at_offset,\n };\n use rustc_hash::FxHashSet;\n \n@@ -49,7 +48,7 @@ pub struct Diagnostic {\n     pub fix: Option<LocalEdit>,\n }\n \n-pub fn matching_brace(file: &SourceFileNode, offset: TextUnit) -> Option<TextUnit> {\n+pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n     const BRACES: &[SyntaxKind] = &[\n         L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE,\n     ];\n@@ -67,7 +66,7 @@ pub fn matching_brace(file: &SourceFileNode, offset: TextUnit) -> Option<TextUni\n     Some(matching_node.range().start())\n }\n \n-pub fn highlight(root: SyntaxNodeRef) -> Vec<HighlightedRange> {\n+pub fn highlight(root: &SyntaxNode) -> Vec<HighlightedRange> {\n     // Visited nodes to handle highlighting priorities\n     let mut highlighted = FxHashSet::default();\n     let mut res = Vec::new();\n@@ -117,26 +116,25 @@ pub fn highlight(root: SyntaxNodeRef) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn syntax_tree(file: &SourceFileNode) -> String {\n+pub fn syntax_tree(file: &SourceFile) -> String {\n     ::ra_syntax::utils::dump_tree(file.syntax())\n }\n \n-pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n-    syntax: SyntaxNodeRef<'a>,\n-    offset: TextUnit,\n-) -> Option<N> {\n+pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<&N> {\n     find_leaf_at_offset(syntax, offset).find_map(|leaf| leaf.ancestors().find_map(N::cast))\n }\n \n #[cfg(test)]\n mod tests {\n+    use ra_syntax::AstNode;\n+\n     use crate::test_utils::{add_cursor, assert_eq_dbg, assert_eq_text, extract_offset};\n \n     use super::*;\n \n     #[test]\n     fn test_highlighting() {\n-        let file = SourceFileNode::parse(\n+        let file = SourceFile::parse(\n             r#\"\n // comment\n fn main() {}\n@@ -159,7 +157,7 @@ fn main() {}\n     fn test_matching_brace() {\n         fn do_check(before: &str, after: &str) {\n             let (pos, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let new_pos = match matching_brace(&file, pos) {\n                 None => pos,\n                 Some(pos) => pos,"}, {"sha": "8bd57555f513394c0cd73a44af893ff8e306e77b", "filename": "crates/ra_editor/src/structure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fstructure.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -3,7 +3,7 @@ use crate::TextRange;\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     ast::{self, NameOwner},\n-    AstNode, SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent,\n+    AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n };\n \n #[derive(Debug, Clone)]\n@@ -15,7 +15,7 @@ pub struct StructureNode {\n     pub kind: SyntaxKind,\n }\n \n-pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n+pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();\n \n@@ -38,8 +38,8 @@ pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n     res\n }\n \n-fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n+fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n+    fn decl<N: NameOwner>(node: &N) -> Option<StructureNode> {\n         let name = node.name()?;\n         Some(StructureNode {\n             parent: None,\n@@ -60,7 +60,7 @@ fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n         .visit(decl::<ast::TypeDef>)\n         .visit(decl::<ast::ConstDef>)\n         .visit(decl::<ast::StaticDef>)\n-        .visit(|im: ast::ImplBlock| {\n+        .visit(|im: &ast::ImplBlock| {\n             let target_type = im.target_type()?;\n             let target_trait = im.target_trait();\n             let label = match target_trait {\n@@ -91,7 +91,7 @@ mod tests {\n \n     #[test]\n     fn test_file_structure() {\n-        let file = SourceFileNode::parse(\n+        let file = SourceFile::parse(\n             r#\"\n struct Foo {\n     x: i32"}, {"sha": "bf40c92c07abb2e4001c94a7c7b4ba62531162c1", "filename": "crates/ra_editor/src/test_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,15 +1,15 @@\n-use ra_syntax::{SourceFileNode, TextRange, TextUnit};\n+use ra_syntax::{SourceFile, TextRange, TextUnit};\n \n use crate::LocalEdit;\n pub use test_utils::*;\n \n-pub fn check_action<F: Fn(&SourceFileNode, TextUnit) -> Option<LocalEdit>>(\n+pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,\n     f: F,\n ) {\n     let (before_cursor_pos, before) = extract_offset(before);\n-    let file = SourceFileNode::parse(&before);\n+    let file = SourceFile::parse(&before);\n     let result = f(&file, before_cursor_pos).expect(\"code action is not applicable\");\n     let actual = result.edit.apply(&before);\n     let actual_cursor_pos = match result.cursor_position {\n@@ -20,13 +20,13 @@ pub fn check_action<F: Fn(&SourceFileNode, TextUnit) -> Option<LocalEdit>>(\n     assert_eq_text!(after, &actual);\n }\n \n-pub fn check_action_range<F: Fn(&SourceFileNode, TextRange) -> Option<LocalEdit>>(\n+pub fn check_action_range<F: Fn(&SourceFile, TextRange) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,\n     f: F,\n ) {\n     let (range, before) = extract_range(before);\n-    let file = SourceFileNode::parse(&before);\n+    let file = SourceFile::parse(&before);\n     let result = f(&file, range).expect(\"code action is not applicable\");\n     let actual = result.edit.apply(&before);\n     let actual_cursor_pos = match result.cursor_position {"}, {"sha": "5b260d2ac7475bddafe2e5cfff62d76a1f9a0d55", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -5,15 +5,15 @@ use ra_syntax::{\n     algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n     ast,\n     text_utils::intersect,\n-    AstNode, Direction, SourceFileNode, SyntaxKind,\n+    AstNode, Direction, SourceFile, SyntaxKind,\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNode, TextRange, TextUnit,\n };\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n \n use crate::{find_node_at_offset, LocalEdit, TextEditBuilder};\n \n-pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n+pub fn join_lines(file: &SourceFile, range: TextRange) -> LocalEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();\n         let text = syntax.text().slice(range.start()..);\n@@ -59,7 +59,7 @@ pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n     }\n }\n \n-pub fn on_enter(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n+pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let comment = find_leaf_at_offset(file.syntax(), offset)\n         .left_biased()\n         .and_then(ast::Comment::cast)?;\n@@ -85,7 +85,7 @@ pub fn on_enter(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-fn node_indent<'a>(file: &'a SourceFileNode, node: SyntaxNodeRef) -> Option<&'a str> {\n+fn node_indent<'a>(file: &'a SourceFile, node: &SyntaxNode) -> Option<&'a str> {\n     let ws = match find_leaf_at_offset(file.syntax(), node.range().start()) {\n         LeafAtOffset::Between(l, r) => {\n             assert!(r == node);\n@@ -105,8 +105,8 @@ fn node_indent<'a>(file: &'a SourceFileNode, node: SyntaxNodeRef) -> Option<&'a\n     Some(&text[pos..])\n }\n \n-pub fn on_eq_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n-    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n+pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n+    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n@@ -136,7 +136,7 @@ pub fn on_eq_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit>\n     })\n }\n \n-pub fn on_dot_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n+pub fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let before_dot_offset = offset - TextUnit::of_char('.');\n \n     let whitespace = find_leaf_at_offset(file.syntax(), before_dot_offset).left_biased()?;\n@@ -151,7 +151,7 @@ pub fn on_dot_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit\n         .skip(1)\n         .next()?;\n \n-    ast::MethodCallExprNode::cast(method_call)?;\n+    ast::MethodCallExpr::cast(method_call)?;\n \n     // find how much the _method call is indented\n     let method_chain_indent = method_call\n@@ -188,7 +188,7 @@ fn last_line_indent_in_whitespace(ws: &str) -> &str {\n \n fn remove_newline(\n     edit: &mut TextEditBuilder,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n     node_text: &str,\n     offset: TextUnit,\n ) {\n@@ -266,7 +266,7 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     }\n }\n \n-fn join_single_expr_block(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Option<()> {\n+fn join_single_expr_block(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n     let block = ast::Block::cast(node.parent()?)?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n     let expr = single_expr(block)?;\n@@ -277,7 +277,7 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Op\n     Some(())\n }\n \n-fn single_expr(block: ast::Block) -> Option<ast::Expr> {\n+fn single_expr(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut res = None;\n     for child in block.syntax().children() {\n         if let Some(expr) = ast::Expr::cast(child) {\n@@ -297,7 +297,7 @@ fn single_expr(block: ast::Block) -> Option<ast::Expr> {\n     res\n }\n \n-fn join_single_use_tree(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Option<()> {\n+fn join_single_use_tree(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node.parent()?)?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n     edit.replace(\n@@ -307,7 +307,7 @@ fn join_single_use_tree(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Opti\n     Some(())\n }\n \n-fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n+fn compute_ws(left: &SyntaxNode, right: &SyntaxNode) -> &'static str {\n     match left.kind() {\n         L_PAREN | L_BRACK => return \"\",\n         L_CURLY => {\n@@ -547,7 +547,7 @@ fn foo() {\n \n     fn check_join_lines_sel(before: &str, after: &str) {\n         let (sel, before) = extract_range(before);\n-        let file = SourceFileNode::parse(&before);\n+        let file = SourceFile::parse(&before);\n         let result = join_lines(&file, sel);\n         let actual = result.edit.apply(&before);\n         assert_eq_text!(after, &actual);\n@@ -626,7 +626,7 @@ pub fn handle_find_matching_brace() {\n     fn test_on_eq_typed() {\n         fn do_check(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let result = on_eq_typed(&file, offset).unwrap();\n             let actual = result.edit.apply(&before);\n             assert_eq_text!(after, &actual);\n@@ -670,7 +670,7 @@ fn foo() {\n     fn test_on_dot_typed() {\n         fn do_check(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             if let Some(result) = on_eq_typed(&file, offset) {\n                 let actual = result.edit.apply(&before);\n                 assert_eq_text!(after, &actual);\n@@ -779,7 +779,7 @@ fn foo() {\n     fn test_on_enter() {\n         fn apply_on_enter(before: &str) -> Option<String> {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let result = on_enter(&file, offset)?;\n             let actual = result.edit.apply(&before);\n             let actual = add_cursor(&actual, result.cursor_position.unwrap());"}, {"sha": "b700be2673b2f640b66af95a05b56c129d1db537", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -42,7 +42,7 @@ pub struct StructData {\n }\n \n impl StructData {\n-    pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n+    pub(crate) fn new(struct_def: &ast::StructDef) -> StructData {\n         let name = struct_def.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(struct_def.flavor());\n         let variant_data = Arc::new(variant_data);\n@@ -87,7 +87,7 @@ pub struct EnumData {\n }\n \n impl EnumData {\n-    pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n+    pub(crate) fn new(enum_def: &ast::EnumDef) -> Self {\n         let name = enum_def.name().map(|n| n.as_name());\n         let variants = if let Some(evl) = enum_def.variant_list() {\n             evl.variants()"}, {"sha": "43cddb5044e95fa12839fe0830f3a403f090631c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,6 +1,6 @@\n use relative_path::RelativePathBuf;\n use ra_db::{CrateId, Cancelable, FileId};\n-use ra_syntax::{ast, SyntaxNode};\n+use ra_syntax::{ast, TreePtr, SyntaxNode};\n \n use crate::{Name, db::HirDatabase, DefId, Path, PerNs, nameres::ModuleScope};\n \n@@ -36,8 +36,8 @@ pub struct Module {\n }\n \n pub enum ModuleSource {\n-    SourceFile(ast::SourceFileNode),\n-    Module(ast::ModuleNode),\n+    SourceFile(TreePtr<ast::SourceFile>),\n+    Module(TreePtr<ast::Module>),\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n@@ -66,7 +66,7 @@ impl Module {\n     pub fn declaration_source(\n         &self,\n         db: &impl HirDatabase,\n-    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+    ) -> Cancelable<Option<(FileId, TreePtr<ast::Module>)>> {\n         self.declaration_source_impl(db)\n     }\n \n@@ -104,7 +104,10 @@ impl Module {\n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n         self.resolve_path_impl(db, path)\n     }\n-    pub fn problems(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+    pub fn problems(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Vec<(TreePtr<SyntaxNode>, Problem)>> {\n         self.problems_impl(db)\n     }\n }"}, {"sha": "0d22c9dbe591f0e919db9578a36d21ff5f6547a8", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,5 +1,5 @@\n use ra_db::{Cancelable, SourceRootId, FileId};\n-use ra_syntax::{ast, SyntaxNode, AstNode};\n+use ra_syntax::{ast, SyntaxNode, AstNode, TreePtr};\n \n use crate::{\n     Module, ModuleSource, Problem,\n@@ -43,20 +43,19 @@ impl Module {\n         let loc = self.def_id.loc(db);\n         let file_id = loc.source_item_id.file_id.as_original_file();\n         let syntax_node = db.file_item(loc.source_item_id);\n-        let syntax_node = syntax_node.borrowed();\n-        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n-            ModuleSource::SourceFile(source_file.owned())\n+        let module_source = if let Some(source_file) = ast::SourceFile::cast(&syntax_node) {\n+            ModuleSource::SourceFile(source_file.to_owned())\n         } else {\n-            let module = ast::Module::cast(syntax_node).unwrap();\n-            ModuleSource::Module(module.owned())\n+            let module = ast::Module::cast(&syntax_node).unwrap();\n+            ModuleSource::Module(module.to_owned())\n         };\n         Ok((file_id, module_source))\n     }\n \n     pub fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n-    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+    ) -> Cancelable<Option<(FileId, TreePtr<ast::Module>)>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         let link = ctry!(loc.module_id.parent_link(&module_tree));\n@@ -146,7 +145,10 @@ impl Module {\n         }\n         Ok(curr_per_ns)\n     }\n-    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+    pub fn problems_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Vec<(TreePtr<SyntaxNode>, Problem)>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         Ok(loc.module_id.problems(&module_tree, db))"}, {"sha": "03e65387d8ff2e03a0e26ebcd7aae75fa431bae1", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use ra_syntax::{SyntaxNode, SourceFileNode};\n+use ra_syntax::{SyntaxNode, TreePtr, SourceFile};\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n@@ -22,7 +22,7 @@ pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n     + AsRef<LocationIntener<MacroCallLoc, MacroCallId>>\n {\n-    fn hir_source_file(file_id: HirFileId) -> SourceFileNode {\n+    fn hir_source_file(file_id: HirFileId) -> TreePtr<SourceFile> {\n         type HirSourceFileQuery;\n         use fn HirFileId::hir_source_file;\n     }\n@@ -66,7 +66,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::file_items;\n     }\n \n-    fn file_item(source_item_id: SourceItemId) -> SyntaxNode {\n+    fn file_item(source_item_id: SourceItemId) -> TreePtr<SyntaxNode> {\n         type FileItemQuery;\n         use fn query_definitions::file_item;\n     }"}, {"sha": "4c54449ef1332133179f89d4dcf56e04d8240824", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -77,7 +77,7 @@ impl BodySyntaxMapping {\n     pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n         self.expr_syntax_mapping.get(&ptr).cloned()\n     }\n-    pub fn node_expr(&self, node: ast::Expr) -> Option<ExprId> {\n+    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_syntax_mapping\n             .get(&LocalSyntaxPtr::new(node.syntax()))\n             .cloned()\n@@ -88,7 +88,7 @@ impl BodySyntaxMapping {\n     pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n         self.pat_syntax_mapping.get(&ptr).cloned()\n     }\n-    pub fn node_pat(&self, node: ast::Pat) -> Option<PatId> {\n+    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_syntax_mapping\n             .get(&LocalSyntaxPtr::new(node.syntax()))\n             .cloned()\n@@ -373,10 +373,10 @@ impl ExprCollector {\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n         let syntax_ptr = LocalSyntaxPtr::new(expr.syntax());\n-        match expr {\n-            ast::Expr::IfExpr(e) => {\n+        match expr.kind() {\n+            ast::ExprKind::IfExpr(e) => {\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n                     // if let -- desugar to match\n                     let pat = self.collect_pat(pat);\n@@ -419,12 +419,12 @@ impl ExprCollector {\n                     )\n                 }\n             }\n-            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n-            ast::Expr::LoopExpr(e) => {\n+            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::ExprKind::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n-            ast::Expr::WhileExpr(e) => {\n+            ast::ExprKind::WhileExpr(e) => {\n                 let condition = if let Some(condition) = e.condition() {\n                     if condition.pat().is_none() {\n                         self.collect_expr_opt(condition.expr())\n@@ -438,7 +438,7 @@ impl ExprCollector {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n-            ast::Expr::ForExpr(e) => {\n+            ast::ExprKind::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -451,7 +451,7 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::CallExpr(e) => {\n+            ast::ExprKind::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -460,7 +460,7 @@ impl ExprCollector {\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n-            ast::Expr::MethodCallExpr(e) => {\n+            ast::ExprKind::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -480,7 +480,7 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::MatchExpr(e) => {\n+            ast::ExprKind::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n@@ -495,33 +495,33 @@ impl ExprCollector {\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n-            ast::Expr::PathExpr(e) => {\n+            ast::ExprKind::PathExpr(e) => {\n                 let path = e\n                     .path()\n                     .and_then(Path::from_ast)\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(_e) => {\n+            ast::ExprKind::ContinueExpr(_e) => {\n                 // TODO: labels\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n-            ast::Expr::BreakExpr(e) => {\n+            ast::ExprKind::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n-            ast::Expr::ParenExpr(e) => {\n+            ast::ExprKind::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 self.expr_syntax_mapping.insert(syntax_ptr, inner);\n                 inner\n             }\n-            ast::Expr::ReturnExpr(e) => {\n+            ast::ExprKind::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n-            ast::Expr::StructLit(e) => {\n+            ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let fields = if let Some(nfl) = e.named_field_list() {\n                     nfl.fields()\n@@ -558,34 +558,34 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::FieldExpr(e) => {\n+            ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = e\n                     .name_ref()\n                     .map(|nr| nr.as_name())\n                     .unwrap_or_else(Name::missing);\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n-            ast::Expr::TryExpr(e) => {\n+            ast::ExprKind::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n-            ast::Expr::CastExpr(e) => {\n+            ast::ExprKind::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n-            ast::Expr::RefExpr(e) => {\n+            ast::ExprKind::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n-            ast::Expr::PrefixExpr(e) => {\n+            ast::ExprKind::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let op = e.op();\n                 self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n             }\n-            ast::Expr::LambdaExpr(e) => {\n+            ast::ExprKind::LambdaExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -606,36 +606,36 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n-            ast::Expr::BinExpr(e) => {\n+            ast::ExprKind::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n \n             // TODO implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n+    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n-                ast::Stmt::LetStmt(stmt) => {\n+            .map(|s| match s.kind() {\n+                ast::StmtKind::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.type_ref().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n@@ -645,7 +645,9 @@ impl ExprCollector {\n                         initializer,\n                     }\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+                ast::StmtKind::ExprStmt(stmt) => {\n+                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n+                }\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -655,25 +657,25 @@ impl ExprCollector {\n         )\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n         if let Some(block) = block {\n             self.collect_block(block)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+    fn collect_pat(&mut self, pat: &ast::Pat) -> PatId {\n         let syntax_ptr = LocalSyntaxPtr::new(pat.syntax());\n-        match pat {\n-            ast::Pat::BindPat(bp) => {\n+        match pat.kind() {\n+            ast::PatKind::BindPat(bp) => {\n                 let name = bp\n                     .name()\n                     .map(|nr| nr.as_name())\n                     .unwrap_or_else(Name::missing);\n                 self.alloc_pat(Pat::Bind { name }, syntax_ptr)\n             }\n-            ast::Pat::TupleStructPat(p) => {\n+            ast::PatKind::TupleStructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 self.alloc_pat(Pat::TupleStruct { path, args }, syntax_ptr)\n@@ -685,7 +687,7 @@ impl ExprCollector {\n         }\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<&ast::Pat>) -> PatId {\n         if let Some(pat) = pat {\n             self.collect_pat(pat)\n         } else {\n@@ -710,7 +712,7 @@ impl ExprCollector {\n     }\n }\n \n-pub(crate) fn collect_fn_body_syntax(node: ast::FnDef) -> BodySyntaxMapping {\n+pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n     let mut collector = ExprCollector::new();\n \n     let args = if let Some(param_list) = node.param_list() {\n@@ -758,9 +760,7 @@ pub(crate) fn body_syntax_mapping(\n     let body_syntax_mapping = match def {\n         Def::Function(f) => {\n             let node = f.syntax(db);\n-            let node = node.borrowed();\n-\n-            collect_fn_body_syntax(node)\n+            collect_fn_body_syntax(&node)\n         }\n         // TODO: consts, etc.\n         _ => panic!(\"Trying to get body for item type without body\"),"}, {"sha": "81b790c5f954013c05f435b71f276b4d888e0145", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -7,7 +7,7 @@ use std::{\n \n use ra_db::Cancelable;\n use ra_syntax::{\n-    TextRange, TextUnit,\n+    TextRange, TextUnit, TreePtr,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n@@ -29,11 +29,11 @@ impl Function {\n         self.def_id\n     }\n \n-    pub fn syntax(&self, db: &impl HirDatabase) -> ast::FnDefNode {\n+    pub fn syntax(&self, db: &impl HirDatabase) -> TreePtr<ast::FnDef> {\n         let def_loc = self.def_id.loc(db);\n         assert!(def_loc.kind == DefKind::Function);\n         let syntax = db.file_item(def_loc.source_item_id);\n-        ast::FnDef::cast(syntax.borrowed()).unwrap().owned()\n+        ast::FnDef::cast(&syntax).unwrap().to_owned()\n     }\n \n     pub fn body(&self, db: &impl HirDatabase) -> Cancelable<Arc<Body>> {\n@@ -59,7 +59,7 @@ impl Function {\n \n     pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n         let syntax = self.syntax(db);\n-        FnSignatureInfo::new(syntax.borrowed())\n+        FnSignatureInfo::new(&syntax)\n     }\n \n     pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n@@ -99,8 +99,7 @@ impl FnSignature {\n \n pub(crate) fn fn_signature(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n     let func = Function::new(def_id);\n-    let syntax = func.syntax(db);\n-    let node = syntax.borrowed();\n+    let node = func.syntax(db);\n     let mut args = Vec::new();\n     if let Some(param_list) = node.param_list() {\n         if let Some(self_param) = param_list.self_param() {\n@@ -144,7 +143,7 @@ pub struct FnSignatureInfo {\n }\n \n impl FnSignatureInfo {\n-    fn new(node: ast::FnDef) -> Option<Self> {\n+    fn new(node: &ast::FnDef) -> Option<Self> {\n         let name = node.name()?.text().to_string();\n \n         let mut doc = None;\n@@ -207,7 +206,7 @@ impl FnSignatureInfo {\n         })\n     }\n \n-    fn extract_doc_comments(node: ast::FnDef) -> Option<(TextRange, String)> {\n+    fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n         if node.doc_comments().count() == 0 {\n             return None;\n         }\n@@ -227,7 +226,7 @@ impl FnSignatureInfo {\n         Some((range, comment_text))\n     }\n \n-    fn param_list(node: ast::FnDef) -> Vec<String> {\n+    fn param_list(node: &ast::FnDef) -> Vec<String> {\n         let mut res = vec![];\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {"}, {"sha": "699784f71fe361ad10b09cea5e935023c06c34f9", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SyntaxNodeRef, TextUnit, TextRange,\n+    AstNode, SyntaxNode, TextUnit, TextRange,\n     algo::generate,\n     ast,\n };\n@@ -127,7 +127,7 @@ impl ScopeEntryWithSyntax {\n }\n \n impl ScopesWithSyntaxMapping {\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n+    pub fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n             self.scopes.scopes[scope].parent\n         })\n@@ -178,7 +178,7 @@ impl ScopesWithSyntaxMapping {\n             .unwrap_or(original_scope)\n     }\n \n-    pub fn resolve_local_name(&self, name_ref: ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n+    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n         let mut shadowed = FxHashSet::default();\n         let name = name_ref.as_name();\n         let ret = self\n@@ -195,7 +195,7 @@ impl ScopesWithSyntaxMapping {\n         })\n     }\n \n-    pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n+    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n         let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n         fn_def\n@@ -213,7 +213,7 @@ impl ScopesWithSyntaxMapping {\n             .collect()\n     }\n \n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+    fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n         node.ancestors()\n             .map(LocalSyntaxPtr::new)\n             .filter_map(|ptr| self.syntax_mapping.syntax_expr(ptr))\n@@ -309,7 +309,7 @@ pub struct ReferenceDescriptor {\n #[cfg(test)]\n mod tests {\n     use ra_editor::find_node_at_offset;\n-    use ra_syntax::SourceFileNode;\n+    use ra_syntax::SourceFile;\n     use test_utils::{extract_offset, assert_eq_text};\n \n     use crate::expr;\n@@ -326,9 +326,9 @@ mod tests {\n             buf.push_str(&code[off..]);\n             buf\n         };\n-        let file = SourceFileNode::parse(&code);\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let file = SourceFile::parse(&code);\n+        let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let body_hir = expr::collect_fn_body_syntax(fn_def);\n         let scopes = FnScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n@@ -422,9 +422,9 @@ mod tests {\n \n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n-        let file = SourceFileNode::parse(&code);\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let file = SourceFile::parse(&code);\n+        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n         let body_hir = expr::collect_fn_body_syntax(fn_def);\n         let scopes = FnScopes::new(Arc::clone(body_hir.body()));"}, {"sha": "730a3e542bc8b2a866ad0d1985cd052f8b9b0e1a", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,5 +1,5 @@\n use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n-use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n+use ra_syntax::{TreePtr, SyntaxKind, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{HirDatabase, PerNs, ModuleId, Def, Function, Struct, Enum, ImplBlock, Crate};\n@@ -55,15 +55,18 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn hir_source_file(db: &impl HirDatabase, file_id: HirFileId) -> SourceFileNode {\n+    pub(crate) fn hir_source_file(\n+        db: &impl HirDatabase,\n+        file_id: HirFileId,\n+    ) -> TreePtr<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.source_file(file_id),\n             HirFileIdRepr::Macro(m) => {\n                 if let Some(exp) = db.expand_macro_invocation(m) {\n                     return exp.file();\n                 }\n                 // returning an empty string looks fishy...\n-                SourceFileNode::parse(\"\")\n+                SourceFile::parse(\"\")\n             }\n         }\n     }\n@@ -233,11 +236,11 @@ pub struct SourceItemId {\n #[derive(Debug, PartialEq, Eq)]\n pub struct SourceFileItems {\n     file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNode>,\n+    arena: Arena<SourceFileItemId, TreePtr<SyntaxNode>>,\n }\n \n impl SourceFileItems {\n-    pub(crate) fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n+    pub(crate) fn new(file_id: HirFileId, source_file: &SourceFile) -> SourceFileItems {\n         let mut res = SourceFileItems {\n             file_id,\n             arena: Arena::default(),\n@@ -246,29 +249,29 @@ impl SourceFileItems {\n         res\n     }\n \n-    fn init(&mut self, source_file: SourceFile) {\n+    fn init(&mut self, source_file: &SourceFile) {\n         source_file.syntax().descendants().for_each(|it| {\n             if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                self.alloc(module_item.syntax().owned());\n+                self.alloc(module_item.syntax().to_owned());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                self.alloc(macro_call.syntax().owned());\n+                self.alloc(macro_call.syntax().to_owned());\n             }\n         });\n     }\n \n-    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+    fn alloc(&mut self, item: TreePtr<SyntaxNode>) -> SourceFileItemId {\n         self.arena.alloc(item)\n     }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n         assert_eq!(\n             self.file_id, file_id,\n             \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n             self.file_id, file_id\n         );\n         self.id_of_unchecked(item)\n     }\n-    pub(crate) fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n+    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| *i == item) {\n             return id;\n         }\n         // This should not happen. Let's try to give a sensible diagnostics."}, {"sha": "bb0ad84e47e5bc526d3d979f418990cb9d80b6d5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -62,7 +62,7 @@ impl ImplData {\n         db: &impl AsRef<LocationIntener<DefLoc, DefId>>,\n         file_items: &SourceFileItems,\n         module: &Module,\n-        node: ast::ImplBlock,\n+        node: &ast::ImplBlock,\n     ) -> Self {\n         let target_trait = node.target_type().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n@@ -71,10 +71,10 @@ impl ImplData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| {\n-                    let kind = match item_node {\n-                        ast::ImplItem::FnDef(..) => DefKind::Function,\n-                        ast::ImplItem::ConstDef(..) => DefKind::Item,\n-                        ast::ImplItem::TypeDef(..) => DefKind::Item,\n+                    let kind = match item_node.kind() {\n+                        ast::ImplItemKind::FnDef(..) => DefKind::Function,\n+                        ast::ImplItemKind::ConstDef(..) => DefKind::Item,\n+                        ast::ImplItemKind::TypeDef(..) => DefKind::Item,\n                     };\n                     let item_id = file_items.id_of_unchecked(item_node.syntax());\n                     let source_item_id = SourceItemId {\n@@ -87,10 +87,10 @@ impl ImplData {\n                         ..module_loc\n                     };\n                     let def_id = def_loc.id(db);\n-                    match item_node {\n-                        ast::ImplItem::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n-                        ast::ImplItem::ConstDef(..) => ImplItem::Const(def_id),\n-                        ast::ImplItem::TypeDef(..) => ImplItem::Type(def_id),\n+                    match item_node.kind() {\n+                        ast::ImplItemKind::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n+                        ast::ImplItemKind::ConstDef(..) => ImplItem::Const(def_id),\n+                        ast::ImplItemKind::TypeDef(..) => ImplItem::Type(def_id),\n                     }\n                 })\n                 .collect()\n@@ -152,8 +152,8 @@ impl ModuleImplBlocks {\n     fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n         let (file_id, module_source) = module.defenition_source(db)?;\n         let node = match &module_source {\n-            ModuleSource::SourceFile(node) => node.borrowed().syntax(),\n-            ModuleSource::Module(node) => node.borrowed().syntax(),\n+            ModuleSource::SourceFile(node) => node.syntax(),\n+            ModuleSource::Module(node) => node.syntax(),\n         };\n \n         let source_file_items = db.file_items(file_id.into());"}, {"sha": "eb1c86091ef28c685b51ce3a7cf148450e50a8c9", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n \n use ra_db::LocalSyntaxPtr;\n use ra_syntax::{\n-    TextRange, TextUnit, SourceFileNode, AstNode, SyntaxNode,\n+    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreePtr,\n     ast::{self, NameOwner},\n };\n \n@@ -28,14 +28,14 @@ pub enum MacroDef {\n impl MacroDef {\n     /// Expands macro call, returning the expansion and offset to be used to\n     /// convert ranges between expansion and original source.\n-    pub fn ast_expand(macro_call: ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n+    pub fn ast_expand(macro_call: &ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n         let (def, input) = MacroDef::from_call(macro_call)?;\n         let exp = def.expand(input)?;\n         let off = macro_call.token_tree()?.syntax().range().start();\n         Some((off, exp))\n     }\n \n-    fn from_call(macro_call: ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n+    fn from_call(macro_call: &ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n         let def = {\n             let path = macro_call.path()?;\n             let name_ref = path.segment()?.name_ref()?;\n@@ -77,7 +77,7 @@ impl MacroDef {\n                 }}\",\n             input.text\n         );\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let match_expr = file.syntax().descendants().find_map(ast::MatchExpr::cast)?;\n         let match_arg = match_expr.expr()?;\n         let ptr = LocalSyntaxPtr::new(match_arg.syntax());\n@@ -92,7 +92,7 @@ impl MacroDef {\n     }\n     fn expand_vec(self, input: MacroInput) -> Option<MacroExpansion> {\n         let text = format!(r\"fn dummy() {{ {}; }}\", input.text);\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let array_expr = file.syntax().descendants().find_map(ast::ArrayExpr::cast)?;\n         let ptr = LocalSyntaxPtr::new(array_expr.syntax());\n         let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n@@ -116,7 +116,7 @@ impl MacroDef {\n         }\n         let src_range = TextRange::offset_len((pos as u32).into(), TextUnit::of_str(&trait_name));\n         let text = format!(r\"trait {} {{ }}\", trait_name);\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let trait_def = file.syntax().descendants().find_map(ast::TraitDef::cast)?;\n         let name = trait_def.name()?;\n         let ptr = LocalSyntaxPtr::new(trait_def.syntax());\n@@ -152,11 +152,11 @@ pub struct MacroExpansion {\n impl MacroExpansion {\n     // FIXME: does not really make sense, macro expansion is not neccessary a\n     // whole file. See `MacroExpansion::ptr` as well.\n-    pub(crate) fn file(&self) -> SourceFileNode {\n-        SourceFileNode::parse(&self.text)\n+    pub(crate) fn file(&self) -> TreePtr<SourceFile> {\n+        SourceFile::parse(&self.text)\n     }\n \n-    pub fn syntax(&self) -> SyntaxNode {\n+    pub fn syntax(&self) -> TreePtr<SyntaxNode> {\n         self.ptr.resolve(&self.file())\n     }\n     /// Maps range in the source code to the range in the expanded code.\n@@ -191,8 +191,7 @@ pub(crate) fn expand_macro_invocation(\n ) -> Option<Arc<MacroExpansion>> {\n     let loc = invoc.loc(db);\n     let syntax = db.file_item(loc.source_item_id);\n-    let syntax = syntax.borrowed();\n-    let macro_call = ast::MacroCall::cast(syntax).unwrap();\n+    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n \n     let (def, input) = MacroDef::from_call(macro_call)?;\n     def.expand(input).map(Arc::new)"}, {"sha": "91aab5c74ce59367115f9142f2e88063e7416d2c", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -5,9 +5,9 @@ use arrayvec::ArrayVec;\n use relative_path::RelativePathBuf;\n use ra_db::{FileId, SourceRootId, Cancelable, SourceRoot};\n use ra_syntax::{\n+    SyntaxNode, TreePtr,\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SyntaxNode,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n@@ -19,12 +19,11 @@ impl ModuleSource {\n         source_item_id: SourceItemId,\n     ) -> ModuleSource {\n         let module_syntax = db.file_item(source_item_id);\n-        let module_syntax = module_syntax.borrowed();\n-        if let Some(source_file) = ast::SourceFile::cast(module_syntax) {\n-            ModuleSource::SourceFile(source_file.owned())\n-        } else if let Some(module) = ast::Module::cast(module_syntax) {\n+        if let Some(source_file) = ast::SourceFile::cast(&module_syntax) {\n+            ModuleSource::SourceFile(source_file.to_owned())\n+        } else if let Some(module) = ast::Module::cast(&module_syntax) {\n             assert!(module.item_list().is_some(), \"expected inline module\");\n-            ModuleSource::Module(module.owned())\n+            ModuleSource::Module(module.to_owned())\n         } else {\n             panic!(\"expected file or inline module\")\n         }\n@@ -49,19 +48,18 @@ impl Submodule {\n         let module_source = ModuleSource::from_source_item_id(db, source);\n         let submodules = match module_source {\n             ModuleSource::SourceFile(source_file) => {\n-                collect_submodules(file_id, &file_items, source_file.borrowed())\n+                collect_submodules(file_id, &file_items, &*source_file)\n             }\n             ModuleSource::Module(module) => {\n-                let module = module.borrowed();\n                 collect_submodules(file_id, &file_items, module.item_list().unwrap())\n             }\n         };\n         return Ok(Arc::new(submodules));\n \n-        fn collect_submodules<'a>(\n+        fn collect_submodules(\n             file_id: HirFileId,\n             file_items: &SourceFileItems,\n-            root: impl ast::ModuleItemOwner<'a>,\n+            root: &impl ast::ModuleItemOwner,\n         ) -> Vec<Submodule> {\n             modules(root)\n                 .map(|(name, m)| Submodule {\n@@ -120,8 +118,8 @@ impl ModuleTree {\n         source_root: SourceRootId,\n     ) -> Cancelable<Arc<ModuleTree>> {\n         db.check_canceled()?;\n-        let res = create_module_tree(db, source_root)?;\n-        Ok(Arc::new(res))\n+        let res = create_module_tree(db, source_root);\n+        Ok(Arc::new(res?))\n     }\n \n     pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n@@ -172,14 +170,14 @@ impl ModuleId {\n         self,\n         tree: &ModuleTree,\n         db: &impl HirDatabase,\n-    ) -> Vec<(SyntaxNode, Problem)> {\n+    ) -> Vec<(TreePtr<SyntaxNode>, Problem)> {\n         tree.mods[self]\n             .children\n             .iter()\n             .filter_map(|&link| {\n                 let p = tree.links[link].problem.clone()?;\n                 let s = link.source(tree, db);\n-                let s = s.borrowed().name().unwrap().syntax().owned();\n+                let s = s.name().unwrap().syntax().to_owned();\n                 Some((s, p))\n             })\n             .collect()\n@@ -193,11 +191,9 @@ impl LinkId {\n     pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n         &tree.links[self].name\n     }\n-    pub(crate) fn source(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n+    pub(crate) fn source(self, tree: &ModuleTree, db: &impl HirDatabase) -> TreePtr<ast::Module> {\n         let syntax_node = db.file_item(tree.links[self].source);\n-        ast::ModuleNode::cast(syntax_node.borrowed())\n-            .unwrap()\n-            .owned()\n+        ast::Module::cast(&syntax_node).unwrap().to_owned()\n     }\n }\n \n@@ -213,12 +209,10 @@ impl ModuleTree {\n     }\n }\n \n-fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n+fn modules(root: &impl ast::ModuleItemOwner) -> impl Iterator<Item = (Name, &ast::Module)> {\n     root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n+        .filter_map(|item| match item.kind() {\n+            ast::ModuleItemKind::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {"}, {"sha": "dee1c9c5c518cc65c1a954d12d0608083713c44c", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -74,13 +74,13 @@ pub(crate) trait AsName {\n     fn as_name(&self) -> Name;\n }\n \n-impl AsName for ast::NameRef<'_> {\n+impl AsName for ast::NameRef {\n     fn as_name(&self) -> Name {\n         Name::new(self.text())\n     }\n }\n \n-impl AsName for ast::Name<'_> {\n+impl AsName for ast::Name {\n     fn as_name(&self) -> Name {\n         Name::new(self.text())\n     }"}, {"sha": "749fd604eb4d210f7aff959c9a4b9ded3e51b8fb", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -103,7 +103,7 @@ impl NamedImport {\n             item_id: Some(self.file_item_id),\n         };\n         let syntax = db.file_item(source_item_id);\n-        let offset = syntax.borrowed().range().start();\n+        let offset = syntax.range().start();\n         self.relative_range + offset\n     }\n }\n@@ -215,45 +215,45 @@ impl InputModuleItems {\n         &mut self,\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        item: ast::ModuleItem,\n+        item: &ast::ModuleItem,\n     ) -> Option<()> {\n-        match item {\n-            ast::ModuleItem::StructDef(it) => {\n+        match item.kind() {\n+            ast::ModuleItemKind::StructDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::EnumDef(it) => {\n+            ast::ModuleItemKind::EnumDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::FnDef(it) => {\n+            ast::ModuleItemKind::FnDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::TraitDef(it) => {\n+            ast::ModuleItemKind::TraitDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::TypeDef(it) => {\n+            ast::ModuleItemKind::TypeDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::ImplBlock(_) => {\n+            ast::ModuleItemKind::ImplBlock(_) => {\n                 // impls don't define items\n             }\n-            ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n-            ast::ModuleItem::ExternCrateItem(_) => {\n+            ast::ModuleItemKind::UseItem(it) => self.add_use_item(file_items, it),\n+            ast::ModuleItemKind::ExternCrateItem(_) => {\n                 // TODO\n             }\n-            ast::ModuleItem::ConstDef(it) => {\n+            ast::ModuleItemKind::ConstDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::StaticDef(it) => {\n+            ast::ModuleItemKind::StaticDef(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n-            ast::ModuleItem::Module(it) => {\n+            ast::ModuleItemKind::Module(it) => {\n                 self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n         }\n         Some(())\n     }\n \n-    fn add_use_item(&mut self, file_items: &SourceFileItems, item: ast::UseItem) {\n+    fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n         let file_item_id = file_items.id_of_unchecked(item.syntax());\n         let start_offset = item.syntax().range().start();\n         Path::expand_use_item(item, |path, range| {\n@@ -270,10 +270,10 @@ impl InputModuleItems {\n }\n \n impl ModuleItem {\n-    fn new<'a>(\n+    fn new(\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        item: impl ast::NameOwner<'a>,\n+        item: &impl ast::NameOwner,\n     ) -> Option<ModuleItem> {\n         let name = item.name()?.as_name();\n         let kind = item.syntax().kind();"}, {"sha": "6f0b0da97a6eadf9c98fd66ee9241fd1a6c9623d", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -18,14 +18,14 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+    pub fn expand_use_item(item: &ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: &ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -53,7 +53,7 @@ impl Path {\n         segments.reverse();\n         return Some(Path { kind, segments });\n \n-        fn qualifier(path: ast::Path) -> Option<ast::Path> {\n+        fn qualifier(path: &ast::Path) -> Option<&ast::Path> {\n             if let Some(q) = path.qualifier() {\n                 return Some(q);\n             }\n@@ -66,7 +66,7 @@ impl Path {\n     }\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n-    pub fn from_name_ref(name_ref: ast::NameRef) -> Path {\n+    pub fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n         name_ref.as_name().into()\n     }\n \n@@ -100,7 +100,7 @@ impl From<Name> for Path {\n \n fn expand_use_tree(\n     prefix: Option<Path>,\n-    tree: ast::UseTree,\n+    tree: &ast::UseTree,\n     cb: &mut impl FnMut(Path, Option<TextRange>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n@@ -146,7 +146,7 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n     let prefix = if let Some(qual) = path.qualifier() {\n         Some(convert_path(prefix, qual)?)\n     } else {"}, {"sha": "380ea5410452fab0b4dbf1d18dd32df56231e445", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n-    AstNode, SyntaxNode,\n+    AstNode, SyntaxNode, TreePtr,\n     ast::{self, ModuleItemOwner}\n };\n use ra_db::{SourceRootId, Cancelable,};\n@@ -31,30 +31,34 @@ pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ar\n     assert!(def_loc.kind == DefKind::Struct);\n     let syntax = db.file_item(def_loc.source_item_id);\n     let struct_def =\n-        ast::StructDef::cast(syntax.borrowed()).expect(\"struct def should point to StructDef node\");\n-    Ok(Arc::new(StructData::new(struct_def.borrowed())))\n+        ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n+    Ok(Arc::new(StructData::new(struct_def)))\n }\n \n pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<EnumData>> {\n     let def_loc = def_id.loc(db);\n     assert!(def_loc.kind == DefKind::Enum);\n     let syntax = db.file_item(def_loc.source_item_id);\n-    let enum_def =\n-        ast::EnumDef::cast(syntax.borrowed()).expect(\"enum def should point to EnumDef node\");\n-    Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n+    let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n+    Ok(Arc::new(EnumData::new(enum_def)))\n }\n \n pub(super) fn file_items(db: &impl HirDatabase, file_id: HirFileId) -> Arc<SourceFileItems> {\n     let source_file = db.hir_source_file(file_id);\n-    let source_file = source_file.borrowed();\n-    let res = SourceFileItems::new(file_id, source_file);\n+    let res = SourceFileItems::new(file_id, &source_file);\n     Arc::new(res)\n }\n \n-pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n+pub(super) fn file_item(\n+    db: &impl HirDatabase,\n+    source_item_id: SourceItemId,\n+) -> TreePtr<SyntaxNode> {\n     match source_item_id.item_id {\n-        Some(id) => db.file_items(source_item_id.file_id)[id].clone(),\n-        None => db.hir_source_file(source_item_id.file_id).syntax().owned(),\n+        Some(id) => db.file_items(source_item_id.file_id)[id].to_owned(),\n+        None => db\n+            .hir_source_file(source_item_id.file_id)\n+            .syntax()\n+            .to_owned(),\n     }\n }\n \n@@ -88,7 +92,7 @@ pub(super) fn input_module_items(\n                     let file_id = HirFileId::from(id);\n                     let file_items = db.file_items(file_id);\n                     //FIXME: expand recursively\n-                    for item in db.hir_source_file(file_id).borrowed().items() {\n+                    for item in db.hir_source_file(file_id).items() {\n                         acc.add_item(file_id, &file_items, item);\n                     }\n                 }\n@@ -98,9 +102,9 @@ pub(super) fn input_module_items(\n \n     let mut res = InputModuleItems::default();\n     match source {\n-        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.borrowed().items_with_macros()),\n+        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.items_with_macros()),\n         ModuleSource::Module(it) => {\n-            if let Some(item_list) = it.borrowed().item_list() {\n+            if let Some(item_list) = it.item_list() {\n                 fill(&mut res, &mut item_list.items_with_macros())\n             }\n         }"}, {"sha": "82675c0e44f302347553cc23c839e6e19bb39639", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -8,7 +8,7 @@\n use ra_db::{FileId, FilePosition, Cancelable};\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    SmolStr, TextRange, SyntaxNodeRef,\n+    SmolStr, TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner},\n };\n \n@@ -30,7 +30,7 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable\n pub fn module_from_declaration(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    decl: ast::Module,\n+    decl: &ast::Module,\n ) -> Cancelable<Option<Module>> {\n     let parent_module = module_from_file_id(db, file_id)?;\n     let child_name = decl.name();\n@@ -60,7 +60,7 @@ pub fn module_from_position(\n fn module_from_inline(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    module: ast::Module,\n+    module: &ast::Module,\n ) -> Cancelable<Option<Module>> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n@@ -77,7 +77,7 @@ fn module_from_inline(\n pub fn module_from_child_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    child: SyntaxNodeRef,\n+    child: &SyntaxNode,\n ) -> Cancelable<Option<Module>> {\n     if let Some(m) = child\n         .ancestors()\n@@ -112,7 +112,7 @@ pub fn function_from_position(\n pub fn function_from_source(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    fn_def: ast::FnDef,\n+    fn_def: &ast::FnDef,\n ) -> Cancelable<Option<Function>> {\n     let module = ctry!(module_from_child_node(db, file_id, fn_def.syntax())?);\n     let res = function_from_module(db, &module, fn_def);\n@@ -122,7 +122,7 @@ pub fn function_from_source(\n pub fn function_from_module(\n     db: &impl HirDatabase,\n     module: &Module,\n-    fn_def: ast::FnDef,\n+    fn_def: &ast::FnDef,\n ) -> Function {\n     let loc = module.def_id.loc(db);\n     let file_id = loc.source_item_id.file_id;\n@@ -144,7 +144,7 @@ pub fn function_from_module(\n pub fn function_from_child_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Cancelable<Option<Function>> {\n     let fn_def = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n     function_from_source(db, file_id, fn_def)\n@@ -170,8 +170,7 @@ pub fn macro_symbols(\n         if let Some(exp) = db.expand_macro_invocation(macro_call_id) {\n             let loc = macro_call_id.loc(db);\n             let syntax = db.file_item(loc.source_item_id);\n-            let syntax = syntax.borrowed();\n-            let macro_call = ast::MacroCall::cast(syntax).unwrap();\n+            let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n             let off = macro_call.token_tree().unwrap().syntax().range().start();\n             let file = exp.file();\n             for trait_def in file.syntax().descendants().filter_map(ast::TraitDef::cast) {"}, {"sha": "c9db4e0a58b11edcf48dde8e9b449201f1954547", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -56,9 +56,9 @@ pub enum TypeRef {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n-        use ra_syntax::ast::TypeRef::*;\n-        match node {\n+    pub(crate) fn from_ast(node: &ast::TypeRef) -> Self {\n+        use ra_syntax::ast::TypeRefKind::*;\n+        match node.kind() {\n             ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n             TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n             NeverType(..) => TypeRef::Never,\n@@ -100,7 +100,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(node: Option<&ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {"}, {"sha": "99f15354f87aef82b1f883f7a0baa552ac24dc87", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -11,7 +11,7 @@ use languageserver_types::{\n use ra_analysis::{\n     FileId, FilePosition, FileRange, FoldKind, Query, RunnableKind, Severity, SourceChange,\n };\n-use ra_syntax::{text_utils::intersect, TextUnit};\n+use ra_syntax::{text_utils::intersect, TextUnit, AstNode};\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n use rustc_hash::FxHashMap;\n use serde_json::to_value;"}, {"sha": "eea0e251a8b47e24e69cd2a57e3d5fbdb1f20715", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -13,7 +13,7 @@ unicode-xid = \"0.1.0\"\n itertools = \"0.8.0\"\n drop_bomb = \"0.1.4\"\n parking_lot = \"0.7.0\"\n-rowan = \"0.1.2\"\n+rowan = \"0.2.0\"\n text_unit = \"0.1.5\"\n ra_text_edit = { path = \"../ra_text_edit\" }\n "}, {"sha": "13f50d2ef80438a16b7f2d40750ceacf7e9da19f", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,19 +1,23 @@\n pub mod visit;\n \n-use crate::{SyntaxNode, SyntaxNodeRef, TextRange, TextUnit};\n+use rowan::TransparentNewType;\n+\n+use crate::{SyntaxNode, TextRange, TextUnit};\n \n pub use rowan::LeafAtOffset;\n \n-pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffset<SyntaxNodeRef> {\n+pub fn find_leaf_at_offset(node: &SyntaxNode, offset: TextUnit) -> LeafAtOffset<&SyntaxNode> {\n     match node.0.leaf_at_offset(offset) {\n         LeafAtOffset::None => LeafAtOffset::None,\n-        LeafAtOffset::Single(n) => LeafAtOffset::Single(SyntaxNode(n)),\n-        LeafAtOffset::Between(l, r) => LeafAtOffset::Between(SyntaxNode(l), SyntaxNode(r)),\n+        LeafAtOffset::Single(n) => LeafAtOffset::Single(SyntaxNode::from_repr(n)),\n+        LeafAtOffset::Between(l, r) => {\n+            LeafAtOffset::Between(SyntaxNode::from_repr(l), SyntaxNode::from_repr(r))\n+        }\n     }\n }\n \n-pub fn find_covering_node(root: SyntaxNodeRef, range: TextRange) -> SyntaxNodeRef {\n-    SyntaxNode(root.0.covering_node(range))\n+pub fn find_covering_node(root: &SyntaxNode, range: TextRange) -> &SyntaxNode {\n+    SyntaxNode::from_repr(root.0.covering_node(range))\n }\n \n pub fn generate<T>(seed: Option<T>, step: impl Fn(&T) -> Option<T>) -> impl Iterator<Item = T> {"}, {"sha": "38f21594cd46dad43c6d56b10aa5fbe17789eb8d", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,4 +1,4 @@\n-use crate::{AstNode, SyntaxNodeRef};\n+use crate::{AstNode, SyntaxNode};\n \n use std::marker::PhantomData;\n \n@@ -15,11 +15,11 @@ pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output = T, Ctx = C>\n \n pub trait Visitor<'a>: Sized {\n     type Output;\n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output>;\n+    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output>;\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n     where\n-        N: AstNode<'a>,\n-        F: FnOnce(N) -> Self::Output,\n+        N: AstNode + 'a,\n+        F: FnOnce(&'a N) -> Self::Output,\n     {\n         Vis {\n             inner: self,\n@@ -32,11 +32,11 @@ pub trait Visitor<'a>: Sized {\n pub trait VisitorCtx<'a>: Sized {\n     type Output;\n     type Ctx;\n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx>;\n+    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx>;\n     fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n     where\n-        N: AstNode<'a>,\n-        F: FnOnce(N, Self::Ctx) -> Self::Output,\n+        N: AstNode + 'a,\n+        F: FnOnce(&'a N, Self::Ctx) -> Self::Output,\n     {\n         VisCtx {\n             inner: self,\n@@ -54,7 +54,7 @@ struct EmptyVisitor<T> {\n impl<'a, T> Visitor<'a> for EmptyVisitor<T> {\n     type Output = T;\n \n-    fn accept(self, _node: SyntaxNodeRef<'a>) -> Option<T> {\n+    fn accept(self, _node: &'a SyntaxNode) -> Option<T> {\n         None\n     }\n }\n@@ -69,7 +69,7 @@ impl<'a, T, C> VisitorCtx<'a> for EmptyVisitorCtx<T, C> {\n     type Output = T;\n     type Ctx = C;\n \n-    fn accept(self, _node: SyntaxNodeRef<'a>) -> Result<T, C> {\n+    fn accept(self, _node: &'a SyntaxNode) -> Result<T, C> {\n         Err(self.ctx)\n     }\n }\n@@ -84,12 +84,12 @@ pub struct Vis<V, N, F> {\n impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n where\n     V: Visitor<'a>,\n-    N: AstNode<'a>,\n-    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n+    N: AstNode + 'a,\n+    F: FnOnce(&'a N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;\n \n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output> {\n+    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output> {\n         let Vis { inner, f, .. } = self;\n         inner.accept(node).or_else(|| N::cast(node).map(f))\n     }\n@@ -105,13 +105,13 @@ pub struct VisCtx<V, N, F> {\n impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n where\n     V: VisitorCtx<'a>,\n-    N: AstNode<'a>,\n-    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+    N: AstNode + 'a,\n+    F: FnOnce(&'a N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n {\n     type Output = <V as VisitorCtx<'a>>::Output;\n     type Ctx = <V as VisitorCtx<'a>>::Ctx;\n \n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx> {\n+    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx> {\n         let VisCtx { inner, f, .. } = self;\n         inner.accept(node).or_else(|ctx| match N::cast(node) {\n             None => Err(ctx),"}, {"sha": "0e303ee986346fb17f06ec212e651563f56b9953", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 103, "deletions": 107, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,119 +1,115 @@\n mod generated;\n \n use std::marker::PhantomData;\n-use std::string::String as RustString;\n \n use itertools::Itertools;\n \n pub use self::generated::*;\n use crate::{\n-    yellow::{RefRoot, SyntaxNodeChildren},\n+    yellow::{SyntaxNode, SyntaxNodeChildren, TreePtr, RaTypes},\n     SmolStr,\n     SyntaxKind::*,\n-    SyntaxNodeRef,\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode<'a>: Clone + Copy + 'a {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self>\n+pub trait AstNode: rowan::TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>> {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self>\n     where\n         Self: Sized;\n-    fn syntax(self) -> SyntaxNodeRef<'a>;\n+    fn syntax(&self) -> &SyntaxNode;\n+    fn to_owned(&self) -> TreePtr<Self>;\n }\n \n-pub trait NameOwner<'a>: AstNode<'a> {\n-    fn name(self) -> Option<Name<'a>> {\n+pub trait NameOwner: AstNode {\n+    fn name(&self) -> Option<&Name> {\n         child_opt(self)\n     }\n }\n \n-pub trait VisibilityOwner<'a>: AstNode<'a> {\n-    fn visibility(self) -> Option<Visibility<'a>> {\n+pub trait VisibilityOwner: AstNode {\n+    fn visibility(&self) -> Option<&Visibility> {\n         child_opt(self)\n     }\n }\n \n-pub trait LoopBodyOwner<'a>: AstNode<'a> {\n-    fn loop_body(self) -> Option<Block<'a>> {\n+pub trait LoopBodyOwner: AstNode {\n+    fn loop_body(&self) -> Option<&Block> {\n         child_opt(self)\n     }\n }\n \n-pub trait ArgListOwner<'a>: AstNode<'a> {\n-    fn arg_list(self) -> Option<ArgList<'a>> {\n+pub trait ArgListOwner: AstNode {\n+    fn arg_list(&self) -> Option<&ArgList> {\n         child_opt(self)\n     }\n }\n \n-pub trait FnDefOwner<'a>: AstNode<'a> {\n-    fn functions(self) -> AstChildren<'a, FnDef<'a>> {\n+pub trait FnDefOwner: AstNode {\n+    fn functions(&self) -> AstChildren<FnDef> {\n         children(self)\n     }\n }\n \n-// ModuleItem\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum ItemOrMacro<'a> {\n-    Item(ModuleItem<'a>),\n-    Macro(MacroCall<'a>),\n+    Item(&'a ModuleItem),\n+    Macro(&'a MacroCall),\n }\n \n-impl<'a> AstNode<'a> for ItemOrMacro<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n-        let res = if let Some(item) = ModuleItem::cast(syntax) {\n-            ItemOrMacro::Item(item)\n-        } else if let Some(macro_call) = MacroCall::cast(syntax) {\n-            ItemOrMacro::Macro(macro_call)\n-        } else {\n-            return None;\n-        };\n-        Some(res)\n+pub trait ModuleItemOwner: AstNode {\n+    fn items(&self) -> AstChildren<ModuleItem> {\n+        children(self)\n     }\n-    fn syntax(self) -> SyntaxNodeRef<'a> {\n-        match self {\n-            ItemOrMacro::Item(it) => it.syntax(),\n-            ItemOrMacro::Macro(it) => it.syntax(),\n-        }\n+    fn items_with_macros(&self) -> ItemOrMacroIter {\n+        ItemOrMacroIter(self.syntax().children())\n     }\n }\n \n-pub trait ModuleItemOwner<'a>: AstNode<'a> {\n-    fn items(self) -> AstChildren<'a, ModuleItem<'a>> {\n-        children(self)\n-    }\n+#[derive(Debug)]\n+pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n \n-    fn items_with_macros(self) -> AstChildren<'a, ItemOrMacro<'a>> {\n-        children(self)\n+impl<'a> Iterator for ItemOrMacroIter<'a> {\n+    type Item = ItemOrMacro<'a>;\n+    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+        loop {\n+            let n = self.0.next()?;\n+            if let Some(item) = ModuleItem::cast(n) {\n+                return Some(ItemOrMacro::Item(item));\n+            }\n+            if let Some(call) = MacroCall::cast(n) {\n+                return Some(ItemOrMacro::Macro(call));\n+            }\n+        }\n     }\n }\n \n-pub trait TypeParamsOwner<'a>: AstNode<'a> {\n-    fn type_param_list(self) -> Option<TypeParamList<'a>> {\n+pub trait TypeParamsOwner: AstNode {\n+    fn type_param_list(&self) -> Option<&TypeParamList> {\n         child_opt(self)\n     }\n \n-    fn where_clause(self) -> Option<WhereClause<'a>> {\n+    fn where_clause(&self) -> Option<&WhereClause> {\n         child_opt(self)\n     }\n }\n \n-pub trait AttrsOwner<'a>: AstNode<'a> {\n-    fn attrs(self) -> AstChildren<'a, Attr<'a>> {\n+pub trait AttrsOwner: AstNode {\n+    fn attrs(&self) -> AstChildren<Attr> {\n         children(self)\n     }\n }\n \n-pub trait DocCommentsOwner<'a>: AstNode<'a> {\n-    fn doc_comments(self) -> AstChildren<'a, Comment<'a>> {\n+pub trait DocCommentsOwner: AstNode {\n+    fn doc_comments(&self) -> AstChildren<Comment> {\n         children(self)\n     }\n \n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` and joins lines\n-    fn doc_comment_text(self) -> RustString {\n+    fn doc_comment_text(&self) -> std::string::String {\n         self.doc_comments()\n             .filter(|comment| comment.is_doc_comment())\n             .map(|comment| {\n@@ -130,13 +126,13 @@ pub trait DocCommentsOwner<'a>: AstNode<'a> {\n     }\n }\n \n-impl<'a> FnDef<'a> {\n+impl FnDef {\n     pub fn has_atom_attr(&self, atom: &str) -> bool {\n         self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n     }\n }\n \n-impl<'a> Attr<'a> {\n+impl Attr {\n     pub fn as_atom(&self) -> Option<SmolStr> {\n         let tt = self.value()?;\n         let (_bra, attr, _ket) = tt.syntax().children().collect_tuple()?;\n@@ -147,7 +143,7 @@ impl<'a> Attr<'a> {\n         }\n     }\n \n-    pub fn as_call(&self) -> Option<(SmolStr, TokenTree<'a>)> {\n+    pub fn as_call(&self) -> Option<(SmolStr, &TokenTree)> {\n         let tt = self.value()?;\n         let (_bra, attr, args, _ket) = tt.syntax().children().collect_tuple()?;\n         let args = TokenTree::cast(args)?;\n@@ -159,37 +155,37 @@ impl<'a> Attr<'a> {\n     }\n }\n \n-impl<'a> Lifetime<'a> {\n+impl Lifetime {\n     pub fn text(&self) -> SmolStr {\n         self.syntax().leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> Char<'a> {\n+impl Char {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> Byte<'a> {\n+impl Byte {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> ByteString<'a> {\n+impl ByteString {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> String<'a> {\n+impl String {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> Comment<'a> {\n+impl Comment {\n     pub fn text(&self) -> &SmolStr {\n         self.syntax().leaf_text().unwrap()\n     }\n@@ -251,7 +247,7 @@ impl CommentFlavor {\n     }\n }\n \n-impl<'a> Whitespace<'a> {\n+impl Whitespace {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n@@ -265,90 +261,90 @@ impl<'a> Whitespace<'a> {\n     }\n }\n \n-impl<'a> Name<'a> {\n+impl Name {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> NameRef<'a> {\n+impl NameRef {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> ImplBlock<'a> {\n-    pub fn target_type(self) -> Option<TypeRef<'a>> {\n+impl ImplBlock {\n+    pub fn target_type(&self) -> Option<&TypeRef> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(self) -> Option<TypeRef<'a>> {\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(self) -> (Option<TypeRef<'a>>, Option<TypeRef<'a>>) {\n+    fn target(&self) -> (Option<&TypeRef>, Option<&TypeRef>) {\n         let mut types = children(self);\n         let first = types.next();\n         let second = types.next();\n         (first, second)\n     }\n }\n \n-impl<'a> Module<'a> {\n-    pub fn has_semi(self) -> bool {\n+impl Module {\n+    pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child() {\n             None => false,\n             Some(node) => node.kind() == SEMI,\n         }\n     }\n }\n \n-impl<'a> LetStmt<'a> {\n-    pub fn has_semi(self) -> bool {\n+impl LetStmt {\n+    pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child() {\n             None => false,\n             Some(node) => node.kind() == SEMI,\n         }\n     }\n }\n \n-impl<'a> IfExpr<'a> {\n-    pub fn then_branch(self) -> Option<Block<'a>> {\n+impl IfExpr {\n+    pub fn then_branch(&self) -> Option<&Block> {\n         self.blocks().nth(0)\n     }\n-    pub fn else_branch(self) -> Option<Block<'a>> {\n+    pub fn else_branch(&self) -> Option<&Block> {\n         self.blocks().nth(1)\n     }\n-    fn blocks(self) -> AstChildren<'a, Block<'a>> {\n+    fn blocks(&self) -> AstChildren<Block> {\n         children(self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum PathSegmentKind<'a> {\n-    Name(NameRef<'a>),\n+    Name(&'a NameRef),\n     SelfKw,\n     SuperKw,\n     CrateKw,\n }\n \n-impl<'a> PathSegment<'a> {\n-    pub fn parent_path(self) -> Path<'a> {\n+impl PathSegment {\n+    pub fn parent_path(&self) -> &Path {\n         self.syntax()\n             .parent()\n             .and_then(Path::cast)\n             .expect(\"segments are always nested in paths\")\n     }\n \n-    pub fn kind(self) -> Option<PathSegmentKind<'a>> {\n+    pub fn kind(&self) -> Option<PathSegmentKind> {\n         let res = if let Some(name_ref) = self.name_ref() {\n             PathSegmentKind::Name(name_ref)\n         } else {\n@@ -363,53 +359,53 @@ impl<'a> PathSegment<'a> {\n     }\n }\n \n-impl<'a> Path<'a> {\n-    pub fn parent_path(self) -> Option<Path<'a>> {\n+impl Path {\n+    pub fn parent_path(&self) -> Option<&Path> {\n         self.syntax().parent().and_then(Path::cast)\n     }\n }\n \n-impl<'a> UseTree<'a> {\n-    pub fn has_star(self) -> bool {\n+impl UseTree {\n+    pub fn has_star(&self) -> bool {\n         self.syntax().children().any(|it| it.kind() == STAR)\n     }\n }\n \n-impl<'a> UseTreeList<'a> {\n-    pub fn parent_use_tree(self) -> UseTree<'a> {\n+impl UseTreeList {\n+    pub fn parent_use_tree(&self) -> &UseTree {\n         self.syntax()\n             .parent()\n             .and_then(UseTree::cast)\n             .expect(\"UseTreeLists are always nested in UseTrees\")\n     }\n }\n \n-fn child_opt<'a, P: AstNode<'a>, C: AstNode<'a>>(parent: P) -> Option<C> {\n+fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n     children(parent).next()\n }\n \n-fn children<'a, P: AstNode<'a>, C: AstNode<'a>>(parent: P) -> AstChildren<'a, C> {\n+fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n #[derive(Debug)]\n pub struct AstChildren<'a, N> {\n-    inner: SyntaxNodeChildren<RefRoot<'a>>,\n+    inner: SyntaxNodeChildren<'a>,\n     ph: PhantomData<N>,\n }\n \n impl<'a, N> AstChildren<'a, N> {\n-    fn new(parent: SyntaxNodeRef<'a>) -> Self {\n+    fn new(parent: &'a SyntaxNode) -> Self {\n         AstChildren {\n             inner: parent.children(),\n             ph: PhantomData,\n         }\n     }\n }\n \n-impl<'a, N: AstNode<'a>> Iterator for AstChildren<'a, N> {\n-    type Item = N;\n-    fn next(&mut self) -> Option<N> {\n+impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n+    type Item = &'a N;\n+    fn next(&mut self) -> Option<&'a N> {\n         loop {\n             if let Some(n) = N::cast(self.inner.next()?) {\n                 return Some(n);\n@@ -420,13 +416,13 @@ impl<'a, N: AstNode<'a>> Iterator for AstChildren<'a, N> {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StructFlavor<'a> {\n-    Tuple(PosFieldList<'a>),\n-    Named(NamedFieldDefList<'a>),\n+    Tuple(&'a PosFieldList),\n+    Named(&'a NamedFieldDefList),\n     Unit,\n }\n \n-impl<'a> StructFlavor<'a> {\n-    fn from_node<N: AstNode<'a>>(node: N) -> StructFlavor<'a> {\n+impl StructFlavor<'_> {\n+    fn from_node<N: AstNode>(node: &N) -> StructFlavor {\n         if let Some(nfdl) = child_opt::<_, NamedFieldDefList>(node) {\n             StructFlavor::Named(nfdl)\n         } else if let Some(pfl) = child_opt::<_, PosFieldList>(node) {\n@@ -437,31 +433,31 @@ impl<'a> StructFlavor<'a> {\n     }\n }\n \n-impl<'a> StructDef<'a> {\n-    pub fn flavor(self) -> StructFlavor<'a> {\n+impl StructDef {\n+    pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }\n }\n \n-impl<'a> EnumVariant<'a> {\n-    pub fn flavor(self) -> StructFlavor<'a> {\n+impl EnumVariant {\n+    pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }\n }\n \n-impl<'a> PointerType<'a> {\n+impl PointerType {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n }\n \n-impl<'a> ReferenceType<'a> {\n+impl ReferenceType {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n }\n \n-impl<'a> RefExpr<'a> {\n+impl RefExpr {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n@@ -477,7 +473,7 @@ pub enum PrefixOp {\n     Neg,\n }\n \n-impl<'a> PrefixExpr<'a> {\n+impl PrefixExpr {\n     pub fn op(&self) -> Option<PrefixOp> {\n         match self.syntax().first_child()?.kind() {\n             STAR => Some(PrefixOp::Deref),\n@@ -552,7 +548,7 @@ pub enum BinOp {\n     BitXorAssign,\n }\n \n-impl<'a> BinExpr<'a> {\n+impl BinExpr {\n     pub fn op(&self) -> Option<BinOp> {\n         self.syntax()\n             .children()\n@@ -592,15 +588,15 @@ impl<'a> BinExpr<'a> {\n             .next()\n     }\n \n-    pub fn lhs(self) -> Option<Expr<'a>> {\n+    pub fn lhs(&self) -> Option<&Expr> {\n         children(self).nth(0)\n     }\n \n-    pub fn rhs(self) -> Option<Expr<'a>> {\n+    pub fn rhs(&self) -> Option<&Expr> {\n         children(self).nth(1)\n     }\n \n-    pub fn sub_exprs(self) -> (Option<Expr<'a>>, Option<Expr<'a>>) {\n+    pub fn sub_exprs(&self) -> (Option<&Expr>, Option<&Expr>) {\n         let mut children = children(self);\n         let first = children.next();\n         let second = children.next();\n@@ -618,7 +614,7 @@ pub enum SelfParamFlavor {\n     MutRef,\n }\n \n-impl<'a> SelfParam<'a> {\n+impl SelfParam {\n     pub fn flavor(&self) -> SelfParamFlavor {\n         let borrowed = self.syntax().children().any(|n| n.kind() == AMP);\n         if borrowed {\n@@ -641,7 +637,7 @@ impl<'a> SelfParam<'a> {\n \n #[test]\n fn test_doc_comment_of_items() {\n-    let file = SourceFileNode::parse(\n+    let file = SourceFile::parse(\n         r#\"\n         //! doc\n         // non-doc"}, {"sha": "5e96ab1421ef0c0c8a89d39415b2736c0ca85de0", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1791, "deletions": 3052, "changes": 4843, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e"}, {"sha": "0a20fc78e74b4927656f802644e61a54a7acb734", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -11,89 +11,92 @@ the below applies to the result of this template\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n-use std::hash::{Hash, Hasher};\n+use rowan::TransparentNewType;\n \n use crate::{\n-    ast,\n-    SyntaxNode, SyntaxNodeRef, AstNode,\n-    yellow::{TreeRoot, RaTypes, OwnedRoot, RefRoot},\n-    SyntaxKind::*,\n+    SyntaxNode, SyntaxKind::*,\n+    yellow::{RaTypes, TreePtr},\n+    ast::{self, AstNode},\n };\n {% for node, methods in ast %}\n // {{ node }}\n \n {%- if methods.enum %}\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct {{ node }} {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for {{ node }} {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum {{ node }}<'a> {\n+pub enum {{ node }}Kind<'a> {\n {%- for kind in methods.enum %}\n-    {{ kind }}({{ kind }}<'a>),\n+    {{ kind }}(&'a {{ kind }}),\n {%- endfor %}\n }\n \n-impl<'a> AstNode<'a> for {{ node }}<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+impl AstNode for {{ node }} {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-{%- for kind in methods.enum %}\n-            {{ kind | SCREAM }} => Some({{ node }}::{{ kind }}({{ kind }} { syntax })),\n-{%- endfor %}\n+            {%- for kind in methods.enum %}\n+            | {{ kind | SCREAM }}\n+            {%- endfor %} => Some({{ node }}::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n-    fn syntax(self) -> SyntaxNodeRef<'a> {\n-        match self {\n-{%- for kind in methods.enum %}\n-            {{ node }}::{{ kind }}(inner) => inner.syntax(),\n-{%- endfor %}\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreePtr<{{ node }}> { TreePtr::cast(self.syntax.to_owned()) }\n+}\n+\n+impl {{ node }} {\n+    pub fn kind(&self) -> {{ node }}Kind {\n+        match self.syntax.kind() {\n+            {%- for kind in methods.enum %}\n+            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(&self.syntax).unwrap()),\n+            {%- endfor %}\n+            _ => unreachable!(),\n         }\n     }\n }\n {% else %}\n-#[derive(Debug, Clone, Copy,)]\n-pub struct {{ node }}Node<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    pub(crate) syntax: SyntaxNode<R>,\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct {{ node }} {\n+    pub(crate) syntax: SyntaxNode,\n }\n-pub type {{ node }}<'a> = {{ node }}Node<RefRoot<'a>>;\n-\n-impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<{{node}}Node<R1>> for {{node}}Node<R2> {\n-    fn eq(&self, other: &{{node}}Node<R1>) -> bool { self.syntax == other.syntax }\n-}\n-impl<R: TreeRoot<RaTypes>> Eq for {{node}}Node<R> {}\n-impl<R: TreeRoot<RaTypes>> Hash for {{node}}Node<R> {\n-    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+unsafe impl TransparentNewType for {{ node }} {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n }\n \n-impl<'a> AstNode<'a> for {{ node }}<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+impl AstNode for {{ node }} {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-            {{ node | SCREAM }} => Some({{ node }} { syntax }),\n+            {{ node | SCREAM }} => Some({{ node }}::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n-    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n-}\n-\n-impl<R: TreeRoot<RaTypes>> {{ node }}Node<R> {\n-    pub fn borrowed(&self) -> {{ node }} {\n-        {{ node }}Node { syntax: self.syntax.borrowed() }\n-    }\n-    pub fn owned(&self) -> {{ node }}Node {\n-        {{ node }}Node { syntax: self.syntax.owned() }\n-    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreePtr<{{ node }}> { TreePtr::cast(self.syntax.to_owned()) }\n }\n \n {% endif %}\n {% if methods.traits -%}\n+\n {%- for t in methods.traits -%}\n-impl<'a> ast::{{ t }}<'a> for {{ node }}<'a> {}\n+impl ast::{{ t }} for {{ node }} {}\n {% endfor -%}\n+\n {%- endif -%}\n \n-impl<'a> {{ node }}<'a> {\n+impl {{ node }} {\n {%- if methods.collections -%}\n {%- for m in methods.collections -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}(self) -> impl Iterator<Item = {{ ChildName }}<'a>> + 'a {\n+    pub fn {{ method_name }}(&self) -> impl Iterator<Item = &{{ ChildName }}> {\n         super::children(self)\n     }\n {% endfor -%}\n@@ -109,7 +112,7 @@ impl<'a> {{ node }}<'a> {\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n {%- endif %}\n-    pub fn {{ method_name }}(self) -> Option<{{ ChildName }}<'a>> {\n+    pub fn {{ method_name }}(&self) -> Option<&{{ ChildName }}> {\n         super::child_opt(self)\n     }\n {% endfor -%}"}, {"sha": "a75e641eada1ff0a2755aeae3271363ac46b2b5e", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -42,52 +42,42 @@ pub use crate::{\n     ast::AstNode,\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n-    yellow::{\n-        Direction, OwnedRoot, RefRoot, SyntaxError, SyntaxNode, SyntaxNodeRef, TreeRoot, WalkEvent, Location,\n-    },\n+    yellow::{Direction, SyntaxError, SyntaxNode, WalkEvent, Location, TreePtr},\n };\n \n use ra_text_edit::AtomTextEdit;\n use crate::yellow::GreenNode;\n \n-/// `SourceFileNode` represents a parse tree for a single Rust file.\n-pub use crate::ast::{SourceFile, SourceFileNode};\n+/// `SourceFile` represents a parse tree for a single Rust file.\n+pub use crate::ast::SourceFile;\n \n-impl SourceFileNode {\n-    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SourceFileNode {\n+impl SourceFile {\n+    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreePtr<SourceFile> {\n         let root = SyntaxNode::new(green, errors);\n         if cfg!(debug_assertions) {\n-            utils::validate_block_structure(root.borrowed());\n+            utils::validate_block_structure(&root);\n         }\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n-        ast::SourceFileNode { syntax: root }\n+        TreePtr::cast(root)\n     }\n-    pub fn parse(text: &str) -> SourceFileNode {\n+    pub fn parse(text: &str) -> TreePtr<SourceFile> {\n         let tokens = tokenize(&text);\n         let (green, errors) =\n             parser_impl::parse_with(yellow::GreenBuilder::new(), text, &tokens, grammar::root);\n-        SourceFileNode::new(green, errors)\n+        SourceFile::new(green, errors)\n     }\n-    pub fn reparse(&self, edit: &AtomTextEdit) -> SourceFileNode {\n+    pub fn reparse(&self, edit: &AtomTextEdit) -> TreePtr<SourceFile> {\n         self.incremental_reparse(edit)\n             .unwrap_or_else(|| self.full_reparse(edit))\n     }\n-    pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<SourceFileNode> {\n+    pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreePtr<SourceFile>> {\n         reparsing::incremental_reparse(self.syntax(), edit, self.errors())\n-            .map(|(green_node, errors)| SourceFileNode::new(green_node, errors))\n+            .map(|(green_node, errors)| SourceFile::new(green_node, errors))\n     }\n-    fn full_reparse(&self, edit: &AtomTextEdit) -> SourceFileNode {\n+    fn full_reparse(&self, edit: &AtomTextEdit) -> TreePtr<SourceFile> {\n         let text =\n             text_utils::replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n-        SourceFileNode::parse(&text)\n-    }\n-    /// Typed AST representation of the parse tree.\n-    pub fn ast(&self) -> ast::SourceFile {\n-        self.borrowed()\n-    }\n-    /// Untyped homogeneous representation of the parse tree.\n-    pub fn syntax(&self) -> SyntaxNodeRef {\n-        self.syntax.borrowed()\n+        SourceFile::parse(&text)\n     }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n         let mut errors = self.syntax.root_data().clone();"}, {"sha": "d5d72e1f8e5220f944a2f794304b74b93d3f2bfb", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -4,12 +4,12 @@ use crate::lexer::{tokenize, Token};\n use crate::parser_api::Parser;\n use crate::parser_impl;\n use crate::text_utils::replace_range;\n-use crate::yellow::{self, GreenNode, SyntaxError, SyntaxNodeRef};\n+use crate::yellow::{self, GreenNode, SyntaxError, SyntaxNode};\n use crate::{SyntaxKind::*, TextRange, TextUnit};\n use ra_text_edit::AtomTextEdit;\n \n pub(crate) fn incremental_reparse(\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n     edit: &AtomTextEdit,\n     errors: Vec<SyntaxError>,\n ) -> Option<(GreenNode, Vec<SyntaxError>)> {\n@@ -21,9 +21,9 @@ pub(crate) fn incremental_reparse(\n }\n \n fn reparse_leaf<'node>(\n-    node: SyntaxNodeRef<'node>,\n+    node: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n-) -> Option<(SyntaxNodeRef<'node>, GreenNode, Vec<SyntaxError>)> {\n+) -> Option<(&'node SyntaxNode, GreenNode, Vec<SyntaxError>)> {\n     let node = algo::find_covering_node(node, edit.delete);\n     match node.kind() {\n         WHITESPACE | COMMENT | IDENT | STRING | RAW_STRING => {\n@@ -47,9 +47,9 @@ fn reparse_leaf<'node>(\n }\n \n fn reparse_block<'node>(\n-    node: SyntaxNodeRef<'node>,\n+    node: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n-) -> Option<(SyntaxNodeRef<'node>, GreenNode, Vec<SyntaxError>)> {\n+) -> Option<(&'node SyntaxNode, GreenNode, Vec<SyntaxError>)> {\n     let (node, reparser) = find_reparsable_node(node, edit.delete)?;\n     let text = get_text_after_edit(node, &edit);\n     let tokens = tokenize(&text);\n@@ -61,7 +61,7 @@ fn reparse_block<'node>(\n     Some((node, green, new_errors))\n }\n \n-fn get_text_after_edit(node: SyntaxNodeRef, edit: &AtomTextEdit) -> String {\n+fn get_text_after_edit(node: &SyntaxNode, edit: &AtomTextEdit) -> String {\n     replace_range(\n         node.text().to_string(),\n         edit.delete - node.range().start(),\n@@ -77,17 +77,14 @@ fn is_contextual_kw(text: &str) -> bool {\n }\n \n type ParseFn = fn(&mut Parser);\n-fn find_reparsable_node(\n-    node: SyntaxNodeRef<'_>,\n-    range: TextRange,\n-) -> Option<(SyntaxNodeRef<'_>, ParseFn)> {\n+fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxNode, ParseFn)> {\n     let node = algo::find_covering_node(node, range);\n     return node\n         .ancestors()\n         .filter_map(|node| reparser(node).map(|r| (node, r)))\n         .next();\n \n-    fn reparser(node: SyntaxNodeRef) -> Option<ParseFn> {\n+    fn reparser(node: &SyntaxNode) -> Option<ParseFn> {\n         let res = match node.kind() {\n             BLOCK => grammar::block,\n             NAMED_FIELD_DEF_LIST => grammar::named_field_def_list,\n@@ -138,7 +135,7 @@ fn is_balanced(tokens: &[Token]) -> bool {\n fn merge_errors(\n     old_errors: Vec<SyntaxError>,\n     new_errors: Vec<SyntaxError>,\n-    old_node: SyntaxNodeRef,\n+    old_node: &SyntaxNode,\n     edit: &AtomTextEdit,\n ) -> Vec<SyntaxError> {\n     let mut res = Vec::new();\n@@ -159,22 +156,22 @@ fn merge_errors(\n mod tests {\n     use test_utils::{extract_range, assert_eq_text};\n \n-    use crate::{SourceFileNode, text_utils::replace_range, utils::dump_tree };\n+    use crate::{SourceFile, AstNode, text_utils::replace_range, utils::dump_tree};\n     use super::*;\n \n     fn do_check<F>(before: &str, replace_with: &str, reparser: F)\n     where\n         for<'a> F: Fn(\n-            SyntaxNodeRef<'a>,\n+            &'a SyntaxNode,\n             &AtomTextEdit,\n-        ) -> Option<(SyntaxNodeRef<'a>, GreenNode, Vec<SyntaxError>)>,\n+        ) -> Option<(&'a SyntaxNode, GreenNode, Vec<SyntaxError>)>,\n     {\n         let (range, before) = extract_range(before);\n         let after = replace_range(before.clone(), range, replace_with);\n \n-        let fully_reparsed = SourceFileNode::parse(&after);\n+        let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed = {\n-            let f = SourceFileNode::parse(&before);\n+            let f = SourceFile::parse(&before);\n             let edit = AtomTextEdit {\n                 delete: range,\n                 insert: replace_with.to_string(),\n@@ -183,7 +180,7 @@ mod tests {\n                 reparser(f.syntax(), &edit).expect(\"cannot incrementally reparse\");\n             let green_root = node.replace_with(green);\n             let errors = super::merge_errors(f.errors(), new_errors, node, &edit);\n-            SourceFileNode::new(green_root, errors)\n+            SourceFile::new(green_root, errors)\n         };\n \n         assert_eq_text!("}, {"sha": "2e1b42da0f6af6b90d2bb9543623b4733db34638", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,11 +1,11 @@\n-use crate::{SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent, AstNode};\n-use std::fmt::Write;\n-use std::str;\n+use std::{str, fmt::Write};\n+\n+use crate::{SourceFile, SyntaxKind, WalkEvent, AstNode, SyntaxNode};\n \n /// Parse a file and create a string representation of the resulting parse tree.\n-pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n-    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFileNode::cast) {\n-        Some(file) => file.owned().errors(),\n+pub fn dump_tree(syntax: &SyntaxNode) -> String {\n+    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFile::cast) {\n+        Some(file) => file.errors(),\n         None => syntax.root_data().to_vec(),\n     };\n     errors.sort_by_key(|e| e.offset());\n@@ -48,14 +48,13 @@ pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n }\n \n pub fn check_fuzz_invariants(text: &str) {\n-    let file = SourceFileNode::parse(text);\n+    let file = SourceFile::parse(text);\n     let root = file.syntax();\n     validate_block_structure(root);\n-    let _ = file.ast();\n     let _ = file.errors();\n }\n \n-pub(crate) fn validate_block_structure(root: SyntaxNodeRef) {\n+pub(crate) fn validate_block_structure(root: &SyntaxNode) {\n     let mut stack = Vec::new();\n     for node in root.descendants() {\n         match node.kind() {"}, {"sha": "73e1d20b9f86d09dc42045a74f49cd158949eb99", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -1,16 +1,15 @@\n-use crate::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast,\n-    SourceFileNode,\n-    yellow::SyntaxError,\n-};\n-\n mod byte;\n mod byte_string;\n mod char;\n mod string;\n \n-pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n+use crate::{\n+    SourceFile, yellow::SyntaxError, AstNode,\n+    ast,\n+    algo::visit::{visitor_ctx, VisitorCtx},\n+};\n+\n+pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)"}, {"sha": "4deb302a740c8ab235c5b85a8ed75d5b734c4ace", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     },\n };\n \n-pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_byte_node(node: &ast::Byte, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_byte_literal(literal_text);\n@@ -106,11 +106,11 @@ fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<Synt\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(\"const C: u8 = b'{}';\", literal);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_byte(literal: &str) {"}, {"sha": "670c43a09a39b58c2a5a0f99e81cd16a0f8e8293", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n use super::byte;\n \n-pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_byte_string_node(node: &ast::ByteString, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_byte_string_literal(literal_text);\n@@ -43,12 +43,12 @@ pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(r#\"const S: &'static [u8] = b\"{}\";\"#, literal);\n         println!(\"Source: {}\", src);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_str(literal: &str) {"}, {"sha": "9cbd43fba4166d719ec641a8e92b2c7b69261399", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     },\n };\n \n-pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_char_node(node: &ast::Char, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_char_literal(literal_text);\n@@ -175,11 +175,11 @@ fn validate_unicode_escape(text: &str, range: TextRange, errors: &mut Vec<Syntax\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(\"const C: char = '{}';\", literal);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_char(literal: &str) {"}, {"sha": "7b2a68d1208ce0ca8ffe4a2997b8438d82e20bab", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n use super::char;\n \n-pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_string_node(node: &ast::String, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_string_literal(literal_text);\n@@ -38,12 +38,12 @@ pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxErr\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(r#\"const S: &'static str = \"{}\";\"#, literal);\n         println!(\"Source: {}\", src);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_str(literal: &str) {"}, {"sha": "1bf1806b9cd5aca108f50b9ebb275983c624519d", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 92, "deletions": 56, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -4,15 +4,12 @@ mod syntax_text;\n \n use self::syntax_text::SyntaxText;\n use crate::{SmolStr, SyntaxKind, TextRange};\n-use rowan::Types;\n-use std::{\n-    fmt,\n-    hash::{Hash, Hasher},\n-};\n+use rowan::{Types, TransparentNewType};\n+use std::fmt;\n \n pub(crate) use self::builder::GreenBuilder;\n pub use self::syntax_error::{SyntaxError, SyntaxErrorKind, Location};\n-pub use rowan::{TreeRoot, WalkEvent};\n+pub use rowan::WalkEvent;\n \n #[derive(Debug, Clone, Copy)]\n pub enum RaTypes {}\n@@ -21,35 +18,76 @@ impl Types for RaTypes {\n     type RootData = Vec<SyntaxError>;\n }\n \n-pub type OwnedRoot = ::rowan::OwnedRoot<RaTypes>;\n-pub type RefRoot<'a> = ::rowan::RefRoot<'a, RaTypes>;\n+pub type GreenNode = rowan::GreenNode<RaTypes>;\n \n-pub type GreenNode = ::rowan::GreenNode<RaTypes>;\n+#[derive(PartialEq, Eq, Hash)]\n+pub struct TreePtr<T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>>(\n+    pub(crate) rowan::TreePtr<RaTypes, T>,\n+);\n \n-#[derive(Clone, Copy)]\n-pub struct SyntaxNode<R: TreeRoot<RaTypes> = OwnedRoot>(pub(crate) ::rowan::SyntaxNode<RaTypes, R>);\n-pub type SyntaxNodeRef<'a> = SyntaxNode<RefRoot<'a>>;\n+impl<T> TreePtr<T>\n+where\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+{\n+    pub(crate) fn cast<U>(this: TreePtr<T>) -> TreePtr<U>\n+    where\n+        U: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    {\n+        TreePtr(rowan::TreePtr::cast(this.0))\n+    }\n+}\n+\n+impl<T> std::ops::Deref for TreePtr<T>\n+where\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+{\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        self.0.deref()\n+    }\n+}\n+\n+impl<T> PartialEq<T> for TreePtr<T>\n+where\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: PartialEq<T>,\n+{\n+    fn eq(&self, other: &T) -> bool {\n+        let t: &T = self;\n+        t == other\n+    }\n+}\n \n-impl<R1, R2> PartialEq<SyntaxNode<R1>> for SyntaxNode<R2>\n+impl<T> Clone for TreePtr<T>\n where\n-    R1: TreeRoot<RaTypes>,\n-    R2: TreeRoot<RaTypes>,\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n {\n-    fn eq(&self, other: &SyntaxNode<R1>) -> bool {\n-        self.0 == other.0\n+    fn clone(&self) -> TreePtr<T> {\n+        TreePtr(self.0.clone())\n     }\n }\n \n-impl<R: TreeRoot<RaTypes>> Eq for SyntaxNode<R> {}\n-impl<R: TreeRoot<RaTypes>> Hash for SyntaxNode<R> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.0.hash(state)\n+impl<T> fmt::Debug for TreePtr<T>\n+where\n+    T: TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>>,\n+    T: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, fmt)\n     }\n }\n \n+#[derive(PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct SyntaxNode(pub(crate) rowan::SyntaxNode<RaTypes>);\n+unsafe impl TransparentNewType for SyntaxNode {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SyntaxNode {\n-        SyntaxNode(::rowan::SyntaxNode::new(green, errors))\n+    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreePtr<SyntaxNode> {\n+        let ptr = TreePtr(rowan::SyntaxNode::new(green, errors));\n+        TreePtr::cast(ptr)\n     }\n }\n \n@@ -59,45 +97,43 @@ pub enum Direction {\n     Prev,\n }\n \n-impl<'a> SyntaxNodeRef<'a> {\n-    pub fn leaf_text(self) -> Option<&'a SmolStr> {\n+impl SyntaxNode {\n+    pub fn leaf_text(&self) -> Option<&SmolStr> {\n         self.0.leaf_text()\n     }\n-    pub fn ancestors(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n         crate::algo::generate(Some(self), |&node| node.parent())\n     }\n-    pub fn descendants(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n         self.preorder().filter_map(|event| match event {\n             WalkEvent::Enter(node) => Some(node),\n             WalkEvent::Leave(_) => None,\n         })\n     }\n-    pub fn siblings(self, direction: Direction) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n         crate::algo::generate(Some(self), move |&node| match direction {\n             Direction::Next => node.next_sibling(),\n             Direction::Prev => node.prev_sibling(),\n         })\n     }\n-    pub fn preorder(self) -> impl Iterator<Item = WalkEvent<SyntaxNodeRef<'a>>> {\n+    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n         self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode(n)),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n         })\n     }\n }\n \n-impl<R: TreeRoot<RaTypes>> SyntaxNode<R> {\n+impl SyntaxNode {\n     pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n         self.0.root_data()\n     }\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n-        self.0.replace_with(replacement)\n-    }\n-    pub fn borrowed<'a>(&'a self) -> SyntaxNode<RefRoot<'a>> {\n-        SyntaxNode(self.0.borrowed())\n+        self.0.replace_self(replacement)\n     }\n-    pub fn owned(&self) -> SyntaxNode<OwnedRoot> {\n-        SyntaxNode(self.0.owned())\n+    pub fn to_owned(&self) -> TreePtr<SyntaxNode> {\n+        let ptr = TreePtr(self.0.to_owned());\n+        TreePtr::cast(ptr)\n     }\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind()\n@@ -106,32 +142,32 @@ impl<R: TreeRoot<RaTypes>> SyntaxNode<R> {\n         self.0.range()\n     }\n     pub fn text(&self) -> SyntaxText {\n-        SyntaxText::new(self.borrowed())\n+        SyntaxText::new(self)\n     }\n     pub fn is_leaf(&self) -> bool {\n         self.0.is_leaf()\n     }\n-    pub fn parent(&self) -> Option<SyntaxNode<R>> {\n-        self.0.parent().map(SyntaxNode)\n+    pub fn parent(&self) -> Option<&SyntaxNode> {\n+        self.0.parent().map(SyntaxNode::from_repr)\n     }\n-    pub fn first_child(&self) -> Option<SyntaxNode<R>> {\n-        self.0.first_child().map(SyntaxNode)\n+    pub fn first_child(&self) -> Option<&SyntaxNode> {\n+        self.0.first_child().map(SyntaxNode::from_repr)\n     }\n-    pub fn last_child(&self) -> Option<SyntaxNode<R>> {\n-        self.0.last_child().map(SyntaxNode)\n+    pub fn last_child(&self) -> Option<&SyntaxNode> {\n+        self.0.last_child().map(SyntaxNode::from_repr)\n     }\n-    pub fn next_sibling(&self) -> Option<SyntaxNode<R>> {\n-        self.0.next_sibling().map(SyntaxNode)\n+    pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n+        self.0.next_sibling().map(SyntaxNode::from_repr)\n     }\n-    pub fn prev_sibling(&self) -> Option<SyntaxNode<R>> {\n-        self.0.prev_sibling().map(SyntaxNode)\n+    pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n+        self.0.prev_sibling().map(SyntaxNode::from_repr)\n     }\n-    pub fn children(&self) -> SyntaxNodeChildren<R> {\n+    pub fn children(&self) -> SyntaxNodeChildren {\n         SyntaxNodeChildren(self.0.children())\n     }\n }\n \n-impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n+impl fmt::Debug for SyntaxNode {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n         if has_short_text(self.kind()) {\n@@ -142,13 +178,13 @@ impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n }\n \n #[derive(Debug)]\n-pub struct SyntaxNodeChildren<R: TreeRoot<RaTypes>>(::rowan::SyntaxNodeChildren<RaTypes, R>);\n+pub struct SyntaxNodeChildren<'a>(rowan::SyntaxNodeChildren<'a, RaTypes>);\n \n-impl<R: TreeRoot<RaTypes>> Iterator for SyntaxNodeChildren<R> {\n-    type Item = SyntaxNode<R>;\n+impl<'a> Iterator for SyntaxNodeChildren<'a> {\n+    type Item = &'a SyntaxNode;\n \n-    fn next(&mut self) -> Option<SyntaxNode<R>> {\n-        self.0.next().map(SyntaxNode)\n+    fn next(&mut self) -> Option<&'a SyntaxNode> {\n+        self.0.next().map(SyntaxNode::from_repr)\n     }\n }\n "}, {"sha": "31db0fdab38a495e2fdee6cdab3da55a4baac9af", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -3,17 +3,17 @@ use std::{fmt, ops};\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n use crate::{\n     text_utils::intersect,\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNode, TextRange, TextUnit,\n };\n \n #[derive(Clone)]\n pub struct SyntaxText<'a> {\n-    node: SyntaxNodeRef<'a>,\n+    node: &'a SyntaxNode,\n     range: TextRange,\n }\n \n impl<'a> SyntaxText<'a> {\n-    pub(crate) fn new(node: SyntaxNodeRef<'a>) -> SyntaxText<'a> {\n+    pub(crate) fn new(node: &'a SyntaxNode) -> SyntaxText<'a> {\n         SyntaxText {\n             node,\n             range: node.range(),"}, {"sha": "3243b27aec0a377458ec1f2cd2c1f84757af3527", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4be819125ce4a22edd86721fa56b5caba99c2e/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=3f4be819125ce4a22edd86721fa56b5caba99c2e", "patch": "@@ -9,8 +9,8 @@ use std::{\n \n use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n use ra_syntax::{\n+    SourceFile, AstNode,\n     utils::{check_fuzz_invariants, dump_tree},\n-    SourceFileNode,\n };\n \n #[test]\n@@ -27,7 +27,7 @@ fn parser_tests() {\n         &test_data_dir(),\n         &[\"parser/inline/ok\", \"parser/ok\"],\n         |text, path| {\n-            let file = SourceFileNode::parse(text);\n+            let file = SourceFile::parse(text);\n             let errors = file.errors();\n             assert_eq!(\n                 &*errors,\n@@ -42,7 +42,7 @@ fn parser_tests() {\n         &test_data_dir(),\n         &[\"parser/err\", \"parser/inline/err\"],\n         |text, path| {\n-            let file = SourceFileNode::parse(text);\n+            let file = SourceFile::parse(text);\n             let errors = file.errors();\n             assert_ne!(\n                 &*errors,\n@@ -85,7 +85,7 @@ fn self_hosting_parsing() {\n     {\n         count += 1;\n         let text = read_text(entry.path());\n-        let node = SourceFileNode::parse(&text);\n+        let node = SourceFile::parse(&text);\n         let errors = node.errors();\n         assert_eq!(\n             &*errors,"}]}