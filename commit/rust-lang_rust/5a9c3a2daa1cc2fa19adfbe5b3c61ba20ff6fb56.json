{"sha": "5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "node_id": "C_kwDOAAsO6NoAKDVhOWMzYTJkYWExY2MyZmExOWFkZmJlNWIzYzYxYmEyMGZmNmZiNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-07T13:17:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-07T13:17:54Z"}, "message": "Auto merge of #99983 - RalfJung:more-layout-checks, r=eddyb\n\nMore layout sanity checks\n\nr? `@eddyb`", "tree": {"sha": "ec3020f96b170c75c5dff4adf4473662ddfb0ecc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec3020f96b170c75c5dff4adf4473662ddfb0ecc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "html_url": "https://github.com/rust-lang/rust/commit/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5651759746e6eefa691f61522d19b46d07cf9244", "url": "https://api.github.com/repos/rust-lang/rust/commits/5651759746e6eefa691f61522d19b46d07cf9244", "html_url": "https://github.com/rust-lang/rust/commit/5651759746e6eefa691f61522d19b46d07cf9244"}, {"sha": "27013d23638adcc115c5c460e7c6d0abca9cc1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/27013d23638adcc115c5c460e7c6d0abca9cc1c9", "html_url": "https://github.com/rust-lang/rust/commit/27013d23638adcc115c5c460e7c6d0abca9cc1c9"}], "stats": {"total": 419, "additions": 309, "deletions": 110}, "files": [{"sha": "f5505590168d2927dd1fb8ffaa3b6830e2cb1e60", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 110, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "patch": "@@ -2,7 +2,10 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::normalize_erasing_regions::NormalizationError;\n use crate::ty::subst::Subst;\n-use crate::ty::{self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable};\n+use crate::ty::{\n+    self, layout_sanity_check::sanity_check_layout, subst::SubstsRef, EarlyBinder, ReprOptions, Ty,\n+    TyCtxt, TypeVisitable,\n+};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_hir as hir;\n@@ -221,114 +224,6 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-/// Enforce some basic invariants on layouts.\n-fn sanity_check_layout<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    layout: &TyAndLayout<'tcx>,\n-) {\n-    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-    if tcx.conservative_is_privately_uninhabited(param_env.and(layout.ty)) {\n-        assert!(layout.abi.is_uninhabited());\n-    }\n-\n-    if layout.size.bytes() % layout.align.abi.bytes() != 0 {\n-        bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n-    }\n-\n-    if cfg!(debug_assertions) {\n-        fn check_layout_abi<'tcx>(tcx: TyCtxt<'tcx>, layout: Layout<'tcx>) {\n-            match layout.abi() {\n-                Abi::Scalar(scalar) => {\n-                    // No padding in scalars.\n-                    assert_eq!(\n-                        layout.align().abi,\n-                        scalar.align(&tcx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    assert_eq!(\n-                        layout.size(),\n-                        scalar.size(&tcx),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.align().abi >= element.align(&tcx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(&tcx) * count;\n-                    assert_eq!(\n-                        layout.size(),\n-                        size.align_to(tcx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                }\n-                Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pairs. These are a bit more flexible and support\n-                    // padding, but we can at least ensure both fields actually fit into the layout\n-                    // and the alignment requirement has not been weakened.\n-                    let align1 = scalar1.align(&tcx).abi;\n-                    let align2 = scalar2.align(&tcx).abi;\n-                    assert!(\n-                        layout.align().abi >= cmp::max(align1, align2),\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                    );\n-                    let field2_offset = scalar1.size(&tcx).align_to(align2);\n-                    assert!(\n-                        layout.size() >= field2_offset + scalar2.size(&tcx),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                }\n-                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n-            }\n-        }\n-\n-        check_layout_abi(tcx, layout.layout);\n-\n-        if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants {\n-                check_layout_abi(tcx, *variant);\n-                // No nested \"multiple\".\n-                assert!(matches!(variant.variants(), Variants::Single { .. }));\n-                // Skip empty variants.\n-                if variant.size() == Size::ZERO\n-                    || variant.fields().count() == 0\n-                    || variant.abi().is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip them. (Note that\n-                    // sometimes, variants with fields have size 0, and sometimes, variants without\n-                    // fields have non-0 size.)\n-                    continue;\n-                }\n-                // Variants should have the same or a smaller size as the full thing.\n-                if variant.size() > layout.size {\n-                    bug!(\n-                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n-                        layout.size.bytes(),\n-                        variant.size().bytes(),\n-                    )\n-                }\n-                // The top-level ABI and the ABI of the variants should be coherent.\n-                let abi_coherent = match (layout.abi, variant.abi()) {\n-                    (Abi::Scalar(..), Abi::Scalar(..)) => true,\n-                    (Abi::ScalarPair(..), Abi::ScalarPair(..)) => true,\n-                    (Abi::Uninhabited, _) => true,\n-                    (Abi::Aggregate { .. }, _) => true,\n-                    _ => false,\n-                };\n-                if !abi_coherent {\n-                    bug!(\n-                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n-                        variant\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n #[instrument(skip(tcx, query), level = \"debug\")]\n fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -372,7 +267,7 @@ fn layout_of<'tcx>(\n \n             cx.record_layout_for_printing(layout);\n \n-            sanity_check_layout(tcx, param_env, &layout);\n+            sanity_check_layout(&cx, &layout);\n \n             Ok(layout)\n         })"}, {"sha": "87c85dcfff34af92bb1b0acb8b4124158be8ad7c", "filename": "compiler/rustc_middle/src/ty/layout_sanity_check.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs?ref=5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "patch": "@@ -0,0 +1,303 @@\n+use crate::ty::{\n+    layout::{LayoutCx, TyAndLayout},\n+    TyCtxt,\n+};\n+use rustc_target::abi::*;\n+\n+use std::cmp;\n+\n+/// Enforce some basic invariants on layouts.\n+pub(super) fn sanity_check_layout<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: &TyAndLayout<'tcx>,\n+) {\n+    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+    if cx.tcx.conservative_is_privately_uninhabited(cx.param_env.and(layout.ty)) {\n+        assert!(layout.abi.is_uninhabited());\n+    }\n+\n+    if layout.size.bytes() % layout.align.abi.bytes() != 0 {\n+        bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n+    }\n+\n+    if cfg!(debug_assertions) {\n+        /// Yields non-ZST fields of the type\n+        fn non_zst_fields<'tcx, 'a>(\n+            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &'a TyAndLayout<'tcx>,\n+        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+            (0..layout.layout.fields().count()).filter_map(|i| {\n+                let field = layout.field(cx, i);\n+                // Also checking `align == 1` here leads to test failures in\n+                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+                // alignment 4 that still gets ignored during layout computation (which is okay\n+                // since other fields already force alignment 4).\n+                let zst = field.is_zst();\n+                (!zst).then(|| (layout.fields.offset(i), field))\n+            })\n+        }\n+\n+        fn skip_newtypes<'tcx>(\n+            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &TyAndLayout<'tcx>,\n+        ) -> TyAndLayout<'tcx> {\n+            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+                // Definitely not a newtype of anything.\n+                return *layout;\n+            }\n+            let mut fields = non_zst_fields(cx, layout);\n+            let Some(first) = fields.next() else {\n+                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+                return *layout\n+            };\n+            if fields.next().is_none() {\n+                let (offset, first) = first;\n+                if offset == Size::ZERO && first.layout.size() == layout.size {\n+                    // This is a newtype, so keep recursing.\n+                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                    // alignment here, so we don't. Is that correct?\n+                    return skip_newtypes(cx, &first);\n+                }\n+            }\n+            // No more newtypes here.\n+            *layout\n+        }\n+\n+        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+            match layout.layout.abi() {\n+                Abi::Scalar(scalar) => {\n+                    // No padding in scalars.\n+                    let size = scalar.size(cx);\n+                    let align = scalar.align(cx).abi;\n+                    assert_eq!(\n+                        layout.layout.size(),\n+                        size,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    assert_eq!(\n+                        layout.layout.align().abi,\n+                        align,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    // Check that this matches the underlying field.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    match inner.layout.fields() {\n+                        FieldsShape::Primitive => {\n+                            // Fine.\n+                        }\n+                        FieldsShape::Union(..) => {\n+                            // FIXME: I guess we could also check something here? Like, look at all fields?\n+                            return;\n+                        }\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Should be an enum, the only field is the discriminant.\n+                            assert!(\n+                                inner.ty.is_enum(),\n+                                \"`Scalar` layout for non-primitive non-enum type {}\",\n+                                inner.ty\n+                            );\n+                            assert_eq!(\n+                                inner.layout.fields().count(),\n+                                1,\n+                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                            );\n+                            let offset = inner.layout.fields().offset(0);\n+                            let field = inner.field(cx, 0);\n+                            // The field should be at the right offset, and match the `scalar` layout.\n+                            assert_eq!(\n+                                offset,\n+                                Size::ZERO,\n+                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.size, size,\n+                                \"`Scalar` field with bad size in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.align.abi, align,\n+                                \"`Scalar` field with bad align in {inner:#?}\",\n+                            );\n+                            assert!(\n+                                matches!(field.abi, Abi::Scalar(_)),\n+                                \"`Scalar` field with bad ABI in {inner:#?}\",\n+                            );\n+                        }\n+                        _ => {\n+                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n+                        }\n+                    }\n+                }\n+                Abi::ScalarPair(scalar1, scalar2) => {\n+                    // Sanity-check scalar pairs. These are a bit more flexible and support\n+                    // padding, but we can at least ensure both fields actually fit into the layout\n+                    // and the alignment requirement has not been weakened.\n+                    let size1 = scalar1.size(cx);\n+                    let align1 = scalar1.align(cx).abi;\n+                    let size2 = scalar2.size(cx);\n+                    let align2 = scalar2.align(cx).abi;\n+                    assert!(\n+                        layout.layout.align().abi >= cmp::max(align1, align2),\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                    );\n+                    let field2_offset = size1.align_to(align2);\n+                    assert!(\n+                        layout.layout.size() >= field2_offset + size2,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    // Check that the underlying pair of fields matches.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                        // to check anything about them.\n+                        return;\n+                    }\n+                    match inner.layout.fields() {\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Checked below.\n+                        }\n+                        FieldsShape::Union(..) => {\n+                            // FIXME: I guess we could also check something here? Like, look at all fields?\n+                            return;\n+                        }\n+                        _ => {\n+                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                        }\n+                    }\n+                    let mut fields = non_zst_fields(cx, &inner);\n+                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n+                    });\n+                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n+                    });\n+                    assert!(\n+                        fields.next().is_none(),\n+                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                    );\n+                    // The fields might be in opposite order.\n+                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                        (offset1, field1, offset2, field2)\n+                    } else {\n+                        (offset2, field2, offset1, field1)\n+                    };\n+                    // The fields should be at the right offset, and match the `scalar` layout.\n+                    assert_eq!(\n+                        offset1,\n+                        Size::ZERO,\n+                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.size, size1,\n+                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.align.abi, align1,\n+                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field1.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        offset2, field2_offset,\n+                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.size, size2,\n+                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.align.abi, align2,\n+                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field2.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                    );\n+                }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n+                    assert!(\n+                        layout.layout.align().abi >= element.align(cx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(cx) * count;\n+                    assert_eq!(\n+                        layout.layout.size(),\n+                        size.align_to(cx.data_layout().vector_align(size).abi),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+            }\n+        }\n+\n+        check_layout_abi(cx, layout);\n+\n+        if let Variants::Multiple { variants, .. } = &layout.variants {\n+            for variant in variants.iter() {\n+                // No nested \"multiple\".\n+                assert!(matches!(variant.variants(), Variants::Single { .. }));\n+                // Variants should have the same or a smaller size as the full thing,\n+                // and same for alignment.\n+                if variant.size() > layout.size {\n+                    bug!(\n+                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                        layout.size.bytes(),\n+                        variant.size().bytes(),\n+                    )\n+                }\n+                if variant.align().abi > layout.align.abi {\n+                    bug!(\n+                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                        layout.align.abi.bytes(),\n+                        variant.align().abi.bytes(),\n+                    )\n+                }\n+                // Skip empty variants.\n+                if variant.size() == Size::ZERO\n+                    || variant.fields().count() == 0\n+                    || variant.abi().is_uninhabited()\n+                {\n+                    // These are never actually accessed anyway, so we can skip the coherence check\n+                    // for them. They also fail that check, since they have\n+                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                    // 0, and sometimes, variants without fields have non-0 size.)\n+                    continue;\n+                }\n+                // The top-level ABI and the ABI of the variants should be coherent.\n+                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n+                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n+                };\n+                let abi_coherent = match (layout.abi, variant.abi()) {\n+                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n+                    }\n+                    (Abi::Uninhabited, _) => true,\n+                    (Abi::Aggregate { .. }, _) => true,\n+                    _ => false,\n+                };\n+                if !abi_coherent {\n+                    bug!(\n+                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                        variant\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "79309097e785b2920d9c44f852b67c1bcdeb339b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5a9c3a2daa1cc2fa19adfbe5b3c61ba20ff6fb56", "patch": "@@ -124,6 +124,7 @@ mod erase_regions;\n mod generics;\n mod impls_ty;\n mod instance;\n+mod layout_sanity_check;\n mod list;\n mod parameterized;\n mod rvalue_scopes;"}]}